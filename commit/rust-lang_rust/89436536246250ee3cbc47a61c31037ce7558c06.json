{"sha": "89436536246250ee3cbc47a61c31037ce7558c06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NDM2NTM2MjQ2MjUwZWUzY2JjNDdhNjFjMzEwMzdjZTc1NThjMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-01T10:02:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-01T10:02:37Z"}, "message": "Auto merge of #23936 - pnkfelix:rollup, r=pnkfelix\n\nThis is an attempt to fix #23922", "tree": {"sha": "451f704eef5a5c33ef3aa36a04c498f855cb4fb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/451f704eef5a5c33ef3aa36a04c498f855cb4fb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89436536246250ee3cbc47a61c31037ce7558c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89436536246250ee3cbc47a61c31037ce7558c06", "html_url": "https://github.com/rust-lang/rust/commit/89436536246250ee3cbc47a61c31037ce7558c06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89436536246250ee3cbc47a61c31037ce7558c06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d754722a04b99fdcae0fd97fa2a4395521145ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d754722a04b99fdcae0fd97fa2a4395521145ef2", "html_url": "https://github.com/rust-lang/rust/commit/d754722a04b99fdcae0fd97fa2a4395521145ef2"}, {"sha": "2b71aed003997cc09b85c01306083187cb924a29", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b71aed003997cc09b85c01306083187cb924a29", "html_url": "https://github.com/rust-lang/rust/commit/2b71aed003997cc09b85c01306083187cb924a29"}], "stats": {"total": 9011, "additions": 3820, "deletions": 5191}, "files": [{"sha": "7fd09f9e1f5b0b9e0310b26d9efd76c346efc457", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -18,7 +18,6 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(path_ext)]\n-#![feature(convert)]\n #![feature(str_char)]\n \n #![deny(warnings)]"}, {"sha": "b3d5ad3b55d0ff8b3d5ce7739a431ff0f5a66742", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -977,17 +977,13 @@ An example of `use` declarations:\n \n ```\n # #![feature(core)]\n-use std::iter::range_step;\n use std::option::Option::{Some, None};\n use std::collections::hash_map::{self, HashMap};\n \n fn foo<T>(_: T){}\n fn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n \n fn main() {\n-    // Equivalent to 'std::iter::range_step(0, 10, 2);'\n-    range_step(0, 10, 2);\n-\n     // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n     // std::option::Option::None]);'\n     foo(vec![Some(1.0f64), None]);"}, {"sha": "136e155b1afe3e6f9f6d00f29b8b9718c12e585a", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -42,5 +42,6 @@\n     * [Intrinsics](intrinsics.md)\n     * [Lang items](lang-items.md)\n     * [Link args](link-args.md)\n+    * [Benchmark Tests](benchmark-tests.md)\n * [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "887965375932b3fe4953179a96d4dd54ec23c32e", "filename": "src/doc/trpl/benchmark-tests.md", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,152 @@\n+% Benchmark tests\n+\n+Rust supports benchmark tests, which can test the performance of your\n+code. Let's make our `src/lib.rs` look like this (comments elided):\n+\n+```{rust,ignore}\n+#![feature(test)]\n+\n+extern crate test;\n+\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test::Bencher;\n+\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(4, add_two(2));\n+    }\n+\n+    #[bench]\n+    fn bench_add_two(b: &mut Bencher) {\n+        b.iter(|| add_two(2));\n+    }\n+}\n+```\n+\n+Note the `test` feature gate, which enables this unstable feature.\n+\n+We've imported the `test` crate, which contains our benchmarking support.\n+We have a new function as well, with the `bench` attribute. Unlike regular\n+tests, which take no arguments, benchmark tests take a `&mut Bencher`. This\n+`Bencher` provides an `iter` method, which takes a closure. This closure\n+contains the code we'd like to benchmark.\n+\n+We can run benchmark tests with `cargo bench`:\n+\n+```bash\n+$ cargo bench\n+   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n+     Running target/release/adder-91b3e234d4ed382a\n+\n+running 2 tests\n+test tests::it_works ... ignored\n+test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)\n+\n+test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured\n+```\n+\n+Our non-benchmark test was ignored. You may have noticed that `cargo bench`\n+takes a bit longer than `cargo test`. This is because Rust runs our benchmark\n+a number of times, and then takes the average. Because we're doing so little\n+work in this example, we have a `1 ns/iter (+/- 0)`, but this would show\n+the variance if there was one.\n+\n+Advice on writing benchmarks:\n+\n+\n+* Move setup code outside the `iter` loop; only put the part you want to measure inside\n+* Make the code do \"the same thing\" on each iteration; do not accumulate or change state\n+* Make the outer function idempotent too; the benchmark runner is likely to run\n+  it many times\n+*  Make the inner `iter` loop short and fast so benchmark runs are fast and the\n+   calibrator can adjust the run-length at fine resolution\n+* Make the code in the `iter` loop do something simple, to assist in pinpointing\n+  performance improvements (or regressions)\n+\n+## Gotcha: optimizations\n+\n+There's another tricky part to writing benchmarks: benchmarks compiled with\n+optimizations activated can be dramatically changed by the optimizer so that\n+the benchmark is no longer benchmarking what one expects. For example, the\n+compiler might recognize that some calculation has no external effects and\n+remove it entirely.\n+\n+```{rust,ignore}\n+#![feature(test)]\n+\n+extern crate test;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_xor_1000_ints(b: &mut Bencher) {\n+    b.iter(|| {\n+        (0..1000).fold(0, |old, new| old ^ new);\n+    });\n+}\n+```\n+\n+gives the following results\n+\n+```text\n+running 1 test\n+test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n+```\n+\n+The benchmarking runner offers two ways to avoid this. Either, the closure that\n+the `iter` method receives can return an arbitrary value which forces the\n+optimizer to consider the result used and ensures it cannot remove the\n+computation entirely. This could be done for the example above by adjusting the\n+`b.iter` call to\n+\n+```rust\n+# struct X;\n+# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n+b.iter(|| {\n+    // note lack of `;` (could also use an explicit `return`).\n+    (0..1000).fold(0, |old, new| old ^ new)\n+});\n+```\n+\n+Or, the other option is to call the generic `test::black_box` function, which\n+is an opaque \"black box\" to the optimizer and so forces it to consider any\n+argument as used.\n+\n+```rust\n+#![feature(test)]\n+\n+extern crate test;\n+\n+# fn main() {\n+# struct X;\n+# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n+b.iter(|| {\n+    let n = test::black_box(1000);\n+\n+    (0..n).fold(0, |a, b| a ^ b)\n+})\n+# }\n+```\n+\n+Neither of these read or modify the value, and are very cheap for small values.\n+Larger values can be passed indirectly to reduce overhead (e.g.\n+`black_box(&huge_struct)`).\n+\n+Performing either of the above changes gives the following benchmarking results\n+\n+```text\n+running 1 test\n+test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n+```\n+\n+However, the optimizer can still modify a testcase in an undesirable manner\n+even when using either of the above."}, {"sha": "6b814a685424ef83220f8ce19f02d036bfe58b70", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -280,13 +280,15 @@ it returns an `Result<T, E>`, and because this is just an example, we `unwrap()`\n it to get a reference to the data. Real code would have more robust error handling\n here. We're then free to mutate it, since we have the lock.\n \n-This timer bit is a bit awkward, however. We have picked a reasonable amount of\n-time to wait, but it's entirely possible that we've picked too high, and that\n-we could be taking less time. It's also possible that we've picked too low,\n-and that we aren't actually finishing this computation.\n-\n-Rust's standard library provides a few more mechanisms for two threads to\n-synchronize with each other. Let's talk about one: channels.\n+Lastly, while the threads are running, we wait on a short timer. But\n+this is not ideal: we may have picked a reasonable amount of time to\n+wait but it's more likely we'll either be waiting longer than\n+necessary or not long enough, depending on just how much time the\n+threads actually take to finish computing when the program runs.\n+\n+A more precise alternative to the timer would be to use one of the\n+mechanisms provided by the Rust standard library for synchronizing\n+threads with each other. Let's talk about one of them: channels.\n \n ## Channels\n "}, {"sha": "55776bee3b585c91e8b0e7bc02b7ca8f5f43571c", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -243,11 +243,12 @@ for num in nums.iter() {\n ```\n \n These two basic iterators should serve you well. There are some more\n-advanced iterators, including ones that are infinite. Like `count`:\n+advanced iterators, including ones that are infinite. Like using range syntax\n+and `step_by`:\n \n ```rust\n-# #![feature(core)]\n-std::iter::count(1, 5);\n+# #![feature(step_by)]\n+(1..).step_by(5);\n ```\n \n This iterator counts up from one, adding five each time. It will give\n@@ -292,11 +293,11 @@ just use `for` instead.\n There are tons of interesting iterator adapters. `take(n)` will return an\n iterator over the next `n` elements of the original iterator, note that this\n has no side effect on the original iterator. Let's try it out with our infinite\n-iterator from before, `count()`:\n+iterator from before:\n \n ```rust\n-# #![feature(core)]\n-for i in std::iter::count(1, 5).take(5) {\n+# #![feature(step_by)]\n+for i in (1..).step_by(5).take(5) {\n     println!(\"{}\", i);\n }\n ```"}, {"sha": "7e19ec94ee745160e4fe01ecbcb47e056b43b81d", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -37,7 +37,7 @@ number of elements.\n \n ```rust\n let x: Vec<u32> = vec![1, 2, 3];\n-# assert_eq!(&[1,2,3], &x);\n+# assert_eq!(x, [1, 2, 3]);\n ```\n \n This can't be an ordinary function, because it takes any number of arguments.\n@@ -51,7 +51,7 @@ let x: Vec<u32> = {\n     temp_vec.push(3);\n     temp_vec\n };\n-# assert_eq!(&[1,2,3], &x);\n+# assert_eq!(x, [1, 2, 3]);\n ```\n \n We can implement this shorthand, using a macro: [^actual]\n@@ -73,7 +73,7 @@ macro_rules! vec {\n     };\n }\n # fn main() {\n-#     assert_eq!([1,2,3], vec![1,2,3]);\n+#     assert_eq!(vec![1,2,3], [1, 2, 3]);\n # }\n ```\n "}, {"sha": "223085cc40b8ee50d04258794276363069d4222c", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -477,7 +477,7 @@ forbidden in item signatures to allow reasoning about the types just based in\n the item signature alone. However, for ergonomic reasons a very restricted\n secondary inference algorithm called \u201clifetime elision\u201d applies in function\n signatures. It infers only based on the signature components themselves and not\n-based on the body of the function, only infers lifetime paramters, and does\n+based on the body of the function, only infers lifetime parameters, and does\n this with only three easily memorizable and unambiguous rules. This makes\n lifetime elision a shorthand for writing an item signature, while not hiding\n away the actual types involved as full local inference would if applied to it."}, {"sha": "fddb4c19031726f51f9dfe0930c40dbb4ff538fb", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -430,149 +430,3 @@ documentation tests: the `_0` is generated for the module test, and `add_two_0`\n for the function test. These will auto increment with names like `add_two_1` as\n you add more examples.\n \n-# Benchmark tests\n-\n-Rust also supports benchmark tests, which can test the performance of your\n-code. Let's make our `src/lib.rs` look like this (comments elided):\n-\n-```{rust,ignore}\n-extern crate test;\n-\n-pub fn add_two(a: i32) -> i32 {\n-    a + 2\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test::Bencher;\n-\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(4, add_two(2));\n-    }\n-\n-    #[bench]\n-    fn bench_add_two(b: &mut Bencher) {\n-        b.iter(|| add_two(2));\n-    }\n-}\n-```\n-\n-We've imported the `test` crate, which contains our benchmarking support.\n-We have a new function as well, with the `bench` attribute. Unlike regular\n-tests, which take no arguments, benchmark tests take a `&mut Bencher`. This\n-`Bencher` provides an `iter` method, which takes a closure. This closure\n-contains the code we'd like to benchmark.\n-\n-We can run benchmark tests with `cargo bench`:\n-\n-```bash\n-$ cargo bench\n-   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n-     Running target/release/adder-91b3e234d4ed382a\n-\n-running 2 tests\n-test tests::it_works ... ignored\n-test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)\n-\n-test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured\n-```\n-\n-Our non-benchmark test was ignored. You may have noticed that `cargo bench`\n-takes a bit longer than `cargo test`. This is because Rust runs our benchmark\n-a number of times, and then takes the average. Because we're doing so little\n-work in this example, we have a `1 ns/iter (+/- 0)`, but this would show\n-the variance if there was one.\n-\n-Advice on writing benchmarks:\n-\n-\n-* Move setup code outside the `iter` loop; only put the part you want to measure inside\n-* Make the code do \"the same thing\" on each iteration; do not accumulate or change state\n-* Make the outer function idempotent too; the benchmark runner is likely to run\n-  it many times\n-*  Make the inner `iter` loop short and fast so benchmark runs are fast and the\n-   calibrator can adjust the run-length at fine resolution\n-* Make the code in the `iter` loop do something simple, to assist in pinpointing\n-  performance improvements (or regressions)\n-\n-## Gotcha: optimizations\n-\n-There's another tricky part to writing benchmarks: benchmarks compiled with\n-optimizations activated can be dramatically changed by the optimizer so that\n-the benchmark is no longer benchmarking what one expects. For example, the\n-compiler might recognize that some calculation has no external effects and\n-remove it entirely.\n-\n-```{rust,ignore}\n-extern crate test;\n-use test::Bencher;\n-\n-#[bench]\n-fn bench_xor_1000_ints(b: &mut Bencher) {\n-    b.iter(|| {\n-        (0..1000).fold(0, |old, new| old ^ new);\n-    });\n-}\n-```\n-\n-gives the following results\n-\n-```text\n-running 1 test\n-test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-```\n-\n-The benchmarking runner offers two ways to avoid this. Either, the closure that\n-the `iter` method receives can return an arbitrary value which forces the\n-optimizer to consider the result used and ensures it cannot remove the\n-computation entirely. This could be done for the example above by adjusting the\n-`b.iter` call to\n-\n-```rust\n-# struct X;\n-# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n-b.iter(|| {\n-    // note lack of `;` (could also use an explicit `return`).\n-    (0..1000).fold(0, |old, new| old ^ new)\n-});\n-```\n-\n-Or, the other option is to call the generic `test::black_box` function, which\n-is an opaque \"black box\" to the optimizer and so forces it to consider any\n-argument as used.\n-\n-```rust\n-# #![feature(test)]\n-\n-extern crate test;\n-\n-# fn main() {\n-# struct X;\n-# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n-b.iter(|| {\n-    let n = test::black_box(1000);\n-\n-    (0..n).fold(0, |a, b| a ^ b)\n-})\n-# }\n-```\n-\n-Neither of these read or modify the value, and are very cheap for small values.\n-Larger values can be passed indirectly to reduce overhead (e.g.\n-`black_box(&huge_struct)`).\n-\n-Performing either of the above changes gives the following benchmarking results\n-\n-```text\n-running 1 test\n-test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-```\n-\n-However, the optimizer can still modify a testcase in an undesirable manner\n-even when using either of the above."}, {"sha": "341c90a70877e7cc485e6ac22b645e9e27c02367", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -277,6 +277,29 @@ One last thing about traits: generic functions with a trait bound use\n dispatched. What's that mean? Check out the chapter on [static and dynamic\n dispatch](static-and-dynamic-dispatch.html) for more.\n \n+## Multiple trait bounds\n+\n+You\u2019ve seen that you can bound a generic type parameter with a trait:\n+\n+```rust\n+fn foo<T: Clone>(x: T) {\n+    x.clone();\n+}\n+```\n+\n+If you need more than one bound, you can use `+`:\n+\n+```rust\n+use std::fmt::Debug;\n+\n+fn foo<T: Clone + Debug>(x: T) {\n+    x.clone();\n+    println!(\"{:?}\", x);\n+}\n+```\n+\n+`T` now needs to be both `Clone` as well as `Debug`.\n+\n ## Where clause\n \n Writing functions with only a few generic types and a small number of trait"}, {"sha": "855c86f08e7451acca9f0b042c4ed33653cf07a6", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -110,7 +110,7 @@ use heap::deallocate;\n ///         let child_numbers = shared_numbers.clone();\n ///\n ///         thread::spawn(move || {\n-///             let local_numbers = child_numbers.as_slice();\n+///             let local_numbers = &child_numbers[..];\n ///\n ///             // Work with the local numbers\n ///         });"}, {"sha": "550b25ac3a7cfa00e95ecee31063edf59cd8cf46", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -51,13 +51,15 @@ use core::prelude::*;\n use core::any::Any;\n use core::cmp::Ordering;\n use core::default::Default;\n-use core::error::{Error, FromError};\n+use core::error::Error;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::mem;\n use core::ops::{Deref, DerefMut};\n-use core::ptr::Unique;\n-use core::raw::TraitObject;\n+use core::ptr::{self, Unique};\n+use core::raw::{TraitObject, Slice};\n+\n+use heap;\n \n /// A value that represents the heap. This is the default place that the `box`\n /// keyword allocates into when no place is supplied.\n@@ -233,24 +235,10 @@ impl<T: ?Sized + Hash> Hash for Box<T> {\n     }\n }\n \n-/// Extension methods for an owning `Any` trait object.\n-#[unstable(feature = \"alloc\",\n-           reason = \"this trait will likely disappear once compiler bugs blocking \\\n-                     a direct impl on `Box<Any>` have been fixed \")]\n-// FIXME(#18737): this should be a direct impl on `Box<Any>`. If you're\n-//                removing this please make sure that you can downcase on\n-//                `Box<Any + Send>` as well as `Box<Any>`\n-pub trait BoxAny {\n-    /// Returns the boxed value if it is of type `T`, or\n-    /// `Err(Self)` if it isn't.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl BoxAny for Box<Any> {\n+impl Box<Any> {\n     #[inline]\n-    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -267,10 +255,10 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl BoxAny for Box<Any+Send> {\n+impl Box<Any+Send> {\n     #[inline]\n-    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         <Box<Any>>::downcast(self)\n     }\n }\n@@ -322,8 +310,48 @@ impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, E: Error + 'a> FromError<E> for Box<Error + 'a> {\n-    fn from_error(err: E) -> Box<Error + 'a> {\n+impl<'a, E: Error + 'a> From<E> for Box<Error + 'a> {\n+    fn from(err: E) -> Box<Error + 'a> {\n         Box::new(err)\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, E: Error + Send + 'a> From<E> for Box<Error + Send + 'a> {\n+    fn from(err: E) -> Box<Error + Send + 'a> {\n+        Box::new(err)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b> From<&'b str> for Box<Error + Send + 'a> {\n+    fn from(err: &'b str) -> Box<Error + Send + 'a> {\n+        #[derive(Debug)]\n+        struct StringError(Box<str>);\n+        impl Error for StringError {\n+            fn description(&self) -> &str { &self.0 }\n+        }\n+        impl fmt::Display for StringError {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                self.0.fmt(f)\n+            }\n+        }\n+\n+        // Unfortunately `String` is located in libcollections, so we construct\n+        // a `Box<str>` manually here.\n+        unsafe {\n+            let alloc = if err.len() == 0 {\n+                0 as *mut u8\n+            } else {\n+                let ptr = heap::allocate(err.len(), 1);\n+                if ptr.is_null() { ::oom(); }\n+                ptr as *mut u8\n+            };\n+            ptr::copy(err.as_bytes().as_ptr(), alloc, err.len());\n+            Box::new(StringError(mem::transmute(Slice {\n+                data: alloc,\n+                len: err.len(),\n+            })))\n+        }\n+    }\n+}"}, {"sha": "682d5f407c4eaeaf02f23666963cda07a0e63e69", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -17,7 +17,6 @@ use core::clone::Clone;\n \n use std::boxed;\n use std::boxed::Box;\n-use std::boxed::BoxAny;\n \n #[test]\n fn test_owned_clone() {"}, {"sha": "8874ac6eb872f020c1d55de74b835dd454d6cd73", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -38,7 +38,7 @@\n //! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n //!\n //! ```\n-//! # #![feature(collections, core)]\n+//! # #![feature(collections, core, step_by)]\n //! use std::collections::{BitSet, BitVec};\n //! use std::num::Float;\n //! use std::iter;\n@@ -60,7 +60,7 @@\n //!         if bv[i] {\n //!             // Mark all multiples of i as non-prime (any multiples below i * i\n //!             // will have been marked as non-prime previously)\n-//!             for j in iter::range_step(i * i, max_prime, i) { bv.set(j, false) }\n+//!             for j in (i * i..max_prime).step_by(i) { bv.set(j, false) }\n //!         }\n //!     }\n //!     BitSet::from_bit_vec(bv)\n@@ -1264,14 +1264,6 @@ impl BitSet {\n         BitSet { bit_vec: bit_vec }\n     }\n \n-    /// Deprecated: use `from_bit_vec`.\n-    #[inline]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_bit_vec\")]\n-    #[unstable(feature = \"collections\")]\n-    pub fn from_bitv(bit_vec: BitVec) -> BitSet {\n-        BitSet { bit_vec: bit_vec }\n-    }\n-\n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n     ///"}, {"sha": "2fe769b73f5cc00619e11b0d2f771eb3b05bd717", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 56, "deletions": 20, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -40,6 +40,24 @@ use self::Cow::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrow from an owned value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::borrow::Borrow;\n+    ///\n+    /// fn check<T: Borrow<str>>(s: T) {\n+    ///     assert_eq!(\"Hello\", s.borrow());\n+    /// }\n+    ///\n+    /// let s = \"Hello\".to_string();\n+    ///\n+    /// check(s);\n+    ///\n+    /// let s = \"Hello\";\n+    ///\n+    /// check(s);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn borrow(&self) -> &Borrowed;\n }\n@@ -50,6 +68,20 @@ pub trait Borrow<Borrowed: ?Sized> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n     /// Mutably borrow from an owned value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::borrow::BorrowMut;\n+    ///\n+    /// fn check<T: BorrowMut<[i32]>>(mut v: T) {\n+    ///     assert_eq!(&mut [1, 2, 3], v.borrow_mut());\n+    /// }\n+    ///\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    /// check(v);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn borrow_mut(&mut self) -> &mut Borrowed;\n }\n@@ -171,6 +203,18 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n     /// Acquire a mutable reference to the owned form of the data.\n     ///\n     /// Copies the data if it is not already owned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let mut cow: Cow<[_]> = Cow::Owned(vec![1, 2, 3]);\n+    ///\n+    /// let hello = cow.to_mut();\n+    ///\n+    /// assert_eq!(hello, &[1, 2, 3]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned {\n         match *self {\n@@ -185,33 +229,25 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n     /// Extract the owned data.\n     ///\n     /// Copies the data if it is not already owned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let cow: Cow<[_]> = Cow::Owned(vec![1, 2, 3]);\n+    ///\n+    /// let hello = cow.into_owned();\n+    ///\n+    /// assert_eq!(vec![1, 2, 3], hello);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_owned(self) -> <B as ToOwned>::Owned {\n         match self {\n             Borrowed(borrowed) => borrowed.to_owned(),\n             Owned(owned) => owned\n         }\n     }\n-\n-    /// Returns true if this `Cow` wraps a borrowed value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_borrowed(&self) -> bool {\n-        match *self {\n-            Borrowed(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps an owned value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            Owned(_) => true,\n-            _ => false,\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "adfb284dabea73562a31832c15a098fdfd84d849", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -1134,8 +1134,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n-               reason = \"matches entry v3 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n     pub fn or_insert(self, default: V) -> &'a mut V {\n@@ -1145,8 +1144,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n-               reason = \"matches entry v3 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {"}, {"sha": "7658611d809afd6ac23bdd666878c206dc1d3749", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -38,7 +38,6 @@\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(step_by)]\n #![feature(str_char)]\n-#![feature(convert)]\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n #![cfg_attr(test, feature(rand, rustc_private, test, hash, collections))]\n@@ -68,22 +67,6 @@ pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n-#[deprecated(since = \"1.0.0\", reason = \"renamed to vec_deque\")]\n-#[unstable(feature = \"collections\")]\n-pub use vec_deque as ring_buf;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to linked_list\")]\n-#[unstable(feature = \"collections\")]\n-pub use linked_list as dlist;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_vec\")]\n-#[unstable(feature = \"collections\")]\n-pub use bit_vec as bitv;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_set\")]\n-#[unstable(feature = \"collections\")]\n-pub use bit_set as bitv_set;\n-\n // Needed for the vec! macro\n pub use alloc::boxed;\n \n@@ -108,21 +91,13 @@ pub mod vec_map;\n            reason = \"RFC 509\")]\n pub mod bit_vec {\n     pub use bit::{BitVec, Iter};\n-\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitVec\")]\n-    #[unstable(feature = \"collections\")]\n-    pub use bit::BitVec as Bitv;\n }\n \n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub mod bit_set {\n     pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n-\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitSet\")]\n-    #[unstable(feature = \"collections\")]\n-    pub use bit::BitSet as BitvSet;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "dbdb79565736cd16a33a13390f5c67b9ef1f6d81", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -32,10 +32,6 @@ use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n \n-#[deprecated(since = \"1.0.0\", reason = \"renamed to LinkedList\")]\n-#[unstable(feature = \"collections\")]\n-pub use LinkedList as DList;\n-\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinkedList<T> {\n@@ -252,6 +248,7 @@ impl<T> LinkedList<T> {\n     /// }\n     /// println!(\"{}\", b.len()); // prints 0\n     /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, other: &mut LinkedList<T>) {\n         match self.list_tail.resolve() {\n             None => {\n@@ -844,7 +841,7 @@ impl<A> ExactSizeIterator for IntoIter<A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for LinkedList<A> {\n     fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> LinkedList<A> {\n-        let mut ret = DList::new();\n+        let mut ret = LinkedList::new();\n         ret.extend(iter);\n         ret\n     }\n@@ -1079,7 +1076,7 @@ mod test {\n         thread::spawn(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<_>>());\n+            assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n         }).join().ok().unwrap();\n     }\n "}, {"sha": "4599aff000df5f48e98fa41f08126faad183620b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -89,8 +89,6 @@ use core::iter::MultiplicativeIterator;\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n-#[cfg(stage0)]\n-use core::num::wrapping::WrappingOps;\n use core::ops::FnMut;\n use core::option::Option::{self, Some, None};\n use core::ptr;\n@@ -107,7 +105,6 @@ pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n-pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -281,33 +278,6 @@ impl<T> [T] {\n         cmp::min(self.len(), end-start)\n     }\n \n-    /// Deprecated: use `&s[start .. end]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n-    #[inline]\n-    pub fn slice(&self, start: usize, end: usize) -> &[T] {\n-        &self[start .. end]\n-    }\n-\n-    /// Deprecated: use `&s[start..]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n-    #[inline]\n-    pub fn slice_from(&self, start: usize) -> &[T] {\n-        &self[start ..]\n-    }\n-\n-    /// Deprecated: use `&s[..end]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n-    #[inline]\n-    pub fn slice_to(&self, end: usize) -> &[T] {\n-        &self[.. end]\n-    }\n-\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -557,7 +527,6 @@ impl<T> [T] {\n     /// ```rust\n     /// # #![feature(core)]\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n     ///\n     /// let seek = 13;\n     /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n@@ -611,42 +580,6 @@ impl<T> [T] {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n \n-    /// Deprecated: use `&mut s[..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-    #[allow(deprecated)]\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::as_mut_slice(self)\n-    }\n-\n-    /// Deprecated: use `&mut s[start .. end]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n-    #[inline]\n-    pub fn slice_mut(&mut self, start: usize, end: usize) -> &mut [T] {\n-        &mut self[start .. end]\n-    }\n-\n-    /// Deprecated: use `&mut s[start ..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n-    #[inline]\n-    pub fn slice_from_mut(&mut self, start: usize) -> &mut [T] {\n-        &mut self[start ..]\n-    }\n-\n-    /// Deprecated: use `&mut s[.. end]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n-    #[inline]\n-    pub fn slice_to_mut(&mut self, end: usize) -> &mut [T] {\n-        &mut self[.. end]\n-    }\n-\n     /// Returns an iterator that allows modifying each value\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -924,7 +857,6 @@ impl<T> [T] {\n     /// ```rust\n     /// # #![feature(core)]\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n     ///\n     /// assert_eq!(s.binary_search(&13),  Ok(9));\n     /// assert_eq!(s.binary_search(&4),   Err(7));\n@@ -937,13 +869,6 @@ impl<T> [T] {\n         core_slice::SliceExt::binary_search(self, x)\n     }\n \n-    /// Deprecated: use `binary_search` instead.\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n-    pub fn binary_search_elem(&self, x: &T) -> Result<usize, usize> where T: Ord {\n-        self.binary_search(x)\n-    }\n-\n     /// Mutates the slice to the next lexicographic permutation.\n     ///\n     /// Returns `true` if successful and `false` if the slice is at the"}, {"sha": "f8f2909291f3e0402fd70fb5e49972459657e06b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 11, "deletions": 93, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,13 +10,12 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-//! Unicode string manipulation (the [`str`](../primitive.str.html) type).\n+//! Unicode string manipulation (the `str` type).\n //!\n-//! Rust's [`str`](../primitive.str.html) type is one of the core primitive\n-//! types of the language. `&str` is the borrowed string type. This type of\n-//! string can only be created from other strings, unless it is a `&'static str`\n-//! (see below). It is not possible to move out of borrowed strings because they\n-//! are owned elsewhere.\n+//! Rust's `str` type is one of the core primitive types of the language. `&str`\n+//! is the borrowed string type. This type of string can only be created from\n+//! other strings, unless it is a `&'static str` (see below). It is not possible\n+//! to move out of borrowed strings because they are owned elsewhere.\n //!\n //! # Examples\n //!\n@@ -70,11 +69,11 @@ use vec::Vec;\n use slice::SliceConcatExt;\n \n pub use core::str::{FromStr, Utf8Error, Str};\n-pub use core::str::{Lines, LinesAny, MatchIndices, SplitStr, CharRange};\n+pub use core::str::{Lines, LinesAny, MatchIndices, CharRange};\n pub use core::str::{Split, SplitTerminator, SplitN};\n pub use core::str::{RSplit, RSplitN};\n-pub use core::str::{from_utf8, CharEq, Chars, CharIndices, Bytes};\n-pub use core::str::{from_utf8_unchecked, from_c_str, ParseBoolError};\n+pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n+pub use core::str::{from_utf8_unchecked, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n pub use core::str::Pattern;\n pub use core::str::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n@@ -536,22 +535,6 @@ impl str {\n         core_str::StrExt::contains(&self[..], pat)\n     }\n \n-    /// Returns `true` if `self` contains a `char`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// assert!(\"hello\".contains_char('e'));\n-    ///\n-    /// assert!(!\"hello\".contains_char('z'));\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `contains()` with a char\")]\n-    pub fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(&self[..], pat)\n-    }\n-\n     /// An iterator over the codepoints of `self`.\n     ///\n     /// # Examples\n@@ -778,25 +761,6 @@ impl str {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n-    /// An iterator over the substrings of `self` separated by a `&str`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, [\"1\", \"\", \"2\"]);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n-    #[allow(deprecated) /* for SplitStr */]\n-    pub fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n-        core_str::StrExt::split_str(&self[..], pat)\n-    }\n-\n     /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n     /// This does not include the empty string after a trailing `\\n`.\n@@ -848,31 +812,6 @@ impl str {\n     pub fn lines_any(&self) -> LinesAny {\n         core_str::StrExt::lines_any(&self[..])\n     }\n-\n-    /// Deprecated: use `s[a .. b]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n-    pub fn slice(&self, begin: usize, end: usize) -> &str {\n-        &self[begin..end]\n-    }\n-\n-    /// Deprecated: use `s[a..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n-    pub fn slice_from(&self, begin: usize) -> &str {\n-        &self[begin..]\n-    }\n-\n-    /// Deprecated: use `s[..a]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n-    pub fn slice_to(&self, end: usize) -> &str {\n-        &self[..end]\n-    }\n-\n     /// Returns a slice of the string from the character range [`begin`..`end`).\n     ///\n     /// That is, start at the `begin`-th code point of the string and continue\n@@ -1306,27 +1245,6 @@ impl str {\n         core_str::StrExt::rfind(&self[..], pat)\n     }\n \n-    /// Returns the byte index of the first matching substring if it exists.\n-    ///\n-    /// Returns `None` if it doesn't exist.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n-    /// assert_eq!(s.find_str(\"muffin man\"), None);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `find()` with a `&str`\")]\n-    pub fn find_str<'a, P: Pattern<'a>>(&'a self, needle: P) -> Option<usize> {\n-        core_str::StrExt::find_str(&self[..], needle)\n-    }\n-\n     /// Retrieves the first character from a `&str` and returns it.\n     ///\n     /// This does not allocate a new string; instead, it returns a slice that points one character\n@@ -1470,12 +1388,12 @@ impl str {\n     /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n     ///\n-    /// assert_eq!(gr1.as_slice(), b);\n+    /// assert_eq!(&gr1[..], b);\n     ///\n     /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n     ///\n-    /// assert_eq!(gr2.as_slice(), b);\n+    /// assert_eq!(&gr2[..], b);\n     /// ```\n     #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n@@ -1493,7 +1411,7 @@ impl str {\n     /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n     /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     ///\n-    /// assert_eq!(gr_inds.as_slice(), b);\n+    /// assert_eq!(&gr_inds[..], b);\n     /// ```\n     #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]"}, {"sha": "d8d7ad9887a8ce92ccf5be1a693fc1bd26a91387", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -93,7 +93,7 @@ impl String {\n     /// ```\n     /// # #![feature(collections, core)]\n     /// let s = String::from_str(\"hello\");\n-    /// assert_eq!(s.as_slice(), \"hello\");\n+    /// assert_eq!(&s[..], \"hello\");\n     /// ```\n     #[inline]\n     #[unstable(feature = \"collections\",\n@@ -364,6 +364,14 @@ impl String {\n         self.vec\n     }\n \n+    /// Extract a string slice containing the entire string.\n+    #[inline]\n+    #[unstable(feature = \"convert\",\n+               reason = \"waiting on RFC revision\")]\n+    pub fn as_str(&self) -> &str {\n+        self\n+    }\n+\n     /// Pushes the given string onto this string buffer.\n     ///\n     /// # Examples\n@@ -848,7 +856,6 @@ impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n #[allow(deprecated)]\n impl Str for String {\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice(&self) -> &str {\n         unsafe { mem::transmute(&*self.vec) }\n     }\n@@ -1072,11 +1079,6 @@ impl<'a> Str for Cow<'a, str> {\n     }\n }\n \n-/// A clone-on-write string\n-#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, str> instead\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type CowString<'a> = Cow<'a, str>;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "087b065031f2badba5d3314a147db426e9af508d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -389,7 +389,7 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n-    #[unstable(feature = \"collections\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n@@ -425,11 +425,18 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Extract a slice containing the entire vector.\n+    #[inline]\n+    #[unstable(feature = \"convert\",\n+               reason = \"waiting on RFC revision\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self\n+    }\n+\n     /// Deprecated: use `&mut s[..]` instead.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n+    #[unstable(feature = \"convert\",\n+               reason = \"waiting on RFC revision\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         &mut self[..]\n     }\n@@ -823,13 +830,13 @@ impl<T> Vec<T> {\n     /// # #![feature(collections, core)]\n     /// let v = vec![0, 1, 2];\n     /// let w = v.map_in_place(|i| i + 3);\n-    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n+    /// assert_eq!(&w[..], &[3, 4, 5]);\n     ///\n     /// #[derive(PartialEq, Debug)]\n     /// struct Newtype(u8);\n     /// let bytes = vec![0x11, 0x22];\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n-    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n+    /// assert_eq!(&newtyped_bytes[..], &[Newtype(0x11), Newtype(0x22)]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"API may change to provide stronger guarantees\")]\n@@ -1533,22 +1540,22 @@ impl<T> Extend<T> for Vec<T> {\n }\n \n __impl_slice_eq1! { Vec<A>, Vec<B> }\n-__impl_slice_eq2! { Vec<A>, &'b [B] }\n-__impl_slice_eq2! { Vec<A>, &'b mut [B] }\n-__impl_slice_eq2! { Cow<'a, [A]>, &'b [B], Clone }\n-__impl_slice_eq2! { Cow<'a, [A]>, &'b mut [B], Clone }\n-__impl_slice_eq2! { Cow<'a, [A]>, Vec<B>, Clone }\n+__impl_slice_eq1! { Vec<A>, &'b [B] }\n+__impl_slice_eq1! { Vec<A>, &'b mut [B] }\n+__impl_slice_eq1! { Cow<'a, [A]>, &'b [B], Clone }\n+__impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B], Clone }\n+__impl_slice_eq1! { Cow<'a, [A]>, Vec<B>, Clone }\n \n macro_rules! array_impls {\n     ($($N: expr)+) => {\n         $(\n             // NOTE: some less important impls are omitted to reduce code bloat\n-            __impl_slice_eq2! { Vec<A>, [B; $N] }\n-            __impl_slice_eq2! { Vec<A>, &'b [B; $N] }\n-            // __impl_slice_eq2! { Vec<A>, &'b mut [B; $N] }\n-            // __impl_slice_eq2! { Cow<'a, [A]>, [B; $N], Clone }\n-            // __impl_slice_eq2! { Cow<'a, [A]>, &'b [B; $N], Clone }\n-            // __impl_slice_eq2! { Cow<'a, [A]>, &'b mut [B; $N], Clone }\n+            __impl_slice_eq1! { Vec<A>, [B; $N] }\n+            __impl_slice_eq1! { Vec<A>, &'b [B; $N] }\n+            // __impl_slice_eq1! { Vec<A>, &'b mut [B; $N] }\n+            // __impl_slice_eq1! { Cow<'a, [A]>, [B; $N], Clone }\n+            // __impl_slice_eq1! { Cow<'a, [A]>, &'b [B; $N], Clone }\n+            // __impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B; $N], Clone }\n         )+\n     }\n }\n@@ -1642,13 +1649,6 @@ impl<T> AsRef<Vec<T>> for Vec<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Into<Vec<T>> for Vec<T> {\n-    fn into(self) -> Vec<T> {\n-        self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> AsRef<[T]> for Vec<T> {\n     fn as_ref(&self) -> &[T] {\n@@ -1679,11 +1679,6 @@ impl<'a> From<&'a str> for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// A clone-on-write vector\n-#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, [T]> instead\")]\n-#[unstable(feature = \"collections\")]\n-pub type CowVec<'a, T> = Cow<'a, [T]>;\n-\n #[unstable(feature = \"collections\")]\n impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n     fn from_iter<I: IntoIterator<Item=T>>(it: I) -> Cow<'a, [T]> {"}, {"sha": "49b0c229215bd98ee8842debf19edb21b9d79275", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -25,8 +25,6 @@ use core::default::Default;\n use core::fmt;\n use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::mem;\n-#[cfg(stage0)]\n-use core::num::wrapping::WrappingOps;\n use core::ops::{Index, IndexMut};\n use core::ptr::{self, Unique};\n use core::slice;\n@@ -36,10 +34,6 @@ use core::cmp;\n \n use alloc::heap;\n \n-#[deprecated(since = \"1.0.0\", reason = \"renamed to VecDeque\")]\n-#[unstable(feature = \"collections\")]\n-pub use VecDeque as RingBuf;\n-\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n@@ -527,7 +521,8 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// let b: &[_] = &[&5, &3, &4];\n-    /// assert_eq!(buf.iter().collect::<Vec<&i32>>().as_slice(), b);\n+    /// let c: Vec<&i32> = buf.iter().collect();\n+    /// assert_eq!(&c[..], b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -1902,7 +1897,7 @@ mod test {\n         // len is the length *after* insertion\n         for len in 1..cap {\n             // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n+            let expected = (0..).take(len).collect();\n             for tail_pos in 0..cap {\n                 for to_insert in 0..len {\n                     tester.tail = tail_pos;\n@@ -1935,7 +1930,7 @@ mod test {\n         // len is the length *after* removal\n         for len in 0..cap - 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n+            let expected = (0..).take(len).collect();\n             for tail_pos in 0..cap {\n                 for to_remove in 0..len + 1 {\n                     tester.tail = tail_pos;\n@@ -1973,7 +1968,7 @@ mod test {\n \n         for len in 0..cap + 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n+            let expected = (0..).take(len).collect();\n             for tail_pos in 0..max_cap + 1 {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -2006,9 +2001,9 @@ mod test {\n             // index to split at\n             for at in 0..len + 1 {\n                 // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = iter::count(0, 1).take(at).collect();\n+                let expected_self = (0..).take(at).collect();\n                 // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = iter::count(at, 1).take(len - at).collect();\n+                let expected_other = (at..).take(len - at).collect();\n \n                 for tail_pos in 0..cap {\n                     tester.tail = tail_pos;"}, {"sha": "19ea25ee345fae46e07067f200ab34dc9ad907d2", "filename": "src/libcollectionstest/bit/set.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,7 +10,6 @@\n \n use std::cmp::Ordering::{Equal, Greater, Less};\n use std::collections::{BitSet, BitVec};\n-use std::iter::range_step;\n \n #[test]\n fn test_bit_set_show() {\n@@ -42,7 +41,7 @@ fn test_bit_set_iterator() {\n     assert_eq!(idxs, [0, 2, 3]);\n \n     let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n-    let real: Vec<_> = range_step(0, 10000, 2).collect();\n+    let real: Vec<_> = (0..10000).step_by(2).collect();\n \n     let idxs: Vec<_> = long.iter().collect();\n     assert_eq!(idxs, real);"}, {"sha": "a748541fca5ce9609670271cb38276dd39000c37", "filename": "src/libcollectionstest/enum_set.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fenum_set.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -153,19 +153,19 @@ fn test_iterator() {\n \n     e1.insert(A);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A], elems);\n+    assert_eq!(elems, [A]);\n \n     e1.insert(C);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A,C], elems);\n+    assert_eq!(elems, [A,C]);\n \n     e1.insert(C);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A,C], elems);\n+    assert_eq!(elems, [A,C]);\n \n     e1.insert(B);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A,B,C], elems);\n+    assert_eq!(elems, [A,B,C]);\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -183,35 +183,35 @@ fn test_operators() {\n \n     let e_union = e1 | e2;\n     let elems: Vec<_> = e_union.iter().collect();\n-    assert_eq!([A,B,C], elems);\n+    assert_eq!(elems, [A,B,C]);\n \n     let e_intersection = e1 & e2;\n     let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!([C], elems);\n+    assert_eq!(elems, [C]);\n \n     // Another way to express intersection\n     let e_intersection = e1 - (e1 - e2);\n     let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!([C], elems);\n+    assert_eq!(elems, [C]);\n \n     let e_subtract = e1 - e2;\n     let elems: Vec<_> = e_subtract.iter().collect();\n-    assert_eq!([A], elems);\n+    assert_eq!(elems, [A]);\n \n     // Bitwise XOR of two sets, aka symmetric difference\n     let e_symmetric_diff = e1 ^ e2;\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!([A,B], elems);\n+    assert_eq!(elems, [A,B]);\n \n     // Another way to express symmetric difference\n     let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!([A,B], elems);\n+    assert_eq!(elems, [A,B]);\n \n     // Yet another way to express symmetric difference\n     let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!([A,B], elems);\n+    assert_eq!(elems, [A,B]);\n }\n \n #[test]"}, {"sha": "70e21c65a1806549eb10764d5bbb67ddfb616a6e", "filename": "src/libcollectionstest/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Ffmt.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,5 +13,5 @@ use std::fmt;\n #[test]\n fn test_format() {\n     let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n-    assert_eq!(s.as_slice(), \"Hello, world!\");\n+    assert_eq!(s, \"Hello, world!\");\n }"}, {"sha": "456c658a9c6dc82d03b861cd50b8cf51ad6a245b", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n@@ -21,6 +20,7 @@\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n #![feature(into_cow)]\n+#![feature(step_by)]\n #![cfg_attr(test, feature(str_char))]\n \n #[macro_use] extern crate log;"}, {"sha": "041d9fba57cc35169b0e4921e7a3af053e69d9ad", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -59,7 +59,7 @@ fn test_from_elem() {\n     // Test on-heap from_elem.\n     v = vec![20; 6];\n     {\n-        let v = v.as_slice();\n+        let v = &v[..];\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 20);\n         assert_eq!(v[2], 20);\n@@ -685,7 +685,7 @@ fn test_capacity() {\n #[test]\n fn test_slice_2() {\n     let v = vec![1, 2, 3, 4, 5];\n-    let v = v.slice(1, 3);\n+    let v = &v[1..3];\n     assert_eq!(v.len(), 2);\n     assert_eq!(v[0], 2);\n     assert_eq!(v[1], 3);"}, {"sha": "ed9ee0206b74f1f724fc434a8ff379694ebdcd5c", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -83,38 +83,38 @@ fn test_collect() {\n fn test_into_bytes() {\n     let data = String::from_str(\"asdf\");\n     let buf = data.into_bytes();\n-    assert_eq!(b\"asdf\", buf);\n+    assert_eq!(buf, b\"asdf\");\n }\n \n #[test]\n fn test_find_str() {\n     // byte positions\n-    assert_eq!(\"\".find_str(\"\"), Some(0));\n-    assert!(\"banana\".find_str(\"apple pie\").is_none());\n+    assert_eq!(\"\".find(\"\"), Some(0));\n+    assert!(\"banana\".find(\"apple pie\").is_none());\n \n     let data = \"abcabc\";\n-    assert_eq!(data[0..6].find_str(\"ab\"), Some(0));\n-    assert_eq!(data[2..6].find_str(\"ab\"), Some(3 - 2));\n-    assert!(data[2..4].find_str(\"ab\").is_none());\n+    assert_eq!(data[0..6].find(\"ab\"), Some(0));\n+    assert_eq!(data[2..6].find(\"ab\"), Some(3 - 2));\n+    assert!(data[2..4].find(\"ab\").is_none());\n \n     let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let mut data = String::from_str(string);\n     data.push_str(string);\n-    assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n-    assert_eq!(data[0..43].find_str(\"\"), Some(0));\n-    assert_eq!(data[6..43].find_str(\"\"), Some(6 - 6));\n+    assert!(data.find(\"\u0e44\u0e17\u534e\").is_none());\n+    assert_eq!(data[0..43].find(\"\"), Some(0));\n+    assert_eq!(data[6..43].find(\"\"), Some(6 - 6));\n \n-    assert_eq!(data[0..43].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n-    assert_eq!(data[0..43].find_str(\"\u0e17\u0e28\u0e44\"), Some(12));\n-    assert_eq!(data[0..43].find_str(\"\u0e22\u4e2d\"), Some(24));\n-    assert_eq!(data[0..43].find_str(\"i\u1ec7t\"), Some(34));\n-    assert_eq!(data[0..43].find_str(\"Nam\"), Some(40));\n+    assert_eq!(data[0..43].find(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n+    assert_eq!(data[0..43].find(\"\u0e17\u0e28\u0e44\"), Some(12));\n+    assert_eq!(data[0..43].find(\"\u0e22\u4e2d\"), Some(24));\n+    assert_eq!(data[0..43].find(\"i\u1ec7t\"), Some(34));\n+    assert_eq!(data[0..43].find(\"Nam\"), Some(40));\n \n-    assert_eq!(data[43..86].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n-    assert_eq!(data[43..86].find_str(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n-    assert_eq!(data[43..86].find_str(\"\u0e22\u4e2d\"), Some(67 - 43));\n-    assert_eq!(data[43..86].find_str(\"i\u1ec7t\"), Some(77 - 43));\n-    assert_eq!(data[43..86].find_str(\"Nam\"), Some(83 - 43));\n+    assert_eq!(data[43..86].find(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n+    assert_eq!(data[43..86].find(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n+    assert_eq!(data[43..86].find(\"\u0e22\u4e2d\"), Some(67 - 43));\n+    assert_eq!(data[43..86].find(\"i\u1ec7t\"), Some(77 - 43));\n+    assert_eq!(data[43..86].find(\"Nam\"), Some(83 - 43));\n }\n \n #[test]\n@@ -297,16 +297,16 @@ fn test_replace_2d() {\n \n #[test]\n fn test_slice() {\n-    assert_eq!(\"ab\", \"abc\".slice(0, 2));\n-    assert_eq!(\"bc\", \"abc\".slice(1, 3));\n-    assert_eq!(\"\", \"abc\".slice(1, 1));\n-    assert_eq!(\"\\u{65e5}\", \"\\u{65e5}\\u{672c}\".slice(0, 3));\n+    assert_eq!(\"ab\", &\"abc\"[0..2]);\n+    assert_eq!(\"bc\", &\"abc\"[1..3]);\n+    assert_eq!(\"\", &\"abc\"[1..1]);\n+    assert_eq!(\"\\u{65e5}\", &\"\\u{65e5}\\u{672c}\"[0..3]);\n \n     let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-    assert_eq!(\"\u0e1b\", data.slice(0, 3));\n-    assert_eq!(\"\u0e23\", data.slice(3, 6));\n-    assert_eq!(\"\", data.slice(3, 3));\n-    assert_eq!(\"\u534e\", data.slice(30, 33));\n+    assert_eq!(\"\u0e1b\", &data[0..3]);\n+    assert_eq!(\"\u0e23\", &data[3..6]);\n+    assert_eq!(\"\", &data[3..3]);\n+    assert_eq!(\"\u534e\", &data[30..33]);\n \n     fn a_million_letter_x() -> String {\n         let mut i = 0;\n@@ -328,23 +328,23 @@ fn test_slice() {\n     }\n     let letters = a_million_letter_x();\n     assert!(half_a_million_letter_x() ==\n-        String::from_str(letters.slice(0, 3 * 500000)));\n+        String::from_str(&letters[0..3 * 500000]));\n }\n \n #[test]\n fn test_slice_2() {\n     let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-    assert_eq!(\"\u534e\", ss.slice(3, 6));\n-    assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6, 16));\n+    assert_eq!(\"\u534e\", &ss[3..6]);\n+    assert_eq!(\"Vi\u1ec7t Nam\", &ss[6..16]);\n \n-    assert_eq!(\"ab\", \"abc\".slice(0, 2));\n-    assert_eq!(\"bc\", \"abc\".slice(1, 3));\n-    assert_eq!(\"\", \"abc\".slice(1, 1));\n+    assert_eq!(\"ab\", &\"abc\"[0..2]);\n+    assert_eq!(\"bc\", &\"abc\"[1..3]);\n+    assert_eq!(\"\", &\"abc\"[1..1]);\n \n-    assert_eq!(\"\u4e2d\", ss.slice(0, 3));\n-    assert_eq!(\"\u534eV\", ss.slice(3, 7));\n-    assert_eq!(\"\", ss.slice(3, 3));\n+    assert_eq!(\"\u4e2d\", &ss[0..3]);\n+    assert_eq!(\"\u534eV\", &ss[3..7]);\n+    assert_eq!(\"\", &ss[3..3]);\n     /*0: \u4e2d\n       3: \u534e\n       6: V\n@@ -360,20 +360,20 @@ fn test_slice_2() {\n #[test]\n #[should_panic]\n fn test_slice_fail() {\n-    \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0, 2);\n+    &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n }\n \n #[test]\n fn test_slice_from() {\n-    assert_eq!(\"abcd\".slice_from(0), \"abcd\");\n-    assert_eq!(\"abcd\".slice_from(2), \"cd\");\n-    assert_eq!(\"abcd\".slice_from(4), \"\");\n+    assert_eq!(&\"abcd\"[0..], \"abcd\");\n+    assert_eq!(&\"abcd\"[2..], \"cd\");\n+    assert_eq!(&\"abcd\"[4..], \"\");\n }\n #[test]\n fn test_slice_to() {\n-    assert_eq!(\"abcd\".slice_to(0), \"\");\n-    assert_eq!(\"abcd\".slice_to(2), \"ab\");\n-    assert_eq!(\"abcd\".slice_to(4), \"abcd\");\n+    assert_eq!(&\"abcd\"[..0], \"\");\n+    assert_eq!(&\"abcd\"[..2], \"ab\");\n+    assert_eq!(&\"abcd\"[..4], \"abcd\");\n }\n \n #[test]\n@@ -660,10 +660,10 @@ fn test_contains() {\n \n #[test]\n fn test_contains_char() {\n-    assert!(\"abc\".contains_char('b'));\n-    assert!(\"a\".contains_char('a'));\n-    assert!(!\"abc\".contains_char('d'));\n-    assert!(!\"\".contains_char('a'));\n+    assert!(\"abc\".contains('b'));\n+    assert!(\"a\".contains('a'));\n+    assert!(!\"abc\".contains('d'));\n+    assert!(!\"\".contains('a'));\n }\n \n #[test]\n@@ -1445,9 +1445,9 @@ fn test_graphemes() {\n }\n \n #[test]\n-fn test_split_strator() {\n+fn test_splitator() {\n     fn t(s: &str, sep: &str, u: &[&str]) {\n-        let v: Vec<&str> = s.split_str(sep).collect();\n+        let v: Vec<&str> = s.split(sep).collect();\n         assert_eq!(v, u);\n     }\n     t(\"--1233345--\", \"12345\", &[\"--1233345--\"]);\n@@ -1470,9 +1470,9 @@ fn test_split_strator() {\n fn test_str_default() {\n     use std::default::Default;\n \n-    fn t<S: Default + Str>() {\n+    fn t<S: Default + AsRef<str>>() {\n         let s: S = Default::default();\n-        assert_eq!(s.as_slice(), \"\");\n+        assert_eq!(s.as_ref(), \"\");\n     }\n \n     t::<&str>();"}, {"sha": "5d6aa8ac0dcc37aa181ad829c2e0ee0e97d6e803", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::borrow::IntoCow;\n+use std::borrow::{IntoCow, Cow};\n use std::iter::repeat;\n use std::str::Utf8Error;\n-use std::string::{CowString, as_string};\n+use std::string::as_string;\n \n use test::Bencher;\n \n@@ -52,11 +52,11 @@ fn test_from_utf8() {\n #[test]\n fn test_from_utf8_lossy() {\n     let xs = b\"hello\";\n-    let ys: CowString = \"hello\".into_cow();\n+    let ys: Cow<str> = \"hello\".into_cow();\n     assert_eq!(String::from_utf8_lossy(xs), ys);\n \n     let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-    let ys: CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n+    let ys: Cow<str> = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n     assert_eq!(String::from_utf8_lossy(xs), ys);\n \n     let xs = b\"Hello\\xC2 There\\xFF Goodbye\";"}, {"sha": "12323286f6b4bae103ecaca8e012da9632d63916", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -18,7 +18,6 @@ use self::Taggy::*;\n use self::Taggypar::*;\n \n #[test]\n-#[allow(deprecated)]\n fn test_simple() {\n     let mut d = VecDeque::new();\n     assert_eq!(d.len(), 0);\n@@ -545,7 +544,7 @@ fn test_from_iter() {\n     let u: Vec<_> = deq.iter().cloned().collect();\n     assert_eq!(u, v);\n \n-    let seq = iter::count(0, 2).take(256);\n+    let seq = (0..).step_by(2).take(256);\n     let deq: VecDeque<_> = seq.collect();\n     for (i, &x) in deq.iter().enumerate() {\n         assert_eq!(2*i, x);\n@@ -821,7 +820,7 @@ fn test_as_slices() {\n \n         let (left, right) = ring.as_slices();\n         let expected: Vec<_> = (0..i+1).collect();\n-        assert_eq!(left, expected);\n+        assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n@@ -830,8 +829,8 @@ fn test_as_slices() {\n         let (left, right) = ring.as_slices();\n         let expected_left: Vec<_> = (-last..j+1).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n-        assert_eq!(left, expected_left);\n-        assert_eq!(right, expected_right);\n+        assert_eq!(left, &expected_left[..]);\n+        assert_eq!(right, &expected_right[..]);\n     }\n \n     assert_eq!(ring.len() as i32, cap);\n@@ -849,7 +848,7 @@ fn test_as_mut_slices() {\n \n         let (left, right) = ring.as_mut_slices();\n         let expected: Vec<_> = (0..i+1).collect();\n-        assert_eq!(left, expected);\n+        assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n@@ -858,8 +857,8 @@ fn test_as_mut_slices() {\n         let (left, right) = ring.as_mut_slices();\n         let expected_left: Vec<_> = (-last..j+1).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n-        assert_eq!(left, expected_left);\n-        assert_eq!(right, expected_right);\n+        assert_eq!(left, &expected_left[..]);\n+        assert_eq!(right, &expected_right[..]);\n     }\n \n     assert_eq!(ring.len() as i32, cap);"}, {"sha": "0ffc4a229b5ae60a934ba2df4a16dae14def0e3d", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -202,8 +202,7 @@ pub struct TypeId {\n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n-    #[unstable(feature = \"core\",\n-               reason = \"may grow a `Reflect` bound soon via marker traits\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn of<T: ?Sized + Any>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },"}, {"sha": "8c396a4e7fbcb1768e74efb576fbb4d33b163040", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -1062,144 +1062,3 @@ pub fn fence(order: Ordering) {\n         }\n     }\n }\n-\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"renamed to AtomicIsize\")]\n-#[allow(missing_docs)]\n-pub struct AtomicInt {\n-    v: UnsafeCell<isize>,\n-}\n-\n-#[allow(deprecated)]\n-unsafe impl Sync for AtomicInt {}\n-\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"renamed to AtomicUsize\")]\n-#[allow(missing_docs)]\n-pub struct AtomicUint {\n-    v: UnsafeCell<usize>,\n-}\n-\n-#[allow(deprecated)]\n-unsafe impl Sync for AtomicUint {}\n-\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use ATOMIC_ISIZE_INIT instead\")]\n-#[allow(missing_docs, deprecated)]\n-pub const ATOMIC_INT_INIT: AtomicInt =\n-        AtomicInt { v: UnsafeCell { value: 0 } };\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use ATOMIC_USIZE_INIT instead\")]\n-#[allow(missing_docs, deprecated)]\n-pub const ATOMIC_UINT_INIT: AtomicUint =\n-        AtomicUint { v: UnsafeCell { value: 0, } };\n-\n-#[allow(missing_docs, deprecated)]\n-impl AtomicInt {\n-    #[inline]\n-    pub fn new(v: isize) -> AtomicInt {\n-        AtomicInt {v: UnsafeCell::new(v)}\n-    }\n-\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> isize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    #[inline]\n-    pub fn store(&self, val: isize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    #[inline]\n-    pub fn swap(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-#[allow(missing_docs, deprecated)]\n-impl AtomicUint {\n-    #[inline]\n-    pub fn new(v: usize) -> AtomicUint {\n-        AtomicUint { v: UnsafeCell::new(v) }\n-    }\n-\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> usize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    #[inline]\n-    pub fn store(&self, val: usize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    #[inline]\n-    pub fn swap(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}"}, {"sha": "906c87f3ffda63132a2a7cce73e71447bf26016e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -343,23 +343,6 @@ impl<T> RefCell<T> {\n         }\n     }\n \n-    /// Attempts to immutably borrow the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n-    ///\n-    /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"dispatch on `cell.borrow_state()` instead\")]\n-    #[inline]\n-    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n-        match BorrowRef::new(&self.borrow) {\n-            Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n-            None => None,\n-        }\n-    }\n-\n     /// Immutably borrows the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n@@ -407,23 +390,6 @@ impl<T> RefCell<T> {\n         }\n     }\n \n-    /// Mutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n-    ///\n-    /// Returns `None` if the value is currently borrowed.\n-    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"dispatch on `cell.borrow_state()` instead\")]\n-    #[inline]\n-    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n-        match BorrowRefMut::new(&self.borrow) {\n-            Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n-            None => None,\n-        }\n-    }\n-\n     /// Mutably borrows the wrapped value.\n     ///\n     /// The borrow lasts until the returned `RefMut` exits scope. The value"}, {"sha": "efe1179621de5efde5843896c2aabea9faba2e99", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -64,7 +64,6 @@ use option::Option::{self, Some, None};\n /// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n #[lang=\"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[old_orphan_check]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -360,6 +359,8 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n /// Compare and return the minimum of two values.\n ///\n+/// Returns the first argument if the comparison determines them to be equal.\n+///\n /// # Examples\n ///\n /// ```\n@@ -371,11 +372,13 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n-    if v1 < v2 { v1 } else { v2 }\n+    if v1 <= v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n ///\n+/// Returns the second argument if the comparison determines them to be equal.\n+///\n /// # Examples\n ///\n /// ```\n@@ -387,7 +390,7 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n-    if v1 > v2 { v1 } else { v2 }\n+    if v2 >= v1 { v2 } else { v1 }\n }\n \n /// Compare and return the minimum of two values if there is one.\n@@ -425,7 +428,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n \n /// Compare and return the maximum of two values if there is one.\n ///\n-/// Returns the first argument if the comparison determines them to be equal.\n+/// Returns the second argument if the comparison determines them to be equal.\n ///\n /// # Examples\n ///\n@@ -450,8 +453,8 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n #[unstable(feature = \"core\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n-        Some(Less) => Some(v2),\n-        Some(Equal) | Some(Greater) => Some(v1),\n+        Some(Equal) | Some(Less) => Some(v2),\n+        Some(Greater) => Some(v1),\n         None => None\n     }\n }"}, {"sha": "95dab3d165ad3f99cfa4db8034afa5cc492b0d7d", "filename": "src/libcore/cmp_macros.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fcmp_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fcmp_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp_macros.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -15,8 +15,11 @@\n #[macro_export]\n macro_rules! __impl_slice_eq1 {\n     ($Lhs: ty, $Rhs: ty) => {\n+        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n+    };\n+    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n             #[inline]\n             fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n             #[inline]\n@@ -31,13 +34,7 @@ macro_rules! __impl_slice_eq2 {\n         __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n     };\n     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Rhs) -> bool { &self[..] != &other[..] }\n-        }\n+        __impl_slice_eq1!($Lhs, $Rhs, $Bound);\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, 'b, A: $Bound, B> PartialEq<$Lhs> for $Rhs where B: PartialEq<A> {"}, {"sha": "4a99f1a756a7c3e8ac31317a0a2eee8374fc06d3", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,55 +14,57 @@\n //! conversions from one type to another. They follow the standard\n //! Rust conventions of `as`/`to`/`into`/`from`.\n \n-#![unstable(feature = \"convert\",\n-            reason = \"recently added, experimental traits\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n \n /// A cheap, reference-to-reference conversion.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRef<T: ?Sized> {\n     /// Perform the conversion.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_ref(&self) -> &T;\n }\n \n /// A cheap, mutable reference-to-mutable reference conversion.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n     /// Perform the conversion.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut(&mut self) -> &mut T;\n }\n \n /// A conversion that consumes `self`, which may or may not be\n /// expensive.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Perform the conversion.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into(self) -> T;\n }\n \n /// Construct `Self` via a conversion.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T> {\n     /// Perform the conversion.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from(T) -> Self;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // GENERIC IMPLS\n ////////////////////////////////////////////////////////////////////////////////\n \n-// As implies Into\n-impl<'a, T: ?Sized, U: ?Sized> Into<&'a U> for &'a T where T: AsRef<U> {\n-    fn into(self) -> &'a U {\n-        self.as_ref()\n-    }\n-}\n-\n // As lifts over &\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U> {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n     }\n }\n \n // As lifts over &mut\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n@@ -77,14 +79,8 @@ impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> {\n //     }\n // }\n \n-// AsMut implies Into\n-impl<'a, T: ?Sized, U: ?Sized> Into<&'a mut U> for &'a mut T where T: AsMut<U> {\n-    fn into(self) -> &'a mut U {\n-        (*self).as_mut()\n-    }\n-}\n-\n // AsMut lifts over &mut\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> {\n     fn as_mut(&mut self) -> &mut U {\n         (*self).as_mut()\n@@ -100,28 +96,38 @@ impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> {\n // }\n \n // From implies Into\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, U> Into<U> for T where U: From<T> {\n     fn into(self) -> U {\n         U::from(self)\n     }\n }\n \n+// From (and thus Into) is reflexive\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> From<T> for T {\n+    fn from(t: T) -> T { t }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // CONCRETE IMPLS\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> AsRef<[T]> for [T] {\n     fn as_ref(&self) -> &[T] {\n         self\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> AsMut<[T]> for [T] {\n     fn as_mut(&mut self) -> &mut [T] {\n         self\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<str> for str {\n     fn as_ref(&self) -> &str {\n         self"}, {"sha": "24035b7d9a83bdc8ff23a6c687ee58de29461a90", "filename": "src/libcore/error.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -33,49 +33,6 @@\n //! high-level module to provide its own errors that do not commit to any\n //! particular implementation, but also reveal some of its implementation for\n //! debugging via `cause` chains.\n-//!\n-//! # The `FromError` trait\n-//!\n-//! `FromError` is a simple trait that expresses conversions between different\n-//! error types. To provide maximum flexibility, it does not require either of\n-//! the types to actually implement the `Error` trait, although this will be the\n-//! common case.\n-//!\n-//! The main use of this trait is in the `try!` macro, which uses it to\n-//! automatically convert a given error to the error specified in a function's\n-//! return type.\n-//!\n-//! For example,\n-//!\n-//! ```\n-//! #![feature(core)]\n-//! use std::error::FromError;\n-//! use std::{io, str};\n-//! use std::fs::File;\n-//!\n-//! enum MyError {\n-//!     Io(io::Error),\n-//!     Utf8(str::Utf8Error),\n-//! }\n-//!\n-//! impl FromError<io::Error> for MyError {\n-//!     fn from_error(err: io::Error) -> MyError { MyError::Io(err) }\n-//! }\n-//!\n-//! impl FromError<str::Utf8Error> for MyError {\n-//!     fn from_error(err: str::Utf8Error) -> MyError { MyError::Utf8(err) }\n-//! }\n-//!\n-//! #[allow(unused_variables)]\n-//! fn open_and_map() -> Result<(), MyError> {\n-//!     let b = b\"foo.txt\";\n-//!     let s = try!(str::from_utf8(b));\n-//!     let f = try!(File::open(s));\n-//!\n-//!     // do something interesting here...\n-//!     Ok(())\n-//! }\n-//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -97,19 +54,3 @@ pub trait Error: Debug + Display {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cause(&self) -> Option<&Error> { None }\n }\n-\n-/// A trait for types that can be converted from a given error type `E`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait FromError<E> {\n-    /// Perform the conversion.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_error(err: E) -> Self;\n-}\n-\n-// Any type is convertable from itself\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<E> FromError<E> for E {\n-    fn from_error(err: E) -> E {\n-        err\n-    }\n-}"}, {"sha": "93a7d2bb17b92237a305a8b5ac033060b51a12b1", "filename": "src/libcore/finally.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,111 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The Finally trait provides a method, `finally` on\n-//! stack closures that emulates Java-style try/finally blocks.\n-//!\n-//! Using the `finally` method is sometimes convenient, but the type rules\n-//! prohibit any shared, mutable state between the \"try\" case and the\n-//! \"finally\" case. For advanced cases, the `try_finally` function can\n-//! also be used. See that function for more details.\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! # #![feature(core)]\n-//! # #![feature(unboxed_closures)]\n-//!\n-//! use std::finally::Finally;\n-//!\n-//! (|| {\n-//!     // ...\n-//! }).finally(|| {\n-//!     // this code is always run\n-//! })\n-//! ```\n-\n-#![unstable(feature = \"core\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"It is unclear if this module is more robust than implementing \\\n-                        Drop on a custom type, and this module is being removed with no \\\n-                        replacement. Use a custom Drop implementation to regain existing \\\n-                        functionality.\")]\n-#![allow(deprecated)]\n-\n-use ops::{Drop, FnMut, FnOnce};\n-\n-/// A trait for executing a destructor unconditionally after a block of code,\n-/// regardless of whether the blocked fails.\n-pub trait Finally<T> {\n-    /// Executes this object, unconditionally running `dtor` after this block of\n-    /// code has run.\n-    fn finally<F>(&mut self, dtor: F) -> T where F: FnMut();\n-}\n-\n-impl<T, F> Finally<T> for F where F: FnMut() -> T {\n-    fn finally<G>(&mut self, mut dtor: G) -> T where G: FnMut() {\n-        try_finally(&mut (), self, |_, f| (*f)(), |_| dtor())\n-    }\n-}\n-\n-/// The most general form of the `finally` functions. The function\n-/// `try_fn` will be invoked first; whether or not it panics, the\n-/// function `finally_fn` will be invoked next. The two parameters\n-/// `mutate` and `drop` are used to thread state through the two\n-/// closures. `mutate` is used for any shared, mutable state that both\n-/// closures require access to; `drop` is used for any state that the\n-/// `try_fn` requires ownership of.\n-///\n-/// **WARNING:** While shared, mutable state between the try and finally\n-/// function is often necessary, one must be very careful; the `try`\n-/// function could have panicked at any point, so the values of the shared\n-/// state may be inconsistent.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::finally::try_finally;\n-///\n-/// struct State<'a> { buffer: &'a mut [u8], len: usize }\n-/// # let mut buf = [];\n-/// let mut state = State { buffer: &mut buf, len: 0 };\n-/// try_finally(\n-///     &mut state, (),\n-///     |state, ()| {\n-///         // use state.buffer, state.len\n-///     },\n-///     |state| {\n-///         // use state.buffer, state.len to cleanup\n-///     })\n-/// ```\n-pub fn try_finally<T, U, R, F, G>(mutate: &mut T, drop: U, try_fn: F, finally_fn: G) -> R where\n-    F: FnOnce(&mut T, U) -> R,\n-    G: FnMut(&mut T),\n-{\n-    let f = Finallyalizer {\n-        mutate: mutate,\n-        dtor: finally_fn,\n-    };\n-    try_fn(&mut *f.mutate, drop)\n-}\n-\n-struct Finallyalizer<'a, A:'a, F> where F: FnMut(&mut A) {\n-    mutate: &'a mut A,\n-    dtor: F,\n-}\n-\n-#[unsafe_destructor]\n-impl<'a, A, F> Drop for Finallyalizer<'a, A, F> where F: FnMut(&mut A) {\n-    #[inline]\n-    fn drop(&mut self) {\n-        (self.dtor)(self.mutate);\n-    }\n-}"}, {"sha": "6820a7025fca6f171cda155752bf60d6e258bf2d", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -114,11 +114,6 @@ impl SipHasher {\n         state\n     }\n \n-    /// Returns the computed hash.\n-    #[unstable(feature = \"hash\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to finish\")]\n-    pub fn result(&self) -> u64 { self.finish() }\n-\n     fn reset(&mut self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;"}, {"sha": "0e91eafce187f7b0ed2dd8160c7c4fe365669043", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -197,7 +197,6 @@ extern \"rust-intrinsic\" {\n     /// Rust moves to non-zeroing dynamic drop (and thus removes the\n     /// embedded drop flags that are being established by this\n     /// intrinsic).\n-    #[cfg(not(stage0))]\n     pub fn init_dropped<T>() -> T;\n \n     /// Create a value initialized to zero."}, {"sha": "2d69eeb9fa962cf7de006cff5b279612fc1ae1a1", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 140, "deletions": 246, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,47 +12,49 @@\n //!\n //! # The `Iterator` trait\n //!\n-//! This module defines Rust's core iteration trait. The `Iterator` trait has one\n-//! unimplemented method, `next`. All other methods are derived through default\n-//! methods to perform operations such as `zip`, `chain`, `enumerate`, and `fold`.\n+//! This module defines Rust's core iteration trait. The `Iterator` trait has\n+//! one unimplemented method, `next`. All other methods are derived through\n+//! default methods to perform operations such as `zip`, `chain`, `enumerate`,\n+//! and `fold`.\n //!\n //! The goal of this module is to unify iteration across all containers in Rust.\n-//! An iterator can be considered as a state machine which is used to track which\n-//! element will be yielded next.\n+//! An iterator can be considered as a state machine which is used to track\n+//! which element will be yielded next.\n //!\n-//! There are various extensions also defined in this module to assist with various\n-//! types of iteration, such as the `DoubleEndedIterator` for iterating in reverse,\n-//! the `FromIterator` trait for creating a container from an iterator, and much\n-//! more.\n+//! There are various extensions also defined in this module to assist with\n+//! various types of iteration, such as the `DoubleEndedIterator` for iterating\n+//! in reverse, the `FromIterator` trait for creating a container from an\n+//! iterator, and much more.\n //!\n-//! ## Rust's `for` loop\n+//! # Rust's `for` loop\n //!\n-//! The special syntax used by rust's `for` loop is based around the `Iterator`\n-//! trait defined in this module. For loops can be viewed as a syntactical expansion\n-//! into a `loop`, for example, the `for` loop in this example is essentially\n-//! translated to the `loop` below.\n+//! The special syntax used by rust's `for` loop is based around the\n+//! `IntoIterator` trait defined in this module. `for` loops can be viewed as a\n+//! syntactical expansion into a `loop`, for example, the `for` loop in this\n+//! example is essentially translated to the `loop` below.\n //!\n //! ```\n //! let values = vec![1, 2, 3];\n //!\n-//! // \"Syntactical sugar\" taking advantage of an iterator\n-//! for &x in values.iter() {\n+//! for x in values {\n //!     println!(\"{}\", x);\n //! }\n //!\n //! // Rough translation of the iteration without a `for` iterator.\n-//! let mut it = values.iter();\n+//! # let values = vec![1, 2, 3];\n+//! let mut it = values.into_iter();\n //! loop {\n //!     match it.next() {\n-//!         Some(&x) => {\n+//!         Some(x) => {\n //!             println!(\"{}\", x);\n //!         }\n //!         None => { break }\n //!     }\n //! }\n //! ```\n //!\n-//! This `for` loop syntax can be applied to any iterator over any type.\n+//! Because `Iterator`s implement `IntoIterator`, this `for` loop syntax can be applied to any\n+//! iterator over any type.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -64,10 +66,9 @@ use cmp::Ord;\n use default::Default;\n use marker;\n use mem;\n-use num::{Int, Zero, One, ToPrimitive};\n-use ops::{Add, Sub, FnMut, RangeFrom};\n-use option::Option;\n-use option::Option::{Some, None};\n+use num::{Int, Zero, One};\n+use ops::{self, Add, Sub, FnMut, RangeFrom};\n+use option::Option::{self, Some, None};\n use marker::Sized;\n use usize;\n \n@@ -85,21 +86,22 @@ fn _assert_is_object_safe(_: &Iterator) {}\n /// else.\n #[lang=\"iterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling `.iter()` or a similar \\\n-                            method\"]\n+#[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n+                            `.iter()` or a similar method\"]\n pub trait Iterator {\n     /// The type of the elements being iterated\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n-    /// Advance the iterator and return the next value. Return `None` when the end is reached.\n+    /// Advance the iterator and return the next value. Return `None` when the\n+    /// end is reached.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n-    /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n-    /// does not fit within a `usize`.\n+    /// An upper bound of `None` means either there is no known upper bound, or\n+    /// the upper bound does not fit within a `usize`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n@@ -275,7 +277,8 @@ pub trait Iterator {\n     /// iterator plus the current index of iteration.\n     ///\n     /// `enumerate` keeps its count as a `usize`. If you want to count by a\n-    /// different sized integer, the `zip` function provides similar functionality.\n+    /// different sized integer, the `zip` function provides similar\n+    /// functionality.\n     ///\n     /// # Examples\n     ///\n@@ -433,7 +436,7 @@ pub trait Iterator {\n     /// # #![feature(core)]\n     /// let xs = [2, 3];\n     /// let ys = [0, 1, 0, 1, 2];\n-    /// let it = xs.iter().flat_map(|&x| std::iter::count(0, 1).take(x));\n+    /// let it = xs.iter().flat_map(|&x| (0..).take(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// for (i, x) in it.enumerate() {\n     ///     assert_eq!(x, ys[i]);\n@@ -530,10 +533,9 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let b: Vec<_> = a.iter().cloned().collect();\n-    /// assert_eq!(a, b);\n+    /// let expected = [1, 2, 3, 4, 5];\n+    /// let actual: Vec<_> = expected.iter().cloned().collect();\n+    /// assert_eq!(actual, expected);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -553,8 +555,7 @@ pub trait Iterator {\n     /// assert_eq!(even, [2, 4]);\n     /// assert_eq!(odd, [1, 3]);\n     /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added as part of collections reform\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partition<B, F>(self, mut f: F) -> (B, B) where\n         Self: Sized,\n         B: Default + Extend<Self::Item>,\n@@ -613,7 +614,8 @@ pub trait Iterator {\n         true\n     }\n \n-    /// Tests whether any element of an iterator satisfies the specified predicate.\n+    /// Tests whether any element of an iterator satisfies the specified\n+    /// predicate.\n     ///\n     /// Does not consume the iterator past the first found element.\n     ///\n@@ -624,7 +626,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|x| *x == 3));\n-    /// assert_eq!(it.as_slice(), [4, 5]);\n+    /// assert_eq!(&it[..], [4, 5]);\n     ///\n     /// ```\n     #[inline]\n@@ -648,7 +650,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n-    /// assert_eq!(it.as_slice(), [4, 5]);\n+    /// assert_eq!(&it[..], [4, 5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n@@ -672,7 +674,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n-    /// assert_eq!(it.as_slice(), [4, 5]);\n+    /// assert_eq!(&it[..], [4, 5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -702,7 +704,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 2, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n-    /// assert_eq!(it.as_slice(), [1, 2]);\n+    /// assert_eq!(&it[..], [1, 2]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -722,6 +724,9 @@ pub trait Iterator {\n \n     /// Consumes the entire iterator to return the maximum element.\n     ///\n+    /// Returns the rightmost element if the comparison determines two elements\n+    /// to be equally maximum.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -732,16 +737,19 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        self.fold(None, |max, x| {\n+        self.fold(None, |max, y| {\n             match max {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::max(x, y))\n+                None    => Some(y),\n+                Some(x) => Some(cmp::max(x, y))\n             }\n         })\n     }\n \n     /// Consumes the entire iterator to return the minimum element.\n     ///\n+    /// Returns the leftmost element if the comparison determines two elements\n+    /// to be equally minimum.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -752,10 +760,10 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        self.fold(None, |min, x| {\n+        self.fold(None, |min, y| {\n             match min {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::min(x, y))\n+                None    => Some(y),\n+                Some(x) => Some(cmp::min(x, y))\n             }\n         })\n     }\n@@ -771,7 +779,8 @@ pub trait Iterator {\n     ///    element in the iterator and all elements are equal.\n     ///\n     /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n-    /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n+    /// and so is faster than calling `min` and `max` separately which does `2 *\n+    /// n` comparisons.\n     ///\n     /// # Examples\n     ///\n@@ -799,16 +808,17 @@ pub trait Iterator {\n             Some(x) => {\n                 match self.next() {\n                     None => return OneElement(x),\n-                    Some(y) => if x < y {(x, y)} else {(y,x)}\n+                    Some(y) => if x <= y {(x, y)} else {(y, x)}\n                 }\n             }\n         };\n \n         loop {\n-            // `first` and `second` are the two next elements we want to look at.\n-            // We first compare `first` and `second` (#1). The smaller one is then compared to\n-            // current minimum (#2). The larger one is compared to current maximum (#3). This\n-            // way we do 3 comparisons for 2 elements.\n+            // `first` and `second` are the two next elements we want to look\n+            // at.  We first compare `first` and `second` (#1). The smaller one\n+            // is then compared to current minimum (#2). The larger one is\n+            // compared to current maximum (#3). This way we do 3 comparisons\n+            // for 2 elements.\n             let first = match self.next() {\n                 None => break,\n                 Some(x) => x\n@@ -817,19 +827,19 @@ pub trait Iterator {\n                 None => {\n                     if first < min {\n                         min = first;\n-                    } else if first > max {\n+                    } else if first >= max {\n                         max = first;\n                     }\n                     break;\n                 }\n                 Some(x) => x\n             };\n-            if first < second {\n-                if first < min {min = first;}\n-                if max < second {max = second;}\n+            if first <= second {\n+                if first < min { min = first }\n+                if second >= max { max = second }\n             } else {\n-                if second < min {min = second;}\n-                if max < first {max = first;}\n+                if second < min { min = second }\n+                if first >= max { max = first }\n             }\n         }\n \n@@ -839,6 +849,9 @@ pub trait Iterator {\n     /// Return the element that gives the maximum value from the\n     /// specified function.\n     ///\n+    /// Returns the rightmost element if the comparison determines two elements\n+    /// to be equally maximum.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -854,14 +867,14 @@ pub trait Iterator {\n         Self: Sized,\n         F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |max: Option<(Self::Item, B)>, x| {\n-            let x_val = f(&x);\n+        self.fold(None, |max: Option<(Self::Item, B)>, y| {\n+            let y_val = f(&y);\n             match max {\n-                None             => Some((x, x_val)),\n-                Some((y, y_val)) => if x_val > y_val {\n-                    Some((x, x_val))\n-                } else {\n+                None             => Some((y, y_val)),\n+                Some((x, x_val)) => if y_val >= x_val {\n                     Some((y, y_val))\n+                } else {\n+                    Some((x, x_val))\n                 }\n             }\n         }).map(|(x, _)| x)\n@@ -870,6 +883,9 @@ pub trait Iterator {\n     /// Return the element that gives the minimum value from the\n     /// specified function.\n     ///\n+    /// Returns the leftmost element if the comparison determines two elements\n+    /// to be equally minimum.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -885,11 +901,11 @@ pub trait Iterator {\n         Self: Sized,\n         F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |min: Option<(Self::Item, B)>, x| {\n-            let x_val = f(&x);\n+        self.fold(None, |min: Option<(Self::Item, B)>, y| {\n+            let y_val = f(&y);\n             match min {\n-                None             => Some((x, x_val)),\n-                Some((y, y_val)) => if x_val < y_val {\n+                None             => Some((y, y_val)),\n+                Some((x, x_val)) => if x_val <= y_val {\n                     Some((x, x_val))\n                 } else {\n                     Some((y, y_val))\n@@ -927,10 +943,10 @@ pub trait Iterator {\n     /// # #![feature(core)]\n     /// let a = [(1, 2), (3, 4)];\n     /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n-    /// assert_eq!([1, 3], left);\n-    /// assert_eq!([2, 4], right);\n+    /// assert_eq!(left, [1, 3]);\n+    /// assert_eq!(right, [2, 4]);\n     /// ```\n-    #[unstable(feature = \"core\", reason = \"recent addition\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -1027,7 +1043,8 @@ pub trait FromIterator<A> {\n     /// assert_eq!(colors_set.len(), 3);\n     /// ```\n     ///\n-    /// `FromIterator` is more commonly used implicitly via the `Iterator::collect` method:\n+    /// `FromIterator` is more commonly used implicitly via the\n+    /// `Iterator::collect` method:\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n@@ -1041,6 +1058,9 @@ pub trait FromIterator<A> {\n }\n \n /// Conversion into an `Iterator`\n+///\n+/// Implementing this trait allows you to use your type with Rust's `for` loop. See\n+/// the [module level documentation](../index.html) for more details.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n     /// The type of the elements being iterated\n@@ -1094,12 +1114,13 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n \n /// An object implementing random access indexing by `usize`\n ///\n-/// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n-/// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n-/// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n-/// after `it.next()` is called.\n+/// A `RandomAccessIterator` should be either infinite or a\n+/// `DoubleEndedIterator`.  Calling `next()` or `next_back()` on a\n+/// `RandomAccessIterator` reduces the indexable range accordingly. That is,\n+/// `it.idx(1)` will become `it.idx(0)` after `it.next()` is called.\n #[unstable(feature = \"core\",\n-           reason = \"not widely used, may be better decomposed into Index and ExactSizeIterator\")]\n+           reason = \"not widely used, may be better decomposed into Index \\\n+                     and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::usize::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n@@ -1144,13 +1165,15 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F> where\n     F: FnMut(&I::Item),\n {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n+impl<I> ExactSizeIterator for Rev<I>\n+    where I: ExactSizeIterator + DoubleEndedIterator {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F> where\n     F: FnMut(I::Item) -> B,\n {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n+impl<A, B> ExactSizeIterator for Zip<A, B>\n+    where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n #[derive(Clone)]\n@@ -1177,7 +1200,9 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n+impl<I> RandomAccessIterator for Rev<I>\n+    where I: DoubleEndedIterator + RandomAccessIterator\n+{\n     #[inline]\n     fn indexable(&self) -> usize { self.iter.indexable() }\n     #[inline]\n@@ -1244,10 +1269,10 @@ pub trait MultiplicativeIterator<A> {\n     ///\n     /// ```\n     /// # #![feature(core)]\n-    /// use std::iter::{count, MultiplicativeIterator};\n+    /// use std::iter::MultiplicativeIterator;\n     ///\n     /// fn factorial(n: usize) -> usize {\n-    ///     count(1, 1).take_while(|&i| i <= n).product()\n+    ///     (1..).take_while(|&i| i <= n).product()\n     /// }\n     /// assert!(factorial(0) == 1);\n     /// assert!(factorial(1) == 1);\n@@ -1280,7 +1305,8 @@ impl_multiplicative! { usize, 1 }\n impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }\n \n-/// `MinMaxResult` is an enum returned by `min_max`. See `Iterator::min_max` for more detail.\n+/// `MinMaxResult` is an enum returned by `min_max`. See `Iterator::min_max` for\n+/// more detail.\n #[derive(Clone, PartialEq, Debug)]\n #[unstable(feature = \"core\",\n            reason = \"unclear whether such a fine-grained result is widely useful\")]\n@@ -1291,15 +1317,17 @@ pub enum MinMaxResult<T> {\n     /// Iterator with one element, so the minimum and maximum are the same\n     OneElement(T),\n \n-    /// More than one element in the iterator, the first element is not larger than the second\n+    /// More than one element in the iterator, the first element is not larger\n+    /// than the second\n     MinMax(T, T)\n }\n \n impl<T: Clone> MinMaxResult<T> {\n-    /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n-    /// `None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n-    /// `Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\n-    /// performing this operation will make one clone of `x`.\n+    /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option`\n+    /// has variant `None` if and only if the `MinMaxResult` has variant\n+    /// `NoElements`. Otherwise variant `Some(x,y)` is returned where `x <= y`.\n+    /// If `MinMaxResult` has variant `OneElement(x)`, performing this operation\n+    /// will make one clone of `x`.\n     ///\n     /// # Examples\n     ///\n@@ -2511,7 +2539,7 @@ impl<A: Step> RangeFrom<A> {\n }\n \n #[allow(deprecated)]\n-impl<A: Step> ::ops::Range<A> {\n+impl<A: Step> ops::Range<A> {\n     /// Creates an iterator with the same range, but stepping by the\n     /// given amount at each iteration.\n     ///\n@@ -2544,26 +2572,6 @@ impl<A: Step> ::ops::Range<A> {\n     }\n }\n \n-/// An infinite iterator starting at `start` and advancing by `step` with each\n-/// iteration\n-#[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapters\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation and step_by\")]\n-pub type Counter<A> = StepBy<A, RangeFrom<A>>;\n-\n-/// Deprecated: use `(start..).step_by(step)` instead.\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapters\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use (start..).step_by(step) instead\")]\n-#[allow(deprecated)]\n-pub fn count<A>(start: A, step: A) -> Counter<A> {\n-    StepBy {\n-        range: RangeFrom { start: start },\n-        step_by: step,\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n     A: Clone,\n@@ -2584,137 +2592,41 @@ impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n     }\n }\n \n-/// An iterator over the range [start, stop)\n-#[allow(deprecated)]\n-#[derive(Clone)]\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n-pub struct Range<A> {\n-    state: A,\n-    stop: A,\n-    one: A,\n-}\n-\n-/// Deprecated: use `(start..stop)` instead.\n-#[inline]\n-#[unstable(feature = \"core\", reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use (start..stop) instead\")]\n-#[allow(deprecated)]\n-pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n-    Range {\n-        state: start,\n-        stop: stop,\n-        one: Int::one(),\n-    }\n-}\n-\n-// FIXME: #10414: Unfortunate type bound\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n-#[allow(deprecated)]\n-impl<A: Int + ToPrimitive> Iterator for Range<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        if self.state < self.stop {\n-            let result = self.state.clone();\n-            self.state = self.state + self.one;\n-            Some(result)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // This first checks if the elements are representable as i64. If they aren't, try u64 (to\n-        // handle cases like range(huge, huger)). We don't use usize/isize because the difference of\n-        // the i64/u64 might lie within their range.\n-        let bound = match self.state.to_i64() {\n-            Some(a) => {\n-                let sz = self.stop.to_i64().map(|b| b.checked_sub(a));\n-                match sz {\n-                    Some(Some(bound)) => bound.to_usize(),\n-                    _ => None,\n-                }\n-            },\n-            None => match self.state.to_u64() {\n-                Some(a) => {\n-                    let sz = self.stop.to_u64().map(|b| b.checked_sub(a));\n-                    match sz {\n-                        Some(Some(bound)) => bound.to_usize(),\n-                        _ => None\n-                    }\n-                },\n-                None => None\n-            }\n-        };\n-\n-        match bound {\n-            Some(b) => (b, Some(b)),\n-            // Standard fallback for unbounded/unrepresentable bounds\n-            None => (0, None)\n-        }\n-    }\n-}\n-\n-/// `Int` is required to ensure the range will be the same regardless of\n-/// the direction it is consumed.\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n-#[allow(deprecated)]\n-impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        if self.stop > self.state {\n-            self.stop = self.stop - self.one;\n-            Some(self.stop.clone())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n pub struct RangeInclusive<A> {\n-    range: Range<A>,\n+    range: ops::Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n+pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>\n+    where A: Step + One + Clone\n+{\n     RangeInclusive {\n-        range: range(start, stop),\n+        range: start..stop,\n         done: false,\n     }\n }\n \n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n+impl<A: Step + One + Clone> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n             Some(x) => Some(x),\n             None => {\n-                if !self.done && self.range.state == self.range.stop {\n+                if !self.done && self.range.start == self.range.end {\n                     self.done = true;\n-                    Some(self.range.stop.clone())\n+                    Some(self.range.end.clone())\n                 } else {\n                     None\n                 }\n@@ -2740,46 +2652,28 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n \n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n+impl<A> DoubleEndedIterator for RangeInclusive<A>\n+    where A: Step + One + Clone,\n+          for<'a> &'a A: Sub<Output=A>\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.range.stop > self.range.state {\n-            let result = self.range.stop.clone();\n-            self.range.stop = self.range.stop - self.range.one;\n+        if self.range.end > self.range.start {\n+            let result = self.range.end.clone();\n+            self.range.end = &self.range.end - &A::one();\n             Some(result)\n-        } else if !self.done && self.range.state == self.range.stop {\n+        } else if !self.done && self.range.start == self.range.end {\n             self.done = true;\n-            Some(self.range.stop.clone())\n+            Some(self.range.end.clone())\n         } else {\n             None\n         }\n     }\n }\n \n-/// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation and step_by\")]\n-pub type RangeStep<A> = StepBy<A, ::ops::Range<A>>;\n-\n-/// Deprecated: use `(start..stop).step_by(step)` instead.\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[deprecated(since = \"1.0.0-beta\",\n-             reason = \"use `(start..stop).step_by(step)` instead\")]\n-#[allow(deprecated)]\n-pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n-    StepBy {\n-        step_by: step,\n-        range: ::ops::Range { start: start, end: stop },\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n-impl<A: Step + Zero + Clone> Iterator for StepBy<A, ::ops::Range<A>> {\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     type Item = A;\n \n     #[inline]\n@@ -2882,13 +2776,13 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl ExactSizeIterator for ::ops::Range<$t> { }\n+        impl ExactSizeIterator for ops::Range<$t> { }\n     )*)\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n-impl<A: Step + One + Clone> Iterator for ::ops::Range<A> {\n+impl<A: Step + One + Clone> Iterator for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n@@ -2927,7 +2821,7 @@ range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n-impl<A: Step + One + Clone> DoubleEndedIterator for ::ops::Range<A> where\n+impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n     for<'a> &'a A: Sub<&'a A, Output = A>\n {\n     #[inline]\n@@ -2943,7 +2837,7 @@ impl<A: Step + One + Clone> DoubleEndedIterator for ::ops::Range<A> where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n-impl<A: Step + One> Iterator for ::ops::RangeFrom<A> {\n+impl<A: Step + One> Iterator for ops::RangeFrom<A> {\n     type Item = A;\n \n     #[inline]"}, {"sha": "5e8b7fba1f15c92e5dd53bdfefd6b3bd9a028a31", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -136,7 +136,6 @@ pub mod atomic;\n pub mod cell;\n pub mod char;\n pub mod panicking;\n-pub mod finally;\n pub mod iter;\n pub mod option;\n pub mod raw;"}, {"sha": "751bd7353e4cbba9d861b22c98c10419239997a4", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -66,10 +66,10 @@ macro_rules! assert {\n     );\n }\n \n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n+/// Asserts that two expressions are equal to each other.\n ///\n-/// On panic, this macro will print the values of the expressions.\n+/// On panic, this macro will print the values of the expressions with their\n+/// debug representations.\n ///\n /// # Examples\n ///\n@@ -84,10 +84,8 @@ macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n-                // check both directions of equality....\n-                if !((*left_val == *right_val) &&\n-                     (*right_val == *left_val)) {\n-                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                if !(*left_val == *right_val) {\n+                    panic!(\"assertion failed: `(left == right)` \\\n                            (left: `{:?}`, right: `{:?}`)\", *left_val, *right_val)\n                 }\n             }\n@@ -156,7 +154,7 @@ macro_rules! debug_assert_eq {\n \n /// Short circuiting evaluation on Err\n ///\n-/// `libstd` contains a more general `try!` macro that uses `FromError`.\n+/// `libstd` contains a more general `try!` macro that uses `From<E>`.\n #[macro_export]\n macro_rules! try {\n     ($e:expr) => ({\n@@ -233,7 +231,7 @@ macro_rules! writeln {\n /// ```\n /// # #![feature(core)]\n /// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n-///     for i in std::iter::count(0, 1) {\n+///     for i in 0.. {\n ///         if 3*i < i { panic!(\"u32 overflow\"); }\n ///         if x < 3*i { return i-1; }\n ///     }"}, {"sha": "f755c912fcd4a7a03e0de405e96e38797df3ac97", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -415,42 +415,6 @@ mod impls {\n     unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n }\n \n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<&'a ()>`\")]\n-#[lang=\"contravariant_lifetime\"]\n-pub struct ContravariantLifetime<'a>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(&'a ())>`\")]\n-#[lang=\"covariant_lifetime\"]\n-pub struct CovariantLifetime<'a>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<&'a ()>>`\")]\n-#[lang=\"invariant_lifetime\"]\n-pub struct InvariantLifetime<'a>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(T)>`\")]\n-#[lang=\"contravariant_type\"]\n-pub struct ContravariantType<T>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<T>`\")]\n-#[lang=\"covariant_type\"]\n-pub struct CovariantType<T>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<T>>`\")]\n-#[lang=\"invariant_type\"]\n-pub struct InvariantType<T>;\n-\n /// A marker trait indicates a type that can be reflected over. This\n /// trait is implemented for all types. Its purpose is to ensure that\n /// when you write a generic function that will employ reflection,\n@@ -487,9 +451,5 @@ pub struct InvariantType<T>;\n pub trait Reflect : MarkerTrait {\n }\n \n-#[cfg(stage0)]\n-impl<T> Reflect for T { }\n-\n-#[cfg(not(stage0))]\n impl Reflect for .. { }\n "}, {"sha": "249beb6295c0733be70e4f74806ee1fbe3c2ea90", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -173,11 +173,6 @@ pub unsafe fn zeroed<T>() -> T {\n #[inline]\n #[unstable(feature = \"filling_drop\")]\n pub unsafe fn dropped<T>() -> T {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    unsafe fn dropped_impl<T>() -> T { zeroed() }\n-\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     unsafe fn dropped_impl<T>() -> T { intrinsics::init_dropped() }\n \n@@ -337,38 +332,32 @@ macro_rules! repeat_u8_as_u64 {\n // But having the sign bit set is a pain, so 0x1d is probably better.\n //\n // And of course, 0x00 brings back the old world of zero'ing on drop.\n-#[cfg(not(stage0))] #[unstable(feature = \"filling_drop\")]\n+#[unstable(feature = \"filling_drop\")]\n pub const POST_DROP_U8: u8 = 0x1d;\n-#[cfg(not(stage0))] #[unstable(feature = \"filling_drop\")]\n+#[unstable(feature = \"filling_drop\")]\n pub const POST_DROP_U32: u32 = repeat_u8_as_u32!(POST_DROP_U8);\n-#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+#[unstable(feature = \"filling_drop\")]\n pub const POST_DROP_U64: u64 = repeat_u8_as_u64!(POST_DROP_U8);\n \n #[cfg(target_pointer_width = \"32\")]\n-#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+#[unstable(feature = \"filling_drop\")]\n pub const POST_DROP_USIZE: usize = POST_DROP_U32 as usize;\n #[cfg(target_pointer_width = \"64\")]\n-#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+#[unstable(feature = \"filling_drop\")]\n pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n \n-#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n-pub const POST_DROP_U8: u8 = 0;\n-#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n-pub const POST_DROP_U32: u32 = 0;\n-#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n-pub const POST_DROP_U64: u64 = 0;\n-#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n-pub const POST_DROP_USIZE: usize = 0;\n-\n-/// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n-///\n-/// This function will unsafely assume the pointer `src` is valid for `sizeof(U)` bytes by\n-/// transmuting `&T` to `&U` and then reading the `&U`. It will also unsafely create a copy of the\n-/// contained value instead of moving out of `src`.\n-///\n-/// It is not a compile-time error if `T` and `U` have different sizes, but it is highly encouraged\n-/// to only invoke this function where `T` and `U` have the same size. This function triggers\n-/// undefined behavior if `U` is larger than `T`.\n+/// Interprets `src` as `&U`, and then reads `src` without moving the contained\n+/// value.\n+///\n+/// This function will unsafely assume the pointer `src` is valid for\n+/// `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It\n+/// will also unsafely create a copy of the contained value instead of moving\n+/// out of `src`.\n+///\n+/// It is not a compile-time error if `T` and `U` have different sizes, but it\n+/// is highly encouraged to only invoke this function where `T` and `U` have the\n+/// same size. This function triggers undefined behavior if `U` is larger than\n+/// `T`.\n ///\n /// # Examples\n ///"}, {"sha": "a4829ed96b3530d6e81096d6f59594eed1a45381", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -46,7 +46,7 @@ use str::{FromStr, StrExt};\n /// intended to have wrapping semantics.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug)]\n-pub struct Wrapping<T>(pub T);\n+pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n #[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n pub mod wrapping;"}, {"sha": "a78eed8ae5fa843c65007fc8bb097cc9328d81d7", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -30,6 +30,8 @@ use intrinsics::{i16_mul_with_overflow, u16_mul_with_overflow};\n use intrinsics::{i32_mul_with_overflow, u32_mul_with_overflow};\n use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n+use ::{i8,i16,i32,i64,u8,u16,u32,u64};\n+\n #[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n #[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n pub trait WrappingOps {\n@@ -43,6 +45,12 @@ pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n     fn overflowing_sub(self, rhs: Self) -> (Self, bool);\n     fn overflowing_mul(self, rhs: Self) -> (Self, bool);\n+\n+    fn overflowing_div(self, rhs: Self) -> (Self, bool);\n+    fn overflowing_rem(self, rhs: Self) -> (Self, bool);\n+\n+    fn overflowing_shl(self, rhs: u32) -> (Self, bool);\n+    fn overflowing_shr(self, rhs: u32) -> (Self, bool);\n }\n \n macro_rules! sh_impl {\n@@ -184,6 +192,20 @@ macro_rules! wrapping_impl {\n \n wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n+mod shift_max {\n+    #![allow(non_upper_case_globals)]\n+\n+    pub const  i8: u32 = (1 << 3) - 1;\n+    pub const i16: u32 = (1 << 4) - 1;\n+    pub const i32: u32 = (1 << 5) - 1;\n+    pub const i64: u32 = (1 << 6) - 1;\n+\n+    pub const  u8: u32 = i8;\n+    pub const u16: u32 = i16;\n+    pub const u32: u32 = i32;\n+    pub const u64: u32 = i64;\n+}\n+\n macro_rules! overflowing_impl {\n     ($($t:ident)*) => ($(\n         impl OverflowingOps for $t {\n@@ -205,6 +227,34 @@ macro_rules! overflowing_impl {\n                     concat_idents!($t, _mul_with_overflow)(self, rhs)\n                 }\n             }\n+\n+            #[inline(always)]\n+            fn overflowing_div(self, rhs: $t) -> ($t, bool) {\n+                if self == $t::MIN && rhs == -1 {\n+                    (1, true)\n+                } else {\n+                    (self/rhs, false)\n+                }\n+            }\n+            #[inline(always)]\n+            fn overflowing_rem(self, rhs: $t) -> ($t, bool) {\n+                if self == $t::MIN && rhs == -1 {\n+                    (0, true)\n+                } else {\n+                    (self % rhs, false)\n+                }\n+            }\n+\n+            #[inline(always)]\n+            fn overflowing_shl(self, rhs: u32) -> ($t, bool) {\n+                (self << (rhs & self::shift_max::$t),\n+                 (rhs > self::shift_max::$t))\n+            }\n+            #[inline(always)]\n+            fn overflowing_shr(self, rhs: u32) -> ($t, bool) {\n+                (self >> (rhs & self::shift_max::$t),\n+                 (rhs > self::shift_max::$t))\n+            }\n         }\n     )*)\n }\n@@ -234,6 +284,26 @@ impl OverflowingOps for usize {\n             (res.0 as usize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_div(rhs as u64);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_rem(rhs as u64);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_shl(rhs);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_shr(rhs);\n+        (r as usize, f)\n+    }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n@@ -259,6 +329,26 @@ impl OverflowingOps for usize {\n             (res.0 as usize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_div(rhs as u32);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_rem(rhs as u32);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_shl(rhs);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_shr(rhs);\n+        (r as usize, f)\n+    }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n@@ -284,6 +374,26 @@ impl OverflowingOps for isize {\n             (res.0 as isize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_div(rhs as i64);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_rem(rhs as i64);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_shl(rhs);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_shr(rhs);\n+        (r as isize, f)\n+    }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n@@ -309,4 +419,24 @@ impl OverflowingOps for isize {\n             (res.0 as isize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_div(rhs as i32);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_rem(rhs as i32);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_shl(rhs);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_shr(rhs);\n+        (r as isize, f)\n+    }\n }"}, {"sha": "6db7c9bd99d9b08cb02fa3e12ca5d79e84bd695a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -154,8 +154,6 @@ use mem;\n use ops::FnOnce;\n use result::Result::{Ok, Err};\n use result::Result;\n-#[allow(deprecated)]\n-use slice::AsSlice;\n use slice;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n@@ -765,25 +763,6 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"core\",\n-           reason = \"waiting on the stability of the trait itself\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use the inherent method instead\")]\n-#[allow(deprecated)]\n-impl<T> AsSlice<T> for Option<T> {\n-    /// Convert from `Option<T>` to `&[T]` (without copying)\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        match *self {\n-            Some(ref x) => slice::ref_slice(x),\n-            None => {\n-                let result: &[_] = &[];\n-                result\n-            }\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     #[inline]"}, {"sha": "e60bc49408195644c331d56e35926db606000bb0", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -37,10 +37,11 @@ pub use char::CharExt;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use convert::{AsRef, AsMut, Into, From};\n-pub use iter::Extend;\n-pub use iter::{Iterator, DoubleEndedIterator};\n-pub use iter::{ExactSizeIterator};\n+pub use iter::{Iterator, DoubleEndedIterator, Extend, ExactSizeIterator};\n pub use option::Option::{self, Some, None};\n pub use result::Result::{self, Ok, Err};\n-pub use slice::{AsSlice, SliceExt};\n-pub use str::{Str, StrExt};\n+pub use slice::SliceExt;\n+pub use str::StrExt;\n+\n+#[allow(deprecated)] pub use slice::AsSlice;\n+#[allow(deprecated)] pub use str::Str;"}, {"sha": "ff51e25fcbf2535f9cf81a3d0129c7dc7aa556c3", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -157,21 +157,6 @@ pub fn null<T>() -> *const T { 0 as *const T }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n-/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be\n-/// `0`.\n-///\n-/// # Safety\n-///\n-/// Beyond accepting a raw pointer, this is unsafe because it will not drop the\n-/// contents of `dst`, and may be used to create invalid instances of `T`.\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"may play a larger role in std::ptr future extensions\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `write_bytes` instead\")]\n-pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n-    write_bytes(dst, 0, count);\n-}\n-\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitialising either. They may overlap, unlike `mem::swap` which is\n /// otherwise equivalent."}, {"sha": "47d1f3a1a3ccf1ab40ef385c921bd0c8e2f8b41c", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -64,19 +64,6 @@ pub struct Slice<T> {\n \n impl<T> Copy for Slice<T> {}\n \n-/// The representation of an old closure.\n-#[repr(C)]\n-#[derive(Copy)]\n-#[unstable(feature = \"core\")]\n-#[deprecated(reason = \"unboxed new closures do not have a universal representation; \\\n-                       `&Fn` (etc) trait objects should use `TraitObject` instead\",\n-             since= \"1.0.0\")]\n-#[allow(deprecated) /* for deriving Copy impl */]\n-pub struct Closure {\n-    pub code: *mut (),\n-    pub env: *mut (),\n-}\n-\n /// The representation of a trait object like `&SomeTrait`.\n ///\n /// This struct has the same layout as types like `&SomeTrait` and"}, {"sha": "d8856130fab33b1d794ede0a0a6f966f73196701", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -88,10 +88,6 @@ pub trait SliceExt {\n     fn len(&self) -> usize;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut Self::Item>;\n-    #[unstable(feature = \"core\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n@@ -263,12 +259,6 @@ impl<T> SliceExt for [T] {\n         if index < self.len() { Some(&mut self[index]) } else { None }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-    fn as_mut_slice(&mut self) -> &mut [T] { self }\n-\n     #[inline]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -1502,54 +1492,6 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n     transmute(RawSlice { data: p, len: len })\n }\n \n-/// Forms a slice from a pointer and a length.\n-///\n-/// The pointer given is actually a reference to the base of the slice. This\n-/// reference is used to give a concrete lifetime to tie the returned slice to.\n-/// Typically this should indicate that the slice is valid for as long as the\n-/// pointer itself is valid.\n-///\n-/// The `len` argument is the number of **elements**, not the number of bytes.\n-///\n-/// This function is unsafe as there is no guarantee that the given pointer is\n-/// valid for `len` elements, nor whether the lifetime provided is a suitable\n-/// lifetime for the returned slice.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(core)]\n-/// use std::slice;\n-///\n-/// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const usize;\n-/// let amt = 10;\n-/// unsafe {\n-///     let slice = slice::from_raw_buf(&ptr, amt);\n-/// }\n-/// ```\n-#[inline]\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use from_raw_parts\")]\n-pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: usize) -> &'a [T] {\n-    transmute(RawSlice { data: *p, len: len })\n-}\n-\n-/// Performs the same functionality as `from_raw_buf`, except that a mutable\n-/// slice is returned.\n-///\n-/// This function is unsafe for the same reasons as `from_raw_buf`, as well as\n-/// not being able to provide a non-aliasing guarantee of the returned mutable\n-/// slice.\n-#[inline]\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use from_raw_parts_mut\")]\n-pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: usize) -> &'a mut [T] {\n-    transmute(RawSlice { data: *p, len: len })\n-}\n-\n //\n // Submodules\n //"}, {"sha": "934c4515614efc52dc97d3890c60908c5f98e391", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -28,8 +28,6 @@ use iter::ExactSizeIterator;\n use iter::{Map, Iterator, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n-#[allow(deprecated)]\n-use num::Int;\n use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n@@ -243,78 +241,6 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n \n-/// Constructs a static string slice from a given raw pointer.\n-///\n-/// This function will read memory starting at `s` until it finds a 0, and then\n-/// transmute the memory up to that point as a string slice, returning the\n-/// corresponding `&'static str` value.\n-///\n-/// This function is unsafe because the caller must ensure the C string itself\n-/// has the static lifetime and that the memory `s` is valid up to and including\n-/// the first null byte.\n-///\n-/// # Panics\n-///\n-/// This function will panic if the string pointed to by `s` is not valid UTF-8.\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use std::ffi::c_str_to_bytes + str::from_utf8\")]\n-pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n-    let s = s as *const u8;\n-    let mut len: usize = 0;\n-    while *s.offset(len as isize) != 0 {\n-        len += 1;\n-    }\n-    let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n-    from_utf8(v).ok().expect(\"from_c_str passed invalid utf-8 data\")\n-}\n-\n-/// Something that can be used to compare against a character\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use `Pattern` instead\")]\n-// NB: Rather than removing it, make it private and move it into self::pattern\n-pub trait CharEq {\n-    /// Determine if the splitter should split at the given character\n-    fn matches(&mut self, char) -> bool;\n-    /// Indicate if this is only concerned about ASCII characters,\n-    /// which can allow for a faster implementation.\n-    fn only_ascii(&self) -> bool;\n-}\n-\n-#[allow(deprecated) /* for CharEq */ ]\n-impl CharEq for char {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { *self == c }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n-}\n-\n-#[allow(deprecated) /* for CharEq */ ]\n-impl<F> CharEq for F where F: FnMut(char) -> bool {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-#[allow(deprecated) /* for CharEq */ ]\n-impl<'a> CharEq for &'a [char] {\n-    #[inline]\n-    #[allow(deprecated) /* for CharEq */ ]\n-    fn matches(&mut self, c: char) -> bool {\n-        self.iter().any(|&m| { let mut m = m; m.matches(c) })\n-    }\n-\n-    #[inline]\n-    #[allow(deprecated) /* for CharEq */ ]\n-    fn only_ascii(&self) -> bool {\n-        self.iter().all(|m| m.only_ascii())\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for Utf8Error {\n     fn description(&self) -> &str {\n@@ -1047,22 +973,6 @@ impl<'a, P: Pattern<'a>> Iterator for MatchIndices<'a, P> {\n     }\n }\n \n-/// An iterator over the substrings of a string separated by a given\n-/// search string\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `Split` with a `&str`\")]\n-pub struct SplitStr<'a, P: Pattern<'a>>(Split<'a, P>);\n-#[allow(deprecated)]\n-impl<'a, P: Pattern<'a>> Iterator for SplitStr<'a, P> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn next(&mut self) -> Option<&'a str> {\n-        Iterator::next(&mut self.0)\n-    }\n-}\n-\n impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n     #[inline]\n     #[allow(dead_code)]\n@@ -1444,8 +1354,6 @@ pub trait StrExt {\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n-    #[allow(deprecated) /* for SplitStr */]\n-    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> usize;\n@@ -1565,12 +1473,6 @@ impl StrExt for str {\n         MatchIndices(pat.into_searcher(self))\n     }\n \n-    #[inline]\n-    #[allow(deprecated) /* for SplitStr */ ]\n-    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n-        SplitStr(self.split(pat))\n-    }\n-\n     #[inline]\n     fn lines(&self) -> Lines {\n         Lines { inner: self.split_terminator('\\n').0 }"}, {"sha": "922ab2c14a6b71d9b19980267af365f06e204f5b", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 125, "deletions": 43, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated) /* for CharEq */ ]\n-\n use prelude::*;\n-use super::CharEq;\n \n // Pattern\n \n@@ -228,6 +225,40 @@ pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n \n // Impl for a CharEq wrapper\n \n+#[doc(hidden)]\n+trait CharEq {\n+    fn matches(&mut self, char) -> bool;\n+    fn only_ascii(&self) -> bool;\n+}\n+\n+impl CharEq for char {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { *self == c }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n+}\n+\n+impl<F> CharEq for F where F: FnMut(char) -> bool {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { false }\n+}\n+\n+impl<'a> CharEq for &'a [char] {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool {\n+        self.iter().any(|&m| { let mut m = m; m.matches(c) })\n+    }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool {\n+        self.iter().all(|m| m.only_ascii())\n+    }\n+}\n+\n struct CharEqPattern<C: CharEq>(C);\n \n struct CharEqSearcher<'a, C: CharEq> {\n@@ -425,65 +456,116 @@ fn str_search_step<F, G>(mut m: &mut StrSearcher,\n     }\n }\n \n-macro_rules! associated_items {\n-    ($t:ty, $s:ident, $e:expr) => {\n-        // FIXME: #22463\n-        //type Searcher = $t;\n-\n-        fn into_searcher(self, haystack: &'a str) -> $t {\n-            let $s = self;\n-            $e.into_searcher(haystack)\n+macro_rules! char_eq_pattern_impl {\n+    ($wrapper:ty, $wrapper_ident:ident) => {\n+        fn into_searcher(self, haystack: &'a str) -> $wrapper {\n+            $wrapper_ident(CharEqPattern(self).into_searcher(haystack))\n         }\n-\n         #[inline]\n         fn is_contained_in(self, haystack: &'a str) -> bool {\n-            let $s = self;\n-            $e.is_contained_in(haystack)\n+            CharEqPattern(self).is_contained_in(haystack)\n         }\n-\n         #[inline]\n         fn is_prefix_of(self, haystack: &'a str) -> bool {\n-            let $s = self;\n-            $e.is_prefix_of(haystack)\n+            CharEqPattern(self).is_prefix_of(haystack)\n         }\n-\n-        // FIXME: #21750\n-        /*#[inline]\n+        #[inline]\n         fn is_suffix_of(self, haystack: &'a str) -> bool\n-            where $t: ReverseSearcher<'a>\n+            where $wrapper: ReverseSearcher<'a>\n         {\n-            let $s = self;\n-            $e.is_suffix_of(haystack)\n-        }*/\n+            CharEqPattern(self).is_suffix_of(haystack)\n+        }\n     }\n }\n \n-// CharEq delegation impls\n+// Pattern for char\n \n-/// Searches for chars that are equal to a given char\n impl<'a> Pattern<'a> for char {\n-    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n-    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n-                      s, CharEqPattern(s));\n+    type Searcher = CharSearcher<'a>;\n+    char_eq_pattern_impl!(CharSearcher<'a>, CharSearcher);\n+}\n+\n+pub struct CharSearcher<'a>(CharEqSearcher<'a, char>);\n+\n+unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n+    #[inline]\n+    fn haystack(&self) -> &'a str { self.0.haystack() }\n+    #[inline]\n+    fn next(&mut self) -> SearchStep { self.0.next() }\n+}\n+unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n }\n+impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n+\n+// Pattern for &[char]\n \n-/// Searches for chars that are equal to any of the chars in the array\n impl<'a, 'b> Pattern<'a> for &'b [char] {\n-    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n-    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n-                      s, CharEqPattern(s));\n+    type Searcher = CharSliceSearcher<'a, 'b>;\n+    char_eq_pattern_impl!(CharSliceSearcher<'a, 'b>, CharSliceSearcher);\n }\n \n-/// A convenience impl that delegates to the impl for `&str`\n-impl<'a, 'b> Pattern<'a> for &'b &'b str {\n-    type Searcher =   <&'b str as Pattern<'a>>::Searcher;\n-    associated_items!(<&'b str as Pattern<'a>>::Searcher,\n-                      s, (*s));\n+pub struct CharSliceSearcher<'a, 'b>(CharEqSearcher<'a, &'b [char]>);\n+\n+unsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n+    #[inline]\n+    fn haystack(&self) -> &'a str { self.0.haystack() }\n+    #[inline]\n+    fn next(&mut self) -> SearchStep { self.0.next() }\n+}\n+unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+}\n+impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n+\n+// Pattern for predicates\n+\n+impl<'a, F: FnMut(char) -> bool> Pattern<'a> for F {\n+    type Searcher = CharPredSearcher<'a, F>;\n+    char_eq_pattern_impl!(CharPredSearcher<'a, F>, CharPredSearcher);\n+}\n+\n+pub struct CharPredSearcher<'a, F: FnMut(char) -> bool>(CharEqSearcher<'a, F>);\n+\n+unsafe impl<'a, F> Searcher<'a> for CharPredSearcher<'a, F>\n+    where F: FnMut(char) -> bool\n+{\n+    #[inline]\n+    fn haystack(&self) -> &'a str { self.0.haystack() }\n+    #[inline]\n+    fn next(&mut self) -> SearchStep { self.0.next() }\n+}\n+unsafe impl<'a, F> ReverseSearcher<'a> for CharPredSearcher<'a, F>\n+    where F: FnMut(char) -> bool\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n }\n+impl<'a, F> DoubleEndedSearcher<'a> for CharPredSearcher<'a, F>\n+    where F: FnMut(char) -> bool\n+{}\n \n-/// Searches for chars that match the given predicate\n-impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n-    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n-    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n-                      s, CharEqPattern(s));\n+// Pattern for &&str\n+\n+impl<'a, 'b> Pattern<'a> for &'b &'b str {\n+    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n+    #[inline]\n+    fn into_searcher(self, haystack: &'a str)\n+                     -> <&'b str as Pattern<'a>>::Searcher {\n+        (*self).into_searcher(haystack)\n+    }\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        (*self).is_contained_in(haystack)\n+    }\n+    #[inline]\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        (*self).is_prefix_of(haystack)\n+    }\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool {\n+        (*self).is_suffix_of(haystack)\n+    }\n }"}, {"sha": "85dd10390038fadc92ac4e3faf3d260d029497d3", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -59,15 +59,13 @@ fn double_imm_borrow() {\n fn no_mut_then_imm_borrow() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow_mut();\n-    assert!(x.try_borrow().is_none());\n     assert_eq!(x.borrow_state(), BorrowState::Writing);\n }\n \n #[test]\n fn no_imm_then_borrow_mut() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow();\n-    assert!(x.try_borrow_mut().is_none());\n     assert_eq!(x.borrow_state(), BorrowState::Reading);\n }\n \n@@ -76,7 +74,6 @@ fn no_double_borrow_mut() {\n     let x = RefCell::new(0);\n     assert_eq!(x.borrow_state(), BorrowState::Unused);\n     let _b1 = x.borrow_mut();\n-    assert!(x.try_borrow_mut().is_none());\n     assert_eq!(x.borrow_state(), BorrowState::Writing);\n }\n \n@@ -105,7 +102,7 @@ fn double_borrow_single_release_no_borrow_mut() {\n     {\n         let _b2 = x.borrow();\n     }\n-    assert!(x.try_borrow_mut().is_none());\n+    assert_eq!(x.borrow_state(), BorrowState::Reading);\n }\n \n #[test]\n@@ -122,14 +119,14 @@ fn clone_ref_updates_flag() {\n     let x = RefCell::new(0);\n     {\n         let b1 = x.borrow();\n-        assert!(x.try_borrow_mut().is_none());\n+        assert_eq!(x.borrow_state(), BorrowState::Reading);\n         {\n             let _b2 = clone_ref(&b1);\n-            assert!(x.try_borrow_mut().is_none());\n+            assert_eq!(x.borrow_state(), BorrowState::Reading);\n         }\n-        assert!(x.try_borrow_mut().is_none());\n+        assert_eq!(x.borrow_state(), BorrowState::Reading);\n     }\n-    assert!(x.try_borrow_mut().is_some());\n+    assert_eq!(x.borrow_state(), BorrowState::Unused);\n }\n \n #[test]"}, {"sha": "2a48395271db3804ccb20a0b0c6be55bc67e72f4", "filename": "src/libcoretest/finally.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use core::finally::{try_finally, Finally};\n-use std::thread;\n-\n-#[test]\n-fn test_success() {\n-    let mut i = 0;\n-    try_finally(\n-        &mut i, (),\n-        |i, ()| {\n-            *i = 10;\n-        },\n-        |i| {\n-            assert!(!thread::panicking());\n-            assert_eq!(*i, 10);\n-            *i = 20;\n-        });\n-    assert_eq!(i, 20);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_fail() {\n-    let mut i = 0;\n-    try_finally(\n-        &mut i, (),\n-        |i, ()| {\n-            *i = 10;\n-            panic!();\n-        },\n-        |i| {\n-            assert!(thread::panicking());\n-            assert_eq!(*i, 10);\n-        })\n-}\n-\n-#[test]\n-fn test_retval() {\n-    let mut closure = || 10;\n-    // FIXME(#16640) `: i32` annotation shouldn't be necessary\n-    let i: i32 = closure.finally(|| { });\n-    assert_eq!(i, 10);\n-}\n-\n-#[test]\n-fn test_compact() {\n-    fn do_some_fallible_work() {}\n-    fn but_always_run_this_function() { }\n-    let mut f = do_some_fallible_work;\n-    f.finally(but_always_run_this_function);\n-}"}, {"sha": "af80d347f028e02b66d4b8c572993c9b4d5edda4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -72,7 +72,7 @@ fn test_multi_iter() {\n \n #[test]\n fn test_counter_from_iter() {\n-    let it = count(0, 5).take(10);\n+    let it = (0..).step_by(5).take(10);\n     let xs: Vec<isize> = FromIterator::from_iter(it);\n     assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n@@ -90,7 +90,7 @@ fn test_iterator_chain() {\n     }\n     assert_eq!(i, expected.len());\n \n-    let ys = count(30, 10).take(4);\n+    let ys = (30..).step_by(10).take(4);\n     let it = xs.iter().cloned().chain(ys);\n     let mut i = 0;\n     for x in it {\n@@ -102,7 +102,7 @@ fn test_iterator_chain() {\n \n #[test]\n fn test_filter_map() {\n-    let it = count(0, 1).take(10)\n+    let it = (0..).step_by(1).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n     assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n@@ -244,7 +244,7 @@ fn test_iterator_scan() {\n fn test_iterator_flat_map() {\n     let xs = [0, 3, 6];\n     let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    let it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n+    let it = xs.iter().flat_map(|&x| (x..).step_by(1).take(3));\n     let mut i = 0;\n     for x in it {\n         assert_eq!(x, ys[i]);\n@@ -291,13 +291,13 @@ fn test_unfoldr() {\n #[test]\n fn test_cycle() {\n     let cycle_len = 3;\n-    let it = count(0, 1).take(cycle_len).cycle();\n+    let it = (0..).step_by(1).take(cycle_len).cycle();\n     assert_eq!(it.size_hint(), (usize::MAX, None));\n     for (i, x) in it.take(100).enumerate() {\n         assert_eq!(i % cycle_len, x);\n     }\n \n-    let mut it = count(0, 1).take(0).cycle();\n+    let mut it = (0..).step_by(1).take(0).cycle();\n     assert_eq!(it.size_hint(), (0, Some(0)));\n     assert_eq!(it.next(), None);\n }\n@@ -360,7 +360,7 @@ fn test_iterator_min() {\n \n #[test]\n fn test_iterator_size_hint() {\n-    let c = count(0, 1);\n+    let c = (0..).step_by(1);\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let v2 = &[10, 11, 12];\n     let vi = v.iter();"}, {"sha": "7ae0dcbb5f9d4b7cae3fda5196908395db025ead", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -39,7 +39,6 @@ mod atomic;\n mod cell;\n mod char;\n mod cmp;\n-mod finally;\n mod fmt;\n mod hash;\n mod iter;"}, {"sha": "5bc08376d257c5ceff5a7e2b1a722bbcdbc15d45", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -103,7 +103,7 @@ fn test_transmute() {\n     }\n \n     unsafe {\n-        assert_eq!([76], transmute::<_, Vec<u8>>(\"L\".to_string()));\n+        assert_eq!(transmute::<_, Vec<u8>>(\"L\".to_string()), [76]);\n     }\n }\n "}, {"sha": "e3eff6e7512ecf6d3c08167ac809fd5e49ea6552", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -20,7 +20,7 @@ mod tests {\n     fn test_overflows() {\n         assert!(MAX > 0);\n         assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n+        assert!((MIN + MAX).wrapping_add(1) == 0);\n     }\n \n     #[test]"}, {"sha": "c935b5545740c6d8c6b8b8ba438fb069f93ede75", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -163,9 +163,9 @@ fn starts_short_long() {\n \n #[test]\n fn contains_weird_cases() {\n-    assert!(\"* \\t\".contains_char(' '));\n-    assert!(!\"* \\t\".contains_char('?'));\n-    assert!(!\"* \\t\".contains_char('\\u{1F4A9}'));\n+    assert!(\"* \\t\".contains(' '));\n+    assert!(!\"* \\t\".contains('?'));\n+    assert!(!\"* \\t\".contains('\\u{1F4A9}'));\n }\n \n #[test]\n@@ -347,11 +347,11 @@ malesuada sollicitudin quam eu fermentum!\");\n     make_test!(chars_count, s, s.chars().count());\n \n     make_test!(contains_bang_str, s, s.contains(\"!\"));\n-    make_test!(contains_bang_char, s, s.contains_char('!'));\n+    make_test!(contains_bang_char, s, s.contains('!'));\n \n     make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n \n-    make_test!(split_str_a_str, s, s.split_str(\"a\").count());\n+    make_test!(split_a_str, s, s.split(\"a\").count());\n \n     make_test!(trim_ascii_char, s, {\n         use std::ascii::AsciiExt;\n@@ -368,18 +368,18 @@ malesuada sollicitudin quam eu fermentum!\");\n \n     make_test!(find_underscore_char, s, s.find('_'));\n     make_test!(rfind_underscore_char, s, s.rfind('_'));\n-    make_test!(find_underscore_str, s, s.find_str(\"_\"));\n+    make_test!(find_underscore_str, s, s.find(\"_\"));\n \n     make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n     make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n-    make_test!(find_zzz_str, s, s.find_str(\"\\u{1F4A4}\"));\n+    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n \n     make_test!(split_space_char, s, s.split(' ').count());\n     make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n \n     make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n     make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n \n-    make_test!(split_str_space_str, s, s.split_str(\" \").count());\n-    make_test!(split_str_ad_str, s, s.split_str(\"ad\").count());\n+    make_test!(split_space_str, s, s.split(\" \").count());\n+    make_test!(split_ad_str, s, s.split(\"ad\").count());\n }"}, {"sha": "a7be6a7fcf07a8550e31481b47fe8cb7049a5e40", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -446,7 +446,7 @@ mod tests {\n \n     fn same(fmt: &'static str, p: &[Piece<'static>]) {\n         let parser = Parser::new(fmt);\n-        assert!(p == parser.collect::<Vec<Piece<'static>>>());\n+        assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n     }\n \n     fn fmtdflt() -> FormatSpec<'static> {"}, {"sha": "74be96235d2d767918f2a3b91bcf5ad7e780eec2", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -84,7 +84,7 @@\n //!\n //!     fn edges(&'a self) -> dot::Edges<'a,Ed> {\n //!         let &Edges(ref edges) = self;\n-//!         edges.as_slice().into_cow()\n+//!         (&edges[..]).into_cow()\n //!     }\n //!\n //!     fn source(&self, e: &Ed) -> Nd { let &(s,_) = e; s }"}, {"sha": "44187a4fc99429002d292e679fb4af77bc5260d7", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -198,7 +198,7 @@ impl Rand for ChaChaRng {\n         for word in &mut key {\n             *word = other.gen();\n         }\n-        SeedableRng::from_seed(key.as_slice())\n+        SeedableRng::from_seed(&key[..])\n     }\n }\n "}, {"sha": "15d3d981eb5c0c79fd565e7e33ecbcc3aea19c8c", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -154,7 +154,7 @@ pub trait Rng : Sized {\n     ///\n     /// let mut v = [0; 13579];\n     /// thread_rng().fill_bytes(&mut v);\n-    /// println!(\"{:?}\", v.as_slice());\n+    /// println!(\"{:?}\", &v[..]);\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n         // this could, in theory, be done by transmuting dest to a\n@@ -310,9 +310,9 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// let mut y = [1, 2, 3];\n     /// rng.shuffle(&mut y);\n-    /// println!(\"{:?}\", y.as_slice());\n+    /// println!(\"{:?}\", y);\n     /// rng.shuffle(&mut y);\n-    /// println!(\"{:?}\", y.as_slice());\n+    /// println!(\"{:?}\", y);\n     /// ```\n     fn shuffle<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();"}, {"sha": "3e91b98877062cc5f83a3288774f69c22527460e", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -123,7 +123,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(io)]\n #![feature(core)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -862,8 +861,8 @@ pub mod writer {\n         } else if 0x100 <= n && n < NUM_TAGS {\n             w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n         } else {\n-            Err(io::Error::new(io::ErrorKind::Other, \"invalid tag\",\n-                               Some(n.to_string())))\n+            Err(io::Error::new(io::ErrorKind::Other,\n+                               &format!(\"invalid tag: {}\", n)[..]))\n         }\n     }\n \n@@ -876,7 +875,7 @@ pub mod writer {\n             4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8,\n                             (n >> 8) as u8, n as u8]),\n             _ => Err(io::Error::new(io::ErrorKind::Other,\n-                                    \"isize too big\", Some(n.to_string())))\n+                                    &format!(\"isize too big: {}\", n)[..]))\n         }\n     }\n \n@@ -885,8 +884,8 @@ pub mod writer {\n         if n < 0x4000 { return write_sized_vuint(w, n, 2); }\n         if n < 0x200000 { return write_sized_vuint(w, n, 3); }\n         if n < 0x10000000 { return write_sized_vuint(w, n, 4); }\n-        Err(io::Error::new(io::ErrorKind::Other, \"isize too big\",\n-                           Some(n.to_string())))\n+        Err(io::Error::new(io::ErrorKind::Other,\n+                           &format!(\"isize too big: {}\", n)[..]))\n     }\n \n     impl<'a> Encoder<'a> {\n@@ -1077,8 +1076,8 @@ pub mod writer {\n                 self.wr_tagged_raw_u32(EsSub32 as usize, v)\n             } else {\n                 Err(io::Error::new(io::ErrorKind::Other,\n-                                   \"length or variant id too big\",\n-                                   Some(v.to_string())))\n+                                   &format!(\"length or variant id too big: {}\",\n+                                            v)[..]))\n             }\n         }\n "}, {"sha": "0a29ed90ad46100d863d69a2e799c34000632a69", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -68,6 +68,8 @@ register_diagnostics! {\n     E0019,\n     E0020,\n     E0022,\n+    E0079, // enum variant: expected signed integer constant\n+    E0080, // enum variant: constant evaluation error\n     E0109,\n     E0110,\n     E0133,\n@@ -128,7 +130,8 @@ register_diagnostics! {\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n-    E0316 // nested quantification of lifetimes\n+    E0316, // nested quantification of lifetimes\n+    E0370  // discriminant overflow\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "b3ad96c4b5f167d7d68856d96bf1e69634829c1e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -37,11 +37,9 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(io)]\n #![feature(path_ext)]\n #![feature(str_words)]\n #![feature(str_char)]\n-#![feature(convert)]\n #![feature(into_cow)]\n #![feature(slice_patterns)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "b6061f39233d20b26d2f7a11535223310f67c192", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -1197,7 +1197,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(ty) = tcx.node_types.borrow().get(&id) {\n+    if let Some(ty) = tcx.node_types().get(&id) {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_ty(ecx, *ty);\n@@ -1884,7 +1884,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let ty = val_dsr.read_ty(dcx);\n                         debug!(\"inserting ty for node {}: {}\",\n                                id, ty_to_string(dcx.tcx, ty));\n-                        dcx.tcx.node_types.borrow_mut().insert(id, ty);\n+                        dcx.tcx.node_type_insert(id, ty);\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {"}, {"sha": "e3e5efc53c7decdca8253aab72db0ada53beea16", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 338, "deletions": 112, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,6 +13,8 @@\n \n pub use self::const_val::*;\n \n+use self::ErrKind::*;\n+\n use metadata::csearch;\n use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n@@ -27,6 +29,7 @@ use syntax::{ast_map, ast_util, codemap};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n+use std::num::ToPrimitive;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::{i8, i16, i32, i64};\n@@ -234,6 +237,7 @@ pub enum ErrKind {\n     NotOnStruct,\n     NotOnTuple,\n \n+    NegateWithOverflow(i64),\n     AddiWithOverflow(i64, i64),\n     SubiWithOverflow(i64, i64),\n     MuliWithOverflow(i64, i64),\n@@ -244,6 +248,8 @@ pub enum ErrKind {\n     DivideWithOverflow,\n     ModuloByZero,\n     ModuloWithOverflow,\n+    ShiftLeftWithOverflow,\n+    ShiftRightWithOverflow,\n     MissingStructField,\n     NonConstPath,\n     ExpectedConstTuple,\n@@ -257,6 +263,7 @@ pub enum ErrKind {\n impl ConstEvalErr {\n     pub fn description(&self) -> Cow<str> {\n         use self::ErrKind::*;\n+\n         match self.kind {\n             CannotCast => \"can't cast this type\".into_cow(),\n             CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n@@ -275,6 +282,7 @@ impl ConstEvalErr {\n             NotOnStruct => \"not on struct\".into_cow(),\n             NotOnTuple => \"not on tuple\".into_cow(),\n \n+            NegateWithOverflow(..) => \"attempted to negate with overflow\".into_cow(),\n             AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n             SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n             MuliWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n@@ -285,6 +293,8 @@ impl ConstEvalErr {\n             DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n             ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n             ModuloWithOverflow   => \"attempted remainder with overflow\".into_cow(),\n+            ShiftLeftWithOverflow => \"attempted left shift with overflow\".into_cow(),\n+            ShiftRightWithOverflow => \"attempted right shift with overflow\".into_cow(),\n             MissingStructField  => \"nonexistent struct field\".into_cow(),\n             NonConstPath        => \"non-constant path in constant expr\".into_cow(),\n             ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n@@ -297,57 +307,294 @@ impl ConstEvalErr {\n     }\n }\n \n+pub type EvalResult = Result<const_val, ConstEvalErr>;\n+pub type CastResult = Result<const_val, ErrKind>;\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum IntTy { I8, I16, I32, I64 }\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum UintTy { U8, U16, U32, U64 }\n+\n+impl IntTy {\n+    pub fn from(tcx: &ty::ctxt, t: ast::IntTy) -> IntTy {\n+        let t = if let ast::TyIs = t {\n+            tcx.sess.target.int_type\n+        } else {\n+            t\n+        };\n+        match t {\n+            ast::TyIs => unreachable!(),\n+            ast::TyI8  => IntTy::I8,\n+            ast::TyI16 => IntTy::I16,\n+            ast::TyI32 => IntTy::I32,\n+            ast::TyI64 => IntTy::I64,\n+        }\n+    }\n+}\n+\n+impl UintTy {\n+    pub fn from(tcx: &ty::ctxt, t: ast::UintTy) -> UintTy {\n+        let t = if let ast::TyUs = t {\n+            tcx.sess.target.uint_type\n+        } else {\n+            t\n+        };\n+        match t {\n+            ast::TyUs => unreachable!(),\n+            ast::TyU8  => UintTy::U8,\n+            ast::TyU16 => UintTy::U16,\n+            ast::TyU32 => UintTy::U32,\n+            ast::TyU64 => UintTy::U64,\n+        }\n+    }\n+}\n+\n macro_rules! signal {\n-    ($e:expr, $ctor:ident) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor })\n+    ($e:expr, $exn:expr) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n+    }\n+}\n+\n+// The const_{int,uint}_checked_{neg,add,sub,mul,div,shl,shr} family\n+// of functions catch and signal overflow errors during constant\n+// evaluation.\n+//\n+// They all take the operator's arguments (`a` and `b` if binary), the\n+// overall expression (`e`) and, if available, whole expression's\n+// concrete type (`opt_ety`).\n+//\n+// If the whole expression's concrete type is None, then this is a\n+// constant evaluation happening before type check (e.g. in the check\n+// to confirm that a pattern range's left-side is not greater than its\n+// right-side). We do not do arithmetic modulo the type's bitwidth in\n+// such a case; we just do 64-bit arithmetic and assume that later\n+// passes will do it again with the type information, and thus do the\n+// overflow checks then.\n+\n+pub fn const_int_checked_neg<'a>(\n+    a: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+\n+    let (min,max) = match opt_ety {\n+        // (-i8::MIN is itself not an i8, etc, but this is an easy way\n+        // to allow literals to pass the check. Of course that does\n+        // not work for i64::MIN.)\n+        Some(IntTy::I8) =>  (-(i8::MAX as i64), -(i8::MIN as i64)),\n+        Some(IntTy::I16) => (-(i16::MAX as i64), -(i16::MIN as i64)),\n+        Some(IntTy::I32) => (-(i32::MAX as i64), -(i32::MIN as i64)),\n+        None | Some(IntTy::I64) => (-i64::MAX, -(i64::MIN+1)),\n     };\n \n-    ($e:expr, $ctor:ident($($arg:expr),*)) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor($($arg),*) })\n+    let oflo = a < min || a > max;\n+    if oflo {\n+        signal!(e, NegateWithOverflow(a));\n+    } else {\n+        Ok(const_int(-a))\n+    }\n+}\n+\n+pub fn const_uint_checked_neg<'a>(\n+    a: u64, _e: &'a Expr, _opt_ety: Option<UintTy>) -> EvalResult {\n+    // This always succeeds, and by definition, returns `(!a)+1`.\n+    Ok(const_uint(-a))\n+}\n+\n+macro_rules! overflow_checking_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident,\n+     lhs: $to_8_lhs:ident $to_16_lhs:ident $to_32_lhs:ident,\n+     rhs: $to_8_rhs:ident $to_16_rhs:ident $to_32_rhs:ident $to_64_rhs:ident,\n+     $EnumTy:ident $T8: ident $T16: ident $T32: ident $T64: ident,\n+     $result_type: ident) => { {\n+        let (a,b,opt_ety) = ($a,$b,$ety);\n+        match opt_ety {\n+            Some($EnumTy::$T8) => match (a.$to_8_lhs(), b.$to_8_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            Some($EnumTy::$T16) => match (a.$to_16_lhs(), b.$to_16_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            Some($EnumTy::$T32) => match (a.$to_32_lhs(), b.$to_32_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            None | Some($EnumTy::$T64) => match b.$to_64_rhs() {\n+                Some(b) => a.$overflowing_op(b),\n+                None => (0, true),\n+            }\n+        }\n+    } }\n+}\n+\n+macro_rules! int_arith_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_i8 to_i16 to_i32,\n+            rhs: to_i8 to_i16 to_i32 to_i64, IntTy I8 I16 I32 I64, i64)\n+    }\n+}\n+\n+macro_rules! uint_arith_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_u8 to_u16 to_u32,\n+            rhs: to_u8 to_u16 to_u32 to_u64, UintTy U8 U16 U32 U64, u64)\n+    }\n+}\n+\n+macro_rules! int_shift_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_i8 to_i16 to_i32,\n+            rhs: to_u32 to_u32 to_u32 to_u32, IntTy I8 I16 I32 I64, i64)\n     }\n }\n \n-fn checked_add_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, AddiWithOverflow(a, b)) }\n+macro_rules! uint_shift_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_u8 to_u16 to_u32,\n+            rhs: to_u32 to_u32 to_u32 to_u32, UintTy U8 U16 U32 U64, u64)\n+    }\n }\n-fn checked_sub_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, SubiWithOverflow(a, b)) }\n+\n+macro_rules! pub_fn_checked_op {\n+    {$fn_name:ident ($a:ident : $a_ty:ty, $b:ident : $b_ty:ty,.. $WhichTy:ident) {\n+        $ret_oflo_body:ident $overflowing_op:ident\n+            $const_ty:ident $signal_exn:expr\n+    }} => {\n+        pub fn $fn_name<'a>($a: $a_ty,\n+                            $b: $b_ty,\n+                            e: &'a Expr,\n+                            opt_ety: Option<$WhichTy>) -> EvalResult {\n+            let (ret, oflo) = $ret_oflo_body!($a, $b, opt_ety, $overflowing_op);\n+            if !oflo { Ok($const_ty(ret)) } else { signal!(e, $signal_exn) }\n+        }\n+    }\n }\n-fn checked_mul_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, MuliWithOverflow(a, b)) }\n+\n+pub_fn_checked_op!{ const_int_checked_add(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_add const_int AddiWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_sub(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_sub const_int SubiWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_mul(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_mul const_int MuliWithOverflow(a, b)\n+}}\n+\n+pub fn const_int_checked_div<'a>(\n+    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+    if b == 0 { signal!(e, DivideByZero); }\n+    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_div);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, DivideWithOverflow) }\n }\n \n-fn checked_add_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, AdduWithOverflow(a, b)) }\n+pub fn const_int_checked_rem<'a>(\n+    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+    if b == 0 { signal!(e, ModuloByZero); }\n+    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_rem);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, ModuloWithOverflow) }\n }\n-fn checked_sub_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, SubuWithOverflow(a, b)) }\n+\n+pub_fn_checked_op!{ const_int_checked_shl(a: i64, b: i64,.. IntTy) {\n+           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shl_via_uint(a: i64, b: u64,.. IntTy) {\n+           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shr(a: i64, b: i64,.. IntTy) {\n+           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shr_via_uint(a: i64, b: u64,.. IntTy) {\n+           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_add(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_add const_uint AdduWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_sub(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_sub const_uint SubuWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_mul(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_mul const_uint MuluWithOverflow(a, b)\n+}}\n+\n+pub fn const_uint_checked_div<'a>(\n+    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n+    if b == 0 { signal!(e, DivideByZero); }\n+    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_div);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, DivideWithOverflow) }\n }\n-fn checked_mul_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, MuluWithOverflow(a, b)) }\n+\n+pub fn const_uint_checked_rem<'a>(\n+    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n+    if b == 0 { signal!(e, ModuloByZero); }\n+    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_rem);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, ModuloWithOverflow) }\n }\n \n+pub_fn_checked_op!{ const_uint_checked_shl(a: u64, b: u64,.. UintTy) {\n+           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shl_via_int(a: u64, b: i64,.. UintTy) {\n+           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shr(a: u64, b: u64,.. UintTy) {\n+           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n+           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+}}\n \n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n-                                     ty_hint: Option<Ty<'tcx>>)\n-                                     -> Result<const_val, ConstEvalErr> {\n+                                     ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n \n+    // If type of expression itself is int or uint, normalize in these\n+    // bindings so that isize/usize is mapped to a type with an\n+    // inherently known bitwidth.\n+    let expr_int_type = ety.and_then(|ty| {\n+        if let ty::ty_int(t) = ty.sty {\n+            Some(IntTy::from(tcx, t)) } else { None }\n+    });\n+    let expr_uint_type = ety.and_then(|ty| {\n+        if let ty::ty_uint(t) = ty.sty {\n+            Some(UintTy::from(tcx, t)) } else { None }\n+    });\n+\n     let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n           const_float(f) => const_float(-f),\n-          const_int(i) => const_int(-i),\n-          const_uint(i) => const_uint(-i),\n+          const_int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n+          const_uint(n) => try!(const_uint_checked_neg(n, e, expr_uint_type)),\n           const_str(_) => signal!(e, NegateOnString),\n           const_bool(_) => signal!(e, NegateOnBoolean),\n           const_binary(_) => signal!(e, NegateOnBinary),\n@@ -391,51 +638,17 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n           }\n           (const_int(a), const_int(b)) => {\n-            let is_a_min_value = || {\n-                let int_ty = match ty::expr_ty_opt(tcx, e).map(|ty| &ty.sty) {\n-                    Some(&ty::ty_int(int_ty)) => int_ty,\n-                    _ => return false\n-                };\n-                let int_ty = if let ast::TyIs = int_ty {\n-                    tcx.sess.target.int_type\n-                } else {\n-                    int_ty\n-                };\n-                match int_ty {\n-                    ast::TyI8 => (a as i8) == i8::MIN,\n-                    ast::TyI16 =>  (a as i16) == i16::MIN,\n-                    ast::TyI32 =>  (a as i32) == i32::MIN,\n-                    ast::TyI64 =>  (a as i64) == i64::MIN,\n-                    ast::TyIs => unreachable!()\n-                }\n-            };\n             match op.node {\n-              ast::BiAdd => try!(checked_add_int(e, a, b)),\n-              ast::BiSub => try!(checked_sub_int(e, a, b)),\n-              ast::BiMul => try!(checked_mul_int(e, a, b)),\n-              ast::BiDiv => {\n-                  if b == 0 {\n-                      signal!(e, DivideByZero);\n-                  } else if b == -1 && is_a_min_value() {\n-                      signal!(e, DivideWithOverflow);\n-                  } else {\n-                      const_int(a / b)\n-                  }\n-              }\n-              ast::BiRem => {\n-                  if b == 0 {\n-                      signal!(e, ModuloByZero)\n-                  } else if b == -1 && is_a_min_value() {\n-                      signal!(e, ModuloWithOverflow)\n-                  } else {\n-                      const_int(a % b)\n-                  }\n-              }\n+              ast::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n+              ast::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n+              ast::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n+              ast::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n+              ast::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n               ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n               ast::BiOr | ast::BiBitOr => const_int(a | b),\n               ast::BiBitXor => const_int(a ^ b),\n-              ast::BiShl => const_int(a << b as usize),\n-              ast::BiShr => const_int(a >> b as usize),\n+              ast::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n+              ast::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -446,18 +659,16 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           }\n           (const_uint(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiAdd => try!(checked_add_uint(e, a, b)),\n-              ast::BiSub => try!(checked_sub_uint(e, a, b)),\n-              ast::BiMul => try!(checked_mul_uint(e, a, b)),\n-              ast::BiDiv if b == 0 => signal!(e, DivideByZero),\n-              ast::BiDiv => const_uint(a / b),\n-              ast::BiRem if b == 0 => signal!(e, ModuloByZero),\n-              ast::BiRem => const_uint(a % b),\n+              ast::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n+              ast::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n+              ast::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n+              ast::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n+              ast::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n               ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n               ast::BiOr | ast::BiBitOr => const_uint(a | b),\n               ast::BiBitXor => const_uint(a ^ b),\n-              ast::BiShl => const_uint(a << b as usize),\n-              ast::BiShr => const_uint(a >> b as usize),\n+              ast::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n+              ast::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -469,15 +680,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           // shifts can have any integral type as their rhs\n           (const_int(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiShl => const_int(a << b as usize),\n-              ast::BiShr => const_int(a >> b as usize),\n+              ast::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n+              ast::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n           (const_uint(a), const_int(b)) => {\n             match op.node {\n-              ast::BiShl => const_uint(a << b as usize),\n-              ast::BiShr => const_uint(a >> b as usize),\n+              ast::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n+              ast::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n@@ -506,10 +717,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n                 });\n+\n         // Prefer known type to noop, but always have a type hint.\n+        //\n+        // FIXME (#23833): the type-hint can cause problems,\n+        // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n+        // type to the sum, and thus no overflow is signaled.\n         let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n-        match cast_const(val, ety) {\n+        match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n@@ -607,39 +823,49 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n     Ok(result)\n }\n \n-fn cast_const(val: const_val, ty: Ty) -> Result<const_val, ErrKind> {\n-    macro_rules! define_casts {\n-        ($($ty_pat:pat => (\n-            $intermediate_ty:ty,\n-            $const_type:ident,\n-            $target_ty:ty\n-        )),*) => (match ty.sty {\n-            $($ty_pat => {\n-                match val {\n-                    const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n-                    const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n-                    const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n-                    const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                    _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n-                }\n-            },)*\n-            _ => Err(ErrKind::CannotCast),\n-        })\n+fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult {\n+    macro_rules! convert_val {\n+        ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n+            match val {\n+                const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n+                const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n+                const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n+                const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n+                _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n+            }\n+        }\n+    }\n+\n+    // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n+    match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n+        (&ty::ty_int(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, const_int, i64),\n+        (&ty::ty_int(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, const_int, i64),\n+        (&ty::ty_int(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n+\n+        (&ty::ty_uint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, const_uint, u64),\n+        (&ty::ty_uint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, const_uint, u64),\n+        (&ty::ty_uint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n+\n+        _ => {}\n     }\n \n-    define_casts!{\n-        ty::ty_int(ast::TyIs) => (isize, const_int, i64),\n-        ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n-        ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n-        ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n-        ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-        ty::ty_uint(ast::TyUs) => (usize, const_uint, u64),\n-        ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n-        ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n-        ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),\n-        ty::ty_uint(ast::TyU64) => (u64, const_uint, u64),\n-        ty::ty_float(ast::TyF32) => (f32, const_float, f64),\n-        ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n+    match ty.sty {\n+        ty::ty_int(ast::TyIs) => unreachable!(),\n+        ty::ty_uint(ast::TyUs) => unreachable!(),\n+\n+        ty::ty_int(ast::TyI8) => convert_val!(i8, const_int, i64),\n+        ty::ty_int(ast::TyI16) => convert_val!(i16, const_int, i64),\n+        ty::ty_int(ast::TyI32) => convert_val!(i32, const_int, i64),\n+        ty::ty_int(ast::TyI64) => convert_val!(i64, const_int, i64),\n+\n+        ty::ty_uint(ast::TyU8) => convert_val!(u8, const_uint, u64),\n+        ty::ty_uint(ast::TyU16) => convert_val!(u16, const_uint, u64),\n+        ty::ty_uint(ast::TyU32) => convert_val!(u32, const_uint, u64),\n+        ty::ty_uint(ast::TyU64) => convert_val!(u64, const_uint, u64),\n+\n+        ty::ty_float(ast::TyF32) => convert_val!(f32, const_float, f64),\n+        ty::ty_float(ast::TyF64) => convert_val!(f64, const_float, f64),\n+        _ => Err(ErrKind::CannotCast),\n     }\n }\n "}, {"sha": "6e81d14d73cad02e32612d191c9500fab324b0a7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 270, "deletions": 54, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -68,11 +68,12 @@ use util::nodemap::FnvHashMap;\n \n use arena::TypedArena;\n use std::borrow::{Borrow, Cow};\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use std::mem;\n+use std::num::ToPrimitive;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;\n@@ -83,9 +84,11 @@ use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::{ast, ast_map};\n \n pub type Disr = u64;\n@@ -685,7 +688,7 @@ pub struct ctxt<'tcx> {\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: RefCell<NodeMap<Ty<'tcx>>>,\n+    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n@@ -850,6 +853,13 @@ pub struct ctxt<'tcx> {\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n }\n \n+impl<'tcx> ctxt<'tcx> {\n+    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> { self.node_types.borrow() }\n+    pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n+        self.node_types.borrow_mut().insert(id, ty);\n+    }\n+}\n+\n // Flags that we track on types. These flags are propagated upwards\n // through the type during type construction, so that we can quickly\n // check whether the type has various kinds of types in it without\n@@ -5489,63 +5499,268 @@ pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n      }\n }\n \n+trait IntTypeExt {\n+    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx>;\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n+    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n+    fn disr_string(&self, val: Disr) -> String;\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n+}\n+\n+impl IntTypeExt for attr::IntType {\n+    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            SignedInt(ast::TyI8)      => cx.types.i8,\n+            SignedInt(ast::TyI16)     => cx.types.i16,\n+            SignedInt(ast::TyI32)     => cx.types.i32,\n+            SignedInt(ast::TyI64)     => cx.types.i64,\n+            SignedInt(ast::TyIs)   => cx.types.isize,\n+            UnsignedInt(ast::TyU8)    => cx.types.u8,\n+            UnsignedInt(ast::TyU16)   => cx.types.u16,\n+            UnsignedInt(ast::TyU32)   => cx.types.u32,\n+            UnsignedInt(ast::TyU64)   => cx.types.u64,\n+            UnsignedInt(ast::TyUs) => cx.types.usize,\n+        }\n+    }\n+\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n+        macro_rules! add1 {\n+            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n+        }\n+        match *self {\n+            // SignedInt repr means we *want* to reinterpret the bits\n+            // treating the highest bit of Disr as a sign-bit, so\n+            // cast to i64 before range-checking.\n+            SignedInt(ast::TyI8)    => add1!((val as i64).to_i8()),\n+            SignedInt(ast::TyI16)   => add1!((val as i64).to_i16()),\n+            SignedInt(ast::TyI32)   => add1!((val as i64).to_i32()),\n+            SignedInt(ast::TyI64)   => add1!(Some(val as i64)),\n+\n+            UnsignedInt(ast::TyU8)  => add1!(val.to_u8()),\n+            UnsignedInt(ast::TyU16) => add1!(val.to_u16()),\n+            UnsignedInt(ast::TyU32) => add1!(val.to_u32()),\n+            UnsignedInt(ast::TyU64) => add1!(Some(val)),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    // This returns a String because (1.) it is only used for\n+    // rendering an error message and (2.) a string can represent the\n+    // full range from `i64::MIN` through `u64::MAX`.\n+    fn disr_string(&self, val: Disr) -> String {\n+        match *self {\n+            SignedInt(ast::TyI8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(ast::TyI16)   => format!(\"{}\", val as i16),\n+            SignedInt(ast::TyI32)   => format!(\"{}\", val as i32),\n+            SignedInt(ast::TyI64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(ast::TyU8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(ast::TyU16) => format!(\"{}\", val as u16),\n+            UnsignedInt(ast::TyU32) => format!(\"{}\", val as u32),\n+            UnsignedInt(ast::TyU64) => format!(\"{}\", val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n+        macro_rules! add1 {\n+            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n+        }\n+        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n+        match *self {\n+            SignedInt(ast::TyI8)    => add1!(val as i8 ),\n+            SignedInt(ast::TyI16)   => add1!(val as i16),\n+            SignedInt(ast::TyI32)   => add1!(val as i32),\n+            SignedInt(ast::TyI64)   => add1!(val as i64),\n+            UnsignedInt(ast::TyU8)  => add1!(val as u8 ),\n+            UnsignedInt(ast::TyU16) => add1!(val as u16),\n+            UnsignedInt(ast::TyU32) => add1!(val as u32),\n+            UnsignedInt(ast::TyU64) => add1!(val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+}\n+\n+/// Returns `(normalized_type, ty)`, where `normalized_type` is the\n+/// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n+/// and `ty` is the original type (i.e. may include `isize` or\n+/// `usize`).\n+pub fn enum_repr_type<'tcx>(cx: &ctxt<'tcx>,\n+                            opt_hint: Option<&attr::ReprAttr>)\n+                            -> (attr::IntType, Ty<'tcx>)\n+{\n+    let repr_type = match opt_hint {\n+        // Feed in the given type\n+        Some(&attr::ReprInt(_, int_t)) => int_t,\n+        // ... but provide sensible default if none provided\n+        //\n+        // NB. Historically `fn enum_variants` generate i64 here, while\n+        // rustc_typeck::check would generate isize.\n+        _ => SignedInt(ast::TyIs),\n+    };\n+\n+    let repr_type_ty = repr_type.to_ty(cx);\n+    let repr_type = match repr_type {\n+        SignedInt(ast::TyIs) =>\n+            SignedInt(cx.sess.target.int_type),\n+        UnsignedInt(ast::TyUs) =>\n+            UnsignedInt(cx.sess.target.uint_type),\n+        other => other\n+    };\n+\n+    (repr_type, repr_type_ty)\n+}\n+\n+fn report_discrim_overflow(cx: &ctxt,\n+                           variant_span: Span,\n+                           variant_name: &str,\n+                           repr_type: attr::IntType,\n+                           prev_val: Disr) {\n+    let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n+    let computed_value = repr_type.disr_string(computed_value);\n+    let prev_val = repr_type.disr_string(prev_val);\n+    let repr_type = repr_type.to_ty(cx).user_string(cx);\n+    span_err!(cx.sess, variant_span, E0370,\n+              \"enum discriminant overflowed on value after {}: {}; \\\n+               set explicitly via {} = {} if that is desired outcome\",\n+              prev_val, repr_type, variant_name, computed_value);\n+}\n+\n+// This computes the discriminant values for the sequence of Variants\n+// attached to a particular enum, taking into account the #[repr] (if\n+// any) provided via the `opt_hint`.\n+fn compute_enum_variants<'tcx>(cx: &ctxt<'tcx>,\n+                               vs: &'tcx [P<ast::Variant>],\n+                               opt_hint: Option<&attr::ReprAttr>)\n+                               -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+    let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n+    let mut prev_disr_val: Option<ty::Disr> = None;\n+\n+    let (repr_type, repr_type_ty) = ty::enum_repr_type(cx, opt_hint);\n+\n+    for v in vs {\n+        // If the discriminant value is specified explicitly in the\n+        // enum, check whether the initialization expression is valid,\n+        // otherwise use the last value plus one.\n+        let current_disr_val;\n+\n+        // This closure marks cases where, when an error occurs during\n+        // the computation, attempt to assign a (hopefully) fresh\n+        // value to avoid spurious error reports downstream.\n+        let attempt_fresh_value = move || -> Disr {\n+            repr_type.disr_wrap_incr(prev_disr_val)\n+        };\n+\n+        match v.node.disr_expr {\n+            Some(ref e) => {\n+                debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n+\n+                // check_expr (from check_const pass) doesn't guarantee\n+                // that the expression is in a form that eval_const_expr can\n+                // handle, so we may still get an internal compiler error\n+                //\n+                // pnkfelix: The above comment was transcribed from\n+                // the version of this code taken from rustc_typeck.\n+                // Presumably the implication is that we need to deal\n+                // with such ICE's as they arise.\n+                //\n+                // Since this can be called from `ty::enum_variants`\n+                // anyway, best thing is to make `eval_const_expr`\n+                // more robust (on case-by-case basis).\n+\n+                match const_eval::eval_const_expr_partial(cx, &**e, Some(repr_type_ty)) {\n+                    Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n+                    Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n+                    Ok(_) => {\n+                        span_err!(cx.sess, e.span, E0079,\n+                                  \"expected signed integer constant\");\n+                        current_disr_val = attempt_fresh_value();\n+                    }\n+                    Err(ref err) => {\n+                        span_err!(cx.sess, err.span, E0080,\n+                                  \"constant evaluation error: {}\",\n+                                  err.description());\n+                        current_disr_val = attempt_fresh_value();\n+                    }\n+                }\n+            },\n+            None => {\n+                current_disr_val = match prev_disr_val {\n+                    Some(prev_disr_val) => {\n+                        if let Some(v) = repr_type.disr_incr(prev_disr_val) {\n+                            v\n+                        } else {\n+                            report_discrim_overflow(cx, v.span, v.node.name.as_str(),\n+                                                    repr_type, prev_disr_val);\n+                            attempt_fresh_value()\n+                        }\n+                    }\n+                    None => ty::INITIAL_DISCRIMINANT_VALUE\n+                }\n+            }\n+        }\n+\n+        let variant_info = Rc::new(VariantInfo::from_ast_variant(cx, &**v, current_disr_val));\n+        prev_disr_val = Some(current_disr_val);\n+\n+        variants.push(variant_info);\n+    }\n+\n+    return variants;\n+}\n+\n pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                            -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n     memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n         if ast::LOCAL_CRATE != id.krate {\n             Rc::new(csearch::get_enum_variants(cx, id))\n         } else {\n-            /*\n-              Although both this code and check_enum_variants in typeck/check\n-              call eval_const_expr, it should never get called twice for the same\n-              expr, since check_enum_variants also updates the enum_var_cache\n-             */\n             match cx.map.get(id.node) {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n                         ast::ItemEnum(ref enum_definition, _) => {\n-                            let mut last_discriminant: Option<Disr> = None;\n-                            Rc::new(enum_definition.variants.iter().map(|variant| {\n-\n-                                let mut discriminant = INITIAL_DISCRIMINANT_VALUE;\n-                                if let Some(ref e) = variant.node.disr_expr {\n-                                    // Preserve all values, and prefer signed.\n-                                    let ty = Some(cx.types.i64);\n-                                    match const_eval::eval_const_expr_partial(cx, &**e, ty) {\n-                                        Ok(const_eval::const_int(val)) => {\n-                                            discriminant = val as Disr;\n-                                        }\n-                                        Ok(const_eval::const_uint(val)) => {\n-                                            discriminant = val as Disr;\n-                                        }\n-                                        Ok(_) => {\n-                                            span_err!(cx.sess, e.span, E0304,\n-                                                      \"expected signed integer constant\");\n-                                        }\n-                                        Err(err) => {\n-                                            span_err!(cx.sess, err.span, E0305,\n-                                                      \"constant evaluation error: {}\",\n-                                                      err.description());\n-                                        }\n-                                    }\n-                                } else {\n-                                    if let Some(val) = last_discriminant {\n-                                        if let Some(v) = val.checked_add(1) {\n-                                            discriminant = v\n-                                        } else {\n-                                            cx.sess.span_err(\n-                                                variant.span,\n-                                                &format!(\"Discriminant overflowed!\"));\n-                                        }\n-                                    } else {\n-                                        discriminant = INITIAL_DISCRIMINANT_VALUE;\n-                                    }\n-                                }\n-\n-                                last_discriminant = Some(discriminant);\n-                                Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n-                                                                      discriminant))\n-                            }).collect())\n+                            Rc::new(compute_enum_variants(\n+                                cx,\n+                                &enum_definition.variants,\n+                                lookup_repr_hints(cx, id).get(0)))\n                         }\n                         _ => {\n                             cx.sess.bug(\"enum_variants: id not bound to an enum\")\n@@ -5831,19 +6046,20 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> usize {\n                 \"expected positive integer for repeat count, found {}\",\n                 found);\n         }\n-        Err(_) => {\n+        Err(err) => {\n+            let err_description = err.description();\n             let found = match count_expr.node {\n                 ast::ExprPath(None, ast::Path {\n                     global: false,\n                     ref segments,\n                     ..\n                 }) if segments.len() == 1 =>\n-                    \"variable\",\n+                    format!(\"{}\", \"found variable\"),\n                 _ =>\n-                    \"non-constant expression\"\n+                    format!(\"but {}\", err_description),\n             };\n             span_err!(tcx.sess, count_expr.span, E0307,\n-                \"expected constant integer for repeat count, found {}\",\n+                \"expected constant integer for repeat count, {}\",\n                 found);\n         }\n     }"}, {"sha": "d71a68e2050524970304e1147c739ce190e88558", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -228,8 +228,9 @@ pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) ->\n #[cfg(unix)]\n pub fn path2cstr(p: &Path) -> CString {\n     use std::os::unix::prelude::*;\n-    use std::ffi::AsOsStr;\n-    CString::new(p.as_os_str().as_bytes()).unwrap()\n+    use std::ffi::OsStr;\n+    let p: &OsStr = p.as_ref();\n+    CString::new(p.as_bytes()).unwrap()\n }\n #[cfg(windows)]\n pub fn path2cstr(p: &Path) -> CString {"}, {"sha": "231f6ee3be6adb317f0c5ac4bd6551919047d87d", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::io;\n+use std::env;\n #[allow(deprecated)] use std::old_path::{self, GenericPath};\n #[allow(deprecated)] use std::old_io;\n use std::path::{Path, PathBuf};\n@@ -20,18 +21,16 @@ pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n     let old = old_path::Path::new(original.to_str().unwrap());\n     match old_realpath(&old) {\n         Ok(p) => Ok(PathBuf::from(p.as_str().unwrap())),\n-        Err(e) => Err(io::Error::new(io::ErrorKind::Other,\n-                                     \"realpath error\",\n-                                     Some(e.to_string())))\n+        Err(e) => Err(io::Error::new(io::ErrorKind::Other, e))\n     }\n }\n \n #[allow(deprecated)]\n fn old_realpath(original: &old_path::Path) -> old_io::IoResult<old_path::Path> {\n     use std::old_io::fs;\n-    use std::os;\n     const MAX_LINKS_FOLLOWED: usize = 256;\n-    let original = try!(os::getcwd()).join(original);\n+    let original = old_path::Path::new(env::current_dir().unwrap()\n+                                           .to_str().unwrap()).join(original);\n \n     // Right now lstat on windows doesn't work quite well\n     if cfg!(windows) {"}, {"sha": "7591ebf67f868e8ee43c71568f8aadc2845fd804", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -36,17 +36,13 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(old_fs)]\n-#![feature(io)]\n #![feature(old_io)]\n #![feature(old_path)]\n-#![feature(os)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n #![feature(path_ext)]\n-#![feature(std_misc)]\n #![feature(step_by)]\n-#![feature(convert)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;"}, {"sha": "898f20e74518fca23d44b4912ea5da69d2d7eb47", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,7 +14,7 @@\n \n #![allow(deprecated)] // to_be32\n \n-use std::iter::{range_step, repeat};\n+use std::iter::repeat;\n use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n@@ -368,7 +368,7 @@ impl Engine256State {\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n-        for t in range_step(0, 48, 8) {\n+        for t in (0..48).step_by(8) {\n             schedule_round!(t + 16);\n             schedule_round!(t + 17);\n             schedule_round!(t + 18);\n@@ -388,7 +388,7 @@ impl Engine256State {\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n-        for t in range_step(48, 64, 8) {\n+        for t in (48..64).step_by(8) {\n             sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n             sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n             sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);"}, {"sha": "42cbdd7577d8e3b5d27d3b8d9d7d17b6a5dbe90d", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -47,9 +47,10 @@ pub fn get_sdk_root(sdk_name: &str) -> String {\n                               Ok(String::from_utf8(output.stdout).unwrap())\n                           } else {\n                               let error = String::from_utf8(output.stderr);\n+                              let error = format!(\"process exit with error: {}\",\n+                                                  error.unwrap());\n                               Err(io::Error::new(io::ErrorKind::Other,\n-                                                 \"process exit with error\",\n-                                                 error.ok()))\n+                                                 &error[..]))\n                           }\n                       });\n "}, {"sha": "b12732f8794564ded4b09bcb5323db2c895e0d27", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,7 +11,7 @@\n use std::env;\n use std::io::{self, Error, ErrorKind};\n use std::fs;\n-use std::path::{self, PathBuf, AsPath};\n+use std::path::{self, PathBuf, Path};\n use std::rand::{thread_rng, Rng};\n \n /// A wrapper for a path to temporary directory implementing automatic\n@@ -36,10 +36,10 @@ impl TempDir {\n     ///\n     /// If no directory can be created, `Err` is returned.\n     #[allow(deprecated)] // rand usage\n-    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)\n-                                      -> io::Result<TempDir> {\n+    pub fn new_in<P: AsRef<Path>>(tmpdir: P, prefix: &str)\n+                                  -> io::Result<TempDir> {\n         let storage;\n-        let mut tmpdir = tmpdir.as_path();\n+        let mut tmpdir = tmpdir.as_ref();\n         if !tmpdir.is_absolute() {\n             let cur_dir = try!(env::current_dir());\n             storage = cur_dir.join(tmpdir);\n@@ -67,8 +67,7 @@ impl TempDir {\n         }\n \n         Err(Error::new(ErrorKind::AlreadyExists,\n-                       \"too many temporary directories already exist\",\n-                       None))\n+                       \"too many temporary directories already exist\"))\n     }\n \n     /// Attempts to make a temporary directory inside of `env::temp_dir()` whose"}, {"sha": "be416327dad3b192f521255d2007790372478f7a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -27,18 +27,15 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(exit_status)]\n-#![feature(io)]\n #![feature(set_stdio)]\n #![feature(unicode)]\n-#![feature(convert)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "fe55ca3b73bfbedf5566e025eab251bc41fe90d7", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -699,8 +699,8 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n \n     fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n         r.map_err(|ioerr| {\n-            io::Error::new(io::ErrorKind::Other, \"graphviz::render failed\",\n-                           Some(ioerr.to_string()))\n+            io::Error::new(io::ErrorKind::Other,\n+                           &format!(\"graphviz::render failed: {}\", ioerr)[..])\n         })\n     }\n }"}, {"sha": "b0fc5fbcb50b211c541eec2ae17578c02e92cc6f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -808,12 +808,11 @@ fn walk_ty() {\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n         let walked: Vec<_> = uniq_ty.walk().collect();\n-        assert_eq!([uniq_ty,\n-                    tup2_ty,\n-                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                    uint_ty],\n-                   walked);\n+        assert_eq!(walked, [uniq_ty,\n+                            tup2_ty,\n+                            tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                            tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                            uint_ty]);\n     })\n }\n "}, {"sha": "647f4bc6a40fdbe7118dd31349b6de4657af6bae", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -42,8 +42,9 @@ impl ArchiveRO {\n         #[cfg(unix)]\n         fn path2cstr(p: &Path) -> CString {\n             use std::os::unix::prelude::*;\n-            use std::ffi::AsOsStr;\n-            CString::new(p.as_os_str().as_bytes()).unwrap()\n+            use std::ffi::OsStr;\n+            let p: &OsStr = p.as_ref();\n+            CString::new(p.as_bytes()).unwrap()\n         }\n         #[cfg(windows)]\n         fn path2cstr(p: &Path) -> CString {"}, {"sha": "cdafa4a16d07dbd88a46007f5e5bd81ad653f959", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -30,7 +30,6 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n-#![cfg_attr(unix, feature(std_misc))]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -1976,6 +1975,7 @@ extern {\n     pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n \n     pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n \n     pub fn LLVMInitializeX86TargetInfo();\n     pub fn LLVMInitializeX86Target();"}, {"sha": "b0eacd1a55d4150221e924c8b3bf390f8d81d9ca", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -39,7 +39,6 @@\n #![feature(unicode)]\n #![feature(path_ext)]\n #![feature(fs)]\n-#![feature(convert)]\n #![feature(path_relative_from)]\n \n #![allow(trivial_casts)]"}, {"sha": "26fcf947e4f900e179c6365bbc0fb5ddaad20674", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -272,7 +272,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let typ =\n                     ppaux::ty_to_string(\n                         &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types.borrow().get(&id).unwrap());\n+                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -436,7 +436,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let typ =\n                     ppaux::ty_to_string(\n                         &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types.borrow().get(&field.node.id).unwrap());\n+                        *self.analysis.ty_cx.node_types().get(&field.node.id).unwrap());\n                 match self.span.sub_span_before_token(field.span, token::Colon) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -1471,7 +1471,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n         for &(id, ref p, ref immut, _) in &self.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n-            let types = self.analysis.ty_cx.node_types.borrow();\n+            let types = self.analysis.ty_cx.node_types();\n             let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?)."}, {"sha": "20677ab93fc57ecfca93af7b6cc8efe0e1cbf4a2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -41,7 +41,7 @@ use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::subst::{Subst, Substs};\n-use middle::ty::{self, Ty, ClosureTyper};\n+use middle::ty::{self, Ty, ClosureTyper, type_is_simd, simd_size};\n use session::config::{self, NoDebugInfo};\n use session::Session;\n use trans::_match;\n@@ -52,7 +52,7 @@ use trans::callee;\n use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n use trans::closure;\n-use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n+use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan};\n@@ -824,6 +824,15 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n+        ty::ty_struct(_, _) if type_is_simd(cx.tcx(), rhs_t) => {\n+            let mut res = C_bool(cx.ccx(), false);\n+            for i in 0 .. simd_size(cx.tcx(), rhs_t) {\n+                res = Or(cx, res,\n+                         IsNull(cx,\n+                                ExtractElement(cx, rhs, C_int(cx.ccx(), i as i64))), debug_loc);\n+            }\n+            (res, false)\n+        }\n         _ => {\n             cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n                                   ty_to_string(cx.tcx(), rhs_t)));"}, {"sha": "995f3caf588701907a11b4d158284fd475861071", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -963,6 +963,32 @@ pub fn const_to_uint(v: ValueRef) -> u64 {\n     }\n }\n \n+fn is_const_integral(v: ValueRef) -> bool {\n+    unsafe {\n+        !llvm::LLVMIsAConstantInt(v).is_null()\n+    }\n+}\n+\n+pub fn const_to_opt_int(v: ValueRef) -> Option<i64> {\n+    unsafe {\n+        if is_const_integral(v) {\n+            Some(llvm::LLVMConstIntGetSExtValue(v))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+pub fn const_to_opt_uint(v: ValueRef) -> Option<u64> {\n+    unsafe {\n+        if is_const_integral(v) {\n+            Some(llvm::LLVMConstIntGetZExtValue(v))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub fn is_undef(val: ValueRef) -> bool {\n     unsafe {\n         llvm::LLVMIsUndef(val) != False"}, {"sha": "c32cb28ec78dbb9bbdbf83fced5510b615f2780e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 116, "deletions": 9, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,6 +14,14 @@ use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::{check_const, const_eval, def};\n+use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n+use middle::const_eval::{const_int_checked_add, const_uint_checked_add};\n+use middle::const_eval::{const_int_checked_sub, const_uint_checked_sub};\n+use middle::const_eval::{const_int_checked_mul, const_uint_checked_mul};\n+use middle::const_eval::{const_int_checked_div, const_uint_checked_div};\n+use middle::const_eval::{const_int_checked_rem, const_uint_checked_rem};\n+use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n+use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n@@ -336,6 +344,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n     let tsize = machine::llsize_of_alloc(cx, llty);\n     if csize != tsize {\n+        cx.sess().abort_if_errors();\n         unsafe {\n             // FIXME these values could use some context\n             llvm::LLVMDumpValue(llconst);\n@@ -348,6 +357,100 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     (llconst, ety_adjusted)\n }\n \n+fn check_unary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n+                             te: ValueRef) {\n+    // The only kind of unary expression that we check for validity\n+    // here is `-expr`, to check if it \"overflows\" (e.g. `-i32::MIN`).\n+    if let ast::ExprUnary(ast::UnNeg, ref inner_e) = e.node {\n+\n+        // An unfortunate special case: we parse e.g. -128 as a\n+        // negation of the literal 128, which means if we're expecting\n+        // a i8 (or if it was already suffixed, e.g. `-128_i8`), then\n+        // 128 will have already overflowed to -128, and so then the\n+        // constant evaluator thinks we're trying to negate -128.\n+        //\n+        // Catch this up front by looking for ExprLit directly,\n+        // and just accepting it.\n+        if let ast::ExprLit(_) = inner_e.node { return; }\n+\n+        let result = match t.sty {\n+            ty::ty_int(int_type) => {\n+                let input = match const_to_opt_int(te) {\n+                    Some(v) => v,\n+                    None => return,\n+                };\n+                const_int_checked_neg(\n+                    input, e, Some(const_eval::IntTy::from(cx.tcx(), int_type)))\n+            }\n+            ty::ty_uint(uint_type) => {\n+                let input = match const_to_opt_uint(te) {\n+                    Some(v) => v,\n+                    None => return,\n+                };\n+                const_uint_checked_neg(\n+                    input, e, Some(const_eval::UintTy::from(cx.tcx(), uint_type)))\n+            }\n+            _ => return,\n+        };\n+\n+        // We do not actually care about a successful result.\n+        if let Err(err) = result {\n+            cx.tcx().sess.span_err(e.span, &err.description());\n+        }\n+    }\n+}\n+\n+fn check_binary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n+                              te1: ValueRef, te2: ValueRef) {\n+    let b = if let ast::ExprBinary(b, _, _) = e.node { b } else { return };\n+\n+    let result = match t.sty {\n+        ty::ty_int(int_type) => {\n+            let (lhs, rhs) = match (const_to_opt_int(te1),\n+                                    const_to_opt_int(te2)) {\n+                (Some(v1), Some(v2)) => (v1, v2),\n+                _ => return,\n+            };\n+\n+            let opt_ety = Some(const_eval::IntTy::from(cx.tcx(), int_type));\n+            match b.node {\n+                ast::BiAdd => const_int_checked_add(lhs, rhs, e, opt_ety),\n+                ast::BiSub => const_int_checked_sub(lhs, rhs, e, opt_ety),\n+                ast::BiMul => const_int_checked_mul(lhs, rhs, e, opt_ety),\n+                ast::BiDiv => const_int_checked_div(lhs, rhs, e, opt_ety),\n+                ast::BiRem => const_int_checked_rem(lhs, rhs, e, opt_ety),\n+                ast::BiShl => const_int_checked_shl(lhs, rhs, e, opt_ety),\n+                ast::BiShr => const_int_checked_shr(lhs, rhs, e, opt_ety),\n+                _ => return,\n+            }\n+        }\n+        ty::ty_uint(uint_type) => {\n+            let (lhs, rhs) = match (const_to_opt_uint(te1),\n+                                    const_to_opt_uint(te2)) {\n+                (Some(v1), Some(v2)) => (v1, v2),\n+                _ => return,\n+            };\n+\n+            let opt_ety = Some(const_eval::UintTy::from(cx.tcx(), uint_type));\n+            match b.node {\n+                ast::BiAdd => const_uint_checked_add(lhs, rhs, e, opt_ety),\n+                ast::BiSub => const_uint_checked_sub(lhs, rhs, e, opt_ety),\n+                ast::BiMul => const_uint_checked_mul(lhs, rhs, e, opt_ety),\n+                ast::BiDiv => const_uint_checked_div(lhs, rhs, e, opt_ety),\n+                ast::BiRem => const_uint_checked_rem(lhs, rhs, e, opt_ety),\n+                ast::BiShl => const_uint_checked_shl(lhs, rhs, e, opt_ety),\n+                ast::BiShr => const_uint_checked_shr(lhs, rhs, e, opt_ety),\n+                _ => return,\n+            }\n+        }\n+        _ => return,\n+    };\n+    // We do not actually care about a successful result.\n+    if let Err(err) = result {\n+        cx.tcx().sess.span_err(e.span, &err.description());\n+    }\n+}\n+\n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    e: &ast::Expr,\n                                    ety: Ty<'tcx>,\n@@ -386,7 +489,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let signed = ty::type_is_signed(intype);\n \n             let (te2, _) = const_expr(cx, &**e2, param_substs);\n-            let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+\n+            check_binary_expr_validity(cx, e, ty, te1, te2);\n \n             match b.node {\n               ast::BiAdd   => {\n@@ -416,8 +520,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               ast::BiBitXor => llvm::LLVMConstXor(te1, te2),\n               ast::BiBitAnd => llvm::LLVMConstAnd(te1, te2),\n               ast::BiBitOr  => llvm::LLVMConstOr(te1, te2),\n-              ast::BiShl    => llvm::LLVMConstShl(te1, te2),\n+              ast::BiShl    => {\n+                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+                llvm::LLVMConstShl(te1, te2)\n+              }\n               ast::BiShr    => {\n+                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n                 if signed { llvm::LLVMConstAShr(te1, te2) }\n                 else      { llvm::LLVMConstLShr(te1, te2) }\n               }\n@@ -439,8 +547,11 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n             }\n           },\n-          ast::ExprUnary(u, ref e) => {\n-            let (te, ty) = const_expr(cx, &**e, param_substs);\n+          ast::ExprUnary(u, ref inner_e) => {\n+            let (te, ty) = const_expr(cx, &**inner_e, param_substs);\n+\n+            check_unary_expr_validity(cx, e, ty, te);\n+\n             let is_float = ty::type_is_fp(ty);\n             match u {\n               ast::UnUniq | ast::UnDeref => {\n@@ -661,11 +772,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = match const_eval::eval_const_expr_partial(cx.tcx(), &**count, None) {\n-                Ok(const_eval::const_int(i))  => i as usize,\n-                Ok(const_eval::const_uint(i)) => i as usize,\n-                _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n-            };\n+            let n = ty::eval_repeat_count(cx.tcx(), count);\n             let unit_val = const_expr(cx, &**elem, param_substs).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {"}, {"sha": "8e9ae2eba0bcd688201775bdd050285ab1d7db22", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -3207,7 +3207,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n fn assert_type_for_node_id(cx: &CrateContext,\n                            node_id: ast::NodeId,\n                            error_reporting_span: Span) {\n-    if !cx.tcx().node_types.borrow().contains_key(&node_id) {\n+    if !cx.tcx().node_types().contains_key(&node_id) {\n         cx.sess().span_bug(error_reporting_span,\n                            \"debuginfo: Could not find type for node id!\");\n     }"}, {"sha": "fbff4e84788822d06dbf54cc62e3b6cd2c862e5b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 67, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -85,7 +85,7 @@ use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n-use middle::{const_eval, def};\n+use middle::def;\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n@@ -94,7 +94,7 @@ use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n-use middle::ty::{FnSig, GenericPredicates, VariantInfo, TypeScheme};\n+use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::liberate_late_bound_regions;\n@@ -4283,68 +4283,30 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                           vs: &'tcx [P<ast::Variant>],\n                           id: ast::NodeId,\n-                          hint: attr::ReprAttr)\n-                          -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+                          hint: attr::ReprAttr) {\n         #![allow(trivial_numeric_casts)]\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n-        let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for v in vs {\n+        let inh = static_inherited_fields(ccx);\n+        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n-            // If the discriminant value is specified explicitly in the enum check whether the\n-            // initialization expression is valid, otherwise use the last value plus one.\n-            let mut current_disr_val = match prev_disr_val {\n-                Some(prev_disr_val) => {\n-                    if let Some(v) = prev_disr_val.checked_add(1) {\n-                        v\n-                    } else {\n-                        ty::INITIAL_DISCRIMINANT_VALUE\n-                    }\n-                }\n-                None => ty::INITIAL_DISCRIMINANT_VALUE\n-            };\n+        let (_, repr_type_ty) = ty::enum_repr_type(ccx.tcx, Some(&hint));\n+        for v in vs {\n+            if let Some(ref e) = v.node.disr_expr {\n+                check_const_with_ty(&fcx, e.span, e, repr_type_ty);\n+            }\n+        }\n \n-            match v.node.disr_expr {\n-                Some(ref e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n+        let def_id = local_def(id);\n \n-                    let inh = static_inherited_fields(ccx);\n-                    let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-                    let declty = match hint {\n-                        attr::ReprAny | attr::ReprPacked |\n-                        attr::ReprExtern => fcx.tcx().types.isize,\n+        // ty::enum_variants guards against discriminant overflows, so\n+        // we need not check for that.\n+        let variants = ty::enum_variants(ccx.tcx, def_id);\n \n-                        attr::ReprInt(_, attr::SignedInt(ity)) => {\n-                            ty::mk_mach_int(fcx.tcx(), ity)\n-                        }\n-                        attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n-                            ty::mk_mach_uint(fcx.tcx(), ity)\n-                        },\n-                    };\n-                    check_const_with_ty(&fcx, e.span, &**e, declty);\n-                    // check_expr (from check_const pass) doesn't guarantee\n-                    // that the expression is in a form that eval_const_expr can\n-                    // handle, so we may still get an internal compiler error\n-\n-                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e, Some(declty)) {\n-                        Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n-                        Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n-                        Ok(_) => {\n-                            span_err!(ccx.tcx.sess, e.span, E0079,\n-                                \"expected signed integer constant\");\n-                        }\n-                        Err(ref err) => {\n-                            span_err!(ccx.tcx.sess, err.span, E0080,\n-                                      \"constant evaluation error: {}\",\n-                                      err.description());\n-                        }\n-                    }\n-                },\n-                None => ()\n-            };\n+        for (v, variant) in vs.iter().zip(variants.iter()) {\n+            let current_disr_val = variant.disr_val;\n \n             // Check for duplicate discriminant values\n             match disr_vals.iter().position(|&x| x == current_disr_val) {\n@@ -4372,15 +4334,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 }\n             }\n             disr_vals.push(current_disr_val);\n-\n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &**v,\n-                                                                     current_disr_val));\n-            prev_disr_val = Some(current_disr_val);\n-\n-            variants.push(variant_info);\n         }\n-\n-        return variants;\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n@@ -4396,10 +4350,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         };\n     }\n \n-    let variants = do_check(ccx, vs, id, hint);\n-\n-    // cache so that ty::enum_variants won't repeat this work\n-    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), Rc::new(variants));\n+    do_check(ccx, vs, id, hint);\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n "}, {"sha": "b450e6b398a6a00d8ef1dd716c198559f829f8a2", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -215,25 +215,21 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 match traits::orphan_check(self.tcx, def_id) {\n                     Ok(()) => { }\n                     Err(traits::OrphanCheckErr::NoLocalInputType) => {\n-                        if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n-                            span_err!(\n-                                self.tcx.sess, item.span, E0117,\n-                                \"the impl does not reference any \\\n-                                 types defined in this crate; \\\n-                                 only traits defined in the current crate can be \\\n-                                 implemented for arbitrary types\");\n-                            return;\n-                        }\n+                        span_err!(\n+                            self.tcx.sess, item.span, E0117,\n+                            \"the impl does not reference any \\\n+                             types defined in this crate; \\\n+                             only traits defined in the current crate can be \\\n+                             implemented for arbitrary types\");\n+                        return;\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n-                        if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n-                            span_err!(self.tcx.sess, item.span, E0210,\n-                                    \"type parameter `{}` must be used as the type parameter for \\\n-                                     some local type (e.g. `MyStruct<T>`); only traits defined in \\\n-                                     the current crate can be implemented for a type parameter\",\n-                                    param_ty.user_string(self.tcx));\n-                            return;\n-                        }\n+                        span_err!(self.tcx.sess, item.span, E0210,\n+                                \"type parameter `{}` must be used as the type parameter for \\\n+                                 some local type (e.g. `MyStruct<T>`); only traits defined in \\\n+                                 the current crate can be implemented for a type parameter\",\n+                                param_ty.user_string(self.tcx));\n+                        return;\n                     }\n                 }\n "}, {"sha": "a8d93c8bd111a054b8a49bfc9f97c3de14913fd8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -51,8 +51,6 @@ register_diagnostics! {\n     E0075,\n     E0076,\n     E0077,\n-    E0079,\n-    E0080,\n     E0081,\n     E0082,\n     E0083,"}, {"sha": "9d6c04b1ad49d90957a2f373b6685f4a4ae15693", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -146,7 +146,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n-    tcx.node_types.borrow_mut().insert(node_id, ty);\n+    tcx.node_type_insert(node_id, ty);\n }\n \n fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "760fa329fd9866808f68a7570a4bd2ba48b19c99", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -20,7 +20,7 @@ pub use self::imp::Lock;\n \n #[cfg(unix)]\n mod imp {\n-    use std::ffi::{AsOsStr, CString};\n+    use std::ffi::{CString, OsStr};\n     use std::os::unix::prelude::*;\n     use std::path::Path;\n     use std::io;\n@@ -116,7 +116,8 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let buf = CString::new(p.as_os_str().as_bytes()).unwrap();\n+            let os: &OsStr = p.as_ref();\n+            let buf = CString::new(os.as_bytes()).unwrap();\n             let fd = unsafe {\n                 libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n                            libc::S_IRWXU)\n@@ -164,9 +165,9 @@ mod imp {\n #[cfg(windows)]\n mod imp {\n     use libc;\n-    use std::ffi::AsOsStr;\n     use std::io;\n     use std::mem;\n+    use std::ffi::OsStr;\n     use std::os::windows::prelude::*;\n     use std::path::Path;\n     use std::ptr;\n@@ -194,7 +195,8 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let mut p_16: Vec<_> = p.as_os_str().encode_wide().collect();\n+            let os: &OsStr = p.as_ref();\n+            let mut p_16: Vec<_> = os.encode_wide().collect();\n             p_16.push(0);\n             let handle = unsafe {\n                 libc::CreateFileW(p_16.as_ptr(),"}, {"sha": "1ff3411f8fc14368809ab1f5339c68dbc4421b5e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -23,7 +23,6 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(exit_status)]\n #![feature(set_stdio)]\n #![feature(libc)]\n@@ -36,7 +35,6 @@\n #![feature(file_path)]\n #![feature(path_ext)]\n #![feature(path_relative_from)]\n-#![feature(convert)]\n #![feature(slice_patterns)]\n \n extern crate arena;"}, {"sha": "cdfe212bf23ddccd9c0b97cce4e73c0c97b545e2", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -100,7 +100,7 @@\n //!     let encoded = json::encode(&object).unwrap();\n //!\n //!     // Deserialize using `json::decode`\n-//!     let decoded: TestStruct = json::decode(encoded.as_slice()).unwrap();\n+//!     let decoded: TestStruct = json::decode(&encoded[..]).unwrap();\n //! }\n //! ```\n //!\n@@ -367,8 +367,8 @@ impl std::error::Error for EncoderError {\n     fn description(&self) -> &str { \"encoder error\" }\n }\n \n-impl std::error::FromError<fmt::Error> for EncoderError {\n-    fn from_error(err: fmt::Error) -> EncoderError { EncoderError::FmtError(err) }\n+impl From<fmt::Error> for EncoderError {\n+    fn from(err: fmt::Error) -> EncoderError { EncoderError::FmtError(err) }\n }\n \n pub type EncodeResult = Result<(), EncoderError>;"}, {"sha": "2e86712c9bccf66cb24f1d45c0ff3884d5e2526b", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -36,7 +36,6 @@ Core encoding and decoding interfaces.\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(str_char)]\n-#![feature(convert)]\n #![cfg_attr(test, feature(test, old_io))]\n \n // test harness access"}, {"sha": "a636c1a812ddcbf2df4c3b5b009b36be5a072955", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -1482,8 +1482,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n-               reason = \"matches entry v3 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n     pub fn or_insert(self, default: V) -> &'a mut V {\n@@ -1493,8 +1492,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n-               reason = \"matches entry v3 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {"}, {"sha": "5fbc21797ab5a0442d82ebd5fc2254f54219b9fb", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -1192,7 +1192,7 @@ mod test_set {\n         };\n \n         let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n+        assert!(v == ['a', 'b'] || v == ['b', 'a']);\n     }\n \n     #[test]"}, {"sha": "053ceceb49621f1525c9eb54ea11ca9382d90bbd", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -15,7 +15,7 @@ use self::BucketState::*;\n use clone::Clone;\n use cmp;\n use hash::{Hash, Hasher};\n-use iter::{Iterator, ExactSizeIterator, count};\n+use iter::{Iterator, ExactSizeIterator};\n use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;"}, {"sha": "e76d5460eb0c4218317461061e587fca3de7ddf5", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -18,7 +18,7 @@\n use prelude::v1::*;\n \n use env;\n-use ffi::{AsOsStr, CString, OsString};\n+use ffi::{CString, OsString};\n use mem;\n use path::{Path, PathBuf};\n \n@@ -190,7 +190,6 @@ mod dl {\n     use ffi::{CStr, OsStr};\n     use str;\n     use libc;\n-    use os::unix::prelude::*;\n     use ptr;\n \n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {"}, {"sha": "931cf46a58f2266ee822e6b6eb60a656e460f6ca", "filename": "src/libstd/env.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -20,7 +20,7 @@ use prelude::v1::*;\n \n use iter::IntoIterator;\n use error::Error;\n-use ffi::{OsString, AsOsStr};\n+use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n@@ -176,7 +176,7 @@ impl Iterator for VarsOs {\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n+pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsRef<OsStr> {\n     match var_os(key) {\n         Some(s) => s.into_string().map_err(VarError::NotUnicode),\n         None => Err(VarError::NotPresent)\n@@ -198,9 +198,9 @@ pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn var_os<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr {\n+pub fn var_os<K: ?Sized>(key: &K) -> Option<OsString> where K: AsRef<OsStr> {\n     let _g = ENV_LOCK.lock();\n-    os_imp::getenv(key.as_os_str())\n+    os_imp::getenv(key.as_ref())\n }\n \n /// Possible errors from the `env::var` method.\n@@ -255,17 +255,30 @@ impl Error for VarError {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n-    where K: AsOsStr, V: AsOsStr\n+    where K: AsRef<OsStr>, V: AsRef<OsStr>\n {\n     let _g = ENV_LOCK.lock();\n-    os_imp::setenv(k.as_os_str(), v.as_os_str())\n+    os_imp::setenv(k.as_ref(), v.as_ref())\n }\n \n-/// Remove a variable from the environment entirely.\n+/// Remove an environment variable from the environment of the currently running process.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::env;\n+///\n+/// let key = \"KEY\";\n+/// env::set_var(key, \"VALUE\");\n+/// assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n+///\n+/// env::remove_var(key);\n+/// assert!(env::var(key).is_err());\n+/// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn remove_var<K: ?Sized>(k: &K) where K: AsOsStr {\n+pub fn remove_var<K: ?Sized>(k: &K) where K: AsRef<OsStr> {\n     let _g = ENV_LOCK.lock();\n-    os_imp::unsetenv(k.as_os_str())\n+    os_imp::unsetenv(k.as_ref())\n }\n \n /// An iterator over `Path` instances for parsing an environment variable\n@@ -296,8 +309,8 @@ pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn split_paths<T: AsOsStr + ?Sized>(unparsed: &T) -> SplitPaths {\n-    SplitPaths { inner: os_imp::split_paths(unparsed.as_os_str()) }\n+pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths {\n+    SplitPaths { inner: os_imp::split_paths(unparsed.as_ref()) }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -327,7 +340,6 @@ pub struct JoinPathsError {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(convert)]\n /// use std::env;\n /// use std::path::PathBuf;\n ///\n@@ -340,7 +352,7 @@ pub struct JoinPathsError {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: IntoIterator<Item=T>, T: AsOsStr\n+    where I: IntoIterator<Item=T>, T: AsRef<OsStr>\n {\n     os_imp::join_paths(paths.into_iter()).map_err(|e| {\n         JoinPathsError { inner: e }\n@@ -398,6 +410,19 @@ pub fn home_dir() -> Option<PathBuf> {\n /// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n /// 'USERPROFILE' environment variable  if any are set and not the empty\n /// string. Otherwise, tmpdir returns the path to the Windows directory.\n+///\n+/// ```\n+/// use std::env;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let mut dir = env::temp_dir();\n+/// dir.push(\"foo.txt\");\n+///\n+/// let f = try!(File::create(dir));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn temp_dir() -> PathBuf {\n     os_imp::temp_dir()\n@@ -557,6 +582,7 @@ pub mod consts {\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n     pub const ARCH: &'static str = super::arch::ARCH;\n \n+    /// The family of the operating system. In this case, `unix`.\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n     pub const FAMILY: &'static str = super::os::FAMILY;\n \n@@ -740,7 +766,7 @@ mod tests {\n         let mut rng = rand::thread_rng();\n         let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n                                      .collect::<String>());\n-        let n = OsString::from_string(n);\n+        let n = OsString::from(n);\n         assert!(var_os(&n).is_none());\n         n\n     }"}, {"sha": "de91e5f32683939d5bee102c8739c14a0d6b5e25", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 7, "deletions": 102, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,9 +10,9 @@\n \n #![unstable(feature = \"std_misc\")]\n \n-use convert::Into;\n+use convert::{Into, From};\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use error::{Error, FromError};\n+use error::Error;\n use fmt;\n use io;\n use iter::Iterator;\n@@ -132,15 +132,6 @@ pub struct CStr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n-/// A conversion trait used by the constructor of `CString` for types that can\n-/// be converted to a vector of bytes.\n-#[deprecated(since = \"1.0.0\", reason = \"use std::convert::Into<Vec<u8>> instead\")]\n-#[unstable(feature = \"std_misc\")]\n-pub trait IntoBytes {\n-    /// Consumes this container, returning a vector of bytes.\n-    fn into_bytes(self) -> Vec<u8>;\n-}\n-\n impl CString {\n     /// Create a new C-compatible string from a container of bytes.\n     ///\n@@ -178,57 +169,6 @@ impl CString {\n         }\n     }\n \n-    /// Create a new C-compatible string from a byte slice.\n-    ///\n-    /// This method will copy the data of the slice provided into a new\n-    /// allocation, ensuring that there is a trailing 0 byte.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n-    /// use std::ffi::CString;\n-    ///\n-    /// extern { fn puts(s: *const libc::c_char); }\n-    ///\n-    /// fn main() {\n-    ///     let to_print = CString::new(\"Hello!\").unwrap();\n-    ///     unsafe {\n-    ///         puts(to_print.as_ptr());\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the provided slice contains any\n-    /// interior nul bytes.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use CString::new instead\")]\n-    #[allow(deprecated)]\n-    pub fn from_slice(v: &[u8]) -> CString {\n-        CString::from_vec(v.to_vec())\n-    }\n-\n-    /// Create a C-compatible string from a byte vector.\n-    ///\n-    /// This method will consume ownership of the provided vector, appending a 0\n-    /// byte to the end after verifying that there are no interior 0 bytes.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the provided slice contains any\n-    /// interior nul bytes.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use CString::new instead\")]\n-    pub fn from_vec(v: Vec<u8>) -> CString {\n-        match v.iter().position(|x| *x == 0) {\n-            Some(i) => panic!(\"null byte found in slice at: {}\", i),\n-            None => unsafe { CString::from_vec_unchecked(v) },\n-        }\n-    }\n-\n     /// Create a C-compatible string from a byte vector without checking for\n     /// interior 0 bytes.\n     ///\n@@ -298,17 +238,17 @@ impl fmt::Display for NulError {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromError<NulError> for io::Error {\n-    fn from_error(_: NulError) -> io::Error {\n+impl From<NulError> for io::Error {\n+    fn from(_: NulError) -> io::Error {\n         io::Error::new(io::ErrorKind::InvalidInput,\n-                       \"data provided contains a nul byte\", None)\n+                       \"data provided contains a nul byte\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n-impl FromError<NulError> for old_io::IoError {\n-    fn from_error(_: NulError) -> old_io::IoError {\n+impl From<NulError> for old_io::IoError {\n+    fn from(_: NulError) -> old_io::IoError {\n         old_io::IoError {\n             kind: old_io::IoErrorKind::InvalidInput,\n             desc: \"data provided contains a nul byte\",\n@@ -424,41 +364,6 @@ impl Ord for CStr {\n     }\n }\n \n-/// Deprecated in favor of `CStr`\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use CStr::from_ptr(p).to_bytes() instead\")]\n-pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n-    let len = libc::strlen(*raw);\n-    slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n-}\n-\n-/// Deprecated in favor of `CStr`\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use CStr::from_ptr(p).to_bytes_with_nul() instead\")]\n-pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char)\n-                                          -> &'a [u8] {\n-    let len = libc::strlen(*raw) + 1;\n-    slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n-}\n-\n-#[allow(deprecated)]\n-impl<'a> IntoBytes for &'a str {\n-    fn into_bytes(self) -> Vec<u8> { self.as_bytes().to_vec() }\n-}\n-#[allow(deprecated)]\n-impl<'a> IntoBytes for &'a [u8] {\n-    fn into_bytes(self) -> Vec<u8> { self.to_vec() }\n-}\n-#[allow(deprecated)]\n-impl IntoBytes for String {\n-    fn into_bytes(self) -> Vec<u8> { self.into_bytes() }\n-}\n-#[allow(deprecated)]\n-impl IntoBytes for Vec<u8> {\n-    fn into_bytes(self) -> Vec<u8> { self }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;"}, {"sha": "1b7e913d46cbf49120c0f2798a5135477dec53ff", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,17 +13,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::c_str::{CString, CStr};\n-pub use self::c_str::{NulError, IntoBytes};\n-#[allow(deprecated)]\n-pub use self::c_str::c_str_to_bytes;\n-#[allow(deprecated)]\n-pub use self::c_str::c_str_to_bytes_with_nul;\n+pub use self::c_str::{CString, CStr, NulError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::os_str::OsString;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::os_str::OsStr;\n+pub use self::os_str::{OsString, OsStr};\n \n mod c_str;\n mod os_str;"}, {"sha": "ab20efe25eb19da63db8ffd9e5f2020c41d674ce", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 76, "deletions": 28, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -29,19 +29,21 @@\n //! for conversion to/from various other string types. Eventually these types\n //! will offer a full-fledged string API.\n \n-#![unstable(feature = \"os\",\n+#![unstable(feature = \"os_str\",\n             reason = \"recently added as part of path/io reform\")]\n \n use core::prelude::*;\n \n use borrow::{Borrow, Cow, ToOwned};\n+use ffi::CString;\n use fmt::{self, Debug};\n use mem;\n use string::String;\n use ops;\n use cmp;\n use hash::{Hash, Hasher};\n use old_path::{Path, GenericPath};\n+use vec::Vec;\n \n use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};\n@@ -61,26 +63,41 @@ pub struct OsStr {\n }\n \n impl OsString {\n-    /// Constructs an `OsString` at no cost by consuming a `String`.\n+    /// Constructs a new empty `OsString`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n-    pub fn from_string(s: String) -> OsString {\n-        OsString::from(s)\n+    pub fn new() -> OsString {\n+        OsString { inner: Buf::from_string(String::new()) }\n     }\n \n-    /// Constructs an `OsString` by copying from a `&str` slice.\n+    /// Construct an `OsString` from a byte sequence.\n     ///\n-    /// Equivalent to: `OsString::from_string(String::from_str(s))`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n-    pub fn from_str(s: &str) -> OsString {\n-        OsString::from(s)\n+    /// # Platform behavior\n+    ///\n+    /// On Unix systems, any byte sequence can be successfully\n+    /// converted into an `OsString`.\n+    ///\n+    /// On Windows system, only UTF-8 byte sequences will successfully\n+    /// convert; non UTF-8 data will produce `None`.\n+    #[unstable(feature = \"convert\", reason = \"recently added\")]\n+    pub fn from_bytes<B>(bytes: B) -> Option<OsString> where B: Into<Vec<u8>> {\n+        #[cfg(unix)]\n+        fn from_bytes_inner(vec: Vec<u8>) -> Option<OsString> {\n+            use os::unix::ffi::OsStringExt;\n+            Some(OsString::from_vec(vec))\n+        }\n+\n+        #[cfg(windows)]\n+        fn from_bytes_inner(vec: Vec<u8>) -> Option<OsString> {\n+            String::from_utf8(vec).ok().map(OsString::from)\n+        }\n+\n+        from_bytes_inner(bytes.into())\n     }\n \n-    /// Constructs a new empty `OsString`.\n+    /// Convert to an `OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> OsString {\n-        OsString { inner: Buf::from_string(String::new()) }\n+    pub fn as_os_str(&self) -> &OsStr {\n+        self\n     }\n \n     /// Convert the `OsString` into a `String` if it contains valid Unicode data.\n@@ -91,13 +108,6 @@ impl OsString {\n         self.inner.into_string().map_err(|buf| OsString { inner: buf} )\n     }\n \n-    /// Extend the string with the given `&OsStr` slice.\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `push`\")]\n-    #[unstable(feature = \"os\")]\n-    pub fn push_os_str(&mut self, s: &OsStr) {\n-        self.inner.push_slice(&s.inner)\n-    }\n-\n     /// Extend the string with the given `&OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n@@ -211,8 +221,16 @@ impl Hash for OsString {\n }\n \n impl OsStr {\n+    /// Coerce into an `OsStr` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr {\n+        s.as_ref()\n+    }\n+\n     /// Coerce directly from a `&str` slice to a `&OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `OsStr::new` instead\")]\n     pub fn from_str(s: &str) -> &OsStr {\n         unsafe { mem::transmute(Slice::from_str(s)) }\n     }\n@@ -239,6 +257,36 @@ impl OsStr {\n         OsString { inner: self.inner.to_owned() }\n     }\n \n+    /// Yield this `OsStr` as a byte slice.\n+    ///\n+    /// # Platform behavior\n+    ///\n+    /// On Unix systems, this is a no-op.\n+    ///\n+    /// On Windows systems, this returns `None` unless the `OsStr` is\n+    /// valid unicode, in which case it produces UTF-8-encoded\n+    /// data. This may entail checking validity.\n+    #[unstable(feature = \"convert\", reason = \"recently added\")]\n+    pub fn to_bytes(&self) -> Option<&[u8]> {\n+        if cfg!(windows) {\n+            self.to_str().map(|s| s.as_bytes())\n+        } else {\n+            Some(self.bytes())\n+        }\n+    }\n+\n+    /// Create a `CString` containing this `OsStr` data.\n+    ///\n+    /// Fails if the `OsStr` contains interior nulls.\n+    ///\n+    /// This is a convenience for creating a `CString` from\n+    /// `self.to_bytes()`, and inherits the platform behavior of the\n+    /// `to_bytes` method.\n+    #[unstable(feature = \"convert\", reason = \"recently added\")]\n+    pub fn to_cstring(&self) -> Option<CString> {\n+        self.to_bytes().and_then(|b| CString::new(b).ok())\n+    }\n+\n     /// Get the underlying byte representation.\n     ///\n     /// Note: it is *crucial* that this API is private, to avoid\n@@ -258,14 +306,14 @@ impl PartialEq for OsStr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<str> for OsStr {\n     fn eq(&self, other: &str) -> bool {\n-        *self == *OsStr::from_str(other)\n+        *self == *OsStr::new(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<OsStr> for str {\n     fn eq(&self, other: &OsStr) -> bool {\n-        *other == *OsStr::from_str(self)\n+        *other == *OsStr::new(self)\n     }\n }\n \n@@ -292,7 +340,7 @@ impl PartialOrd for OsStr {\n impl PartialOrd<str> for OsStr {\n     #[inline]\n     fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n-        self.partial_cmp(OsStr::from_str(other))\n+        self.partial_cmp(OsStr::new(other))\n     }\n }\n \n@@ -359,15 +407,15 @@ impl AsOsStr for OsString {\n #[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for str {\n     fn as_os_str(&self) -> &OsStr {\n-        OsStr::from_str(self)\n+        unsafe { mem::transmute(Slice::from_str(self)) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for String {\n     fn as_os_str(&self) -> &OsStr {\n-        OsStr::from_str(&self[..])\n+        unsafe { mem::transmute(Slice::from_str(self)) }\n     }\n }\n \n@@ -388,14 +436,14 @@ impl AsRef<OsStr> for OsString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for str {\n     fn as_ref(&self) -> &OsStr {\n-        OsStr::from_str(self)\n+        unsafe { mem::transmute(Slice::from_str(self)) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for String {\n     fn as_ref(&self) -> &OsStr {\n-        OsStr::from_str(&self[..])\n+        unsafe { mem::transmute(Slice::from_str(self)) }\n     }\n }\n "}, {"sha": "4f97ae8f69bba0541d2d54dbeeda74a7c3cae218", "filename": "src/libstd/fs.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -25,11 +25,6 @@ use sys::fs2 as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n \n-#[allow(deprecated)]\n-pub use self::tempdir::TempDir;\n-\n-mod tempdir;\n-\n /// A reference to an open file on the filesystem.\n ///\n /// An instance of a `File` can be read and/or written depending on what options\n@@ -56,7 +51,7 @@ mod tempdir;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct File {\n     inner: fs_imp::File,\n-    path: PathBuf,\n+    path: Option<PathBuf>,\n }\n \n /// Metadata information about a file.\n@@ -171,7 +166,7 @@ impl File {\n                reason = \"this abstraction is imposed by this library instead \\\n                          of the underlying OS and may be removed\")]\n     pub fn path(&self) -> Option<&Path> {\n-        Some(&self.path)\n+        self.path.as_ref().map(|p| &**p)\n     }\n \n     /// Attempt to sync all OS-internal metadata to disk.\n@@ -273,6 +268,12 @@ impl File {\n impl AsInner<fs_imp::File> for File {\n     fn as_inner(&self) -> &fs_imp::File { &self.inner }\n }\n+impl FromInner<fs_imp::File> for File {\n+    fn from_inner(f: fs_imp::File) -> File {\n+        File { inner: f, path: None }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -381,7 +382,7 @@ impl OpenOptions {\n     pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {\n         let path = path.as_ref();\n         let inner = try!(fs_imp::File::open(path, &self.0));\n-        Ok(File { path: path.to_path_buf(), inner: inner })\n+        Ok(File { path: Some(path.to_path_buf()), inner: inner })\n     }\n }\n \n@@ -575,8 +576,7 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n     let to = to.as_ref();\n     if !from.is_file() {\n         return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing file\",\n-                              None))\n+                              \"the source path is not an existing file\"))\n     }\n \n     let mut reader = try!(File::open(from));\n@@ -1327,7 +1327,7 @@ mod tests {\n         check!(fs::copy(&input, &out));\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n-        assert_eq!(v.as_slice(), b\"hello\");\n+        assert_eq!(v, b\"hello\");\n \n         assert_eq!(check!(input.metadata()).permissions(),\n                    check!(out.metadata()).permissions());\n@@ -1622,7 +1622,7 @@ mod tests {\n         check!(check!(File::create(&tmpdir.join(\"test\"))).write(&bytes));\n         let mut v = Vec::new();\n         check!(check!(File::open(&tmpdir.join(\"test\"))).read_to_end(&mut v));\n-        assert!(v == bytes.as_slice());\n+        assert!(v == &bytes[..]);\n     }\n \n     #[test]", "previous_filename": "src/libstd/fs/mod.rs"}, {"sha": "8cc1dde98a0b8bd25178874dfda8da92742d7d46", "filename": "src/libstd/fs/tempdir.rs", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,127 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"tempdir\", reason = \"needs an RFC before stabilization\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"use the `tempdir` crate from crates.io instead\")]\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-\n-use env;\n-use io::{self, Error, ErrorKind};\n-use fs;\n-use path::{self, PathBuf};\n-use rand::{thread_rng, Rng};\n-\n-/// A wrapper for a path to temporary directory implementing automatic\n-/// scope-based deletion.\n-pub struct TempDir {\n-    path: Option<PathBuf>,\n-}\n-\n-// How many times should we (re)try finding an unused random name? It should be\n-// enough that an attacker will run out of luck before we run out of patience.\n-const NUM_RETRIES: u32 = 1 << 31;\n-// How many characters should we include in a random file name? It needs to\n-// be enough to dissuade an attacker from trying to preemptively create names\n-// of that length, but not so huge that we unnecessarily drain the random number\n-// generator of entropy.\n-const NUM_RAND_CHARS: usize = 12;\n-\n-impl TempDir {\n-    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n-    /// will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)] // rand usage\n-    pub fn new_in<P: AsRef<path::Path>>(tmpdir: P, prefix: &str) -> io::Result<TempDir> {\n-        let storage;\n-        let mut tmpdir = tmpdir.as_ref();\n-        if !tmpdir.is_absolute() {\n-            let cur_dir = try!(env::current_dir());\n-            storage = cur_dir.join(tmpdir);\n-            tmpdir = &storage;\n-            // return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n-        }\n-\n-        let mut rng = thread_rng();\n-        for _ in 0..NUM_RETRIES {\n-            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n-            let leaf = if prefix.len() > 0 {\n-                format!(\"{}.{}\", prefix, suffix)\n-            } else {\n-                // If we're given an empty string for a prefix, then creating a\n-                // directory starting with \".\" would lead to it being\n-                // semi-invisible on some systems.\n-                suffix\n-            };\n-            let path = tmpdir.join(&leaf);\n-            match fs::create_dir(&path) {\n-                Ok(_) => return Ok(TempDir { path: Some(path) }),\n-                Err(ref e) if e.kind() == ErrorKind::AlreadyExists => {}\n-                Err(e) => return Err(e)\n-            }\n-        }\n-\n-        Err(Error::new(ErrorKind::AlreadyExists,\n-                       \"too many temporary directories already exist\",\n-                       None))\n-    }\n-\n-    /// Attempts to make a temporary directory inside of `env::temp_dir()` whose\n-    /// name will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)]\n-    pub fn new(prefix: &str) -> io::Result<TempDir> {\n-        TempDir::new_in(&env::temp_dir(), prefix)\n-    }\n-\n-    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n-    /// This discards the wrapper so that the automatic deletion of the\n-    /// temporary directory is prevented.\n-    pub fn into_path(mut self) -> PathBuf {\n-        self.path.take().unwrap()\n-    }\n-\n-    /// Access the wrapped `std::path::Path` to the temporary directory.\n-    pub fn path(&self) -> &path::Path {\n-        self.path.as_ref().unwrap()\n-    }\n-\n-    /// Close and remove the temporary directory\n-    ///\n-    /// Although `TempDir` removes the directory on drop, in the destructor\n-    /// any errors are ignored. To detect errors cleaning up the temporary\n-    /// directory, call `close` instead.\n-    pub fn close(mut self) -> io::Result<()> {\n-        self.cleanup_dir()\n-    }\n-\n-    fn cleanup_dir(&mut self) -> io::Result<()> {\n-        match self.path {\n-            Some(ref p) => fs::remove_dir_all(p),\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl Drop for TempDir {\n-    fn drop(&mut self) {\n-        let _ = self.cleanup_dir();\n-    }\n-}\n-\n-// the tests for this module need to change the path using change_dir,\n-// and this doesn't play nicely with other tests so these unit tests are located\n-// in src/test/run-pass/tempfile.rs"}, {"sha": "6fe35614a85b6da4e61be246ba0ab116cae70854", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,7 +16,7 @@ use prelude::v1::*;\n use io::prelude::*;\n \n use cmp;\n-use error::{self, FromError};\n+use error;\n use fmt;\n use io::{self, DEFAULT_BUF_SIZE, Error, ErrorKind};\n use ptr;\n@@ -165,7 +165,7 @@ impl<W: Write> BufWriter<W> {\n             match self.inner.as_mut().unwrap().write(&self.buf[written..]) {\n                 Ok(0) => {\n                     ret = Err(Error::new(ErrorKind::WriteZero,\n-                                         \"failed to write the buffered data\", None));\n+                                         \"failed to write the buffered data\"));\n                     break;\n                 }\n                 Ok(n) => written += n,\n@@ -264,8 +264,8 @@ impl<W> IntoInnerError<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> FromError<IntoInnerError<W>> for Error {\n-    fn from_error(iie: IntoInnerError<W>) -> Error { iie.1 }\n+impl<W> From<IntoInnerError<W>> for Error {\n+    fn from(iie: IntoInnerError<W>) -> Error { iie.1 }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -503,34 +503,34 @@ mod tests {\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(3), nread);\n+        assert_eq!(nread.unwrap(), 3);\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf, b);\n \n         let mut buf = [0, 0];\n         let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(2), nread);\n+        assert_eq!(nread.unwrap(), 2);\n         let b: &[_] = &[0, 1];\n         assert_eq!(buf, b);\n \n         let mut buf = [0];\n         let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n+        assert_eq!(nread.unwrap(), 1);\n         let b: &[_] = &[2];\n         assert_eq!(buf, b);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n+        assert_eq!(nread.unwrap(), 1);\n         let b: &[_] = &[3, 0, 0];\n         assert_eq!(buf, b);\n \n         let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n+        assert_eq!(nread.unwrap(), 1);\n         let b: &[_] = &[4, 0, 0];\n         assert_eq!(buf, b);\n \n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n     #[test]\n@@ -592,7 +592,7 @@ mod tests {\n         }\n \n         let mut stream = BufStream::new(S);\n-        assert_eq!(stream.read(&mut [0; 10]), Ok(0));\n+        assert_eq!(stream.read(&mut [0; 10]).unwrap(), 0);\n         stream.write(&[0; 10]).unwrap();\n         stream.flush().unwrap();\n     }\n@@ -658,41 +658,41 @@ mod tests {\n         let in_buf: &[u8] = b\"a\\nb\\nc\";\n         let reader = BufReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n-        assert_eq!(it.next(), Some(Ok(\"a\".to_string())));\n-        assert_eq!(it.next(), Some(Ok(\"b\".to_string())));\n-        assert_eq!(it.next(), Some(Ok(\"c\".to_string())));\n-        assert_eq!(it.next(), None);\n+        assert_eq!(it.next().unwrap().unwrap(), \"a\".to_string());\n+        assert_eq!(it.next().unwrap().unwrap(), \"b\".to_string());\n+        assert_eq!(it.next().unwrap().unwrap(), \"c\".to_string());\n+        assert!(it.next().is_none());\n     }\n \n     #[test]\n     fn test_short_reads() {\n         let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n         let mut reader = BufReader::new(inner);\n         let mut buf = [0, 0];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.read(&mut buf), Ok(2));\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 2);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n     #[test]\n     fn read_char_buffered() {\n         let buf = [195, 159];\n         let reader = BufReader::with_capacity(1, &buf[..]);\n-        assert_eq!(reader.chars().next(), Some(Ok('\u00df')));\n+        assert_eq!(reader.chars().next().unwrap().unwrap(), '\u00df');\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195, 159, b'a'];\n         let reader = BufReader::with_capacity(1, &buf[..]);\n         let mut it = reader.chars();\n-        assert_eq!(it.next(), Some(Ok('\u00df')));\n-        assert_eq!(it.next(), Some(Ok('a')));\n-        assert_eq!(it.next(), None);\n+        assert_eq!(it.next().unwrap().unwrap(), '\u00df');\n+        assert_eq!(it.next().unwrap().unwrap(), 'a');\n+        assert!(it.next().is_none());\n     }\n \n     #[test]"}, {"sha": "6433c29bb9d6e456d0701828cd576c58d2afe591", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -75,8 +75,7 @@ macro_rules! seek {\n \n             if pos < 0 {\n                 Err(Error::new(ErrorKind::InvalidInput,\n-                               \"invalid seek to a negative position\",\n-                               None))\n+                               \"invalid seek to a negative position\"))\n             } else {\n                 self.pos = pos as u64;\n                 Ok(self.pos)\n@@ -172,19 +171,19 @@ mod tests {\n     #[test]\n     fn test_vec_writer() {\n         let mut writer = Vec::new();\n-        assert_eq!(writer.write(&[0]), Ok(1));\n-        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n-        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        assert_eq!(writer.write(&[0]).unwrap(), 1);\n+        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         assert_eq!(writer, b);\n     }\n \n     #[test]\n     fn test_mem_writer() {\n         let mut writer = Cursor::new(Vec::new());\n-        assert_eq!(writer.write(&[0]), Ok(1));\n-        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n-        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        assert_eq!(writer.write(&[0]).unwrap(), 1);\n+        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         assert_eq!(&writer.get_ref()[..], b);\n     }\n@@ -195,16 +194,16 @@ mod tests {\n         {\n             let mut writer = Cursor::new(&mut buf[..]);\n             assert_eq!(writer.position(), 0);\n-            assert_eq!(writer.write(&[0]), Ok(1));\n+            assert_eq!(writer.write(&[0]).unwrap(), 1);\n             assert_eq!(writer.position(), 1);\n-            assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n-            assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+            assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+            assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n             assert_eq!(writer.position(), 8);\n-            assert_eq!(writer.write(&[]), Ok(0));\n+            assert_eq!(writer.write(&[]).unwrap(), 0);\n             assert_eq!(writer.position(), 8);\n \n-            assert_eq!(writer.write(&[8, 9]), Ok(1));\n-            assert_eq!(writer.write(&[10]), Ok(0));\n+            assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n+            assert_eq!(writer.write(&[10]).unwrap(), 0);\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n         assert_eq!(buf, b);\n@@ -216,22 +215,22 @@ mod tests {\n         {\n             let mut writer = Cursor::new(&mut buf[..]);\n             assert_eq!(writer.position(), 0);\n-            assert_eq!(writer.write(&[1]), Ok(1));\n+            assert_eq!(writer.write(&[1]).unwrap(), 1);\n             assert_eq!(writer.position(), 1);\n \n-            assert_eq!(writer.seek(SeekFrom::Start(2)), Ok(2));\n+            assert_eq!(writer.seek(SeekFrom::Start(2)).unwrap(), 2);\n             assert_eq!(writer.position(), 2);\n-            assert_eq!(writer.write(&[2]), Ok(1));\n+            assert_eq!(writer.write(&[2]).unwrap(), 1);\n             assert_eq!(writer.position(), 3);\n \n-            assert_eq!(writer.seek(SeekFrom::Current(-2)), Ok(1));\n+            assert_eq!(writer.seek(SeekFrom::Current(-2)).unwrap(), 1);\n             assert_eq!(writer.position(), 1);\n-            assert_eq!(writer.write(&[3]), Ok(1));\n+            assert_eq!(writer.write(&[3]).unwrap(), 1);\n             assert_eq!(writer.position(), 2);\n \n-            assert_eq!(writer.seek(SeekFrom::End(-1)), Ok(7));\n+            assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n             assert_eq!(writer.position(), 7);\n-            assert_eq!(writer.write(&[4]), Ok(1));\n+            assert_eq!(writer.write(&[4]).unwrap(), 1);\n             assert_eq!(writer.position(), 8);\n \n         }\n@@ -243,31 +242,31 @@ mod tests {\n     fn test_buf_writer_error() {\n         let mut buf = [0 as u8; 2];\n         let mut writer = Cursor::new(&mut buf[..]);\n-        assert_eq!(writer.write(&[0]), Ok(1));\n-        assert_eq!(writer.write(&[0, 0]), Ok(1));\n-        assert_eq!(writer.write(&[0, 0]), Ok(0));\n+        assert_eq!(writer.write(&[0]).unwrap(), 1);\n+        assert_eq!(writer.write(&[0, 0]).unwrap(), 1);\n+        assert_eq!(writer.write(&[0, 0]).unwrap(), 0);\n     }\n \n     #[test]\n     fn test_mem_reader() {\n         let mut reader = Cursor::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n         assert_eq!(reader.position(), 0);\n         let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n         assert_eq!(reader.position(), 1);\n         let b: &[_] = &[0];\n         assert_eq!(buf, b);\n         let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 4);\n         assert_eq!(reader.position(), 5);\n         let b: &[_] = &[1, 2, 3, 4];\n         assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 3);\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(&buf[..3], b);\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n     #[test]\n@@ -281,57 +280,57 @@ mod tests {\n     #[test]\n     fn test_slice_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = &mut in_buf.as_slice();\n+        let mut reader = &mut &in_buf[..];\n         let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n         let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n         assert_eq!(reader.len(), 7);\n         let b: &[_] = &[0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(&buf[..], b);\n         let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 4);\n         assert_eq!(reader.len(), 3);\n         let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf.as_slice(), b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n+        assert_eq!(&buf[..], b);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 3);\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(&buf[..3], b);\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n     #[test]\n     fn test_buf_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = Cursor::new(in_buf.as_slice());\n+        let mut reader = Cursor::new(&in_buf[..]);\n         let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n         assert_eq!(reader.position(), 0);\n         let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n         assert_eq!(reader.position(), 1);\n         let b: &[_] = &[0];\n         assert_eq!(buf, b);\n         let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 4);\n         assert_eq!(reader.position(), 5);\n         let b: &[_] = &[1, 2, 3, 4];\n         assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 3);\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(&buf[..3], b);\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n     #[test]\n     fn test_read_char() {\n         let b = &b\"Vi\\xE1\\xBB\\x87t\"[..];\n         let mut c = Cursor::new(b).chars();\n-        assert_eq!(c.next(), Some(Ok('V')));\n-        assert_eq!(c.next(), Some(Ok('i')));\n-        assert_eq!(c.next(), Some(Ok('\u1ec7')));\n-        assert_eq!(c.next(), Some(Ok('t')));\n-        assert_eq!(c.next(), None);\n+        assert_eq!(c.next().unwrap().unwrap(), 'V');\n+        assert_eq!(c.next().unwrap().unwrap(), 'i');\n+        assert_eq!(c.next().unwrap().unwrap(), '\u1ec7');\n+        assert_eq!(c.next().unwrap().unwrap(), 't');\n+        assert!(c.next().is_none());\n     }\n \n     #[test]\n@@ -345,17 +344,17 @@ mod tests {\n     fn seek_past_end() {\n         let buf = [0xff];\n         let mut r = Cursor::new(&buf[..]);\n-        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n-        assert_eq!(r.read(&mut [0]), Ok(0));\n+        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+        assert_eq!(r.read(&mut [0]).unwrap(), 0);\n \n         let mut r = Cursor::new(vec!(10));\n-        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n-        assert_eq!(r.read(&mut [0]), Ok(0));\n+        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+        assert_eq!(r.read(&mut [0]).unwrap(), 0);\n \n         let mut buf = [0];\n         let mut r = Cursor::new(&mut buf[..]);\n-        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n-        assert_eq!(r.write(&[3]), Ok(0));\n+        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+        assert_eq!(r.write(&[3]).unwrap(), 0);\n     }\n \n     #[test]\n@@ -376,41 +375,41 @@ mod tests {\n     fn test_seekable_mem_writer() {\n         let mut writer = Cursor::new(Vec::<u8>::new());\n         assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.write(&[0]).unwrap(), 1);\n         assert_eq!(writer.position(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n-        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n         assert_eq!(writer.position(), 8);\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         assert_eq!(&writer.get_ref()[..], b);\n \n-        assert_eq!(writer.seek(SeekFrom::Start(0)), Ok(0));\n+        assert_eq!(writer.seek(SeekFrom::Start(0)).unwrap(), 0);\n         assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write(&[3, 4]), Ok(2));\n+        assert_eq!(writer.write(&[3, 4]).unwrap(), 2);\n         let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n         assert_eq!(&writer.get_ref()[..], b);\n \n-        assert_eq!(writer.seek(SeekFrom::Current(1)), Ok(3));\n-        assert_eq!(writer.write(&[0, 1]), Ok(2));\n+        assert_eq!(writer.seek(SeekFrom::Current(1)).unwrap(), 3);\n+        assert_eq!(writer.write(&[0, 1]).unwrap(), 2);\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n         assert_eq!(&writer.get_ref()[..], b);\n \n-        assert_eq!(writer.seek(SeekFrom::End(-1)), Ok(7));\n-        assert_eq!(writer.write(&[1, 2]), Ok(2));\n+        assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n+        assert_eq!(writer.write(&[1, 2]).unwrap(), 2);\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n         assert_eq!(&writer.get_ref()[..], b);\n \n-        assert_eq!(writer.seek(SeekFrom::End(1)), Ok(10));\n-        assert_eq!(writer.write(&[1]), Ok(1));\n+        assert_eq!(writer.seek(SeekFrom::End(1)).unwrap(), 10);\n+        assert_eq!(writer.write(&[1]).unwrap(), 1);\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n         assert_eq!(&writer.get_ref()[..], b);\n     }\n \n     #[test]\n     fn vec_seek_past_end() {\n         let mut r = Cursor::new(Vec::new());\n-        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n-        assert_eq!(r.write(&[3]), Ok(1));\n+        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+        assert_eq!(r.write(&[3]).unwrap(), 1);\n     }\n \n     #[test]"}, {"sha": "b84dcb8fb620616f256927c8d68e69b8567ba0e9", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 34, "deletions": 55, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use boxed::Box;\n-use clone::Clone;\n+use convert::Into;\n use error;\n use fmt;\n+use marker::Send;\n use option::Option::{self, Some, None};\n use result;\n-use string::String;\n use sys;\n \n /// A type for results generated by I/O related functions where the `Err` type\n@@ -31,23 +31,22 @@ pub type Result<T> = result::Result<T, Error>;\n /// Errors mostly originate from the underlying OS, but custom instances of\n /// `Error` can be created with crafted error messages and a particular value of\n /// `ErrorKind`.\n-#[derive(PartialEq, Eq, Clone, Debug)]\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Error {\n     repr: Repr,\n }\n \n-#[derive(PartialEq, Eq, Clone, Debug)]\n+#[derive(Debug)]\n enum Repr {\n     Os(i32),\n     Custom(Box<Custom>),\n }\n \n-#[derive(PartialEq, Eq, Clone, Debug)]\n+#[derive(Debug)]\n struct Custom {\n     kind: ErrorKind,\n-    desc: &'static str,\n-    detail: Option<String>\n+    error: Box<error::Error+Send>,\n }\n \n /// A list specifying general categories of I/O error.\n@@ -125,18 +124,34 @@ pub enum ErrorKind {\n }\n \n impl Error {\n-    /// Creates a new custom error from a specified kind/description/detail.\n-    #[unstable(feature = \"io\", reason = \"the exact makeup of an Error may\n-                                         change to include `Box<Error>` for \\\n-                                         example\")]\n-    pub fn new(kind: ErrorKind,\n-               description: &'static str,\n-               detail: Option<String>) -> Error {\n+    /// Creates a new I/O error from a known kind of error as well as an\n+    /// arbitrary error payload.\n+    ///\n+    /// This function is used to generically create I/O errors which do not\n+    /// originate from the OS itself. The `error` argument is an arbitrary\n+    /// payload which will be contained in this `Error`. Accessors as well as\n+    /// downcasting will soon be added to this type as well to access the custom\n+    /// information.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{Error, ErrorKind};\n+    ///\n+    /// // errors can be created from strings\n+    /// let custom_error = Error::new(ErrorKind::Other, \"oh no!\");\n+    ///\n+    /// // errors can also be created from other errors\n+    /// let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new<E>(kind: ErrorKind, error: E) -> Error\n+        where E: Into<Box<error::Error+Send>>\n+    {\n         Error {\n             repr: Repr::Custom(Box::new(Custom {\n                 kind: kind,\n-                desc: description,\n-                detail: detail,\n+                error: error.into(),\n             }))\n         }\n     }\n@@ -162,8 +177,7 @@ impl Error {\n     ///\n     /// If this `Error` was constructed via `last_os_error` then this function\n     /// will return `Some`, otherwise it will return `None`.\n-    #[unstable(feature = \"io\", reason = \"function was just added and the return \\\n-                                         type may become an abstract OS error\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn raw_os_error(&self) -> Option<i32> {\n         match self.repr {\n             Repr::Os(i) => Some(i),\n@@ -179,27 +193,6 @@ impl Error {\n             Repr::Custom(ref c) => c.kind,\n         }\n     }\n-\n-    /// Returns a short description for this error message\n-    #[unstable(feature = \"io\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use the Error trait's description \\\n-                                            method instead\")]\n-    pub fn description(&self) -> &str {\n-        match self.repr {\n-            Repr::Os(..) => \"os error\",\n-            Repr::Custom(ref c) => c.desc,\n-        }\n-    }\n-\n-    /// Returns a detailed error message for this error (if one is available)\n-    #[unstable(feature = \"io\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use the to_string() method instead\")]\n-    pub fn detail(&self) -> Option<String> {\n-        match self.repr {\n-            Repr::Os(code) => Some(sys::os::error_string(code)),\n-            Repr::Custom(ref s) => s.detail.clone(),\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -210,21 +203,7 @@ impl fmt::Display for Error {\n                 let detail = sys::os::error_string(code);\n                 write!(fmt, \"{} (os error {})\", detail, code)\n             }\n-            Repr::Custom(ref c) => {\n-                match **c {\n-                    Custom {\n-                        kind: ErrorKind::Other,\n-                        desc: \"unknown error\",\n-                        detail: Some(ref detail)\n-                    } => {\n-                        write!(fmt, \"{}\", detail)\n-                    }\n-                    Custom { detail: None, desc, .. } =>\n-                        write!(fmt, \"{}\", desc),\n-                    Custom { detail: Some(ref detail), desc, .. } =>\n-                        write!(fmt, \"{} ({})\", desc, detail)\n-                }\n-            }\n+            Repr::Custom(ref c) => c.error.fmt(fmt),\n         }\n     }\n }\n@@ -234,7 +213,7 @@ impl error::Error for Error {\n     fn description(&self) -> &str {\n         match self.repr {\n             Repr::Os(..) => \"os error\",\n-            Repr::Custom(ref c) => c.desc,\n+            Repr::Custom(ref c) => c.error.description(),\n         }\n     }\n }"}, {"sha": "67bc45d3b62a1fd4d514b238786ccab5be086af8", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -180,7 +180,7 @@ impl<'a> Write for &'a mut [u8] {\n         if try!(self.write(data)) == data.len() {\n             Ok(())\n         } else {\n-            Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\", None))\n+            Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"))\n         }\n     }\n "}, {"sha": "a014d6e68ffb172fc8e910232226404da1e6c8ee", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -83,7 +83,7 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n         if str::from_utf8(&g.s[g.len..]).is_err() {\n             ret.and_then(|_| {\n                 Err(Error::new(ErrorKind::InvalidInput,\n-                               \"stream did not contain valid UTF-8\", None))\n+                               \"stream did not contain valid UTF-8\"))\n             })\n         } else {\n             g.len = g.s.len();\n@@ -359,8 +359,7 @@ pub trait Write {\n         while buf.len() > 0 {\n             match self.write(buf) {\n                 Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n-                                               \"failed to write whole buffer\",\n-                                               None)),\n+                                               \"failed to write whole buffer\")),\n                 Ok(n) => buf = &buf[n..],\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                 Err(e) => return Err(e),\n@@ -441,9 +440,7 @@ pub trait Write {\n ///\n /// The stream typically has a fixed size, allowing seeking relative to either\n /// end or the current offset.\n-#[unstable(feature = \"io\", reason = \"the central `seek` method may be split \\\n-                                     into multiple methods instead of taking \\\n-                                     an enum as an argument\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Seek {\n     /// Seek to an offset, in bytes, in a stream\n     ///\n@@ -459,28 +456,32 @@ pub trait Seek {\n     /// # Errors\n     ///\n     /// Seeking to a negative offset is considered an error\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n }\n \n /// Enumeration of possible methods to seek within an I/O object.\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n-#[unstable(feature = \"io\", reason = \"awaiting the stability of Seek\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SeekFrom {\n     /// Set the offset to the provided number of bytes.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Start(u64),\n \n     /// Set the offset to the size of this object plus the specified number of\n     /// bytes.\n     ///\n     /// It is possible to seek beyond the end of an object, but is an error to\n     /// seek before byte 0.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     End(i64),\n \n     /// Set the offset to the current position plus the specified number of\n     /// bytes.\n     ///\n     /// It is possible to seek beyond the end of an object, but is an error to\n     /// seek before byte 0.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Current(i64),\n }\n \n@@ -780,7 +781,7 @@ pub struct Chars<R> {\n \n /// An enumeration of possible errors that can be generated from the `Chars`\n /// adapter.\n-#[derive(PartialEq, Clone, Debug)]\n+#[derive(Debug)]\n #[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\")]\n pub enum CharsError {\n     /// Variant representing that the underlying stream was read successfully\n@@ -919,91 +920,91 @@ mod tests {\n     fn read_until() {\n         let mut buf = Cursor::new(&b\"12\"[..]);\n         let mut v = Vec::new();\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(2));\n+        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 2);\n         assert_eq!(v, b\"12\");\n \n         let mut buf = Cursor::new(&b\"1233\"[..]);\n         let mut v = Vec::new();\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(3));\n+        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 3);\n         assert_eq!(v, b\"123\");\n         v.truncate(0);\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(1));\n+        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 1);\n         assert_eq!(v, b\"3\");\n         v.truncate(0);\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(0));\n+        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 0);\n         assert_eq!(v, []);\n     }\n \n     #[test]\n     fn split() {\n         let buf = Cursor::new(&b\"12\"[..]);\n         let mut s = buf.split(b'3');\n-        assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n-        assert_eq!(s.next(), None);\n+        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n+        assert!(s.next().is_none());\n \n         let buf = Cursor::new(&b\"1233\"[..]);\n         let mut s = buf.split(b'3');\n-        assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n-        assert_eq!(s.next(), Some(Ok(vec![])));\n-        assert_eq!(s.next(), None);\n+        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n+        assert_eq!(s.next().unwrap().unwrap(), vec![]);\n+        assert!(s.next().is_none());\n     }\n \n     #[test]\n     fn read_line() {\n         let mut buf = Cursor::new(&b\"12\"[..]);\n         let mut v = String::new();\n-        assert_eq!(buf.read_line(&mut v), Ok(2));\n+        assert_eq!(buf.read_line(&mut v).unwrap(), 2);\n         assert_eq!(v, \"12\");\n \n         let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n         let mut v = String::new();\n-        assert_eq!(buf.read_line(&mut v), Ok(3));\n+        assert_eq!(buf.read_line(&mut v).unwrap(), 3);\n         assert_eq!(v, \"12\\n\");\n         v.truncate(0);\n-        assert_eq!(buf.read_line(&mut v), Ok(1));\n+        assert_eq!(buf.read_line(&mut v).unwrap(), 1);\n         assert_eq!(v, \"\\n\");\n         v.truncate(0);\n-        assert_eq!(buf.read_line(&mut v), Ok(0));\n+        assert_eq!(buf.read_line(&mut v).unwrap(), 0);\n         assert_eq!(v, \"\");\n     }\n \n     #[test]\n     fn lines() {\n         let buf = Cursor::new(&b\"12\"[..]);\n         let mut s = buf.lines();\n-        assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n-        assert_eq!(s.next(), None);\n+        assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n+        assert!(s.next().is_none());\n \n         let buf = Cursor::new(&b\"12\\n\\n\"[..]);\n         let mut s = buf.lines();\n-        assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n-        assert_eq!(s.next(), Some(Ok(String::new())));\n-        assert_eq!(s.next(), None);\n+        assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n+        assert_eq!(s.next().unwrap().unwrap(), \"\".to_string());\n+        assert!(s.next().is_none());\n     }\n \n     #[test]\n     fn read_to_end() {\n         let mut c = Cursor::new(&b\"\"[..]);\n         let mut v = Vec::new();\n-        assert_eq!(c.read_to_end(&mut v), Ok(0));\n+        assert_eq!(c.read_to_end(&mut v).unwrap(), 0);\n         assert_eq!(v, []);\n \n         let mut c = Cursor::new(&b\"1\"[..]);\n         let mut v = Vec::new();\n-        assert_eq!(c.read_to_end(&mut v), Ok(1));\n+        assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n         assert_eq!(v, b\"1\");\n     }\n \n     #[test]\n     fn read_to_string() {\n         let mut c = Cursor::new(&b\"\"[..]);\n         let mut v = String::new();\n-        assert_eq!(c.read_to_string(&mut v), Ok(0));\n+        assert_eq!(c.read_to_string(&mut v).unwrap(), 0);\n         assert_eq!(v, \"\");\n \n         let mut c = Cursor::new(&b\"1\"[..]);\n         let mut v = String::new();\n-        assert_eq!(c.read_to_string(&mut v), Ok(1));\n+        assert_eq!(c.read_to_string(&mut v).unwrap(), 1);\n         assert_eq!(v, \"1\");\n \n         let mut c = Cursor::new(&b\"\\xff\"[..]);\n@@ -1017,11 +1018,11 @@ mod tests {\n \n         impl Read for R {\n             fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-                Err(io::Error::new(io::ErrorKind::Other, \"\", None))\n+                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n             }\n         }\n \n         let mut buf = [0; 1];\n-        assert_eq!(Ok(0), R.take(0).read(&mut buf));\n+        assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n     }\n }"}, {"sha": "c82f9515e8d52813ba494a6b0a48b0b71bc27a65", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -111,33 +111,33 @@ mod test {\n     #[test]\n     fn sink_sinks() {\n         let mut s = sink();\n-        assert_eq!(s.write(&[]), Ok(0));\n-        assert_eq!(s.write(&[0]), Ok(1));\n-        assert_eq!(s.write(&[0; 1024]), Ok(1024));\n-        assert_eq!(s.by_ref().write(&[0; 1024]), Ok(1024));\n+        assert_eq!(s.write(&[]).unwrap(), 0);\n+        assert_eq!(s.write(&[0]).unwrap(), 1);\n+        assert_eq!(s.write(&[0; 1024]).unwrap(), 1024);\n+        assert_eq!(s.by_ref().write(&[0; 1024]).unwrap(), 1024);\n     }\n \n     #[test]\n     fn empty_reads() {\n         let mut e = empty();\n-        assert_eq!(e.read(&mut []), Ok(0));\n-        assert_eq!(e.read(&mut [0]), Ok(0));\n-        assert_eq!(e.read(&mut [0; 1024]), Ok(0));\n-        assert_eq!(e.by_ref().read(&mut [0; 1024]), Ok(0));\n+        assert_eq!(e.read(&mut []).unwrap(), 0);\n+        assert_eq!(e.read(&mut [0]).unwrap(), 0);\n+        assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n+        assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n     }\n \n     #[test]\n     fn repeat_repeats() {\n         let mut r = repeat(4);\n         let mut b = [0; 1024];\n-        assert_eq!(r.read(&mut b), Ok(1024));\n+        assert_eq!(r.read(&mut b).unwrap(), 1024);\n         assert!(b.iter().all(|b| *b == 4));\n     }\n \n     #[test]\n     fn take_some_bytes() {\n         assert_eq!(repeat(4).take(100).bytes().count(), 100);\n-        assert_eq!(repeat(4).take(100).bytes().next(), Some(Ok(4)));\n+        assert_eq!(repeat(4).take(100).bytes().next().unwrap().unwrap(), 4);\n         assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n     }\n \n@@ -146,7 +146,7 @@ mod test {\n         let mut buf = [0; 10];\n         {\n             let mut ptr: &mut [u8] = &mut buf;\n-            assert_eq!(repeat(4).tee(&mut ptr).take(5).read(&mut [0; 10]), Ok(5));\n+            assert_eq!(repeat(4).tee(&mut ptr).take(5).read(&mut [0; 10]).unwrap(), 5);\n         }\n         assert_eq!(buf, [4, 4, 4, 4, 4, 0, 0, 0, 0, 0]);\n     }\n@@ -160,7 +160,7 @@ mod test {\n             let mut ptr2: &mut [u8] = &mut buf2;\n \n             assert_eq!((&mut ptr1).broadcast(&mut ptr2)\n-                                  .write(&[1, 2, 3]), Ok(3));\n+                                  .write(&[1, 2, 3]).unwrap(), 3);\n         }\n         assert_eq!(buf1, buf2);\n         assert_eq!(buf1, [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]);"}, {"sha": "41ac3d60df5581db331d3cc4bdd6a4ac99586622", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -44,7 +44,7 @@\n //! lives in the [`vec`](vec/index.html) module. Contiguous, unsized regions\n //! of memory, `[T]`, commonly called \"slices\", and their borrowed versions,\n //! `&[T]`, commonly called \"borrowed slices\", are built-in types for which the\n-//! for which the [`slice`](slice/index.html) module defines many methods.\n+//! [`slice`](slice/index.html) module defines many methods.\n //!\n //! `&str`, a UTF-8 string, is a built-in type, and the standard library\n //! defines methods for it on a variety of traits in the\n@@ -122,12 +122,11 @@\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(macro_reexport)]\n #![feature(unique)]\n-#![feature(convert)]\n #![feature(allow_internal_unstable)]\n #![feature(str_char)]\n #![feature(into_cow)]\n-#![feature(slice_patterns)]\n #![feature(std_misc)]\n+#![feature(slice_patterns)]\n #![feature(debug_builders)]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n@@ -173,8 +172,6 @@ pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n pub use core::convert;\n pub use core::default;\n-#[allow(deprecated)]\n-pub use core::finally;\n pub use core::hash;\n pub use core::intrinsics;\n pub use core::iter;"}, {"sha": "b3d1adb44218a7e302037dd466640ece8a2039e0", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -101,7 +101,7 @@ macro_rules! try {\n     ($expr:expr) => (match $expr {\n         $crate::result::Result::Ok(val) => val,\n         $crate::result::Result::Err(err) => {\n-            return $crate::result::Result::Err($crate::error::FromError::from_error(err))\n+            return $crate::result::Result::Err($crate::convert::From::from(err))\n         }\n     })\n }"}, {"sha": "c45230e91ba9ea9b8e17b23657836934dd210cbf", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -435,7 +435,7 @@ impl ToSocketAddrs for str {\n                 match $e {\n                     Some(r) => r,\n                     None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                                      $msg, None)),\n+                                                      $msg)),\n                 }\n             )\n         }\n@@ -697,8 +697,11 @@ mod tests {\n               false, false, false, true,  false, false, false, Some(Global));\n     }\n \n-    fn tsa<A: ToSocketAddrs>(a: A) -> io::Result<Vec<SocketAddr>> {\n-        Ok(try!(a.to_socket_addrs()).collect())\n+    fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {\n+        match a.to_socket_addrs() {\n+            Ok(a) => Ok(a.collect()),\n+            Err(e) => Err(e.to_string()),\n+        }\n     }\n \n     #[test]"}, {"sha": "a152b98822a0bead2e9c337d927ca36d21a8fb02", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -72,7 +72,7 @@ fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n     }\n     Err(last_err.unwrap_or_else(|| {\n         Error::new(ErrorKind::InvalidInput,\n-                   \"could not resolve to any addresses\", None)\n+                   \"could not resolve to any addresses\")\n     }))\n }\n "}, {"sha": "04d1013af1faec67fd37be4cd91415bad249241f", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -17,7 +17,7 @@ use io::prelude::*;\n use io;\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n use sys_common::net2 as net_imp;\n-use sys_common::AsInner;\n+use sys_common::{AsInner, FromInner};\n \n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n@@ -100,13 +100,6 @@ impl TcpStream {\n         self.0.peer_addr()\n     }\n \n-    /// Returns the socket address of the local half of this TCP connection.\n-    #[unstable(feature = \"net\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.socket_addr()\n-    }\n-\n     /// Returns the socket address of the local half of this TCP connection.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n@@ -172,6 +165,10 @@ impl AsInner<net_imp::TcpStream> for TcpStream {\n     fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }\n }\n \n+impl FromInner<net_imp::TcpStream> for TcpStream {\n+    fn from_inner(inner: net_imp::TcpStream) -> TcpStream { TcpStream(inner) }\n+}\n+\n impl TcpListener {\n     /// Creates a new `TcpListener` which will be bound to the specified\n     /// address.\n@@ -195,13 +192,6 @@ impl TcpListener {\n         self.0.socket_addr()\n     }\n \n-    /// Deprecated, renamed to local_addr\n-    #[unstable(feature = \"net\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.socket_addr()\n-    }\n-\n     /// Create a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `TcpListener` is a reference to the same socket that this\n@@ -245,6 +235,12 @@ impl AsInner<net_imp::TcpListener> for TcpListener {\n     fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }\n }\n \n+impl FromInner<net_imp::TcpListener> for TcpListener {\n+    fn from_inner(inner: net_imp::TcpListener) -> TcpListener {\n+        TcpListener(inner)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n@@ -349,7 +345,7 @@ mod tests {\n             let _t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 t!(stream.write(&[99]));\n-                tx.send(t!(stream.socket_addr())).unwrap();\n+                tx.send(t!(stream.local_addr())).unwrap();\n             });\n \n             let (mut stream, addr) = t!(acceptor.accept());\n@@ -499,7 +495,7 @@ mod tests {\n     fn socket_and_peer_name_ip4() {\n         each_ip(&mut |addr| {\n             let listener = t!(TcpListener::bind(&addr));\n-            let so_name = t!(listener.socket_addr());\n+            let so_name = t!(listener.local_addr());\n             assert_eq!(addr, so_name);\n             let _t = thread::spawn(move|| {\n                 t!(listener.accept());\n@@ -525,7 +521,7 @@ mod tests {\n \n             let mut c = t!(TcpStream::connect(&addr));\n             let mut b = [0; 10];\n-            assert_eq!(c.read(&mut b), Ok(1));\n+            assert_eq!(c.read(&mut b).unwrap(), 1);\n             t!(c.write(&[1]));\n             rx.recv().unwrap();\n         })\n@@ -570,7 +566,7 @@ mod tests {\n             let _t = thread::spawn(move|| {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 0];\n-                assert_eq!(s.read(&mut buf), Ok(1));\n+                assert_eq!(s.read(&mut buf).unwrap(), 1);\n                 assert_eq!(buf[0], 1);\n                 t!(s.write(&[2]));\n             });\n@@ -588,7 +584,7 @@ mod tests {\n             });\n             tx1.send(()).unwrap();\n             let mut buf = [0, 0];\n-            assert_eq!(s1.read(&mut buf), Ok(1));\n+            assert_eq!(s1.read(&mut buf).unwrap(), 1);\n             rx2.recv().unwrap();\n         })\n     }\n@@ -661,7 +657,7 @@ mod tests {\n             let _t = thread::spawn(move|| {\n                 let mut c = t!(a.accept()).0;\n                 let mut b = [0];\n-                assert_eq!(c.read(&mut b), Ok(0));\n+                assert_eq!(c.read(&mut b).unwrap(), 0);\n                 t!(c.write(&[1]));\n             });\n \n@@ -692,16 +688,16 @@ mod tests {\n             t!(s.shutdown(Shutdown::Write));\n             assert!(s.write(&[0]).is_err());\n             t!(s.shutdown(Shutdown::Read));\n-            assert_eq!(s.read(&mut b), Ok(0));\n+            assert_eq!(s.read(&mut b).unwrap(), 0);\n \n             // closing should affect previous handles\n             assert!(s2.write(&[0]).is_err());\n-            assert_eq!(s2.read(&mut b), Ok(0));\n+            assert_eq!(s2.read(&mut b).unwrap(), 0);\n \n             // closing should affect new handles\n             let mut s3 = t!(s.try_clone());\n             assert!(s3.write(&[0]).is_err());\n-            assert_eq!(s3.read(&mut b), Ok(0));\n+            assert_eq!(s3.read(&mut b).unwrap(), 0);\n \n             // make sure these don't die\n             let _ = s2.shutdown(Shutdown::Read);"}, {"sha": "7b14e4dbea6788420954a43731d8853ddb154a66", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,7 +16,7 @@ use prelude::v1::*;\n use io::{self, Error, ErrorKind};\n use net::{ToSocketAddrs, SocketAddr, IpAddr};\n use sys_common::net2 as net_imp;\n-use sys_common::AsInner;\n+use sys_common::{AsInner, FromInner};\n \n /// A User Datagram Protocol socket.\n ///\n@@ -76,17 +76,10 @@ impl UdpSocket {\n         match try!(addr.to_socket_addrs()).next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n             None => Err(Error::new(ErrorKind::InvalidInput,\n-                                   \"no addresses to send data to\", None)),\n+                                   \"no addresses to send data to\")),\n         }\n     }\n \n-    /// Returns the socket address that this socket was created from.\n-    #[unstable(feature = \"net\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.socket_addr()\n-    }\n-\n     /// Returns the socket address that this socket was created from.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n@@ -140,6 +133,10 @@ impl AsInner<net_imp::UdpSocket> for UdpSocket {\n     fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }\n }\n \n+impl FromInner<net_imp::UdpSocket> for UdpSocket {\n+    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket { UdpSocket(inner) }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n@@ -203,7 +200,7 @@ mod tests {\n     fn socket_name_ip4() {\n         each_ip(&mut |addr, _| {\n             let server = t!(UdpSocket::bind(&addr));\n-            assert_eq!(addr, t!(server.socket_addr()));\n+            assert_eq!(addr, t!(server.local_addr()));\n         })\n     }\n \n@@ -215,7 +212,7 @@ mod tests {\n \n             let _t = thread::spawn(move|| {\n                 let mut buf = [0, 0];\n-                assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n+                assert_eq!(sock2.recv_from(&mut buf).unwrap(), (1, addr1));\n                 assert_eq!(buf[0], 1);\n                 t!(sock2.send_to(&[2], &addr1));\n             });\n@@ -231,7 +228,7 @@ mod tests {\n             });\n             tx1.send(()).unwrap();\n             let mut buf = [0, 0];\n-            assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n+            assert_eq!(sock1.recv_from(&mut buf).unwrap(), (1, addr2));\n             rx2.recv().unwrap();\n         })\n     }"}, {"sha": "68aa7e4770f067e3cada0738e0256ac7381d242a", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -548,7 +548,7 @@ mod test {\n         let mut w = BufferedWriter::with_capacity(3, Vec::new());\n         w.write_all(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n-        assert_eq!(a, &w.get_ref()[..]);\n+        assert_eq!(&w.get_ref()[..], a);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n         assert_eq!(a, &w[..]);"}, {"sha": "73973d0db282d26c92c8adc059d46bb0f1c5dc96", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -519,7 +519,8 @@ mod bench {\n         ({\n             use super::u64_from_be_bytes;\n \n-            let data = (0..$stride*100+$start_index).collect::<Vec<_>>();\n+            let len = ($stride as u8).wrapping_mul(100).wrapping_add($start_index);\n+            let data = (0..len).collect::<Vec<_>>();\n             let mut sum = 0;\n             $b.iter(|| {\n                 let mut i = $start_index;"}, {"sha": "bef6ea53e5085c2dc0f68c1055917dcaaba0237f", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -951,7 +951,8 @@ mod test {\n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n-        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n+        let temp = Path::new(::env::temp_dir().to_str().unwrap());\n+        let ret = temp.join(format!(\"rust-{}\", rand::random::<u32>()));\n         check!(old_io::fs::mkdir(&ret, old_io::USER_RWX));\n         TempDir(ret)\n     }\n@@ -1639,7 +1640,7 @@ mod test {\n \n         check!(File::create(&tmpdir.join(\"test\")).write(&bytes));\n         let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n-        assert!(actual == bytes.as_slice());\n+        assert!(actual == &bytes[..]);\n     }\n \n     #[test]"}, {"sha": "c92e74fbc565e10b3a84aa46c67b86a630d816d8", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -399,7 +399,7 @@ impl<'a> Buffer for BufReader<'a> {\n mod test {\n     extern crate test as test_crate;\n     use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek, Buffer};\n-    use prelude::v1::{Ok, Err, Vec,  AsSlice};\n+    use prelude::v1::{Ok, Err, Vec};\n     use prelude::v1::Iterator;\n     use old_io;\n     use iter::repeat;\n@@ -744,7 +744,7 @@ mod test {\n                     wr.write(&[5; 10]).unwrap();\n                 }\n             }\n-            assert_eq!(buf.as_slice(), [5; 100].as_slice());\n+            assert_eq!(&buf[..], &[5; 100][..]);\n         });\n     }\n "}, {"sha": "9d7e1082d33b14fb42e76612a3b67debd55be8c6", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -274,7 +274,7 @@ use mem::transmute;\n use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n-use os;\n+use sys::os;\n use boxed::Box;\n use result::Result;\n use result::Result::{Ok, Err};"}, {"sha": "099fe657f2602b761d74e3cffb955240b54a4434", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -414,7 +414,7 @@ pub struct ParseError;\n /// Some examples:\n ///\n /// ```rust,no_run\n-/// # #![feature(old_io, core)]\n+/// # #![feature(old_io, core, convert)]\n /// # #![allow(unused_must_use)]\n ///\n /// use std::old_io::{TcpStream, TcpListener};\n@@ -435,7 +435,7 @@ pub struct ParseError;\n ///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n ///\n ///     let mut udp_s = UdpSocket::bind((\"127.0.0.1\", 23451)).unwrap();\n-///     udp_s.send_to([7, 7, 7].as_slice(), (Ipv4Addr(127, 0, 0, 1), 23451));\n+///     udp_s.send_to([7, 7, 7].as_ref(), (Ipv4Addr(127, 0, 0, 1), 23451));\n /// }\n /// ```\n pub trait ToSocketAddr {"}, {"sha": "fd1df49473e586d4bd6c40b8a497bf1a1937d963", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -124,9 +124,9 @@ mod test {\n         use os;\n         use old_io::pipe::PipeStream;\n \n-        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-        let out = PipeStream::open(writer);\n-        let mut input = PipeStream::open(reader);\n+        let (reader, writer) = unsafe { ::sys::os::pipe().unwrap() };\n+        let out = PipeStream::open(writer.unwrap());\n+        let mut input = PipeStream::open(reader.unwrap());\n         let (tx, rx) = channel();\n         let _t = thread::spawn(move|| {\n             let mut out = out;"}, {"sha": "ad2d5b4681978c99e5231f20cacdaad5eb4ee7c8", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -246,7 +246,7 @@ impl Command {\n             None => {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n-                self.env = Some(os::env_as_bytes().into_iter().map(|(k, v)| {\n+                self.env = Some(::env::vars().map(|(k, v)| {\n                     (EnvKey(CString::new(k).unwrap()),\n                      CString::new(v).unwrap())\n                 }).collect());\n@@ -367,7 +367,7 @@ impl Command {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(old_io, core)]\n+    /// # #![feature(old_io, core, convert)]\n     /// use std::old_io::Command;\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n@@ -376,8 +376,8 @@ impl Command {\n     /// };\n     ///\n     /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", String::from_utf8_lossy(output.output.as_slice()));\n-    /// println!(\"stderr: {}\", String::from_utf8_lossy(output.error.as_slice()));\n+    /// println!(\"stdout: {}\", String::from_utf8_lossy(output.output.as_ref()));\n+    /// println!(\"stderr: {}\", String::from_utf8_lossy(output.error.as_ref()));\n     /// ```\n     pub fn output(&self) -> IoResult<ProcessOutput> {\n         self.spawn().and_then(|p| p.wait_with_output())\n@@ -764,11 +764,9 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::v1::*;\n     use old_io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n     use old_io::{Reader, Writer};\n-    use prelude::v1::{Ok, Err, drop, Some, None, Vec};\n-    use prelude::v1::{String, Clone};\n-    use prelude::v1::{Str, AsSlice, ToString};\n     use old_path::{GenericPath, Path};\n     use old_io::fs::PathExtensions;\n     use old_io::timer::*;\n@@ -1003,7 +1001,7 @@ mod tests {\n         let prog = pwd_cmd().spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let parent_dir = os::getcwd().unwrap();\n+        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n         let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -1018,7 +1016,7 @@ mod tests {\n         use os;\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = os::getcwd().unwrap().dir_path();\n+        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n@@ -1058,11 +1056,11 @@ mod tests {\n         let prog = env_cmd().spawn().unwrap();\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n-        let r = os::env();\n-        for &(ref k, ref v) in &r {\n+        let r = ::env::vars();\n+        for (k, v) in r {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() ||\n-                    output.contains(&format!(\"{}={}\", *k, *v)),\n+                    output.contains(&format!(\"{}={}\", k, v)),\n                     \"output doesn't contain `{}={}`\\n{}\",\n                     k, v, output);\n         }\n@@ -1076,16 +1074,12 @@ mod tests {\n         let mut prog = env_cmd().spawn().unwrap();\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n-        let r = os::env();\n-        for &(ref k, ref v) in &r {\n+        let r = ::env::vars();\n+        for (k, v) in r {\n             // don't check android RANDOM variables\n-            if *k != \"RANDOM\".to_string() {\n-                assert!(output.contains(&format!(\"{}={}\",\n-                                                 *k,\n-                                                 *v)) ||\n-                        output.contains(&format!(\"{}=\\'{}\\'\",\n-                                                 *k,\n-                                                 *v)));\n+            if k != \"RANDOM\".to_string() {\n+                assert!(output.contains(&format!(\"{}={}\", k, v)) ||\n+                        output.contains(&format!(\"{}=\\'{}\\'\", k, v)));\n             }\n         }\n     }\n@@ -1100,9 +1094,9 @@ mod tests {\n         // PATH to our sub-process.\n         let path_val: String;\n         let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n-        match os::getenv(\"PATH\") {\n-            None => {}\n-            Some(val) => {\n+        match ::env::var(\"PATH\") {\n+            Err(..) => {}\n+            Ok(val) => {\n                 path_val = val;\n                 new_env.push((\"PATH\", &path_val))\n             }"}, {"sha": "94faa5540bb30d538945a8e27b8c239a61345aee", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -100,7 +100,8 @@ impl TempDir {\n     #[allow(deprecated)]\n     pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n-            let cur_dir = try!(::os::getcwd());\n+            let cur_dir = ::env::current_dir().unwrap();\n+            let cur_dir = Path::new(cur_dir.to_str().unwrap());\n             return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n         }\n \n@@ -136,7 +137,8 @@ impl TempDir {\n     /// If no directory can be created, `Err` is returned.\n     #[allow(deprecated)]\n     pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&::os::tmpdir(), prefix)\n+        let tmp = Path::new(::env::temp_dir().to_str().unwrap());\n+        TempDir::new_in(&tmp, prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "312e1c814dc58e730c588e446da5dbcd877879ce", "filename": "src/libstd/old_io/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -43,7 +43,7 @@ fn next_test_unix_socket() -> String {\n pub fn next_test_unix() -> Path {\n     let string = next_test_unix_socket();\n     if cfg!(unix) {\n-        ::os::tmpdir().join(string)\n+        Path::new(::env::temp_dir().to_str().unwrap()).join(string)\n     } else {\n         Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n     }\n@@ -141,22 +141,22 @@ mod darwin_fd_limit {\n         // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n         use ptr::null_mut;\n         use mem::size_of_val;\n-        use os::last_os_error;\n+        use io;\n \n         // Fetch the kern.maxfilesperproc value\n         let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n         let mut maxfiles: libc::c_int = 0;\n         let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n         if sysctl(&mut mib[0], 2, &mut maxfiles as *mut libc::c_int as *mut libc::c_void, &mut size,\n                   null_mut(), 0) != 0 {\n-            let err = last_os_error();\n+            let err = io::Error::last_os_error();\n             panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n         }\n \n         // Fetch the current resource limits\n         let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n         if getrlimit(RLIMIT_NOFILE, &mut rlim) != 0 {\n-            let err = last_os_error();\n+            let err = io::Error::last_os_error();\n             panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n         }\n \n@@ -165,7 +165,7 @@ mod darwin_fd_limit {\n \n         // Set our newly-increased resource limit\n         if setrlimit(RLIMIT_NOFILE, &rlim) != 0 {\n-            let err = last_os_error();\n+            let err = io::Error::last_os_error();\n             panic!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n         }\n     }"}, {"sha": "a5ecb98334a81f1fc977e17f2ff4d021d7a7b261", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -334,7 +334,7 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n+            assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n         }\n     }\n \n@@ -343,9 +343,9 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!([0, 1], r.read_to_end().unwrap());\n+            assert_eq!(r.read_to_end().unwrap(), [0, 1]);\n         }\n-        assert_eq!([2], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [2]);\n     }\n \n     #[test]\n@@ -355,7 +355,7 @@ mod test {\n         assert_eq!(3, r.limit());\n         assert_eq!(0, r.read_byte().unwrap());\n         assert_eq!(2, r.limit());\n-        assert_eq!([1, 2], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [1, 2]);\n         assert_eq!(0, r.limit());\n     }\n \n@@ -364,7 +364,7 @@ mod test {\n         let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n         let mut r = LimitReader::new(r.by_ref(), 1);\n         r.consume(2);\n-        assert_eq!([], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), []);\n     }\n \n     #[test]\n@@ -380,7 +380,7 @@ mod test {\n         let mut s = ZeroReader;\n         let mut buf = vec![1, 2, 3];\n         assert_eq!(s.read(&mut buf), Ok(3));\n-        assert_eq!([0, 0, 0], buf);\n+        assert_eq!(buf, [0, 0, 0]);\n     }\n \n     #[test]\n@@ -423,24 +423,24 @@ mod test {\n         let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n                       MemReader::new(vec!(2, 3)));\n         let mut r = ChainedReader::new(rs.into_iter());\n-        assert_eq!([0, 1, 2, 3], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    Vec::new());\n-        assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n         let (_, w) = r.into_inner();\n-        assert_eq!([0, 1, 2], w);\n+        assert_eq!(w, [0, 1, 2]);\n     }\n \n     #[test]\n     fn test_copy() {\n         let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut w = Vec::new();\n         copy(&mut r, &mut w).unwrap();\n-        assert_eq!([0, 1, 2, 3, 4], w);\n+        assert_eq!(w, [0, 1, 2, 3, 4]);\n     }\n \n     #[test]"}, {"sha": "9c88533d3bac605cb55b328b7265b8cb98a9ab5b", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -69,12 +69,13 @@\n use core::marker::Sized;\n use ffi::CString;\n use clone::Clone;\n+use borrow::Cow;\n use fmt;\n use iter::Iterator;\n use option::Option;\n use option::Option::{None, Some};\n use str;\n-use string::{String, CowString};\n+use string::String;\n use vec::Vec;\n \n /// Typedef for POSIX file paths.\n@@ -907,7 +908,7 @@ impl<'a, P: GenericPath> Display<'a, P> {\n     /// If the path is not UTF-8, invalid sequences will be replaced with the\n     /// Unicode replacement char. This involves allocation.\n     #[inline]\n-    pub fn as_cow(&self) -> CowString<'a> {\n+    pub fn as_cow(&self) -> Cow<'a, str> {\n         String::from_utf8_lossy(if self.filename {\n             match self.path.filename() {\n                 None => {"}, {"sha": "c517fab257f9574678d813ff07b0e20c63da59f9", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -20,7 +20,7 @@ use iter::{Iterator, Map};\n use marker::Sized;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n-use slice::{AsSlice, Split, SliceConcatExt};\n+use slice::{Split, SliceConcatExt};\n use str::{self, FromStr};\n use vec::Vec;\n \n@@ -126,7 +126,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if b\"..\" == self.repr => {\n+            None if self.repr == b\"..\" => {\n                 let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n@@ -186,7 +186,7 @@ impl GenericPath for Path {\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if b\"..\" == self.repr => &self.repr,\n+            None if self.repr == b\"..\" => &self.repr,\n             None => dot_static,\n             Some(0) => &self.repr[..1],\n             Some(idx) if &self.repr[idx+1..] == b\"..\" => &self.repr,\n@@ -196,8 +196,7 @@ impl GenericPath for Path {\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if b\".\" == self.repr ||\n-                b\"..\" == self.repr => None,\n+            None if self.repr == b\".\" || self.repr == b\"..\" => None,\n             None => Some(&self.repr),\n             Some(idx) if &self.repr[idx+1..] == b\"..\" => None,\n             Some(0) if self.repr[1..].is_empty() => None,\n@@ -207,13 +206,13 @@ impl GenericPath for Path {\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if b\".\" == self.repr => false,\n+            None if self.repr == b\".\" => false,\n             None => {\n                 self.repr = vec![b'.'];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if b\"/\" == self.repr => false,\n+            Some(0) if self.repr == b\"/\" => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n@@ -245,7 +244,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if b\".\" == self.repr {\n+            if self.repr == b\".\" {\n                 return match itb.next() {\n                     None => true,\n                     Some(b) => b != b\"..\"\n@@ -339,11 +338,11 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<V: ?Sized + AsSlice<u8>>(v: &V) -> Vec<u8> {\n+    fn normalize(v: &[u8]) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n-            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { &v.as_slice()[1..] } else { v.as_slice() };\n+            let is_abs = !v.is_empty() && v[0] == SEP_BYTE;\n+            let v_ = if is_abs { &v[1..] } else { v };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -371,7 +370,7 @@ impl Path {\n             }\n         };\n         match val {\n-            None => v.as_slice().to_vec(),\n+            None => v.to_vec(),\n             Some(val) => val\n         }\n     }\n@@ -446,8 +445,7 @@ mod tests {\n     use clone::Clone;\n     use option::Option::{self, Some, None};\n     use old_path::GenericPath;\n-    use slice::AsSlice;\n-    use str::{self, Str};\n+    use str;\n     use string::ToString;\n     use vec::Vec;\n     use iter::Iterator;"}, {"sha": "0b88f368b3952aa9985839ec42636dc40e88f70c", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -1129,8 +1129,6 @@ mod tests {\n     use iter::Iterator;\n     use option::Option::{self, Some, None};\n     use old_path::GenericPath;\n-    use slice::AsSlice;\n-    use str::Str;\n     use string::ToString;\n     use vec::Vec;\n "}, {"sha": "ee0f04cb9911cc8ccf55bd53e262b8cf5d0ccebf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1819, "changes": 1821, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,1826 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Higher-level interfaces to libc::* functions and operating system services.\n-//!\n-//! In general these take and return rust types, use rust idioms (enums,\n-//! closures, vectors) rather than C idioms, and do more extensive safety\n-//! checks.\n-//!\n-//! This module is not meant to only contain 1:1 mappings to libc entries; any\n-//! os-interface code that is reasonably useful and broadly applicable can go\n-//! here. Including utility routines that merely build on other os code.\n-//!\n-//! We assume the general case is that users do not care, and do not want to be\n-//! made to care, which operating system they are on. While they may want to\n-//! special case various special cases -- and so we will not _hide_ the facts of\n-//! which OS the user is on -- they should be given the opportunity to write\n-//! OS-ignorant code by default.\n+//! OS-specific functionality\n \n-#![unstable(feature = \"os\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced with std::env APIs\")]\n-\n-#![allow(missing_docs)]\n-#![allow(non_snake_case)]\n-#![allow(unused_imports)]\n-#![allow(deprecated)]\n-\n-use self::MemoryMapKind::*;\n-use self::MapOption::*;\n-use self::MapError::*;\n-\n-use boxed::Box;\n-use clone::Clone;\n-use convert::From;\n-use env;\n-use error::{FromError, Error};\n-use ffi::{OsString, OsStr};\n-use fmt;\n-use iter::Iterator;\n-use libc::{c_void, c_int, c_char};\n-use libc;\n-use marker::{Copy, Send};\n-use old_io::{IoResult, IoError};\n-use ops::{Drop, FnOnce};\n-use option::Option::{Some, None};\n-use option::Option;\n-use old_path::{Path, GenericPath, BytesContainer};\n-use path::{self, PathBuf};\n-use ptr;\n-use result::Result::{Err, Ok};\n-use result::Result;\n-use slice::AsSlice;\n-use str::Str;\n-use str;\n-use string::{String, ToString};\n-use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n-use sys::os as os_imp;\n-use sys;\n-use vec::Vec;\n-\n-#[cfg(unix)] use ffi::{self, CString};\n+#![stable(feature = \"os\", since = \"1.0.0\")]\n \n #[cfg(unix)] pub use sys::ext as unix;\n #[cfg(windows)] pub use sys::ext as windows;\n-\n-fn err2old(new: ::io::Error) -> IoError {\n-    IoError {\n-        kind: ::old_io::OtherIoError,\n-        desc: \"os error\",\n-        detail: Some(new.to_string()),\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn path2new(path: &Path) -> PathBuf {\n-    PathBuf::from(path.as_str().unwrap())\n-}\n-#[cfg(unix)]\n-fn path2new(path: &Path) -> PathBuf {\n-    use os::unix::prelude::*;\n-    PathBuf::from(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n-}\n-\n-#[cfg(unix)]\n-fn path2old(path: &path::Path) -> Path {\n-    use os::unix::prelude::*;\n-    use ffi::AsOsStr;\n-    Path::new(path.as_os_str().as_bytes())\n-}\n-#[cfg(windows)]\n-fn path2old(path: &path::Path) -> Path {\n-    Path::new(path.to_str().unwrap())\n-}\n-\n-/// Get the number of cores available\n-pub fn num_cpus() -> usize {\n-    unsafe {\n-        return rust_get_num_cpus() as usize;\n-    }\n-\n-    extern {\n-        fn rust_get_num_cpus() -> libc::uintptr_t;\n-    }\n-}\n-\n-pub const TMPBUF_SZ : usize = 1000;\n-\n-/// Returns the current working directory as a `Path`.\n-///\n-/// # Errors\n-///\n-/// Returns an `Err` if the current working directory value is invalid.\n-/// Possible cases:\n-///\n-/// * Current directory does not exist.\n-/// * There are insufficient permissions to access the current directory.\n-/// * The internal buffer is not large enough to hold the path.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// // We assume that we are in a valid directory.\n-/// let current_working_directory = os::getcwd().unwrap();\n-/// println!(\"The current directory is {:?}\", current_working_directory.display());\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn getcwd() -> IoResult<Path> {\n-    env::current_dir().map_err(err2old).map(|s| path2old(&s))\n-}\n-\n-/// Returns a vector of (variable, value) pairs, for all the environment\n-/// variables of the current process.\n-///\n-/// Invalid UTF-8 bytes are replaced with \\uFFFD. See `String::from_utf8_lossy()`\n-/// for details.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// // We will iterate through the references to the element returned by os::env();\n-/// for &(ref key, ref value) in os::env().iter() {\n-///     println!(\"'{}': '{}'\", key, value );\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn env() -> Vec<(String,String)> {\n-    env::vars_os().map(|(k, v)| {\n-        (k.to_string_lossy().into_owned(), v.to_string_lossy().into_owned())\n-    }).collect()\n-}\n-\n-/// Returns a vector of (variable, value) byte-vector pairs for all the\n-/// environment variables of the current process.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::vars_os instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n-    env::vars_os().map(|(k, v)| (byteify(k), byteify(v))).collect()\n-}\n-\n-/// Fetches the environment variable `n` from the current process, returning\n-/// None if the variable isn't set.\n-///\n-/// Any invalid UTF-8 bytes in the value are replaced by \\uFFFD. See\n-/// `String::from_utf8_lossy()` for details.\n-///\n-/// # Panics\n-///\n-/// Panics if `n` has any interior NULs.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// let key = \"HOME\";\n-/// match os::getenv(key) {\n-///     Some(val) => println!(\"{}: {}\", key, val),\n-///     None => println!(\"{} is not defined in the environment.\", key)\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::var instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn getenv(n: &str) -> Option<String> {\n-    env::var(n).ok()\n-}\n-\n-/// Fetches the environment variable `n` byte vector from the current process,\n-/// returning None if the variable isn't set.\n-///\n-/// # Panics\n-///\n-/// Panics if `n` has any interior NULs.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::var_os instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    env::var_os(n).map(byteify)\n-}\n-\n-#[cfg(unix)]\n-fn byteify(s: OsString) -> Vec<u8> {\n-    use os::unix::prelude::*;\n-    s.into_vec()\n-}\n-#[cfg(windows)]\n-fn byteify(s: OsString) -> Vec<u8> {\n-    s.to_string_lossy().as_bytes().to_vec()\n-}\n-\n-/// Sets the environment variable `n` to the value `v` for the currently running\n-/// process.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// let key = \"KEY\";\n-/// os::setenv(key, \"VALUE\");\n-/// match os::getenv(key) {\n-///     Some(ref val) => println!(\"{}: {}\", key, val),\n-///     None => println!(\"{} is not defined in the environment.\", key)\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_var\")]\n-#[unstable(feature = \"os\")]\n-pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n-    #[cfg(unix)]\n-    fn _setenv(n: &str, v: &[u8]) {\n-        use os::unix::prelude::*;\n-        let v: OsString = OsStringExt::from_vec(v.to_vec());\n-        env::set_var(n, &v)\n-    }\n-\n-    #[cfg(windows)]\n-    fn _setenv(n: &str, v: &[u8]) {\n-        let v = str::from_utf8(v).unwrap();\n-        env::set_var(n, v)\n-    }\n-\n-    _setenv(n, v.container_as_bytes())\n-}\n-\n-/// Remove a variable from the environment entirely.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::remove_var\")]\n-#[unstable(feature = \"os\")]\n-pub fn unsetenv(n: &str) {\n-    env::remove_var(n)\n-}\n-\n-/// Parses input according to platform conventions for the `PATH`\n-/// environment variable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_path, os)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// let key = \"PATH\";\n-/// match os::getenv_as_bytes(key) {\n-///     Some(paths) => {\n-///         for path in os::split_paths(paths).iter() {\n-///             println!(\"'{}'\", path.display());\n-///         }\n-///     }\n-///     None => println!(\"{} is not defined in the environment.\", key)\n-/// }\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    let b = unparsed.container_as_bytes();\n-    let s = str::from_utf8(b).unwrap();\n-    env::split_paths(s).map(|s| path2old(&s)).collect()\n-}\n-\n-/// Joins a collection of `Path`s appropriately for the `PATH`\n-/// environment variable.\n-///\n-/// Returns a `Vec<u8>` on success, since `Path`s are not utf-8\n-/// encoded on all platforms.\n-///\n-/// Returns an `Err` (containing an error message) if one of the input\n-/// `Path`s contains an invalid character for constructing the `PATH`\n-/// variable (a double quote on Windows or a colon on Unix).\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path, core)]\n-/// use std::os;\n-/// use std::old_path::Path;\n-///\n-/// let key = \"PATH\";\n-/// let mut paths = os::getenv_as_bytes(key).map_or(Vec::new(), os::split_paths);\n-/// paths.push(Path::new(\"/home/xyz/bin\"));\n-/// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-    env::join_paths(paths.iter().map(|s| {\n-        str::from_utf8(s.container_as_bytes()).unwrap()\n-    })).map(|s| {\n-        s.to_string_lossy().into_owned().into_bytes()\n-    }).map_err(|_| \"failed to join paths\")\n-}\n-\n-/// A low-level OS in-memory pipe.\n-#[derive(Copy)]\n-pub struct Pipe {\n-    /// A file descriptor representing the reading end of the pipe. Data written\n-    /// on the `out` file descriptor can be read from this file descriptor.\n-    pub reader: c_int,\n-    /// A file descriptor representing the write end of the pipe. Data written\n-    /// to this file descriptor can be read from the `input` file descriptor.\n-    pub writer: c_int,\n-}\n-\n-/// Creates a new low-level OS in-memory pipe.\n-///\n-/// This function can fail to succeed if there are no more resources available\n-/// to allocate a pipe.\n-///\n-/// This function is also unsafe as there is no destructor associated with the\n-/// `Pipe` structure will return. If it is not arranged for the returned file\n-/// descriptors to be closed, the file descriptors will leak. For safe handling\n-/// of this scenario, use `std::old_io::PipeStream` instead.\n-pub unsafe fn pipe() -> IoResult<Pipe> {\n-    let (reader, writer) = try!(sys::os::pipe());\n-    Ok(Pipe {\n-        reader: reader.unwrap(),\n-        writer: writer.unwrap(),\n-    })\n-}\n-\n-/// Returns the proper dll filename for the given basename of a file\n-/// as a String.\n-#[cfg(not(target_os=\"ios\"))]\n-#[deprecated(since = \"1.0.0\", reason = \"this function will be removed, use the constants directly\")]\n-#[unstable(feature = \"os\")]\n-#[allow(deprecated)]\n-pub fn dll_filename(base: &str) -> String {\n-    format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n-}\n-\n-/// Optionally returns the filesystem path to the current executable which is\n-/// running but with the executable name.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// match os::self_exe_name() {\n-///     Some(exe_path) => println!(\"Path of this executable is: {}\", exe_path.display()),\n-///     None => println!(\"Unable to get the path of this executable!\")\n-/// };\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn self_exe_name() -> Option<Path> {\n-    env::current_exe().ok().map(|p| path2old(&p))\n-}\n-\n-/// Optionally returns the filesystem path to the current executable which is\n-/// running.\n-///\n-/// Like self_exe_name() but without the binary's name.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// match os::self_exe_path() {\n-///     Some(exe_path) => println!(\"Executable's Path is: {}\", exe_path.display()),\n-///     None => println!(\"Impossible to fetch the path of this executable.\")\n-/// };\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn self_exe_path() -> Option<Path> {\n-    env::current_exe().ok().map(|p| { let mut p = path2old(&p); p.pop(); p })\n-}\n-\n-/// Optionally returns the path to the current user's home directory if known.\n-///\n-/// # Unix\n-///\n-/// Returns the value of the 'HOME' environment variable if it is set\n-/// and not equal to the empty string.\n-///\n-/// # Windows\n-///\n-/// Returns the value of the 'HOME' environment variable if it is\n-/// set and not equal to the empty string. Otherwise, returns the value of the\n-/// 'USERPROFILE' environment variable if it is set and not equal to the empty\n-/// string.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// match os::homedir() {\n-///     Some(ref p) => println!(\"{}\", p.display()),\n-///     None => println!(\"Impossible to get your home dir!\")\n-/// }\n-/// ```\n-#[unstable(feature = \"os\")]\n-#[allow(deprecated)]\n-pub fn homedir() -> Option<Path> {\n-    #[inline]\n-    #[cfg(unix)]\n-    fn _homedir() -> Option<Path> {\n-        aux_homedir(\"HOME\")\n-    }\n-\n-    #[inline]\n-    #[cfg(windows)]\n-    fn _homedir() -> Option<Path> {\n-        aux_homedir(\"HOME\").or(aux_homedir(\"USERPROFILE\"))\n-    }\n-\n-    #[inline]\n-    fn aux_homedir(home_name: &str) -> Option<Path> {\n-        match getenv_as_bytes(home_name) {\n-            Some(p)  => {\n-                if p.is_empty() { None } else { Path::new_opt(p) }\n-            },\n-            _ => None\n-        }\n-    }\n-    _homedir()\n-}\n-\n-/// Returns the path to a temporary directory.\n-///\n-/// On Unix, returns the value of the 'TMPDIR' environment variable if it is\n-/// set, otherwise for non-Android it returns '/tmp'. If Android, since there\n-/// is no global temporary folder (it is usually allocated per-app), we return\n-/// '/data/local/tmp'.\n-///\n-/// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n-/// 'USERPROFILE' environment variable  if any are set and not the empty\n-/// string. Otherwise, tmpdir returns the path to the Windows directory.\n-#[unstable(feature = \"os\")]\n-#[allow(deprecated)]\n-pub fn tmpdir() -> Path {\n-    return lookup();\n-\n-    fn getenv_nonempty(v: &str) -> Option<Path> {\n-        match getenv(v) {\n-            Some(x) =>\n-                if x.is_empty() {\n-                    None\n-                } else {\n-                    Path::new_opt(x)\n-                },\n-            _ => None\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn lookup() -> Path {\n-        let default = if cfg!(target_os = \"android\") {\n-            Path::new(\"/data/local/tmp\")\n-        } else {\n-            Path::new(\"/tmp\")\n-        };\n-\n-        getenv_nonempty(\"TMPDIR\").unwrap_or(default)\n-    }\n-\n-    #[cfg(windows)]\n-    fn lookup() -> Path {\n-        getenv_nonempty(\"TMP\").or(\n-            getenv_nonempty(\"TEMP\").or(\n-                getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path::new(\"C:\\\\Windows\"))\n-    }\n-}\n-\n-/// Convert a relative path to an absolute path\n-///\n-/// If the given path is relative, return it prepended with the current working\n-/// directory. If the given path is already an absolute path, return it\n-/// as is.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// // Assume we're in a path like /home/someuser\n-/// let rel_path = Path::new(\"..\");\n-/// let abs_path = os::make_absolute(&rel_path).unwrap();\n-/// println!(\"The absolute path is {}\", abs_path.display());\n-/// // Prints \"The absolute path is /home\"\n-/// ```\n-// NB: this is here rather than in path because it is a form of environment\n-// querying; what it does depends on the process working directory, not just\n-// the input paths.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::current_dir + .join directly\")]\n-#[unstable(feature = \"os\")]\n-pub fn make_absolute(p: &Path) -> IoResult<Path> {\n-    if p.is_absolute() {\n-        Ok(p.clone())\n-    } else {\n-        env::current_dir().map_err(err2old).map(|cwd| {\n-            let mut cwd = path2old(&cwd);\n-            cwd.push(p);\n-            cwd\n-        })\n-    }\n-}\n-\n-/// Changes the current working directory to the specified path, returning\n-/// whether the change was completed successfully or not.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// let root = Path::new(\"/\");\n-/// assert!(os::change_dir(&root).is_ok());\n-/// println!(\"Successfully changed working directory to {}!\", root.display());\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn change_dir(p: &Path) -> IoResult<()> {\n-    sys::os::chdir(&path2new(p)).map_err(err2old)\n-}\n-\n-/// Returns the platform-specific value of errno\n-pub fn errno() -> i32 {\n-    sys::os::errno() as i32\n-}\n-\n-/// Return the string corresponding to an `errno()` value of `errnum`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// // Same as println!(\"{}\", last_os_error());\n-/// println!(\"{}\", os::error_string(os::errno() as i32));\n-/// ```\n-pub fn error_string(errnum: i32) -> String {\n-    return sys::os::error_string(errnum);\n-}\n-\n-/// Get a string representing the platform-dependent last error\n-pub fn last_os_error() -> String {\n-    error_string(errno())\n-}\n-\n-/// Sets the process exit code\n-///\n-/// Sets the exit code returned by the process if all supervised tasks\n-/// terminate successfully (without panicking). If the current root task panics\n-/// and is supervised by the scheduler then any user-specified exit status is\n-/// ignored and the process exits with the default panic status.\n-///\n-/// Note that this is not synchronized against modifications of other threads.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_exit_status\")]\n-#[unstable(feature = \"os\")]\n-pub fn set_exit_status(code: isize) {\n-    env::set_exit_status(code as i32)\n-}\n-\n-/// Fetches the process's current exit code. This defaults to 0 and can change\n-/// by calling `set_exit_status`.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::get_exit_status\")]\n-#[unstable(feature = \"os\")]\n-pub fn get_exit_status() -> isize {\n-    env::get_exit_status() as isize\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: isize,\n-                             argv: *const *const c_char) -> Vec<Vec<u8>> {\n-    use ffi::CStr;\n-\n-    (0..argc).map(|i| {\n-        CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec()\n-    }).collect()\n-}\n-\n-/// Returns the command line arguments\n-///\n-/// Returns a list of the command line arguments.\n-#[cfg(target_os = \"macos\")]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    unsafe {\n-        let (argc, argv) = (*_NSGetArgc() as isize,\n-                            *_NSGetArgv() as *const *const c_char);\n-        load_argc_and_argv(argc, argv)\n-    }\n-}\n-\n-// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n-// and use underscores in their names - they're most probably\n-// are considered private and therefore should be avoided\n-// Here is another way to get arguments using Objective C\n-// runtime\n-//\n-// In general it looks like:\n-// res = Vec::new()\n-// let args = [[NSProcessInfo processInfo] arguments]\n-// for i in 0..[args count]\n-//      res.push([args objectAtIndex:i])\n-// res\n-#[cfg(target_os = \"ios\")]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use ffi::CStr;\n-    use iter::range;\n-    use mem;\n-\n-    #[link(name = \"objc\")]\n-    extern {\n-        fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n-        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n-        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n-    }\n-\n-    #[link(name = \"Foundation\", kind = \"framework\")]\n-    extern {}\n-\n-    type Sel = *const libc::c_void;\n-    type NsId = *const libc::c_void;\n-\n-    let mut res = Vec::new();\n-\n-    unsafe {\n-        let processInfoSel = sel_registerName(\"processInfo\\0\".as_ptr());\n-        let argumentsSel = sel_registerName(\"arguments\\0\".as_ptr());\n-        let utf8Sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n-        let countSel = sel_registerName(\"count\\0\".as_ptr());\n-        let objectAtSel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n-\n-        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n-        let info = objc_msgSend(klass, processInfoSel);\n-        let args = objc_msgSend(info, argumentsSel);\n-\n-        let cnt: isize = mem::transmute(objc_msgSend(args, countSel));\n-        for i in 0..cnt {\n-            let tmp = objc_msgSend(args, objectAtSel, i);\n-            let utf_c_str: *const libc::c_char =\n-                mem::transmute(objc_msgSend(tmp, utf8Sel));\n-            res.push(CStr::from_ptr(utf_c_str).to_bytes().to_vec());\n-        }\n-    }\n-\n-    res\n-}\n-\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"openbsd\"))]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use rt;\n-    rt::args::clone().unwrap_or_else(|| vec![])\n-}\n-\n-#[cfg(not(windows))]\n-fn real_args() -> Vec<String> {\n-    real_args_as_bytes().into_iter()\n-                        .map(|v| {\n-                            String::from_utf8_lossy(&v).into_owned()\n-                        }).collect()\n-}\n-\n-#[cfg(windows)]\n-fn real_args() -> Vec<String> {\n-    use slice;\n-    use iter::range;\n-\n-    let mut nArgs: c_int = 0;\n-    let lpArgCount: *mut c_int = &mut nArgs;\n-    let lpCmdLine = unsafe { GetCommandLineW() };\n-    let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n-\n-    let args: Vec<_> = (0..nArgs as usize).map(|i| unsafe {\n-        // Determine the length of this argument.\n-        let ptr = *szArgList.offset(i as isize);\n-        let mut len = 0;\n-        while *ptr.offset(len as isize) != 0 { len += 1; }\n-\n-        // Push it onto the list.\n-        let ptr = ptr as *const u16;\n-        let buf = slice::from_raw_parts(ptr, len);\n-        let opt_s = String::from_utf16(sys::truncate_utf16_at_nul(buf));\n-        opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n-    }).collect();\n-\n-    unsafe {\n-        LocalFree(szArgList as *mut c_void);\n-    }\n-\n-    return args\n-}\n-\n-#[cfg(windows)]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    real_args().into_iter().map(|s| s.into_bytes()).collect()\n-}\n-\n-type LPCWSTR = *const u16;\n-\n-#[cfg(windows)]\n-#[link_name=\"kernel32\"]\n-extern \"system\" {\n-    fn GetCommandLineW() -> LPCWSTR;\n-    fn LocalFree(ptr: *mut c_void);\n-}\n-\n-#[cfg(windows)]\n-#[link_name=\"shell32\"]\n-extern \"system\" {\n-    fn CommandLineToArgvW(lpCmdLine: LPCWSTR,\n-                          pNumArgs: *mut c_int) -> *mut *mut u16;\n-}\n-\n-/// Returns the arguments which this program was started with (normally passed\n-/// via the command line).\n-///\n-/// The first element is traditionally the path to the executable, but it can be\n-/// set to arbitrary text, and it may not even exist, so this property should not\n-/// be relied upon for security purposes.\n-///\n-/// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n-/// See `String::from_utf8_lossy` for details.\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// // Prints each argument on a separate line\n-/// for argument in os::args().iter() {\n-///     println!(\"{}\", argument);\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use std::env::args() instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn args() -> Vec<String> {\n-    real_args()\n-}\n-\n-/// Returns the arguments which this program was started with (normally passed\n-/// via the command line) as byte vectors.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::args_os instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn args_as_bytes() -> Vec<Vec<u8>> {\n-    real_args_as_bytes()\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-extern {\n-    // These functions are in crt_externs.h.\n-    fn _NSGetArgc() -> *mut c_int;\n-    fn _NSGetArgv() -> *mut *mut *mut c_char;\n-}\n-\n-/// Returns the page size of the current architecture in bytes.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::page_size\")]\n-#[unstable(feature = \"os\")]\n-pub fn page_size() -> usize {\n-    sys::os::page_size()\n-}\n-\n-/// A memory mapped file or chunk of memory. This is a very system-specific\n-/// interface to the OS's memory mapping facilities (`mmap` on POSIX,\n-/// `VirtualAlloc`/`CreateFileMapping` on Windows). It makes no attempt at\n-/// abstracting platform differences, besides in error values returned. Consider\n-/// yourself warned.\n-///\n-/// The memory map is released (unmapped) when the destructor is run, so don't\n-/// let it leave scope by accident if you want it to stick around.\n-pub struct MemoryMap {\n-    data: *mut u8,\n-    len: usize,\n-    kind: MemoryMapKind,\n-}\n-\n-/// Type of memory map\n-#[allow(raw_pointer_derive)]\n-#[derive(Copy)]\n-pub enum MemoryMapKind {\n-    /// Virtual memory map. Usually used to change the permissions of a given\n-    /// chunk of memory.  Corresponds to `VirtualAlloc` on Windows.\n-    MapFile(*const u8),\n-    /// Virtual memory map. Usually used to change the permissions of a given\n-    /// chunk of memory, or for allocation. Corresponds to `VirtualAlloc` on\n-    /// Windows.\n-    MapVirtual\n-}\n-\n-/// Options the memory map is created with\n-#[allow(raw_pointer_derive)]\n-#[derive(Copy)]\n-pub enum MapOption {\n-    /// The memory should be readable\n-    MapReadable,\n-    /// The memory should be writable\n-    MapWritable,\n-    /// The memory should be executable\n-    MapExecutable,\n-    /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on\n-    /// POSIX.\n-    MapAddr(*const u8),\n-    /// Create a memory mapping for a file with a given HANDLE.\n-    #[cfg(windows)]\n-    MapFd(libc::HANDLE),\n-    /// Create a memory mapping for a file with a given fd.\n-    #[cfg(not(windows))]\n-    MapFd(c_int),\n-    /// When using `MapFd`, the start of the map is `usize` bytes from the start\n-    /// of the file.\n-    MapOffset(usize),\n-    /// On POSIX, this can be used to specify the default flags passed to\n-    /// `mmap`. By default it uses `MAP_PRIVATE` and, if not using `MapFd`,\n-    /// `MAP_ANON`. This will override both of those. This is platform-specific\n-    /// (the exact values used) and ignored on Windows.\n-    MapNonStandardFlags(c_int),\n-}\n-\n-/// Possible errors when creating a map.\n-#[derive(Copy, Debug)]\n-pub enum MapError {\n-    /// # The following are POSIX-specific\n-    ///\n-    /// fd was not open for reading or, if using `MapWritable`, was not open for\n-    /// writing.\n-    ErrFdNotAvail,\n-    /// fd was not valid\n-    ErrInvalidFd,\n-    /// Either the address given by `MapAddr` or offset given by `MapOffset` was\n-    /// not a multiple of `MemoryMap::granularity` (unaligned to page size).\n-    ErrUnaligned,\n-    /// With `MapFd`, the fd does not support mapping.\n-    ErrNoMapSupport,\n-    /// If using `MapAddr`, the address + `min_len` was outside of the process's\n-    /// address space. If using `MapFd`, the target of the fd didn't have enough\n-    /// resources to fulfill the request.\n-    ErrNoMem,\n-    /// A zero-length map was requested. This is invalid according to\n-    /// [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html).\n-    /// Not all platforms obey this, but this wrapper does.\n-    ErrZeroLength,\n-    /// Unrecognized error. The inner value is the unrecognized errno.\n-    ErrUnknown(isize),\n-    /// # The following are Windows-specific\n-    ///\n-    /// Unsupported combination of protection flags\n-    /// (`MapReadable`/`MapWritable`/`MapExecutable`).\n-    ErrUnsupProt,\n-    /// When using `MapFd`, `MapOffset` was given (Windows does not support this\n-    /// at all)\n-    ErrUnsupOffset,\n-    /// When using `MapFd`, there was already a mapping to the file.\n-    ErrAlreadyExists,\n-    /// Unrecognized error from `VirtualAlloc`. The inner value is the return\n-    /// value of GetLastError.\n-    ErrVirtualAlloc(i32),\n-    /// Unrecognized error from `CreateFileMapping`. The inner value is the\n-    /// return value of `GetLastError`.\n-    ErrCreateFileMappingW(i32),\n-    /// Unrecognized error from `MapViewOfFile`. The inner value is the return\n-    /// value of `GetLastError`.\n-    ErrMapViewOfFile(i32)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for MapError {\n-    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {\n-        let str = match *self {\n-            ErrFdNotAvail => \"fd not available for reading or writing\",\n-            ErrInvalidFd => \"Invalid fd\",\n-            ErrUnaligned => {\n-                \"Unaligned address, invalid flags, negative length or \\\n-                 unaligned offset\"\n-            }\n-            ErrNoMapSupport=> \"File doesn't support mapping\",\n-            ErrNoMem => \"Invalid address, or not enough available memory\",\n-            ErrUnsupProt => \"Protection mode unsupported\",\n-            ErrUnsupOffset => \"Offset in virtual memory mode is unsupported\",\n-            ErrAlreadyExists => \"File mapping for specified file already exists\",\n-            ErrZeroLength => \"Zero-length mapping not allowed\",\n-            ErrUnknown(code) => {\n-                return write!(out, \"Unknown error = {}\", code)\n-            },\n-            ErrVirtualAlloc(code) => {\n-                return write!(out, \"VirtualAlloc failure = {}\", code)\n-            },\n-            ErrCreateFileMappingW(code) => {\n-                return write!(out, \"CreateFileMappingW failure = {}\", code)\n-            },\n-            ErrMapViewOfFile(code) => {\n-                return write!(out, \"MapViewOfFile failure = {}\", code)\n-            }\n-        };\n-        write!(out, \"{}\", str)\n-    }\n-}\n-\n-impl Error for MapError {\n-    fn description(&self) -> &str { \"memory map error\" }\n-}\n-\n-// Round up `from` to be divisible by `to`\n-fn round_up(from: usize, to: usize) -> usize {\n-    let r = if from % to == 0 {\n-        from\n-    } else {\n-        from + to - (from % to)\n-    };\n-    if r == 0 {\n-        to\n-    } else {\n-        r\n-    }\n-}\n-\n-#[cfg(unix)]\n-impl MemoryMap {\n-    /// Create a new mapping with the given `options`, at least `min_len` bytes\n-    /// long. `min_len` must be greater than zero; see the note on\n-    /// `ErrZeroLength`.\n-    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n-        use libc::off_t;\n-\n-        if min_len == 0 {\n-            return Err(ErrZeroLength)\n-        }\n-        let mut addr: *const u8 = ptr::null();\n-        let mut prot = 0;\n-        let mut flags = libc::MAP_PRIVATE;\n-        let mut fd = -1;\n-        let mut offset = 0;\n-        let mut custom_flags = false;\n-        let len = round_up(min_len, env::page_size());\n-\n-        for &o in options {\n-            match o {\n-                MapReadable => { prot |= libc::PROT_READ; },\n-                MapWritable => { prot |= libc::PROT_WRITE; },\n-                MapExecutable => { prot |= libc::PROT_EXEC; },\n-                MapAddr(addr_) => {\n-                    flags |= libc::MAP_FIXED;\n-                    addr = addr_;\n-                },\n-                MapFd(fd_) => {\n-                    flags |= libc::MAP_FILE;\n-                    fd = fd_;\n-                },\n-                MapOffset(offset_) => { offset = offset_ as off_t; },\n-                MapNonStandardFlags(f) => { custom_flags = true; flags = f },\n-            }\n-        }\n-        if fd == -1 && !custom_flags { flags |= libc::MAP_ANON; }\n-\n-        let r = unsafe {\n-            libc::mmap(addr as *mut c_void, len as libc::size_t, prot, flags,\n-                       fd, offset)\n-        };\n-        if r == libc::MAP_FAILED {\n-            Err(match errno() as c_int {\n-                libc::EACCES => ErrFdNotAvail,\n-                libc::EBADF => ErrInvalidFd,\n-                libc::EINVAL => ErrUnaligned,\n-                libc::ENODEV => ErrNoMapSupport,\n-                libc::ENOMEM => ErrNoMem,\n-                code => ErrUnknown(code as isize)\n-            })\n-        } else {\n-            Ok(MemoryMap {\n-               data: r as *mut u8,\n-               len: len,\n-               kind: if fd == -1 {\n-                   MapVirtual\n-               } else {\n-                   MapFile(ptr::null())\n-               }\n-            })\n-        }\n-    }\n-\n-    /// Granularity that the offset or address must be for `MapOffset` and\n-    /// `MapAddr` respectively.\n-    pub fn granularity() -> usize {\n-        env::page_size()\n-    }\n-}\n-\n-#[cfg(unix)]\n-impl Drop for MemoryMap {\n-    /// Unmap the mapping. Panics the task if `munmap` panics.\n-    fn drop(&mut self) {\n-        if self.len == 0 { /* workaround for dummy_stack */ return; }\n-\n-        unsafe {\n-            // `munmap` only panics due to logic errors\n-            libc::munmap(self.data as *mut c_void, self.len as libc::size_t);\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-impl MemoryMap {\n-    /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n-    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n-        use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n-\n-        let mut lpAddress: LPVOID = ptr::null_mut();\n-        let mut readable = false;\n-        let mut writable = false;\n-        let mut executable = false;\n-        let mut handle: HANDLE = libc::INVALID_HANDLE_VALUE;\n-        let mut offset: usize = 0;\n-        let len = round_up(min_len, env::page_size());\n-\n-        for &o in options {\n-            match o {\n-                MapReadable => { readable = true; },\n-                MapWritable => { writable = true; },\n-                MapExecutable => { executable = true; }\n-                MapAddr(addr_) => { lpAddress = addr_ as LPVOID; },\n-                MapFd(handle_) => { handle = handle_; },\n-                MapOffset(offset_) => { offset = offset_; },\n-                MapNonStandardFlags(..) => {}\n-            }\n-        }\n-\n-        let flProtect = match (executable, readable, writable) {\n-            (false, false, false) if handle == libc::INVALID_HANDLE_VALUE => libc::PAGE_NOACCESS,\n-            (false, true, false) => libc::PAGE_READONLY,\n-            (false, true, true) => libc::PAGE_READWRITE,\n-            (true, false, false) if handle == libc::INVALID_HANDLE_VALUE => libc::PAGE_EXECUTE,\n-            (true, true, false) => libc::PAGE_EXECUTE_READ,\n-            (true, true, true) => libc::PAGE_EXECUTE_READWRITE,\n-            _ => return Err(ErrUnsupProt)\n-        };\n-\n-        if handle == libc::INVALID_HANDLE_VALUE {\n-            if offset != 0 {\n-                return Err(ErrUnsupOffset);\n-            }\n-            let r = unsafe {\n-                libc::VirtualAlloc(lpAddress,\n-                                   len as SIZE_T,\n-                                   libc::MEM_COMMIT | libc::MEM_RESERVE,\n-                                   flProtect)\n-            };\n-            match r as usize {\n-                0 => Err(ErrVirtualAlloc(errno())),\n-                _ => Ok(MemoryMap {\n-                   data: r as *mut u8,\n-                   len: len,\n-                   kind: MapVirtual\n-                })\n-            }\n-        } else {\n-            let dwDesiredAccess = match (executable, readable, writable) {\n-                (false, true, false) => libc::FILE_MAP_READ,\n-                (false, true, true) => libc::FILE_MAP_WRITE,\n-                (true, true, false) => libc::FILE_MAP_READ | libc::FILE_MAP_EXECUTE,\n-                (true, true, true) => libc::FILE_MAP_WRITE | libc::FILE_MAP_EXECUTE,\n-                _ => return Err(ErrUnsupProt) // Actually, because of the check above,\n-                                              // we should never get here.\n-            };\n-            unsafe {\n-                let hFile = handle;\n-                let mapping = libc::CreateFileMappingW(hFile,\n-                                                       ptr::null_mut(),\n-                                                       flProtect,\n-                                                       0,\n-                                                       0,\n-                                                       ptr::null());\n-                if mapping == ptr::null_mut() {\n-                    return Err(ErrCreateFileMappingW(errno()));\n-                }\n-                if errno() as c_int == libc::ERROR_ALREADY_EXISTS {\n-                    return Err(ErrAlreadyExists);\n-                }\n-                let r = libc::MapViewOfFile(mapping,\n-                                            dwDesiredAccess,\n-                                            ((len as u64) >> 32) as DWORD,\n-                                            (offset & 0xffff_ffff) as DWORD,\n-                                            0);\n-                match r as usize {\n-                    0 => Err(ErrMapViewOfFile(errno())),\n-                    _ => Ok(MemoryMap {\n-                       data: r as *mut u8,\n-                       len: len,\n-                       kind: MapFile(mapping as *const u8)\n-                    })\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Granularity of MapAddr() and MapOffset() parameter values.\n-    /// This may be greater than the value returned by page_size().\n-    pub fn granularity() -> usize {\n-        use mem;\n-        unsafe {\n-            let mut info = mem::zeroed();\n-            libc::GetSystemInfo(&mut info);\n-\n-            return info.dwAllocationGranularity as usize;\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-impl Drop for MemoryMap {\n-    /// Unmap the mapping. Panics the task if any of `VirtualFree`,\n-    /// `UnmapViewOfFile`, or `CloseHandle` fail.\n-    fn drop(&mut self) {\n-        use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n-        use libc::consts::os::extra::FALSE;\n-        if self.len == 0 { return }\n-\n-        unsafe {\n-            match self.kind {\n-                MapVirtual => {\n-                    if libc::VirtualFree(self.data as *mut c_void, 0,\n-                                         libc::MEM_RELEASE) == 0 {\n-                        println!(\"VirtualFree failed: {}\", errno());\n-                    }\n-                },\n-                MapFile(mapping) => {\n-                    if libc::UnmapViewOfFile(self.data as LPCVOID) == FALSE {\n-                        println!(\"UnmapViewOfFile failed: {}\", errno());\n-                    }\n-                    if libc::CloseHandle(mapping as HANDLE) == FALSE {\n-                        println!(\"CloseHandle failed: {}\", errno());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl MemoryMap {\n-    /// Returns the pointer to the memory created or modified by this map.\n-    pub fn data(&self) -> *mut u8 { self.data }\n-    /// Returns the number of bytes this map applies to.\n-    pub fn len(&self) -> usize { self.len }\n-    /// Returns the type of mapping this represents.\n-    pub fn kind(&self) -> MemoryMapKind { self.kind }\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `linux`.\n-    pub const SYSNAME: &'static str = \"linux\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `macos`.\n-    pub const SYSNAME: &'static str = \"macos\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.dylib`.\n-    pub const DLL_SUFFIX: &'static str = \".dylib\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `dylib`.\n-    pub const DLL_EXTENSION: &'static str = \"dylib\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"ios\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `ios`.\n-    pub const SYSNAME: &'static str = \"ios\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `freebsd`.\n-    pub const SYSNAME: &'static str = \"freebsd\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"dragonfly\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `dragonfly`.\n-    pub const SYSNAME: &'static str = \"dragonfly\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"bitrig\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `bitrig`.\n-    pub const SYSNAME: &'static str = \"bitrig\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"openbsd\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `openbsd`.\n-    pub const SYSNAME: &'static str = \"openbsd\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"android\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `android`.\n-    pub const SYSNAME: &'static str = \"android\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"windows\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"windows\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `windows`.\n-    pub const SYSNAME: &'static str = \"windows\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, the empty string.\n-    pub const DLL_PREFIX: &'static str = \"\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.dll`.\n-    pub const DLL_SUFFIX: &'static str = \".dll\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `dll`.\n-    pub const DLL_EXTENSION: &'static str = \"dll\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, `.exe`.\n-    pub const EXE_SUFFIX: &'static str = \".exe\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, `exe`.\n-    pub const EXE_EXTENSION: &'static str = \"exe\";\n-}\n-\n-#[cfg(target_arch = \"x86\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"x86\";\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"x86_64\";\n-}\n-\n-#[cfg(target_arch = \"arm\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"arm\";\n-}\n-\n-#[cfg(target_arch = \"aarch64\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"aarch64\";\n-}\n-\n-#[cfg(target_arch = \"mips\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"mips\";\n-}\n-\n-#[cfg(target_arch = \"mipsel\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"mipsel\";\n-}\n-\n-#[cfg(target_arch = \"powerpc\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"powerpc\";\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    #![allow(deprecated)] // rand\n-\n-    use prelude::v1::*;\n-\n-    use iter::repeat;\n-    use os::{env, getcwd, getenv, make_absolute};\n-    use os::{split_paths, join_paths, setenv, unsetenv};\n-    use os;\n-    use rand::Rng;\n-    use rand;\n-    use old_path::{Path, GenericPath};\n-    use old_io::{Reader, Writer, Seek};\n-\n-    #[test]\n-    pub fn last_os_error() {\n-        debug!(\"{}\", os::last_os_error());\n-    }\n-\n-    fn make_rand_name() -> String {\n-        let mut rng = rand::thread_rng();\n-        let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n-                                     .collect::<String>());\n-        assert!(getenv(&n).is_none());\n-        n\n-    }\n-\n-    #[test]\n-    fn test_num_cpus() {\n-        assert!(os::num_cpus() > 0);\n-    }\n-\n-    #[test]\n-    fn test_setenv() {\n-        let n = make_rand_name();\n-        setenv(&n, \"VALUE\");\n-        assert_eq!(getenv(&n), Some(\"VALUE\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_unsetenv() {\n-        let n = make_rand_name();\n-        setenv(&n, \"VALUE\");\n-        unsetenv(&n);\n-        assert_eq!(getenv(&n), None);\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn test_setenv_overwrite() {\n-        let n = make_rand_name();\n-        setenv(&n, \"1\");\n-        setenv(&n, \"2\");\n-        assert_eq!(getenv(&n), Some(\"2\".to_string()));\n-        setenv(&n, \"\");\n-        assert_eq!(getenv(&n), Some(\"\".to_string()));\n-    }\n-\n-    // Windows GetEnvironmentVariable requires some extra work to make sure\n-    // the buffer the variable is copied into is the right size\n-    #[test]\n-    #[ignore]\n-    fn test_getenv_big() {\n-        let mut s = \"\".to_string();\n-        let mut i = 0;\n-        while i < 100 {\n-            s.push_str(\"aaaaaaaaaa\");\n-            i += 1;\n-        }\n-        let n = make_rand_name();\n-        setenv(&n, &s);\n-        debug!(\"{}\", s.clone());\n-        assert_eq!(getenv(&n), Some(s));\n-    }\n-\n-    #[test]\n-    fn test_self_exe_name() {\n-        let path = os::self_exe_name();\n-        assert!(path.is_some());\n-        let path = path.unwrap();\n-        debug!(\"{}\", path.display());\n-\n-        // Hard to test this function\n-        assert!(path.is_absolute());\n-    }\n-\n-    #[test]\n-    fn test_self_exe_path() {\n-        let path = os::self_exe_path();\n-        assert!(path.is_some());\n-        let path = path.unwrap();\n-        debug!(\"{}\", path.display());\n-\n-        // Hard to test this function\n-        assert!(path.is_absolute());\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn test_env_getenv() {\n-        let e = env();\n-        assert!(e.len() > 0);\n-        for p in &e {\n-            let (n, v) = (*p).clone();\n-            debug!(\"{}\", n);\n-            let v2 = getenv(&n);\n-            // MingW seems to set some funky environment variables like\n-            // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n-            // from env() but not visible from getenv().\n-            assert!(v2.is_none() || v2 == Some(v));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_env_set_get_huge() {\n-        let n = make_rand_name();\n-        let s = repeat(\"x\").take(10000).collect::<String>();\n-        setenv(&n, &s);\n-        assert_eq!(getenv(&n), Some(s));\n-        unsetenv(&n);\n-        assert_eq!(getenv(&n), None);\n-    }\n-\n-    #[test]\n-    fn test_env_setenv() {\n-        let n = make_rand_name();\n-\n-        let mut e = env();\n-        setenv(&n, \"VALUE\");\n-        assert!(!e.contains(&(n.clone(), \"VALUE\".to_string())));\n-\n-        e = env();\n-        assert!(e.contains(&(n, \"VALUE\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test() {\n-        assert!((!Path::new(\"test-path\").is_absolute()));\n-\n-        let cwd = getcwd().unwrap();\n-        debug!(\"Current working directory: {}\", cwd.display());\n-\n-        debug!(\"{}\", make_absolute(&Path::new(\"test-path\")).unwrap().display());\n-        debug!(\"{}\", make_absolute(&Path::new(\"/usr/bin\")).unwrap().display());\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn homedir() {\n-        let oldhome = getenv(\"HOME\");\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        setenv(\"HOME\", \"\");\n-        assert!(os::homedir().is_none());\n-\n-        if let Some(s) = oldhome {\n-            setenv(\"HOME\", s);\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn homedir() {\n-\n-        let oldhome = getenv(\"HOME\");\n-        let olduserprofile = getenv(\"USERPROFILE\");\n-\n-        setenv(\"HOME\", \"\");\n-        setenv(\"USERPROFILE\", \"\");\n-\n-        assert!(os::homedir().is_none());\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        setenv(\"HOME\", \"\");\n-\n-        setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        if let Some(s) = oldhome {\n-            setenv(\"HOME\", &s);\n-        }\n-        if let Some(s) = olduserprofile {\n-            setenv(\"USERPROFILE\", &s);\n-        }\n-    }\n-\n-    #[test]\n-    fn memory_map_rw() {\n-        use result::Result::{Ok, Err};\n-\n-        let chunk = match os::MemoryMap::new(16, &[\n-            os::MapOption::MapReadable,\n-            os::MapOption::MapWritable\n-        ]) {\n-            Ok(chunk) => chunk,\n-            Err(msg) => panic!(\"{:?}\", msg)\n-        };\n-        assert!(chunk.len >= 16);\n-\n-        unsafe {\n-            *chunk.data = 0xBE;\n-            assert!(*chunk.data == 0xBE);\n-        }\n-    }\n-\n-    #[test]\n-    fn memory_map_file() {\n-        use libc;\n-        use os::*;\n-        use old_io::fs::{File, unlink};\n-        use old_io::SeekStyle::SeekSet;\n-        use old_io::FileMode::Open;\n-        use old_io::FileAccess::ReadWrite;\n-\n-        #[cfg(not(windows))]\n-        fn get_fd(file: &File) -> libc::c_int {\n-            use os::unix::prelude::*;\n-            file.as_raw_fd()\n-        }\n-\n-        #[cfg(windows)]\n-        fn get_fd(file: &File) -> libc::HANDLE {\n-            use os::windows::prelude::*;\n-            file.as_raw_handle()\n-        }\n-\n-        let mut path = tmpdir();\n-        path.push(\"mmap_file.tmp\");\n-        let size = MemoryMap::granularity() * 2;\n-        let mut file = File::open_mode(&path, Open, ReadWrite).unwrap();\n-        file.seek(size as i64, SeekSet).unwrap();\n-        file.write_u8(0).unwrap();\n-\n-        let chunk = MemoryMap::new(size / 2, &[\n-            MapOption::MapReadable,\n-            MapOption::MapWritable,\n-            MapOption::MapFd(get_fd(&file)),\n-            MapOption::MapOffset(size / 2)\n-        ]).unwrap();\n-        assert!(chunk.len > 0);\n-\n-        unsafe {\n-            *chunk.data = 0xbe;\n-            assert!(*chunk.data == 0xbe);\n-        }\n-        drop(chunk);\n-\n-        unlink(&path).unwrap();\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn split_paths_windows() {\n-        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed) ==\n-                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n-        }\n-\n-        assert!(check_parse(\"\", &mut [\"\"]));\n-        assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n-        assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n-        assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n-        assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n-        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n-                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n-                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn split_paths_unix() {\n-        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed) ==\n-                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n-        }\n-\n-        assert!(check_parse(\"\", &mut [\"\"]));\n-        assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n-        assert!(check_parse(\"/\", &mut [\"/\"]));\n-        assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n-        assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn join_paths_unix() {\n-        fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap() == output.as_bytes()\n-        }\n-\n-        assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n-                         \"/bin:/usr/bin:/usr/local/bin\"));\n-        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n-                         \":/bin:::/usr/bin:\"));\n-        assert!(join_paths(&[\"/te:st\"]).is_err());\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn join_paths_windows() {\n-        fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap() == output.as_bytes()\n-        }\n-\n-        assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"],\n-                        r\"c:\\windows;c:\\\"));\n-        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n-                        r\";c:\\windows;;;c:\\;\"));\n-        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"],\n-                        r#\"\"c:\\te;st\";c:\\\"#));\n-        assert!(join_paths(&[r#\"c:\\te\"st\"#]).is_err());\n-    }\n-\n-    // More recursive_mkdir tests are in extra::tempfile\n-}"}, {"sha": "9006ed336542e9198131df7978d0901d8a7503a7", "filename": "src/libstd/path.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -35,7 +35,6 @@\n //! To build or modify paths, use `PathBuf`:\n //!\n //! ```rust\n-//! # #![feature(convert)]\n //! use std::path::PathBuf;\n //!\n //! let mut path = PathBuf::from(\"c:\\\\\");\n@@ -521,9 +520,9 @@ impl<'a> Component<'a> {\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n             Component::Prefix(p) => p.as_os_str(),\n-            Component::RootDir => OsStr::from_str(MAIN_SEP_STR),\n-            Component::CurDir => OsStr::from_str(\".\"),\n-            Component::ParentDir => OsStr::from_str(\"..\"),\n+            Component::RootDir => OsStr::new(MAIN_SEP_STR),\n+            Component::CurDir => OsStr::new(\".\"),\n+            Component::ParentDir => OsStr::new(\"..\"),\n             Component::Normal(path) => path,\n         }\n     }\n@@ -893,7 +892,6 @@ impl<'a> cmp::Ord for Components<'a> {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(convert)]\n /// use std::path::PathBuf;\n ///\n /// let mut path = PathBuf::from(\"c:\\\\\");\n@@ -918,6 +916,12 @@ impl PathBuf {\n         PathBuf { inner: OsString::new() }\n     }\n \n+    /// Coerce to a `Path` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn as_path(&self) -> &Path {\n+        self\n+    }\n+\n     /// Extend `self` with `path`.\n     ///\n     /// If `path` is absolute, it replaces the current path.\n@@ -985,7 +989,6 @@ impl PathBuf {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(convert)]\n     /// use std::path::PathBuf;\n     ///\n     /// let mut buf = PathBuf::from(\"/\");\n@@ -1318,7 +1321,7 @@ impl Path {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n         self.components().next_back().and_then(|p| match p {\n-            Component::Normal(p) => Some(p.as_os_str()),\n+            Component::Normal(p) => Some(p.as_ref()),\n             _ => None\n         })\n     }"}, {"sha": "84a450867675c814c96eff49d0873a0735ffc338", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -42,12 +42,11 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-#[doc(no_inline)] pub use slice::{SliceConcatExt, AsSlice};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-#[doc(no_inline)] pub use str::Str;\n+#[doc(no_inline)] pub use slice::SliceConcatExt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use string::{String, ToString};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use vec::Vec;\n+\n+#[allow(deprecated)] pub use slice::AsSlice;\n+#[allow(deprecated)] pub use str::Str;"}, {"sha": "52f5965db809a76c5168a5d8985d006569e1aaf6", "filename": "src/libstd/process.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,15 +16,15 @@\n use prelude::v1::*;\n use io::prelude::*;\n \n-use ffi::AsOsStr;\n+use ffi::OsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n use libc;\n use path;\n use sync::mpsc::{channel, Receiver};\n use sys::pipe2::{self, AnonPipe};\n-use sys::process2::Process as ProcessImp;\n use sys::process2::Command as CommandImp;\n+use sys::process2::Process as ProcessImp;\n use sys::process2::ExitStatus as ExitStatusImp;\n use sys_common::{AsInner, AsInnerMut};\n use thread;\n@@ -147,9 +147,9 @@ impl Command {\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn new<S: AsOsStr>(program: S) -> Command {\n+    pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n         Command {\n-            inner: CommandImp::new(program.as_os_str()),\n+            inner: CommandImp::new(program.as_ref()),\n             stdin: None,\n             stdout: None,\n             stderr: None,\n@@ -158,15 +158,15 @@ impl Command {\n \n     /// Add an argument to pass to the program.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn arg<S: AsOsStr>(&mut self, arg: S) -> &mut Command {\n-        self.inner.arg(arg.as_os_str());\n+    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {\n+        self.inner.arg(arg.as_ref());\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn args<S: AsOsStr>(&mut self, args: &[S]) -> &mut Command {\n-        self.inner.args(args.iter().map(AsOsStr::as_os_str));\n+    pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {\n+        self.inner.args(args.iter().map(AsRef::as_ref));\n         self\n     }\n \n@@ -176,16 +176,16 @@ impl Command {\n     /// and case-sensitive on all other platforms.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n-        where K: AsOsStr, V: AsOsStr\n+        where K: AsRef<OsStr>, V: AsRef<OsStr>\n     {\n-        self.inner.env(key.as_os_str(), val.as_os_str());\n+        self.inner.env(key.as_ref(), val.as_ref());\n         self\n     }\n \n     /// Removes an environment variable mapping.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn env_remove<K: AsOsStr>(&mut self, key: K) -> &mut Command {\n-        self.inner.env_remove(key.as_os_str());\n+    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {\n+        self.inner.env_remove(key.as_ref());\n         self\n     }\n \n@@ -199,7 +199,7 @@ impl Command {\n     /// Set the working directory for the child process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn current_dir<P: AsRef<path::Path>>(&mut self, dir: P) -> &mut Command {\n-        self.inner.cwd(dir.as_ref().as_os_str());\n+        self.inner.cwd(dir.as_ref().as_ref());\n         self\n     }\n \n@@ -378,11 +378,6 @@ enum StdioImp {\n }\n \n impl Stdio {\n-    /// A new pipe should be arranged to connect the parent and child processes.\n-    #[unstable(feature = \"process_capture\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `Stdio::piped`\")]\n-    pub fn capture() -> Stdio { Stdio::piped() }\n-\n     /// A new pipe should be arranged to connect the parent and child processes.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn piped() -> Stdio { Stdio(StdioImp::Piped) }\n@@ -461,7 +456,6 @@ impl Child {\n             return Err(Error::new(\n                 ErrorKind::InvalidInput,\n                 \"invalid argument: can't kill an exited process\",\n-                None\n             ))\n         }\n \n@@ -527,13 +521,28 @@ impl Child {\n     }\n }\n \n+/// Terminates the current process with the specified exit code.\n+///\n+/// This function will never return and will immediately terminate the current\n+/// process. The exit code is passed through to the underlying OS and will be\n+/// available for consumption by another process.\n+///\n+/// Note that because this function never returns, and that it terminates the\n+/// process, no destructors on the current stack or any other thread's stack\n+/// will be run. If a clean shutdown is needed it is recommended to only call\n+/// this function at a known point where there are no more destructors left\n+/// to run.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn exit(code: i32) -> ! {\n+    ::sys::os::exit(code)\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use io::ErrorKind;\n+    use prelude::v1::*;\n     use io::prelude::*;\n-    use prelude::v1::{Ok, Err, drop, Some, Vec};\n-    use prelude::v1::{String, Clone};\n-    use prelude::v1::{Str, AsSlice, ToString};\n+\n+    use io::ErrorKind;\n     use old_path::{self, GenericPath};\n     use old_io::fs::PathExtensions;\n     use rt::running_on_valgrind;\n@@ -567,7 +576,7 @@ mod tests {\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().unwrap().code() == Some(1));\n-        drop(p.wait().clone());\n+        drop(p.wait());\n     }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n@@ -678,7 +687,7 @@ mod tests {\n     fn test_process_output_output() {\n         let Output {status, stdout, stderr}\n              = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n-        let output_str = str::from_utf8(stdout.as_slice()).unwrap();\n+        let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n@@ -720,7 +729,7 @@ mod tests {\n         let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped())\n             .spawn().unwrap();\n         let Output {status, stdout, stderr} = prog.wait_with_output().unwrap();\n-        let output_str = str::from_utf8(stdout.as_slice()).unwrap();\n+        let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n@@ -755,7 +764,8 @@ mod tests {\n         let prog = pwd_cmd().spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().stdout).unwrap();\n-        let parent_dir = os::getcwd().unwrap();\n+        let parent_dir = ::env::current_dir().unwrap().to_str().unwrap().to_string();\n+        let parent_dir = old_path::Path::new(parent_dir);\n         let child_dir = old_path::Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -770,7 +780,8 @@ mod tests {\n         use os;\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = os::getcwd().unwrap().dir_path();\n+        let parent_dir = ::env::current_dir().unwrap().to_str().unwrap().to_string();\n+        let parent_dir = old_path::Path::new(parent_dir).dir_path();\n         let result = pwd_cmd().current_dir(parent_dir.as_str().unwrap()).output().unwrap();\n \n         let output = String::from_utf8(result.stdout).unwrap();\n@@ -821,14 +832,13 @@ mod tests {\n     #[cfg(target_os=\"android\")]\n     #[test]\n     fn test_inherit_env() {\n-        use os;\n+        use std::env;\n         if running_on_valgrind() { return; }\n \n         let mut result = env_cmd().output().unwrap();\n         let output = String::from_utf8(result.stdout).unwrap();\n \n-        let r = os::env();\n-        for &(ref k, ref v) in &r {\n+        for (ref k, ref v) in env::vars() {\n             // don't check android RANDOM variables\n             if *k != \"RANDOM\".to_string() {\n                 assert!(output.contains(&format!(\"{}={}\",\n@@ -855,7 +865,7 @@ mod tests {\n             cmd.env(\"PATH\", &p);\n         }\n         let result = cmd.output().unwrap();\n-        let output = String::from_utf8_lossy(result.stdout.as_slice()).to_string();\n+        let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n@@ -864,7 +874,7 @@ mod tests {\n     #[test]\n     fn test_add_to_env() {\n         let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n-        let output = String::from_utf8_lossy(result.stdout.as_slice()).to_string();\n+        let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "7aba40dc6be89908d07accb551d74aa20469cd0e", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -15,17 +15,16 @@ pub use self::imp::OsRng;\n \n #[cfg(all(unix, not(target_os = \"ios\")))]\n mod imp {\n-    extern crate libc;\n-\n+    use prelude::v1::*;\n     use self::OsRngInner::*;\n \n+    use libc;\n+    use mem;\n     use old_io::{IoResult, File};\n     use old_path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n-    use result::Result::Ok;\n-    use mem;\n-    use os::errno;\n+    use sys::os::errno;\n \n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\",\n@@ -184,14 +183,13 @@ mod imp {\n \n #[cfg(target_os = \"ios\")]\n mod imp {\n-    extern crate libc;\n+    use prelude::v1::*;\n \n-    use old_io::{IoResult};\n+    use old_io::IoResult;\n     use mem;\n     use os;\n     use rand::Rng;\n-    use result::Result::{Ok};\n-    use self::libc::{c_int, size_t};\n+    use libc::{c_int, size_t};\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -251,16 +249,14 @@ mod imp {\n \n #[cfg(windows)]\n mod imp {\n-    extern crate libc;\n+    use prelude::v1::*;\n \n-    use old_io::{IoResult, IoError};\n+    use io;\n     use mem;\n-    use ops::Drop;\n-    use os;\n+    use old_io::{IoResult, IoError};\n     use rand::Rng;\n-    use result::Result::{Ok, Err};\n-    use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n-    use self::libc::types::os::arch::extra::{LONG_PTR};\n+    use libc::types::os::arch::extra::{LONG_PTR};\n+    use libc::{DWORD, BYTE, LPCSTR, BOOL};\n \n     type HCRYPTPROV = LONG_PTR;\n \n@@ -330,7 +326,8 @@ mod imp {\n                                v.as_mut_ptr())\n             };\n             if ret == 0 {\n-                panic!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+                panic!(\"couldn't generate random bytes: {}\",\n+                       io::Error::last_os_error());\n             }\n         }\n     }\n@@ -341,7 +338,8 @@ mod imp {\n                 CryptReleaseContext(self.hcryptprov, 0)\n             };\n             if ret == 0 {\n-                panic!(\"couldn't release context: {}\", os::last_os_error());\n+                panic!(\"couldn't release context: {}\",\n+                       io::Error::last_os_error());\n             }\n         }\n     }"}, {"sha": "2329861f29bc06dc6b7428d8ecb9fc560720a573", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -108,7 +108,6 @@ mod imp {\n     #[cfg(test)]\n     mod tests {\n         use prelude::v1::*;\n-        use finally::Finally;\n \n         use super::*;\n \n@@ -127,14 +126,11 @@ mod imp {\n             assert!(take() == Some(expected.clone()));\n             assert!(take() == None);\n \n-            (|| {\n-            }).finally(|| {\n-                // Restore the actual global state.\n-                match saved_value {\n-                    Some(ref args) => put(args.clone()),\n-                    None => ()\n-                }\n-            })\n+            // Restore the actual global state.\n+            match saved_value {\n+                Some(ref args) => put(args.clone()),\n+                None => ()\n+            }\n         }\n     }\n }"}, {"sha": "a5259a00390f55369a7e737781fe0f6c00f52e34", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -31,8 +31,6 @@ pub use self::barrier::{Barrier, BarrierWaitResult};\n pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;\n-#[allow(deprecated)]\n-pub use self::task_pool::TaskPool;\n \n pub mod mpsc;\n \n@@ -44,4 +42,3 @@ mod once;\n mod poison;\n mod rwlock;\n mod semaphore;\n-mod task_pool;"}, {"sha": "e14f32865fa10fe8dc6453503aadb50d3c563415", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -114,7 +114,7 @@\n //! ```\n //!\n //! Reading from a channel with a timeout requires to use a Timer together\n-//! with the channel. You can use the select! macro to select either and\n+//! with the channel. You can use the `select!` macro to select either and\n //! handle the timeout case. This first example will break out of the loop\n //! after 10 seconds no matter what:\n //!"}, {"sha": "347cd0b464ed95892e74b13adafdb30a3013e532", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,7 +11,7 @@\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n-use error::{Error, FromError};\n+use error::{Error};\n use fmt;\n use thread;\n \n@@ -122,12 +122,6 @@ impl<T> PoisonError<T> {\n         PoisonError { guard: guard }\n     }\n \n-    /// Consumes this error indicating that a lock is poisoned, returning the\n-    /// underlying guard to allow access regardless.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to into_inner\")]\n-    pub fn into_guard(self) -> T { self.guard }\n-\n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n     #[unstable(feature = \"std_misc\")]\n@@ -144,8 +138,8 @@ impl<T> PoisonError<T> {\n     pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n }\n \n-impl<T> FromError<PoisonError<T>> for TryLockError<T> {\n-    fn from_error(err: PoisonError<T>) -> TryLockError<T> {\n+impl<T> From<PoisonError<T>> for TryLockError<T> {\n+    fn from(err: PoisonError<T>) -> TryLockError<T> {\n         TryLockError::Poisoned(err)\n     }\n }"}, {"sha": "51cf70e615bcc17eb1619a794b61c64ea595e37f", "filename": "src/libstd/sync/task_pool.rs", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,217 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Abstraction of a thread pool for basic parallelism.\n-\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"This kind of API needs some time to bake in \\\n-                        crates.io. This functionality is available through \\\n-                        https://crates.io/crates/threadpool\")]\n-#![unstable(feature = \"std_misc\")]\n-\n-#![allow(deprecated)]\n-\n-use core::prelude::*;\n-\n-use sync::{Arc, Mutex};\n-use sync::mpsc::{channel, Sender, Receiver};\n-use thread;\n-use thunk::Thunk;\n-\n-struct Sentinel<'a> {\n-    jobs: &'a Arc<Mutex<Receiver<Thunk<'static>>>>,\n-    active: bool\n-}\n-\n-impl<'a> Sentinel<'a> {\n-    fn new(jobs: &'a Arc<Mutex<Receiver<Thunk<'static>>>>) -> Sentinel<'a> {\n-        Sentinel {\n-            jobs: jobs,\n-            active: true\n-        }\n-    }\n-\n-    // Cancel and destroy this sentinel.\n-    fn cancel(mut self) {\n-        self.active = false;\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for Sentinel<'a> {\n-    fn drop(&mut self) {\n-        if self.active {\n-            spawn_in_pool(self.jobs.clone())\n-        }\n-    }\n-}\n-\n-/// A thread pool used to execute functions in parallel.\n-///\n-/// Spawns `n` worker threads and replenishes the pool if any worker threads\n-/// panic.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(std_misc, core)]\n-/// use std::sync::TaskPool;\n-/// use std::iter::AdditiveIterator;\n-/// use std::sync::mpsc::channel;\n-///\n-/// let pool = TaskPool::new(4);\n-///\n-/// let (tx, rx) = channel();\n-/// for _ in 0..8 {\n-///     let tx = tx.clone();\n-///     pool.execute(move|| {\n-///         tx.send(1_u32).unwrap();\n-///     });\n-/// }\n-///\n-/// assert_eq!(rx.iter().take(8).sum(), 8);\n-/// ```\n-pub struct TaskPool {\n-    // How the threadpool communicates with subthreads.\n-    //\n-    // This is the only such Sender, so when it is dropped all subthreads will\n-    // quit.\n-    jobs: Sender<Thunk<'static>>\n-}\n-\n-impl TaskPool {\n-    /// Spawns a new thread pool with `threads` threads.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `threads` is 0.\n-    pub fn new(threads: usize) -> TaskPool {\n-        assert!(threads >= 1);\n-\n-        let (tx, rx) = channel::<Thunk>();\n-        let rx = Arc::new(Mutex::new(rx));\n-\n-        // Threadpool threads\n-        for _ in 0..threads {\n-            spawn_in_pool(rx.clone());\n-        }\n-\n-        TaskPool { jobs: tx }\n-    }\n-\n-    /// Executes the function `job` on a thread in the pool.\n-    pub fn execute<F>(&self, job: F)\n-        where F : FnOnce(), F : Send + 'static\n-    {\n-        self.jobs.send(Thunk::new(job)).unwrap();\n-    }\n-}\n-\n-fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk<'static>>>>) {\n-    thread::spawn(move || {\n-        // Will spawn a new thread on panic unless it is cancelled.\n-        let sentinel = Sentinel::new(&jobs);\n-\n-        loop {\n-            let message = {\n-                // Only lock jobs for the time it takes\n-                // to get a job, not run it.\n-                let lock = jobs.lock().unwrap();\n-                lock.recv()\n-            };\n-\n-            match message {\n-                Ok(job) => job.invoke(()),\n-\n-                // The Taskpool was dropped.\n-                Err(..) => break\n-            }\n-        }\n-\n-        sentinel.cancel();\n-    });\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::*;\n-    use sync::mpsc::channel;\n-\n-    const TEST_TASKS: usize = 4;\n-\n-    #[test]\n-    fn test_works() {\n-        use iter::AdditiveIterator;\n-\n-        let pool = TaskPool::new(TEST_TASKS);\n-\n-        let (tx, rx) = channel();\n-        for _ in 0..TEST_TASKS {\n-            let tx = tx.clone();\n-            pool.execute(move|| {\n-                tx.send(1).unwrap();\n-            });\n-        }\n-\n-        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_zero_tasks_panic() {\n-        TaskPool::new(0);\n-    }\n-\n-    #[test]\n-    fn test_recovery_from_subtask_panic() {\n-        use iter::AdditiveIterator;\n-\n-        let pool = TaskPool::new(TEST_TASKS);\n-\n-        // Panic all the existing threads.\n-        for _ in 0..TEST_TASKS {\n-            pool.execute(move|| -> () { panic!() });\n-        }\n-\n-        // Ensure new threads were spawned to compensate.\n-        let (tx, rx) = channel();\n-        for _ in 0..TEST_TASKS {\n-            let tx = tx.clone();\n-            pool.execute(move|| {\n-                tx.send(1).unwrap();\n-            });\n-        }\n-\n-        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n-    }\n-\n-    #[test]\n-    fn test_should_not_panic_on_drop_if_subtasks_panic_after_drop() {\n-        use sync::{Arc, Barrier};\n-\n-        let pool = TaskPool::new(TEST_TASKS);\n-        let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n-\n-        // Panic all the existing threads in a bit.\n-        for _ in 0..TEST_TASKS {\n-            let waiter = waiter.clone();\n-            pool.execute(move|| {\n-                waiter.wait();\n-                panic!();\n-            });\n-        }\n-\n-        drop(pool);\n-\n-        // Kick off the failure.\n-        waiter.wait();\n-    }\n-}"}, {"sha": "7d42d65d360f548db50943439b54c8908ffd6854", "filename": "src/libstd/sys/common/net2.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -75,7 +75,7 @@ fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             })))\n         }\n         _ => {\n-            Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\", None))\n+            Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\"))\n         }\n     }\n }\n@@ -158,8 +158,7 @@ pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> {\n     match from_utf8(data.to_bytes()) {\n         Ok(name) => Ok(name.to_string()),\n         Err(_) => Err(io::Error::new(io::ErrorKind::Other,\n-                                     \"failed to lookup address information\",\n-                                     Some(\"invalid host name\".to_string())))\n+                                     \"failed to lookup address information\"))\n     }\n }\n \n@@ -259,6 +258,12 @@ impl TcpStream {\n     }\n }\n \n+impl FromInner<Socket> for TcpStream {\n+    fn from_inner(socket: Socket) -> TcpStream {\n+        TcpStream { inner: socket }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // TCP listeners\n ////////////////////////////////////////////////////////////////////////////////\n@@ -312,6 +317,12 @@ impl TcpListener {\n     }\n }\n \n+impl FromInner<Socket> for TcpListener {\n+    fn from_inner(socket: Socket) -> TcpListener {\n+        TcpListener { inner: socket }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // UDP\n ////////////////////////////////////////////////////////////////////////////////\n@@ -424,3 +435,9 @@ impl UdpSocket {\n         self.inner.duplicate().map(|s| UdpSocket { inner: s })\n     }\n }\n+\n+impl FromInner<Socket> for UdpSocket {\n+    fn from_inner(socket: Socket) -> UdpSocket {\n+        UdpSocket { inner: socket }\n+    }\n+}"}, {"sha": "ca805ad02422ad6cda891f3a561bda0301dfebbf", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -251,7 +251,6 @@ fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n          symaddr: *mut libc::c_void) -> io::Result<()> {\n     use env;\n-    use ffi::AsOsStr;\n     use os::unix::prelude::*;\n     use ptr;\n "}, {"sha": "fbfbb40701fd9f5887a841ba7e50dde90ed36479", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 93, "deletions": 31, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -32,102 +32,171 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n /// Unix-specific extensions to general I/O primitives\n-#[unstable(feature = \"io_ext\",\n-           reason = \"may want a slightly different organization or a more \\\n-                     general file descriptor primitive\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod io {\n     #[allow(deprecated)] use old_io;\n     use fs;\n     use libc;\n     use net;\n-    use sys_common::AsInner;\n+    use sys_common::{net2, AsInner, FromInner};\n+    use sys;\n \n     /// Raw file descriptors.\n-    pub type Fd = libc::c_int;\n-\n-    /// Extract raw file descriptor\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub type RawFd = libc::c_int;\n+\n+    /// A trait to extract the raw unix file descriptor from an underlying\n+    /// object.\n+    ///\n+    /// This is only available on unix platforms and must be imported in order\n+    /// to call the method. Windows platforms have a corresponding `AsRawHandle`\n+    /// and `AsRawSocket` set of traits.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub trait AsRawFd {\n-        /// Extract the raw file descriptor, without taking any ownership.\n-        fn as_raw_fd(&self) -> Fd;\n+        /// Extract the raw file descriptor.\n+        ///\n+        /// This method does **not** pass ownership of the raw file descriptor\n+        /// to the caller. The descriptor is only guarantee to be valid while\n+        /// the original object has not yet been destroyed.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        fn as_raw_fd(&self) -> RawFd;\n+    }\n+\n+    /// A trait to express the ability to construct an object from a raw file\n+    /// descriptor.\n+    #[unstable(feature = \"from_raw_os\",\n+               reason = \"recent addition to std::os::unix::io\")]\n+    pub trait FromRawFd {\n+        /// Constructs a new instances of `Self` from the given raw file\n+        /// descriptor.\n+        ///\n+        /// This function **consumes ownership** of the specified file\n+        /// descriptor. The returned object will take responsibility for closing\n+        /// it when the object goes out of scope.\n+        ///\n+        /// Callers should normally only pass in a valid file descriptor to this\n+        /// method or otherwise methods will return errors.\n+        fn from_raw_fd(fd: RawFd) -> Self;\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for old_io::fs::File {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for fs::File {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd().raw()\n         }\n     }\n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawFd for fs::File {\n+        fn from_raw_fd(fd: RawFd) -> fs::File {\n+            fs::File::from_inner(sys::fs2::File::from_inner(fd))\n+        }\n+    }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for old_io::pipe::PipeStream {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for old_io::net::pipe::UnixStream {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for old_io::net::pipe::UnixListener {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for old_io::net::pipe::UnixAcceptor {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     impl AsRawFd for old_io::net::tcp::TcpStream {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     impl AsRawFd for old_io::net::tcp::TcpListener {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     impl AsRawFd for old_io::net::tcp::TcpAcceptor {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for old_io::net::udp::UdpSocket {\n-        fn as_raw_fd(&self) -> Fd {\n+        fn as_raw_fd(&self) -> RawFd {\n             self.as_inner().fd()\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for net::TcpStream {\n-        fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n     }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for net::TcpListener {\n-        fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n     }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for net::UdpSocket {\n-        fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    }\n+\n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawFd for net::TcpStream {\n+        fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+            let socket = sys::net::Socket::from_inner(fd);\n+            net::TcpStream::from_inner(net2::TcpStream::from_inner(socket))\n+        }\n+    }\n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawFd for net::TcpListener {\n+        fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+            let socket = sys::net::Socket::from_inner(fd);\n+            net::TcpListener::from_inner(net2::TcpListener::from_inner(socket))\n+        }\n+    }\n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawFd for net::UdpSocket {\n+        fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+            let socket = sys::net::Socket::from_inner(fd);\n+            net::UdpSocket::from_inner(net2::UdpSocket::from_inner(socket))\n+        }\n     }\n }\n \n@@ -138,7 +207,7 @@ pub mod io {\n /// Unix-specific extension to the primitives in the `std::ffi` module\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod ffi {\n-    use ffi::{CString, NulError, OsStr, OsString};\n+    use ffi::{OsStr, OsString};\n     use mem;\n     use prelude::v1::*;\n     use sys::os_str::Buf;\n@@ -175,10 +244,6 @@ pub mod ffi {\n         /// Get the underlying byte view of the `OsStr` slice.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         fn as_bytes(&self) -> &[u8];\n-\n-        /// Convert the `OsStr` slice into a `CString`.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn to_cstring(&self) -> Result<CString, NulError>;\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -189,9 +254,6 @@ pub mod ffi {\n         fn as_bytes(&self) -> &[u8] {\n             &self.as_inner().inner\n         }\n-        fn to_cstring(&self) -> Result<CString, NulError> {\n-            CString::new(self.as_bytes())\n-        }\n     }\n }\n \n@@ -302,7 +364,7 @@ pub mod process {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n     #[doc(no_inline)]\n-    pub use super::io::{Fd, AsRawFd};\n+    pub use super::io::{RawFd, AsRawFd};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::ffi::{OsStrExt, OsStringExt};\n     #[doc(no_inline)]"}, {"sha": "6b085c8eb7a85fc90b41b2239c4410e29118c5f4", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -388,9 +388,7 @@ mod tests {\n     fn test_file_desc() {\n         // Run this test with some pipes so we don't have to mess around with\n         // opening or closing files.\n-        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-        let mut reader = FileDesc::new(reader, true);\n-        let mut writer = FileDesc::new(writer, true);\n+        let (mut reader, mut writer) = unsafe { ::sys::os::pipe().unwrap() };\n \n         writer.write(b\"test\").unwrap();\n         let mut buf = [0; 4];"}, {"sha": "c0426af051be372061b45cae94f907247ae57298", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n use io::prelude::*;\n use os::unix::prelude::*;\n \n-use ffi::{CString, CStr, OsString, AsOsStr, OsStr};\n+use ffi::{CString, CStr, OsString, OsStr};\n use io::{self, Error, SeekFrom};\n use libc::{self, c_int, size_t, off_t, c_char, mode_t};\n use mem;\n@@ -276,8 +276,14 @@ impl File {\n }\n \n fn cstr(path: &Path) -> io::Result<CString> {\n-    let cstring = try!(path.as_os_str().to_cstring());\n-    Ok(cstring)\n+    path.as_os_str().to_cstring().ok_or(\n+        io::Error::new(io::ErrorKind::InvalidInput, \"path contained a null\"))\n+}\n+\n+impl FromInner<c_int> for File {\n+    fn from_inner(fd: c_int) -> File {\n+        File(FileDesc::new(fd))\n+    }\n }\n \n pub fn mkdir(p: &Path) -> io::Result<()> {"}, {"sha": "fe0ede80fc663cbda1451a8cfffecb65aaecb178", "filename": "src/libstd/sys/unix/helper_signal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,15 +11,15 @@\n #![allow(deprecated)]\n \n use libc;\n-use os;\n+use sys::os;\n \n use sys::fs::FileDesc;\n \n pub type signal = libc::c_int;\n \n pub fn new() -> (signal, signal) {\n-    let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-    (reader, writer)\n+    let (a, b) = unsafe { os::pipe().unwrap() };\n+    (a.unwrap(), b.unwrap())\n }\n \n pub fn signal(fd: libc::c_int) {"}, {"sha": "908136a42ab00a96723bc902d863def68d5f26ef", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -17,7 +17,7 @@ use str;\n use sys::c;\n use net::SocketAddr;\n use sys::fd::FileDesc;\n-use sys_common::AsInner;\n+use sys_common::{AsInner, FromInner};\n \n pub use sys::{cvt, cvt_r};\n \n@@ -35,7 +35,8 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n             .to_string()\n     };\n     Err(io::Error::new(io::ErrorKind::Other,\n-                       \"failed to lookup address information\", Some(detail)))\n+                       &format!(\"failed to lookup address information: {}\",\n+                                detail)[..]))\n }\n \n impl Socket {\n@@ -72,3 +73,7 @@ impl Socket {\n impl AsInner<c_int> for Socket {\n     fn as_inner(&self) -> &c_int { self.0.as_inner() }\n }\n+\n+impl FromInner<c_int> for Socket {\n+    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+}"}, {"sha": "7b13e951b9b3315203bdf294a51bb1172828d084", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,7 +16,7 @@ use prelude::v1::*;\n use os::unix::prelude::*;\n \n use error::Error as StdError;\n-use ffi::{CString, CStr, OsString, OsStr, AsOsStr};\n+use ffi::{CString, CStr, OsString, OsStr};\n use fmt;\n use io;\n use iter;\n@@ -125,7 +125,8 @@ pub fn getcwd() -> io::Result<PathBuf> {\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let p = try!(CString::new(p.as_os_str().as_bytes()));\n+    let p: &OsStr = p.as_ref();\n+    let p = try!(CString::new(p.as_bytes()));\n     unsafe {\n         match libc::chdir(p.as_ptr()) == (0 as c_int) {\n             true => Ok(()),\n@@ -158,13 +159,13 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsOsStr\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n {\n     let mut joined = Vec::new();\n     let sep = b':';\n \n     for (i, path) in paths.enumerate() {\n-        let path = path.as_os_str().as_bytes();\n+        let path = path.as_ref().as_bytes();\n         if i > 0 { joined.push(sep) }\n         if path.contains(&sep) {\n             return Err(JoinPathsError)\n@@ -464,7 +465,7 @@ pub fn page_size() -> usize {\n }\n \n pub fn temp_dir() -> PathBuf {\n-    getenv(\"TMPDIR\".as_os_str()).map(os2path).unwrap_or_else(|| {\n+    getenv(\"TMPDIR\".as_ref()).map(os2path).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n             PathBuf::from(\"/data/local/tmp\")\n         } else {\n@@ -474,7 +475,7 @@ pub fn temp_dir() -> PathBuf {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    return getenv(\"HOME\".as_os_str()).or_else(|| unsafe {\n+    return getenv(\"HOME\".as_ref()).or_else(|| unsafe {\n         fallback()\n     }).map(os2path);\n \n@@ -505,3 +506,7 @@ pub fn home_dir() -> Option<PathBuf> {\n         }\n     }\n }\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe { libc::exit(code as c_int) }\n+}"}, {"sha": "8095325f83d1faf553220784814a6e2f84b102a7", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -19,8 +19,9 @@ use hash::Hash;\n use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n use old_io::{IoResult, EndOfFile};\n use libc::{self, pid_t, c_void, c_int};\n+use io;\n use mem;\n-use os;\n+use sys::os;\n use old_path::BytesContainer;\n use ptr;\n use sync::mpsc::{channel, Sender, Receiver};\n@@ -496,7 +497,8 @@ impl Process {\n                     n if n > 0 => { ret = true; }\n                     0 => return true,\n                     -1 if wouldblock() => return ret,\n-                    n => panic!(\"bad read {:?} ({:?})\", os::last_os_error(), n),\n+                    n => panic!(\"bad read {} ({})\",\n+                                io::Error::last_os_error(), n),\n                 }\n             }\n         }"}, {"sha": "c2a8b26aef4ebb63306fa9f6b947f9c3df15e99e", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -54,7 +54,7 @@ impl Command {\n         self.args.push(arg.to_cstring().unwrap())\n     }\n     pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n-        self.args.extend(args.map(|s| OsStrExt::to_cstring(s).unwrap()))\n+        self.args.extend(args.map(|s| s.to_cstring().unwrap()))\n     }\n     fn init_env_map(&mut self) {\n         if self.env.is_none() {"}, {"sha": "9309147b15c44f6bd14ae38417bf04ef010fcda2", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -54,7 +54,8 @@ use self::Req::*;\n use old_io::IoResult;\n use libc;\n use mem;\n-use os;\n+use sys::os;\n+use io;\n use ptr;\n use sync::atomic::{self, Ordering};\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n@@ -209,7 +210,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n             -1 if os::errno() == libc::EINTR as i32 => {}\n             n => panic!(\"helper thread failed in select() with error: {} ({})\",\n-                       n, os::last_os_error())\n+                       n, io::Error::last_os_error())\n         }\n     }\n }"}, {"sha": "e74de595f9750db33072c5396a74e3f7c3ab1119", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -433,6 +433,7 @@ extern \"system\" {\n                             TokenHandle: *mut libc::HANDLE) -> libc::BOOL;\n     pub fn GetCurrentProcess() -> libc::HANDLE;\n     pub fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n+    pub fn ExitProcess(uExitCode: libc::c_uint) -> !;\n }\n \n #[link(name = \"userenv\")]"}, {"sha": "2dd61861bd6dc8c78299ffb2b7c9065f3aef29c9", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 98, "deletions": 22, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,112 +16,188 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[unstable(feature = \"io_ext\",\n-           reason = \"organization may change slightly and the primitives \\\n-                     provided may be tweaked\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod io {\n     use fs;\n     use libc;\n     use net;\n-    use sys_common::AsInner;\n+    use sys_common::{net2, AsInner, FromInner};\n+    use sys;\n \n     #[allow(deprecated)]\n     use old_io;\n \n     /// Raw HANDLEs.\n-    pub type Handle = libc::HANDLE;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub type RawHandle = libc::HANDLE;\n \n     /// Raw SOCKETs.\n-    pub type Socket = libc::SOCKET;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub type RawSocket = libc::SOCKET;\n \n     /// Extract raw handles.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub trait AsRawHandle {\n         /// Extract the raw handle, without taking any ownership.\n-        fn as_raw_handle(&self) -> Handle;\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        fn as_raw_handle(&self) -> RawHandle;\n+    }\n+\n+    /// Construct I/O objects from raw handles.\n+    #[unstable(feature = \"from_raw_os\",\n+               reason = \"recent addition to the std::os::windows::io module\")]\n+    pub trait FromRawHandle {\n+        /// Construct a new I/O object from the specified raw handle.\n+        ///\n+        /// This function will **consume ownership** of the handle given,\n+        /// passing responsibility for closing the handle to the returned\n+        /// object.\n+        fn from_raw_handle(handle: RawHandle) -> Self;\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawHandle for old_io::fs::File {\n-        fn as_raw_handle(&self) -> Handle {\n+        fn as_raw_handle(&self) -> RawHandle {\n             self.as_inner().handle()\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawHandle for fs::File {\n-        fn as_raw_handle(&self) -> Handle {\n+        fn as_raw_handle(&self) -> RawHandle {\n             self.as_inner().handle().raw()\n         }\n     }\n \n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawHandle for fs::File {\n+        fn from_raw_handle(handle: RawHandle) -> fs::File {\n+            fs::File::from_inner(sys::fs2::File::from_inner(handle))\n+        }\n+    }\n+\n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawHandle for old_io::pipe::PipeStream {\n-        fn as_raw_handle(&self) -> Handle {\n+        fn as_raw_handle(&self) -> RawHandle {\n             self.as_inner().handle()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawHandle for old_io::net::pipe::UnixStream {\n-        fn as_raw_handle(&self) -> Handle {\n+        fn as_raw_handle(&self) -> RawHandle {\n             self.as_inner().handle()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawHandle for old_io::net::pipe::UnixListener {\n-        fn as_raw_handle(&self) -> Handle {\n+        fn as_raw_handle(&self) -> RawHandle {\n             self.as_inner().handle()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawHandle for old_io::net::pipe::UnixAcceptor {\n-        fn as_raw_handle(&self) -> Handle {\n+        fn as_raw_handle(&self) -> RawHandle {\n             self.as_inner().handle()\n         }\n     }\n \n     /// Extract raw sockets.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub trait AsRawSocket {\n-        fn as_raw_socket(&self) -> Socket;\n+        /// Extract the underlying raw socket from this object.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        fn as_raw_socket(&self) -> RawSocket;\n+    }\n+\n+    /// Create I/O objects from raw sockets.\n+    #[unstable(feature = \"from_raw_os\", reason = \"recent addition to module\")]\n+    pub trait FromRawSocket {\n+        /// Creates a new I/O object from the given raw socket.\n+        ///\n+        /// This function will **consume ownership** of the socket provided and\n+        /// it will be closed when the returned object goes out of scope.\n+        fn from_raw_socket(sock: RawSocket) -> Self;\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawSocket for old_io::net::tcp::TcpStream {\n-        fn as_raw_socket(&self) -> Socket {\n+        fn as_raw_socket(&self) -> RawSocket {\n             self.as_inner().fd()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawSocket for old_io::net::tcp::TcpListener {\n-        fn as_raw_socket(&self) -> Socket {\n+        fn as_raw_socket(&self) -> RawSocket {\n             self.as_inner().socket()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawSocket for old_io::net::tcp::TcpAcceptor {\n-        fn as_raw_socket(&self) -> Socket {\n+        fn as_raw_socket(&self) -> RawSocket {\n             self.as_inner().socket()\n         }\n     }\n \n     #[allow(deprecated)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawSocket for old_io::net::udp::UdpSocket {\n-        fn as_raw_socket(&self) -> Socket {\n+        fn as_raw_socket(&self) -> RawSocket {\n             self.as_inner().fd()\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawSocket for net::TcpStream {\n-        fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+        fn as_raw_socket(&self) -> RawSocket {\n+            *self.as_inner().socket().as_inner()\n+        }\n     }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawSocket for net::TcpListener {\n-        fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+        fn as_raw_socket(&self) -> RawSocket {\n+            *self.as_inner().socket().as_inner()\n+        }\n     }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawSocket for net::UdpSocket {\n-        fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+        fn as_raw_socket(&self) -> RawSocket {\n+            *self.as_inner().socket().as_inner()\n+        }\n+    }\n+\n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawSocket for net::TcpStream {\n+        fn from_raw_socket(sock: RawSocket) -> net::TcpStream {\n+            let sock = sys::net::Socket::from_inner(sock);\n+            net::TcpStream::from_inner(net2::TcpStream::from_inner(sock))\n+        }\n+    }\n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawSocket for net::TcpListener {\n+        fn from_raw_socket(sock: RawSocket) -> net::TcpListener {\n+            let sock = sys::net::Socket::from_inner(sock);\n+            net::TcpListener::from_inner(net2::TcpListener::from_inner(sock))\n+        }\n+    }\n+    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+    impl FromRawSocket for net::UdpSocket {\n+        fn from_raw_socket(sock: RawSocket) -> net::UdpSocket {\n+            let sock = sys::net::Socket::from_inner(sock);\n+            net::UdpSocket::from_inner(net2::UdpSocket::from_inner(sock))\n+        }\n     }\n }\n \n@@ -230,7 +306,7 @@ pub mod fs {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n     #[doc(no_inline)]\n-    pub use super::io::{Socket, Handle, AsRawSocket, AsRawHandle};\n+    pub use super::io::{RawSocket, RawHandle, AsRawSocket, AsRawHandle};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::ffi::{OsStrExt, OsStringExt};\n     #[doc(no_inline)]"}, {"sha": "0bbb1a9e92752c09c39f81adbcb6b53335b23baf", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -136,7 +136,7 @@ impl FileDesc {\n         }\n     }\n \n-    /// Extract the actual filedescriptor without closing it.\n+    #[allow(dead_code)]\n     pub fn unwrap(self) -> fd_t {\n         let fd = self.fd;\n         unsafe { mem::forget(self) };"}, {"sha": "d03e45649ed05e3a8a3daec584b453eb32fbc4da", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -20,11 +20,12 @@ use mem;\n use path::{Path, PathBuf};\n use ptr;\n use sync::Arc;\n-use sys::handle::Handle as RawHandle;\n+use sys::handle::Handle;\n use sys::{c, cvt};\n+use sys_common::FromInner;\n use vec::Vec;\n \n-pub struct File { handle: RawHandle }\n+pub struct File { handle: Handle }\n pub struct FileAttr { data: c::WIN32_FILE_ATTRIBUTE_DATA }\n \n pub struct ReadDir {\n@@ -192,7 +193,7 @@ impl File {\n         if handle == libc::INVALID_HANDLE_VALUE {\n             Err(Error::last_os_error())\n         } else {\n-            Ok(File { handle: RawHandle::new(handle) })\n+            Ok(File { handle: Handle::new(handle) })\n         }\n     }\n \n@@ -260,7 +261,13 @@ impl File {\n         Ok(newpos as u64)\n     }\n \n-    pub fn handle(&self) -> &RawHandle { &self.handle }\n+    pub fn handle(&self) -> &Handle { &self.handle }\n+}\n+\n+impl FromInner<libc::HANDLE> for File {\n+    fn from_inner(handle: libc::HANDLE) -> File {\n+        File { handle: Handle::new(handle) }\n+    }\n }\n \n pub fn to_utf16(s: &Path) -> Vec<u16> {"}, {"sha": "12a8ef99d764adc3a9d70b6eea9c66bb71787ca0", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -20,7 +20,7 @@ use num::{SignedInt, Int};\n use rt;\n use sync::{Once, ONCE_INIT};\n use sys::c;\n-use sys_common::AsInner;\n+use sys_common::{AsInner, FromInner};\n \n pub type wrlen_t = i32;\n \n@@ -126,10 +126,14 @@ impl Socket {\n \n impl Drop for Socket {\n     fn drop(&mut self) {\n-        unsafe { cvt(libc::closesocket(self.0)).unwrap(); }\n+        let _ = unsafe { libc::closesocket(self.0) };\n     }\n }\n \n impl AsInner<libc::SOCKET> for Socket {\n     fn as_inner(&self) -> &libc::SOCKET { &self.0 }\n }\n+\n+impl FromInner<libc::SOCKET> for Socket {\n+    fn from_inner(sock: libc::SOCKET) -> Socket { Socket(sock) }\n+}"}, {"sha": "d5843a2f9987b153b67543303530eb44dc9af436", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,7 +16,7 @@ use prelude::v1::*;\n use os::windows::prelude::*;\n \n use error::Error as StdError;\n-use ffi::{OsString, OsStr, AsOsStr};\n+use ffi::{OsString, OsStr};\n use fmt;\n use io;\n use libc::types::os::arch::extra::LPWCH;\n@@ -31,7 +31,7 @@ use ptr;\n use slice;\n use sys::c;\n use sys::fs::FileDesc;\n-use sys::handle::Handle as RawHandle;\n+use sys::handle::Handle;\n \n use libc::funcs::extra::kernel32::{\n     GetEnvironmentStringsW,\n@@ -199,13 +199,13 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsOsStr\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n {\n     let mut joined = Vec::new();\n     let sep = b';' as u16;\n \n     for (i, path) in paths.enumerate() {\n-        let path = path.as_os_str();\n+        let path = path.as_ref();\n         if i > 0 { joined.push(sep) }\n         let v = path.encode_wide().collect::<Vec<u16>>();\n         if v.contains(&(b'\"' as u16)) {\n@@ -245,7 +245,8 @@ pub fn getcwd() -> io::Result<PathBuf> {\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let mut p = p.as_os_str().encode_wide().collect::<Vec<_>>();\n+    let p: &OsStr = p.as_ref();\n+    let mut p = p.encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n     unsafe {\n@@ -361,15 +362,15 @@ pub fn temp_dir() -> PathBuf {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    getenv(\"HOME\".as_os_str()).or_else(|| {\n-        getenv(\"USERPROFILE\".as_os_str())\n+    getenv(\"HOME\".as_ref()).or_else(|| {\n+        getenv(\"USERPROFILE\".as_ref())\n     }).map(PathBuf::from).or_else(|| unsafe {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n             return None\n         }\n-        let _handle = RawHandle::new(token);\n+        let _handle = Handle::new(token);\n         super::fill_utf16_buf_new(|buf, mut sz| {\n             match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n                 0 if libc::GetLastError() != 0 => 0,\n@@ -379,3 +380,7 @@ pub fn home_dir() -> Option<PathBuf> {\n         }, super::os2path).ok()\n     })\n }\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe { c::ExitProcess(code as libc::c_uint) }\n+}"}, {"sha": "b10042090ddc8d634a89d875cb10334ea07cf52e", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -23,7 +23,7 @@ use mem;\n use old_io::process::{ProcessExit, ExitStatus};\n use old_io::{IoResult, IoError};\n use old_io;\n-use os;\n+use fs::PathExt;\n use old_path::{BytesContainer, GenericPath};\n use ptr;\n use str;\n@@ -142,14 +142,19 @@ impl Process {\n         let program = cfg.env().and_then(|env| {\n             for (key, v) in env {\n                 if b\"PATH\" != key.container_as_bytes() { continue }\n+                let v = match ::str::from_utf8(v.container_as_bytes()) {\n+                    Ok(s) => s,\n+                    Err(..) => continue,\n+                };\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n-                for path in os::split_paths(v.container_as_bytes()) {\n-                    let path = path.join(cfg.program().as_bytes())\n+                for path in ::env::split_paths(v) {\n+                    let program = str::from_utf8(cfg.program().as_bytes()).unwrap();\n+                    let path = path.join(program)\n                                    .with_extension(env::consts::EXE_EXTENSION);\n                     if path.exists() {\n-                        return Some(CString::from_slice(path.as_vec()))\n+                        return Some(CString::new(path.to_str().unwrap()).unwrap())\n                     }\n                 }\n                 break\n@@ -482,9 +487,9 @@ mod tests {\n     #[test]\n     fn test_make_command_line() {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n-            make_command_line(&CString::from_slice(prog.as_bytes()),\n+            make_command_line(&CString::new(prog).unwrap(),\n                               &args.iter()\n-                                   .map(|a| CString::from_slice(a.as_bytes()))\n+                                   .map(|a| CString::new(*a).unwrap())\n                                    .collect::<Vec<CString>>())\n         }\n "}, {"sha": "7e832b6384dee46ce09686ccd483c7c4008928b3", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -445,10 +445,9 @@ mod tests {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n             String::from_utf16(\n                 &make_command_line(OsStr::from_str(prog),\n-                                   args.iter()\n-                                       .map(|a| OsString::from_str(a))\n-                                       .collect::<Vec<OsString>>()\n-                                       .as_slice())).unwrap()\n+                                   &args.iter()\n+                                        .map(|a| OsString::from(a))\n+                                        .collect::<Vec<OsString>>())).unwrap()\n         }\n \n         assert_eq!("}, {"sha": "91f6f328ff6e0a9eb7038dbfe21e7c4babca885a", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -41,7 +41,7 @@ fn get(handle: libc::DWORD) -> io::Result<Output> {\n         Err(io::Error::last_os_error())\n     } else if handle.is_null() {\n         Err(io::Error::new(io::ErrorKind::Other,\n-                           \"no stdio handle available for this process\", None))\n+                           \"no stdio handle available for this process\"))\n     } else {\n         let ret = NoClose::new(handle);\n         let mut out = 0;\n@@ -160,6 +160,5 @@ impl Drop for NoClose {\n }\n \n fn invalid_encoding() -> io::Error {\n-    io::Error::new(io::ErrorKind::InvalidInput, \"text was not valid unicode\",\n-                   None)\n+    io::Error::new(io::ErrorKind::InvalidInput, \"text was not valid unicode\")\n }"}, {"sha": "b9cbd01bed180120895dc28c1e3085a85b39b377", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -294,12 +294,6 @@ impl<T: 'static> LocalKey<T> {\n             }\n         }\n     }\n-\n-    /// Deprecated\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"function renamed to state() and returns more info\")]\n-    pub fn destroyed(&'static self) -> bool { self.state() == LocalKeyState::Destroyed }\n }\n \n #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]"}, {"sha": "1202b353317cdb4c28cd7ac2cb6b0f7900c65d5d", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 103, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -189,8 +189,6 @@ use sys_common::{stack, thread_info};\n use thunk::Thunk;\n use time::Duration;\n \n-#[allow(deprecated)] use old_io::Writer;\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Thread-local storage\n ////////////////////////////////////////////////////////////////////////////////\n@@ -243,28 +241,6 @@ impl Builder {\n         self\n     }\n \n-    /// Redirect thread-local stdout.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"Will likely go away after proc removal\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"the old I/O module is deprecated and this function \\\n-                           will be removed with no replacement\")]\n-    #[allow(deprecated)]\n-    pub fn stdout(self, _stdout: Box<Writer + Send + 'static>) -> Builder {\n-        self\n-    }\n-\n-    /// Redirect thread-local stderr.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"Will likely go away after proc removal\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"the old I/O module is deprecated and this function \\\n-                           will be removed with no replacement\")]\n-    #[allow(deprecated)]\n-    pub fn stderr(self, _stderr: Box<Writer + Send + 'static>) -> Builder {\n-        self\n-    }\n-\n     /// Spawn a new thread, and return a join handle for it.\n     ///\n     /// The child thread may outlive the parent (unless the parent thread\n@@ -568,71 +544,6 @@ impl Thread {\n         }\n     }\n \n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        Builder::new().spawn(f).unwrap().thread().clone()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n-        T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n-    {\n-        Builder::new().scoped(f).unwrap()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn current() -> Thread {\n-        thread_info::current_thread()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n-    pub fn yield_now() {\n-        unsafe { imp::yield_now() }\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn panicking() -> bool {\n-        unwind::panicking()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n-    pub fn park() {\n-        let thread = current();\n-        let mut guard = thread.inner.lock.lock().unwrap();\n-        while !*guard {\n-            guard = thread.inner.cvar.wait(guard).unwrap();\n-        }\n-        *guard = false;\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n-    pub fn park_timeout(duration: Duration) {\n-        let thread = current();\n-        let mut guard = thread.inner.lock.lock().unwrap();\n-        if !*guard {\n-            let (g, _) = thread.inner.cvar.wait_timeout(guard, duration).unwrap();\n-            guard = g;\n-        }\n-        *guard = false;\n-    }\n-\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n@@ -762,8 +673,8 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n         &self.inner.thread\n     }\n \n-    /// Wait for the associated thread to finish, returning the result of the thread's\n-    /// calculation.\n+    /// Wait for the associated thread to finish, returning the result of the\n+    /// thread's calculation.\n     ///\n     /// # Panics\n     ///\n@@ -777,17 +688,6 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> JoinGuard<'static, T> {\n-    /// Detaches the child thread, allowing it to outlive its parent.\n-    #[deprecated(since = \"1.0.0\", reason = \"use spawn instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn detach(mut self) {\n-        unsafe { imp::detach(self.inner.native) };\n-        self.inner.joined = true; // avoid joining in the destructor\n-    }\n-}\n-\n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n@@ -810,7 +710,6 @@ mod test {\n \n     use any::Any;\n     use sync::mpsc::{channel, Sender};\n-    use boxed::BoxAny;\n     use result;\n     use std::old_io::{ChanReader, ChanWriter};\n     use super::{Builder};"}, {"sha": "f88381fb36f86ea7c274f29671b7ab1ae578aaf8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -92,7 +92,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"main\", \"1.0.0\", Active),\n \n     // Deprecate after snapshot\n-    // SNAP a923278\n+    // SNAP 5520801\n     (\"unsafe_destructor\", \"1.0.0\", Active),\n \n     // A temporary feature gate used to enable parser extensions needed\n@@ -102,9 +102,6 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n     (\"opt_out_copy\", \"1.0.0\", Removed),\n \n-    // A way to temporarily opt out of the new orphan rules. This will *never* be accepted.\n-    (\"old_orphan_check\", \"1.0.0\", Deprecated),\n-\n     // OIBIT specific features\n     (\"optin_builtin_traits\", \"1.0.0\", Active),\n \n@@ -161,10 +158,6 @@ enum Status {\n     /// currently being considered for addition/removal.\n     Active,\n \n-    /// Represents a feature gate that is temporarily enabling deprecated behavior.\n-    /// This gate will never be accepted.\n-    Deprecated,\n-\n     /// Represents a feature which has since been removed (it was once Active)\n     Removed,\n \n@@ -277,9 +270,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"stable\", Whitelisted),\n     (\"unstable\", Whitelisted),\n \n-    // FIXME: #19470 this shouldn't be needed forever\n-    (\"old_orphan_check\", Whitelisted),\n-\n     (\"rustc_paren_sugar\", Gated(\"unboxed_closures\",\n                                 \"unboxed_closures are still evolving\")),\n     (\"rustc_reflect_like\", Gated(\"reflect\",\n@@ -327,7 +317,6 @@ pub struct Features {\n     pub allow_trace_macros: bool,\n     pub allow_internal_unstable: bool,\n     pub allow_custom_derive: bool,\n-    pub old_orphan_check: bool,\n     pub simd_ffi: bool,\n     pub unmarked_api: bool,\n     /// spans of #![feature] attrs for stable language features. for error reporting\n@@ -349,7 +338,6 @@ impl Features {\n             allow_trace_macros: false,\n             allow_internal_unstable: false,\n             allow_custom_derive: false,\n-            old_orphan_check: false,\n             simd_ffi: false,\n             unmarked_api: false,\n             declared_stable_lang_features: Vec::new(),\n@@ -573,14 +561,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                     },\n                     _ => {}\n                 }\n-\n-                if attr::contains_name(&i.attrs[..],\n-                                       \"old_orphan_check\") {\n-                    self.gate_feature(\n-                        \"old_orphan_check\",\n-                        i.span,\n-                        \"the new orphan check rules will eventually be strictly enforced\");\n-                }\n             }\n \n             _ => {}\n@@ -699,13 +679,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n                         Some(&(name, _, Active)) => {\n                             cx.features.push(name);\n                         }\n-                        Some(&(name, _, Deprecated)) => {\n-                            cx.features.push(name);\n-                            span_handler.span_warn(\n-                                mi.span,\n-                                \"feature is deprecated and will only be available \\\n-                                 for a limited time, please rewrite code that relies on it\");\n-                        }\n                         Some(&(_, _, Removed)) => {\n                             span_handler.span_err(mi.span, \"feature has been removed\");\n                         }\n@@ -737,7 +710,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         allow_trace_macros: cx.has_feature(\"trace_macros\"),\n         allow_internal_unstable: cx.has_feature(\"allow_internal_unstable\"),\n         allow_custom_derive: cx.has_feature(\"custom_derive\"),\n-        old_orphan_check: cx.has_feature(\"old_orphan_check\"),\n         simd_ffi: cx.has_feature(\"simd_ffi\"),\n         unmarked_api: cx.has_feature(\"unmarked_api\"),\n         declared_stable_lang_features: accepted_features,"}, {"sha": "0980acd3433dcc427dcf3da5833b856ccdaa3f60", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -37,7 +37,6 @@\n #![feature(unicode)]\n #![feature(path_ext)]\n #![feature(str_char)]\n-#![feature(convert)]\n #![feature(into_cow)]\n #![feature(slice_patterns)]\n "}, {"sha": "78470f002072ddf6f724c21e6d1858ae68f1f92a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -620,8 +620,8 @@ impl<'a> StringReader<'a> {\n         let base = 10;\n \n         // find the integer representing the name\n-        self.scan_digits(base);\n-        let encoded_name: u32 = self.with_str_from(start_bpos, |s| {\n+        self.scan_digits(base, base);\n+        let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n             u32::from_str_radix(s, 10).unwrap_or_else(|_| {\n                 panic!(\"expected digits representing a name, got {:?}, {}, range [{:?},{:?}]\",\n                       s, whence, start_bpos, self.last_pos);\n@@ -638,7 +638,7 @@ impl<'a> StringReader<'a> {\n \n         // find the integer representing the ctxt\n         let start_bpos = self.last_pos;\n-        self.scan_digits(base);\n+        self.scan_digits(base, base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n             u32::from_str_radix(s, 10).unwrap_or_else(|_| {\n                 panic!(\"expected digits representing a ctxt, got {:?}, {}\", s, whence);\n@@ -652,16 +652,28 @@ impl<'a> StringReader<'a> {\n                      ctxt: encoded_ctxt, }\n     }\n \n-    /// Scan through any digits (base `radix`) or underscores, and return how\n-    /// many digits there were.\n-    fn scan_digits(&mut self, radix: u32) -> usize {\n+    /// Scan through any digits (base `scan_radix`) or underscores,\n+    /// and return how many digits there were.\n+    ///\n+    /// `real_radix` represents the true radix of the number we're\n+    /// interested in, and errors will be emitted for any digits\n+    /// between `real_radix` and `scan_radix`.\n+    fn scan_digits(&mut self, real_radix: u32, scan_radix: u32) -> usize {\n+        assert!(real_radix <= scan_radix);\n         let mut len = 0;\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n-            match c.and_then(|cc| cc.to_digit(radix)) {\n+            match c.and_then(|cc| cc.to_digit(scan_radix)) {\n                 Some(_) => {\n                     debug!(\"{:?} in scan_digits\", c);\n+                    // check that the hypothetical digit is actually\n+                    // in range for the true radix\n+                    if c.unwrap().to_digit(real_radix).is_none() {\n+                        self.err_span_(self.last_pos, self.pos,\n+                                       &format!(\"invalid digit for a base {} literal\",\n+                                                real_radix));\n+                    }\n                     len += 1;\n                     self.bump();\n                 }\n@@ -680,19 +692,19 @@ impl<'a> StringReader<'a> {\n \n         if c == '0' {\n             match self.curr.unwrap_or('\\0') {\n-                'b' => { self.bump(); base = 2; num_digits = self.scan_digits(2); }\n-                'o' => { self.bump(); base = 8; num_digits = self.scan_digits(8); }\n-                'x' => { self.bump(); base = 16; num_digits = self.scan_digits(16); }\n+                'b' => { self.bump(); base = 2; num_digits = self.scan_digits(2, 10); }\n+                'o' => { self.bump(); base = 8; num_digits = self.scan_digits(8, 10); }\n+                'x' => { self.bump(); base = 16; num_digits = self.scan_digits(16, 16); }\n                 '0'...'9' | '_' | '.' => {\n-                    num_digits = self.scan_digits(10) + 1;\n+                    num_digits = self.scan_digits(10, 10) + 1;\n                 }\n                 _ => {\n                     // just a 0\n                     return token::Integer(self.name_from(start_bpos));\n                 }\n             }\n         } else if c.is_digit(10) {\n-            num_digits = self.scan_digits(10) + 1;\n+            num_digits = self.scan_digits(10, 10) + 1;\n         } else {\n             num_digits = 0;\n         }\n@@ -711,7 +723,7 @@ impl<'a> StringReader<'a> {\n             // with a number\n             self.bump();\n             if self.curr.unwrap_or('\\0').is_digit(10) {\n-                self.scan_digits(10);\n+                self.scan_digits(10, 10);\n                 self.scan_float_exponent();\n             }\n             let last_pos = self.last_pos;\n@@ -934,7 +946,7 @@ impl<'a> StringReader<'a> {\n             if self.curr_is('-') || self.curr_is('+') {\n                 self.bump();\n             }\n-            if self.scan_digits(10) == 0 {\n+            if self.scan_digits(10, 10) == 0 {\n                 self.err_span_(self.last_pos, self.pos, \"expected at least one digit in exponent\")\n             }\n         }"}, {"sha": "f59e1d8214a5a632d32651e824d04dd9ef9eebff", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -736,7 +736,20 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n \n     let res = match u64::from_str_radix(s, base).ok() {\n         Some(r) => r,\n-        None => { sd.span_err(sp, \"int literal is too large\"); 0 }\n+        None => {\n+            // small bases are lexed as if they were base 10, e.g, the string\n+            // might be `0b10201`. This will cause the conversion above to fail,\n+            // but these cases have errors in the lexer: we don't want to emit\n+            // two errors, and we especially don't want to emit this error since\n+            // it isn't necessarily true.\n+            let already_errored = base < 10 &&\n+                s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n+\n+            if !already_errored {\n+                sd.span_err(sp, \"int literal is too large\");\n+            }\n+            0\n+        }\n     };\n \n     // adjust the sign"}, {"sha": "1649934f4b10e5d4628d20e9ed26370bb9e5a7f6", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -226,13 +226,13 @@ mod test {\n     fn test_move_iter() {\n         let v = SmallVector::zero();\n         let v: Vec<isize> = v.into_iter().collect();\n-        assert_eq!(Vec::new(), v);\n+        assert_eq!(v, Vec::new());\n \n         let v = SmallVector::one(1);\n-        assert_eq!([1], v.into_iter().collect::<Vec<_>>());\n+        assert_eq!(v.into_iter().collect::<Vec<_>>(), [1]);\n \n         let v = SmallVector::many(vec![1, 2, 3]);\n-        assert_eq!([1, 2, 3], v.into_iter().collect::<Vec<_>>());\n+        assert_eq!(v.into_iter().collect::<Vec<_>>(), [1, 2, 3]);\n     }\n \n     #[test]"}, {"sha": "38d58f042b94167fd7ff9ed5d2bd6378d3656bd8", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -62,7 +62,6 @@\n #![feature(std_misc)]\n #![feature(str_char)]\n #![feature(path_ext)]\n-#![feature(convert)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "f7e5c9f1deedc1ef21634c3a5adbb47540ad8d44", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -43,8 +43,6 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(set_stdio)]\n-#![feature(os)]\n-#![feature(convert)]\n #![cfg_attr(test, feature(old_io))]\n \n extern crate getopts;\n@@ -857,7 +855,8 @@ fn get_concurrency() -> usize {\n             if std::rt::util::limit_thread_creation_due_to_osx_and_valgrind() {\n                 1\n             } else {\n-                std::os::num_cpus()\n+                extern { fn rust_get_num_cpus() -> libc::uintptr_t; }\n+                unsafe { rust_get_num_cpus() as usize }\n             }\n         }\n     }"}, {"sha": "09fcd518c1e7e3998f32851738559f36840d845d", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -15,7 +15,6 @@\n #![feature(rustdoc)]\n #![feature(rustc_private)]\n #![feature(path_relative_from)]\n-#![feature(convert)]\n \n extern crate rustdoc;\n extern crate rustc_back;"}, {"sha": "74d8b222c541f72e323869415049d304486b2f3d", "filename": "src/snapshots.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -1,3 +1,13 @@\n+S 2015-03-27 5520801\n+  bitrig-x86_64 41de2c7a69a1ac648d3fa3b65e96a29bdc122163\n+  freebsd-x86_64 0910bbad35e213f679d0433884fd51398eb3bc8d\n+  linux-i386 1ef82402ed16f5a6d2f87a9a62eaa83170e249ec\n+  linux-x86_64 ef2154372e97a3cb687897d027fd51c8f2c5f349\n+  macos-i386 0310b1a970f2da7e61770fd14dbbbdca3b518234\n+  macos-x86_64 5f35d9c920b8083a7420ef8cf5b00d5ef3085dfa\n+  winnt-i386 808b7961f85872f04ec15ad0d3e9e23ae9bc0c3b\n+  winnt-x86_64 903a99a58f57a9bd9848cc68a2445dda881f1ee8\n+\n S 2015-03-25 a923278\n   bitrig-x86_64 41de2c7a69a1ac648d3fa3b65e96a29bdc122163\n   freebsd-x86_64 cd02c86a9218da73b2a45aff293787010d33bf3e"}, {"sha": "ce050cc73235dfd76aced3df5d7b3fff0aeb4690", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -38,11 +38,10 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(rustc_private, core)]\n+#![feature(rustc_private, core, step_by)]\n \n extern crate arena;\n \n-use std::iter::range_step;\n use std::thread;\n use arena::TypedArena;\n \n@@ -109,7 +108,7 @@ fn main() {\n     let long_lived_arena = TypedArena::new();\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n-    let messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n+    let messages = (min_depth..max_depth + 1).step_by(2).map(|depth| {\n         use std::num::Int;\n         let iterations = 2.pow((max_depth - depth + min_depth) as u32);\n         thread::scoped(move || inner(depth, iterations))"}, {"sha": "af9ef80e609bac36aff6e39eeeffa7fb3687a2f4", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -38,9 +38,9 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(core)]\n+#![feature(step_by)]\n \n-use std::{cmp, iter, mem};\n+use std::{cmp, mem};\n use std::thread;\n \n fn rotate(x: &mut [i32]) {\n@@ -163,7 +163,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     let mut futures = vec![];\n     let k = perm.max() / N;\n \n-    for (_, j) in (0..N).zip(iter::count(0, k)) {\n+    for (_, j) in (0..N).zip((0..).step_by(k)) {\n         let max = cmp::min(j+k, perm.max());\n \n         futures.push(thread::scoped(move|| {"}, {"sha": "c190641bfbff02e468df6396c064805ad47139e9", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -193,7 +193,7 @@ fn main() {\n \n            // start processing if this is the one\n            ('>', false) => {\n-               match line[1..].find_str(\"THREE\") {\n+               match line[1..].find(\"THREE\") {\n                    Some(_) => { proc_mode = true; }\n                    None    => { }\n                }"}, {"sha": "c0268e816cf3e537b9c2b7653a4c89680fbebb66", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -118,7 +118,9 @@ fn dot(v: &[f64], u: &[f64]) -> f64 {\n fn parallel<'a,T, F>(v: &mut [T], ref f: F)\n                   where T: Send + Sync + 'a,\n                         F: Fn(usize, &mut [T]) + Sync + 'a {\n-    let size = v.len() / os::num_cpus() + 1;\n+    // FIXME: pick a more appropriate parallel factor\n+    let parallelism = 4;\n+    let size = v.len() / parallelism + 1;\n     v.chunks_mut(size).enumerate().map(|(i, chunk)| {\n         thread::scoped(move|| {\n             f(i * size, chunk)"}, {"sha": "be04bc9bd3b732effbb96c0d55258242f7ed6c8d", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in refutable patterns goes through\n+// different compiler control-flow paths.\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const NEG_128: i8 = -128;\n+const NEG_NEG_128: i8 = -NEG_128;\n+//~^ ERROR constant evaluation error: attempted to negate with overflow\n+//~| ERROR attempted to negate with overflow\n+\n+fn main() {\n+    match -128i8 {\n+        NEG_NEG_128 => println!(\"A\"),\n+        _ => println!(\"B\"),\n+    }\n+}"}, {"sha": "c2bc5b2648af3c4d8393998c707801ab514fda41", "filename": "src/test/compile-fail/const-eval-overflow-3.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array expression.\n+\n+// FIXME (#23926): the error output is not consistent between a\n+// self-hosted and a cross-compiled setup; therefore resorting to\n+// error-pattern for now.\n+\n+// error-pattern: expected constant integer for repeat count, but attempted to add with overflow\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_I\n+    : [u32; (i8::MAX as usize) + 1]\n+    = [0; (i8::MAX + 1) as usize];\n+\n+fn main() {\n+    foo(&A_I8_I[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "719b21000f7a615e48f7dcd1021f41d02a55f0ad", "filename": "src/test/compile-fail/const-eval-overflow-3b.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3b.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array expression.\n+//\n+// This is a variation of another such test, but in this case the\n+// types for the left- and right-hand sides of the addition do not\n+// match (as well as overflow).\n+\n+// FIXME (#23926): the error output is not consistent between a\n+// self-hosted and a cross-compiled setup; therefore resorting to\n+// error-pattern for now.\n+\n+// error-pattern: mismatched types\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_I\n+    : [u32; (i8::MAX as usize) + 1]\n+    = [0; (i8::MAX + 1u8) as usize];\n+\n+fn main() {\n+    foo(&A_I8_I[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "f1f125adaa7e330a73db146083c15493a53ab1bf", "filename": "src/test/compile-fail/const-eval-overflow-4.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test this should fail to compile (#23833)\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array type.\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_T\n+    : [u32; (i8::MAX as i8 + 1i8) as usize]\n+    //~^ ERROR error evaluating count: attempted to add with overflow\n+    = [0; (i8::MAX as usize) + 1];\n+\n+fn main() {\n+    foo(&A_I8_T[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "6322b56a82f000b1931e24ae96ce653534c9068d", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array type.\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_T\n+    : [u32; (i8::MAX as i8 + 1u8) as usize]\n+    //~^ ERROR mismatched types\n+    //~| the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n+    //~| the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n+    = [0; (i8::MAX as usize) + 1];\n+\n+fn main() {\n+    foo(&A_I8_T[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "f647c43e13755d216debdf165d6208284e22840e", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+#![warn(unsigned_negation)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8, i8, i8, i8) =\n+    (-i8::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i8::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i8::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i8::MIN * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_I16: (i16, i16, i16, i16) =\n+    (-i16::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i16::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i16::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i16::MIN * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_I32: (i32, i32, i32, i32) =\n+    (-i32::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i32::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i32::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i32::MIN * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_I64: (i64, i64, i64, i64) =\n+    (-i64::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i64::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i64::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i64::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U8: (u8, u8, u8, u8) =\n+    (-u8::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u8::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u8::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u8::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U16: (u16, u16, u16, u16) =\n+    (-u16::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u16::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u16::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u16::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U32: (u32, u32, u32, u32) =\n+    (-u32::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u32::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u32::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u32::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U64: (u64, u64, u64, u64) =\n+    (-u64::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u64::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u64::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u64::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}"}, {"sha": "23106c99594a6f69e7f2c0ba3734453145a1df19", "filename": "src/test/compile-fail/discrim-ill-typed.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// When explicit discriminant value has\n+// a type that does not match the representation\n+// type, rustc should fail gracefully.\n+\n+// See also run-pass/discrim-explicit-23030.rs where the input types\n+// are correct.\n+\n+#![allow(dead_code, unused_variables, unused_imports)]\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64, u64};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u8,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i8,\n+        //~^  ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u16,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i16,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u32,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i32,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u64,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i64,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn main() { }"}, {"sha": "76378d5c8021bd03eac59f856ba9ad41e5c766aa", "filename": "src/test/compile-fail/discrim-overflow-2.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Issue 23030: Detect overflowing discriminant\n+//\n+// Check that we detect the overflow even if enum is not used.\n+\n+// See also run-pass/discrim-explicit-23030.rs where the suggested\n+// workaround is tested.\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64, u64};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+    }\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+    }\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "5d7e61e9d1eec67fcb340de8ca036661ab9236e9", "filename": "src/test/compile-fail/discrim-overflow.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Issue 23030: Detect overflowing discriminant\n+\n+// See also run-pass/discrim-explicit-23030.rs where the suggested\n+// workaround is tested.\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64, u64};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn main() { }"}, {"sha": "40d992fe21f207abe22984110f44735c61fcced7", "filename": "src/test/compile-fail/dropck_arr_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -20,9 +20,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "9488882ca94a51421a5bf04d89d7ab0d5eb35df6", "filename": "src/test/compile-fail/dropck_tarena_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -27,9 +27,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "9d92552244f28e651f83b1d03a639f68ce11cd32", "filename": "src/test/compile-fail/dropck_vec_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -19,9 +19,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "b5c6db0cea9e32767687133e5330509b1f5b3bdb", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -18,7 +18,7 @@ fn has_uniq(x: String) {\n \n fn has_slice(x: &str) {\n    wants_uniq(x); //~ ERROR mismatched types\n-   wants_slice(x.as_slice());\n+   wants_slice(x);\n }\n \n fn main() {"}, {"sha": "54340cf7ac414f17d922749321a2814c7997f5e1", "filename": "src/test/compile-fail/huge-array-simple.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,9 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: too big for the current\n+// FIXME (#23926): the error output is not consistent between a\n+// self-hosted and a cross-compiled setup. Skipping for now.\n+\n+// ignore-test FIXME(#23926)\n+\n #![allow(exceeding_bitshifts)]\n \n fn main() {\n-   let fat : [u8; (1<<61)+(1<<31)] = [0; (1u64<<61) as usize +(1u64<<31) as usize];\n+    let _fat : [u8; (1<<61)+(1<<31)] =\n+        [0; (1u64<<61) as usize +(1u64<<31) as usize];\n }"}, {"sha": "8886dd80be5039bed56eb68650bcf347efd7d6b9", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::iter::{Range,range};\n+use std::ops::Range;\n \n trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n \n impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n     fn iter(&'r self) -> Range<usize> {\n         let &(min, max) = self;\n-        range(min, max)\n+        min..max\n     }\n }\n "}, {"sha": "9e49abc463f15491906c9a402f844437ebdb980f", "filename": "src/test/compile-fail/issue-17651.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,6 +13,6 @@\n \n fn main() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    (|| Box::new(*[0].as_slice()))();\n+    (|| Box::new(*(&[0][..])))();\n     //~^ ERROR the trait `core::marker::Sized` is not implemented for the type `[_]`\n }"}, {"sha": "d2d0dbf3e981fe3fa32a24d7eb7d9bd32b8cbac4", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,14 +10,14 @@\n \n // ignore-tidy-linelength\n \n-use std::iter::{Range,range};\n+use std::ops::Range;\n \n trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n \n impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n     fn iter(&'r self) -> Range<usize> {\n         let &(min, max) = self;\n-        range(min, max)\n+        min..max\n     }\n }\n "}, {"sha": "a7cabae16be1b8f39be0f84ae8f66a090bbfbdad", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Note: This test is checking that we forbid a coding pattern that\n+// Issue #5873 explicitly wants to allow.\n+\n enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [State::ST_NULL; (State::ST_WHITESPACE as usize)];\n-    //~^ ERROR expected constant integer for repeat count, found non-constant expression\n+    //~^ ERROR expected constant integer for repeat count, but non-constant path\n }"}, {"sha": "3ce206ff7fb2c0c13b1a5a7b1079aa2e65e9a16d", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,6 +12,7 @@\n \n fn main() {\n     fn bar(n: usize) {\n-        let _x = [0; n]; //~ ERROR expected constant integer for repeat count, found variable\n+        let _x = [0; n];\n+        //~^ ERROR expected constant integer for repeat count, found variable\n     }\n }"}, {"sha": "8f9d24cb132c2e4f2a475a4a540338ac5079b2ad", "filename": "src/test/compile-fail/variance-deprecated-markers.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the deprecated markers still have their old effect.\n-\n-#![feature(rustc_attrs)]\n-\n-use std::marker;\n-\n-#[rustc_variance]\n-struct A<T>(marker::CovariantType<T>); //~ ERROR types=[[+];[];[]]\n-\n-#[rustc_variance]\n-struct B<T>(marker::ContravariantType<T>); //~ ERROR types=[[-];[];[]]\n-\n-#[rustc_variance]\n-struct C<T>(marker::InvariantType<T>); //~ ERROR types=[[o];[];[]]\n-\n-#[rustc_variance]\n-struct D<'a>(marker::CovariantLifetime<'a>); //~ ERROR regions=[[+];[];[]]\n-\n-#[rustc_variance]\n-struct E<'a>(marker::ContravariantLifetime<'a>); //~ ERROR regions=[[-];[];[]]\n-\n-#[rustc_variance]\n-struct F<'a>(marker::InvariantLifetime<'a>); //~ ERROR regions=[[o];[];[]]\n-\n-fn main() { }"}, {"sha": "44a3f716e3eea4a3602cc43a5d8928d8faa9a71e", "filename": "src/test/compile-fail/vec-must-not-hide-type-from-dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -30,9 +30,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     /// generates globally unique count (global across the current\n     /// process, that is)"}, {"sha": "0025449a3dbb7f93b2ae5bfb94675b1825ac9ddb", "filename": "src/test/compile-fail/vec_refs_data_with_early_death.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -27,5 +27,5 @@ fn main() {\n     v.push(&x); //~ ERROR `x` does not live long enough\n     v.push(&y); //~ ERROR `y` does not live long enough\n \n-    assert_eq!(v.as_slice(), [&3, &4]);\n+    assert_eq!(v, [&3, &4]);\n }"}, {"sha": "00fb2808faa95124227431a325a22660525b0f8b", "filename": "src/test/parse-fail/issue-1802-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fparse-fail%2Fissue-1802-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fparse-fail%2Fissue-1802-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-1802-1.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,5 +10,5 @@\n \n // error-pattern:no valid digits found for number\n fn main() {\n-    log(error, 0b42);\n+    log(error, 0b);\n }"}, {"sha": "e92000c54ba343633cf645b8612be55883a0ffc4", "filename": "src/test/parse-fail/lex-bad-binary-literal.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fparse-fail%2Flex-bad-binary-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fparse-fail%2Flex-bad-binary-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bad-binary-literal.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    0b121; //~ ERROR invalid digit for a base 2 literal\n+    0b10_10301; //~ ERROR invalid digit for a base 2 literal\n+    0b30; //~ ERROR invalid digit for a base 2 literal\n+    0b41; //~ ERROR invalid digit for a base 2 literal\n+    0b5; //~ ERROR invalid digit for a base 2 literal\n+    0b6; //~ ERROR invalid digit for a base 2 literal\n+    0b7; //~ ERROR invalid digit for a base 2 literal\n+    0b8; //~ ERROR invalid digit for a base 2 literal\n+    0b9; //~ ERROR invalid digit for a base 2 literal\n+}"}, {"sha": "bf9880cb6cfbfb174997b6cde6a912ba1533a253", "filename": "src/test/parse-fail/lex-bad-octal-literal.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    0o18; //~ ERROR invalid digit for a base 8 literal\n+    0o1234_9_5670;  //~ ERROR invalid digit for a base 8 literal\n+}"}, {"sha": "0b35062b186e9227bebbbb35c022fa4454f9df5a", "filename": "src/test/run-fail/assert-eq-macro-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assertion failed: `(left == right) && (right == left)` (left: `14`, right: `15`)\n+// error-pattern:assertion failed: `(left == right)` (left: `14`, right: `15`)\n \n fn main() {\n     assert_eq!(14,15);"}, {"sha": "249e2e1ac2d64938594f638ccbc8186a405e1bfd", "filename": "src/test/run-fail/rt-set-exit-status-panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,16 +10,16 @@\n \n // error-pattern:whatever\n \n-#![feature(os, rustc_private)]\n+#![feature(exit_status, rustc_private)]\n \n #[macro_use] extern crate log;\n-use std::os;\n+use std::env;\n \n fn main() {\n     error!(\"whatever\");\n     // Setting the exit status only works when the scheduler terminates\n     // normally. In this case we're going to panic, so instead of\n     // returning 50 the process will return the typical rt failure code.\n-    os::set_exit_status(50);\n+    env::set_exit_status(50);\n     panic!();\n }"}, {"sha": "fddff3c5a9f4fea67ab205b483e7f34a8b17720c", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,10 +10,10 @@\n \n // error-pattern:whatever\n \n-#![feature(os, rustc_private)]\n+#![feature(exit_status, rustc_private)]\n \n #[macro_use] extern crate log;\n-use std::os;\n+use std::env;\n use std::thread;\n \n struct r {\n@@ -25,7 +25,7 @@ struct r {\n // runtime's exit code\n impl Drop for r {\n     fn drop(&mut self) {\n-        os::set_exit_status(50);\n+        env::set_exit_status(50);\n     }\n }\n "}, {"sha": "c33a8d2d03227027c976a20bb5d8782b9d4e1e4d", "filename": "src/test/run-fail/rt-set-exit-status.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,14 +10,14 @@\n \n // error-pattern:whatever\n \n-#![feature(rustc_private, os)]\n+#![feature(rustc_private, exit_status)]\n \n #[macro_use] extern crate log;\n-use std::os;\n+use std::env;\n \n fn main() {\n     error!(\"whatever\");\n     // 101 is the code the runtime uses on task panic and the value\n     // compiletest expects run-fail tests to return.\n-    os::set_exit_status(101);\n+    env::set_exit_status(101);\n }"}, {"sha": "c1787eb03f5925a67ececa5b076df9828345c957", "filename": "src/test/run-make/link-path-order/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(libc, os)]\n+#![feature(libc, exit_status)]\n \n extern crate libc;\n \n@@ -23,6 +23,6 @@ fn main() {\n     };\n \n     if result != 1 {\n-        std::os::set_exit_status(255);\n+        std::env::set_exit_status(255);\n     }\n }"}, {"sha": "a70a160076520aca44acdf60aa98baea8d2542dc", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -95,10 +95,10 @@ fn main() {\n     let expected_span = format!(\"\\n{}^{}\\n\",\n                                 repeat(\" \").take(offset + 7).collect::<String>(),\n                                 repeat(\"~\").take(8).collect::<String>());\n-    assert!(err.contains(expected_span.as_slice()));\n+    assert!(err.contains(&expected_span));\n     // Second snake is 8 ~s long, with 36 preceding spaces\n     let expected_span = format!(\"\\n{}^{}\\n\",\n                                 repeat(\" \").take(offset + 36).collect::<String>(),\n                                 repeat(\"~\").take(8).collect::<String>());\n-    assert!(err.contains(expected_span.as_slice()));\n+    assert!(err.contains(&expected_span));\n }"}, {"sha": "4bacde0aadf3fc67fed7a79fbef5e90361342828", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -77,6 +77,6 @@ fn main() {\n     let mut tc = TestCalls { count: 1 };\n     // we should never get use this filename, but lets make sure they are valid args.\n     let args = vec![\"compiler-calls\".to_string(), \"foo.rs\".to_string()];\n-    rustc_driver::run_compiler(args.as_slice(), &mut tc);\n+    rustc_driver::run_compiler(&args, &mut tc);\n     assert!(tc.count == 30);\n }"}, {"sha": "e4fb7c199094722d2987568c42f5fcbe08c8528e", "filename": "src/test/run-pass-fulldeps/create-dir-all-bare.rs", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,10 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tempdir)]\n+// ignore-android\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_back;\n \n use std::env;\n-use std::fs::{self, TempDir};\n+use std::fs;\n+use rustc_back::tempdir::TempDir;\n \n fn main() {\n     let td = TempDir::new(\"create-dir-all-bare\").unwrap();", "previous_filename": "src/test/run-pass/create-dir-all-bare.rs"}, {"sha": "a1e016bf2eabaa5be1f1d0e0971c87a06af423b3", "filename": "src/test/run-pass-fulldeps/rename-directory.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,12 +11,16 @@\n // This test can't be a unit test in std,\n // because it needs TempDir, which is in extra\n \n+// ignore-android\n // pretty-expanded FIXME #23616\n \n-#![feature(tempdir, path_ext)]\n+#![feature(rustc_private, path_ext)]\n+\n+extern crate rustc_back;\n \n use std::ffi::CString;\n-use std::fs::{self, TempDir, File, PathExt};\n+use std::fs::{self, File, PathExt};\n+use rustc_back::tempdir::TempDir;\n \n fn rename_directory() {\n     let tmpdir = TempDir::new(\"rename_directory\").ok().expect(\"rename_directory failed\");", "previous_filename": "src/test/run-pass/rename-directory.rs"}, {"sha": "14d8bce061f5aed20699783b800cd333377a08d9", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -80,9 +80,9 @@ fn runtest(me: &str) {\n     let s = str::from_utf8(&out.error).unwrap();\n     let mut i = 0;\n     for _ in 0..2 {\n-        i += s[i + 10..].find_str(\"stack backtrace\").unwrap() + 10;\n+        i += s[i + 10..].find(\"stack backtrace\").unwrap() + 10;\n     }\n-    assert!(s[i + 10..].find_str(\"stack backtrace\").is_none(),\n+    assert!(s[i + 10..].find(\"stack backtrace\").is_none(),\n             \"bad output4: {}\", s);\n }\n "}, {"sha": "b73eac0c7140fa230f64ee7d40296cf6065a75df", "filename": "src/test/run-pass/big-literals.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,11 +10,16 @@\n \n // pretty-expanded FIXME #23616\n \n+#![feature(core)]\n+\n+// Catch mistakes in the overflowing literals lint.\n+#![deny(overflowing_literals)]\n+\n pub fn main() {\n     assert_eq!(0xffffffff, (-1 as u32));\n     assert_eq!(4294967295, (-1 as u32));\n     assert_eq!(0xffffffffffffffff, (-1 as u64));\n     assert_eq!(18446744073709551615, (-1 as u64));\n \n-    assert_eq!(-2147483648 - 1, 2147483647);\n+    assert_eq!((-2147483648i32).wrapping_sub(1), 2147483647);\n }"}, {"sha": "f9b429a935a6a676a553f031f29023c050cdbc5f", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -22,7 +22,7 @@ use log::{set_logger, Logger, LogRecord};\n use std::sync::mpsc::channel;\n use std::fmt;\n use std::old_io::{ChanReader, ChanWriter, Reader, Writer};\n-use std::thread::Thread;\n+use std::thread;\n \n struct MyWriter(ChanWriter);\n \n@@ -36,7 +36,7 @@ impl Logger for MyWriter {\n fn main() {\n     let (tx, rx) = channel();\n     let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         set_logger(box MyWriter(w) as Box<Logger+Send>);\n         debug!(\"debug\");\n         info!(\"info\");"}, {"sha": "7da1416602f6daec46d6961d456da65febc39cc8", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,10 +14,10 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn child2(_s: String) { }\n \n pub fn main() {\n-    let _x = Thread::spawn(move|| child2(\"hi\".to_string()));\n+    let _x = thread::spawn(move|| child2(\"hi\".to_string()));\n }"}, {"sha": "16efceb9d7e0e1db35803a9620b0c2639889f30c", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,7 +13,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax, std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n struct Pair {\n     a: isize,\n@@ -23,7 +23,7 @@ struct Pair {\n pub fn main() {\n     let z: Box<_> = box Pair { a : 10, b : 12};\n \n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n     });"}, {"sha": "859599596ae7bc114ad03a74968137ae96717d6a", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,12 +10,12 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| { child(&tx) });\n+    let _t = thread::scoped(move|| { child(&tx) });\n     let y = rx.recv().unwrap();\n     println!(\"received\");\n     println!(\"{}\", y);"}, {"sha": "03bf3851257dfa10c1644e751d1e55acdb7d335b", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -24,7 +24,7 @@ use std::old_io::{Process, Command, timer};\n use std::time::Duration;\n use std::str;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n macro_rules! succeed { ($e:expr) => (\n     match $e { Ok(..) => {}, Err(e) => panic!(\"panic: {}\", e) }\n@@ -86,7 +86,7 @@ pub fn test_destroy_actually_kills(force: bool) {\n     let (tx, rx1) = channel();\n     let mut t = timer::Timer::new().unwrap();\n     let rx2 = t.oneshot(Duration::milliseconds(1000));\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         select! {\n             _ = rx2.recv() => unsafe { libc::exit(1) },\n             _ = rx1.recv() => {}"}, {"sha": "6ccedb0ad982f129982a87ef47925557c59eadd3", "filename": "src/test/run-pass/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,7 +12,7 @@\n \n #![allow(unknown_features)]\n #![feature(box_syntax)]\n-#![feature(old_orphan_check, rustc_private)]\n+#![feature(rustc_private)]\n \n extern crate serialize;\n "}, {"sha": "d216062bb2da362c3c7369f79fc237a365e8cecc", "filename": "src/test/run-pass/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,7 +13,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(old_orphan_check, rustc_private)]\n+#![feature(rustc_private)]\n \n extern crate serialize;\n "}, {"sha": "105d421b4041567c49497d14b41adde4f2ce4fde", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(old_orphan_check, rand, rustc_private)]\n+#![feature(rand, rustc_private)]\n \n extern crate serialize;\n extern crate rand;"}, {"sha": "aed7b1527ce76d1f2cf483058d9910505f9c177c", "filename": "src/test/run-pass/discrim-explicit-23030.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fdiscrim-explicit-23030.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fdiscrim-explicit-23030.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiscrim-explicit-23030.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 23030: Workaround overflowing discriminant\n+// with explicit assignments.\n+\n+// See also compile-fail/overflow-discrim.rs, which shows what\n+// happens if you leave the OhNo explicit cases out here.\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64,u64,isize,usize};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo = i8::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i8;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo = u8::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo = i16::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i16;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo = u16::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo = i32::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i32;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo = u32::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo = i64::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i64;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo = u64::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_isize() {\n+    #[repr(isize)]\n+    enum A {\n+        Ok = isize::MAX - 1,\n+        Ok2,\n+        OhNo = isize::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as isize;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_usize() {\n+    #[repr(usize)]\n+    enum A {\n+        Ok = usize::MAX - 1,\n+        Ok2,\n+        OhNo = usize::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn main() {\n+    f_i8(); f_u8();\n+    f_i16(); f_u16();\n+    f_i32(); f_u32();\n+    f_i64(); f_u64();\n+\n+    f_isize(); f_usize();\n+}"}, {"sha": "3d4af80e30bb57a98a3349b07eed10ef61e7b1fa", "filename": "src/test/run-pass/drop-with-type-ascription-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,7 +14,7 @@\n \n fn main() {\n     let args = vec!(\"foobie\", \"asdf::asdf\");\n-    let arr: Vec<&str> = args[1].split_str(\"::\").collect();\n+    let arr: Vec<&str> = args[1].split(\"::\").collect();\n     assert_eq!(arr[0], \"asdf\");\n     assert_eq!(arr[0], \"asdf\");\n }"}, {"sha": "7fb96112125afaaae984810a19d6ad83bbfeff3e", "filename": "src/test/run-pass/env-home-dir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,7 +11,6 @@\n // pretty-expanded FIXME #23616\n \n #![feature(path)]\n-#![feature(convert)]\n \n use std::env::*;\n use std::path::PathBuf;"}, {"sha": "e8c9bc76335f7ab7500eed3b0ae0232535b22f82", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -15,7 +15,7 @@\n #![feature(libc, std_misc)]\n \n extern crate libc;\n-use std::thread::Thread;\n+use std::thread;\n \n mod rustrt {\n     extern crate libc;\n@@ -46,7 +46,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let result = count(12);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 2048);"}, {"sha": "5c96aaf4bd8902365862e4a14066d048d35ff374", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -25,7 +25,7 @@ mod map_reduce {\n     use std::collections::HashMap;\n     use std::sync::mpsc::{channel, Sender};\n     use std::str;\n-    use std::thread::Thread;\n+    use std::thread;\n \n     pub type putter<'a> = Box<FnMut(String, String) + 'a>;\n \n@@ -37,7 +37,7 @@ mod map_reduce {\n         for i in &inputs {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n-            Thread::spawn(move|| map_task(ctrl.clone(), i.clone()) );\n+            thread::spawn(move|| map_task(ctrl.clone(), i.clone()) );\n         }\n     }\n "}, {"sha": "26d58d34b9dea1e4dc373adcaeaff2057590b4c9", "filename": "src/test/run-pass/init-large-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-large-type.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,7 +16,7 @@\n \n #![feature(intrinsics, std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n extern \"rust-intrinsic\" {\n     pub fn init<T>() -> T;\n@@ -26,7 +26,7 @@ const SIZE: usize = 1024 * 1024;\n \n fn main() {\n     // do the test in a new thread to avoid (spurious?) stack overflows\n-    let _ = Thread::scoped(|| {\n+    let _ = thread::scoped(|| {\n         let _memory: [u8; SIZE] = unsafe { init() };\n     }).join();\n }"}, {"sha": "35c25b33a9764c2976889ffdf7877dfc4f24a030", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(old_orphan_check, rustc_private, old_io)]\n+#![feature(rustc_private, old_io)]\n \n extern crate rbml;\n extern crate serialize;"}, {"sha": "c260aa95b57f1d556bdf83f77826ba120ab0ea7c", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -29,8 +29,8 @@ fn main() {\n fn parent() {\n     let args: Vec<String> = env::args().collect();\n     let mut p = Command::new(&args[0]).arg(\"child\")\n-                        .stdout(Stdio::capture())\n-                        .stdin(Stdio::capture())\n+                        .stdout(Stdio::piped())\n+                        .stdin(Stdio::piped())\n                         .spawn().unwrap();\n     p.stdin.as_mut().unwrap().write_all(b\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();"}, {"sha": "d1b1647de7881244887f8011abd854374a4ce71a", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,7 +16,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n fn helper(rx: Receiver<Sender<()>>) {\n     for tx in rx.iter() {\n@@ -26,7 +26,7 @@ fn helper(rx: Receiver<Sender<()>>) {\n \n fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| { helper(rx) });\n+    let _t = thread::scoped(move|| { helper(rx) });\n     let (snd, rcv) = channel::<isize>();\n     for _ in 1..100000 {\n         snd.send(1).unwrap();\n@@ -37,4 +37,5 @@ fn main() {\n             _ = rcv.recv() => ()\n         }\n     }\n+    drop(tx);\n }"}, {"sha": "907967d115d583ec7ecc67ce5e7e6ddc6fede761", "filename": "src/test/run-pass/issue-14021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14021.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(old_orphan_check, rustc_private)]\n+#![feature(rustc_private)]\n \n extern crate serialize;\n "}, {"sha": "ab9633ca1fe90e0ba46d921e66b16264792c5279", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -38,9 +38,9 @@ fn child() {\n fn test() {\n     let args: Vec<String> = env::args().collect();\n     let mut p = Command::new(&args[0]).arg(\"child\")\n-                                     .stdin(Stdio::capture())\n-                                     .stdout(Stdio::capture())\n-                                     .stderr(Stdio::capture())\n+                                     .stdin(Stdio::piped())\n+                                     .stdout(Stdio::piped())\n+                                     .stderr(Stdio::piped())\n                                      .spawn().unwrap();\n     assert!(p.wait().unwrap().success());\n }"}, {"sha": "67ce6a1c44f0db4b2866889bdbaaec565dd92f43", "filename": "src/test/run-pass/issue-15734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15734.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,7 +13,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(old_orphan_check, core)]\n+#![feature(core)]\n \n use std::ops::Index;\n "}, {"sha": "6e93194647ad2c8aea38bbfa4e80361f5100b485", "filename": "src/test/run-pass/issue-17351.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-17351.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-17351.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17351.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,6 +12,10 @@\n \n #![feature(core)]\n \n+trait Str { fn foo(&self) {} }\n+impl Str for str {}\n+impl<'a, S: ?Sized> Str for &'a S where S: Str {}\n+\n fn main() {\n     let _: &Str = &\"x\";\n }"}, {"sha": "a66d5e102888ce0d4f03ff45098fd9f1f38654ae", "filename": "src/test/run-pass/issue-17746.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-17746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-17746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17746.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #17746\n+\n+fn main() {}\n+\n+struct A;\n+\n+impl A {\n+    fn b(&mut self) {\n+        self.a()\n+    }\n+}\n+\n+trait Foo {\n+    fn dummy(&self) {}\n+}\n+trait Bar {\n+    fn a(&self);\n+}\n+\n+impl Foo for A {}\n+impl<T> Bar for T where T: Foo {\n+    fn a(&self) {}\n+}"}, {"sha": "d527d9519cfbc4eee484caa8bca030b6f3c492d4", "filename": "src/test/run-pass/issue-20454.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20454.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,10 +12,12 @@\n \n use std::thread;\n \n-fn main() {\n-    thread::Thread::spawn(move || { // no need for -> ()\n+fn _foo() {\n+    let _t = thread::scoped(move || { // no need for -> ()\n         loop {\n             println!(\"hello\");\n         }\n     });\n }\n+\n+fn main() {}"}, {"sha": "45d31d4a7f168ffa987e9a9cfcc65adad1adf636", "filename": "src/test/run-pass/issue-20797.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,8 +12,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(convert)]\n-\n use std::default::Default;\n use std::io;\n use std::fs;"}, {"sha": "2c4141b0bd37939a88ef3c827b9271532792d262", "filename": "src/test/run-pass/issue-22577.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22577.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -15,13 +15,14 @@\n use std::{fs, net};\n \n fn assert_both<T: Send + Sync>() {}\n+fn assert_send<T: Send>() {}\n \n fn main() {\n     assert_both::<fs::File>();\n     assert_both::<fs::Metadata>();\n     assert_both::<fs::ReadDir>();\n     assert_both::<fs::DirEntry>();\n-    assert_both::<fs::WalkDir>();\n+    assert_send::<fs::WalkDir>();\n     assert_both::<fs::OpenOptions>();\n     assert_both::<fs::Permissions>();\n "}, {"sha": "71d1439dd2bc8f3f14d197137c50853a27e506fe", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -21,7 +21,7 @@ pub mod pipes {\n     use std::mem::{forget, transmute};\n     use std::mem::{replace, swap};\n     use std::mem;\n-    use std::thread::Thread;\n+    use std::thread;\n     use std::marker::Send;\n \n     pub struct Stuff<T> {\n@@ -115,7 +115,7 @@ pub mod pipes {\n             let old_state = swap_state_acq(&mut (*p).state,\n                                            blocked);\n             match old_state {\n-              empty | blocked => { Thread::yield_now(); }\n+              empty | blocked => { thread::yield_now(); }\n               full => {\n                 let payload = replace(&mut p.payload, None);\n                 return Some(payload.unwrap())"}, {"sha": "45eb21374e2981aab7a5b84bdfc5e93f966587f0", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,7 +11,7 @@\n #![allow(unknown_features)]\n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::Sender;\n use std::thunk::Invoke;\n \n@@ -24,7 +24,7 @@ enum Msg\n }\n \n fn foo(name: String, samples_chan: Sender<Msg>) {\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let mut samples_chan = samples_chan;\n \n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible."}, {"sha": "7f66b6b25b8d2860c112edfb97bdc98bec046ede", "filename": "src/test/run-pass/issue-3743.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3743.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,7 +10,6 @@\n \n // If `Mul` used an associated type for its output, this test would\n // work more smoothly.\n-#![feature(old_orphan_check)]\n \n use std::ops::Mul;\n "}, {"sha": "280311af6fbd12ea94121129cc608f6f9a8f12f2", "filename": "src/test/run-pass/issue-8827.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8827.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,12 +10,12 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Receiver};\n \n fn periodical(n: isize) -> Receiver<bool> {\n     let (chan, port) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         loop {\n             for _ in 1..n {\n                 match chan.send(false) {\n@@ -34,7 +34,7 @@ fn periodical(n: isize) -> Receiver<bool> {\n \n fn integers() -> Receiver<isize> {\n     let (chan, port) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         let mut i = 1;\n         loop {\n             match chan.send(i) {"}, {"sha": "bfaf060e43c30ac41d25f856663c430cbe8166c4", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,12 +14,12 @@\n \n use std::sync::mpsc::{TryRecvError, channel};\n use std::old_io::timer::Timer;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::scoped(move||{\n+    let _t = thread::scoped(move||{\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(10));\n         tx.send(()).unwrap();"}, {"sha": "8ae084dce8c37793a928b9deb41101647062325a", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n fn producer(tx: &Sender<Vec<u8>>) {\n@@ -23,7 +23,7 @@ fn producer(tx: &Sender<Vec<u8>>) {\n \n pub fn main() {\n     let (tx, rx) = channel::<Vec<u8>>();\n-    let _prod = Thread::spawn(move|| {\n+    let _prod = thread::scoped(move|| {\n         producer(&tx)\n     });\n "}, {"sha": "11b1d70137deffe7046b5bf791b05bf8b3c83cfd", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,15 +10,15 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn user(_i: isize) {}\n \n fn foo() {\n     // Here, i is *copied* into the proc (heap closure).\n     // Requires allocation.  The proc's copy is not mutable.\n     let mut i = 0;\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         user(i);\n         println!(\"spawned {}\", i)\n     });\n@@ -31,7 +31,7 @@ fn bar() {\n     // mutable outside of the proc.\n     let mut i = 0;\n     while i < 10 {\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::scoped(move|| {\n             user(i);\n         });\n         i += 1;\n@@ -42,7 +42,7 @@ fn car() {\n     // Here, i must be shadowed in the proc to be mutable.\n     let mut i = 0;\n     while i < 10 {\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::scoped(move|| {\n             let mut i = i;\n             i += 1;\n             user(i);"}, {"sha": "4881a5ab647ec0996efde72f97ad3c368aae8120", "filename": "src/test/run-pass/macro-with-braces-in-expr-position.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,13 +10,13 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n macro_rules! expr { ($e: expr) => { $e } }\n \n macro_rules! spawn {\n     ($($code: tt)*) => {\n-        expr!(Thread::spawn(move|| {$($code)*}))\n+        expr!(thread::spawn(move|| {$($code)*}))\n     }\n }\n "}, {"sha": "77072bdec905190cb483a1cacd74e29c7fa49c36", "filename": "src/test/run-pass/method-two-traits-distinguished-via-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -33,6 +33,6 @@ impl<T> B for *const [T] {\n \n fn main() {\n     let x: [isize; 4] = [1,2,3,4];\n-    let xptr = x.as_slice() as *const [isize];\n+    let xptr = &x[..] as *const [isize];\n     xptr.foo();\n }"}, {"sha": "86dd1a04532b47b83b9e0a542117e9eaeb3df58f", "filename": "src/test/run-pass/minmax-stability-issue-23687.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+use std::fmt::Debug;\n+use std::cmp::{self, PartialOrd, Ordering};\n+use std::iter::MinMaxResult::MinMax;\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+struct Foo {\n+    n: u8,\n+    name: &'static str\n+}\n+\n+impl PartialOrd for Foo {\n+    fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Foo {\n+    fn cmp(&self, other: &Foo) -> Ordering {\n+        self.n.cmp(&other.n)\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo { n: 4, name: \"a\" };\n+    let b = Foo { n: 4, name: \"b\" };\n+    let c = Foo { n: 8, name: \"c\" };\n+    let d = Foo { n: 8, name: \"d\" };\n+    let e = Foo { n: 22, name: \"e\" };\n+    let f = Foo { n: 22, name: \"f\" };\n+\n+    let data = [a, b, c, d, e, f];\n+\n+    // `min` should return the left when the values are equal\n+    assert_eq!(data.iter().min(), Some(&a));\n+    assert_eq!(data.iter().min_by(|a| a.n), Some(&a));\n+    assert_eq!(cmp::min(a, b), a);\n+    assert_eq!(cmp::min(b, a), b);\n+    assert_eq!(cmp::partial_min(a, b), Some(a));\n+    assert_eq!(cmp::partial_min(b, a), Some(b));\n+\n+    // `max` should return the right when the values are equal\n+    assert_eq!(data.iter().max(), Some(&f));\n+    assert_eq!(data.iter().max_by(|a| a.n), Some(&f));\n+    assert_eq!(cmp::max(e, f), f);\n+    assert_eq!(cmp::max(f, e), e);\n+    assert_eq!(cmp::partial_max(e, f), Some(f));\n+    assert_eq!(cmp::partial_max(f, e), Some(e));\n+\n+    // Similar for `min_max`\n+    assert_eq!(data.iter().min_max(), MinMax(&a, &f));\n+    assert_eq!(data[1..5].iter().min_max(), MinMax(&b, &e));\n+    assert_eq!(data[2..4].iter().min_max(), MinMax(&c, &d));\n+\n+    let mut presorted = data.to_vec();\n+    presorted.sort();\n+    assert_stable(&presorted);\n+\n+    let mut presorted = data.to_vec();\n+    presorted.sort_by(|a, b| a.cmp(b));\n+    assert_stable(&presorted);\n+\n+    // Assert that sorted and min/max are the same\n+    fn assert_stable<T: Ord + Debug>(presorted: &[T]) {\n+        for slice in presorted.windows(2) {\n+            let a = &slice[0];\n+            let b = &slice[1];\n+\n+            assert_eq!(a, cmp::min(a, b));\n+            assert_eq!(b, cmp::max(a, b));\n+        }\n+    }\n+}"}, {"sha": "b6509d280366a2e295b2998a27c9be2eed7a9464", "filename": "src/test/run-pass/moves-based-on-type-capture-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,11 +10,11 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n     let x = \"Hello world!\".to_string();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         println!(\"{}\", x);\n     });\n }"}, {"sha": "03ba6097cd9297ad6d120e223b749912966abfbe", "filename": "src/test/run-pass/option-ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-ext.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,7 +12,7 @@\n \n pub fn main() {\n     let thing = \"{{ f }}\";\n-    let f = thing.find_str(\"{{\");\n+    let f = thing.find(\"{{\");\n \n     if f.is_none() {\n         println!(\"None!\");"}, {"sha": "f08ed6e7f9cdc06cee25fd99c63689cf8488a0d2", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -18,7 +18,7 @@\n \n use std::old_io::process::Command;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n // lifted from the test module\n // Inlining to avoid llvm turning the recursive functions into tail calls,\n@@ -37,7 +37,7 @@ fn recurse() {\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 && args[1] == \"recurse\" {\n-        let _t = Thread::scoped(recurse);\n+        let _t = thread::scoped(recurse);\n     } else {\n         let recurse = Command::new(&args[0]).arg(\"recurse\").output().unwrap();\n         assert!(!recurse.status.success());"}, {"sha": "9ef66ff2d713c6890dfa54dbfb1fe256a72cf826", "filename": "src/test/run-pass/process-exit.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fprocess-exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fprocess-exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-exit.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::process::{self, Command, Stdio};\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() > 1 && args[1] == \"child\" {\n+        child();\n+    } else {\n+        parent();\n+    }\n+}\n+\n+fn parent() {\n+    let args: Vec<String> = env::args().collect();\n+    let status = Command::new(&args[0]).arg(\"child\").status().unwrap();\n+    assert_eq!(status.code(), Some(2));\n+}\n+\n+fn child() -> i32 {\n+    process::exit(2);\n+}"}, {"sha": "63525b36206a419d1b78fb4e9259a531bca3876f", "filename": "src/test/run-pass/regions-refcell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fregions-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fregions-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-refcell.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -29,7 +29,7 @@ fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) {\n // supposed to match the lifetime `'a`) ...\n fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) {\n     let one = [1];\n-    assert_eq!(map.borrow().get(\"one\"), Some(&one.as_slice()));\n+    assert_eq!(map.borrow().get(\"one\"), Some(&&one[..]));\n }\n \n #[cfg(all(not(cannot_use_this_yet),not(cannot_use_this_yet_either)))]"}, {"sha": "abad08c7ac6b31bc57593547184b2134c7349323", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(start, os, std_misc, old_io)]\n \n-use std::ffi;\n+use std::ffi::CStr;\n use std::old_io::process::{Command, ProcessOutput};\n use std::os;\n use std::rt::unwind::try;\n@@ -38,7 +38,7 @@ fn start(argc: isize, argv: *const *const u8) -> isize {\n     let args = unsafe {\n         (0..argc as usize).map(|i| {\n             let ptr = *argv.offset(i as isize) as *const _;\n-            ffi::c_str_to_bytes(&ptr).to_vec()\n+            CStr::from_ptr(ptr).to_bytes().to_vec()\n         }).collect::<Vec<_>>()\n     };\n     let me = &*args[0];"}, {"sha": "660b1e2036d3311dcd838ef12d5f25d2b37c44b6", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -19,7 +19,7 @@\n extern crate log;\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n pub struct ChannelLogger {\n     tx: Sender<String>\n@@ -41,7 +41,7 @@ impl log::Logger for ChannelLogger {\n pub fn main() {\n     let (logger, rx) = ChannelLogger::new();\n \n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         log::set_logger(logger);\n \n         info!(\"foo\");"}, {"sha": "99ae3b7c7d87c63cf54479adf99bfc0473d3431f", "filename": "src/test/run-pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,7 +11,7 @@\n // pretty-expanded FIXME #23616\n \n #![feature(core, std_misc)]\n-use std::thread::Thread;\n+use std::thread;\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)\n@@ -21,7 +21,7 @@ fn par_for<I, F>(iter: I, f: F)\n {\n     let f = &f;\n     let _guards: Vec<_> = iter.map(|elem| {\n-        Thread::scoped(move || {\n+        thread::scoped(move || {\n             f(elem)\n         })\n     }).collect();"}, {"sha": "3f64b2adb639538f490fc5a3c601606e99854175", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::channel;\n \n struct test {\n@@ -32,7 +32,7 @@ fn test(f: isize) -> test {\n pub fn main() {\n     let (tx, rx) = channel();\n \n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let (tx2, rx2) = channel();\n         tx.send(tx2).unwrap();\n "}, {"sha": "9f7b78e4e3354fae1e16d0bd6978e673f61e5e57", "filename": "src/test/run-pass/simd-binop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-binop.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -32,6 +32,7 @@ pub fn main() {\n     assert!(eq_u32x4(u32x4(1, 2, 3, 4) + u32x4(4, 3, 2, 1), u32x4(5, 5, 5, 5)));\n     assert!(eq_u32x4(u32x4(4, 5, 6, 7) - u32x4(4, 3, 2, 1), u32x4(0, 2, 4, 6)));\n     assert!(eq_u32x4(u32x4(1, 2, 3, 4) * u32x4(4, 3, 2, 1), u32x4(4, 6, 6, 4)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) / u32x4(4, 3, 2, 1), u32x4(0, 0, 1, 4)));\n     assert!(eq_u32x4(u32x4(1, 2, 3, 4) & u32x4(4, 3, 2, 1), u32x4(0, 2, 2, 0)));\n     assert!(eq_u32x4(u32x4(1, 2, 3, 4) | u32x4(4, 3, 2, 1), u32x4(5, 3, 3, 5)));\n     assert!(eq_u32x4(u32x4(1, 2, 3, 4) ^ u32x4(4, 3, 2, 1), u32x4(5, 1, 1, 5)));\n@@ -41,6 +42,7 @@ pub fn main() {\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) + i32x4(4, 3, 2, 1), i32x4(5, 5, 5, 5)));\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) - i32x4(4, 3, 2, 1), i32x4(-3, -1, 1, 3)));\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) * i32x4(4, 3, 2, 1), i32x4(4, 6, 6, 4)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) / i32x4(4, 3, 2, 1), i32x4(0, 0, 1, 4)));\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) & i32x4(4, 3, 2, 1), i32x4(0, 2, 2, 0)));\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) | i32x4(4, 3, 2, 1), i32x4(5, 3, 3, 5)));\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) ^ i32x4(4, 3, 2, 1), i32x4(5, 1, 1, 5)));"}, {"sha": "a87a3072c8adbcbd1d04495b8da91c8b35068507", "filename": "src/test/run-pass/small-enum-range-edge.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,6 +10,9 @@\n \n // pretty-expanded FIXME #23616\n \n+// this is for the wrapping_add call below.\n+#![feature(core)]\n+\n /*!\n  * Tests the range assertion wraparound case in trans::middle::adt::load_discr.\n  */\n@@ -29,8 +32,8 @@ static CLs: Es = Es::Ls;\n static CHs: Es = Es::Hs;\n \n pub fn main() {\n-    assert_eq!((Eu::Hu as u8) + 1, Eu::Lu as u8);\n-    assert_eq!((Es::Hs as i8) + 1, Es::Ls as i8);\n+    assert_eq!((Eu::Hu as u8).wrapping_add(1), Eu::Lu as u8);\n+    assert_eq!((Es::Hs as i8).wrapping_add(1), Es::Ls as i8);\n     assert_eq!(CLu as u8, Eu::Lu as u8);\n     assert_eq!(CHu as u8, Eu::Hu as u8);\n     assert_eq!(CLs as i8, Es::Ls as i8);"}, {"sha": "c453f9252efe6aedd03cf9bfd704d9fb32ffe269", "filename": "src/test/run-pass/stat.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![feature(tempdir, path_ext)]\n-\n-use std::fs::{File, TempDir};\n-use std::io::prelude::*;\n-\n-pub fn main() {\n-    let dir = TempDir::new_in(\".\", \"\").unwrap();\n-    let path = dir.path().join(\"file\");\n-\n-    {\n-        match File::create(&path) {\n-            Err(..) => unreachable!(),\n-            Ok(f) => {\n-                let mut f = f;\n-                for _ in 0..1000 {\n-                    f.write(&[0]);\n-                }\n-            }\n-        }\n-    }\n-\n-    assert!(path.exists());\n-    assert_eq!(path.metadata().unwrap().len(), 1000);\n-}"}, {"sha": "8834fd39d1d8845f135e14abf1bd9f56d1587e17", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -36,16 +36,12 @@ pub fn main() {\n     assert!(\n         include_str!(\"syntax-extension-source-utils-files/includeme.\\\n                       fragment\").to_string()\n-        .as_slice()\n         .starts_with(\"/* this is for \"));\n     assert!(\n         include_bytes!(\"syntax-extension-source-utils-files/includeme.fragment\")\n         [1] == (42 as u8)); // '*'\n     // The Windows tests are wrapped in an extra module for some reason\n     assert!((m1::m2::where_am_i().ends_with(\"m1::m2\")));\n \n-    assert!(match (47, \"( 2 * 3 ) + 5\") {\n-        (line!(), stringify!((2*3) + 5)) => true,\n-        _ => false\n-    })\n+    assert_eq!((46, \"( 2 * 3 ) + 5\"), (line!(), stringify!((2*3) + 5)));\n }"}, {"sha": "786dd2c76123e4a02e7975ccfd26fee519593f79", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { test05(); }\n@@ -26,7 +26,7 @@ fn test05_start(tx : &Sender<isize>) {\n \n fn test05() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| { test05_start(&tx) });\n+    let _t = thread::scoped(move|| { test05_start(&tx) });\n     let mut value: isize = rx.recv().unwrap();\n     println!(\"{}\", value);\n     value = rx.recv().unwrap();"}, {"sha": "9c3466f162b03f365e1dd824689c590c30cabaea", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,13 +10,13 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() { test00(); }\n \n fn start() { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n-    let _ = Thread::scoped(move|| start() ).join();\n+    let _ = thread::scoped(move|| start() ).join();\n     println!(\"Completing.\");\n }"}, {"sha": "f25bb3ff71ae8fe9803c9b58f73e4775460a5404", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n fn start(tx: &Sender<Sender<String>>) {\n@@ -29,10 +29,10 @@ fn start(tx: &Sender<Sender<String>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = Thread::spawn(move|| { start(&tx) });\n+    let _child = thread::scoped(move|| { start(&tx) });\n \n     let mut c = rx.recv().unwrap();\n     c.send(\"A\".to_string()).unwrap();\n     c.send(\"B\".to_string()).unwrap();\n-    Thread::yield_now();\n+    thread::yield_now();\n }"}, {"sha": "ec9ed53c1dca0cb21dc6c3b9ddced2b97554c6cf", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,7 +13,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(tx: &Sender<Sender<isize>>) {\n     let (tx2, _rx) = channel();\n@@ -22,7 +22,7 @@ fn start(tx: &Sender<Sender<isize>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = Thread::spawn(move|| {\n+    let _child = thread::scoped(move|| {\n         start(&tx)\n     });\n     let _tx = rx.recv().unwrap();"}, {"sha": "03305091a2d074cddcece5ee5185786f1b15e3ef", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,22 +10,22 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() { test00(); }\n \n fn start(_task_number: isize) { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: isize = 0;\n-    let mut result = Thread::scoped(move|| {\n+    let mut result = thread::scoped(move|| {\n         start(i)\n     });\n \n     // Sleep long enough for the task to finish.\n     let mut i = 0_usize;\n     while i < 10000 {\n-        Thread::yield_now();\n+        thread::yield_now();\n         i += 1;\n     }\n "}, {"sha": "15ceacd672f8bb8a16a4d91f78762762227367f5", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,7 +11,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(tx: &Sender<isize>, start: isize, number_of_messages: isize) {\n     let mut i: isize = 0;\n@@ -21,6 +21,6 @@ fn start(tx: &Sender<isize>, start: isize, number_of_messages: isize) {\n pub fn main() {\n     println!(\"Check that we don't deadlock.\");\n     let (tx, rx) = channel();\n-    let _ = Thread::scoped(move|| { start(&tx, 0, 10) }).join();\n+    let _t = thread::scoped(move|| { start(&tx, 0, 10) }).join();\n     println!(\"Joined task\");\n }"}, {"sha": "1e2d9fe52df154f1869fc1abc873c1e42737fd48", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -11,7 +11,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n     let (tx, rx) = channel();\n@@ -21,7 +21,7 @@ pub fn main() {\n     while (i > 0) {\n         println!(\"{}\", i);\n         let tx = tx.clone();\n-        Thread::spawn({let i = i; move|| { child(i, &tx) }});\n+        thread::scoped({let i = i; move|| { child(i, &tx) }});\n         i = i - 1;\n     }\n "}, {"sha": "2663595aecfa18570c0130436313f578ee290e65", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,7 +13,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(tx: &Sender<isize>, i0: isize) {\n     let mut i = i0;\n@@ -29,7 +29,7 @@ pub fn main() {\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         start(&tx, 10)\n     });\n     rx.recv();"}, {"sha": "de334c77aa310e5b947c83581f14245043648314", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -16,11 +16,11 @@\n \n // This test is specifically about spawning temporary closures.\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn f() {\n }\n \n pub fn main() {\n-    let _t = Thread::scoped(move|| f() ).join();\n+    let _t = thread::scoped(move|| f() ).join();\n }"}, {"sha": "254ad653c48132ba6a676270774d9a60c4dea121", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,7 +12,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n@@ -42,7 +42,7 @@ fn test00() {\n     let mut results = Vec::new();\n     while i < number_of_tasks {\n         let tx = tx.clone();\n-        results.push(Thread::scoped({\n+        results.push(thread::scoped({\n             let i = i;\n             move|| {\n                 test00_start(&tx, i, number_of_messages)"}, {"sha": "b05e36552a24c16b849168c61ad775e921829f99", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,7 +14,7 @@\n #![allow(dead_assignment)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() { test00(); }\n \n@@ -31,19 +31,19 @@ fn test00() {\n     let number_of_messages: isize = 10;\n \n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 0, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 1, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 2, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 3, number_of_messages);\n     });\n "}, {"sha": "758764aa9fdcca766ee17564cda123e36303d244", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { test00(); }\n@@ -26,7 +26,7 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: isize = 10;\n \n-    let result = Thread::scoped(move|| {\n+    let result = thread::scoped(move|| {\n         test00_start(&tx, number_of_messages);\n     });\n "}, {"sha": "b97f4355b3ee08bb297b0d2d4f4a458628830b9a", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -12,10 +12,10 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n-    let _t = Thread::spawn(move|| child(\"Hello\".to_string()) );\n+    let _t = thread::scoped(move|| child(\"Hello\".to_string()) );\n }\n \n fn child(_s: String) {"}, {"sha": "aa7b61bf112f90627cd4516e53d3d63ecd7d200a", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -13,7 +13,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax, std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::channel;\n \n pub fn main() {\n@@ -22,7 +22,7 @@ pub fn main() {\n     let x: Box<isize> = box 1;\n     let x_in_parent = &(*x) as *const isize as usize;\n \n-    let _t = Thread::spawn(move || {\n+    let _t = thread::scoped(move || {\n         let x_in_child = &(*x) as *const isize as usize;\n         tx.send(x_in_child).unwrap();\n     });"}, {"sha": "00467e563347a32174c7cb5a693448d75a7b68dc", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -19,7 +19,7 @@ use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n use std::sync::Arc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n static N: usize = 8;\n static M: usize = 20;\n@@ -40,7 +40,7 @@ fn test() {\n         let a = a.clone();\n         let cnt = cnt.clone();\n         let srv_tx = srv_tx.clone();\n-        Thread::scoped(move|| {\n+        thread::scoped(move|| {\n             let mut a = a;\n             loop {\n                 match a.accept() {\n@@ -59,7 +59,7 @@ fn test() {\n \n     let _t = (0..N).map(|_| {\n         let cli_tx = cli_tx.clone();\n-        Thread::scoped(move|| {\n+        thread::scoped(move|| {\n             for _ in 0..M {\n                 let _s = TcpStream::connect(addr).unwrap();\n             }"}, {"sha": "64f07a60b3503858390cadc58b92687422f0c8d9", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -26,15 +26,15 @@ use std::old_io::test::*;\n use std::old_io;\n use std::time::Duration;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n #[cfg_attr(target_os = \"freebsd\", ignore)]\n fn eventual_timeout() {\n     let addr = next_test_ip4();\n \n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let _l = TcpListener::bind(addr).unwrap().listen();\n         tx1.send(()).unwrap();\n         let _ = rx2.recv();"}, {"sha": "4209d5986ba506c8fc3d1a69180273bfa94ca4c5", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -23,20 +23,20 @@ extern crate libc;\n use std::sync::mpsc::channel;\n use std::old_io::net::tcp::{TcpListener, TcpStream};\n use std::old_io::{Acceptor, Listener, Reader, Writer};\n-use std::thread::{Builder, Thread};\n+use std::thread::{self, Builder};\n use std::time::Duration;\n \n fn main() {\n     // This test has a chance to time out, try to not let it time out\n-    Thread::spawn(move|| -> () {\n+    thread::spawn(move|| -> () {\n         use std::old_io::timer;\n         timer::sleep(Duration::milliseconds(30 * 1000));\n         println!(\"timed out!\");\n         unsafe { libc::exit(1) }\n     });\n \n     let (tx, rx) = channel();\n-    Thread::spawn(move || -> () {\n+    thread::spawn(move || -> () {\n         let mut listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n         tx.send(listener.socket_name().unwrap()).unwrap();\n         let mut acceptor = listener.listen();"}, {"sha": "49fac24d0b3a5b7e921233856ad3dff79776f99a", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -24,7 +24,7 @@ use std::old_path::{Path, GenericPath};\n use std::old_io::fs::PathExtensions;\n use std::old_io::{fs, TempDir};\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::sync::mpsc::channel;\n use std::thread;\n \n@@ -129,7 +129,7 @@ fn test_rm_tempdir_close() {\n // to depend on std\n fn recursive_mkdir_rel() {\n     let path = Path::new(\"frob\");\n-    let cwd = os::getcwd().unwrap();\n+    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n     println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, old_io::USER_RWX);\n@@ -147,7 +147,7 @@ fn recursive_mkdir_dot() {\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n-    let cwd = os::getcwd().unwrap();\n+    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n     println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, old_io::USER_RWX);\n@@ -196,7 +196,7 @@ pub fn dont_double_panic() {\n \n fn in_tmpdir<F>(f: F) where F: FnOnce() {\n     let tmpdir = TempDir::new(\"test\").ok().expect(\"can't make tmpdir\");\n-    assert!(os::change_dir(tmpdir.path()).is_ok());\n+    assert!(env::set_current_dir(tmpdir.path().as_str().unwrap()).is_ok());\n \n     f();\n }"}, {"sha": "969a42a6f8715624ad3543688927b7cbcd057e08", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -10,12 +10,12 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n     let mut i = 10;\n     while i > 0 {\n-        Thread::scoped({let i = i; move|| child(i)});\n+        thread::scoped({let i = i; move|| child(i)});\n         i = i - 1;\n     }\n     println!(\"main thread exiting\");"}, {"sha": "02ea7037056051a5e2d1a1f79049f327c142f388", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -19,7 +19,7 @@\n \n use std::sync::Arc;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n trait Pet {\n     fn name(&self, blk: Box<FnMut(&str)>);\n@@ -83,13 +83,13 @@ pub fn main() {\n                             box dogge2 as Box<Pet+Sync+Send>));\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n-    let _t1 = Thread::spawn(move|| { check_legs(arc1); tx1.send(()); });\n+    let _t1 = thread::scoped(move|| { check_legs(arc1); tx1.send(()); });\n     let (tx2, rx2) = channel();\n     let arc2 = arc.clone();\n-    let _t2 = Thread::spawn(move|| { check_names(arc2); tx2.send(()); });\n+    let _t2 = thread::scoped(move|| { check_names(arc2); tx2.send(()); });\n     let (tx3, rx3) = channel();\n     let arc3 = arc.clone();\n-    let _t3 = Thread::spawn(move|| { check_pedigree(arc3); tx3.send(()); });\n+    let _t3 = thread::scoped(move|| { check_pedigree(arc3); tx3.send(()); });\n     rx1.recv();\n     rx2.recv();\n     rx3.recv();"}, {"sha": "c2db63ed251a5c72420d8189102f54cb230d5895", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,7 +14,6 @@\n \n #![feature(alloc)]\n \n-use std::boxed::BoxAny;\n use std::thread;\n \n struct Foo;"}, {"sha": "d81dc3afcd7af05d03d7ba52212eba2edeac57da", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89436536246250ee3cbc47a61c31037ce7558c06/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=89436536246250ee3cbc47a61c31037ce7558c06", "patch": "@@ -14,7 +14,7 @@\n \n extern crate libc;\n \n-use std::ffi::{self, CString};\n+use std::ffi::{CStr, CString};\n use libc::{c_char, c_int};\n \n \n@@ -25,7 +25,7 @@ extern {\n unsafe fn check<T, F>(expected: &str, f: F) where F: FnOnce(*mut c_char) -> T {\n     let mut x = [0 as c_char; 50];\n     f(&mut x[0] as *mut c_char);\n-    assert_eq!(expected.as_bytes(), ffi::c_str_to_bytes(&x.as_ptr()));\n+    assert_eq!(expected.as_bytes(), CStr::from_ptr(x.as_ptr()).to_bytes());\n }\n \n pub fn main() {"}]}