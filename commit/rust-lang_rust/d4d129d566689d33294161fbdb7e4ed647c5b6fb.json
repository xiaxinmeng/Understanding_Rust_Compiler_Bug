{"sha": "d4d129d566689d33294161fbdb7e4ed647c5b6fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZDEyOWQ1NjY2ODlkMzMyOTQxNjFmYmRiN2U0ZWQ2NDdjNWI2ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-11T00:00:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-11T00:00:53Z"}, "message": "Auto merge of #85012 - FabianWolff:struct-rec, r=davidtwco\n\nFix stack overflow when checking for structural recursion\n\nThis pull request aims to fix #74224 and fix #84611. The current logic for detecting ADTs with structural recursion is flawed because it only looks at the root type, and then for exact matches. What I mean by this is that for examples such as:\n```rust\nstruct A<T> {\n    x: T,\n    y: A<A<T>>,\n}\n\nstruct B {\n    z: A<usize>\n}\n\nfn main() {}\n```\nWhen checking `A`, the compiler correctly determines that it has an infinite size (because the \"root\" type is `A`, and `A` occurs, albeit with different type arguments, as a nested type in `A`).\n\nHowever, when checking `B`, it also recurses into `A`, but now `B` is the root type, and it only checks for _exact_ matches of `A`, but since `A` never precisely contains itself (only `A<A<T>>`, `A<A<A<T>>>`, etc.), an endless recursion ensues until the stack overflows.\n\nIn this PR, I have attempted to fix this behavior by implementing a two-phase checking: When checking `B`, my code first checks `A` _separately_ and stops if `A` already turns out to be infinite. If not (such as for `Option<T>`), the second phase checks whether the root type (`B`) is ever nested inside itself, e.g.:\n```rust\nstruct Foo { x: Option<Option<Foo>> }\n```\n\nSpecial care needs to be taken for mutually recursive types, e.g.:\n```rust\nstruct A<T> {\n    z: T,\n    x: B<T>,\n}\n\nstruct B<T> {\n    y: A<T>\n}\n```\nHere, both `A` and `B` both _are_ `SelfRecursive` and _contain_ a recursive type. The current behavior, which I have maintained, is to treat both `A` and `B` as `SelfRecursive`, and accordingly report errors for both.", "tree": {"sha": "3ddbc6b53fa147a5dedfe847f4abe35a01db42c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ddbc6b53fa147a5dedfe847f4abe35a01db42c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d129d566689d33294161fbdb7e4ed647c5b6fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d129d566689d33294161fbdb7e4ed647c5b6fb", "html_url": "https://github.com/rust-lang/rust/commit/d4d129d566689d33294161fbdb7e4ed647c5b6fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d129d566689d33294161fbdb7e4ed647c5b6fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79e50bf77928f374921a6bcafee3fcff1915f062", "url": "https://api.github.com/repos/rust-lang/rust/commits/79e50bf77928f374921a6bcafee3fcff1915f062", "html_url": "https://github.com/rust-lang/rust/commit/79e50bf77928f374921a6bcafee3fcff1915f062"}, {"sha": "98728c2b35da6600e15d57e494041dcf6dc21c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/98728c2b35da6600e15d57e494041dcf6dc21c1a", "html_url": "https://github.com/rust-lang/rust/commit/98728c2b35da6600e15d57e494041dcf6dc21c1a"}], "stats": {"total": 357, "additions": 338, "deletions": 19}, "files": [{"sha": "d3eb9fd95571400724496faf317b625e1dfa127f", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 200, "deletions": 19, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/d4d129d566689d33294161fbdb7e4ed647c5b6fb/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d129d566689d33294161fbdb7e4ed647c5b6fb/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=d4d129d566689d33294161fbdb7e4ed647c5b6fb", "patch": "@@ -25,11 +25,26 @@ pub enum Representability {\n pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> Representability {\n     debug!(\"is_type_representable: {:?}\", ty);\n     // To avoid a stack overflow when checking an enum variant or struct that\n-    // contains a different, structurally recursive type, maintain a stack\n-    // of seen types and check recursion for each of them (issues #3008, #3779).\n+    // contains a different, structurally recursive type, maintain a stack of\n+    // seen types and check recursion for each of them (issues #3008, #3779,\n+    // #74224, #84611). `shadow_seen` contains the full stack and `seen` only\n+    // the one for the current type (e.g. if we have structs A and B, B contains\n+    // a field of type A, and we're currently looking at B, then `seen` will be\n+    // cleared when recursing to check A, but `shadow_seen` won't, so that we\n+    // can catch cases of mutual recursion where A also contains B).\n     let mut seen: Vec<Ty<'_>> = Vec::new();\n+    let mut shadow_seen: Vec<&'tcx ty::AdtDef> = Vec::new();\n     let mut representable_cache = FxHashMap::default();\n-    let r = is_type_structurally_recursive(tcx, sp, &mut seen, &mut representable_cache, ty);\n+    let mut force_result = false;\n+    let r = is_type_structurally_recursive(\n+        tcx,\n+        sp,\n+        &mut seen,\n+        &mut shadow_seen,\n+        &mut representable_cache,\n+        ty,\n+        &mut force_result,\n+    );\n     debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n     r\n }\n@@ -48,21 +63,38 @@ fn are_inner_types_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    force_result: &mut bool,\n ) -> Representability {\n+    debug!(\"are_inner_types_recursive({:?}, {:?}, {:?})\", ty, seen, shadow_seen);\n     match ty.kind() {\n         ty::Tuple(..) => {\n             // Find non representable\n-            fold_repr(\n-                ty.tuple_fields().map(|ty| {\n-                    is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n-                }),\n-            )\n+            fold_repr(ty.tuple_fields().map(|ty| {\n+                is_type_structurally_recursive(\n+                    tcx,\n+                    sp,\n+                    seen,\n+                    shadow_seen,\n+                    representable_cache,\n+                    ty,\n+                    force_result,\n+                )\n+            }))\n         }\n         // Fixed-length vectors.\n         // FIXME(#11924) Behavior undecided for zero-length vectors.\n-        ty::Array(ty, _) => is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty),\n+        ty::Array(ty, _) => is_type_structurally_recursive(\n+            tcx,\n+            sp,\n+            seen,\n+            shadow_seen,\n+            representable_cache,\n+            ty,\n+            force_result,\n+        ),\n         ty::Adt(def, substs) => {\n             // Find non representable fields with their spans\n             fold_repr(def.all_fields().map(|field| {\n@@ -76,12 +108,128 @@ fn are_inner_types_recursive<'tcx>(\n                     Some(hir::Node::Field(field)) => field.ty.span,\n                     _ => sp,\n                 };\n-                match is_type_structurally_recursive(tcx, span, seen, representable_cache, ty) {\n-                    Representability::SelfRecursive(_) => {\n-                        Representability::SelfRecursive(vec![span])\n+\n+                let mut result = None;\n+\n+                // First, we check whether the field type per se is representable.\n+                // This catches cases as in #74224 and #84611. There is a special\n+                // case related to mutual recursion, though; consider this example:\n+                //\n+                //   struct A<T> {\n+                //       z: T,\n+                //       x: B<T>,\n+                //   }\n+                //\n+                //   struct B<T> {\n+                //       y: A<T>\n+                //   }\n+                //\n+                // Here, without the following special case, both A and B are\n+                // ContainsRecursive, which is a problem because we only report\n+                // errors for SelfRecursive. We fix this by detecting this special\n+                // case (shadow_seen.first() is the type we are originally\n+                // interested in, and if we ever encounter the same AdtDef again,\n+                // we know that it must be SelfRecursive) and \"forcibly\" returning\n+                // SelfRecursive (by setting force_result, which tells the calling\n+                // invocations of are_inner_types_representable to forward the\n+                // result without adjusting).\n+                if shadow_seen.len() > seen.len() && shadow_seen.first() == Some(def) {\n+                    *force_result = true;\n+                    result = Some(Representability::SelfRecursive(vec![span]));\n+                }\n+\n+                if result == None {\n+                    result = Some(Representability::Representable);\n+\n+                    // Now, we check whether the field types per se are representable, e.g.\n+                    // for struct Foo { x: Option<Foo> }, we first check whether Option<_>\n+                    // by itself is representable (which it is), and the nesting of Foo\n+                    // will be detected later. This is necessary for #74224 and #84611.\n+\n+                    // If we have encountered an ADT definition that we have not seen\n+                    // before (no need to check them twice), recurse to see whether that\n+                    // definition is SelfRecursive. If so, we must be ContainsRecursive.\n+                    if shadow_seen.len() > 1\n+                        && !shadow_seen\n+                            .iter()\n+                            .take(shadow_seen.len() - 1)\n+                            .any(|seen_def| seen_def == def)\n+                    {\n+                        let adt_def_id = def.did;\n+                        let raw_adt_ty = tcx.type_of(adt_def_id);\n+                        debug!(\"are_inner_types_recursive: checking nested type: {:?}\", raw_adt_ty);\n+\n+                        // Check independently whether the ADT is SelfRecursive. If so,\n+                        // we must be ContainsRecursive (except for the special case\n+                        // mentioned above).\n+                        let mut nested_seen: Vec<Ty<'_>> = vec![];\n+                        result = Some(\n+                            match is_type_structurally_recursive(\n+                                tcx,\n+                                span,\n+                                &mut nested_seen,\n+                                shadow_seen,\n+                                representable_cache,\n+                                raw_adt_ty,\n+                                force_result,\n+                            ) {\n+                                Representability::SelfRecursive(_) => {\n+                                    if *force_result {\n+                                        Representability::SelfRecursive(vec![span])\n+                                    } else {\n+                                        Representability::ContainsRecursive\n+                                    }\n+                                }\n+                                x => x,\n+                            },\n+                        );\n+                    }\n+\n+                    // We only enter the following block if the type looks representable\n+                    // so far. This is necessary for cases such as this one (#74224):\n+                    //\n+                    //   struct A<T> {\n+                    //       x: T,\n+                    //       y: A<A<T>>,\n+                    //   }\n+                    //\n+                    //   struct B {\n+                    //       z: A<usize>\n+                    //   }\n+                    //\n+                    // When checking B, we recurse into A and check field y of type\n+                    // A<A<usize>>. We haven't seen this exact type before, so we recurse\n+                    // into A<A<usize>>, which contains, A<A<A<usize>>>, and so forth,\n+                    // ad infinitum. We can prevent this from happening by first checking\n+                    // A separately (the code above) and only checking for nested Bs if\n+                    // A actually looks representable (which it wouldn't in this example).\n+                    if result == Some(Representability::Representable) {\n+                        // Now, even if the type is representable (e.g. Option<_>),\n+                        // it might still contribute to a recursive type, e.g.:\n+                        //   struct Foo { x: Option<Option<Foo>> }\n+                        // These cases are handled by passing the full `seen`\n+                        // stack to is_type_structurally_recursive (instead of the\n+                        // empty `nested_seen` above):\n+                        result = Some(\n+                            match is_type_structurally_recursive(\n+                                tcx,\n+                                span,\n+                                seen,\n+                                shadow_seen,\n+                                representable_cache,\n+                                ty,\n+                                force_result,\n+                            ) {\n+                                Representability::SelfRecursive(_) => {\n+                                    Representability::SelfRecursive(vec![span])\n+                                }\n+                                x => x,\n+                            },\n+                        );\n                     }\n-                    x => x,\n                 }\n+\n+                result.unwrap()\n             }))\n         }\n         ty::Closure(..) => {\n@@ -106,8 +254,10 @@ fn is_type_structurally_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    force_result: &mut bool,\n ) -> Representability {\n     debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n     if let Some(representability) = representable_cache.get(ty) {\n@@ -118,8 +268,15 @@ fn is_type_structurally_recursive<'tcx>(\n         return representability.clone();\n     }\n \n-    let representability =\n-        is_type_structurally_recursive_inner(tcx, sp, seen, representable_cache, ty);\n+    let representability = is_type_structurally_recursive_inner(\n+        tcx,\n+        sp,\n+        seen,\n+        shadow_seen,\n+        representable_cache,\n+        ty,\n+        force_result,\n+    );\n \n     representable_cache.insert(ty, representability.clone());\n     representability\n@@ -129,12 +286,16 @@ fn is_type_structurally_recursive_inner<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    force_result: &mut bool,\n ) -> Representability {\n     match ty.kind() {\n         ty::Adt(def, _) => {\n             {\n+                debug!(\"is_type_structurally_recursive_inner: adt: {:?}, seen: {:?}\", ty, seen);\n+\n                 // Iterate through stack of previously seen types.\n                 let mut iter = seen.iter();\n \n@@ -158,8 +319,10 @@ fn is_type_structurally_recursive_inner<'tcx>(\n                 // will recurse infinitely for some inputs.\n                 //\n                 // It is important that we DO take generic parameters into account\n-                // here, so that code like this is considered SelfRecursive, not\n-                // ContainsRecursive:\n+                // here, because nesting e.g. Options is allowed (as long as the\n+                // definition of Option doesn't itself include an Option field, which\n+                // would be a case of SelfRecursive above). The following, too, counts\n+                // as SelfRecursive:\n                 //\n                 // struct Foo { Option<Option<Foo>> }\n \n@@ -174,13 +337,31 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             // For structs and enums, track all previously seen types by pushing them\n             // onto the 'seen' stack.\n             seen.push(ty);\n-            let out = are_inner_types_recursive(tcx, sp, seen, representable_cache, ty);\n+            shadow_seen.push(def);\n+            let out = are_inner_types_recursive(\n+                tcx,\n+                sp,\n+                seen,\n+                shadow_seen,\n+                representable_cache,\n+                ty,\n+                force_result,\n+            );\n+            shadow_seen.pop();\n             seen.pop();\n             out\n         }\n         _ => {\n             // No need to push in other cases.\n-            are_inner_types_recursive(tcx, sp, seen, representable_cache, ty)\n+            are_inner_types_recursive(\n+                tcx,\n+                sp,\n+                seen,\n+                shadow_seen,\n+                representable_cache,\n+                ty,\n+                force_result,\n+            )\n         }\n     }\n }"}, {"sha": "f3b72c5df7f70b2617ddbe530bf235ebf0204fe7", "filename": "src/test/ui/structs-enums/struct-rec/issue-74224.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.rs?ref=d4d129d566689d33294161fbdb7e4ed647c5b6fb", "patch": "@@ -0,0 +1,11 @@\n+struct A<T> {\n+//~^ ERROR recursive type `A` has infinite size\n+    x: T,\n+    y: A<A<T>>,\n+}\n+\n+struct B {\n+    z: A<usize>\n+}\n+\n+fn main() {}"}, {"sha": "d61ab1952f9f1452acfe37cf5d31df7a8285952b", "filename": "src/test/ui/structs-enums/struct-rec/issue-74224.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr?ref=d4d129d566689d33294161fbdb7e4ed647c5b6fb", "patch": "@@ -0,0 +1,17 @@\n+error[E0072]: recursive type `A` has infinite size\n+  --> $DIR/issue-74224.rs:1:1\n+   |\n+LL | struct A<T> {\n+   | ^^^^^^^^^^^ recursive type has infinite size\n+...\n+LL |     y: A<A<T>>,\n+   |        ------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `A` representable\n+   |\n+LL |     y: Box<A<A<T>>>,\n+   |        ^^^^       ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "4c356af3eb8a3244eeb5c534c7a37ee522a76291", "filename": "src/test/ui/structs-enums/struct-rec/issue-84611.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.rs?ref=d4d129d566689d33294161fbdb7e4ed647c5b6fb", "patch": "@@ -0,0 +1,11 @@\n+struct Foo<T> {\n+//~^ ERROR recursive type `Foo` has infinite size\n+    x: Foo<[T; 1]>,\n+    y: T,\n+}\n+\n+struct Bar {\n+    x: Foo<Bar>,\n+}\n+\n+fn main() {}"}, {"sha": "0a898e5c46dbefcf0e06c6afad4f8a2377c203b8", "filename": "src/test/ui/structs-enums/struct-rec/issue-84611.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr?ref=d4d129d566689d33294161fbdb7e4ed647c5b6fb", "patch": "@@ -0,0 +1,17 @@\n+error[E0072]: recursive type `Foo` has infinite size\n+  --> $DIR/issue-84611.rs:1:1\n+   |\n+LL | struct Foo<T> {\n+   | ^^^^^^^^^^^^^ recursive type has infinite size\n+LL |\n+LL |     x: Foo<[T; 1]>,\n+   |        ----------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL |     x: Box<Foo<[T; 1]>>,\n+   |        ^^^^           ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "cca97f43effc399c80b85c8f6554deaae2ff0301", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs?ref=d4d129d566689d33294161fbdb7e4ed647c5b6fb", "patch": "@@ -0,0 +1,23 @@\n+struct A<T> {\n+//~^ ERROR recursive type `A` has infinite size\n+    x: T,\n+    y: B<T>,\n+}\n+\n+struct B<T> {\n+//~^ ERROR recursive type `B` has infinite size\n+    z: A<T>\n+}\n+\n+struct C<T> {\n+//~^ ERROR recursive type `C` has infinite size\n+    x: T,\n+    y: Option<Option<D<T>>>,\n+}\n+\n+struct D<T> {\n+//~^ ERROR recursive type `D` has infinite size\n+    z: Option<Option<C<T>>>,\n+}\n+\n+fn main() {}"}, {"sha": "efc4ba93f0a2bdf147c366ec149fbaac3949313b", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4d129d566689d33294161fbdb7e4ed647c5b6fb/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr?ref=d4d129d566689d33294161fbdb7e4ed647c5b6fb", "patch": "@@ -0,0 +1,59 @@\n+error[E0072]: recursive type `A` has infinite size\n+  --> $DIR/mutual-struct-recursion.rs:1:1\n+   |\n+LL | struct A<T> {\n+   | ^^^^^^^^^^^ recursive type has infinite size\n+...\n+LL |     y: B<T>,\n+   |        ---- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `A` representable\n+   |\n+LL |     y: Box<B<T>>,\n+   |        ^^^^    ^\n+\n+error[E0072]: recursive type `B` has infinite size\n+  --> $DIR/mutual-struct-recursion.rs:7:1\n+   |\n+LL | struct B<T> {\n+   | ^^^^^^^^^^^ recursive type has infinite size\n+LL |\n+LL |     z: A<T>\n+   |        ---- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `B` representable\n+   |\n+LL |     z: Box<A<T>>\n+   |        ^^^^    ^\n+\n+error[E0072]: recursive type `C` has infinite size\n+  --> $DIR/mutual-struct-recursion.rs:12:1\n+   |\n+LL | struct C<T> {\n+   | ^^^^^^^^^^^ recursive type has infinite size\n+...\n+LL |     y: Option<Option<D<T>>>,\n+   |        -------------------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `C` representable\n+   |\n+LL |     y: Box<Option<Option<D<T>>>>,\n+   |        ^^^^                    ^\n+\n+error[E0072]: recursive type `D` has infinite size\n+  --> $DIR/mutual-struct-recursion.rs:18:1\n+   |\n+LL | struct D<T> {\n+   | ^^^^^^^^^^^ recursive type has infinite size\n+LL |\n+LL |     z: Option<Option<C<T>>>,\n+   |        -------------------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `D` representable\n+   |\n+LL |     z: Box<Option<Option<C<T>>>>,\n+   |        ^^^^                    ^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0072`."}]}