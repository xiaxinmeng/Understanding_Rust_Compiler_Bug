{"sha": "a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYjBmNWZiYTVkN2JmMThiMjRkMWZhMGU0NTRhNGZlODcxZmVjZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-24T04:43:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-24T04:43:24Z"}, "message": "Auto merge of #48552 - kennytm:lower-unstable-priority, r=nikomatsakis\n\nLower the priority of unstable methods when picking a candidate.\n\nPreviously, when searching for the impl of a method, we do not consider the stability of the impl. This leads to lots of insta-inference-regressions due to method ambiguity when a popular name is chosen. This has happened multiple times in Rust's history e.g.\n\n* `f64::from_bits` #40470\n* `Ord::{min, max}` #42496\n* `Ord::clamp` #44095 (eventually got reverted due to these breakages)\n* `Iterator::flatten` #48115 (recently added)\n\nThis PR changes the probing order so that unstable items are considered last. If a stable item is found, the unstable items will not be considered (but a future-incompatible warning will still be emitted), thus allowing stable code continue to function without using qualified names.\n\nOnce the unstable feature is stabilized, the ambiguity error will still be emitted, but the user can also use newly stable std methods, while the current situation is that downstream user is forced to update the code without any immediate benefit.\n\n(I hope that we could bring back `Ord::clamp` if this PR is merged.)", "tree": {"sha": "9369afe94bbea45db94172abd02c1acc4fb7630e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9369afe94bbea45db94172abd02c1acc4fb7630e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "html_url": "https://github.com/rust-lang/rust/commit/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab0ef145ac993d01a73c1c4a5decb1f68b3aad36", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab0ef145ac993d01a73c1c4a5decb1f68b3aad36", "html_url": "https://github.com/rust-lang/rust/commit/ab0ef145ac993d01a73c1c4a5decb1f68b3aad36"}, {"sha": "17cc3d77d16e0cc3dfa1b3ee9749e2fca3ebb9e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/17cc3d77d16e0cc3dfa1b3ee9749e2fca3ebb9e7", "html_url": "https://github.com/rust-lang/rust/commit/17cc3d77d16e0cc3dfa1b3ee9749e2fca3ebb9e7"}], "stats": {"total": 473, "additions": 381, "deletions": 92}, "files": [{"sha": "97cfcf0f60795a07080b82d196a545aee8e14db9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -260,6 +260,12 @@ declare_lint! {\n     \"floating-point literals cannot be used in patterns\"\n }\n \n+declare_lint! {\n+    pub UNSTABLE_NAME_COLLISION,\n+    Warn,\n+    \"detects name collision with an existing but unstable method\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -307,7 +313,8 @@ impl LintPass for HardwiredLints {\n             SINGLE_USE_LIFETIME,\n             TYVAR_BEHIND_RAW_POINTER,\n             ELIDED_LIFETIME_IN_PATH,\n-            BARE_TRAIT_OBJECT\n+            BARE_TRAIT_OBJECT,\n+            UNSTABLE_NAME_COLLISION,\n         )\n     }\n }"}, {"sha": "1497be2d5ba0d35448feeed03c0ca4dcce1a95fd", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -498,15 +498,21 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n     // Check for future incompatibility lints and issue a stronger warning.\n     let lints = sess.lint_store.borrow();\n-    if let Some(future_incompatible) = lints.future_incompatible(LintId::of(lint)) {\n-        let future = if let Some(edition) = future_incompatible.edition {\n-            format!(\"the {} edition\", edition)\n+    let lint_id = LintId::of(lint);\n+    if let Some(future_incompatible) = lints.future_incompatible(lint_id) {\n+        const STANDARD_MESSAGE: &str =\n+            \"this was previously accepted by the compiler but is being phased out; \\\n+             it will become a hard error\";\n+\n+        let explanation = if lint_id == LintId::of(::lint::builtin::UNSTABLE_NAME_COLLISION) {\n+            \"once this method is added to the standard library, \\\n+             there will be ambiguity here, which will cause a hard error!\"\n+                .to_owned()\n+        } else if let Some(edition) = future_incompatible.edition {\n+            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n         } else {\n-            \"a future release\".to_owned()\n+            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n         };\n-        let explanation = format!(\"this was previously accepted by the compiler \\\n-                                   but is being phased out; \\\n-                                   it will become a hard error in {}!\", future);\n         let citation = format!(\"for more information, see {}\",\n                                future_incompatible.reference);\n         err.warn(&explanation);"}, {"sha": "29c8ac046b815f43b2ecdb8f8ea29d23350db124", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 80, "deletions": 38, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -474,6 +474,22 @@ struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n+/// Result of `TyCtxt::eval_stability`.\n+pub enum EvalResult {\n+    /// We can use the item because it is stable or we provided the\n+    /// corresponding feature gate.\n+    Allow,\n+    /// We cannot use the item because it is unstable and we did not provide the\n+    /// corresponding feature gate.\n+    Deny {\n+        feature: Symbol,\n+        reason: Option<Symbol>,\n+        issue: u32,\n+    },\n+    /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n+    Unmarked,\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // (See issue #38412)\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n@@ -509,14 +525,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn check_stability(self, def_id: DefId, id: NodeId, span: Span) {\n+    /// Evaluates the stability of an item.\n+    ///\n+    /// Returns `EvalResult::Allow` if the item is stable, or unstable but the corresponding\n+    /// `#![feature]` has been provided. Returns `EvalResult::Deny` which describes the offending\n+    /// unstable feature otherwise.\n+    ///\n+    /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n+    /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n+    /// `id`.\n+    pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n         if span.allows_unstable() {\n             debug!(\"stability: \\\n                     skipping span={:?} since it is internal\", span);\n-            return;\n+            return EvalResult::Allow;\n         }\n \n-        let lint_deprecated = |def_id: DefId, note: Option<Symbol>| {\n+        let lint_deprecated = |def_id: DefId, id: NodeId, note: Option<Symbol>| {\n             let path = self.item_path_str(def_id);\n \n             let msg = if let Some(note) = note {\n@@ -526,30 +551,29 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             self.lint_node(lint::builtin::DEPRECATED, id, span, &msg);\n+            if id == ast::DUMMY_NODE_ID {\n+                span_bug!(span, \"emitted a deprecated lint with dummy node id: {:?}\", def_id);\n+            }\n         };\n \n         // Deprecated attributes apply in-crate and cross-crate.\n-        if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-            let skip = if id == ast::DUMMY_NODE_ID {\n-                true\n-            } else {\n+        if let Some(id) = id {\n+            if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n                 let parent_def_id = self.hir.local_def_id(self.hir.get_parent(id));\n-                self.lookup_deprecation_entry(parent_def_id).map_or(false, |parent_depr| {\n-                    parent_depr.same_origin(&depr_entry)\n-                })\n+                let skip = self.lookup_deprecation_entry(parent_def_id)\n+                    .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n+                if !skip {\n+                    lint_deprecated(def_id, id, depr_entry.attr.note);\n+                }\n             };\n-\n-            if !skip {\n-                lint_deprecated(def_id, depr_entry.attr.note);\n-            }\n         }\n \n         let is_staged_api = self.lookup_stability(DefId {\n             index: CRATE_DEF_INDEX,\n             ..def_id\n         }).is_some();\n         if !is_staged_api {\n-            return;\n+            return EvalResult::Allow;\n         }\n \n         let stability = self.lookup_stability(def_id);\n@@ -558,26 +582,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(&Stability{rustc_depr: Some(attr::RustcDeprecation { reason, .. }), ..})\n                 = stability {\n-            if id != ast::DUMMY_NODE_ID {\n-                lint_deprecated(def_id, Some(reason));\n+            if let Some(id) = id {\n+                lint_deprecated(def_id, id, Some(reason));\n             }\n         }\n \n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !def_id.is_local();\n         if !cross_crate {\n-            return\n+            return EvalResult::Allow;\n         }\n \n         // Issue 38412: private items lack stability markers.\n         if self.skip_stability_check_due_to_privacy(def_id) {\n-            return\n+            return EvalResult::Allow;\n         }\n \n         match stability {\n-            Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n-                if self.stability().active_features.contains(feature) {\n-                    return\n+            Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+                if self.stability().active_features.contains(&feature) {\n+                    return EvalResult::Allow;\n                 }\n \n                 // When we're compiling the compiler itself we may pull in\n@@ -589,19 +613,41 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n-                if *feature == \"rustc_private\" && issue == 27812 {\n+                if feature == \"rustc_private\" && issue == 27812 {\n                     if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-                        return\n+                        return EvalResult::Allow;\n                     }\n                 }\n \n-                let msg = match *reason {\n-                    Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n-                                           feature.as_str(), &r),\n+                EvalResult::Deny { feature, reason, issue }\n+            }\n+            Some(_) => {\n+                // Stable APIs are always ok to call and deprecated APIs are\n+                // handled by the lint emitting logic above.\n+                EvalResult::Allow\n+            }\n+            None => {\n+                EvalResult::Unmarked\n+            }\n+        }\n+    }\n+\n+    /// Checks if an item is stable or error out.\n+    ///\n+    /// If the item defined by `def_id` is unstable and the corresponding `#![feature]` does not\n+    /// exist, emits an error.\n+    ///\n+    /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n+    /// not `None`, a deprecated lint attached to `id` will be emitted.\n+    pub fn check_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) {\n+        match self.eval_stability(def_id, id, span) {\n+            EvalResult::Allow => {}\n+            EvalResult::Deny { feature, reason, issue } => {\n+                let msg = match reason {\n+                    Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n                     None => format!(\"use of unstable library feature '{}'\", &feature)\n                 };\n \n-\n                 let msp: MultiSpan = span.into();\n                 let cm = &self.sess.parse_sess.codemap();\n                 let span_key = msp.primary_span().and_then(|sp: Span|\n@@ -624,12 +670,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n-            Some(_) => {\n-                // Stable APIs are always ok to call and deprecated APIs are\n-                // handled by the lint emitting logic above.\n-            }\n-            None => {\n-                span_bug!(span, \"encountered unmarked API\");\n+            EvalResult::Unmarked => {\n+                span_bug!(span, \"encountered unmarked API: {:?}\", def_id);\n             }\n         }\n     }\n@@ -655,7 +697,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     None => return,\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, item.id, item.span);\n+                self.tcx.check_stability(def_id, Some(item.id), item.span);\n             }\n \n             // For implementations of traits, check the stability of each item\n@@ -668,8 +710,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n                             .find(|item| item.name == impl_item.name).map(|item| item.def_id);\n                         if let Some(def_id) = trait_item_def_id {\n-                            // Pass `DUMMY_NODE_ID` to skip deprecation warnings.\n-                            self.tcx.check_stability(def_id, ast::DUMMY_NODE_ID, impl_item.span);\n+                            // Pass `None` to skip deprecation warnings.\n+                            self.tcx.check_stability(def_id, None, impl_item.span);\n                         }\n                     }\n                 }\n@@ -705,7 +747,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match path.def {\n             Def::Local(..) | Def::Upvar(..) |\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {}\n-            _ => self.tcx.check_stability(path.def.def_id(), id, path.span)\n+            _ => self.tcx.check_stability(path.def.def_id(), Some(id), path.span)\n         }\n         intravisit::walk_path(self, path)\n     }"}, {"sha": "4639f7b2d28cd1b3fb9fdc4feb6cd32fd97899fe", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -273,7 +273,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(TYVAR_BEHIND_RAW_POINTER),\n             reference: \"issue #46906 <https://github.com/rust-lang/rust/issues/46906>\",\n             edition: Some(Edition::Edition2018),\n-        }\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(UNSTABLE_NAME_COLLISION),\n+            reference: \"issue #48919 <https://github.com/rust-lang/rust/issues/48919>\",\n+            edition: None,\n+            // Note: this item represents future incompatibility of all unstable functions in the\n+            //       standard library, and thus should never be removed or changed to an error.\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "385154152b3736b250cd87d4e4ff21d36ef2b840", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -530,7 +530,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let msg = format!(\"associated type `{}` is private\", binding.item_name);\n             tcx.sess.span_err(binding.span, &msg);\n         }\n-        tcx.check_stability(assoc_ty.def_id, ref_id, binding.span);\n+        tcx.check_stability(assoc_ty.def_id, Some(ref_id), binding.span);\n \n         Ok(candidate.map_bound(|trait_ref| {\n             ty::ProjectionPredicate {\n@@ -868,7 +868,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_name);\n             tcx.sess.span_err(span, &msg);\n         }\n-        tcx.check_stability(item.def_id, ref_id, span);\n+        tcx.check_stability(item.def_id, Some(ref_id), span);\n \n         (ty, def)\n     }"}, {"sha": "00c3b2278098453abcd241e95bd8aeb7b9987bc4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -861,7 +861,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n                 self.check_pat_walk(&subpat, field_ty, def_bm, true);\n \n-                self.tcx.check_stability(variant.fields[i].did, pat.id, subpat.span);\n+                self.tcx.check_stability(variant.fields[i].did, Some(pat.id), subpat.span);\n             }\n         } else {\n             let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n@@ -923,7 +923,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     vacant.insert(span);\n                     field_map.get(&field.name)\n                         .map(|f| {\n-                            self.tcx.check_stability(f.did, pat_id, span);\n+                            self.tcx.check_stability(f.did, Some(pat_id), span);\n \n                             self.field_ty(span, f, substs)\n                         })"}, {"sha": "e8b953d40d7a1ae7ee2664acfc9a719f7f155f30", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -16,7 +16,7 @@ use rustc::traits::ObligationCause;\n \n use syntax::ast;\n use syntax::util::parser::PREC_POSTFIX;\n-use syntax_pos::{self, Span};\n+use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::map::NodeItem;\n@@ -140,7 +140,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some((msg, suggestion)) = self.check_ref(expr, checked_ty, expected) {\n             err.span_suggestion(expr.span, msg, suggestion);\n         } else if !self.check_for_cast(&mut err, expr, expr_ty, expected) {\n-            let methods = self.get_conversion_methods(expected, checked_ty);\n+            let methods = self.get_conversion_methods(expr.span, expected, checked_ty);\n             if let Ok(expr_text) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n                     .map(|(receiver, method)| format!(\"{}.{}()\", receiver, method.name))\n@@ -155,9 +155,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    fn get_conversion_methods(&self, expected: Ty<'tcx>, checked_ty: Ty<'tcx>)\n+    fn get_conversion_methods(&self, span: Span, expected: Ty<'tcx>, checked_ty: Ty<'tcx>)\n                               -> Vec<AssociatedItem> {\n-        let mut methods = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+        let mut methods = self.probe_for_return_type(span,\n                                                      probe::Mode::MethodCall,\n                                                      expected,\n                                                      checked_ty,"}, {"sha": "54f41e65d06a0bb08d5fc8e7f4258aeaf418e921", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         .unwrap().insert(import_def_id);\n         }\n \n-        self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n+        self.tcx.check_stability(pick.item.def_id, Some(call_expr.id), span);\n \n         let result = self.confirm_method(span,\n                                          self_expr,\n@@ -371,7 +371,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let def = pick.item.def();\n-        self.tcx.check_stability(def.def_id(), expr_id, span);\n+        self.tcx.check_stability(def.def_id(), Some(expr_id), span);\n \n         Ok(def)\n     }"}, {"sha": "136eb91e2abe6b8752caad09b77b71be24f77cc5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 102, "deletions": 23, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -23,9 +23,10 @@ use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n+use rustc::middle::stability;\n use syntax::ast;\n use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, symbol::Symbol};\n use rustc::hir;\n use rustc::lint;\n use std::mem;\n@@ -38,6 +39,7 @@ pub use self::PickKind::*;\n \n /// Boolean flag used to indicate if this search is for a suggestion\n /// or not.  If true, we can allow ambiguity and so forth.\n+#[derive(Clone, Copy)]\n pub struct IsSuggestion(pub bool);\n \n struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -65,6 +67,8 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n     unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n+\n+    is_suggestion: IsSuggestion,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n@@ -276,8 +280,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // this creates one big transaction so that all type variables etc\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n-            let mut probe_cx =\n-                ProbeContext::new(self, span, mode, method_name, return_type, Rc::new(steps));\n+            let mut probe_cx = ProbeContext::new(\n+                self, span, mode, method_name, return_type, Rc::new(steps), is_suggestion,\n+            );\n \n             probe_cx.assemble_inherent_candidates();\n             match scope {\n@@ -378,7 +383,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n            mode: Mode,\n            method_name: Option<ast::Name>,\n            return_type: Option<Ty<'tcx>>,\n-           steps: Rc<Vec<CandidateStep<'tcx>>>)\n+           steps: Rc<Vec<CandidateStep<'tcx>>>,\n+           is_suggestion: IsSuggestion)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx,\n@@ -394,6 +400,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             allow_similar_names: false,\n             private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n+            is_suggestion,\n         }\n     }\n \n@@ -937,30 +944,57 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"pick_method(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n-\n-        debug!(\"searching inherent candidates\");\n-        if let Some(pick) = self.consider_candidates(self_ty,\n-                                                     &self.inherent_candidates,\n-                                                     &mut possibly_unsatisfied_predicates) {\n-            return Some(pick);\n+        let mut unstable_candidates = Vec::new();\n+\n+        for (kind, candidates) in &[\n+            (\"inherent\", &self.inherent_candidates),\n+            (\"extension\", &self.extension_candidates),\n+        ] {\n+            debug!(\"searching {} candidates\", kind);\n+            let res = self.consider_candidates(\n+                self_ty,\n+                candidates.iter(),\n+                &mut possibly_unsatisfied_predicates,\n+                Some(&mut unstable_candidates),\n+            );\n+            if let Some(pick) = res {\n+                if !self.is_suggestion.0 && !unstable_candidates.is_empty() {\n+                    if let Ok(p) = &pick {\n+                        // Emit a lint if there are unstable candidates alongside the stable ones.\n+                        //\n+                        // We suppress warning if we're picking the method only because it is a\n+                        // suggestion.\n+                        self.emit_unstable_name_collision_hint(p, &unstable_candidates);\n+                    }\n+                }\n+                return Some(pick);\n+            }\n         }\n \n-        debug!(\"searching extension candidates\");\n-        let res = self.consider_candidates(self_ty,\n-                                           &self.extension_candidates,\n-                                           &mut possibly_unsatisfied_predicates);\n-        if let None = res {\n+        debug!(\"searching unstable candidates\");\n+        let res = self.consider_candidates(\n+            self_ty,\n+            unstable_candidates.into_iter().map(|(c, _)| c),\n+            &mut possibly_unsatisfied_predicates,\n+            None,\n+        );\n+        if res.is_none() {\n             self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n         }\n         res\n     }\n \n-    fn consider_candidates(&self,\n-                           self_ty: Ty<'tcx>,\n-                           probes: &[Candidate<'tcx>],\n-                           possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n-                           -> Option<PickResult<'tcx>> {\n-        let mut applicable_candidates: Vec<_> = probes.iter()\n+    fn consider_candidates<'b, ProbesIter>(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        probes: ProbesIter,\n+        possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>,\n+        unstable_candidates: Option<&mut Vec<(&'b Candidate<'tcx>, Symbol)>>,\n+    ) -> Option<PickResult<'tcx>>\n+    where\n+        ProbesIter: Iterator<Item = &'b Candidate<'tcx>> + Clone,\n+    {\n+        let mut applicable_candidates: Vec<_> = probes.clone()\n             .map(|probe| {\n                 (probe, self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n             })\n@@ -975,8 +1009,20 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        if let Some(uc) = unstable_candidates {\n+            applicable_candidates.retain(|&(p, _)| {\n+                if let stability::EvalResult::Deny { feature, .. } =\n+                    self.tcx.eval_stability(p.item.def_id, None, self.span)\n+                {\n+                    uc.push((p, feature));\n+                    return false;\n+                }\n+                true\n+            });\n+        }\n+\n         if applicable_candidates.len() > 1 {\n-            let sources = probes.iter()\n+            let sources = probes\n                 .map(|p| self.candidate_source(p, self_ty))\n                 .collect();\n             return Some(Err(MethodError::Ambiguity(sources)));\n@@ -991,6 +1037,39 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    fn emit_unstable_name_collision_hint(\n+        &self,\n+        stable_pick: &Pick,\n+        unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n+    ) {\n+        let mut diag = self.tcx.struct_span_lint_node(\n+            lint::builtin::UNSTABLE_NAME_COLLISION,\n+            self.fcx.body_id,\n+            self.span,\n+            \"a method with this name may be added to the standard library in the future\",\n+        );\n+\n+        // FIXME: This should be a `span_suggestion` instead of `help`. However `self.span` only\n+        // highlights the method name, so we can't use it. Also consider reusing the code from\n+        // `report_method_error()`.\n+        diag.help(&format!(\n+            \"call with fully qualified syntax `{}(...)` to keep using the current method\",\n+            self.tcx.item_path_str(stable_pick.item.def_id),\n+        ));\n+\n+        if ::rustc::session::config::nightly_options::is_nightly_build() {\n+            for (candidate, feature) in unstable_candidates {\n+                diag.note(&format!(\n+                    \"add #![feature({})] to the crate attributes to enable `{}`\",\n+                    feature,\n+                    self.tcx.item_path_str(candidate.item.def_id),\n+                ));\n+            }\n+        }\n+\n+        diag.emit();\n+    }\n+\n     fn select_trait_candidate(&self, trait_ref: ty::TraitRef<'tcx>)\n                               -> traits::SelectionResult<'tcx, traits::Selection<'tcx>>\n     {\n@@ -1190,7 +1269,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let steps = self.steps.clone();\n         self.probe(|_| {\n             let mut pcx = ProbeContext::new(self.fcx, self.span, self.mode, self.method_name,\n-                                            self.return_type, steps);\n+                                            self.return_type, steps, IsSuggestion(true));\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n             pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;"}, {"sha": "9afa2d42fa44d740dd11de43c73dd5ad7934438c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -3087,7 +3087,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize();\n \n-                            self.tcx.check_stability(field.did, expr.id, expr.span);\n+                            self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n \n                             return field_ty;\n                         }\n@@ -3228,7 +3228,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            self.tcx.check_stability(field.did, expr.id, expr.span);\n+                            self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n                             Some(field_ty)\n                         } else {\n                             private_candidate = Some((base_def.did, field_ty));\n@@ -3373,7 +3373,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // struct-like enums (yet...), but it's definitely not\n                 // a bug to have construct one.\n                 if adt_kind != ty::AdtKind::Enum {\n-                    tcx.check_stability(v_field.did, expr_id, field.span);\n+                    tcx.check_stability(v_field.did, Some(expr_id), field.span);\n                 }\n \n                 self.field_ty(field.span, v_field, substs)"}, {"sha": "b73346e6332ca12402b94e281b452383001919fd", "filename": "src/test/ui/auxiliary/inference_unstable_iterator.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fauxiliary%2Finference_unstable_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fauxiliary%2Finference_unstable_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Finference_unstable_iterator.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"ipu_iterator\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"ipu_iterator\", since = \"1.0.0\")]\n+pub trait IpuIterator {\n+    #[unstable(feature = \"ipu_flatten\", issue = \"99999\")]\n+    fn ipu_flatten(&self) -> u32 {\n+        0\n+    }\n+}\n+\n+#[stable(feature = \"ipu_iterator\", since = \"1.0.0\")]\n+impl IpuIterator for char {}"}, {"sha": "2ad264ee3d82fbc786d89bfc3d2f2f41b77f132b", "filename": "src/test/ui/auxiliary/inference_unstable_itertools.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fauxiliary%2Finference_unstable_itertools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fauxiliary%2Finference_unstable_itertools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Finference_unstable_itertools.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait IpuItertools {\n+    fn ipu_flatten(&self) -> u32 {\n+        1\n+    }\n+}\n+\n+impl IpuItertools for char {}"}, {"sha": "f5e75f40fca087ed0bd22779aad8a9a0e7e06d7d", "filename": "src/test/ui/did_you_mean/recursion_limit_deref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//~^^^^^^^^^^ ERROR reached the recursion limit\n-\n // Test that the recursion limit can be changed and that the compiler\n // suggests a fix. In this case, we have a long chain of Deref impls\n // which will cause an overflow during the autoderef loop."}, {"sha": "20a94f7aac196121b9a92deee1db7354b1ac7435", "filename": "src/test/ui/did_you_mean/recursion_limit_deref.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -1,25 +1,21 @@\n error[E0055]: reached the recursion limit while auto-dereferencing I\n-  --> $DIR/recursion_limit_deref.rs:62:22\n+  --> $DIR/recursion_limit_deref.rs:60:22\n    |\n LL |     let x: &Bottom = &t; //~ ERROR mismatched types\n    |                      ^^ deref recursion limit reached\n    |\n    = help: consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n \n-error[E0055]: reached the recursion limit while auto-dereferencing I\n-   |\n-   = help: consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-\n error[E0308]: mismatched types\n-  --> $DIR/recursion_limit_deref.rs:62:22\n+  --> $DIR/recursion_limit_deref.rs:60:22\n    |\n LL |     let x: &Bottom = &t; //~ ERROR mismatched types\n    |                      ^^ expected struct `Bottom`, found struct `Top`\n    |\n    = note: expected type `&Bottom`\n               found type `&Top`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors occurred: E0055, E0308.\n For more information about an error, try `rustc --explain E0055`."}, {"sha": "816c443a06c21c6c38fb9600fde1173b0c082636", "filename": "src/test/ui/inference_unstable.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference_unstable.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensures #[unstable] functions without opting in the corresponding #![feature]\n+// will not break inference.\n+\n+// aux-build:inference_unstable_iterator.rs\n+// aux-build:inference_unstable_itertools.rs\n+// run-pass\n+\n+extern crate inference_unstable_iterator;\n+extern crate inference_unstable_itertools;\n+\n+#[allow(unused_imports)]\n+use inference_unstable_iterator::IpuIterator;\n+use inference_unstable_itertools::IpuItertools;\n+\n+fn main() {\n+    assert_eq!('x'.ipu_flatten(), 1);\n+    //~^ WARN a method with this name may be added to the standard library in the future\n+    //~^^ WARN once this method is added to the standard library, there will be ambiguity here\n+}"}, {"sha": "9c614d659d36f79319f9ec78b011ddb4bc33fe9c", "filename": "src/test/ui/inference_unstable.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference_unstable.stderr?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,12 @@\n+warning: a method with this name may be added to the standard library in the future\n+  --> $DIR/inference_unstable.rs:26:20\n+   |\n+LL |     assert_eq!('x'.ipu_flatten(), 1);\n+   |                    ^^^^^^^^^^^\n+   |\n+   = note: #[warn(unstable_name_collision)] on by default\n+   = warning: once this method is added to the standard library, there will be ambiguity here, which will cause a hard error!\n+   = note: for more information, see issue #48919 <https://github.com/rust-lang/rust/issues/48919>\n+   = help: call with fully qualified syntax `inference_unstable_itertools::IpuItertools::ipu_flatten(...)` to keep using the current method\n+   = note: add #![feature(ipu_flatten)] to the crate attributes to enable `inference_unstable_iterator::IpuIterator::ipu_flatten`\n+"}, {"sha": "f5c49bedc7117a24653afb596f5b3f7642d5bc7d", "filename": "src/test/ui/inference_unstable_featured.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_featured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_featured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference_unstable_featured.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// There should be E0034 \"multiple applicable items in scope\" if we opt-in for\n+// the feature.\n+\n+// aux-build:inference_unstable_iterator.rs\n+// aux-build:inference_unstable_itertools.rs\n+\n+#![feature(ipu_flatten)]\n+\n+extern crate inference_unstable_iterator;\n+extern crate inference_unstable_itertools;\n+\n+use inference_unstable_iterator::IpuIterator;\n+use inference_unstable_itertools::IpuItertools;\n+\n+fn main() {\n+    assert_eq!('x'.ipu_flatten(), 0);   //~ ERROR E0034\n+}"}, {"sha": "cb5f3623291b524c843fea0719f958dfae6d203c", "filename": "src/test/ui/inference_unstable_featured.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_featured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_featured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference_unstable_featured.stderr?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,12 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/inference_unstable_featured.rs:26:20\n+   |\n+LL |     assert_eq!('x'.ipu_flatten(), 0);   //~ ERROR E0034\n+   |                    ^^^^^^^^^^^ multiple `ipu_flatten` found\n+   |\n+   = note: candidate #1 is defined in an impl of the trait `inference_unstable_iterator::IpuIterator` for the type `char`\n+   = note: candidate #2 is defined in an impl of the trait `inference_unstable_itertools::IpuItertools` for the type `char`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}, {"sha": "82ce4034ce269297f4b61ddaf871180823a3ec79", "filename": "src/test/ui/inference_unstable_forced.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_forced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_forced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference_unstable_forced.rs?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// If the unstable API is the only possible solution,\n+// still emit E0658 \"use of unstable library feature\".\n+\n+// aux-build:inference_unstable_iterator.rs\n+\n+extern crate inference_unstable_iterator;\n+\n+use inference_unstable_iterator::IpuIterator;\n+\n+fn main() {\n+    assert_eq!('x'.ipu_flatten(), 0);   //~ ERROR E0658\n+}"}, {"sha": "00eb81cd9a2398d6f3bcc5c1bebfcaa83115900b", "filename": "src/test/ui/inference_unstable_forced.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_forced.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee/src%2Ftest%2Fui%2Finference_unstable_forced.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference_unstable_forced.stderr?ref=a0b0f5fba5d7bf18b24d1fa0e454a4fe871fecee", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: use of unstable library feature 'ipu_flatten' (see issue #99999)\n+  --> $DIR/inference_unstable_forced.rs:21:20\n+   |\n+LL |     assert_eq!('x'.ipu_flatten(), 0);   //~ ERROR E0658\n+   |                    ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(ipu_flatten)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}]}