{"sha": "f29b4fbd742b8180edb5e06cad0977b08881541b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyOWI0ZmJkNzQyYjgxODBlZGI1ZTA2Y2FkMDk3N2IwODg4MTU0MWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-31T19:20:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-31T19:20:14Z"}, "message": "Auto merge of #56696 - jonas-schievink:weak-counts, r=alexcrichton\n\nImplement Weak::{strong_count, weak_count}\n\nThe counters are also useful on `Weak`, not just on strong references (`Rc` or `Arc`).\n\nIn situations where there are still strong references around, you can also get these counts by temporarily upgrading and adjusting the values accordingly. Using the methods introduced here is simpler to do, less error-prone (since you can't forget to adjust the counts), can also be used when no strong references are around anymore, and might be more efficient due to not having to temporarily create an `Rc`.\n\nThis is mainly useful in assertions or tests of complex data structures. Data structures might have internal invariants that make them the sole owner of a `Weak` pointer, and an assertion on the weak count could be used to ensure that this indeed happens as expected. Due to the presence of `Weak::upgrade`, the `strong_count` becomes less useful, but it still seems worthwhile to mirror the API of `Rc`.\n\nTODO:\n* [X] Tracking issue - https://github.com/rust-lang/rust/issues/57977\n\nCloses https://github.com/rust-lang/rust/issues/50158", "tree": {"sha": "5ff447b13dde63ff1d6684e67c3e521cb74cde31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ff447b13dde63ff1d6684e67c3e521cb74cde31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f29b4fbd742b8180edb5e06cad0977b08881541b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f29b4fbd742b8180edb5e06cad0977b08881541b", "html_url": "https://github.com/rust-lang/rust/commit/f29b4fbd742b8180edb5e06cad0977b08881541b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f29b4fbd742b8180edb5e06cad0977b08881541b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63505b84a6fb0fdb6a2f2a2a884556aeca2326d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/63505b84a6fb0fdb6a2f2a2a884556aeca2326d4", "html_url": "https://github.com/rust-lang/rust/commit/63505b84a6fb0fdb6a2f2a2a884556aeca2326d4"}, {"sha": "0d314f08af086afd7a67131a621f861b2633d6d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d314f08af086afd7a67131a621f861b2633d6d3", "html_url": "https://github.com/rust-lang/rust/commit/0d314f08af086afd7a67131a621f861b2633d6d3"}], "stats": {"total": 143, "additions": 142, "deletions": 1}, "files": [{"sha": "c1f428658bd05f6e313e0d5527b497ea375fee2a", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f29b4fbd742b8180edb5e06cad0977b08881541b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29b4fbd742b8180edb5e06cad0977b08881541b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f29b4fbd742b8180edb5e06cad0977b08881541b", "patch": "@@ -1305,6 +1305,38 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n+    /// Gets the number of strong (`Rc`) pointers pointing to this value.\n+    ///\n+    /// If `self` was created using [`Weak::new`], this will return 0.\n+    ///\n+    /// [`Weak::new`]: #method.new\n+    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    pub fn strong_count(&self) -> usize {\n+        if let Some(inner) = self.inner() {\n+            inner.strong()\n+        } else {\n+            0\n+        }\n+    }\n+\n+    /// Gets the number of `Weak` pointers pointing to this value.\n+    ///\n+    /// If `self` was created using [`Weak::new`], this will return `None`. If\n+    /// not, the returned value is at least 1, since `self` still points to the\n+    /// value.\n+    ///\n+    /// [`Weak::new`]: #method.new\n+    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    pub fn weak_count(&self) -> Option<usize> {\n+        self.inner().map(|inner| {\n+            if inner.strong() > 0 {\n+                inner.weak() - 1  // subtract the implicit weak ptr\n+            } else {\n+                inner.weak()\n+            }\n+        })\n+    }\n+\n     /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n     /// i.e., this `Weak` was created by `Weak::new`\n     #[inline]\n@@ -1643,6 +1675,33 @@ mod tests {\n         drop(c);\n     }\n \n+    #[test]\n+    fn weak_counts() {\n+        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+        let a = Rc::new(0);\n+        let w = Rc::downgrade(&a);\n+        assert_eq!(Weak::strong_count(&w), 1);\n+        assert_eq!(Weak::weak_count(&w), Some(1));\n+        let w2 = w.clone();\n+        assert_eq!(Weak::strong_count(&w), 1);\n+        assert_eq!(Weak::weak_count(&w), Some(2));\n+        assert_eq!(Weak::strong_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(2));\n+        drop(w);\n+        assert_eq!(Weak::strong_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n+        let a2 = a.clone();\n+        assert_eq!(Weak::strong_count(&w2), 2);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n+        drop(a2);\n+        drop(a);\n+        assert_eq!(Weak::strong_count(&w2), 0);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n+        drop(w2);\n+    }\n+\n     #[test]\n     fn try_unwrap() {\n         let x = Rc::new(3);"}, {"sha": "f6cafd50dc8c9118f039f2a62f8f396159a1c886", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f29b4fbd742b8180edb5e06cad0977b08881541b/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29b4fbd742b8180edb5e06cad0977b08881541b/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=f29b4fbd742b8180edb5e06cad0977b08881541b", "patch": "@@ -11,7 +11,7 @@ use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n-use core::cmp::Ordering;\n+use core::cmp::{self, Ordering};\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val};\n use core::ops::{Deref, Receiver};\n@@ -1138,6 +1138,61 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n+    /// Gets the number of strong (`Arc`) pointers pointing to this value.\n+    ///\n+    /// If `self` was created using [`Weak::new`], this will return 0.\n+    ///\n+    /// [`Weak::new`]: #method.new\n+    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    pub fn strong_count(&self) -> usize {\n+        if let Some(inner) = self.inner() {\n+            inner.strong.load(SeqCst)\n+        } else {\n+            0\n+        }\n+    }\n+\n+    /// Gets an approximation of the number of `Weak` pointers pointing to this\n+    /// value.\n+    ///\n+    /// If `self` was created using [`Weak::new`], this will return 0. If not,\n+    /// the returned value is at least 1, since `self` still points to the\n+    /// value.\n+    ///\n+    /// # Accuracy\n+    ///\n+    /// Due to implementation details, the returned value can be off by 1 in\n+    /// either direction when other threads are manipulating any `Arc`s or\n+    /// `Weak`s pointing to the same value.\n+    ///\n+    /// [`Weak::new`]: #method.new\n+    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    pub fn weak_count(&self) -> Option<usize> {\n+        // Due to the implicit weak pointer added when any strong pointers are\n+        // around, we cannot implement `weak_count` correctly since it\n+        // necessarily requires accessing the strong count and weak count in an\n+        // unsynchronized fashion. So this version is a bit racy.\n+        self.inner().map(|inner| {\n+            let strong = inner.strong.load(SeqCst);\n+            let weak = inner.weak.load(SeqCst);\n+            if strong == 0 {\n+                // If the last `Arc` has *just* been dropped, it might not yet\n+                // have removed the implicit weak count, so the value we get\n+                // here might be 1 too high.\n+                weak\n+            } else {\n+                // As long as there's still at least 1 `Arc` around, subtract\n+                // the implicit weak pointer.\n+                // Note that the last `Arc` might get dropped between the 2\n+                // loads we do above, removing the implicit weak pointer. This\n+                // means that the value might be 1 too low here. In order to not\n+                // return 0 here (which would happen if we're the only weak\n+                // pointer), we guard against that specifically.\n+                cmp::max(1, weak - 1)\n+            }\n+        })\n+    }\n+\n     /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n     /// i.e., this `Weak` was created by `Weak::new`\n     #[inline]\n@@ -1657,6 +1712,33 @@ mod tests {\n         assert!(Arc::get_mut(&mut x).is_none());\n     }\n \n+    #[test]\n+    fn weak_counts() {\n+        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+        let a = Arc::new(0);\n+        let w = Arc::downgrade(&a);\n+        assert_eq!(Weak::strong_count(&w), 1);\n+        assert_eq!(Weak::weak_count(&w), Some(1));\n+        let w2 = w.clone();\n+        assert_eq!(Weak::strong_count(&w), 1);\n+        assert_eq!(Weak::weak_count(&w), Some(2));\n+        assert_eq!(Weak::strong_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(2));\n+        drop(w);\n+        assert_eq!(Weak::strong_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n+        let a2 = a.clone();\n+        assert_eq!(Weak::strong_count(&w2), 2);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n+        drop(a2);\n+        drop(a);\n+        assert_eq!(Weak::strong_count(&w2), 0);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n+        drop(w2);\n+    }\n+\n     #[test]\n     fn try_unwrap() {\n         let x = Arc::new(3);"}]}