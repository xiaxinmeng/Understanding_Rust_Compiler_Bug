{"sha": "b7d680b57d941bbcb8e11363f6278852d59eaea9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZDY4MGI1N2Q5NDFiYmNiOGUxMTM2M2Y2Mjc4ODUyZDU5ZWFlYTk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-19T20:39:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-19T20:39:57Z"}, "message": "Remove mention of effect system from manual.", "tree": {"sha": "b78eeb7d855d14f356285c65b0fedfe04518efd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b78eeb7d855d14f356285c65b0fedfe04518efd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7d680b57d941bbcb8e11363f6278852d59eaea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7d680b57d941bbcb8e11363f6278852d59eaea9", "html_url": "https://github.com/rust-lang/rust/commit/b7d680b57d941bbcb8e11363f6278852d59eaea9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7d680b57d941bbcb8e11363f6278852d59eaea9/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "html_url": "https://github.com/rust-lang/rust/commit/d2bd07dcb02783063375b6c8532fceaf9fa9d50f"}], "stats": {"total": 36, "additions": 11, "deletions": 25}, "files": [{"sha": "8f0e59bff7f06d411d66db57a1e20c6090c22b58", "filename": "doc/rust.texi", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b7d680b57d941bbcb8e11363f6278852d59eaea9/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/b7d680b57d941bbcb8e11363f6278852d59eaea9/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=b7d680b57d941bbcb8e11363f6278852d59eaea9", "patch": "@@ -321,11 +321,9 @@ coupled to the loop that invoked it.\n @item Direct interface to C code\n \n Rust can load and call many C library functions simply by declaring\n-them. Calling a C function statically marks a function as ``unsafe'', unless\n-the task calling the unsafe function is further isolated within an external\n-``heavyweight'' operating-system subprocess. Every ``unsafe'' function or\n-module in a Rust compilation unit must be explicitly authorized in the crate\n-file.\n+them. Calling a C function is an ``unsafe'' action, and can only be taken\n+within a block marked with the @code{unsafe} keyword. Every unsafe block\n+in a Rust compilation unit must be explicitly authorized in the crate file.\n \n @sp 1\n @item Structural algebraic data types\n@@ -684,7 +682,6 @@ The keywords are:\n @tab @code{const}\n @tab @code{thread}\n @item @code{auth}\n-@tab @code{impure}\n @tab @code{unsafe}\n @tab @code{self}\n @item @code{bind}\n@@ -1490,7 +1487,7 @@ operating-system processes.\n @cindex Send expression\n @cindex Receive expression\n \n-With the exception of @emph{unsafe} constructs, Rust tasks are isolated from\n+With the exception of @emph{unsafe} blocks, Rust tasks are isolated from\n interfering with one another's memory directly. Instead of manipulating shared\n storage, Rust tasks communicate with one another using a typed, asynchronous,\n simplex message-passing system.\n@@ -1788,7 +1785,6 @@ fn main() @{\n @c * Ref.Item.Fn::            Items defining functions.\n @cindex Functions\n @cindex Slots, function input and output\n-@cindex Effect of a function\n @cindex Predicate\n \n \n@@ -1809,10 +1805,6 @@ expression. If a control path lacks a @code{ret} expression in source code, an\n implicit @code{ret} expression is appended to the end of the control path\n during compilation, returning the implicit @code{()} value.\n \n-A function may have an @emph{effect}, which may be either @code{impure} or\n-@code{unsafe}. If no effect is specified, the function is said to be\n-@dfn{pure}.\n-\n Any pure boolean function is also called a @emph{predicate}, and may be used\n as part of the static typestate system. @xref{Ref.Typestate.Constr}.\n \n@@ -2307,8 +2299,8 @@ by named reference to a @emph{tag item} declaration. @xref{Ref.Item.Tag}.\n \n The function type-constructor @code{fn} forms new function types. A function\n type consists of a sequence of input slots, an optional set of input\n-constraints (@pxref{Ref.Typestate.Constr}), an output slot, and an\n-@emph{effect}. @xref{Ref.Item.Fn}.\n+constraints (@pxref{Ref.Typestate.Constr}) and an output\n+slot. @xref{Ref.Item.Fn}.\n \n An example of a @code{fn} type:\n @example\n@@ -2329,7 +2321,7 @@ x = bo(5,7);\n \n The iterator type-constructor @code{iter} forms new iterator types. An\n iterator type consists a sequence of input slots, an optional set of input\n-constraints, an output slot, and an @emph{effect}. @xref{Ref.Item.Iter}.\n+constraints and an output slot. @xref{Ref.Item.Iter}.\n \n An example of an @code{iter} type:\n @example\n@@ -2449,9 +2441,7 @@ that a variety of particular objects may conform to, by supporting a superset\n of the methods.\n \n An object type that can contain fields of a given layer must be declared as\n-residing in that layer (or lower), like any other type. And similarly a method\n-with a given effect must be declared as having that effect (or lower) in the\n-object type, like any other function.\n+residing in that layer (or lower), like any other type.\n \n An example of an object type with two separate object items supporting it, and\n a client function using both items via the object type:\n@@ -2460,17 +2450,17 @@ a client function using both items via the object type:\n \n state type taker =\n     state obj @{\n-        impure fn take(int);\n+        fn take(int);\n     @};\n \n state obj adder(mutable int x) @{\n-    impure fn take(int y) @{\n+    fn take(int y) @{\n         x += y;\n     @}\n @}\n \n obj sender(chan[int] c) @{\n-    impure fn take(int z) @{\n+    fn take(int z) @{\n         c <| z;\n     @}\n @}\n@@ -3191,10 +3181,6 @@ by the runtime or emitted to a system console. Log expressions are enabled or\n disabled dynamically at run-time on a per-task and per-item\n basis. @xref{Ref.Run.Log}.\n \n-Executing a @code{log} expression is not considered an impure effect in the\n-effect system. In other words, a pure function remains pure even if it\n-contains a log expression.\n-\n @example\n @end example\n "}]}