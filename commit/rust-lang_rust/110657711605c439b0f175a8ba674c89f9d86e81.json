{"sha": "110657711605c439b0f175a8ba674c89f9d86e81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMDY1NzcxMTYwNWM0MzliMGYxNzVhOGJhNjc0Yzg5ZjlkODZlODE=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-09-19T14:28:49Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-09-20T10:54:31Z"}, "message": "fix intra-links for trait impls", "tree": {"sha": "5a7da052e95f6f0ad913320a601a67bf041a77a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7da052e95f6f0ad913320a601a67bf041a77a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/110657711605c439b0f175a8ba674c89f9d86e81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/110657711605c439b0f175a8ba674c89f9d86e81", "html_url": "https://github.com/rust-lang/rust/commit/110657711605c439b0f175a8ba674c89f9d86e81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/110657711605c439b0f175a8ba674c89f9d86e81/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755c02dbd4101de94229d8e726c8a0cbcb247cbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/755c02dbd4101de94229d8e726c8a0cbcb247cbb", "html_url": "https://github.com/rust-lang/rust/commit/755c02dbd4101de94229d8e726c8a0cbcb247cbb"}], "stats": {"total": 125, "additions": 104, "deletions": 21}, "files": [{"sha": "6e35755d9a4ec228d93024ef5f4c56fe123309d5", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/110657711605c439b0f175a8ba674c89f9d86e81/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110657711605c439b0f175a8ba674c89f9d86e81/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=110657711605c439b0f175a8ba674c89f9d86e81", "patch": "@@ -709,17 +709,22 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the DefId of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n-        let id = match self.walk_parent_nodes(id, |node| match *node {\n+        self.local_def_id(self.get_module_parent_node(id))\n+    }\n+\n+    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// module parent is in this map.\n+    pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n+        match self.walk_parent_nodes(id, |node| match *node {\n             Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n-        };\n-        self.local_def_id(id)\n+        }\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block."}, {"sha": "e8f1733e532de7125db292e8c224e571d8960812", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/110657711605c439b0f175a8ba674c89f9d86e81/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110657711605c439b0f175a8ba674c89f9d86e81/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=110657711605c439b0f175a8ba674c89f9d86e81", "patch": "@@ -26,7 +26,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, Ident, NodeId};\n use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n@@ -163,6 +163,16 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocContext<'a, 'tcx, 'rcx, 'cstore> {\n         def_id.clone()\n     }\n \n+    /// Like the function of the same name on the HIR map, but skips calling it on fake DefIds.\n+    /// (This avoids a slice-index-out-of-bounds panic.)\n+    pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n+        if self.all_fake_def_ids.borrow().contains(&def_id) {\n+            None\n+        } else {\n+            self.tcx.hir.as_local_node_id(def_id)\n+        }\n+    }\n+\n     pub fn get_real_ty<F>(&self,\n                           def_id: DefId,\n                           def_ctor: &F,"}, {"sha": "7b2eb2259d6791bac9976858dd2b34d86f1c38ff", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/110657711605c439b0f175a8ba674c89f9d86e81/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110657711605c439b0f175a8ba674c89f9d86e81/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=110657711605c439b0f175a8ba674c89f9d86e81", "patch": "@@ -69,16 +69,21 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n     /// Resolve a given string as a path, along with whether or not it is\n     /// in the value namespace. Also returns an optional URL fragment in the case\n     /// of variants and methods\n-    fn resolve(&self, path_str: &str, is_val: bool, current_item: &Option<String>)\n+    fn resolve(&self,\n+               path_str: &str,\n+               is_val: bool,\n+               current_item: &Option<String>,\n+               parent_id: Option<NodeId>)\n         -> Result<(Def, Option<String>), ()>\n     {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative\n         // path\n-        if let Some(id) = self.mod_ids.last() {\n+        if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n+            // FIXME: `with_scope` requires the NodeId of a module\n             let result = cx.resolver.borrow_mut()\n-                                    .with_scope(*id,\n+                                    .with_scope(id,\n                 |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP,\n                                                     &path_str, is_val)\n@@ -129,8 +134,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n                 }\n             }\n \n+            // FIXME: `with_scope` requires the NodeId of a module\n             let ty = cx.resolver.borrow_mut()\n-                                .with_scope(*id,\n+                                .with_scope(id,\n                 |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             })?;\n@@ -218,6 +224,20 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n             None\n         };\n \n+        // FIXME: get the resolver to work with non-local resolve scopes\n+        let parent_node = self.cx.as_local_node_id(item.def_id).and_then(|node_id| {\n+            // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n+            // current resolve() implementation\n+            match self.cx.tcx.hir.get_module_parent_node(node_id) {\n+                id if id != node_id => Some(id),\n+                _ => None,\n+            }\n+        });\n+\n+        if parent_node.is_some() {\n+            debug!(\"got parent node for {} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n         let current_item = match item.inner {\n             ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n@@ -227,10 +247,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                         None\n                     }\n                 } else {\n-                    match self.mod_ids.last() {\n-                        Some(parent) if *parent != NodeId::new(0) => {\n+                    match parent_node.or(self.mod_ids.last().cloned()) {\n+                        Some(parent) if parent != NodeId::new(0) => {\n                             //FIXME: can we pull the parent module's name from elsewhere?\n-                            Some(self.cx.tcx.hir.name(*parent).to_string())\n+                            Some(self.cx.tcx.hir.name(parent).to_string())\n                         }\n                         _ => None,\n                     }\n@@ -294,7 +314,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n \n                 match kind {\n                     PathKind::Value => {\n-                        if let Ok(def) = self.resolve(path_str, true, &current_item) {\n+                        if let Ok(def) = self.resolve(path_str, true, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n@@ -305,7 +325,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                         }\n                     }\n                     PathKind::Type => {\n-                        if let Ok(def) = self.resolve(path_str, false, &current_item) {\n+                        if let Ok(def) = self.resolve(path_str, false, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n@@ -316,16 +336,18 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                     PathKind::Unknown => {\n                         // try everything!\n                         if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                            if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                            if let Ok(type_def) =\n+                                self.resolve(path_str, false, &current_item, parent_node)\n+                            {\n                                 let (type_kind, article, type_disambig)\n                                     = type_ns_kind(type_def.0, path_str);\n                                 ambiguity_error(cx, &item.attrs, path_str,\n                                                 article, type_kind, &type_disambig,\n                                                 \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                 continue;\n-                            } else if let Ok(value_def) = self.resolve(path_str,\n-                                                                       true,\n-                                                                       &current_item) {\n+                            } else if let Ok(value_def) =\n+                                self.resolve(path_str, true, &current_item, parent_node)\n+                            {\n                                 let (value_kind, value_disambig)\n                                     = value_ns_kind(value_def.0, path_str)\n                                         .expect(\"struct and mod cases should have been \\\n@@ -335,12 +357,16 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                                                 \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                             }\n                             (macro_def, None)\n-                        } else if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                        } else if let Ok(type_def) =\n+                            self.resolve(path_str, false, &current_item, parent_node)\n+                        {\n                             // It is imperative we search for not-a-value first\n                             // Otherwise we will find struct ctors for when we are looking\n                             // for structs, and the link won't work.\n                             // if there is something in both namespaces\n-                            if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                            if let Ok(value_def) =\n+                                self.resolve(path_str, true, &current_item, parent_node)\n+                            {\n                                 let kind = value_ns_kind(value_def.0, path_str);\n                                 if let Some((value_kind, value_disambig)) = kind {\n                                     let (type_kind, article, type_disambig)\n@@ -352,7 +378,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                                 }\n                             }\n                             type_def\n-                        } else if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                        } else if let Ok(value_def) =\n+                            self.resolve(path_str, true, &current_item, parent_node)\n+                        {\n                             value_def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);"}, {"sha": "8c01941234ec058311967b92b012620303c52c39", "filename": "src/test/rustdoc/intra-link-in-bodies.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/110657711605c439b0f175a8ba674c89f9d86e81/src%2Ftest%2Frustdoc%2Fintra-link-in-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110657711605c439b0f175a8ba674c89f9d86e81/src%2Ftest%2Frustdoc%2Fintra-link-in-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-in-bodies.rs?ref=110657711605c439b0f175a8ba674c89f9d86e81", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// we need to make sure that intra-doc links on trait impls get resolved in the right scope\n+\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub mod inner {\n+    pub struct SomethingOutOfScope;\n+}\n+\n+pub mod other {\n+    use inner::SomethingOutOfScope;\n+    use SomeTrait;\n+\n+    pub struct OtherStruct;\n+\n+    /// Let's link to [SomethingOutOfScope] while we're at it.\n+    impl SomeTrait for OtherStruct {}\n+}\n+\n+pub trait SomeTrait {}\n+\n+pub struct SomeStruct;\n+\n+fn __implementation_details() {\n+    use inner::SomethingOutOfScope;\n+\n+    // FIXME: intra-links resolve in their nearest module scope, not their actual scope in cases\n+    // like this\n+    // Let's link to [SomethingOutOfScope] while we're at it.\n+    impl SomeTrait for SomeStruct {}\n+}"}]}