{"sha": "b814b639836aa76b5c6deaa585367150bb2debf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MTRiNjM5ODM2YWE3NmI1YzZkZWFhNTg1MzY3MTUwYmIyZGViZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-22T16:04:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-22T16:04:36Z"}, "message": "Auto merge of #81271 - m-ou-se:rollup-xv7gq3w, r=m-ou-se\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #80573 (Deny rustc::internal lints for rustdoc and clippy)\n - #81173 (Expand docs on Iterator::intersperse)\n - #81194 (Stabilize std::panic::panic_any.)\n - #81202 (Don't prefix 0x for each segments in `dbg!(Ipv6)`)\n - #81225 (Make 'docs' nullable in rustdoc-json output)\n - #81227 (Remove doctree::StructType)\n - #81233 (Document why not use concat! in dbg! macro)\n - #81236 (Gracefully handle loop labels missing leading `'` in different positions)\n - #81241 (Turn alloc's force_expr macro into a regular macro_rules.)\n - #81242 (Enforce statically that `MIN_NON_ZERO_CAP` is calculated at compile time)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ff77c2ba8ee58410a01d8606ef83071711e78195", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff77c2ba8ee58410a01d8606ef83071711e78195"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b814b639836aa76b5c6deaa585367150bb2debf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b814b639836aa76b5c6deaa585367150bb2debf4", "html_url": "https://github.com/rust-lang/rust/commit/b814b639836aa76b5c6deaa585367150bb2debf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b814b639836aa76b5c6deaa585367150bb2debf4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2de221b0063261140a336c448bf1421170c9a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2de221b0063261140a336c448bf1421170c9a74", "html_url": "https://github.com/rust-lang/rust/commit/f2de221b0063261140a336c448bf1421170c9a74"}, {"sha": "9c2a5776b205aebec2685966fc24f59dde7fe76a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c2a5776b205aebec2685966fc24f59dde7fe76a", "html_url": "https://github.com/rust-lang/rust/commit/9c2a5776b205aebec2685966fc24f59dde7fe76a"}], "stats": {"total": 947, "additions": 681, "deletions": 266}, "files": [{"sha": "31360158e2b4e3afc5ccda8ee96f67cd5e8fc540", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -10,9 +10,9 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_session::parse::feature_err;\n-use rustc_span::hygiene::ForLoopLoc;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n use std::fmt::Write;\n@@ -102,6 +102,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         this.lower_block(body, false),\n                         opt_label,\n                         hir::LoopSource::Loop,\n+                        DUMMY_SP,\n                     )\n                 }),\n                 ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n@@ -453,7 +454,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             self.expr_match(span, scrutinee, arena_vec![self; then_arm, else_arm], desugar);\n \n         // `[opt_ident]: loop { ... }`\n-        hir::ExprKind::Loop(self.block_expr(self.arena.alloc(match_expr)), opt_label, source)\n+        hir::ExprKind::Loop(\n+            self.block_expr(self.arena.alloc(match_expr)),\n+            opt_label,\n+            source,\n+            span.with_hi(cond.span.hi()),\n+        )\n     }\n \n     /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n@@ -748,7 +754,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // loop { .. }\n         let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: loop_hir_id,\n-            kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop),\n+            kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop, span),\n             span,\n             attrs: ThinVec::new(),\n         });\n@@ -1709,7 +1715,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         );\n \n         // `[opt_ident]: loop { ... }`\n-        let kind = hir::ExprKind::Loop(loop_block, opt_label, hir::LoopSource::ForLoop);\n+        let kind = hir::ExprKind::Loop(\n+            loop_block,\n+            opt_label,\n+            hir::LoopSource::ForLoop,\n+            e.span.with_hi(orig_head_span.hi()),\n+        );\n         let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n             kind,"}, {"sha": "35170fa7c1d0250cd27e7430b13a0b61c3fcf927", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1617,7 +1617,9 @@ pub enum ExprKind<'hir> {\n     /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// I.e., `'label: loop { <block> }`.\n-    Loop(&'hir Block<'hir>, Option<Label>, LoopSource),\n+    ///\n+    /// The `Span` is the loop header (`for x in y`/`while let pat = expr`).\n+    Loop(&'hir Block<'hir>, Option<Label>, LoopSource, Span),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),"}, {"sha": "6c1bee2335a00552c8a260ebe887546f5ca72243", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1151,7 +1151,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             visitor.visit_expr(then);\n             walk_list!(visitor, visit_expr, else_opt);\n         }\n-        ExprKind::Loop(ref block, ref opt_label, _) => {\n+        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }"}, {"sha": "f1c2a6b7e6e85af5f75e70c3e8089d836f66ffbe", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1396,7 +1396,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e));\n             }\n-            hir::ExprKind::Loop(ref blk, opt_label, _) => {\n+            hir::ExprKind::Loop(ref blk, opt_label, _, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");"}, {"sha": "b37660e4a90d3bb46b8b2656ae078dd55f327f62", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -96,18 +96,24 @@ fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n \n impl EarlyLintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::While(cond, ..) = &e.kind {\n+        if let ast::ExprKind::While(cond, _, label) = &e.kind {\n             if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind {\n                 if let ast::LitKind::Bool(true) = lit.kind {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n-                        let condition_span = cx.sess.source_map().guess_head_span(e.span);\n+                        let condition_span = e.span.with_hi(cond.span.hi());\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n                             lint.build(msg)\n                                 .span_suggestion_short(\n                                     condition_span,\n                                     \"use `loop`\",\n-                                    \"loop\".to_owned(),\n+                                    format!(\n+                                        \"{}loop\",\n+                                        label.map_or_else(String::new, |label| format!(\n+                                            \"{}: \",\n+                                            label.ident,\n+                                        ))\n+                                    ),\n                                     Applicability::MachineApplicable,\n                                 )\n                                 .emit();"}, {"sha": "2962cbe8157f64b0f98bcbe710b36d7ec99388a1", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -546,9 +546,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             scrutinee: discr.to_ref(),\n             arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n         },\n-        hir::ExprKind::Loop(ref body, _, _) => {\n-            ExprKind::Loop { body: block::to_expr_ref(cx, body) }\n-        }\n+        hir::ExprKind::Loop(ref body, ..) => ExprKind::Loop { body: block::to_expr_ref(cx, body) },\n         hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n             lhs: source.to_ref(),\n             name: Field::new(cx.tcx.field_index(expr.hir_id, cx.typeck_results)),"}, {"sha": "cfd7ad48222a25a5c2fb97d619deace7689f2037", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -585,7 +585,7 @@ impl<'a> Parser<'a> {\n         lhs_span: Span,\n         expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind,\n     ) -> PResult<'a, P<Expr>> {\n-        let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n+        let mk_expr = |this: &mut Self, lhs: P<Expr>, rhs: P<Ty>| {\n             this.mk_expr(\n                 this.mk_expr_sp(&lhs, lhs_span, rhs.span),\n                 expr_kind(lhs, rhs),\n@@ -597,13 +597,49 @@ impl<'a> Parser<'a> {\n         // LessThan comparison after this cast.\n         let parser_snapshot_before_type = self.clone();\n         let cast_expr = match self.parse_ty_no_plus() {\n-            Ok(rhs) => mk_expr(self, rhs),\n+            Ok(rhs) => mk_expr(self, lhs, rhs),\n             Err(mut type_err) => {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n                 let parser_snapshot_after_type = mem::replace(self, parser_snapshot_before_type);\n \n+                // Check for typo of `'a: loop { break 'a }` with a missing `'`.\n+                match (&lhs.kind, &self.token.kind) {\n+                    (\n+                        // `foo: `\n+                        ExprKind::Path(None, ast::Path { segments, .. }),\n+                        TokenKind::Ident(kw::For | kw::Loop | kw::While, false),\n+                    ) if segments.len() == 1 => {\n+                        let snapshot = self.clone();\n+                        let label = Label {\n+                            ident: Ident::from_str_and_span(\n+                                &format!(\"'{}\", segments[0].ident),\n+                                segments[0].ident.span,\n+                            ),\n+                        };\n+                        match self.parse_labeled_expr(label, AttrVec::new(), false) {\n+                            Ok(expr) => {\n+                                type_err.cancel();\n+                                self.struct_span_err(label.ident.span, \"malformed loop label\")\n+                                    .span_suggestion(\n+                                        label.ident.span,\n+                                        \"use the correct loop label format\",\n+                                        label.ident.to_string(),\n+                                        Applicability::MachineApplicable,\n+                                    )\n+                                    .emit();\n+                                return Ok(expr);\n+                            }\n+                            Err(mut err) => {\n+                                err.cancel();\n+                                *self = snapshot;\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n                 match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n                         let (op_noun, op_verb) = match self.token.kind {\n@@ -630,7 +666,8 @@ impl<'a> Parser<'a> {\n                             op_noun,\n                         );\n                         let span_after_type = parser_snapshot_after_type.token.span;\n-                        let expr = mk_expr(self, self.mk_ty(path.span, TyKind::Path(None, path)));\n+                        let expr =\n+                            mk_expr(self, lhs, self.mk_ty(path.span, TyKind::Path(None, path)));\n \n                         let expr_str = self\n                             .span_to_snippet(expr.span)\n@@ -1067,7 +1104,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::While) {\n             self.parse_while_expr(None, self.prev_token.span, attrs)\n         } else if let Some(label) = self.eat_label() {\n-            self.parse_labeled_expr(label, attrs)\n+            self.parse_labeled_expr(label, attrs, true)\n         } else if self.eat_keyword(kw::Loop) {\n             self.parse_loop_expr(None, self.prev_token.span, attrs)\n         } else if self.eat_keyword(kw::Continue) {\n@@ -1228,7 +1265,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n-    fn parse_labeled_expr(&mut self, label: Label, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_labeled_expr(\n+        &mut self,\n+        label: Label,\n+        attrs: AttrVec,\n+        consume_colon: bool,\n+    ) -> PResult<'a, P<Expr>> {\n         let lo = label.ident.span;\n         let label = Some(label);\n         let ate_colon = self.eat(&token::Colon);\n@@ -1247,7 +1289,7 @@ impl<'a> Parser<'a> {\n             self.parse_expr()\n         }?;\n \n-        if !ate_colon {\n+        if !ate_colon && consume_colon {\n             self.error_labeled_expr_must_be_followed_by_colon(lo, expr.span);\n         }\n "}, {"sha": "8950f9b33b6dac3ee4d1084d27839a3eca5de028", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -199,7 +199,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n             // Skip the following checks if we are not currently in a const context.\n             _ if self.const_kind.is_none() => {}\n \n-            hir::ExprKind::Loop(_, _, source) => {\n+            hir::ExprKind::Loop(_, _, source, _) => {\n                 self.const_check_violated(NonConstExpr::Loop(*source), e.span);\n             }\n "}, {"sha": "c11dc231d482c446ee672934fc472b4ece4bd391", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             // Note that labels have been resolved, so we don't need to look\n             // at the label ident\n-            hir::ExprKind::Loop(ref blk, _, _) => self.propagate_through_loop(expr, &blk, succ),\n+            hir::ExprKind::Loop(ref blk, ..) => self.propagate_through_loop(expr, &blk, succ),\n \n             hir::ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 //"}, {"sha": "4bfac1b72983eba1db0c674e346a9fa9ec7a49ea", "filename": "compiler/rustc_passes/src/loops.rs", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Floops.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n         match e.kind {\n-            hir::ExprKind::Loop(ref b, _, source) => {\n+            hir::ExprKind::Loop(ref b, _, source, _) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n             hir::ExprKind::Closure(_, ref function_decl, b, span, movability) => {\n@@ -68,18 +68,18 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprKind::Block(ref b, Some(_label)) => {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n             }\n-            hir::ExprKind::Break(label, ref opt_expr) => {\n+            hir::ExprKind::Break(break_label, ref opt_expr) => {\n                 if let Some(e) = opt_expr {\n                     self.visit_expr(e);\n                 }\n \n-                if self.require_label_in_labeled_block(e.span, &label, \"break\") {\n+                if self.require_label_in_labeled_block(e.span, &break_label, \"break\") {\n                     // If we emitted an error about an unlabeled break in a labeled\n                     // block, we don't need any further checking for this break any more\n                     return;\n                 }\n \n-                let loop_id = match label.target_id {\n+                let loop_id = match break_label.target_id {\n                     Ok(loop_id) => Some(loop_id),\n                     Err(hir::LoopIdError::OutsideLoopScope) => None,\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n@@ -89,49 +89,89 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     Err(hir::LoopIdError::UnresolvedLabel) => None,\n                 };\n \n-                if let Some(loop_id) = loop_id {\n-                    if let Node::Block(_) = self.hir_map.find(loop_id).unwrap() {\n-                        return;\n-                    }\n+                if let Some(Node::Block(_)) = loop_id.and_then(|id| self.hir_map.find(id)) {\n+                    return;\n                 }\n \n-                if opt_expr.is_some() {\n-                    let loop_kind = if let Some(loop_id) = loop_id {\n-                        Some(match self.hir_map.expect_expr(loop_id).kind {\n-                            hir::ExprKind::Loop(_, _, source) => source,\n+                if let Some(break_expr) = opt_expr {\n+                    let (head, loop_label, loop_kind) = if let Some(loop_id) = loop_id {\n+                        match self.hir_map.expect_expr(loop_id).kind {\n+                            hir::ExprKind::Loop(_, label, source, sp) => {\n+                                (Some(sp), label, Some(source))\n+                            }\n                             ref r => {\n                                 span_bug!(e.span, \"break label resolved to a non-loop: {:?}\", r)\n                             }\n-                        })\n+                        }\n                     } else {\n-                        None\n+                        (None, None, None)\n                     };\n                     match loop_kind {\n                         None | Some(hir::LoopSource::Loop) => (),\n                         Some(kind) => {\n-                            struct_span_err!(\n+                            let mut err = struct_span_err!(\n                                 self.sess,\n                                 e.span,\n                                 E0571,\n                                 \"`break` with value from a `{}` loop\",\n                                 kind.name()\n-                            )\n-                            .span_label(\n+                            );\n+                            err.span_label(\n                                 e.span,\n-                                \"can only break with a value inside \\\n-                                            `loop` or breakable block\",\n-                            )\n-                            .span_suggestion(\n+                                \"can only break with a value inside `loop` or breakable block\",\n+                            );\n+                            if let Some(head) = head {\n+                                err.span_label(\n+                                    head,\n+                                    &format!(\n+                                        \"you can't `break` with a value in a `{}` loop\",\n+                                        kind.name()\n+                                    ),\n+                                );\n+                            }\n+                            err.span_suggestion(\n                                 e.span,\n                                 &format!(\n-                                    \"instead, use `break` on its own \\\n-                                        without a value inside this `{}` loop\",\n-                                    kind.name()\n+                                    \"use `break` on its own without a value inside this `{}` loop\",\n+                                    kind.name(),\n+                                ),\n+                                format!(\n+                                    \"break{}\",\n+                                    break_label\n+                                        .label\n+                                        .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n                                 ),\n-                                \"break\".to_string(),\n                                 Applicability::MaybeIncorrect,\n-                            )\n-                            .emit();\n+                            );\n+                            if let (Some(label), None) = (loop_label, break_label.label) {\n+                                match break_expr.kind {\n+                                    hir::ExprKind::Path(hir::QPath::Resolved(\n+                                        None,\n+                                        hir::Path {\n+                                            segments: [segment],\n+                                            res: hir::def::Res::Err,\n+                                            ..\n+                                        },\n+                                    )) if label.ident.to_string()\n+                                        == format!(\"'{}\", segment.ident) =>\n+                                    {\n+                                        // This error is redundant, we will have already emitted a\n+                                        // suggestion to use the label when `segment` wasn't found\n+                                        // (hence the `Res::Err` check).\n+                                        err.delay_as_bug();\n+                                    }\n+                                    _ => {\n+                                        err.span_suggestion(\n+                                            break_expr.span,\n+                                            \"alternatively, you might have meant to use the \\\n+                                             available loop label\",\n+                                            label.ident.to_string(),\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                    }\n+                                }\n+                            }\n+                            err.emit();\n                         }\n                     }\n                 }"}, {"sha": "64356f73f6c65f6e76c74249a4d1f6cdbedc2c18", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -252,7 +252,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 terminating(then.hir_id.local_id);\n             }\n \n-            hir::ExprKind::Loop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }\n "}, {"sha": "eaeb28388d4f0e1fd082b8da863efd191cb24356", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -2266,6 +2266,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 visit::walk_expr(self, expr);\n             }\n \n+            ExprKind::Break(None, Some(ref e)) => {\n+                // We use this instead of `visit::walk_expr` to keep the parent expr around for\n+                // better diagnostics.\n+                self.resolve_expr(e, Some(&expr));\n+            }\n+\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 self.visit_expr(scrutinee);\n                 self.resolve_pattern_top(pat, PatternSource::Let);"}, {"sha": "bed7a350ea86daf6f721258a0d8543039653d94d", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -545,17 +545,23 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         if let Some(err_code) = &err.code {\n             if err_code == &rustc_errors::error_code!(E0425) {\n                 for label_rib in &self.label_ribs {\n-                    for (label_ident, _) in &label_rib.bindings {\n+                    for (label_ident, node_id) in &label_rib.bindings {\n                         if format!(\"'{}\", ident) == label_ident.to_string() {\n-                            let msg = \"a label with a similar name exists\";\n-                            // FIXME: consider only emitting this suggestion if a label would be valid here\n-                            // which is pretty much only the case for `break` expressions.\n-                            err.span_suggestion(\n-                                span,\n-                                &msg,\n-                                label_ident.name.to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.span_label(label_ident.span, \"a label with a similar name exists\");\n+                            if let PathSource::Expr(Some(Expr {\n+                                kind: ExprKind::Break(None, Some(_)),\n+                                ..\n+                            })) = source\n+                            {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use the similarly named label\",\n+                                    label_ident.name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                // Do not lint against unused label when we suggest them.\n+                                self.diagnostic_metadata.unused_labels.remove(node_id);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "95ac2a31dd321a0930e46dd0d126f76d5878f5a1", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1173,7 +1173,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n     }\n \n     fn expression_label(ex: &hir::Expr<'_>) -> Option<Ident> {\n-        if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind { Some(label.ident) } else { None }\n+        if let hir::ExprKind::Loop(_, Some(label), ..) = ex.kind { Some(label.ident) } else { None }\n     }\n \n     fn check_if_label_shadows_lifetime(tcx: TyCtxt<'_>, mut scope: ScopeRef<'_>, label: Ident) {"}, {"sha": "8f463af73c4774f037dfdedd5e9ce8d054f557b5", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -266,7 +266,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Loop(ref body, _, source) => {\n+            ExprKind::Loop(ref body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n             ExprKind::Match(ref discrim, ref arms, match_src) => {"}, {"sha": "24364c6954e490e5d4f9a5dc3ba8f2a8f9a95041", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             | hir::ExprKind::ConstBlock(..)\n             | hir::ExprKind::Err => {}\n \n-            hir::ExprKind::Loop(ref blk, _, _) => {\n+            hir::ExprKind::Loop(ref blk, ..) => {\n                 self.walk_block(blk);\n             }\n "}, {"sha": "d7ae353282e799decf035238000f86db0420b5cd", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -189,11 +189,4 @@ pub mod vec;\n #[unstable(feature = \"liballoc_internals\", issue = \"none\", reason = \"implementation detail\")]\n pub mod __export {\n     pub use core::format_args;\n-\n-    /// Force AST node to an expression to improve diagnostics in pattern position.\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[unstable(feature = \"liballoc_internals\", issue = \"none\", reason = \"implementation detail\")]\n-    pub macro force_expr($e:expr) {\n-        $e\n-    }\n }"}, {"sha": "f1e3ee97ccc399f39ac7a9ff01c22c67f24a45f3", "filename": "library/alloc/src/macros.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Falloc%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Falloc%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fmacros.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -40,13 +40,13 @@\n #[allow_internal_unstable(box_syntax, liballoc_internals)]\n macro_rules! vec {\n     () => (\n-        $crate::__export::force_expr!($crate::vec::Vec::new())\n+        $crate::__rust_force_expr!($crate::vec::Vec::new())\n     );\n     ($elem:expr; $n:expr) => (\n-        $crate::__export::force_expr!($crate::vec::from_elem($elem, $n))\n+        $crate::__rust_force_expr!($crate::vec::from_elem($elem, $n))\n     );\n     ($($x:expr),+ $(,)?) => (\n-        $crate::__export::force_expr!(<[_]>::into_vec(box [$($x),+]))\n+        $crate::__rust_force_expr!(<[_]>::into_vec(box [$($x),+]))\n     );\n }\n \n@@ -111,3 +111,13 @@ macro_rules! format {\n         res\n     }}\n }\n+\n+/// Force AST node to an expression to improve diagnostics in pattern position.\n+#[doc(hidden)]\n+#[macro_export]\n+#[unstable(feature = \"liballoc_internals\", issue = \"none\", reason = \"implementation detail\")]\n+macro_rules! __rust_force_expr {\n+    ($e:expr) => {\n+        $e\n+    };\n+}"}, {"sha": "36e2d18d3ddfbeb182647a848459baac7a79b55a", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -114,6 +114,19 @@ impl<T> RawVec<T, Global> {\n }\n \n impl<T, A: Allocator> RawVec<T, A> {\n+    // Tiny Vecs are dumb. Skip to:\n+    // - 8 if the element size is 1, because any heap allocators is likely\n+    //   to round up a request of less than 8 bytes to at least 8 bytes.\n+    // - 4 if elements are moderate-sized (<= 1 KiB).\n+    // - 1 otherwise, to avoid wasting too much space for very short Vecs.\n+    const MIN_NON_ZERO_CAP: usize = if mem::size_of::<T>() == 1 {\n+        8\n+    } else if mem::size_of::<T>() <= 1024 {\n+        4\n+    } else {\n+        1\n+    };\n+\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n     #[rustc_allow_const_fn_unstable(const_fn)]\n@@ -399,22 +412,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         // This guarantees exponential growth. The doubling cannot overflow\n         // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n         let cap = cmp::max(self.cap * 2, required_cap);\n-\n-        // Tiny Vecs are dumb. Skip to:\n-        // - 8 if the element size is 1, because any heap allocators is likely\n-        //   to round up a request of less than 8 bytes to at least 8 bytes.\n-        // - 4 if elements are moderate-sized (<= 1 KiB).\n-        // - 1 otherwise, to avoid wasting too much space for very short Vecs.\n-        // Note that `min_non_zero_cap` is computed statically.\n-        let elem_size = mem::size_of::<T>();\n-        let min_non_zero_cap = if elem_size == 1 {\n-            8\n-        } else if elem_size <= 1024 {\n-            4\n-        } else {\n-            1\n-        };\n-        let cap = cmp::max(min_non_zero_cap, cap);\n+        let cap = cmp::max(Self::MIN_NON_ZERO_CAP, cap);\n \n         let new_layout = Layout::array::<T>(cap);\n "}, {"sha": "d8bbd424cf2587d6a16abc08d168fcd585b99377", "filename": "library/core/src/iter/adapters/intersperse.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -151,12 +151,10 @@ where\n {\n     let (lo, hi) = iter.size_hint();\n     let next_is_elem = !needs_sep;\n-    let lo = lo.saturating_sub(next_is_elem as usize).saturating_add(lo);\n-    let hi = match hi {\n-        Some(hi) => hi.saturating_sub(next_is_elem as usize).checked_add(hi),\n-        None => None,\n-    };\n-    (lo, hi)\n+    (\n+        lo.saturating_sub(next_is_elem as usize).saturating_add(lo),\n+        hi.and_then(|hi| hi.saturating_sub(next_is_elem as usize).checked_add(hi)),\n+    )\n }\n \n fn intersperse_fold<I, B, F, G>("}, {"sha": "9f7ced829b0ac3930652c19b9af8b61212d037a5", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -567,9 +567,10 @@ pub trait Iterator {\n         Zip::new(self, other.into_iter())\n     }\n \n-    /// Places a copy of `separator` between all elements.\n+    /// Creates a new iterator which places a copy of `separator` between adjacent\n+    /// items of the original iterator.\n     ///\n-    /// In case the separator does not implement [`Clone`] or needs to be\n+    /// In case `separator` does not implement [`Clone`] or needs to be\n     /// computed every time, use [`intersperse_with`].\n     ///\n     /// # Examples\n@@ -579,6 +580,19 @@ pub trait Iterator {\n     /// ```\n     /// #![feature(iter_intersperse)]\n     ///\n+    /// let mut a = [0, 1, 2].iter().intersperse(&100);\n+    /// assert_eq!(a.next(), Some(&0));   // The first element from `a`.\n+    /// assert_eq!(a.next(), Some(&100)); // The separator.\n+    /// assert_eq!(a.next(), Some(&1));   // The next element from `a`.\n+    /// assert_eq!(a.next(), Some(&100)); // The separator.\n+    /// assert_eq!(a.next(), Some(&2));   // The last element from `a`.\n+    /// assert_eq!(a.next(), None);       // The iterator is finished.\n+    /// ```\n+    ///\n+    /// `intersperse` can be very useful to join an iterator's items using a common element:\n+    /// ```\n+    /// #![feature(iter_intersperse)]\n+    ///\n     /// let hello = [\"Hello\", \"World\", \"!\"].iter().copied().intersperse(\" \").collect::<String>();\n     /// assert_eq!(hello, \"Hello World !\");\n     /// ```\n@@ -595,7 +609,16 @@ pub trait Iterator {\n         Intersperse::new(self, separator)\n     }\n \n-    /// Places an element generated by `separator` between all elements.\n+    /// Creates a new iterator which places an item generated by `separator`\n+    /// between adjacent items of the original iterator.\n+    ///\n+    /// The closure will be called exactly once each time an item is placed\n+    /// between two adjacent items from the underlying iterator; specifically,\n+    /// the closure is not called if the underlying iterator yields less than\n+    /// two items and after the last item is yielded.\n+    ///\n+    /// If the iterator's item implements [`Clone`], it may be easier to use\n+    /// [`intersperse`].\n     ///\n     /// # Examples\n     ///\n@@ -604,14 +627,36 @@ pub trait Iterator {\n     /// ```\n     /// #![feature(iter_intersperse)]\n     ///\n+    /// #[derive(PartialEq, Debug)]\n+    /// struct NotClone(usize);\n+    ///\n+    /// let v = vec![NotClone(0), NotClone(1), NotClone(2)];\n+    /// let mut it = v.into_iter().intersperse_with(|| NotClone(99));\n+    ///\n+    /// assert_eq!(it.next(), Some(NotClone(0)));  // The first element from `v`.\n+    /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n+    /// assert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.\n+    /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n+    /// assert_eq!(it.next(), Some(NotClone(2)));  // The last element from from `v`.\n+    /// assert_eq!(it.next(), None);               // The iterator is finished.\n+    /// ```\n+    ///\n+    /// `intersperse_with` can be used in situations where the separator needs\n+    /// to be computed:\n+    /// ```\n+    /// #![feature(iter_intersperse)]\n+    ///\n     /// let src = [\"Hello\", \"to\", \"all\", \"people\", \"!!\"].iter().copied();\n     ///\n+    /// // The closure mutably borrows its context to generate an item.\n     /// let mut happy_emojis = [\" \u2764\ufe0f \", \" \ud83d\ude00 \"].iter().copied();\n     /// let separator = || happy_emojis.next().unwrap_or(\" \ud83e\udd80 \");\n     ///\n     /// let result = src.intersperse_with(separator).collect::<String>();\n     /// assert_eq!(result, \"Hello \u2764\ufe0f to \ud83d\ude00 all \ud83e\udd80 people \ud83e\udd80 !!\");\n     /// ```\n+    /// [`Clone`]: crate::clone::Clone\n+    /// [`intersperse`]: Iterator::intersperse\n     #[inline]\n     #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n     fn intersperse_with<G>(self, separator: G) -> IntersperseWith<Self, G>"}, {"sha": "e466f3151524c6061500306763d05dd0993bff58", "filename": "library/std/src/macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmacros.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -282,6 +282,10 @@ macro_rules! eprintln {\n #[macro_export]\n #[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\n macro_rules! dbg {\n+    // NOTE: We cannot use `concat!` to make a static string as a format argument\n+    // of `eprintln!` because `file!` could contain a `{` or\n+    // `$val` expression could be a block (`{ .. }`), in which case the `eprintln!`\n+    // will be malformed.\n     () => {\n         $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n     };"}, {"sha": "84449e487671867573cd0645070c15981f59b3db", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1610,11 +1610,11 @@ impl fmt::Display for Ipv6Addr {\n                 /// Write a colon-separated part of the address\n                 #[inline]\n                 fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n-                    if let Some(first) = chunk.first() {\n-                        fmt::LowerHex::fmt(first, f)?;\n-                        for segment in &chunk[1..] {\n+                    if let Some((first, tail)) = chunk.split_first() {\n+                        write!(f, \"{:x}\", first)?;\n+                        for segment in tail {\n                             f.write_char(':')?;\n-                            fmt::LowerHex::fmt(segment, f)?;\n+                            write!(f, \"{:x}\", segment)?;\n                         }\n                     }\n                     Ok(())"}, {"sha": "ef0d4edc434736ea0a04d4e8fd439d60bc9035e8", "filename": "library/std/src/net/ip/tests.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -166,6 +166,9 @@ fn ipv6_addr_to_string() {\n \n     // two runs of zeros, equal length\n     assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+\n+    // don't prefix `0x` to each segment in `dbg!`.\n+    assert_eq!(\"1::4:5:0:0:8\", &format!(\"{:#?}\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8)));\n }\n \n #[test]"}, {"sha": "0f568da459befbffbe8b6e0e79bf59d95ae03452", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -31,9 +31,9 @@ pub use core::panic::{Location, PanicInfo};\n /// accessed later using [`PanicInfo::payload`].\n ///\n /// See the [`panic!`] macro for more information about panicking.\n-#[unstable(feature = \"panic_any\", issue = \"78500\")]\n+#[stable(feature = \"panic_any\", since = \"1.51.0\")]\n #[inline]\n-pub fn panic_any<M: Any + Send>(msg: M) -> ! {\n+pub fn panic_any<M: 'static + Any + Send>(msg: M) -> ! {\n     crate::panicking::begin_panic(msg);\n }\n "}, {"sha": "6626fead774d6b42b4d37819bcf755b2280b51fe", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -320,6 +320,13 @@ macro_rules! tool_check_step {\n                     cargo.arg(\"--all-targets\");\n                 }\n \n+                // Enable internal lints for clippy and rustdoc\n+                // NOTE: this intentionally doesn't enable lints for any other tools,\n+                // see https://github.com/rust-lang/rust/pull/80573#issuecomment-754010776\n+                if $path == \"src/tools/rustdoc\" || $path == \"src/tools/clippy\" {\n+                    cargo.rustflag(\"-Zunstable-options\");\n+                }\n+\n                 builder.info(&format!(\n                     \"Checking stage{} {} artifacts ({} -> {})\",\n                     builder.top_stage,"}, {"sha": "1f9e7f8ae5cd424be37326c3fc198a1c336b03e4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -5,7 +5,7 @@ use std::iter::once;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::Mutability;\n use rustc_metadata::creader::LoadedMacro;\n@@ -17,7 +17,6 @@ use rustc_span::Span;\n \n use crate::clean::{self, Attributes, GetDefId, ToSource, TypeKind};\n use crate::core::DocContext;\n-use crate::doctree;\n \n use super::Clean;\n \n@@ -246,11 +245,7 @@ fn build_struct(cx: &DocContext<'_>, did: DefId) -> clean::Struct {\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n     clean::Struct {\n-        struct_type: match variant.ctor_kind {\n-            CtorKind::Fictive => doctree::Plain,\n-            CtorKind::Fn => doctree::Tuple,\n-            CtorKind::Const => doctree::Unit,\n-        },\n+        struct_type: variant.ctor_kind,\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n@@ -262,7 +257,6 @@ fn build_union(cx: &DocContext<'_>, did: DefId) -> clean::Union {\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n     clean::Union {\n-        struct_type: doctree::Plain,\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,"}, {"sha": "8fa60fa7178ae3d136c09b240c8bfc2b7cab7bd3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1827,7 +1827,7 @@ impl Clean<Visibility> for ty::Visibility {\n impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n-            struct_type: doctree::struct_type_from_def(self),\n+            struct_type: CtorKind::from_hir(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n             fields_stripped: false,\n         }\n@@ -1842,7 +1842,7 @@ impl Clean<Item> for ty::VariantDef {\n                 self.fields.iter().map(|f| cx.tcx.type_of(f.did).clean(cx)).collect(),\n             ),\n             CtorKind::Fictive => Variant::Struct(VariantStruct {\n-                struct_type: doctree::Plain,\n+                struct_type: CtorKind::Fictive,\n                 fields_stripped: false,\n                 fields: self\n                     .fields\n@@ -1996,13 +1996,12 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                     bounds: bounds.clean(cx),\n                 }),\n                 ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n-                    struct_type: doctree::struct_type_from_def(&variant_data),\n                     generics: generics.clean(cx),\n                     fields: variant_data.fields().clean(cx),\n                     fields_stripped: false,\n                 }),\n                 ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n-                    struct_type: doctree::struct_type_from_def(&variant_data),\n+                    struct_type: CtorKind::from_hir(variant_data),\n                     generics: generics.clean(cx),\n                     fields: variant_data.fields().clean(cx),\n                     fields_stripped: false,"}, {"sha": "c767b9dd85bf906a9f86da896ac10efc1be062b8", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -16,7 +16,7 @@ use rustc_attr::{ConstStability, Deprecation, Stability, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{CtorKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Mutability;\n@@ -37,7 +37,6 @@ use crate::clean::inline;\n use crate::clean::types::Type::{QPath, ResolvedPath};\n use crate::clean::Clean;\n use crate::core::DocContext;\n-use crate::doctree;\n use crate::formats::cache::cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n@@ -1685,15 +1684,14 @@ impl Visibility {\n \n #[derive(Clone, Debug)]\n crate struct Struct {\n-    crate struct_type: doctree::StructType,\n+    crate struct_type: CtorKind,\n     crate generics: Generics,\n     crate fields: Vec<Item>,\n     crate fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n crate struct Union {\n-    crate struct_type: doctree::StructType,\n     crate generics: Generics,\n     crate fields: Vec<Item>,\n     crate fields_stripped: bool,\n@@ -1704,7 +1702,7 @@ crate struct Union {\n /// only as a variant in an enum.\n #[derive(Clone, Debug)]\n crate struct VariantStruct {\n-    crate struct_type: doctree::StructType,\n+    crate struct_type: CtorKind,\n     crate fields: Vec<Item>,\n     crate fields_stripped: bool,\n }"}, {"sha": "8006c3d2771640d6fb9fb39ad4154bbc40513037", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::ffi::OsStr;\n use std::fmt;\n@@ -219,7 +219,7 @@ crate struct RenderOptions {\n     crate extern_html_root_urls: BTreeMap<String, String>,\n     /// A map of the default settings (values are as for DOM storage API). Keys should lack the\n     /// `rustdoc-` prefix.\n-    crate default_settings: HashMap<String, String>,\n+    crate default_settings: FxHashMap<String, String>,\n     /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n     crate resource_suffix: String,\n     /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by"}, {"sha": "bbf4de5cdc9a84bea527aa21ab08b8f7a40111c1", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,4 +1,5 @@\n use rustc_ast as ast;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{ColorConfig, ErrorReported};\n use rustc_hir as hir;\n@@ -16,7 +17,6 @@ use rustc_span::{BytePos, FileName, Pos, Span, DUMMY_SP};\n use rustc_target::spec::TargetTriple;\n use tempfile::Builder as TempFileBuilder;\n \n-use std::collections::HashMap;\n use std::env;\n use std::io::{self, Write};\n use std::panic;\n@@ -704,7 +704,7 @@ crate struct Collector {\n     position: Span,\n     source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n-    visited_tests: HashMap<(String, usize), usize>,\n+    visited_tests: FxHashMap<(String, usize), usize>,\n }\n \n impl Collector {\n@@ -728,7 +728,7 @@ impl Collector {\n             position: DUMMY_SP,\n             source_map,\n             filename,\n-            visited_tests: HashMap::new(),\n+            visited_tests: FxHashMap::default(),\n         }\n     }\n \n@@ -1010,7 +1010,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n                 self.codes,\n                 self.collector.enable_per_target_ignores,\n                 Some(&crate::html::markdown::ExtraInfo::new(\n-                    &self.tcx,\n+                    self.tcx,\n                     hir_id,\n                     span_of_attrs(&attrs).unwrap_or(sp),\n                 )),"}, {"sha": "645b2bb193ec258c3da5d58a6dceb0714c908b1a", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,7 +1,5 @@\n //! This module is used to store stuff from Rust's AST in a more convenient\n //! manner (and with prettier names) before cleaning.\n-crate use self::StructType::*;\n-\n use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n@@ -34,21 +32,3 @@ impl Module<'hir> {\n         }\n     }\n }\n-\n-#[derive(Debug, Clone, Copy)]\n-crate enum StructType {\n-    /// A braced struct\n-    Plain,\n-    /// A tuple struct\n-    Tuple,\n-    /// A unit struct\n-    Unit,\n-}\n-\n-crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n-    match *vdata {\n-        hir::VariantData::Struct(..) => Plain,\n-        hir::VariantData::Tuple(..) => Tuple,\n-        hir::VariantData::Unit(..) => Unit,\n-    }\n-}"}, {"sha": "5c0f5e50c9e2cfbca5e74aeef67e2a0ccd5e6fad", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,6 +1,6 @@\n use std::sync::Arc;\n \n-use rustc_middle::ty;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n \n use crate::clean;\n@@ -20,7 +20,7 @@ crate trait FormatRenderer<'tcx>: Clone {\n         render_info: RenderInfo,\n         edition: Edition,\n         cache: &mut Cache,\n-        tcx: ty::TyCtxt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error>;\n \n     /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n@@ -55,7 +55,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n     render_info: RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: Edition,\n-    tcx: ty::TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> Result<(), Error> {\n     let (krate, mut cache) = Cache::from_krate(\n         render_info.clone(),"}, {"sha": "c6ff4b57a6e59988eb37821ffa06ae5c6f4e4333", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,6 +1,7 @@\n-use std::collections::HashMap;\n use std::path::PathBuf;\n \n+use rustc_data_structures::fx::FxHashMap;\n+\n use crate::externalfiles::ExternalHtml;\n use crate::html::escape::Escape;\n use crate::html::format::{Buffer, Print};\n@@ -11,7 +12,7 @@ crate struct Layout {\n     crate logo: String,\n     crate favicon: String,\n     crate external_html: ExternalHtml,\n-    crate default_settings: HashMap<String, String>,\n+    crate default_settings: FxHashMap<String, String>,\n     crate krate: String,\n     /// The given user css file which allow to customize the generated\n     /// documentation theme."}, {"sha": "7c8b76be374a8097145e9e1b91d5770382fa3429", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -620,7 +620,7 @@ crate fn find_testable_code<T: doctest::Tester>(\n     tests: &mut T,\n     error_codes: ErrorCodes,\n     enable_per_target_ignores: bool,\n-    extra_info: Option<&ExtraInfo<'_, '_>>,\n+    extra_info: Option<&ExtraInfo<'_>>,\n ) {\n     let mut parser = Parser::new(doc).into_offset_iter();\n     let mut prev_offset = 0;\n@@ -681,19 +681,19 @@ crate fn find_testable_code<T: doctest::Tester>(\n     }\n }\n \n-crate struct ExtraInfo<'a, 'b> {\n+crate struct ExtraInfo<'tcx> {\n     hir_id: Option<HirId>,\n     item_did: Option<DefId>,\n     sp: Span,\n-    tcx: &'a TyCtxt<'b>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'a, 'b> ExtraInfo<'a, 'b> {\n-    crate fn new(tcx: &'a TyCtxt<'b>, hir_id: HirId, sp: Span) -> ExtraInfo<'a, 'b> {\n+impl<'tcx> ExtraInfo<'tcx> {\n+    crate fn new(tcx: TyCtxt<'tcx>, hir_id: HirId, sp: Span) -> ExtraInfo<'tcx> {\n         ExtraInfo { hir_id: Some(hir_id), item_did: None, sp, tcx }\n     }\n \n-    crate fn new_did(tcx: &'a TyCtxt<'b>, did: DefId, sp: Span) -> ExtraInfo<'a, 'b> {\n+    crate fn new_did(tcx: TyCtxt<'tcx>, did: DefId, sp: Span) -> ExtraInfo<'tcx> {\n         ExtraInfo { hir_id: None, item_did: Some(did), sp, tcx }\n     }\n \n@@ -775,7 +775,7 @@ impl LangString {\n         string: &str,\n         allow_error_code_check: ErrorCodes,\n         enable_per_target_ignores: bool,\n-        extra: Option<&ExtraInfo<'_, '_>>,\n+        extra: Option<&ExtraInfo<'_>>,\n     ) -> LangString {\n         let allow_error_code_check = allow_error_code_check.as_bool();\n         let mut seen_rust_tags = false;\n@@ -1208,7 +1208,7 @@ crate struct RustCodeBlock {\n \n /// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n /// untagged (and assumed to be rust).\n-crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_, '_>) -> Vec<RustCodeBlock> {\n+crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_>) -> Vec<RustCodeBlock> {\n     let mut code_blocks = vec![];\n \n     if md.is_empty() {"}, {"sha": "6167b75ee50d398a5f39a1367b0e5357ea7fa747", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -52,10 +52,10 @@ use rustc_attr::{Deprecation, StabilityLevel};\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -68,7 +68,6 @@ use serde::{Serialize, Serializer};\n use crate::clean::{self, AttributesExt, GetDefId, RenderedLink, SelfTy, TypeKind};\n use crate::config::{RenderInfo, RenderOptions};\n use crate::docfs::{DocFS, PathError};\n-use crate::doctree;\n use crate::error::Error;\n use crate::formats::cache::{cache, Cache};\n use crate::formats::item_type::ItemType;\n@@ -390,7 +389,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         _render_info: RenderInfo,\n         edition: Edition,\n         cache: &mut Cache,\n-        tcx: ty::TyCtxt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         // need to save a copy of the options for rendering the index page\n         let md_opts = options.clone();\n@@ -3104,7 +3103,7 @@ fn item_struct(\n             _ => None,\n         })\n         .peekable();\n-    if let doctree::Plain = s.struct_type {\n+    if let CtorKind::Fictive = s.struct_type {\n         if fields.peek().is_some() {\n             write!(\n                 w,\n@@ -3354,7 +3353,7 @@ fn render_struct(\n     w: &mut Buffer,\n     it: &clean::Item,\n     g: Option<&clean::Generics>,\n-    ty: doctree::StructType,\n+    ty: CtorKind,\n     fields: &[clean::Item],\n     tab: &str,\n     structhead: bool,\n@@ -3371,7 +3370,7 @@ fn render_struct(\n         write!(w, \"{}\", g.print())\n     }\n     match ty {\n-        doctree::Plain => {\n+        CtorKind::Fictive => {\n             if let Some(g) = g {\n                 write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })\n             }\n@@ -3403,7 +3402,7 @@ fn render_struct(\n             }\n             write!(w, \"}}\");\n         }\n-        doctree::Tuple => {\n+        CtorKind::Fn => {\n             write!(w, \"(\");\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n@@ -3428,7 +3427,7 @@ fn render_struct(\n             }\n             write!(w, \";\");\n         }\n-        doctree::Unit => {\n+        CtorKind::Const => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n                 write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })\n@@ -4463,7 +4462,7 @@ fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clea\n     let fields = get_struct_fields_name(&s.fields);\n \n     if !fields.is_empty() {\n-        if let doctree::Plain = s.struct_type {\n+        if let CtorKind::Fictive = s.struct_type {\n             sidebar.push_str(&format!(\n                 \"<a class=\\\"sidebar-title\\\" href=\\\"#fields\\\">Fields</a>\\\n                  <div class=\\\"sidebar-links\\\">{}</div>\","}, {"sha": "bfd2141d9a1745214d423700b77f5e2176e69ed0", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -5,11 +5,11 @@\n use std::convert::From;\n \n use rustc_ast::ast;\n+use rustc_hir::def::CtorKind;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_span::Pos;\n \n use crate::clean;\n-use crate::doctree;\n use crate::formats::item_type::ItemType;\n use crate::json::types::*;\n use crate::json::JsonRenderer;\n@@ -27,7 +27,7 @@ impl JsonRenderer<'_> {\n                 name: name.map(|sym| sym.to_string()),\n                 source: self.convert_span(source),\n                 visibility: self.convert_visibility(visibility),\n-                docs: attrs.collapsed_doc_value().unwrap_or_default(),\n+                docs: attrs.collapsed_doc_value(),\n                 links: attrs\n                     .links\n                     .into_iter()\n@@ -210,9 +210,9 @@ impl From<clean::Struct> for Struct {\n \n impl From<clean::Union> for Struct {\n     fn from(struct_: clean::Union) -> Self {\n-        let clean::Union { struct_type, generics, fields, fields_stripped } = struct_;\n+        let clean::Union { generics, fields, fields_stripped } = struct_;\n         Struct {\n-            struct_type: struct_type.into(),\n+            struct_type: StructType::Union,\n             generics: generics.into(),\n             fields_stripped,\n             fields: ids(fields),\n@@ -221,13 +221,12 @@ impl From<clean::Union> for Struct {\n     }\n }\n \n-impl From<doctree::StructType> for StructType {\n-    fn from(struct_type: doctree::StructType) -> Self {\n-        use doctree::StructType::*;\n+impl From<CtorKind> for StructType {\n+    fn from(struct_type: CtorKind) -> Self {\n         match struct_type {\n-            Plain => StructType::Plain,\n-            Tuple => StructType::Tuple,\n-            Unit => StructType::Unit,\n+            CtorKind::Fictive => StructType::Plain,\n+            CtorKind::Fn => StructType::Tuple,\n+            CtorKind::Const => StructType::Unit,\n         }\n     }\n }"}, {"sha": "dc50c8a76b24f446edf9fd30fcf3c6a1549fbc1a", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -13,7 +13,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n \n@@ -26,7 +26,7 @@ use crate::html::render::cache::ExternalLocation;\n \n #[derive(Clone)]\n crate struct JsonRenderer<'tcx> {\n-    tcx: ty::TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     /// A mapping of IDs that contains all local items for this crate which gets output as a top\n     /// level field of the JSON blob.\n     index: Rc<RefCell<FxHashMap<types::Id, types::Item>>>,\n@@ -131,7 +131,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         _render_info: RenderInfo,\n         _edition: Edition,\n         _cache: &mut Cache,\n-        tcx: ty::TyCtxt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         debug!(\"Initializing json renderer\");\n         Ok((\n@@ -241,7 +241,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                     )\n                 })\n                 .collect(),\n-            format_version: 1,\n+            format_version: 2,\n         };\n         let mut p = self.out_path.clone();\n         p.push(output.index.get(&output.root).unwrap().name.clone().unwrap());"}, {"sha": "66cf12954dd0bbc6bfe3fef6f969423ea6e47a6b", "filename": "src/librustdoc/json/types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fjson%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fjson%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Ftypes.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -68,8 +68,9 @@ pub struct Item {\n     /// By default all documented items are public, but you can tell rustdoc to output private items\n     /// so this field is needed to differentiate.\n     pub visibility: Visibility,\n-    /// The full markdown docstring of this item.\n-    pub docs: String,\n+    /// The full markdown docstring of this item. Absent if there is no documentation at all,\n+    /// Some(\"\") if there is some documentation but it is empty (EG `#[doc = \"\"]`).\n+    pub docs: Option<String>,\n     /// This mapping resolves [intra-doc links](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md) from the docstring to their IDs\n     pub links: FxHashMap<String, Id>,\n     /// Stringified versions of the attributes on this item (e.g. `\"#[inline]\"`)\n@@ -269,6 +270,7 @@ pub enum StructType {\n     Plain,\n     Tuple,\n     Unit,\n+    Union,\n }\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]"}, {"sha": "d17189b416dd448a4802c7abf679f93af012d0e8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -18,6 +18,7 @@\n #![feature(str_split_once)]\n #![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::internal)]\n \n #[macro_use]\n extern crate lazy_static;\n@@ -65,7 +66,7 @@ use std::process;\n use rustc_driver::abort_on_err;\n use rustc_errors::ErrorReported;\n use rustc_interface::interface;\n-use rustc_middle::ty;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{make_crate_type_option, ErrorOutputType, RustcOptGroup};\n use rustc_session::getopts;\n use rustc_session::{early_error, early_warn};\n@@ -471,7 +472,7 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n     render_info: config::RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: rustc_span::edition::Edition,\n-    tcx: ty::TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> MainResult {\n     match formats::run_format::<T>(krate, renderopts, render_info, &diag, edition, tcx) {\n         Ok(_) => Ok(()),"}, {"sha": "9516130034b59216a76fd9446c941162859ece0e", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if let Some(dox) = &item.attrs.collapsed_doc_value() {\n             let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());\n-            let extra = crate::html::markdown::ExtraInfo::new_did(&self.cx.tcx, item.def_id, sp);\n+            let extra = crate::html::markdown::ExtraInfo::new_did(self.cx.tcx, item.def_id, sp);\n             for code_block in markdown::rust_code_blocks(&dox, &extra) {\n                 self.check_rust_syntax(&item, &dox, code_block);\n             }"}, {"sha": "002d8938f694deb9a3c769afed4dabdb4d06fa4c", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -13,6 +13,7 @@ use rustc_hir::def::{\n     PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_middle::ty::TyCtxt;\n use rustc_middle::{bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::{\n@@ -85,7 +86,7 @@ impl Res {\n         }\n     }\n \n-    fn name(self, tcx: ty::TyCtxt<'_>) -> String {\n+    fn name(self, tcx: TyCtxt<'_>) -> String {\n         match self {\n             Res::Def(_, id) => tcx.item_name(id).to_string(),\n             Res::Primitive(prim) => prim.as_str().to_string(),\n@@ -865,12 +866,11 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n         let self_name = self_id.and_then(|self_id| {\n-            use ty::TyKind;\n             if matches!(self.cx.tcx.def_kind(self_id), DefKind::Impl) {\n                 // using `ty.to_string()` (or any variant) has issues with raw idents\n                 let ty = self.cx.tcx.type_of(self_id);\n                 let name = match ty.kind() {\n-                    TyKind::Adt(def, _) => Some(self.cx.tcx.item_name(def.did).to_string()),\n+                    ty::Adt(def, _) => Some(self.cx.tcx.item_name(def.did).to_string()),\n                     other if other.is_primitive() => Some(ty.to_string()),\n                     _ => None,\n                 };"}, {"sha": "897fd172b29f34bc8fbfafe520b557f18ffb7999", "filename": "src/test/ui/issues/issue-1962.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-1962.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-1962.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1962.fixed?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -3,8 +3,8 @@\n \n fn main() {\n     let mut i = 0;\n-    loop { //~ ERROR denote infinite loops with `loop\n+    'a: loop { //~ ERROR denote infinite loops with `loop\n         i += 1;\n-        if i == 5 { break; }\n+        if i == 5 { break 'a; }\n     }\n }"}, {"sha": "71e874100874f4fba0367ae8a2a093f124fc8e3b", "filename": "src/test/ui/issues/issue-1962.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-1962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-1962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1962.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -3,8 +3,8 @@\n \n fn main() {\n     let mut i = 0;\n-    while true { //~ ERROR denote infinite loops with `loop\n+    'a: while true { //~ ERROR denote infinite loops with `loop\n         i += 1;\n-        if i == 5 { break; }\n+        if i == 5 { break 'a; }\n     }\n }"}, {"sha": "4c32a4cf3dd5946ac7bfae466c77724938ccb2fe", "filename": "src/test/ui/issues/issue-1962.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-1962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-1962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1962.stderr?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,8 +1,8 @@\n error: denote infinite loops with `loop { ... }`\n   --> $DIR/issue-1962.rs:6:5\n    |\n-LL |     while true {\n-   |     ^^^^^^^^^^ help: use `loop`\n+LL |     'a: while true {\n+   |     ^^^^^^^^^^^^^^ help: use `loop`\n    |\n    = note: requested on the command line with `-D while-true`\n "}, {"sha": "59ef28481d0e6e35b05d20a0d032c4b8036040c5", "filename": "src/test/ui/issues/issue-27042.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -4,7 +4,7 @@ warning: denote infinite loops with `loop { ... }`\n LL | /         'b:\n LL | |\n LL | |         while true { break }; // but here we cite the whole loop\n-   | |____________________________^ help: use `loop`\n+   | |__________________^ help: use `loop`\n    |\n    = note: `#[warn(while_true)]` on by default\n "}, {"sha": "e3180b06ecb2bfa33694e7c94c64efde0a8d801e", "filename": "src/test/ui/label/label_misspelled.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,18 +1,62 @@\n+#![warn(unused_labels)]\n+\n fn main() {\n+    'while_loop: while true { //~ WARN denote infinite loops with\n+        //~^ WARN unused label\n+        while_loop;\n+        //~^ ERROR cannot find value `while_loop` in this scope\n+    };\n+    'while_let: while let Some(_) = Some(()) {\n+        //~^ WARN unused label\n+        while_let;\n+        //~^ ERROR cannot find value `while_let` in this scope\n+    }\n+    'for_loop: for _ in 0..3 {\n+        //~^ WARN unused label\n+        for_loop;\n+        //~^ ERROR cannot find value `for_loop` in this scope\n+    };\n     'LOOP: loop {\n+        //~^ WARN unused label\n         LOOP;\n         //~^ ERROR cannot find value `LOOP` in this scope\n     };\n+}\n+\n+fn foo() {\n+    'LOOP: loop {\n+        break LOOP;\n+        //~^ ERROR cannot find value `LOOP` in this scope\n+    };\n     'while_loop: while true { //~ WARN denote infinite loops with\n-        while_loop;\n+        break while_loop;\n         //~^ ERROR cannot find value `while_loop` in this scope\n     };\n     'while_let: while let Some(_) = Some(()) {\n-        while_let;\n+        break while_let;\n         //~^ ERROR cannot find value `while_let` in this scope\n     }\n     'for_loop: for _ in 0..3 {\n-        for_loop;\n+        break for_loop;\n         //~^ ERROR cannot find value `for_loop` in this scope\n     };\n }\n+\n+fn bar() {\n+    let foo = ();\n+    'while_loop: while true { //~ WARN denote infinite loops with\n+        //~^ WARN unused label\n+        break foo;\n+        //~^ ERROR `break` with value from a `while` loop\n+    };\n+    'while_let: while let Some(_) = Some(()) {\n+        //~^ WARN unused label\n+        break foo;\n+        //~^ ERROR `break` with value from a `while` loop\n+    }\n+    'for_loop: for _ in 0..3 {\n+        //~^ WARN unused label\n+        break foo;\n+        //~^ ERROR `break` with value from a `for` loop\n+    };\n+}"}, {"sha": "b09695787a443ae6108a5c200d15c00352c66e55", "filename": "src/test/ui/label/label_misspelled.stderr", "status": "modified", "additions": 185, "deletions": 26, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.stderr?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,47 +1,206 @@\n-error[E0425]: cannot find value `LOOP` in this scope\n-  --> $DIR/label_misspelled.rs:3:9\n-   |\n-LL |         LOOP;\n-   |         ^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'LOOP`\n-\n error[E0425]: cannot find value `while_loop` in this scope\n-  --> $DIR/label_misspelled.rs:7:9\n+  --> $DIR/label_misspelled.rs:6:9\n    |\n+LL |     'while_loop: while true {\n+   |     ----------- a label with a similar name exists\n+LL |\n LL |         while_loop;\n-   |         ^^^^^^^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'while_loop`\n+   |         ^^^^^^^^^^ not found in this scope\n \n error[E0425]: cannot find value `while_let` in this scope\n   --> $DIR/label_misspelled.rs:11:9\n    |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ---------- a label with a similar name exists\n+LL |\n LL |         while_let;\n-   |         ^^^^^^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'while_let`\n+   |         ^^^^^^^^^ not found in this scope\n \n error[E0425]: cannot find value `for_loop` in this scope\n-  --> $DIR/label_misspelled.rs:15:9\n+  --> $DIR/label_misspelled.rs:16:9\n    |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     --------- a label with a similar name exists\n+LL |\n LL |         for_loop;\n-   |         ^^^^^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'for_loop`\n+   |         ^^^^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `LOOP` in this scope\n+  --> $DIR/label_misspelled.rs:21:9\n+   |\n+LL |     'LOOP: loop {\n+   |     ----- a label with a similar name exists\n+LL |\n+LL |         LOOP;\n+   |         ^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `LOOP` in this scope\n+  --> $DIR/label_misspelled.rs:28:15\n+   |\n+LL |     'LOOP: loop {\n+   |     ----- a label with a similar name exists\n+LL |         break LOOP;\n+   |               ^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'LOOP`\n+\n+error[E0425]: cannot find value `while_loop` in this scope\n+  --> $DIR/label_misspelled.rs:32:15\n+   |\n+LL |     'while_loop: while true {\n+   |     ----------- a label with a similar name exists\n+LL |         break while_loop;\n+   |               ^^^^^^^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'while_loop`\n+\n+error[E0425]: cannot find value `while_let` in this scope\n+  --> $DIR/label_misspelled.rs:36:15\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ---------- a label with a similar name exists\n+LL |         break while_let;\n+   |               ^^^^^^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'while_let`\n+\n+error[E0425]: cannot find value `for_loop` in this scope\n+  --> $DIR/label_misspelled.rs:40:15\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     --------- a label with a similar name exists\n+LL |         break for_loop;\n+   |               ^^^^^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'for_loop`\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:4:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/label_misspelled.rs:1:9\n+   |\n+LL | #![warn(unused_labels)]\n+   |         ^^^^^^^^^^^^^\n \n warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/label_misspelled.rs:6:5\n+  --> $DIR/label_misspelled.rs:4:5\n    |\n LL |     'while_loop: while true {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `loop`\n    |\n    = note: `#[warn(while_true)]` on by default\n \n-error: aborting due to 4 previous errors; 1 warning emitted\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:9:5\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ^^^^^^^^^^\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:14:5\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     ^^^^^^^^^\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:19:5\n+   |\n+LL |     'LOOP: loop {\n+   |     ^^^^^\n+\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/label_misspelled.rs:31:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `loop`\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:47:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^\n+\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/label_misspelled.rs:47:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `loop`\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:52:5\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ^^^^^^^^^^\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:57:5\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     ^^^^^^^^^\n+\n+error[E0571]: `break` with value from a `while` loop\n+  --> $DIR/label_misspelled.rs:49:9\n+   |\n+LL |     'while_loop: while true {\n+   |     ----------------------- you can't `break` with a value in a `while` loop\n+LL |\n+LL |         break foo;\n+   |         ^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+   |\n+help: use `break` on its own without a value inside this `while` loop\n+   |\n+LL |         break;\n+   |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'while_loop;\n+   |               ^^^^^^^^^^^\n+\n+error[E0571]: `break` with value from a `while` loop\n+  --> $DIR/label_misspelled.rs:54:9\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ---------------------------------------- you can't `break` with a value in a `while` loop\n+LL |\n+LL |         break foo;\n+   |         ^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+   |\n+help: use `break` on its own without a value inside this `while` loop\n+   |\n+LL |         break;\n+   |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'while_let;\n+   |               ^^^^^^^^^^\n+\n+error[E0571]: `break` with value from a `for` loop\n+  --> $DIR/label_misspelled.rs:59:9\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     ------------------------ you can't `break` with a value in a `for` loop\n+LL |\n+LL |         break foo;\n+   |         ^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+   |\n+help: use `break` on its own without a value inside this `for` loop\n+   |\n+LL |         break;\n+   |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'for_loop;\n+   |               ^^^^^^^^^\n+\n+error: aborting due to 11 previous errors; 10 warnings emitted\n \n-For more information about this error, try `rustc --explain E0425`.\n+Some errors have detailed explanations: E0425, E0571.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "55bbe6b30a5930382dbd75afac17550f22749d44", "filename": "src/test/ui/label/label_misspelled_2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -0,0 +1,16 @@\n+#![warn(unused_labels)]\n+\n+fn main() {\n+    'a: for _ in 0..1 {\n+        break 'a;\n+    }\n+    'b: for _ in 0..1 {\n+        break b; //~ ERROR cannot find value `b` in this scope\n+    }\n+    c: for _ in 0..1 { //~ ERROR malformed loop label\n+        break 'c;\n+    }\n+    d: for _ in 0..1 { //~ ERROR malformed loop label\n+        break d; //~ ERROR cannot find value `d` in this scope\n+    }\n+}"}, {"sha": "960646d9894d1158774e6d5369ecd7e350e24c38", "filename": "src/test/ui/label/label_misspelled_2.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.stderr?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -0,0 +1,37 @@\n+error: malformed loop label\n+  --> $DIR/label_misspelled_2.rs:10:5\n+   |\n+LL |     c: for _ in 0..1 {\n+   |     ^ help: use the correct loop label format: `'c`\n+\n+error: malformed loop label\n+  --> $DIR/label_misspelled_2.rs:13:5\n+   |\n+LL |     d: for _ in 0..1 {\n+   |     ^ help: use the correct loop label format: `'d`\n+\n+error[E0425]: cannot find value `b` in this scope\n+  --> $DIR/label_misspelled_2.rs:8:15\n+   |\n+LL |     'b: for _ in 0..1 {\n+   |     -- a label with a similar name exists\n+LL |         break b;\n+   |               ^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'b`\n+\n+error[E0425]: cannot find value `d` in this scope\n+  --> $DIR/label_misspelled_2.rs:14:15\n+   |\n+LL |     d: for _ in 0..1 {\n+   |     - a label with a similar name exists\n+LL |         break d;\n+   |               ^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'d`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "1c0d39a6e5ad738983fa19f94cd1cd28f23f7303", "filename": "src/test/ui/loops/loop-break-value-no-repeat.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Floops%2Floop-break-value-no-repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Floops%2Floop-break-value-no-repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value-no-repeat.stderr?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,10 +1,12 @@\n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value-no-repeat.rs:12:9\n    |\n+LL |     for _ in &[1,2,3] {\n+   |     ----------------- you can't `break` with a value in a `for` loop\n LL |         break 22\n    |         ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n+help: use `break` on its own without a value inside this `for` loop\n    |\n LL |         break\n    |         ^^^^^"}, {"sha": "51c9a36a0395641c7575c35e402bd3db29927890", "filename": "src/test/ui/loops/loop-break-value.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -94,6 +94,5 @@ fn main() {\n     'LOOP: for _ in 0 .. 9 {\n         break LOOP;\n         //~^ ERROR cannot find value `LOOP` in this scope\n-        //~| ERROR `break` with value from a `for` loop\n     }\n }"}, {"sha": "adb099f9b1769ed0f26048775866844c4604c4fe", "filename": "src/test/ui/loops/loop-break-value.stderr", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -1,11 +1,13 @@\n error[E0425]: cannot find value `LOOP` in this scope\n   --> $DIR/loop-break-value.rs:95:15\n    |\n+LL |     'LOOP: for _ in 0 .. 9 {\n+   |     ----- a label with a similar name exists\n LL |         break LOOP;\n    |               ^^^^\n    |               |\n    |               not found in this scope\n-   |               help: a label with a similar name exists: `'LOOP`\n+   |               help: use the similarly named label: `'LOOP`\n \n warning: denote infinite loops with `loop { ... }`\n   --> $DIR/loop-break-value.rs:26:5\n@@ -18,101 +20,115 @@ LL |     'while_loop: while true {\n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:28:9\n    |\n+LL |     'while_loop: while true {\n+   |     ----------------------- you can't `break` with a value in a `while` loop\n+LL |         break;\n LL |         break ();\n    |         ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n LL |         break;\n    |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'while_loop;\n+   |               ^^^^^^^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:30:13\n    |\n+LL |     'while_loop: while true {\n+   |     ----------------------- you can't `break` with a value in a `while` loop\n+...\n LL |             break 'while_loop 123;\n    |             ^^^^^^^^^^^^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n-LL |             break;\n-   |             ^^^^^\n+LL |             break 'while_loop;\n+   |             ^^^^^^^^^^^^^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:38:12\n    |\n+LL |     while let Some(_) = Some(()) {\n+   |     ---------------------------- you can't `break` with a value in a `while` loop\n LL |         if break () {\n    |            ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n LL |         if break {\n    |            ^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:43:9\n    |\n+LL |     while let Some(_) = Some(()) {\n+   |     ---------------------------- you can't `break` with a value in a `while` loop\n LL |         break None;\n    |         ^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n LL |         break;\n    |         ^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:49:13\n    |\n+LL |     'while_let_loop: while let Some(_) = Some(()) {\n+   |     --------------------------------------------- you can't `break` with a value in a `while` loop\n+LL |         loop {\n LL |             break 'while_let_loop \"nope\";\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n-LL |             break;\n-   |             ^^^^^\n+LL |             break 'while_let_loop;\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value.rs:56:9\n    |\n+LL |     for _ in &[1,2,3] {\n+   |     ----------------- you can't `break` with a value in a `for` loop\n LL |         break ();\n    |         ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n+help: use `break` on its own without a value inside this `for` loop\n    |\n LL |         break;\n    |         ^^^^^\n \n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value.rs:57:9\n    |\n+LL |     for _ in &[1,2,3] {\n+   |     ----------------- you can't `break` with a value in a `for` loop\n+LL |         break ();\n LL |         break [()];\n    |         ^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n+help: use `break` on its own without a value inside this `for` loop\n    |\n LL |         break;\n    |         ^^^^^\n \n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value.rs:64:13\n    |\n+LL |     'for_loop: for _ in &[1,2,3] {\n+   |     ---------------------------- you can't `break` with a value in a `for` loop\n+...\n LL |             break 'for_loop Some(17);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n-   |\n-LL |             break;\n-   |             ^^^^^\n-\n-error[E0571]: `break` with value from a `for` loop\n-  --> $DIR/loop-break-value.rs:95:9\n-   |\n-LL |         break LOOP;\n-   |         ^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+help: use `break` on its own without a value inside this `for` loop\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n-   |\n-LL |         break;\n-   |         ^^^^^\n+LL |             break 'for_loop;\n+   |             ^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/loop-break-value.rs:4:31\n@@ -171,7 +187,7 @@ LL |         break;\n    |         expected integer, found `()`\n    |         help: give it a value of the expected type: `break value`\n \n-error: aborting due to 18 previous errors; 1 warning emitted\n+error: aborting due to 17 previous errors; 1 warning emitted\n \n Some errors have detailed explanations: E0308, E0425, E0571.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "bbcea387de2cb81bb38838ce5cf1e001d5a91230", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -533,7 +533,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         }\n \n         // check for never_loop\n-        if let ExprKind::Loop(ref block, _, _) = expr.kind {\n+        if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n             match never_loop_block(block, expr.hir_id) {\n                 NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n                 NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n@@ -543,7 +543,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.kind {\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop, _) = expr.kind {\n             // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n             if block.stmts.is_empty() && block.expr.is_none() && !is_in_panic_handler(cx, expr) {\n                 let msg = \"empty `loop {}` wastes CPU cycles\";\n@@ -738,7 +738,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Assign(ref e1, ref e2, _)\n         | ExprKind::AssignOp(_, ref e1, ref e2)\n         | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprKind::Loop(ref b, _, _) => {\n+        ExprKind::Loop(ref b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n@@ -1314,7 +1314,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         match &expr.kind {\n             // Non-determinism may occur ... don't give a lint\n-            ExprKind::Loop(_, _, _) | ExprKind::Match(_, _, _) => self.should_lint = false,\n+            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n             ExprKind::Block(block, _) => self.visit_block(block),\n             _ => {},\n         }"}, {"sha": "603071a5f4ac4659fef61816e436507b54fc5ada", "filename": "src/tools/clippy/clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -221,7 +221,7 @@ where\n {\n     if let ast::ExprKind::While(_, loop_block, label)\n     | ast::ExprKind::ForLoop(_, _, loop_block, label)\n-    | ast::ExprKind::Loop(loop_block, label) = &expr.kind\n+    | ast::ExprKind::Loop(loop_block, label, ..) = &expr.kind\n     {\n         func(loop_block, label.as_ref());\n     }"}, {"sha": "d5b1767e945b9ea4a81b4b9a07d5ed70d56c0cb1", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -325,7 +325,7 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n         | ExprKind::Field(ref e, _)\n         | ExprKind::AddrOf(_, _, ref e)\n         | ExprKind::Box(ref e) => check_expr(cx, e, bindings),\n-        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, _, _) => check_block(cx, block, bindings),\n+        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, ..) => check_block(cx, block, bindings),\n         // ExprKind::Call\n         // ExprKind::MethodCall\n         ExprKind::Array(v) | ExprKind::Tup(v) => {"}, {"sha": "ca60d335262b3bda975431d92c0f7ecc987dde10", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -317,7 +317,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Loop(ref body, _, desugaring) => {\n+            ExprKind::Loop(ref body, _, desugaring, _) => {\n                 let body_pat = self.next(\"body\");\n                 let des = loop_desugaring_name(desugaring);\n                 let label_pat = self.next(\"label\");"}, {"sha": "42ab9a1e7d2472f01173d2d42fc7076ba92b5a40", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -142,7 +142,7 @@ pub fn for_loop<'tcx>(\n         if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(ref block, _, _) = arms[0].body.kind;\n+        if let hir::ExprKind::Loop(ref block, ..) = arms[0].body.kind;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n         if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n@@ -158,7 +158,7 @@ pub fn for_loop<'tcx>(\n /// `while cond { body }` becomes `(cond, body)`.\n pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n     if_chain! {\n-        if let hir::ExprKind::Loop(block, _, hir::LoopSource::While) = &expr.kind;\n+        if let hir::ExprKind::Loop(block, _, hir::LoopSource::While, _) = &expr.kind;\n         if let hir::Block { expr: Some(expr), .. } = &**block;\n         if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n         if let hir::ExprKind::DropTemps(cond) = &cond.kind;"}, {"sha": "6066383f2ef424f84e2c1f529cd3eb45d53fd80c", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b814b639836aa76b5c6deaa585367150bb2debf4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=b814b639836aa76b5c6deaa585367150bb2debf4", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n-            (&ExprKind::Loop(ref lb, ref ll, ref lls), &ExprKind::Loop(ref rb, ref rl, ref rls)) => {\n+            (&ExprKind::Loop(ref lb, ref ll, ref lls, _), &ExprKind::Loop(ref rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);\n             },\n-            ExprKind::Loop(ref b, ref i, _) => {\n+            ExprKind::Loop(ref b, ref i, ..) => {\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);"}]}