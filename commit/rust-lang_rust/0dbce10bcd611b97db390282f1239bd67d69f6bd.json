{"sha": "0dbce10bcd611b97db390282f1239bd67d69f6bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYmNlMTBiY2Q2MTFiOTdkYjM5MDI4MmYxMjM5YmQ2N2Q2OWY2YmQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-04-18T22:43:08Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-05-06T12:14:21Z"}, "message": "Pull in miri test cases", "tree": {"sha": "fb28a64d4de4ec22564fe99a9571900cc036acd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb28a64d4de4ec22564fe99a9571900cc036acd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dbce10bcd611b97db390282f1239bd67d69f6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbce10bcd611b97db390282f1239bd67d69f6bd", "html_url": "https://github.com/rust-lang/rust/commit/0dbce10bcd611b97db390282f1239bd67d69f6bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dbce10bcd611b97db390282f1239bd67d69f6bd/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9907ad6ed9fde5ccdb58a7d59d652a4c8a98a346", "url": "https://api.github.com/repos/rust-lang/rust/commits/9907ad6ed9fde5ccdb58a7d59d652a4c8a98a346", "html_url": "https://github.com/rust-lang/rust/commit/9907ad6ed9fde5ccdb58a7d59d652a4c8a98a346"}], "stats": {"total": 463, "additions": 458, "deletions": 5}, "files": [{"sha": "09c044a1b7a98cbd3044561ee500c3f6783fcbd1", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts.rs", "status": "modified", "additions": 458, "deletions": 5, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/0dbce10bcd611b97db390282f1239bd67d69f6bd/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbce10bcd611b97db390282f1239bd67d69f6bd/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs?ref=0dbce10bcd611b97db390282f1239bd67d69f6bd", "patch": "@@ -1,14 +1,19 @@\n // run-pass\n // Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n+//\n+// Some of these tests come from a similar file in miri,\n+// tests/run-pass/float.rs. They're just duplicated currently but we may want\n+// to merge this in the future.\n \n #![feature(test, stmt_expr_attributes)]\n+#![feature(track_caller)]\n #![deny(overflowing_literals)]\n extern crate test;\n \n use std::{f32, f64};\n-use std::{u8, i8, u16, i16, u32, i32, u64, i64};\n-#[cfg(not(target_os=\"emscripten\"))]\n-use std::{u128, i128};\n+#[cfg(not(target_os = \"emscripten\"))]\n+use std::{i128, u128};\n+use std::{i16, i32, i64, i8, u16, u32, u64, u8};\n use test::black_box;\n \n macro_rules! test {\n@@ -84,11 +89,459 @@ macro_rules! fptoui_tests {\n     })\n }\n \n+use std::fmt::Debug;\n+\n+// Helper function to avoid promotion so that this tests \"run-time\" casts, not CTFE.\n+#[track_caller]\n+#[inline(never)]\n+fn assert_eq<T: PartialEq + Debug>(x: T, y: T) {\n+    assert_eq!(x, y);\n+}\n+\n+trait FloatToInt<Int>: Copy {\n+    fn cast(self) -> Int;\n+    unsafe fn cast_unchecked(self) -> Int;\n+}\n+\n+impl FloatToInt<i8> for f32 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f32 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f32 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f32 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f32 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+impl FloatToInt<i8> for f64 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f64 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f64 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f64 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f64 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<i128> for f64 {\n+    fn cast(self) -> i128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<u128> for f64 {\n+    fn cast(self) -> u128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+/// Test this cast both via `as` and via `to_int_unchecked` (i.e., it must not saturate).\n+#[track_caller]\n+#[inline(never)]\n+fn test_both_cast<F, I>(x: F, y: I)\n+where\n+    F: FloatToInt<I>,\n+    I: PartialEq + Debug,\n+{\n+    assert_eq!(x.cast(), y);\n+    assert_eq!(unsafe { x.cast_unchecked() }, y);\n+}\n+\n+fn basic() {\n+    // basic arithmetic\n+    assert_eq(6.0_f32 * 6.0_f32, 36.0_f32);\n+    assert_eq(6.0_f64 * 6.0_f64, 36.0_f64);\n+    assert_eq(-{ 5.0_f32 }, -5.0_f32);\n+    assert_eq(-{ 5.0_f64 }, -5.0_f64);\n+    // infinities, NaN\n+    assert!((5.0_f32 / 0.0).is_infinite());\n+    assert_ne!({ 5.0_f32 / 0.0 }, { -5.0_f32 / 0.0 });\n+    assert!((5.0_f64 / 0.0).is_infinite());\n+    assert_ne!({ 5.0_f64 / 0.0 }, { 5.0_f64 / -0.0 });\n+    assert!((-5.0_f32).sqrt().is_nan());\n+    assert!((-5.0_f64).sqrt().is_nan());\n+    assert_ne!(f32::NAN, f32::NAN);\n+    assert_ne!(f64::NAN, f64::NAN);\n+    // negative zero\n+    let posz = 0.0f32;\n+    let negz = -0.0f32;\n+    assert_eq(posz, negz);\n+    assert_ne!(posz.to_bits(), negz.to_bits());\n+    let posz = 0.0f64;\n+    let negz = -0.0f64;\n+    assert_eq(posz, negz);\n+    assert_ne!(posz.to_bits(), negz.to_bits());\n+    // byte-level transmute\n+    let x: u64 = unsafe { std::mem::transmute(42.0_f64) };\n+    let y: f64 = unsafe { std::mem::transmute(x) };\n+    assert_eq(y, 42.0_f64);\n+    let x: u32 = unsafe { std::mem::transmute(42.0_f32) };\n+    let y: f32 = unsafe { std::mem::transmute(x) };\n+    assert_eq(y, 42.0_f32);\n+}\n+\n+fn casts() {\n+    // f32 -> i8\n+    test_both_cast::<f32, i8>(127.99, 127);\n+    test_both_cast::<f32, i8>(-128.99, -128);\n+\n+    // f32 -> i32\n+    test_both_cast::<f32, i32>(0.0, 0);\n+    test_both_cast::<f32, i32>(-0.0, 0);\n+    test_both_cast::<f32, i32>(/*0x1p-149*/ f32::from_bits(0x00000001), 0);\n+    test_both_cast::<f32, i32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd), -1);\n+    test_both_cast::<f32, i32>(1.9, 1);\n+    test_both_cast::<f32, i32>(-1.9, -1);\n+    test_both_cast::<f32, i32>(5.0, 5);\n+    test_both_cast::<f32, i32>(-5.0, -5);\n+    test_both_cast::<f32, i32>(2147483520.0, 2147483520);\n+    test_both_cast::<f32, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f32 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483904.0f32 as i32, i32::MIN);\n+    assert_eq::<i32>(f32::MAX as i32, i32::MAX);\n+    assert_eq::<i32>(f32::MIN as i32, i32::MIN);\n+    assert_eq::<i32>(f32::INFINITY as i32, i32::MAX);\n+    assert_eq::<i32>(f32::NEG_INFINITY as i32, i32::MIN);\n+    assert_eq::<i32>(f32::NAN as i32, 0);\n+    assert_eq::<i32>((-f32::NAN) as i32, 0);\n+\n+    // f32 -> u32\n+    test_both_cast::<f32, u32>(0.0, 0);\n+    test_both_cast::<f32, u32>(-0.0, 0);\n+    test_both_cast::<f32, u32>(-0.9999999, 0);\n+    test_both_cast::<f32, u32>(/*0x1p-149*/ f32::from_bits(0x1), 0);\n+    test_both_cast::<f32, u32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, u32>(1.9, 1);\n+    test_both_cast::<f32, u32>(5.0, 5);\n+    test_both_cast::<f32, u32>(2147483648.0, 0x8000_0000);\n+    test_both_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n+    test_both_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n+    test_both_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n+    test_both_cast::<f32, u32>((u32::MAX - 128) as f32, u32::MAX - 255); // rounding loss\n+\n+    // unrepresentable casts:\n+\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u32>((u32::MAX - 127) as f32 as u32, u32::MAX);\n+\n+    assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n+    assert_eq::<u32>(-5.0f32 as u32, 0);\n+    assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n+    assert_eq::<u32>(f32::MIN as u32, 0);\n+    assert_eq::<u32>(f32::INFINITY as u32, u32::MAX);\n+    assert_eq::<u32>(f32::NEG_INFINITY as u32, 0);\n+    assert_eq::<u32>(f32::NAN as u32, 0);\n+    assert_eq::<u32>((-f32::NAN) as u32, 0);\n+\n+    // f32 -> i64\n+    test_both_cast::<f32, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f32, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f32, i64>(9223371487098961920.0, 9223371487098961920);\n+    test_both_cast::<f32, i64>(-9223372036854775808.0, -9223372036854775808);\n+\n+    // f64 -> i8\n+    test_both_cast::<f64, i8>(127.99, 127);\n+    test_both_cast::<f64, i8>(-128.99, -128);\n+\n+    // f64 -> i32\n+    test_both_cast::<f64, i32>(0.0, 0);\n+    test_both_cast::<f64, i32>(-0.0, 0);\n+    test_both_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i32>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i32>(1.9, 1);\n+    test_both_cast::<f64, i32>(-1.9, -1);\n+    test_both_cast::<f64, i32>(1e8, 100_000_000);\n+    test_both_cast::<f64, i32>(2147483647.0, 2147483647);\n+    test_both_cast::<f64, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f64 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483649.0f64 as i32, i32::MIN);\n+\n+    // f64 -> i64\n+    test_both_cast::<f64, i64>(0.0, 0);\n+    test_both_cast::<f64, i64>(-0.0, 0);\n+    test_both_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n+    test_both_cast::<f64, i64>(\n+        /*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001),\n+        0,\n+    );\n+    test_both_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i64>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i64>(5.0, 5);\n+    test_both_cast::<f64, i64>(5.9, 5);\n+    test_both_cast::<f64, i64>(-5.0, -5);\n+    test_both_cast::<f64, i64>(-5.9, -5);\n+    test_both_cast::<f64, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f64, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f64, i64>(9223372036854774784.0, 9223372036854774784);\n+    test_both_cast::<f64, i64>(-9223372036854775808.0, -9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<i64>(9223372036854775808.0f64 as i64, i64::MAX);\n+    assert_eq::<i64>(-9223372036854777856.0f64 as i64, i64::MIN);\n+    assert_eq::<i64>(f64::MAX as i64, i64::MAX);\n+    assert_eq::<i64>(f64::MIN as i64, i64::MIN);\n+    assert_eq::<i64>(f64::INFINITY as i64, i64::MAX);\n+    assert_eq::<i64>(f64::NEG_INFINITY as i64, i64::MIN);\n+    assert_eq::<i64>(f64::NAN as i64, 0);\n+    assert_eq::<i64>((-f64::NAN) as i64, 0);\n+\n+    // f64 -> u64\n+    test_both_cast::<f64, u64>(0.0, 0);\n+    test_both_cast::<f64, u64>(-0.0, 0);\n+    test_both_cast::<f64, u64>(-0.99999999999, 0);\n+    test_both_cast::<f64, u64>(5.0, 5);\n+    test_both_cast::<f64, u64>(1e16, 10000000000000000);\n+    test_both_cast::<f64, u64>((u64::MAX - 1024) as f64, u64::MAX - 2047); // rounding loss\n+    test_both_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<u64>(-5.0f64 as u64, 0);\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u64>((u64::MAX - 1023) as f64 as u64, u64::MAX);\n+    assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MIN as u64, 0);\n+    assert_eq::<u64>(f64::INFINITY as u64, u64::MAX);\n+    assert_eq::<u64>(f64::NEG_INFINITY as u64, 0);\n+    assert_eq::<u64>(f64::NAN as u64, 0);\n+    assert_eq::<u64>((-f64::NAN) as u64, 0);\n+\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // f64 -> i128\n+        assert_eq::<i128>(f64::MAX as i128, i128::MAX);\n+        assert_eq::<i128>(f64::MIN as i128, i128::MIN);\n+\n+        // f64 -> u128\n+        assert_eq::<u128>(f64::MAX as u128, u128::MAX);\n+        assert_eq::<u128>(f64::MIN as u128, 0);\n+    }\n+\n+    // int -> f32\n+    assert_eq::<f32>(127i8 as f32, 127.0);\n+    assert_eq::<f32>(2147483647i32 as f32, 2147483648.0);\n+    assert_eq::<f32>((-2147483648i32) as f32, -2147483648.0);\n+    assert_eq::<f32>(1234567890i32 as f32, /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06));\n+    assert_eq::<f32>(16777217i32 as f32, 16777216.0);\n+    assert_eq::<f32>((-16777217i32) as f32, -16777216.0);\n+    assert_eq::<f32>(16777219i32 as f32, 16777220.0);\n+    assert_eq::<f32>((-16777219i32) as f32, -16777220.0);\n+    assert_eq::<f32>(\n+        0x7fffff4000000001i64 as f32,\n+        /*0x1.fffffep+62*/ f32::from_bits(0x5effffff),\n+    );\n+    assert_eq::<f32>(\n+        0x8000004000000001u64 as i64 as f32,\n+        /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff),\n+    );\n+    assert_eq::<f32>(\n+        0x0020000020000001i64 as f32,\n+        /*0x1.000002p+53*/ f32::from_bits(0x5a000001),\n+    );\n+    assert_eq::<f32>(\n+        0xffdfffffdfffffffu64 as i64 as f32,\n+        /*-0x1.000002p+53*/ f32::from_bits(0xda000001),\n+    );\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        assert_eq::<f32>(i128::MIN as f32, -170141183460469231731687303715884105728.0f32);\n+        assert_eq::<f32>(u128::MAX as f32, f32::INFINITY); // saturation\n+    }\n+\n+    // int -> f64\n+    assert_eq::<f64>(127i8 as f64, 127.0);\n+    assert_eq::<f64>(i16::MIN as f64, -32768.0f64);\n+    assert_eq::<f64>(2147483647i32 as f64, 2147483647.0);\n+    assert_eq::<f64>(-2147483648i32 as f64, -2147483648.0);\n+    assert_eq::<f64>(987654321i32 as f64, 987654321.0);\n+    assert_eq::<f64>(9223372036854775807i64 as f64, 9223372036854775807.0);\n+    assert_eq::<f64>(-9223372036854775808i64 as f64, -9223372036854775808.0);\n+    assert_eq::<f64>(4669201609102990i64 as f64, 4669201609102990.0); // Feigenbaum (?)\n+    assert_eq::<f64>(9007199254740993i64 as f64, 9007199254740992.0);\n+    assert_eq::<f64>(-9007199254740993i64 as f64, -9007199254740992.0);\n+    assert_eq::<f64>(9007199254740995i64 as f64, 9007199254740996.0);\n+    assert_eq::<f64>(-9007199254740995i64 as f64, -9007199254740996.0);\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // even that fits...\n+        assert_eq::<f64>(u128::MAX as f64, 340282366920938463463374607431768211455.0f64);\n+    }\n+\n+    // f32 -> f64\n+    assert_eq::<u64>((0.0f32 as f64).to_bits(), 0.0f64.to_bits());\n+    assert_eq::<u64>(((-0.0f32) as f64).to_bits(), (-0.0f64).to_bits());\n+    assert_eq::<f64>(5.0f32 as f64, 5.0f64);\n+    assert_eq::<f64>(\n+        /*0x1p-149*/ f32::from_bits(0x1) as f64,\n+        /*0x1p-149*/ f64::from_bits(0x36a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1p-149*/ f32::from_bits(0x80000001) as f64,\n+        /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64,\n+        /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64,\n+        /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1p-119*/ f32::from_bits(0x4000000) as f64,\n+        /*0x1p-119*/ f64::from_bits(0x3880000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64,\n+        6.6382536710104395e+37,\n+    );\n+    assert_eq::<f64>(f32::INFINITY as f64, f64::INFINITY);\n+    assert_eq::<f64>(f32::NEG_INFINITY as f64, f64::NEG_INFINITY);\n+\n+    // f64 -> f32\n+    assert_eq::<u32>((0.0f64 as f32).to_bits(), 0.0f32.to_bits());\n+    assert_eq::<u32>(((-0.0f64) as f32).to_bits(), (-0.0f32).to_bits());\n+    assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n+    assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n+    assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n+    assert_eq::<f32>(\n+        /*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32,\n+        /*0x1p-149*/ f32::from_bits(0x800000),\n+    );\n+    assert_eq::<f32>(\n+        /*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32,\n+        /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728),\n+    );\n+    assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n+    assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::NEG_INFINITY as f32, f32::NEG_INFINITY);\n+}\n+\n+fn ops() {\n+    // f32 min/max\n+    assert_eq((1.0 as f32).max(-1.0), 1.0);\n+    assert_eq((1.0 as f32).min(-1.0), -1.0);\n+    assert_eq(f32::NAN.min(9.0), 9.0);\n+    assert_eq(f32::NAN.max(-9.0), -9.0);\n+    assert_eq((9.0 as f32).min(f32::NAN), 9.0);\n+    assert_eq((-9.0 as f32).max(f32::NAN), -9.0);\n+\n+    // f64 min/max\n+    assert_eq((1.0 as f64).max(-1.0), 1.0);\n+    assert_eq((1.0 as f64).min(-1.0), -1.0);\n+    assert_eq(f64::NAN.min(9.0), 9.0);\n+    assert_eq(f64::NAN.max(-9.0), -9.0);\n+    assert_eq((9.0 as f64).min(f64::NAN), 9.0);\n+    assert_eq((-9.0 as f64).max(f64::NAN), -9.0);\n+\n+    // f32 copysign\n+    assert_eq(3.5_f32.copysign(0.42), 3.5_f32);\n+    assert_eq(3.5_f32.copysign(-0.42), -3.5_f32);\n+    assert_eq((-3.5_f32).copysign(0.42), 3.5_f32);\n+    assert_eq((-3.5_f32).copysign(-0.42), -3.5_f32);\n+    assert!(f32::NAN.copysign(1.0).is_nan());\n+\n+    // f64 copysign\n+    assert_eq(3.5_f64.copysign(0.42), 3.5_f64);\n+    assert_eq(3.5_f64.copysign(-0.42), -3.5_f64);\n+    assert_eq((-3.5_f64).copysign(0.42), 3.5_f64);\n+    assert_eq((-3.5_f64).copysign(-0.42), -3.5_f64);\n+    assert!(f64::NAN.copysign(1.0).is_nan());\n+}\n+\n pub fn main() {\n+    basic();\n+    casts();\n+    ops();\n+\n     common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n     fptoui_tests!(f* -> u8 u16 u32 u64);\n     // FIXME emscripten does not support i128\n-    #[cfg(not(target_os=\"emscripten\"))] {\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n         common_fptoi_tests!(f* -> i128 u128);\n         fptoui_tests!(f* -> u128);\n     }\n@@ -123,7 +576,7 @@ pub fn main() {\n     test!(4294967296., f* -> u32, 4294967295);\n \n     // # u128\n-    #[cfg(not(target_os=\"emscripten\"))]\n+    #[cfg(not(target_os = \"emscripten\"))]\n     {\n         // float->int:\n         test_c!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);"}]}