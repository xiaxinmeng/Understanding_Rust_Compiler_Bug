{"sha": "8c705f83dbe1d8daef8ee0735abf8583a66f7732", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNzA1ZjgzZGJlMWQ4ZGFlZjhlZTA3MzVhYmY4NTgzYTY2Zjc3MzI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-08-09T19:23:19Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-08-09T21:05:35Z"}, "message": "Rustdoc: Fix natural ordering to look at all numbers.\n\nThe old implementation only looks at numbers at the end, but not in\nother places in a name: \"u8\" and \"u16\" got sorted properly, but \"u8_bla\"\nand \"u16_bla\" did not.", "tree": {"sha": "6056fcd222981161140b8584fd1a9e91d0e71431", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6056fcd222981161140b8584fd1a9e91d0e71431"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c705f83dbe1d8daef8ee0735abf8583a66f7732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c705f83dbe1d8daef8ee0735abf8583a66f7732", "html_url": "https://github.com/rust-lang/rust/commit/8c705f83dbe1d8daef8ee0735abf8583a66f7732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c705f83dbe1d8daef8ee0735abf8583a66f7732/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "543f03d24118d3af784aa98c507c00e30c796a0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/543f03d24118d3af784aa98c507c00e30c796a0e", "html_url": "https://github.com/rust-lang/rust/commit/543f03d24118d3af784aa98c507c00e30c796a0e"}], "stats": {"total": 92, "additions": 63, "deletions": 29}, "files": [{"sha": "f98ca8a5089d2fc46389ddd9c83c4c58ad691d31", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8c705f83dbe1d8daef8ee0735abf8583a66f7732/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c705f83dbe1d8daef8ee0735abf8583a66f7732/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8c705f83dbe1d8daef8ee0735abf8583a66f7732", "patch": "@@ -1903,23 +1903,41 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n     }\n }\n \n-fn name_key(name: &str) -> (&str, u64, usize) {\n-    let end = name.bytes().rposition(|b| b.is_ascii_digit()).map_or(name.len(), |i| i + 1);\n-\n-    // find number at end\n-    let split = name[0..end].bytes().rposition(|b| !b.is_ascii_digit()).map_or(0, |i| i + 1);\n-\n-    // count leading zeroes\n-    let after_zeroes =\n-        name[split..end].bytes().position(|b| b != b'0').map_or(name.len(), |extra| split + extra);\n-\n-    // sort leading zeroes last\n-    let num_zeroes = after_zeroes - split;\n-\n-    match name[split..end].parse() {\n-        Ok(n) => (&name[..split], n, num_zeroes),\n-        Err(_) => (name, 0, num_zeroes),\n+/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n+pub fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+    /// Takes a non-numeric and a numeric part from the given &str.\n+    fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n+        let i = s.find(|c: char| c.is_ascii_digit());\n+        let (a, b) = s.split_at(i.unwrap_or(s.len()));\n+        let i = b.find(|c: char| !c.is_ascii_digit());\n+        let (b, c) = b.split_at(i.unwrap_or(b.len()));\n+        *s = c;\n+        (a, b)\n+    }\n+\n+    while !lhs.is_empty() || !rhs.is_empty() {\n+        let (la, lb) = take_parts(&mut lhs);\n+        let (ra, rb) = take_parts(&mut rhs);\n+        // First process the non-numeric part.\n+        match la.cmp(ra) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+        // Then process the numeric part, if both sides have one (and they fit in a u64).\n+        if let (Ok(ln), Ok(rn)) = (lb.parse::<u64>(), rb.parse::<u64>()) {\n+            match ln.cmp(&rn) {\n+                Ordering::Equal => (),\n+                x => return x,\n+            }\n+        }\n+        // Then process the numeric part again, but this time as strings.\n+        match lb.cmp(rb) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n     }\n+\n+    Ordering::Equal\n }\n \n fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean::Item]) {\n@@ -1962,7 +1980,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n         }\n         let lhs = i1.name.as_ref().map_or(\"\", |s| &**s);\n         let rhs = i2.name.as_ref().map_or(\"\", |s| &**s);\n-        name_key(lhs).cmp(&name_key(rhs))\n+        compare_names(lhs, rhs)\n     }\n \n     if cx.shared.sort_modules_alphabetically {\n@@ -2395,7 +2413,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n     let rhs = format!(\"{}\", rhs.inner_impl().print());\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n-    name_key(&lhs).cmp(&name_key(&rhs))\n+    compare_names(&lhs, &rhs)\n }\n \n fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait, cache: &Cache) {"}, {"sha": "abf5f05fe58ab71e7f553f4a276278efbf6a1088", "filename": "src/librustdoc/html/render/tests.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8c705f83dbe1d8daef8ee0735abf8583a66f7732/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c705f83dbe1d8daef8ee0735abf8583a66f7732/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=8c705f83dbe1d8daef8ee0735abf8583a66f7732", "patch": "@@ -1,24 +1,40 @@\n use super::*;\n \n #[test]\n-fn test_name_key() {\n-    assert_eq!(name_key(\"0\"), (\"\", 0, 1));\n-    assert_eq!(name_key(\"123\"), (\"\", 123, 0));\n-    assert_eq!(name_key(\"Fruit\"), (\"Fruit\", 0, 0));\n-    assert_eq!(name_key(\"Fruit0\"), (\"Fruit\", 0, 1));\n-    assert_eq!(name_key(\"Fruit0000\"), (\"Fruit\", 0, 4));\n-    assert_eq!(name_key(\"Fruit01\"), (\"Fruit\", 1, 1));\n-    assert_eq!(name_key(\"Fruit10\"), (\"Fruit\", 10, 0));\n-    assert_eq!(name_key(\"Fruit123\"), (\"Fruit\", 123, 0));\n+fn test_compare_names() {\n+    for &(a, b) in &[\n+        (\"hello\", \"world\"),\n+        (\"\", \"world\"),\n+        (\"123\", \"hello\"),\n+        (\"123\", \"\"),\n+        (\"123test\", \"123\"),\n+        (\"hello\", \"\"),\n+        (\"hello\", \"hello\"),\n+        (\"hello123\", \"hello123\"),\n+        (\"hello123\", \"hello12\"),\n+        (\"hello12\", \"hello123\"),\n+        (\"hello01abc\", \"hello01xyz\"),\n+        (\"hello0abc\", \"hello0\"),\n+        (\"hello0\", \"hello0abc\"),\n+        (\"01\", \"1\"),\n+    ] {\n+        assert_eq!(compare_names(a, b), a.cmp(b), \"{:?} - {:?}\", a, b);\n+    }\n+    assert_eq!(compare_names(\"u8\", \"u16\"), Ordering::Less);\n+    assert_eq!(compare_names(\"u32\", \"u16\"), Ordering::Greater);\n+    assert_eq!(compare_names(\"u8_to_f64\", \"u16_to_f64\"), Ordering::Less);\n+    assert_eq!(compare_names(\"u32_to_f64\", \"u16_to_f64\"), Ordering::Greater);\n+    assert_eq!(compare_names(\"u16_to_f64\", \"u16_to_f64\"), Ordering::Equal);\n+    assert_eq!(compare_names(\"u16_to_f32\", \"u16_to_f64\"), Ordering::Less);\n }\n \n #[test]\n fn test_name_sorting() {\n     let names = [\n-        \"Apple\", \"Banana\", \"Fruit\", \"Fruit0\", \"Fruit00\", \"Fruit1\", \"Fruit01\", \"Fruit2\", \"Fruit02\",\n+        \"Apple\", \"Banana\", \"Fruit\", \"Fruit0\", \"Fruit00\", \"Fruit01\", \"Fruit1\", \"Fruit02\", \"Fruit2\",\n         \"Fruit20\", \"Fruit30x\", \"Fruit100\", \"Pear\",\n     ];\n     let mut sorted = names.to_owned();\n-    sorted.sort_by_key(|&s| name_key(s));\n+    sorted.sort_by(|&l, r| compare_names(l, r));\n     assert_eq!(names, sorted);\n }"}]}