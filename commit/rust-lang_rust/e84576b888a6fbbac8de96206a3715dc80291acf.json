{"sha": "e84576b888a6fbbac8de96206a3715dc80291acf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NDU3NmI4ODhhNmZiYmFjOGRlOTYyMDZhMzcxNWRjODAyOTFhY2Y=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-22T16:44:24Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-25T00:24:31Z"}, "message": "convert most of libstd over to structs", "tree": {"sha": "34b961b285e773517bc2d412549eb8a8477e2a8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34b961b285e773517bc2d412549eb8a8477e2a8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84576b888a6fbbac8de96206a3715dc80291acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84576b888a6fbbac8de96206a3715dc80291acf", "html_url": "https://github.com/rust-lang/rust/commit/e84576b888a6fbbac8de96206a3715dc80291acf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84576b888a6fbbac8de96206a3715dc80291acf/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15facb5c092f5d1e5b687111f4dbcd117d567d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c15facb5c092f5d1e5b687111f4dbcd117d567d7", "html_url": "https://github.com/rust-lang/rust/commit/c15facb5c092f5d1e5b687111f4dbcd117d567d7"}], "stats": {"total": 962, "additions": 544, "deletions": 418}, "files": [{"sha": "a62e5ff9d32740492aefdabdbe084010f0165db4", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -158,17 +158,10 @@ fn run_tests(config: config) {\n }\n \n fn test_opts(config: config) -> test::TestOpts {\n-    {filter:\n-         match config.filter {\n-           option::Some(s) => option::Some(s),\n-           option::None => option::None\n-         },\n-     run_ignored: config.run_ignored,\n-     logfile:\n-         match config.logfile {\n-           option::Some(s) => option::Some(s.to_str()),\n-           option::None => option::None\n-         }\n+    test::TestOpts {\n+        filter: config.filter,\n+        run_ignored: config.run_ignored,\n+        logfile: config.logfile.map(|s| s.to_str()),\n     }\n }\n "}, {"sha": "96fce53dd63b41ea7dd30e2217d630a0a6f18e7b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -287,7 +287,7 @@ fn get_lint_settings_level(settings: lint_settings,\n // This is kind of unfortunate. It should be somewhere else, or we should use\n // a persistent data structure...\n fn clone_lint_modes(modes: lint_modes) -> lint_modes {\n-    smallintmap::SmallIntMap_(@{v: copy modes.v})\n+    smallintmap::SmallIntMap_(@smallintmap::SmallIntMap_ { v: copy modes.v })\n }\n \n type ctxt_ = {dict: lint_dict,"}, {"sha": "eef84ae2422ee7fc81e189a8c28dc6dd4f0f4d98", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -68,7 +68,11 @@ const tydesc_drop_glue_index: size_t = 3 as size_t;\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-type Chunk = {data: @[u8], mut fill: uint, is_pod: bool};\n+struct Chunk {\n+    data: @[u8],\n+    mut fill: uint,\n+    is_pod: bool,\n+}\n \n pub struct Arena {\n     // The head is seperated out from the list as a unbenchmarked\n@@ -93,13 +97,19 @@ impl Arena : Drop {\n fn chunk(size: uint, is_pod: bool) -> Chunk {\n     let mut v: @[const u8] = @[];\n     unsafe { at_vec::raw::reserve(&mut v, size); }\n-    { data: unsafe { cast::transmute(v) }, mut fill: 0u, is_pod: is_pod }\n+    Chunk {\n+        data: unsafe { cast::transmute(v) },\n+        fill: 0u,\n+        is_pod: is_pod,\n+    }\n }\n \n pub fn arena_with_size(initial_size: uint) -> Arena {\n-    return Arena {mut head: chunk(initial_size, false),\n-                  mut pod_head: chunk(initial_size, true),\n-                  mut chunks: @Nil};\n+    Arena {\n+        head: chunk(initial_size, false),\n+        pod_head: chunk(initial_size, true),\n+        chunks: @Nil,\n+    }\n }\n \n pub fn Arena() -> Arena {"}, {"sha": "b4217dfb39d4a15dbd2c64a13efa5d6392d22748", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -61,10 +61,12 @@ pub fn create<T: Copy>() -> Deque<T> {\n         match (*elts).get_elt(i) { Some(move t) => t, _ => fail }\n     }\n \n-    type Repr<T> = {mut nelts: uint,\n-                    mut lo: uint,\n-                    mut hi: uint,\n-                    elts: DVec<Cell<T>>};\n+    struct Repr<T> {\n+        mut nelts: uint,\n+        mut lo: uint,\n+        mut hi: uint,\n+        elts: DVec<Cell<T>>,\n+    }\n \n     impl <T: Copy> Repr<T>: Deque<T> {\n         fn size() -> uint { return self.nelts; }\n@@ -119,15 +121,14 @@ pub fn create<T: Copy>() -> Deque<T> {\n         }\n     }\n \n-    let repr: Repr<T> = {\n-        mut nelts: 0u,\n-        mut lo: 0u,\n-        mut hi: 0u,\n-        elts:\n-            dvec::from_vec(\n-                vec::from_elem(initial_capacity, None))\n+    let repr: Repr<T> = Repr {\n+        nelts: 0u,\n+        lo: 0u,\n+        hi: 0u,\n+        elts: dvec::from_vec(vec::from_elem(initial_capacity, None)),\n     };\n-    (move repr) as Deque::<T>\n+\n+    repr as Deque::<T>\n }\n \n #[cfg(test)]\n@@ -254,7 +255,11 @@ mod tests {\n         Onepar(int), Twopar(int, int), Threepar(int, int, int),\n     }\n \n-    type RecCy = {x: int, y: int, t: Taggy};\n+    struct RecCy {\n+        x: int,\n+        y: int,\n+        t: Taggy,\n+    }\n \n     impl Taggy : Eq {\n         pure fn eq(&self, other: &Taggy) -> bool {\n@@ -335,10 +340,10 @@ mod tests {\n \n     #[test]\n     fn test_param_reccy() {\n-        let reccy1: RecCy = {x: 1, y: 2, t: One(1)};\n-        let reccy2: RecCy = {x: 345, y: 2, t: Two(1, 2)};\n-        let reccy3: RecCy = {x: 1, y: 777, t: Three(1, 2, 3)};\n-        let reccy4: RecCy = {x: 19, y: 252, t: Two(17, 42)};\n+        let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n+        let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n+        let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n+        let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n         test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n     }\n }"}, {"sha": "3c890ef06541f4e81613b5c9ca56cc5c12671818", "filename": "src/libstd/map.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -107,7 +107,11 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n }\n \n pub mod util {\n-    pub type Rational = {num: int, den: int}; // : int::positive(*.den);\n+    pub struct Rational {\n+        // : int::positive(*.den);\n+        num: int,\n+        den: int,\n+    }\n \n     pub pure fn rational_leq(x: Rational, y: Rational) -> bool {\n         // NB: Uses the fact that rationals have positive denominators WLOG:\n@@ -265,9 +269,11 @@ pub mod chained {\n \n                 // consider rehashing if more 3/4 full\n                 let nchains = vec::len(self.chains);\n-                let load = {num: (self.count + 1u) as int,\n-                            den: nchains as int};\n-                if !util::rational_leq(load, {num:3, den:4}) {\n+                let load = util::Rational {\n+                    num: (self.count + 1u) as int,\n+                    den: nchains as int,\n+                };\n+                if !util::rational_leq(load, util::Rational {num:3, den:4}) {\n                     self.rehash();\n                 }\n \n@@ -324,9 +330,11 @@ pub mod chained {\n \n                 // consider rehashing if more 3/4 full\n                 let nchains = vec::len(self.chains);\n-                let load = {num: (self.count + 1u) as int,\n-                            den: nchains as int};\n-                if !util::rational_leq(load, {num:3, den:4}) {\n+                let load = util::Rational {\n+                    num: (self.count + 1u) as int,\n+                    den: nchains as int,\n+                };\n+                if !util::rational_leq(load, util::Rational {num:3, den:4}) {\n                     self.rehash();\n                 }\n "}, {"sha": "84c3b75564984a82572875270f45bda7b1f20da1", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -48,9 +48,9 @@ pub enum IpAddr {\n }\n \n /// Human-friendly feedback on why a parse_addr attempt failed\n-pub type ParseAddrErr = {\n-    err_msg: ~str\n-};\n+pub struct ParseAddrErr {\n+    err_msg: ~str,\n+}\n \n /**\n  * Convert a `IpAddr` to a str\n@@ -122,7 +122,7 @@ pub fn get_addr(node: &str, iotask: iotask)\n                 log(debug, fmt!(\"slice len %?\", len));\n                 let handle = create_uv_getaddrinfo_t();\n                 let handle_ptr = ptr::addr_of(&handle);\n-                let handle_data: GetAddrData = {\n+                let handle_data = GetAddrData {\n                     output_ch: output_ch\n                 };\n                 let handle_data_ptr = ptr::addr_of(&handle_data);\n@@ -187,7 +187,7 @@ pub mod v4 {\n     }\n     // the simple, old style numberic representation of\n     // ipv4\n-    pub type Ipv4Rep = { a: u8, b: u8, c: u8, d:u8 };\n+    pub struct Ipv4Rep { a: u8, b: u8, c: u8, d: u8 }\n \n     pub trait AsUnsafeU32 {\n         unsafe fn as_u32() -> u32;\n@@ -207,14 +207,14 @@ pub mod v4 {\n             }\n         });\n         if parts.len() != 4 {\n-                result::Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n-                }\n-        else if parts.contains(&256) {\n-                result::Err(fmt!(\"invalid octal in addr '%s'\", ip))\n-                }\n-        else {\n-            result::Ok({a: parts[0] as u8, b: parts[1] as u8,\n-                        c: parts[2] as u8, d: parts[3] as u8})\n+            Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n+        } else if parts.contains(&256) {\n+            Err(fmt!(\"invalid octal in addr '%s'\", ip))\n+        } else {\n+            Ok(Ipv4Rep {\n+                a: parts[0] as u8, b: parts[1] as u8,\n+                c: parts[2] as u8, d: parts[3] as u8,\n+            })\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n@@ -223,7 +223,7 @@ pub mod v4 {\n             let ip_rep_result = parse_to_ipv4_rep(ip);\n             if result::is_err(&ip_rep_result) {\n                 let err_str = result::get_err(&ip_rep_result);\n-                return result::Err({err_msg: err_str})\n+                return result::Err(ParseAddrErr { err_msg: err_str })\n             }\n             // ipv4_rep.as_u32 is unsafe :/\n             let input_is_inaddr_none =\n@@ -236,15 +236,16 @@ pub mod v4 {\n             let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n             if result::is_err(&ref_ip_rep_result) {\n                 let err_str = result::get_err(&ref_ip_rep_result);\n-                return result::Err({err_msg: err_str})\n+                return Err(ParseAddrErr { err_msg: err_str })\n             }\n+\n             if result::get(&ref_ip_rep_result).as_u32() == INADDR_NONE &&\n                  !input_is_inaddr_none {\n-                return result::Err(\n-                    {err_msg: ~\"uv_ip4_name produced invalid result.\"})\n-            }\n-            else {\n-                result::Ok(Ipv4(copy(new_addr)))\n+                Err(ParseAddrErr {\n+                    err_msg: ~\"uv_ip4_name produced invalid result.\",\n+                })\n+            } else {\n+                Ok(Ipv4(copy(new_addr)))\n             }\n         }\n     }\n@@ -289,19 +290,18 @@ pub mod v6 {\n             // '::' appears to be uv_ip6_name() returns for bogus\n             // parses..\n             if  ip != &\"::\" && reparsed_name == ~\"::\" {\n-                result::Err({err_msg:fmt!(\"failed to parse '%s'\",\n-                                           ip)})\n+                Err(ParseAddrErr { err_msg:fmt!(\"failed to parse '%s'\", ip) })\n             }\n             else {\n-                result::Ok(Ipv6(new_addr))\n+                Ok(Ipv6(new_addr))\n             }\n         }\n     }\n }\n \n-type GetAddrData = {\n+struct GetAddrData {\n     output_ch: oldcomm::Chan<result::Result<~[IpAddr],IpGetAddrErr>>\n-};\n+}\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                       res: *addrinfo) {"}, {"sha": "aa5eec2b43ce2f701ecbf53472e1514daba48ee5", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -83,10 +83,11 @@ pub fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n }\n \n /// Contains raw, string-based, error information returned from libuv\n-pub type TcpErrData = {\n+pub struct TcpErrData {\n     err_name: ~str,\n-    err_msg: ~str\n-};\n+    err_msg: ~str,\n+}\n+\n /// Details returned as part of a `result::err` result from `tcp::listen`\n pub enum TcpListenErrData {\n     /**\n@@ -155,7 +156,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         let reader_po = oldcomm::Port::<result::Result<~[u8], TcpErrData>>();\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-        let socket_data = @{\n+        let socket_data = @TcpSocketData {\n             reader_po: reader_po,\n             reader_ch: oldcomm::Chan(&reader_po),\n             stream_handle_ptr: stream_handle_ptr,\n@@ -231,7 +232,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                         // ip or somesuch\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n                         oldcomm::send((*conn_data_ptr).result_ch,\n-                                   ConnFailure(err_data.to_tcp_err()));\n+                                   ConnFailure(err_data));\n                         uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                                        conn_data_ptr);\n                         uv::ll::close(stream_handle_ptr,\n@@ -243,7 +244,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                     // failure to create a tcp handle\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n                     oldcomm::send((*conn_data_ptr).result_ch,\n-                               ConnFailure(err_data.to_tcp_err()));\n+                               ConnFailure(err_data));\n                   }\n                 }\n             }\n@@ -513,7 +514,7 @@ pub fn accept(new_conn: TcpNewConnection)\n             let iotask = (*server_data_ptr).iotask;\n             let stream_handle_ptr = malloc_uv_tcp_t();\n             *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-            let client_socket_data = @{\n+            let client_socket_data = @TcpSocketData {\n                 reader_po: reader_po,\n                 reader_ch: oldcomm::Chan(&reader_po),\n                 stream_handle_ptr : stream_handle_ptr,\n@@ -785,7 +786,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n-    TcpSocketBuf(@{ sock: move sock, mut buf: ~[] })\n+    TcpSocketBuf(@TcpBufferedSocketData { sock: sock, buf: ~[] })\n }\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n@@ -979,7 +980,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n             match move read_result {\n               None => {\n                 log(debug, ~\"tcp::read: timed out..\");\n-                let err_data = {\n+                let err_data = TcpErrData {\n                     err_name: ~\"TIMEOUT\",\n                     err_msg: ~\"req timed out\"\n                 };\n@@ -1020,9 +1021,10 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n                 }\n             }\n         };\n+\n         match oldcomm::recv(stop_po) {\n-          Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n-          None => result::Ok(())\n+          Some(move err_data) => Err(err_data),\n+          None => Ok(())\n         }\n     }\n }\n@@ -1108,8 +1110,8 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         // ownership of everything to the I/O task and let it deal with the\n         // aftermath, so we don't have to sit here blocking.\n         match oldcomm::recv(result_po) {\n-          TcpWriteSuccess => result::Ok(()),\n-          TcpWriteError(ref err_data) => result::Err(err_data.to_tcp_err())\n+            TcpWriteSuccess => Ok(()),\n+            TcpWriteError(move err_data) => Err(err_data)\n         }\n     }\n }\n@@ -1118,15 +1120,15 @@ enum TcpNewConnection {\n     NewTcpConn(*uv::ll::uv_tcp_t)\n }\n \n-type TcpListenFcData = {\n+struct TcpListenFcData {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n     stream_closed_ch: oldcomm::Chan<()>,\n     kill_ch: oldcomm::Chan<Option<TcpErrData>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n     ipv6: bool,\n-    mut active: bool\n-};\n+    mut active: bool,\n+}\n \n extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n@@ -1191,7 +1193,7 @@ trait ToTcpErr {\n \n impl uv::ll::uv_err_data: ToTcpErr {\n     fn to_tcp_err() -> TcpErrData {\n-        { err_name: self.err_name, err_msg: self.err_msg }\n+        TcpErrData { err_name: self.err_name, err_msg: self.err_msg }\n     }\n }\n \n@@ -1244,9 +1246,9 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n     }\n }\n \n-type TcpSocketCloseData = {\n-    closed_ch: oldcomm::Chan<()>\n-};\n+struct TcpSocketCloseData {\n+    closed_ch: oldcomm::Chan<()>,\n+}\n \n extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n@@ -1273,19 +1275,19 @@ extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             log(debug, ~\"failure to write\");\n             oldcomm::send((*write_data_ptr).result_ch,\n-                             TcpWriteError(err_data));\n+                             TcpWriteError(err_data.to_tcp_err()));\n         }\n     }\n }\n \n-type WriteReqData = {\n-    result_ch: oldcomm::Chan<TcpWriteResult>\n-};\n+struct WriteReqData {\n+    result_ch: oldcomm::Chan<TcpWriteResult>,\n+}\n \n-type ConnectReqData = {\n+struct ConnectReqData {\n     result_ch: oldcomm::Chan<ConnAttempt>,\n-    closed_signal_ch: oldcomm::Chan<()>\n-};\n+    closed_signal_ch: oldcomm::Chan<()>,\n+}\n \n extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n@@ -1337,20 +1339,20 @@ enum ConnAttempt {\n     ConnFailure(uv::ll::uv_err_data)\n }\n \n-type TcpSocketData = {\n+struct TcpSocketData {\n     reader_po: oldcomm::Port<result::Result<~[u8], TcpErrData>>,\n     reader_ch: oldcomm::Chan<result::Result<~[u8], TcpErrData>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n     ipv6: bool,\n-    iotask: IoTask\n-};\n+    iotask: IoTask,\n+}\n \n-type TcpBufferedSocketData = {\n+struct TcpBufferedSocketData {\n     sock: TcpSocket,\n-    mut buf: ~[u8]\n-};\n+    mut buf: ~[u8],\n+}\n \n //#[cfg(test)]\n pub mod test {"}, {"sha": "8c6d77c8828384a988bff20cf7c4c1d718c4f838", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 72, "deletions": 66, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -595,12 +595,12 @@ pub mod node {\n      *     string can be shared between several ropes, e.g. for indexing\n      *     purposes.\n      */\n-    pub type Leaf = {\n+    pub struct Leaf {\n         byte_offset: uint,\n-        byte_len:    uint,\n-        char_len:   uint,\n-        content:    @~str\n-    };\n+        byte_len: uint,\n+        char_len: uint,\n+        content: @~str,\n+    }\n \n     /**\n      * A node obtained from the concatenation of two other nodes\n@@ -619,14 +619,14 @@ pub mod node {\n      *\n      *     Used for rebalancing and to allocate stacks for traversals.\n      */\n-    pub type Concat = {\n+    pub struct Concat {\n         //FIXME (#2744): Perhaps a `vec` instead of `left`/`right`\n-        left:     @Node,\n-        right:    @Node,\n+        left: @Node,\n+        right: @Node,\n         char_len: uint,\n         byte_len: uint,\n-        height:   uint\n-    };\n+        height: uint,\n+    }\n \n     pub enum Node {\n         /// A leaf consisting in a `str`\n@@ -709,11 +709,12 @@ pub mod node {\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n         assert(byte_start + byte_len <= str::len(*str));\n-        let candidate = @Leaf({\n-                byte_offset: byte_start,\n-                byte_len:    byte_len,\n-                char_len:    char_len,\n-                content:     str});\n+        let candidate = @Leaf(Leaf {\n+            byte_offset: byte_start,\n+            byte_len: byte_len,\n+            char_len: char_len,\n+            content: str,\n+        });\n         if char_len <= hint_max_leaf_char_len {\n             return candidate;\n         } else {\n@@ -736,11 +737,11 @@ pub mod node {\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n                     str::count_bytes(*str, offset, chunk_char_len);\n-                nodes[i] = @Leaf({\n+                nodes[i] = @Leaf(Leaf {\n                     byte_offset: offset,\n-                    byte_len:    chunk_byte_len,\n-                    char_len:    chunk_char_len,\n-                    content:     str\n+                    byte_len: chunk_byte_len,\n+                    char_len: chunk_char_len,\n+                    content: str,\n                 });\n \n                 offset += chunk_byte_len;\n@@ -767,15 +768,15 @@ pub mod node {\n     pub pure fn byte_len(node: @Node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         match (*node) {\n-          Leaf(y)   => return y.byte_len,\n-          Concat(ref y) => return y.byte_len\n+          Leaf(y) => y.byte_len,\n+          Concat(ref y) => y.byte_len\n         }\n     }\n \n     pub pure fn char_len(node: @Node) -> uint {\n         match (*node) {\n-          Leaf(y)   => return y.char_len,\n-          Concat(ref y) => return y.char_len\n+          Leaf(y) => y.char_len,\n+          Concat(ref y) => y.char_len\n         }\n     }\n \n@@ -867,15 +868,15 @@ pub mod node {\n     pub fn flatten(node: @Node) -> @Node {\n         unsafe {\n             match (*node) {\n-              Leaf(_) => return node,\n-              Concat(ref x) => {\n-                return @Leaf({\n-                    byte_offset: 0u,\n-                    byte_len:    x.byte_len,\n-                    char_len:    x.char_len,\n-                    content:     @serialize_node(node)\n-                })\n-              }\n+                Leaf(_) => node,\n+                Concat(ref x) => {\n+                    @Leaf(Leaf {\n+                        byte_offset: 0u,\n+                        byte_len: x.byte_len,\n+                        char_len: x.char_len,\n+                        content: @serialize_node(node),\n+                    })\n+                }\n             }\n         }\n     }\n@@ -943,10 +944,12 @@ pub mod node {\n               node::Leaf(x) => {\n                 let char_len =\n                     str::count_chars(*x.content, byte_offset, byte_len);\n-                return @Leaf({byte_offset: byte_offset,\n-                                byte_len:    byte_len,\n-                                char_len:    char_len,\n-                                content:     x.content});\n+                return @Leaf(Leaf {\n+                    byte_offset: byte_offset,\n+                    byte_len: byte_len,\n+                    char_len: char_len,\n+                    content: x.content,\n+                });\n               }\n               node::Concat(ref x) => {\n                 let left_len: uint = node::byte_len(x.left);\n@@ -1007,10 +1010,12 @@ pub mod node {\n                     str::count_bytes(*x.content, 0u, char_offset);\n                 let byte_len    =\n                     str::count_bytes(*x.content, byte_offset, char_len);\n-                return @Leaf({byte_offset: byte_offset,\n-                           byte_len:    byte_len,\n-                           char_len:    char_len,\n-                           content:     x.content});\n+                return @Leaf(Leaf {\n+                    byte_offset: byte_offset,\n+                    byte_len: byte_len,\n+                    char_len: char_len,\n+                    content: x.content,\n+                });\n               }\n               node::Concat(ref x) => {\n                 if char_offset == 0u && char_len == x.char_len {return node;}\n@@ -1040,18 +1045,19 @@ pub mod node {\n     }\n \n     pub fn concat2(left: @Node, right: @Node) -> @Node {\n-        return @Concat({left    : left,\n-                     right   : right,\n-             char_len: char_len(left) + char_len(right),\n-                     byte_len: byte_len(left) + byte_len(right),\n-             height: uint::max(height(left), height(right)) + 1u\n-                    })\n+        @Concat(Concat {\n+            left: left,\n+            right: right,\n+            char_len: char_len(left) + char_len(right),\n+            byte_len: byte_len(left) + byte_len(right),\n+            height: uint::max(height(left), height(right)) + 1u,\n+        })\n     }\n \n     pub pure fn height(node: @Node) -> uint {\n         match (*node) {\n-          Leaf(_)   => return 0u,\n-          Concat(ref x) => return x.height\n+          Leaf(_) => 0u,\n+          Concat(ref x) => x.height,\n         }\n     }\n \n@@ -1135,7 +1141,7 @@ pub mod node {\n         loop {\n             match *node {\n               Leaf(x) => return str::char_at(*x.content, pos),\n-              Concat({left, right, _}) => {\n+              Concat(Concat {left, right, _}) => {\n                 let left_len = char_len(left);\n                 node = if left_len > pos { left }\n                        else { pos -= left_len; right };\n@@ -1151,22 +1157,22 @@ pub mod node {\n         use core::prelude::*;\n         use core::vec;\n \n-        pub type T = {\n-            stack:            ~[mut @Node],\n-            mut stackpos: int\n-        };\n+        pub struct T {\n+            stack: ~[mut @Node],\n+            mut stackpos: int,\n+        }\n \n         pub fn empty() -> T {\n             let stack : ~[mut @Node] = ~[mut];\n-            return {stack: move stack, mut stackpos: -1}\n+            T { stack: stack, stackpos: -1 }\n         }\n \n         pub fn start(node: @Node) -> T {\n             let stack = vec::cast_to_mut(\n                 vec::from_elem(height(node)+1u, node));\n-            return {\n-                stack:         move stack,\n-                mut stackpos:  0\n+            T {\n+                stack: stack,\n+                stackpos:  0,\n             }\n         }\n \n@@ -1196,25 +1202,25 @@ pub mod node {\n         use core::prelude::*;\n         use core::str;\n \n-        pub type T = {\n+        pub struct T {\n             leaf_iterator: leaf_iterator::T,\n             mut leaf:  Option<Leaf>,\n-            mut leaf_byte_pos: uint\n-        };\n+            mut leaf_byte_pos: uint,\n+        }\n \n         pub fn start(node: @Node) -> T {\n-            return {\n+            T {\n                 leaf_iterator: leaf_iterator::start(node),\n-                mut leaf:          option::None,\n-                mut leaf_byte_pos: 0u\n+                leaf: option::None,\n+                leaf_byte_pos: 0u,\n             }\n         }\n \n         pub fn empty() -> T {\n-            return {\n+            T {\n                 leaf_iterator: leaf_iterator::empty(),\n-                mut leaf:  option::None,\n-                mut leaf_byte_pos: 0u\n+                leaf:  option::None,\n+                leaf_byte_pos: 0u,\n             }\n         }\n "}, {"sha": "51c209b1b5f476684c2480594a9b8bfaee7774f7", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 60, "deletions": 40, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -284,7 +284,10 @@ mod tests {\n     #[test]\n     fn test() {\n         unsafe {\n-            type Test = {input: ~str, output: ~[u8]};\n+            struct Test {\n+                input: ~str,\n+                output: ~[u8],\n+            }\n \n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n@@ -297,47 +300,64 @@ mod tests {\n             }\n             // Test messages from FIPS 180-1\n \n-            let fips_180_1_tests: ~[Test] =\n-                ~[{input: ~\"abc\",\n-                  output:\n-                      ~[0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                       0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                       0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                       0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                       0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n-                 {input:\n-                      ~\"abcdbcdecdefdefgefghfghighij\" +\n-                      ~\"hijkijkljklmklmnlmnomnopnopq\",\n-                  output:\n-                      ~[0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                       0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                       0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                       0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                       0xE5u8, 0x46u8, 0x70u8, 0xF1u8]},\n-                 {input: a_million_letter_a(),\n-                  output:\n-                      ~[0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                       0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                       0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                       0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                       0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n+            let fips_180_1_tests = ~[\n+                Test {\n+                    input: ~\"abc\",\n+                    output: ~[\n+                        0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                        0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                        0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                        0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                        0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n+                    ],\n+                },\n+                Test {\n+                    input:\n+                         ~\"abcdbcdecdefdefgefghfghighij\" +\n+                         ~\"hijkijkljklmklmnlmnomnopnopq\",\n+                    output: ~[\n+                        0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                        0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                        0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                        0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                        0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n+                    ],\n+                },\n+                Test {\n+                    input: a_million_letter_a(),\n+                    output: ~[\n+                        0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                        0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                        0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                        0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                        0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n+                    ],\n+                },\n+            ];\n             // Examples from wikipedia\n \n-            let wikipedia_tests: ~[Test] =\n-                ~[{input: ~\"The quick brown fox jumps over the lazy dog\",\n-                  output:\n-                      ~[0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                       0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                       0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                       0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                       0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n-                 {input: ~\"The quick brown fox jumps over the lazy cog\",\n-                  output:\n-                      ~[0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                       0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                       0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                       0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                       0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n+            let wikipedia_tests = ~[\n+                Test {\n+                    input: ~\"The quick brown fox jumps over the lazy dog\",\n+                    output: ~[\n+                        0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                        0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                        0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                        0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                        0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n+                    ],\n+                },\n+                Test {\n+                    input: ~\"The quick brown fox jumps over the lazy cog\",\n+                    output: ~[\n+                        0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                        0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                        0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                        0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                        0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n+                    ],\n+                },\n+            ];\n             let tests = fips_180_1_tests + wikipedia_tests;\n             fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n                 assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));"}, {"sha": "feabb678d6686e05128bae31eb0d0a280adf97f7", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -25,7 +25,9 @@ use core::prelude::*;\n \n // FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n // requires this to be.\n-type SmallIntMap_<T: Copy> = {v: DVec<Option<T>>};\n+struct SmallIntMap_<T: Copy> {\n+    v: DVec<Option<T>>,\n+}\n \n pub enum SmallIntMap<T:Copy> {\n     SmallIntMap_(@SmallIntMap_<T>)\n@@ -34,7 +36,7 @@ pub enum SmallIntMap<T:Copy> {\n /// Create a smallintmap\n pub fn mk<T: Copy>() -> SmallIntMap<T> {\n     let v = DVec();\n-    return SmallIntMap_(@{v: move v});\n+    SmallIntMap_(@SmallIntMap_ { v: v } )\n }\n \n /**"}, {"sha": "7b94702f974b4b371c14b36d9557baa796249982", "filename": "src/libstd/test.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -74,8 +74,11 @@ pub fn test_main(args: &[~str], tests: &[TestDesc]) {\n     if !run_tests_console(&opts, tests) { fail ~\"Some tests failed\"; }\n }\n \n-pub type TestOpts = {filter: Option<~str>, run_ignored: bool,\n-                  logfile: Option<~str>};\n+pub struct TestOpts {\n+    filter: Option<~str>,\n+    run_ignored: bool,\n+    logfile: Option<~str>,\n+}\n \n type OptRes = Either<TestOpts, ~str>;\n \n@@ -97,10 +100,13 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let run_ignored = getopts::opt_present(&matches, ~\"ignored\");\n     let logfile = getopts::opt_maybe_str(&matches, ~\"logfile\");\n \n-    let test_opts = {filter: filter, run_ignored: run_ignored,\n-                     logfile: logfile};\n+    let test_opts = TestOpts {\n+        filter: filter,\n+        run_ignored: run_ignored,\n+        logfile: logfile,\n+    };\n \n-    return either::Left(test_opts);\n+    either::Left(test_opts)\n }\n \n #[deriving_eq]\n@@ -396,7 +402,10 @@ pub fn filter_tests(opts: &TestOpts,\n     move filtered\n }\n \n-type TestFuture = {test: TestDesc, wait: fn@() -> TestResult};\n+struct TestFuture {\n+    test: TestDesc,\n+    wait: fn@() -> TestResult,\n+}\n \n pub fn run_test(test: TestDesc, monitor_ch: oldcomm::Chan<MonitorMsg>) {\n     if test.ignore {\n@@ -431,7 +440,7 @@ mod tests {\n     #[legacy_exports];\n \n     use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc};\n-    use test::{run_test};\n+    use test::{TestOpts, run_test};\n \n     use core::either;\n     use core::oldcomm;\n@@ -528,13 +537,26 @@ mod tests {\n         // When we run ignored tests the test filter should filter out all the\n         // unignored tests and flip the ignore flag on the rest to false\n \n-        let opts = {filter: option::None, run_ignored: true,\n-            logfile: option::None};\n-        let tests =\n-            ~[TestDesc {name: ~\"1\", testfn: fn~() { },\n-                        ignore: true, should_fail: false},\n-              TestDesc {name: ~\"2\", testfn: fn~() { },\n-                        ignore: false, should_fail: false}];\n+        let opts = TestOpts {\n+            filter: option::None,\n+            run_ignored: true,\n+            logfile: option::None,\n+        };\n+\n+        let tests = ~[\n+            TestDesc {\n+                name: ~\"1\",\n+                testfn: fn~() { },\n+                ignore: true,\n+                should_fail: false,\n+            },\n+            TestDesc {\n+                name: ~\"2\",\n+                testfn: fn~() { },\n+                ignore: false,\n+                should_fail: false,\n+            },\n+        ];\n         let filtered = filter_tests(&opts, tests);\n \n         assert (vec::len(filtered) == 1u);\n@@ -544,8 +566,11 @@ mod tests {\n \n     #[test]\n     fn sort_tests() {\n-        let opts = {filter: option::None, run_ignored: false,\n-            logfile: option::None};\n+        let opts = TestOpts {\n+            filter: option::None,\n+            run_ignored: false,\n+            logfile: option::None,\n+        };\n \n         let names =\n             ~[~\"sha1::test\", ~\"int::test_to_str\", ~\"int::test_pow\","}, {"sha": "0a3d64a02a4eab4862a81a1b67b2e171a11ae886", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -111,7 +111,7 @@ fn run_loop(iotask_ch: Chan<IoTask>) {\n         ll::async_init(loop_ptr, async_handle, wake_up_cb);\n \n         // initialize our loop data and store it in the loop\n-        let data: IoTaskLoopData = {\n+        let data = IoTaskLoopData {\n             async_handle: async_handle,\n             msg_po: Port()\n         };\n@@ -134,10 +134,10 @@ fn run_loop(iotask_ch: Chan<IoTask>) {\n }\n \n // data that lives for the lifetime of the high-evel oo\n-type IoTaskLoopData = {\n+struct IoTaskLoopData {\n     async_handle: *ll::uv_async_t,\n-    msg_po: Port<IoTaskMsg>\n-};\n+    msg_po: Port<IoTaskMsg>,\n+}\n \n fn send_msg(iotask: IoTask, msg: IoTaskMsg) {\n     unsafe {\n@@ -214,10 +214,10 @@ mod test {\n             ll::close(handle, async_close_cb);\n         }\n     }\n-    type AhData = {\n+    struct AhData {\n         iotask: IoTask,\n-        exit_ch: oldcomm::Chan<()>\n-    };\n+        exit_ch: oldcomm::Chan<()>,\n+    }\n     fn impl_uv_iotask_async(iotask: IoTask) {\n         unsafe {\n             let async_handle = ll::async_t();"}, {"sha": "5060ae1a7227934b15e5abc7a00c9866b344def3", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 243, "deletions": 188, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84576b888a6fbbac8de96206a3715dc80291acf/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=e84576b888a6fbbac8de96206a3715dc80291acf", "patch": "@@ -41,10 +41,10 @@ use core::str;\n use core::vec;\n \n // libuv struct mappings\n-pub type uv_ip4_addr = {\n+pub struct uv_ip4_addr {\n     ip: ~[u8],\n-    port: int\n-};\n+    port: int,\n+}\n pub type uv_ip6_addr = uv_ip4_addr;\n \n pub enum uv_handle_type {\n@@ -67,31 +67,31 @@ pub enum uv_handle_type {\n \n pub type handle_type = libc::c_uint;\n \n-pub type uv_handle_fields = {\n+pub struct uv_handle_fields {\n    loop_handle: *libc::c_void,\n    type_: handle_type,\n    close_cb: *u8,\n    mut data: *libc::c_void,\n-};\n+}\n \n // unix size: 8\n-pub type uv_err_t = {\n+pub struct uv_err_t {\n     code: libc::c_int,\n     sys_errno_: libc::c_int\n-};\n+}\n \n // don't create one of these directly. instead,\n // count on it appearing in libuv callbacks or embedded\n // in other types as a pointer to be used in other\n // operations (so mostly treat it as opaque, once you\n // have it in this form..)\n-pub type uv_stream_t = {\n-    fields: uv_handle_fields\n-};\n+pub struct uv_stream_t {\n+    fields: uv_handle_fields,\n+}\n \n // 64bit unix size: 272\n #[cfg(unix)]\n-pub type uv_tcp_t = {\n+pub struct uv_tcp_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n@@ -101,191 +101,191 @@ pub type uv_tcp_t = {\n     a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n     a24: *u8, a25: *u8, a26: *u8, a27: *u8,\n     a28: *u8,\n-    a30: uv_tcp_t_32bit_unix_riders\n-};\n+    a30: uv_tcp_t_32bit_unix_riders,\n+}\n // 32bit unix size: 328 (164)\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_tcp_t_32bit_unix_riders = {\n-    a29: *u8\n-};\n+pub struct uv_tcp_t_32bit_unix_riders {\n+    a29: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_tcp_t_32bit_unix_riders = {\n+pub struct uv_tcp_t_32bit_unix_riders {\n     a29: *u8, a30: *u8, a31: *u8,\n     a32: *u8, a33: *u8, a34: *u8,\n-    a35: *u8, a36: *u8\n-};\n+    a35: *u8, a36: *u8,\n+}\n \n // 32bit win32 size: 240 (120)\n #[cfg(windows)]\n-pub type uv_tcp_t = {\n+pub struct uv_tcp_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n     a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n     a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n     a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n-    a24: *u8, a25: *u8\n-};\n+    a24: *u8, a25: *u8,\n+}\n \n // unix size: 48\n #[cfg(unix)]\n-pub type uv_connect_t = {\n+pub struct uv_connect_t {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8\n-};\n+    a04: *u8, a05: *u8,\n+}\n // win32 size: 88 (44)\n #[cfg(windows)]\n-pub type uv_connect_t = {\n+pub struct uv_connect_t {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8\n-};\n+    a08: *u8, a09: *u8, a10: *u8,\n+}\n \n // unix size: 16\n-pub type uv_buf_t = {\n+pub struct uv_buf_t {\n     base: *u8,\n-    len: libc::size_t\n-};\n+    len: libc::size_t,\n+}\n // no gen stub method.. should create\n // it via uv::direct::buf_init()\n \n // unix size: 144\n #[cfg(unix)]\n-pub type uv_write_t = {\n+pub struct uv_write_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n     a12: *u8,\n-    a14: uv_write_t_32bit_unix_riders\n-};\n+    a14: uv_write_t_32bit_unix_riders,\n+}\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_write_t_32bit_unix_riders = {\n-    a13: *u8\n-};\n+pub struct uv_write_t_32bit_unix_riders {\n+    a13: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_write_t_32bit_unix_riders = {\n-    a13: *u8, a14: *u8\n-};\n+pub struct uv_write_t_32bit_unix_riders {\n+    a13: *u8, a14: *u8,\n+}\n // win32 size: 136 (68)\n #[cfg(windows)]\n-pub type uv_write_t = {\n+pub struct uv_write_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8\n-};\n+    a12: *u8,\n+}\n // 64bit unix size: 120\n // 32bit unix size: 152 (76)\n #[cfg(unix)]\n-pub type uv_async_t = {\n+pub struct uv_async_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8,\n-    a11: uv_async_t_32bit_unix_riders\n-};\n+    a11: uv_async_t_32bit_unix_riders,\n+}\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_async_t_32bit_unix_riders = {\n-    a10: *u8\n-};\n+pub struct uv_async_t_32bit_unix_riders {\n+    a10: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_async_t_32bit_unix_riders = {\n-    a10: *u8, a11: *u8, a12: *u8, a13: *u8\n-};\n+pub struct uv_async_t_32bit_unix_riders {\n+    a10: *u8, a11: *u8, a12: *u8, a13: *u8,\n+}\n // win32 size 132 (68)\n #[cfg(windows)]\n-pub type uv_async_t = {\n+pub struct uv_async_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8\n-};\n+    a12: *u8,\n+}\n \n // 64bit unix size: 128\n // 32bit unix size: 84\n #[cfg(unix)]\n-pub type uv_timer_t = {\n+pub struct uv_timer_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8,\n-    a11: uv_timer_t_32bit_unix_riders\n-};\n+    a11: uv_timer_t_32bit_unix_riders,\n+}\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_timer_t_32bit_unix_riders = {\n-    a10: *u8, a11: *u8\n-};\n+pub struct uv_timer_t_32bit_unix_riders {\n+    a10: *u8, a11: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_timer_t_32bit_unix_riders = {\n+pub struct uv_timer_t_32bit_unix_riders {\n     a10: *u8, a11: *u8, a12: *u8, a13: *u8,\n-    a14: *u8, a15: *u8, a16: *u8\n-};\n+    a14: *u8, a15: *u8, a16: *u8,\n+}\n // win32 size: 64\n #[cfg(windows)]\n-pub type uv_timer_t = {\n+pub struct uv_timer_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8\n-};\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+}\n \n // unix size: 16\n-pub type sockaddr_in = {\n+pub struct sockaddr_in {\n     mut sin_family: u16,\n     mut sin_port: u16,\n     mut sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n-    mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8)\n-};\n+    mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8),\n+}\n \n // unix size: 28 .. FIXME #1645\n // stuck with 32 becuse of rust padding structs?\n #[cfg(target_arch=\"x86_64\")]\n-pub type sockaddr_in6 = {\n+pub struct sockaddr_in6 {\n     a0: *u8, a1: *u8,\n-    a2: *u8, a3: *u8\n-};\n+    a2: *u8, a3: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type sockaddr_in6 = {\n+pub struct sockaddr_in6 {\n     a0: *u8, a1: *u8,\n     a2: *u8, a3: *u8,\n     a4: *u8, a5: *u8,\n-    a6: *u8, a7: *u8\n-};\n+    a6: *u8, a7: *u8,\n+}\n \n // unix size: 28 .. FIXME #1645\n // stuck with 32 becuse of rust padding structs?\n pub type addr_in = addr_in_impl::addr_in;\n #[cfg(unix)]\n pub mod addr_in_impl {\n     #[cfg(target_arch=\"x86_64\")]\n-    pub type addr_in = {\n+    pub struct addr_in {\n         a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8\n-    };\n+        a2: *u8, a3: *u8,\n+    }\n     #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-    pub type addr_in = {\n+    pub struct addr_in {\n         a0: *u8, a1: *u8,\n         a2: *u8, a3: *u8,\n         a4: *u8, a5: *u8,\n         a6: *u8, a7: *u8,\n-    };\n+    }\n }\n #[cfg(windows)]\n pub mod addr_in_impl {\n-    pub type addr_in = {\n+    pub struct addr_in {\n         a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8\n-    };\n+        a2: *u8, a3: *u8,\n+    }\n }\n \n // unix size: 48, 32bit: 32\n@@ -294,42 +294,60 @@ pub type addrinfo = addrinfo_impl::addrinfo;\n #[cfg(target_os=\"android\")]\n pub mod addrinfo_impl {\n     #[cfg(target_arch=\"x86_64\")]\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8\n-    };\n+        a04: *u8, a05: *u8,\n+    }\n     #[cfg(target_arch=\"x86\")]\n     #[cfg(target_arch=\"arm\")]\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8, a06: *u8, a07: *u8\n-    };\n+        a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    }\n }\n #[cfg(target_os=\"macos\")]\n #[cfg(target_os=\"freebsd\")]\n pub mod addrinfo_impl {\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8\n-    };\n+        a04: *u8, a05: *u8,\n+    }\n }\n #[cfg(windows)]\n pub mod addrinfo_impl {\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8\n-    };\n+        a04: *u8, a05: *u8,\n+    }\n }\n \n // unix size: 72\n-pub type uv_getaddrinfo_t = {\n+pub struct uv_getaddrinfo_t {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8, a04: *u8, a05: *u8,\n-    a06: *u8, a07: *u8, a08: *u8\n-};\n+    a06: *u8, a07: *u8, a08: *u8,\n+}\n \n pub mod uv_ll_struct_stubgen {\n-    use uv_ll::{uv_async_t, uv_connect_t, uv_getaddrinfo_t, uv_tcp_t};\n-    use uv_ll::{uv_timer_t, uv_write_t};\n+    use uv_ll::{\n+        uv_async_t,\n+        uv_connect_t,\n+        uv_getaddrinfo_t,\n+        uv_handle_fields,\n+        uv_tcp_t,\n+        uv_timer_t,\n+        uv_write_t,\n+    };\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"android\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    use uv_ll::{\n+        uv_async_t_32bit_unix_riders,\n+        uv_tcp_t_32bit_unix_riders,\n+        uv_timer_t_32bit_unix_riders,\n+        uv_write_t_32bit_unix_riders,\n+    };\n \n     use core::ptr;\n \n@@ -343,9 +361,12 @@ pub mod uv_ll_struct_stubgen {\n             return gen_stub_arch();\n             #[cfg(target_arch=\"x86_64\")]\n             pub fn gen_stub_arch() -> uv_tcp_t {\n-                return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                                close_cb: ptr::null(),\n-                                mut data: ptr::null() },\n+                uv_tcp_t {\n+                    fields: uv_handle_fields {\n+                        loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        data: ptr::null(),\n+                    },\n                     a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                     a03: 0 as *u8,\n                     a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -361,17 +382,18 @@ pub mod uv_ll_struct_stubgen {\n                     a24: 0 as *u8, a25: 0 as *u8, a26: 0 as *u8,\n                     a27: 0 as *u8,\n                     a28: 0 as *u8,\n-                    a30: {\n-                        a29: 0 as *u8\n-                    }\n-                };\n+                    a30: uv_tcp_t_32bit_unix_riders { a29: 0 as *u8 },\n+                }\n             }\n             #[cfg(target_arch=\"x86\")]\n             #[cfg(target_arch=\"arm\")]\n             pub fn gen_stub_arch() -> uv_tcp_t {\n-                return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                                close_cb: ptr::null(),\n-                                mut data: ptr::null() },\n+                uv_tcp_t {\n+                    fields: uv_handle_fields {\n+                        loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        data: ptr::null(),\n+                    },\n                     a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                     a03: 0 as *u8,\n                     a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -387,19 +409,22 @@ pub mod uv_ll_struct_stubgen {\n                     a24: 0 as *u8, a25: 0 as *u8, a26: 0 as *u8,\n                     a27: 0 as *u8,\n                     a28: 0 as *u8,\n-                    a30: {\n+                    a30: uv_tcp_t_32bit_unix_riders {\n                         a29: 0 as *u8, a30: 0 as *u8, a31: 0 as *u8,\n                         a32: 0 as *u8, a33: 0 as *u8, a34: 0 as *u8,\n-                        a35: 0 as *u8, a36: 0 as *u8\n-                    }\n-                };\n+                        a35: 0 as *u8, a36: 0 as *u8,\n+                    },\n+                }\n             }\n         }\n         #[cfg(windows)]\n         pub fn gen_stub_os() -> uv_tcp_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_tcp_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -412,58 +437,62 @@ pub mod uv_ll_struct_stubgen {\n                 a19: 0 as *u8,\n                 a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n                 a23: 0 as *u8,\n-                a24: 0 as *u8, a25: 0 as *u8\n-            };\n+                a24: 0 as *u8, a25: 0 as *u8,\n+            }\n         }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        return {\n+        uv_connect_t {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8\n-        };\n+            a04: 0 as *u8, a05: 0 as *u8,\n+        }\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        return {\n+        uv_connect_t {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n             a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n-        };\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n+        }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_async_t() -> uv_async_t {\n         return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n         pub fn gen_stub_arch() -> uv_async_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_async_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n-                    a10: 0 as *u8\n-                }\n-            };\n+                a11: uv_async_t_32bit_unix_riders { a10: 0 as *u8 },\n+            }\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         pub fn gen_stub_arch() -> uv_async_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_async_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n+                a11: uv_async_t_32bit_unix_riders {\n                     a10: 0 as *u8, a11: 0 as *u8,\n                     a12: 0 as *u8, a13: 0 as *u8\n                 }\n@@ -472,107 +501,133 @@ pub mod uv_ll_struct_stubgen {\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_async_t() -> uv_async_t {\n-        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        mut data: ptr::null() },\n+        uv_async_t {\n+            fields: uv_handle_fields {\n+                loop_handle: ptr::null(), type_: 0u32,\n+                close_cb: ptr::null(),\n+                data: ptr::null(),\n+            },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n             a07: 0 as *u8,\n             a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n             a11: 0 as *u8,\n-            a12: 0 as *u8\n-        };\n+            a12: 0 as *u8,\n+        }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n         return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n         pub fn gen_stub_arch() -> uv_timer_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_timer_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n+                a11: uv_timer_t_32bit_unix_riders {\n                     a10: 0 as *u8, a11: 0 as *u8\n-                }\n-            };\n+                },\n+            }\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         pub fn gen_stub_arch() -> uv_timer_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_timer_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n+                a11: uv_timer_t_32bit_unix_riders {\n                     a10: 0 as *u8, a11: 0 as *u8,\n                     a12: 0 as *u8, a13: 0 as *u8,\n                     a14: 0 as *u8, a15: 0 as *u8,\n-                    a16: 0 as *u8\n-                }\n-            };\n+                    a16: 0 as *u8,\n+                },\n+            }\n         }\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        mut data: ptr::null() },\n+        uv_timer_t {\n+            fields: uv_handle_fields {\n+                loop_handle: ptr::null(), type_: 0u32,\n+                close_cb: ptr::null(),\n+                data: ptr::null(),\n+            },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n             a07: 0 as *u8,\n             a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8\n-        };\n+            a11: 0 as *u8,\n+        }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_write_t() -> uv_write_t {\n         return gen_stub_arch();\n         #[cfg(target_arch=\"x86_64\")]\n         pub fn gen_stub_arch() -> uv_write_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_write_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n                 a11: 0 as *u8,\n-                a12: 0 as *u8, a14: { a13: 0 as *u8 }\n-            };\n+                a12: 0 as *u8,\n+                a14: uv_write_t_32bit_unix_riders { a13: 0 as *u8 },\n+            }\n         }\n         #[cfg(target_arch=\"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         pub fn gen_stub_arch() -> uv_write_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_write_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n                 a11: 0 as *u8,\n-                a12: 0 as *u8, a14: { a13: 0 as *u8, a14: 0 as *u8 }\n+                a12: 0 as *u8,\n+                a14: uv_write_t_32bit_unix_riders {\n+                    a13: 0 as *u8,\n+                    a14: 0 as *u8,\n+                }\n             };\n         }\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_write_t() -> uv_write_t {\n-        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        mut data: ptr::null() },\n+        uv_write_t {\n+            fields: uv_handle_fields {\n+                loop_handle: ptr::null(), type_: 0u32,\n+                close_cb: ptr::null(),\n+                data: ptr::null(),\n+            },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -583,7 +638,7 @@ pub mod uv_ll_struct_stubgen {\n         };\n     }\n     pub fn gen_stub_uv_getaddrinfo_t() -> uv_getaddrinfo_t {\n-        {\n+        uv_getaddrinfo_t {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n             a08: 0 as *u8\n@@ -851,7 +906,7 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n     return rustrt::rust_uv_async_send(async_handle);\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-    let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n+    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(&out_buf);\n     log(debug, fmt!(\"buf_init - input %u len %u out_buf: %u\",\n                      input as uint,\n@@ -1043,13 +1098,13 @@ pub unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n     let err_ptr = ptr::addr_of(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    { err_name: err_name, err_msg: err_msg }\n+    uv_err_data { err_name: err_name, err_msg: err_msg }\n }\n \n-pub type uv_err_data = {\n+pub struct uv_err_data {\n     err_name: ~str,\n-    err_msg: ~str\n-};\n+    err_msg: ~str,\n+}\n \n pub unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n     rustrt::rust_uv_is_ipv4_addrinfo(input)\n@@ -1090,11 +1145,11 @@ pub mod test {\n         tcp_read_error\n     }\n \n-    type request_wrapper = {\n+    struct request_wrapper {\n         write_req: *uv_write_t,\n         req_buf: *~[uv_buf_t],\n-        read_chan: *oldcomm::Chan<~str>\n-    };\n+        read_chan: *oldcomm::Chan<~str>,\n+    }\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n         log(debug, fmt!(\"after uv_close! handle ptr: %?\",\n@@ -1424,18 +1479,18 @@ pub mod test {\n         }\n     }\n \n-    type tcp_server_data = {\n+    struct tcp_server_data {\n         client: *uv_tcp_t,\n         server: *uv_tcp_t,\n         server_kill_msg: ~str,\n         server_resp_buf: *~[uv_buf_t],\n         server_chan: *oldcomm::Chan<~str>,\n-        server_write_req: *uv_write_t\n-    };\n+        server_write_req: *uv_write_t,\n+    }\n \n-    type async_handle_data = {\n-        continue_chan: *oldcomm::Chan<bool>\n-    };\n+    struct async_handle_data {\n+        continue_chan: *oldcomm::Chan<bool>,\n+    }\n \n     extern fn async_close_cb(handle: *libc::c_void) {\n         log(debug, fmt!(\"SERVER: closing async cb... h: %?\",\n@@ -1489,7 +1544,7 @@ pub mod test {\n                 { continue_chan: continue_chan };\n             let async_data_ptr = ptr::addr_of(&async_data);\n \n-            let server_data: tcp_server_data = {\n+            let server_data = tcp_server_data {\n                 client: tcp_client_ptr,\n                 server: tcp_server_ptr,\n                 server_kill_msg: kill_server_msg,"}]}