{"sha": "42c77f4958fcd6c2238d883c49f52341e0631999", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYzc3ZjQ5NThmY2Q2YzIyMzhkODgzYzQ5ZjUyMzQxZTA2MzE5OTk=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T09:21:33Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T09:21:33Z"}, "message": "rollup merge of #18970: aturon/fixup-stable", "tree": {"sha": "8d2185033dcafbae16ef5b0ebeed90cb41679695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d2185033dcafbae16ef5b0ebeed90cb41679695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42c77f4958fcd6c2238d883c49f52341e0631999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42c77f4958fcd6c2238d883c49f52341e0631999", "html_url": "https://github.com/rust-lang/rust/commit/42c77f4958fcd6c2238d883c49f52341e0631999", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42c77f4958fcd6c2238d883c49f52341e0631999/comments", "author": null, "committer": null, "parents": [{"sha": "f3fd09a6f57bb9b634a38e672bcd51ef0922dbe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fd09a6f57bb9b634a38e672bcd51ef0922dbe1", "html_url": "https://github.com/rust-lang/rust/commit/f3fd09a6f57bb9b634a38e672bcd51ef0922dbe1"}, {"sha": "60741e0fa0948c75040d0d554b46027021185600", "url": "https://api.github.com/repos/rust-lang/rust/commits/60741e0fa0948c75040d0d554b46027021185600", "html_url": "https://github.com/rust-lang/rust/commit/60741e0fa0948c75040d0d554b46027021185600"}], "stats": {"total": 80, "additions": 63, "deletions": 17}, "files": [{"sha": "501f915461a27844cf162732f8a3848d7e9f1017", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -179,9 +179,9 @@ pub struct Rc<T> {\n     _noshare: marker::NoSync\n }\n \n-#[stable]\n impl<T> Rc<T> {\n     /// Constructs a new reference-counted pointer.\n+    #[stable]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -200,9 +200,7 @@ impl<T> Rc<T> {\n             }\n         }\n     }\n-}\n \n-impl<T> Rc<T> {\n     /// Downgrades the reference-counted pointer to a weak reference.\n     #[experimental = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {"}, {"sha": "ecd10b3d4c9d74eb2a08b26f5cf5b5f9c8183d13", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -645,7 +645,6 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n "}, {"sha": "5511266b4cd2276600c3b8fdf9232fa903c3f37a", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -88,6 +88,7 @@ use intrinsics::TypeId;\n #[stable]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n+    #[stable]\n     fn get_type_id(&self) -> TypeId;\n }\n \n@@ -117,7 +118,6 @@ pub trait AnyRefExt<'a> {\n #[stable]\n impl<'a> AnyRefExt<'a> for &'a Any {\n     #[inline]\n-    #[stable]\n     fn is<T: 'static>(self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n@@ -130,7 +130,6 @@ impl<'a> AnyRefExt<'a> for &'a Any {\n     }\n \n     #[inline]\n-    #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_ref<T: 'static>(self) -> Option<&'a T> {\n         if self.is::<T>() {\n             unsafe {\n@@ -159,7 +158,6 @@ pub trait AnyMutRefExt<'a> {\n #[stable]\n impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n     #[inline]\n-    #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_mut<T: 'static>(self) -> Option<&'a mut T> {\n         if self.is::<T>() {\n             unsafe {"}, {"sha": "d84a7875df1aaa48b0f5daddcd24b1d73e14602c", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -58,20 +58,25 @@ pub struct AtomicPtr<T> {\n #[stable]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations\n+    #[stable]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n     /// on the same value\n+    #[stable]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n     /// in another thread\n+    #[stable]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n     /// `Release` ordering\n+    #[stable]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n+    #[stable]\n     SeqCst\n }\n \n@@ -91,10 +96,10 @@ pub const INIT_ATOMIC_UINT: AtomicUint =\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n \n-#[stable]\n impl AtomicBool {\n     /// Create a new `AtomicBool`\n     #[inline]\n+    #[stable]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val), nocopy: marker::NoCopy }\n@@ -106,6 +111,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n@@ -116,6 +122,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -124,6 +131,7 @@ impl AtomicBool {\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -174,6 +182,7 @@ impl AtomicBool {\n     /// }\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n@@ -205,6 +214,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -236,6 +246,7 @@ impl AtomicBool {\n     /// assert_eq!(true, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -266,6 +277,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -296,17 +308,18 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n-#[stable]\n impl AtomicInt {\n     /// Create a new `AtomicInt`\n     #[inline]\n+    #[stable]\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v), nocopy: marker::NoCopy}\n     }\n@@ -317,6 +330,7 @@ impl AtomicInt {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n@@ -327,12 +341,14 @@ impl AtomicInt {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: int, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -343,6 +359,7 @@ impl AtomicInt {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -359,6 +376,7 @@ impl AtomicInt {\n     /// assert_eq!(10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -375,6 +393,7 @@ impl AtomicInt {\n     /// assert_eq!(-10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -390,6 +409,7 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n     /// assert_eq!(0b100001, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -405,6 +425,7 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n     /// assert_eq!(0b111111, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -420,15 +441,16 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n     /// assert_eq!(0b011110, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n-#[stable]\n impl AtomicUint {\n     /// Create a new `AtomicUint`\n     #[inline]\n+    #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v), nocopy: marker::NoCopy }\n     }\n@@ -439,6 +461,7 @@ impl AtomicUint {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n@@ -449,12 +472,14 @@ impl AtomicUint {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: uint, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -465,6 +490,7 @@ impl AtomicUint {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -481,6 +507,7 @@ impl AtomicUint {\n     /// assert_eq!(10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -497,6 +524,7 @@ impl AtomicUint {\n     /// assert_eq!(0, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -512,6 +540,7 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n     /// assert_eq!(0b100001, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -527,6 +556,7 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n     /// assert_eq!(0b111111, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -542,15 +572,16 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n     /// assert_eq!(0b011110, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n-#[stable]\n impl<T> AtomicPtr<T> {\n     /// Create a new `AtomicPtr`\n     #[inline]\n+    #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as uint), nocopy: marker::NoCopy }\n     }\n@@ -561,6 +592,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(self.p.get() as *const *mut T, order) as *mut T\n@@ -573,12 +605,14 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n     }\n@@ -589,6 +623,7 @@ impl<T> AtomicPtr<T> {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_compare_and_swap(self.p.get(), old as uint,\n@@ -609,6 +644,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -620,6 +656,7 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -632,6 +669,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n+#[stable]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -644,6 +682,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n+#[stable]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -655,6 +694,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -666,6 +706,7 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -677,6 +718,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -689,6 +731,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n+#[stable]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -701,6 +744,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n+#[stable]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),"}, {"sha": "0b7389b20190caadb2769548e1e660cd6443b1db", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -169,9 +169,9 @@ pub struct Cell<T> {\n     noshare: marker::NoSync,\n }\n \n-#[stable]\n impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n+    #[stable]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -181,12 +181,14 @@ impl<T:Copy> Cell<T> {\n \n     /// Returns a copy of the contained value.\n     #[inline]\n+    #[stable]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n     #[inline]\n+    #[stable]\n     pub fn set(&self, value: T) {\n         unsafe {\n             *self.value.get() = value;"}, {"sha": "d41dbb11adb198cc0fe905bc56905cfe07e097f5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -716,7 +716,6 @@ impl<T: Default> Option<T> {\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n@@ -728,6 +727,7 @@ impl<T> AsSlice<T> for Option<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for Option<T> {\n     #[inline]\n     fn default() -> Option<T> { None }\n@@ -772,9 +772,10 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n impl<A> ExactSize<A> for Item<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable]\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a"}, {"sha": "5a6d0917af2c41b9970a3525aa4d1a287e636884", "filename": "src/libcore/result.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -878,9 +878,10 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n impl<A> ExactSize<A> for Item<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable]\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -933,6 +934,10 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     }\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// FromIterator\n+/////////////////////////////////////////////////////////////////////////////\n+\n /// Perform a fold operation over the result values from an iterator.\n ///\n /// If an `Err` is encountered, it is immediately returned."}, {"sha": "058d8b81f7a7ed83a74ba4e5ef4abb36c43eb1f2", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -146,13 +146,12 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n     // considered to have no children.\n     match item.inner {\n         // Require explicit `pub` to be visible\n-        StructItem(Struct { fields: ref subitems, .. }) |\n         ImplItem(Impl { items: ref subitems, trait_: None, .. }) => {\n             let subcounts = subitems.iter().filter(|i| visible(*i))\n                                            .map(summarize_item)\n                                            .map(|s| s.val0())\n                                            .fold(Counts::zero(), |acc, x| acc + x);\n-            (item_counts + subcounts, None)\n+            (subcounts, None)\n         }\n         // `pub` automatically\n         EnumItem(Enum { variants: ref subitems, .. }) => {"}]}