{"sha": "34e4d72929c33bb126e0b1b199faab9031e0f3de", "node_id": "C_kwDOAAsO6NoAKDM0ZTRkNzI5MjljMzNiYjEyNmUwYjFiMTk5ZmFhYjkwMzFlMGYzZGU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-30T16:49:17Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-14T20:45:51Z"}, "message": "Separate `source_span` and `expn_that_defined` from `Definitions`.", "tree": {"sha": "69b51523d44c6b69ba565ede45279fca81027797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69b51523d44c6b69ba565ede45279fca81027797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34e4d72929c33bb126e0b1b199faab9031e0f3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34e4d72929c33bb126e0b1b199faab9031e0f3de", "html_url": "https://github.com/rust-lang/rust/commit/34e4d72929c33bb126e0b1b199faab9031e0f3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34e4d72929c33bb126e0b1b199faab9031e0f3de/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b676edd641dbd1049702e63dc027f92daa849d23", "url": "https://api.github.com/repos/rust-lang/rust/commits/b676edd641dbd1049702e63dc027f92daa849d23", "html_url": "https://github.com/rust-lang/rust/commit/b676edd641dbd1049702e63dc027f92daa849d23"}], "stats": {"total": 270, "additions": 135, "deletions": 135}, "files": [{"sha": "aab9b90e4b7e567bc85abd466139c39a055fbd98", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::definitions::DefPathData;\n use rustc_session::parse::feature_err;\n-use rustc_span::{sym, ExpnId, Span};\n+use rustc_span::{sym, Span};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n use std::fmt::Write;\n@@ -243,13 +243,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n                             let node_id = self.next_node_id();\n-                            self.create_def(\n-                                parent_def_id,\n-                                node_id,\n-                                DefPathData::AnonConst,\n-                                ExpnId::root(),\n-                                *op_sp,\n-                            );\n+                            self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n                             let anon_const = AnonConst { id: node_id, value: P(expr) };\n                             hir::InlineAsmOperand::SymFn {\n                                 anon_const: self.lower_anon_const(&anon_const),"}, {"sha": "d6b27f267e054bb157007ac4e349bcc1b655ffbc", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -11,7 +11,6 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n-use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::DUMMY_SP;\n@@ -358,13 +357,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.create_def(\n-                    parent_def_id,\n-                    node_id,\n-                    DefPathData::AnonConst,\n-                    ExpnId::root(),\n-                    arg.span,\n-                );\n+                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n \n                 let anon_const = AnonConst { id: node_id, value: arg };\n                 generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));"}, {"sha": "d56b2fd5d0b5027f7b98b12879c760f6c64f0bec", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -61,7 +61,7 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnId, MacroKind};\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -391,6 +391,7 @@ fn compute_hir_hash(\n     sess: &Session,\n     definitions: &Definitions,\n     cstore: &CrateStoreDyn,\n+    resolver: &ResolverOutputs,\n     owners: &IndexVec<LocalDefId, hir::MaybeOwner<&hir::OwnerInfo<'_>>>,\n ) -> Fingerprint {\n     let mut hir_body_nodes: Vec<_> = owners\n@@ -404,7 +405,7 @@ fn compute_hir_hash(\n     hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n     let mut stable_hasher = StableHasher::new();\n-    let mut hcx = StableHashingContext::new(sess, definitions, cstore);\n+    let mut hcx = StableHashingContext::new(sess, definitions, cstore, &resolver.source_span);\n     hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n     stable_hasher.finish()\n }\n@@ -437,7 +438,7 @@ pub fn lower_crate<'hir>(\n         .lower_node(def_id);\n     }\n \n-    let hir_hash = compute_hir_hash(sess, definitions, cstore, &owners);\n+    let hir_hash = compute_hir_hash(sess, definitions, cstore, resolver, &owners);\n     let krate = hir::Crate { owners, hir_hash };\n     arena.alloc(krate)\n }\n@@ -459,16 +460,19 @@ enum ParenthesizedGenericArgs {\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(self.sess, self.definitions, self.cstore)\n+        StableHashingContext::new(\n+            self.sess,\n+            self.definitions,\n+            self.cstore,\n+            &self.resolver.source_span,\n+        )\n     }\n \n     fn create_def(\n         &mut self,\n         parent: LocalDefId,\n         node_id: ast::NodeId,\n         data: DefPathData,\n-        expn_id: ExpnId,\n-        span: Span,\n     ) -> LocalDefId {\n         assert!(\n             self.opt_local_def_id(node_id).is_none(),\n@@ -478,7 +482,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.definitions.def_key(self.local_def_id(node_id)),\n         );\n \n-        let def_id = self.definitions.create_def(parent, data, expn_id, span);\n+        let def_id = self.definitions.create_def(parent, data);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n         // anything in the AST, so they don't have a `NodeId`. For these cases\n@@ -998,13 +1002,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                     let parent_def_id = self.current_hir_id_owner;\n                     let impl_trait_node_id = self.next_node_id();\n-                    self.create_def(\n-                        parent_def_id,\n-                        impl_trait_node_id,\n-                        DefPathData::ImplTrait,\n-                        ExpnId::root(),\n-                        constraint.span,\n-                    );\n+                    self.create_def(parent_def_id, impl_trait_node_id, DefPathData::ImplTrait);\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let node_id = this.next_node_id();\n@@ -1110,13 +1108,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 let node_id = self.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n-                                self.create_def(\n-                                    parent_def_id,\n-                                    node_id,\n-                                    DefPathData::AnonConst,\n-                                    ExpnId::root(),\n-                                    ty.span,\n-                                );\n+                                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n \n                                 let span = self.lower_span(ty.span);\n                                 let path_expr = Expr {\n@@ -1624,13 +1616,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let inner_node_id = self.next_node_id();\n \n             // Add a definition for the in scope lifetime def.\n-            self.create_def(\n-                opaque_ty_def_id,\n-                inner_node_id,\n-                DefPathData::LifetimeNs(name),\n-                ExpnId::root(),\n-                span.with_parent(None),\n-            );\n+            self.create_def(opaque_ty_def_id, inner_node_id, DefPathData::LifetimeNs(name));\n \n             let (p_name, inner_res) = match outer_res {\n                 // Input lifetime like `'a`:\n@@ -1824,8 +1810,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     captured_lifetimes.parent_def_id,\n                                     p_id,\n                                     DefPathData::LifetimeNs(p_name.ident().name),\n-                                    ExpnId::root(),\n-                                    span.with_parent(None),\n                                 );\n \n                                 v.insert((span, p_id, p_name, res));\n@@ -1850,8 +1834,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     captured_lifetimes.parent_def_id,\n                                     p_id,\n                                     DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                    ExpnId::root(),\n-                                    span.with_parent(None),\n                                 );\n \n                                 v.insert((span, p_id, ParamName::Fresh, res));\n@@ -1873,8 +1855,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             captured_lifetimes.parent_def_id,\n                             p_id,\n                             DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                            ExpnId::root(),\n-                            span.with_parent(None),\n                         );\n                         captured_lifetimes\n                             .captures"}, {"sha": "5f8801cc4e20d67cc180edc5af4b049e81520be8", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 5, "deletions": 51, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -11,9 +11,7 @@ use crate::def_path_hash_map::DefPathHashMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_index::vec::IndexVec;\n-use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::Span;\n \n use std::fmt::{self, Write};\n use std::hash::Hash;\n@@ -101,11 +99,6 @@ pub struct Definitions {\n     table: DefPathTable,\n     next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n \n-    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n-    expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-\n-    def_id_to_span: IndexVec<LocalDefId, Span>,\n-\n     /// The [StableCrateId] of the local crate.\n     stable_crate_id: StableCrateId,\n }\n@@ -323,7 +316,7 @@ impl Definitions {\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    pub fn new(stable_crate_id: StableCrateId, crate_span: Span) -> Definitions {\n+    pub fn new(stable_crate_id: StableCrateId) -> Definitions {\n         let key = DefKey {\n             parent: None,\n             disambiguated_data: DisambiguatedDefPathData {\n@@ -340,30 +333,12 @@ impl Definitions {\n         let root = LocalDefId { local_def_index: table.allocate(key, def_path_hash) };\n         assert_eq!(root.local_def_index, CRATE_DEF_INDEX);\n \n-        let mut def_id_to_span = IndexVec::new();\n-        // A relative span's parent must be an absolute span.\n-        debug_assert_eq!(crate_span.data_untracked().parent, None);\n-        let _root = def_id_to_span.push(crate_span);\n-        debug_assert_eq!(_root, root);\n-\n-        Definitions {\n-            table,\n-            next_disambiguator: Default::default(),\n-            expansions_that_defined: Default::default(),\n-            def_id_to_span,\n-            stable_crate_id,\n-        }\n+        Definitions { table, next_disambiguator: Default::default(), stable_crate_id }\n     }\n \n     /// Adds a definition with a parent definition.\n-    pub fn create_def(\n-        &mut self,\n-        parent: LocalDefId,\n-        data: DefPathData,\n-        expn_id: ExpnId,\n-        span: Span,\n-    ) -> LocalDefId {\n-        debug!(\"create_def(parent={:?}, data={:?}, expn_id={:?})\", parent, data, expn_id);\n+    pub fn create_def(&mut self, parent: LocalDefId, data: DefPathData) -> LocalDefId {\n+        debug!(\"create_def(parent={:?}, data={:?})\", parent, data);\n \n         // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n@@ -386,28 +361,7 @@ impl Definitions {\n         debug!(\"create_def: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let def_id = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n-\n-        if expn_id != ExpnId::root() {\n-            self.expansions_that_defined.insert(def_id, expn_id);\n-        }\n-\n-        // A relative span's parent must be an absolute span.\n-        debug_assert_eq!(span.data_untracked().parent, None);\n-        let _id = self.def_id_to_span.push(span);\n-        debug_assert_eq!(_id, def_id);\n-\n-        def_id\n-    }\n-\n-    pub fn expansion_that_defined(&self, id: LocalDefId) -> ExpnId {\n-        self.expansions_that_defined.get(&id).copied().unwrap_or_else(ExpnId::root)\n-    }\n-\n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n-    #[inline]\n-    pub fn def_span(&self, def_id: LocalDefId) -> Span {\n-        self.def_id_to_span[def_id]\n+        LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) }\n     }\n \n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {"}, {"sha": "9d77d640a15a640b896ba44dc5b614210b6c1250", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -1078,6 +1078,8 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n \n     let upstream_crates = upstream_crates(tcx);\n \n+    let resolutions = tcx.resolutions(());\n+\n     // We hash the final, remapped names of all local source files so we\n     // don't have to include the path prefix remapping commandline args.\n     // If we included the full mapping in the SVH, we could only have\n@@ -1107,7 +1109,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n             .filter_map(|(def_id, info)| {\n                 let _ = info.as_owner()?;\n                 let def_path_hash = definitions.def_path_hash(def_id);\n-                let span = definitions.def_span(def_id);\n+                let span = resolutions.source_span[def_id];\n                 debug_assert_eq!(span.parent(), None);\n                 Some((def_path_hash, span))\n             })\n@@ -1118,7 +1120,6 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n     tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n     // Hash visibility information since it does not appear in HIR.\n-    let resolutions = tcx.resolutions(());\n     resolutions.visibilities.hash_stable(&mut hcx, &mut stable_hasher);\n     resolutions.has_pub_restricted.hash_stable(&mut hcx, &mut stable_hasher);\n "}, {"sha": "09b142e0c415d6fdc7d5a8e77cbd27810f51e1c0", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::*;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{ExpnId, DUMMY_SP};\n \n /// Top-level HIR node for current owner. This only contains the node for which\n /// `HirId::local_id == 0`, and excludes bodies.\n@@ -117,7 +117,8 @@ pub fn provide(providers: &mut Providers) {\n     };\n     providers.hir_attrs =\n         |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs);\n-    providers.source_span = |tcx, def_id| tcx.definitions_untracked().def_span(def_id);\n+    providers.source_span =\n+        |tcx, def_id| tcx.resolutions(()).source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n     providers.def_span = |tcx, def_id| {\n         let def_id = def_id.expect_local();\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n@@ -147,7 +148,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.all_local_trait_impls = |tcx, ()| &tcx.resolutions(()).trait_impls;\n     providers.expn_that_defined = |tcx, id| {\n         let id = id.expect_local();\n-        tcx.definitions_untracked().expansion_that_defined(id)\n+        tcx.resolutions(()).expn_that_defined.get(&id).copied().unwrap_or(ExpnId::root())\n     };\n     providers.in_scope_traits_map =\n         |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map(|owner_info| &owner_info.trait_map);"}, {"sha": "e0b4eced075e9e42697da026a800de85d82c9c29", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -31,7 +31,6 @@ rustc_queries! {\n     /// This span is meant for dep-tracking rather than diagnostics. It should not be used outside\n     /// of rustc_middle::hir::source_map.\n     query source_span(key: LocalDefId) -> Span {\n-        eval_always\n         desc { \"get the source span\" }\n     }\n \n@@ -272,8 +271,6 @@ rustc_queries! {\n     }\n \n     query expn_that_defined(key: DefId) -> rustc_span::ExpnId {\n-        // This query reads from untracked data in definitions.\n-        eval_always\n         desc { |tcx| \"expansion that defined `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }"}, {"sha": "4464a0211fc2d6156956a955d31a7a958d6b9b61", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -180,6 +180,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         sess: &Session,\n         definitions: &rustc_hir::definitions::Definitions,\n         cstore: &CrateStoreDyn,\n+        source_span: &IndexVec<LocalDefId, Span>,\n     ) -> Ty<'tcx> {\n         Ty(Interned::new_unchecked(\n             self.type_\n@@ -194,7 +195,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n                         Fingerprint::ZERO\n                     } else {\n                         let mut hasher = StableHasher::new();\n-                        let mut hcx = StableHashingContext::ignore_spans(sess, definitions, cstore);\n+                        let mut hcx = StableHashingContext::ignore_spans(\n+                            sess,\n+                            definitions,\n+                            cstore,\n+                            source_span,\n+                        );\n                         kind.hash_stable(&mut hcx, &mut hasher);\n                         hasher.finish()\n                     };\n@@ -934,8 +940,9 @@ impl<'tcx> CommonTypes<'tcx> {\n         sess: &Session,\n         definitions: &rustc_hir::definitions::Definitions,\n         cstore: &CrateStoreDyn,\n+        source_span: &IndexVec<LocalDefId, Span>,\n     ) -> CommonTypes<'tcx> {\n-        let mk = |ty| interners.intern_ty(ty, sess, definitions, cstore);\n+        let mk = |ty| interners.intern_ty(ty, sess, definitions, cstore, source_span);\n \n         CommonTypes {\n             unit: mk(Tuple(List::empty())),\n@@ -1235,7 +1242,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(arena);\n-        let common_types = CommonTypes::new(&interners, s, &definitions, &*cstore);\n+        let common_types = CommonTypes::new(\n+            &interners,\n+            s,\n+            &definitions,\n+            &*cstore,\n+            // This is only used to create a stable hashing context.\n+            &untracked_resolutions.source_span,\n+        );\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n \n@@ -1452,14 +1466,31 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self.definitions\n     }\n \n+    /// Note that this is *untracked* and should only be used within the query\n+    /// system if the result is otherwise tracked through queries\n+    #[inline]\n+    pub fn source_span_untracked(self, def_id: LocalDefId) -> Span {\n+        self.untracked_resolutions.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n+    }\n+\n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        StableHashingContext::new(self.sess, &self.definitions, &*self.cstore)\n+        StableHashingContext::new(\n+            self.sess,\n+            &self.definitions,\n+            &*self.cstore,\n+            &self.untracked_resolutions.source_span,\n+        )\n     }\n \n     #[inline(always)]\n     pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        StableHashingContext::ignore_spans(self.sess, &self.definitions, &*self.cstore)\n+        StableHashingContext::ignore_spans(\n+            self.sess,\n+            &self.definitions,\n+            &*self.cstore,\n+            &self.untracked_resolutions.source_span,\n+        )\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n@@ -2250,7 +2281,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n     pub fn mk_ty(self, st: TyKind<'tcx>) -> Ty<'tcx> {\n-        self.interners.intern_ty(st, self.sess, &self.definitions, &*self.cstore)\n+        self.interners.intern_ty(\n+            st,\n+            self.sess,\n+            &self.definitions,\n+            &*self.cstore,\n+            // This is only used to create a stable hashing context.\n+            &self.untracked_resolutions.source_span,\n+        )\n     }\n \n     #[inline]"}, {"sha": "26b45c5c644d0bc8027d145e65f1192ab3384e61", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -43,7 +43,7 @@ use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{ExpnId, Span};\n use rustc_target::abi::{Align, VariantIdx};\n pub use subst::*;\n pub use vtable::*;\n@@ -138,6 +138,10 @@ pub struct ResolverOutputs {\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n     pub has_pub_restricted: bool,\n+    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n+    pub expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n+    /// Reference span for definitions.\n+    pub source_span: IndexVec<LocalDefId, Span>,\n     pub access_levels: AccessLevels,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,"}, {"sha": "166fd1d272d75234c2d08f9a99b7a545863ff9d0", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -689,8 +689,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n             let dlo = u32::decode(decoder);\n             let dto = u32::decode(decoder);\n \n-            let enclosing =\n-                decoder.tcx.definitions_untracked().def_span(parent.unwrap()).data_untracked();\n+            let enclosing = decoder.tcx.source_span_untracked(parent.unwrap()).data_untracked();\n             let span = Span::new(\n                 enclosing.lo + BytePos::from_u32(dlo),\n                 enclosing.lo + BytePos::from_u32(dto),\n@@ -887,7 +886,7 @@ where\n         }\n \n         if let Some(parent) = span_data.parent {\n-            let enclosing = s.tcx.definitions_untracked().def_span(parent).data_untracked();\n+            let enclosing = s.tcx.source_span(parent).data_untracked();\n             if enclosing.contains(span_data) {\n                 TAG_RELATIVE_SPAN.encode(s);\n                 (span_data.lo - enclosing.lo).to_u32().encode(s);"}, {"sha": "d120742ffe36ba9312cac351030440a079292bb5", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n+use rustc_index::vec::IndexVec;\n use rustc_session::cstore::CrateStore;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n@@ -26,6 +27,7 @@ fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n pub struct StableHashingContext<'a> {\n     definitions: &'a Definitions,\n     cstore: &'a dyn CrateStore,\n+    source_span: &'a IndexVec<LocalDefId, Span>,\n     // The value of `-Z incremental-ignore-spans`.\n     // This field should only be used by `debug_opts_incremental_ignore_span`\n     incremental_ignore_spans: bool,\n@@ -56,6 +58,7 @@ impl<'a> StableHashingContext<'a> {\n         sess: &'a Session,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        source_span: &'a IndexVec<LocalDefId, Span>,\n         always_ignore_spans: bool,\n     ) -> Self {\n         let hash_spans_initial =\n@@ -65,6 +68,7 @@ impl<'a> StableHashingContext<'a> {\n             body_resolver: BodyResolver::Forbidden,\n             definitions,\n             cstore,\n+            source_span,\n             incremental_ignore_spans: sess.opts.debugging_opts.incremental_ignore_spans,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n@@ -77,11 +81,13 @@ impl<'a> StableHashingContext<'a> {\n         sess: &'a Session,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        source_span: &'a IndexVec<LocalDefId, Span>,\n     ) -> Self {\n         Self::new_with_or_without_spans(\n             sess,\n             definitions,\n             cstore,\n+            source_span,\n             /*always_ignore_spans=*/ false,\n         )\n     }\n@@ -91,9 +97,10 @@ impl<'a> StableHashingContext<'a> {\n         sess: &'a Session,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        source_span: &'a IndexVec<LocalDefId, Span>,\n     ) -> Self {\n         let always_ignore_spans = true;\n-        Self::new_with_or_without_spans(sess, definitions, cstore, always_ignore_spans)\n+        Self::new_with_or_without_spans(sess, definitions, cstore, source_span, always_ignore_spans)\n     }\n \n     /// Allow hashing\n@@ -198,7 +205,7 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n \n     #[inline]\n     fn def_span(&self, def_id: LocalDefId) -> Span {\n-        self.definitions.def_span(def_id)\n+        self.source_span[def_id]\n     }\n \n     #[inline]"}, {"sha": "e7c8886f0544ad18e5014540fecbba90e2c2987d", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -10,8 +10,9 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::bug;\n use rustc_middle::ty::DefIdTree;\n use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n@@ -130,8 +131,8 @@ impl<'a> Resolver<'a> {\n             };\n             if !candidates.is_empty() {\n                 show_candidates(\n-                    &self.definitions,\n-                    self.session,\n+                    &self.session,\n+                    &self.source_span,\n                     &mut err,\n                     span,\n                     &candidates,\n@@ -693,8 +694,8 @@ impl<'a> Resolver<'a> {\n                         err.span_help(span, &help_msg);\n                     }\n                     show_candidates(\n-                        &self.definitions,\n-                        self.session,\n+                        &self.session,\n+                        &self.source_span,\n                         &mut err,\n                         Some(span),\n                         &import_suggestions,\n@@ -1474,8 +1475,8 @@ impl<'a> Resolver<'a> {\n         let import_suggestions =\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(\n-            &self.definitions,\n-            self.session,\n+            &self.session,\n+            &self.source_span,\n             err,\n             None,\n             &import_suggestions,\n@@ -2444,8 +2445,8 @@ enum IsPattern {\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n fn show_candidates(\n-    definitions: &rustc_hir::definitions::Definitions,\n     session: &Session,\n+    source_span: &IndexVec<LocalDefId, Span>,\n     err: &mut Diagnostic,\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n@@ -2555,7 +2556,7 @@ fn show_candidates(\n             );\n \n             if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n-                let span = definitions.def_span(local_def_id);\n+                let span = source_span[local_def_id];\n                 let span = session.source_map().guess_head_span(span);\n                 let mut multi_span = MultiSpan::from_span(span);\n                 multi_span.push_span_label(span, \"not accessible\".to_string());\n@@ -2584,7 +2585,7 @@ fn show_candidates(\n             let mut spans = Vec::new();\n             for (name, _, def_id, _) in &inaccessible_path_strings {\n                 if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n-                    let span = definitions.def_span(local_def_id);\n+                    let span = source_span[local_def_id];\n                     let span = session.source_map().guess_head_span(span);\n                     spans.push((name, span));\n                 } else {"}, {"sha": "b04a5ef8161a96c03935b592b45457bf93ea20a6", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e4d72929c33bb126e0b1b199faab9031e0f3de/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=34e4d72929c33bb126e0b1b199faab9031e0f3de", "patch": "@@ -872,6 +872,10 @@ pub struct Resolver<'a> {\n     session: &'a Session,\n \n     definitions: Definitions,\n+    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n+    expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n+    /// Reference span for definitions.\n+    source_span: IndexVec<LocalDefId, Span>,\n \n     graph_root: Module<'a>,\n \n@@ -1146,7 +1150,17 @@ impl Resolver<'_> {\n             self.definitions.def_key(self.node_id_to_def_id[&node_id]),\n         );\n \n-        let def_id = self.definitions.create_def(parent, data, expn_id, span);\n+        let def_id = self.definitions.create_def(parent, data);\n+\n+        // Create the definition.\n+        if expn_id != ExpnId::root() {\n+            self.expn_that_defined.insert(def_id, expn_id);\n+        }\n+\n+        // A relative span's parent must be an absolute span.\n+        debug_assert_eq!(span.data_untracked().parent, None);\n+        let _id = self.source_span.push(span);\n+        debug_assert_eq!(_id, def_id);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n         // anything in the AST, so they don't have a `NodeId`. For these cases\n@@ -1196,7 +1210,7 @@ impl<'a> Resolver<'a> {\n             &mut FxHashMap::default(),\n         );\n \n-        let definitions = Definitions::new(session.local_stable_crate_id(), krate.spans.inner_span);\n+        let definitions = Definitions::new(session.local_stable_crate_id());\n \n         let mut visibilities = FxHashMap::default();\n         visibilities.insert(CRATE_DEF_ID, ty::Visibility::Public);\n@@ -1209,6 +1223,10 @@ impl<'a> Resolver<'a> {\n         let mut invocation_parents = FxHashMap::default();\n         invocation_parents.insert(LocalExpnId::ROOT, (CRATE_DEF_ID, ImplTraitContext::Existential));\n \n+        let mut source_span = IndexVec::default();\n+        let _id = source_span.push(krate.spans.inner_span);\n+        debug_assert_eq!(_id, CRATE_DEF_ID);\n+\n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = session\n             .opts\n             .externs\n@@ -1233,6 +1251,8 @@ impl<'a> Resolver<'a> {\n             session,\n \n             definitions,\n+            expn_that_defined: Default::default(),\n+            source_span,\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1376,6 +1396,8 @@ impl<'a> Resolver<'a> {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions;\n         let cstore = Box::new(self.crate_loader.into_cstore());\n+        let source_span = self.source_span;\n+        let expn_that_defined = self.expn_that_defined;\n         let visibilities = self.visibilities;\n         let has_pub_restricted = self.has_pub_restricted;\n         let extern_crate_map = self.extern_crate_map;\n@@ -1387,6 +1409,8 @@ impl<'a> Resolver<'a> {\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let access_levels = self.access_levels;\n         let resolutions = ResolverOutputs {\n+            source_span,\n+            expn_that_defined,\n             visibilities,\n             has_pub_restricted,\n             access_levels,\n@@ -1426,6 +1450,8 @@ impl<'a> Resolver<'a> {\n         let definitions = self.definitions.clone();\n         let cstore = Box::new(self.cstore().clone());\n         let resolutions = ResolverOutputs {\n+            source_span: self.source_span.clone(),\n+            expn_that_defined: self.expn_that_defined.clone(),\n             visibilities: self.visibilities.clone(),\n             has_pub_restricted: self.has_pub_restricted,\n             extern_crate_map: self.extern_crate_map.clone(),\n@@ -1461,7 +1487,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n+        StableHashingContext::new(\n+            self.session,\n+            &self.definitions,\n+            self.crate_loader.cstore(),\n+            &self.source_span,\n+        )\n     }\n \n     pub fn cstore(&self) -> &CStore {\n@@ -1892,7 +1923,7 @@ impl<'a> Resolver<'a> {\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.definitions.def_span(def_id))\n+        def_id.as_local().map(|def_id| self.source_span[def_id])\n     }\n \n     /// Checks if an expression refers to a function marked with"}]}