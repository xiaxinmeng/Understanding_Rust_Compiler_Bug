{"sha": "10165f8af915ac4d57281694ea6a90041c76b5bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMTY1ZjhhZjkxNWFjNGQ1NzI4MTY5NGVhNmE5MDA0MWM3NmI1YmQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-08-19T17:30:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-19T17:30:09Z"}, "message": "Rollup merge of #88093 - Kobzol:rustdoc-wrap-code-in-code-tag, r=GuillaumeGomez\n\n[rustdoc] Wrap code blocks in <code> tag\n\nThis PR modifies Rustdoc output so that fenced code snippets, items and whole file source codes are wrapped in `<pre><code>` instead of just `<pre>`. This should improve the semantic meaning of the generated content.\n\nI'm not sure what to do about `render_attributes_in_pre` and `render_attributes_in_code`. These functions were clearly expected to be used for things inside `<pre>` or `<code>`, and since I added `<code>` in this PR, some of them will be used in a different context than before. However, it seems to me that even before they were not consistent. For example, `item_constant` used `render_attributes_in_code` for its attributes, however there was no `<code>` used for constants before this PR...\n\nShould I create some `rustdoc-gui` tests? For example to check that all `<pre>` tags have a `<code>` child?\n\nFixes: https://github.com/rust-lang/rust/issues/88020", "tree": {"sha": "e3b3fcf58b2f60f2293568fdc3196faf90f2d995", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b3fcf58b2f60f2293568fdc3196faf90f2d995"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10165f8af915ac4d57281694ea6a90041c76b5bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhHpUhCRBK7hj4Ov3rIwAA7YwIAHxuVwoiErRp/MpWEKTunOg2\n+pljoTOG+ROUwI5jLlbJstrsMfHqjRw7UzC6iQSHFR2V04D4RaOO/gFAup+pgAfh\nCTa/xOQPCDxX/khbNaT0ZV0TCHXoG3o44Yo13pKs+L61cqwu+D1iusgmV/NiYekt\nXqc94Rnokb9u4DpghVMNqI2W6QwhCJbKZT+hwEuFSxpFQCnsGYiiuUNkjyqV+FSX\nw0ooNFT/TnVnlblYPJT53ydcFMLO0Tg7bJLhJq8yBt8U5j+g4CyHwIMw9qWuipZ/\n810CpoZPqIR2m8V4jQb2SBfEKQXupw2xEvGxqhCft4uJRM8KgYep+b0gPzvaelg=\n=q48s\n-----END PGP SIGNATURE-----\n", "payload": "tree e3b3fcf58b2f60f2293568fdc3196faf90f2d995\nparent 09d56a749c56b03f3b56b5d673328a58838cb5ca\nparent ccd550ee565436b4c9b7f987c19bd3a9111714f1\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1629394209 +0200\ncommitter GitHub <noreply@github.com> 1629394209 +0200\n\nRollup merge of #88093 - Kobzol:rustdoc-wrap-code-in-code-tag, r=GuillaumeGomez\n\n[rustdoc] Wrap code blocks in <code> tag\n\nThis PR modifies Rustdoc output so that fenced code snippets, items and whole file source codes are wrapped in `<pre><code>` instead of just `<pre>`. This should improve the semantic meaning of the generated content.\n\nI'm not sure what to do about `render_attributes_in_pre` and `render_attributes_in_code`. These functions were clearly expected to be used for things inside `<pre>` or `<code>`, and since I added `<code>` in this PR, some of them will be used in a different context than before. However, it seems to me that even before they were not consistent. For example, `item_constant` used `render_attributes_in_code` for its attributes, however there was no `<code>` used for constants before this PR...\n\nShould I create some `rustdoc-gui` tests? For example to check that all `<pre>` tags have a `<code>` child?\n\nFixes: https://github.com/rust-lang/rust/issues/88020\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10165f8af915ac4d57281694ea6a90041c76b5bd", "html_url": "https://github.com/rust-lang/rust/commit/10165f8af915ac4d57281694ea6a90041c76b5bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10165f8af915ac4d57281694ea6a90041c76b5bd/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d56a749c56b03f3b56b5d673328a58838cb5ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d56a749c56b03f3b56b5d673328a58838cb5ca", "html_url": "https://github.com/rust-lang/rust/commit/09d56a749c56b03f3b56b5d673328a58838cb5ca"}, {"sha": "ccd550ee565436b4c9b7f987c19bd3a9111714f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd550ee565436b4c9b7f987c19bd3a9111714f1", "html_url": "https://github.com/rust-lang/rust/commit/ccd550ee565436b4c9b7f987c19bd3a9111714f1"}], "stats": {"total": 582, "additions": 315, "deletions": 267}, "files": [{"sha": "f8fc9243e14b95891549e9dd1b835f2e42cded95", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=10165f8af915ac4d57281694ea6a90041c76b5bd", "patch": "@@ -65,10 +65,11 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n         out.push_buffer(extra);\n     }\n     if let Some(class) = class {\n-        writeln!(out, \"<pre class=\\\"rust {}\\\">\", class);\n+        write!(out, \"<pre class=\\\"rust {}\\\">\", class);\n     } else {\n-        writeln!(out, \"<pre class=\\\"rust\\\">\");\n+        write!(out, \"<pre class=\\\"rust\\\">\");\n     }\n+    write!(out, \"<code>\");\n }\n \n /// Convert the given `src` source code into HTML by adding classes for highlighting.\n@@ -101,7 +102,7 @@ fn write_code(\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n-    writeln!(out, \"</pre>{}</div>\", playground_button.unwrap_or_default());\n+    writeln!(out, \"</code></pre>{}</div>\", playground_button.unwrap_or_default());\n }\n \n /// How a span of text is classified. Mostly corresponds to token kinds."}, {"sha": "7c6d7dff816d539ed77a69521fca2df775dbfa36", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=10165f8af915ac4d57281694ea6a90041c76b5bd", "patch": "@@ -234,7 +234,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                     return Some(Event::Html(\n                         format!(\n                             \"<div class=\\\"example-wrap\\\">\\\n-                                 <pre class=\\\"language-{}\\\">{}</pre>\\\n+                                 <pre class=\\\"language-{}\\\"><code>{}</code></pre>\\\n                              </div>\",\n                             lang,\n                             Escape(&text),"}, {"sha": "96cc67ce97c756a44c8757f0dbdce9a3297471e0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 289, "deletions": 261, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=10165f8af915ac4d57281694ea6a90041c76b5bd", "patch": "@@ -454,24 +454,25 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         + name.as_str().len()\n         + generics_len;\n \n-    w.write_str(\"<pre class=\\\"rust fn\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    w.reserve(header_len);\n-    write!(\n-        w,\n-        \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n-         {name}{generics}{decl}{notable_traits}{where_clause}</pre>\",\n-        vis = vis,\n-        constness = constness,\n-        asyncness = asyncness,\n-        unsafety = unsafety,\n-        abi = abi,\n-        name = name,\n-        generics = f.generics.print(cx),\n-        where_clause = print_where_clause(&f.generics, cx, 0, true),\n-        decl = f.decl.full_print(header_len, 0, f.header.asyncness, cx),\n-        notable_traits = notable_traits_decl(&f.decl, cx),\n-    );\n+    wrap_item(w, \"fn\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        w.reserve(header_len);\n+        write!(\n+            w,\n+            \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n+             {name}{generics}{decl}{notable_traits}{where_clause}\",\n+            vis = vis,\n+            constness = constness,\n+            asyncness = asyncness,\n+            unsafety = unsafety,\n+            abi = abi,\n+            name = name,\n+            generics = f.generics.print(cx),\n+            where_clause = print_where_clause(&f.generics, cx, 0, true),\n+            decl = f.decl.full_print(header_len, 0, f.header.asyncness, cx),\n+            notable_traits = notable_traits_decl(&f.decl, cx),\n+        );\n+    });\n     document(w, cx, it, None)\n }\n \n@@ -487,108 +488,111 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n \n     // Output the trait definition\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust trait\\\">\");\n-        render_attributes_in_pre(w, it, \"\");\n-        write!(\n-            w,\n-            \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(it.def_id, cx),\n-            t.unsafety.print_with_space(),\n-            if t.is_auto { \"auto \" } else { \"\" },\n-            it.name.as_ref().unwrap(),\n-            t.generics.print(cx),\n-            bounds\n-        );\n-\n-        if !t.generics.where_predicates.is_empty() {\n-            write!(w, \"{}\", print_where_clause(&t.generics, cx, 0, true));\n-        } else {\n-            w.write_str(\" \");\n-        }\n+        wrap_item(w, \"trait\", |w| {\n+            render_attributes_in_pre(w, it, \"\");\n+            write!(\n+                w,\n+                \"{}{}{}trait {}{}{}\",\n+                it.visibility.print_with_space(it.def_id, cx),\n+                t.unsafety.print_with_space(),\n+                if t.is_auto { \"auto \" } else { \"\" },\n+                it.name.as_ref().unwrap(),\n+                t.generics.print(cx),\n+                bounds\n+            );\n \n-        if t.items.is_empty() {\n-            w.write_str(\"{ }\");\n-        } else {\n-            // FIXME: we should be using a derived_id for the Anchors here\n-            w.write_str(\"{\\n\");\n-            let mut toggle = false;\n-\n-            // If there are too many associated types, hide _everything_\n-            if should_hide_fields(count_types) {\n-                toggle = true;\n-                toggle_open(\n-                    w,\n-                    format_args!(\"{} associated items\", count_types + count_consts + count_methods),\n-                );\n-            }\n-            for t in &types {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n-            }\n-            // If there are too many associated constants, hide everything after them\n-            // We also do this if the types + consts is large because otherwise we could\n-            // render a bunch of types and _then_ a bunch of consts just because both were\n-            // _just_ under the limit\n-            if !toggle && should_hide_fields(count_types + count_consts) {\n-                toggle = true;\n-                toggle_open(\n-                    w,\n-                    format_args!(\n-                        \"{} associated constant{} and {} method{}\",\n-                        count_consts,\n-                        pluralize(count_consts),\n-                        count_methods,\n-                        pluralize(count_methods),\n-                    ),\n-                );\n-            }\n-            if !types.is_empty() && !consts.is_empty() {\n-                w.write_str(\"\\n\");\n-            }\n-            for t in &consts {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n-            }\n-            if !toggle && should_hide_fields(count_methods) {\n-                toggle = true;\n-                toggle_open(w, format_args!(\"{} methods\", count_methods));\n-            }\n-            if !consts.is_empty() && !required.is_empty() {\n-                w.write_str(\"\\n\");\n+            if !t.generics.where_predicates.is_empty() {\n+                write!(w, \"{}\", print_where_clause(&t.generics, cx, 0, true));\n+            } else {\n+                w.write_str(\" \");\n             }\n-            for (pos, m) in required.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n \n-                if pos < required.len() - 1 {\n-                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+            if t.items.is_empty() {\n+                w.write_str(\"{ }\");\n+            } else {\n+                // FIXME: we should be using a derived_id for the Anchors here\n+                w.write_str(\"{\\n\");\n+                let mut toggle = false;\n+\n+                // If there are too many associated types, hide _everything_\n+                if should_hide_fields(count_types) {\n+                    toggle = true;\n+                    toggle_open(\n+                        w,\n+                        format_args!(\n+                            \"{} associated items\",\n+                            count_types + count_consts + count_methods\n+                        ),\n+                    );\n                 }\n-            }\n-            if !required.is_empty() && !provided.is_empty() {\n-                w.write_str(\"\\n\");\n-            }\n-            for (pos, m) in provided.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                match *m.kind {\n-                    clean::MethodItem(ref inner, _)\n-                        if !inner.generics.where_predicates.is_empty() =>\n-                    {\n-                        w.write_str(\",\\n    { ... }\\n\");\n+                for t in &types {\n+                    render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    w.write_str(\";\\n\");\n+                }\n+                // If there are too many associated constants, hide everything after them\n+                // We also do this if the types + consts is large because otherwise we could\n+                // render a bunch of types and _then_ a bunch of consts just because both were\n+                // _just_ under the limit\n+                if !toggle && should_hide_fields(count_types + count_consts) {\n+                    toggle = true;\n+                    toggle_open(\n+                        w,\n+                        format_args!(\n+                            \"{} associated constant{} and {} method{}\",\n+                            count_consts,\n+                            pluralize(count_consts),\n+                            count_methods,\n+                            pluralize(count_methods),\n+                        ),\n+                    );\n+                }\n+                if !types.is_empty() && !consts.is_empty() {\n+                    w.write_str(\"\\n\");\n+                }\n+                for t in &consts {\n+                    render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    w.write_str(\";\\n\");\n+                }\n+                if !toggle && should_hide_fields(count_methods) {\n+                    toggle = true;\n+                    toggle_open(w, format_args!(\"{} methods\", count_methods));\n+                }\n+                if !consts.is_empty() && !required.is_empty() {\n+                    w.write_str(\"\\n\");\n+                }\n+                for (pos, m) in required.iter().enumerate() {\n+                    render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    w.write_str(\";\\n\");\n+\n+                    if pos < required.len() - 1 {\n+                        w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n                     }\n-                    _ => {\n-                        w.write_str(\" { ... }\\n\");\n+                }\n+                if !required.is_empty() && !provided.is_empty() {\n+                    w.write_str(\"\\n\");\n+                }\n+                for (pos, m) in provided.iter().enumerate() {\n+                    render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    match *m.kind {\n+                        clean::MethodItem(ref inner, _)\n+                            if !inner.generics.where_predicates.is_empty() =>\n+                        {\n+                            w.write_str(\",\\n    { ... }\\n\");\n+                        }\n+                        _ => {\n+                            w.write_str(\" { ... }\\n\");\n+                        }\n+                    }\n+                    if pos < provided.len() - 1 {\n+                        w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n                     }\n                 }\n-                if pos < provided.len() - 1 {\n-                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                if toggle {\n+                    toggle_close(w);\n                 }\n+                w.write_str(\"}\");\n             }\n-            if toggle {\n-                toggle_close(w);\n-            }\n-            w.write_str(\"}\");\n-        }\n-        w.write_str(\"</pre>\")\n+        });\n     });\n \n     // Trait documentation\n@@ -811,16 +815,17 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n }\n \n fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n-    w.write_str(\"<pre class=\\\"rust trait-alias\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    write!(\n-        w,\n-        \"trait {}{}{} = {};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx),\n-        print_where_clause(&t.generics, cx, 0, true),\n-        bounds(&t.bounds, true, cx)\n-    );\n+    wrap_item(w, \"trait-alias\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        write!(\n+            w,\n+            \"trait {}{}{} = {};\",\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx),\n+            print_where_clause(&t.generics, cx, 0, true),\n+            bounds(&t.bounds, true, cx)\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -832,16 +837,17 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n-    w.write_str(\"<pre class=\\\"rust opaque\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    write!(\n-        w,\n-        \"type {}{}{where_clause} = impl {bounds};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx),\n-        where_clause = print_where_clause(&t.generics, cx, 0, true),\n-        bounds = bounds(&t.bounds, false, cx),\n-    );\n+    wrap_item(w, \"opaque\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        write!(\n+            w,\n+            \"type {}{}{where_clause} = impl {bounds};\",\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx),\n+            where_clause = print_where_clause(&t.generics, cx, 0, true),\n+            bounds = bounds(&t.bounds, false, cx),\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -859,19 +865,20 @@ fn item_typedef(\n     t: &clean::Typedef,\n     is_associated: bool,\n ) {\n-    w.write_str(\"<pre class=\\\"rust typedef\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    if !is_associated {\n-        write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n-    }\n-    write!(\n-        w,\n-        \"type {}{}{where_clause} = {type_};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx),\n-        where_clause = print_where_clause(&t.generics, cx, 0, true),\n-        type_ = t.type_.print(cx),\n-    );\n+    wrap_item(w, \"typedef\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        if !is_associated {\n+            write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n+        }\n+        write!(\n+            w,\n+            \"type {}{}{where_clause} = {type_};\",\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx),\n+            where_clause = print_where_clause(&t.generics, cx, 0, true),\n+            type_ = t.type_.print(cx),\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -885,10 +892,10 @@ fn item_typedef(\n \n fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust union\\\">\");\n-        render_attributes_in_pre(w, it, \"\");\n-        render_union(w, it, Some(&s.generics), &s.fields, \"\", cx);\n-        w.write_str(\"</pre>\")\n+        wrap_item(w, \"union\", |w| {\n+            render_attributes_in_pre(w, it, \"\");\n+            render_union(w, it, Some(&s.generics), &s.fields, \"\", cx);\n+        });\n     });\n \n     document(w, cx, it, None);\n@@ -934,59 +941,68 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n \n fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust enum\\\">\");\n-        render_attributes_in_pre(w, it, \"\");\n-        write!(\n-            w,\n-            \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(it.def_id, cx),\n-            it.name.as_ref().unwrap(),\n-            e.generics.print(cx),\n-            print_where_clause(&e.generics, cx, 0, true),\n-        );\n-        if e.variants.is_empty() && !e.variants_stripped {\n-            w.write_str(\" {}\");\n-        } else {\n-            w.write_str(\" {\\n\");\n-            let count_variants = e.variants.len();\n-            let toggle = should_hide_fields(count_variants);\n-            if toggle {\n-                toggle_open(w, format_args!(\"{} variants\", count_variants));\n-            }\n-            for v in &e.variants {\n-                w.write_str(\"    \");\n-                let name = v.name.as_ref().unwrap();\n-                match *v.kind {\n-                    clean::VariantItem(ref var) => match var {\n-                        clean::Variant::CLike => write!(w, \"{}\", name),\n-                        clean::Variant::Tuple(ref tys) => {\n-                            write!(w, \"{}(\", name);\n-                            for (i, ty) in tys.iter().enumerate() {\n-                                if i > 0 {\n-                                    w.write_str(\",&nbsp;\")\n+        wrap_item(w, \"enum\", |w| {\n+            render_attributes_in_pre(w, it, \"\");\n+            write!(\n+                w,\n+                \"{}enum {}{}{}\",\n+                it.visibility.print_with_space(it.def_id, cx),\n+                it.name.as_ref().unwrap(),\n+                e.generics.print(cx),\n+                print_where_clause(&e.generics, cx, 0, true),\n+            );\n+            if e.variants.is_empty() && !e.variants_stripped {\n+                w.write_str(\" {}\");\n+            } else {\n+                w.write_str(\" {\\n\");\n+                let count_variants = e.variants.len();\n+                let toggle = should_hide_fields(count_variants);\n+                if toggle {\n+                    toggle_open(w, format_args!(\"{} variants\", count_variants));\n+                }\n+                for v in &e.variants {\n+                    w.write_str(\"    \");\n+                    let name = v.name.as_ref().unwrap();\n+                    match *v.kind {\n+                        clean::VariantItem(ref var) => match var {\n+                            clean::Variant::CLike => write!(w, \"{}\", name),\n+                            clean::Variant::Tuple(ref tys) => {\n+                                write!(w, \"{}(\", name);\n+                                for (i, ty) in tys.iter().enumerate() {\n+                                    if i > 0 {\n+                                        w.write_str(\",&nbsp;\")\n+                                    }\n+                                    write!(w, \"{}\", ty.print(cx));\n                                 }\n-                                write!(w, \"{}\", ty.print(cx));\n+                                w.write_str(\")\");\n                             }\n-                            w.write_str(\")\");\n-                        }\n-                        clean::Variant::Struct(ref s) => {\n-                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n-                        }\n-                    },\n-                    _ => unreachable!(),\n+                            clean::Variant::Struct(ref s) => {\n+                                render_struct(\n+                                    w,\n+                                    v,\n+                                    None,\n+                                    s.struct_type,\n+                                    &s.fields,\n+                                    \"    \",\n+                                    false,\n+                                    cx,\n+                                );\n+                            }\n+                        },\n+                        _ => unreachable!(),\n+                    }\n+                    w.write_str(\",\\n\");\n                 }\n-                w.write_str(\",\\n\");\n-            }\n \n-            if e.variants_stripped {\n-                w.write_str(\"    // some variants omitted\\n\");\n-            }\n-            if toggle {\n-                toggle_close(w);\n+                if e.variants_stripped {\n+                    w.write_str(\"    // some variants omitted\\n\");\n+                }\n+                if toggle {\n+                    toggle_close(w);\n+                }\n+                w.write_str(\"}\");\n             }\n-            w.write_str(\"}\");\n-        }\n-        w.write_str(\"</pre>\")\n+        });\n     });\n \n     document(w, cx, it, None);\n@@ -1090,27 +1106,27 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n     let name = it.name.as_ref().expect(\"proc-macros always have names\");\n     match m.kind {\n         MacroKind::Bang => {\n-            w.push_str(\"<pre class=\\\"rust macro\\\">\");\n-            write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n-            w.push_str(\"</pre>\");\n+            wrap_item(w, \"macro\", |w| {\n+                write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+            });\n         }\n         MacroKind::Attr => {\n-            w.push_str(\"<pre class=\\\"rust attr\\\">\");\n-            write!(w, \"#[{}]\", name);\n-            w.push_str(\"</pre>\");\n+            wrap_item(w, \"attr\", |w| {\n+                write!(w, \"#[{}]\", name);\n+            });\n         }\n         MacroKind::Derive => {\n-            w.push_str(\"<pre class=\\\"rust derive\\\">\");\n-            write!(w, \"#[derive({})]\", name);\n-            if !m.helpers.is_empty() {\n-                w.push_str(\"\\n{\\n\");\n-                w.push_str(\"    // Attributes available to this derive:\\n\");\n-                for attr in &m.helpers {\n-                    writeln!(w, \"    #[{}]\", attr);\n+            wrap_item(w, \"derive\", |w| {\n+                write!(w, \"#[derive({})]\", name);\n+                if !m.helpers.is_empty() {\n+                    w.push_str(\"\\n{\\n\");\n+                    w.push_str(\"    // Attributes available to this derive:\\n\");\n+                    for attr in &m.helpers {\n+                        writeln!(w, \"    #[{}]\", attr);\n+                    }\n+                    w.push_str(\"}\\n\");\n                 }\n-                w.push_str(\"}\\n\");\n-            }\n-            w.push_str(\"</pre>\");\n+            });\n         }\n     }\n     document(w, cx, it, None)\n@@ -1122,49 +1138,49 @@ fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n-    w.write_str(\"<pre class=\\\"rust const\\\">\");\n-    render_attributes_in_code(w, it);\n+    wrap_item(w, \"const\", |w| {\n+        render_attributes_in_code(w, it);\n \n-    write!(\n-        w,\n-        \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n-        name = it.name.as_ref().unwrap(),\n-        typ = c.type_.print(cx),\n-    );\n+        write!(\n+            w,\n+            \"{vis}const {name}: {typ}\",\n+            vis = it.visibility.print_with_space(it.def_id, cx),\n+            name = it.name.as_ref().unwrap(),\n+            typ = c.type_.print(cx),\n+        );\n \n-    let value = c.value(cx.tcx());\n-    let is_literal = c.is_literal(cx.tcx());\n-    let expr = c.expr(cx.tcx());\n-    if value.is_some() || is_literal {\n-        write!(w, \" = {expr};\", expr = Escape(&expr));\n-    } else {\n-        w.write_str(\";\");\n-    }\n+        let value = c.value(cx.tcx());\n+        let is_literal = c.is_literal(cx.tcx());\n+        let expr = c.expr(cx.tcx());\n+        if value.is_some() || is_literal {\n+            write!(w, \" = {expr};\", expr = Escape(&expr));\n+        } else {\n+            w.write_str(\";\");\n+        }\n \n-    if !is_literal {\n-        if let Some(value) = &value {\n-            let value_lowercase = value.to_lowercase();\n-            let expr_lowercase = expr.to_lowercase();\n+        if !is_literal {\n+            if let Some(value) = &value {\n+                let value_lowercase = value.to_lowercase();\n+                let expr_lowercase = expr.to_lowercase();\n \n-            if value_lowercase != expr_lowercase\n-                && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n-            {\n-                write!(w, \" // {value}\", value = Escape(value));\n+                if value_lowercase != expr_lowercase\n+                    && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n+                {\n+                    write!(w, \" // {value}\", value = Escape(value));\n+                }\n             }\n         }\n-    }\n+    });\n \n-    w.write_str(\"</pre>\");\n     document(w, cx, it, None)\n }\n \n fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust struct\\\">\");\n-        render_attributes_in_code(w, it);\n-        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n-        w.write_str(\"</pre>\")\n+        wrap_item(w, \"struct\", |w| {\n+            render_attributes_in_code(w, it);\n+            render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n+        });\n     });\n \n     document(w, cx, it, None);\n@@ -1213,28 +1229,31 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n }\n \n fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n-    w.write_str(\"<pre class=\\\"rust static\\\">\");\n-    render_attributes_in_code(w, it);\n-    write!(\n-        w,\n-        \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n-        mutability = s.mutability.print_with_space(),\n-        name = it.name.as_ref().unwrap(),\n-        typ = s.type_.print(cx)\n-    );\n+    wrap_item(w, \"static\", |w| {\n+        render_attributes_in_code(w, it);\n+        write!(\n+            w,\n+            \"{vis}static {mutability}{name}: {typ}\",\n+            vis = it.visibility.print_with_space(it.def_id, cx),\n+            mutability = s.mutability.print_with_space(),\n+            name = it.name.as_ref().unwrap(),\n+            typ = s.type_.print(cx)\n+        );\n+    });\n     document(w, cx, it, None)\n }\n \n fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n-    w.write_str(\"<pre class=\\\"rust foreigntype\\\">extern {\\n\");\n-    render_attributes_in_code(w, it);\n-    write!(\n-        w,\n-        \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(it.def_id, cx),\n-        it.name.as_ref().unwrap(),\n-    );\n+    wrap_item(w, \"foreigntype\", |w| {\n+        w.write_str(\"extern {\\n\");\n+        render_attributes_in_code(w, it);\n+        write!(\n+            w,\n+            \"    {}type {};\\n}}\",\n+            it.visibility.print_with_space(it.def_id, cx),\n+            it.name.as_ref().unwrap(),\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -1321,6 +1340,15 @@ where\n     w.write_str(\"</div>\")\n }\n \n+fn wrap_item<F>(w: &mut Buffer, item_name: &str, f: F)\n+where\n+    F: FnOnce(&mut Buffer),\n+{\n+    w.write_fmt(format_args!(\"<pre class=\\\"rust {}\\\"><code>\", item_name));\n+    f(w);\n+    w.write_str(\"</code></pre>\");\n+}\n+\n fn render_stability_since(\n     w: &mut Buffer,\n     item: &clean::Item,"}, {"sha": "23ca6eeaf3bb969be1af9f6ab6526bdfa12a0171", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=10165f8af915ac4d57281694ea6a90041c76b5bd", "patch": "@@ -249,7 +249,6 @@ code, pre, a.test-arrow, .code-header {\n }\n .docblock pre code, .docblock-short pre code {\n \tpadding: 0;\n-\tpadding-right: 1ex;\n }\n pre {\n \tpadding: 14px;"}, {"sha": "200569a28d4a43e2ad466cb0399104d134cf9e76", "filename": "src/test/rustdoc-gui/code-tags.goml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Ftest%2Frustdoc-gui%2Fcode-tags.goml", "raw_url": "https://github.com/rust-lang/rust/raw/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Ftest%2Frustdoc-gui%2Fcode-tags.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fcode-tags.goml?ref=10165f8af915ac4d57281694ea6a90041c76b5bd", "patch": "@@ -0,0 +1,20 @@\n+// This test ensures that items and documentation code blocks are wrapped in <pre><code>\n+goto: file://|DOC_PATH|/test_docs/fn.foo.html\n+size: (1080, 600)\n+// There should be three doc codeblocks\n+// Check that their content is inside <pre><code>\n+assert-count: (\".example-wrap pre > code\", 3)\n+// Check that function signature is inside <pre><code>\n+assert: \"pre.rust.fn > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n+assert: \"pre.rust.struct > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/enum.AnEnum.html\n+assert: \"pre.rust.enum > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/trait.AnotherOne.html\n+assert: \"pre.rust.trait > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/type.SomeType.html\n+assert: \"pre.rust.typedef > code\""}, {"sha": "5a49807e180b27d06fe1b15b157fb8dd14cff7b9", "filename": "src/test/rustdoc-gui/source-code-page.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml", "raw_url": "https://github.com/rust-lang/rust/raw/10165f8af915ac4d57281694ea6a90041c76b5bd/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml?ref=10165f8af915ac4d57281694ea6a90041c76b5bd", "patch": "@@ -12,4 +12,4 @@ assert-attribute: (\".line-numbers > span:nth-child(5)\", {\"class\": \"line-highligh\n assert-attribute: (\".line-numbers > span:nth-child(6)\", {\"class\": \"line-highlighted\"})\n assert-attribute-false: (\".line-numbers > span:nth-child(7)\", {\"class\": \"line-highlighted\"})\n // This is to ensure that the content is correctly align with the line numbers.\n-compare-elements-position: (\"//*[@id='1']\", \".rust > span\", (\"y\"))\n+compare-elements-position: (\"//*[@id='1']\", \".rust > code > span\", (\"y\"))"}]}