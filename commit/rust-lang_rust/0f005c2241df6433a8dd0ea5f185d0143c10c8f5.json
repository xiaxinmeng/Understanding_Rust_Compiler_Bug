{"sha": "0f005c2241df6433a8dd0ea5f185d0143c10c8f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMDA1YzIyNDFkZjY0MzNhOGRkMGVhNWYxODVkMDE0M2MxMGM4ZjU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-05T12:23:11Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-21T15:07:24Z"}, "message": "BTreeMap: address namespace conflicts", "tree": {"sha": "97e23b4f56f8c954018867dcb2eb932fbb861140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97e23b4f56f8c954018867dcb2eb932fbb861140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f005c2241df6433a8dd0ea5f185d0143c10c8f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f005c2241df6433a8dd0ea5f185d0143c10c8f5", "html_url": "https://github.com/rust-lang/rust/commit/0f005c2241df6433a8dd0ea5f185d0143c10c8f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f005c2241df6433a8dd0ea5f185d0143c10c8f5/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29a74e62857bc8c51723402dee5873ef0fe2cd83", "url": "https://api.github.com/repos/rust-lang/rust/commits/29a74e62857bc8c51723402dee5873ef0fe2cd83", "html_url": "https://github.com/rust-lang/rust/commit/29a74e62857bc8c51723402dee5873ef0fe2cd83"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "8c7913b533b5f2a16945c572f3fd04cd46ccbfa6", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0f005c2241df6433a8dd0ea5f185d0143c10c8f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f005c2241df6433a8dd0ea5f185d0143c10c8f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=0f005c2241df6433a8dd0ea5f185d0143c10c8f5", "patch": "@@ -6,13 +6,14 @@ use crate::fmt::Debug;\n use crate::rc::Rc;\n use crate::string::{String, ToString};\n use crate::vec::Vec;\n+use std::cmp::Ordering;\n use std::convert::TryFrom;\n use std::iter::{self, FromIterator};\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n \n mod ord_chaos;\n use ord_chaos::{Cyclic3, Governed, Governor};\n@@ -1094,7 +1095,7 @@ mod test_drain_filter {\n         struct D;\n         impl Drop for D {\n             fn drop(&mut self) {\n-                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                if DROPS.fetch_add(1, SeqCst) == 1 {\n                     panic!(\"panic in `drop`\");\n                 }\n             }\n@@ -1105,14 +1106,14 @@ mod test_drain_filter {\n \n         catch_unwind(move || {\n             drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                PREDS.fetch_add(1usize << i, SeqCst);\n                 true\n             }))\n         })\n         .unwrap_err();\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+        assert_eq!(PREDS.load(SeqCst), 0x011);\n+        assert_eq!(DROPS.load(SeqCst), 3);\n     }\n \n     #[test]\n@@ -1123,7 +1124,7 @@ mod test_drain_filter {\n         struct D;\n         impl Drop for D {\n             fn drop(&mut self) {\n-                DROPS.fetch_add(1, Ordering::SeqCst);\n+                DROPS.fetch_add(1, SeqCst);\n             }\n         }\n \n@@ -1132,7 +1133,7 @@ mod test_drain_filter {\n \n         catch_unwind(AssertUnwindSafe(|| {\n             drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                PREDS.fetch_add(1usize << i, SeqCst);\n                 match i {\n                     0 => true,\n                     _ => panic!(),\n@@ -1141,8 +1142,8 @@ mod test_drain_filter {\n         }))\n         .unwrap_err();\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(PREDS.load(SeqCst), 0x011);\n+        assert_eq!(DROPS.load(SeqCst), 1);\n         assert_eq!(map.len(), 2);\n         assert_eq!(map.first_entry().unwrap().key(), &4);\n         assert_eq!(map.last_entry().unwrap().key(), &8);\n@@ -1158,7 +1159,7 @@ mod test_drain_filter {\n         struct D;\n         impl Drop for D {\n             fn drop(&mut self) {\n-                DROPS.fetch_add(1, Ordering::SeqCst);\n+                DROPS.fetch_add(1, SeqCst);\n             }\n         }\n \n@@ -1167,7 +1168,7 @@ mod test_drain_filter {\n \n         {\n             let mut it = map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                PREDS.fetch_add(1usize << i, SeqCst);\n                 match i {\n                     0 => true,\n                     _ => panic!(),\n@@ -1180,8 +1181,8 @@ mod test_drain_filter {\n             assert!(matches!(result, Ok(None)));\n         }\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(PREDS.load(SeqCst), 0x011);\n+        assert_eq!(DROPS.load(SeqCst), 1);\n         assert_eq!(map.len(), 2);\n         assert_eq!(map.first_entry().unwrap().key(), &4);\n         assert_eq!(map.last_entry().unwrap().key(), &8);\n@@ -1315,8 +1316,6 @@ fn test_zst() {\n // undefined.\n #[test]\n fn test_bad_zst() {\n-    use std::cmp::Ordering;\n-\n     #[derive(Clone, Copy, Debug)]\n     struct Bad;\n \n@@ -1763,7 +1762,7 @@ fn test_append_drop_leak() {\n \n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == 0 {\n+            if DROPS.fetch_add(1, SeqCst) == 0 {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n@@ -1779,7 +1778,7 @@ fn test_append_drop_leak() {\n \n     catch_unwind(move || left.append(&mut right)).unwrap_err();\n \n-    assert_eq!(DROPS.load(Ordering::SeqCst), 4); // Rust issue #47949 ate one little piggy\n+    assert_eq!(DROPS.load(SeqCst), 4); // Rust issue #47949 ate one little piggy\n }\n \n #[test]\n@@ -1894,7 +1893,7 @@ fn test_into_iter_drop_leak_height_0() {\n \n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == 3 {\n+            if DROPS.fetch_add(1, SeqCst) == 3 {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n@@ -1909,7 +1908,7 @@ fn test_into_iter_drop_leak_height_0() {\n \n     catch_unwind(move || drop(map.into_iter())).unwrap_err();\n \n-    assert_eq!(DROPS.load(Ordering::SeqCst), 5);\n+    assert_eq!(DROPS.load(SeqCst), 5);\n }\n \n #[test]\n@@ -1921,18 +1920,18 @@ fn test_into_iter_drop_leak_height_1() {\n     struct D;\n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == PANIC_POINT.load(Ordering::SeqCst) {\n+            if DROPS.fetch_add(1, SeqCst) == PANIC_POINT.load(SeqCst) {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n     }\n \n     for panic_point in vec![0, 1, size - 2, size - 1] {\n-        DROPS.store(0, Ordering::SeqCst);\n-        PANIC_POINT.store(panic_point, Ordering::SeqCst);\n+        DROPS.store(0, SeqCst);\n+        PANIC_POINT.store(panic_point, SeqCst);\n         let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n         catch_unwind(move || drop(map.into_iter())).unwrap_err();\n-        assert_eq!(DROPS.load(Ordering::SeqCst), size);\n+        assert_eq!(DROPS.load(SeqCst), size);\n     }\n }\n "}, {"sha": "93de2d829ac8d9c6249d5da7efe38131cafca51b", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f005c2241df6433a8dd0ea5f185d0143c10c8f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f005c2241df6433a8dd0ea5f185d0143c10c8f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=0f005c2241df6433a8dd0ea5f185d0143c10c8f5", "patch": "@@ -50,7 +50,7 @@ where\n {\n     match search_linear(&node, key) {\n         (idx, true) => Found(unsafe { Handle::new_kv(node, idx) }),\n-        (idx, false) => SearchResult::GoDown(unsafe { Handle::new_edge(node, idx) }),\n+        (idx, false) => GoDown(unsafe { Handle::new_edge(node, idx) }),\n     }\n }\n "}, {"sha": "4d05bc4ebfa1e9aa5255d60f5103b123496f6504", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f005c2241df6433a8dd0ea5f185d0143c10c8f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f005c2241df6433a8dd0ea5f185d0143c10c8f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=0f005c2241df6433a8dd0ea5f185d0143c10c8f5", "patch": "@@ -1,9 +1,10 @@\n use super::super::DeterministicRng;\n use super::*;\n use crate::vec::Vec;\n+use std::cmp::Ordering;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicU32, Ordering};\n+use std::sync::atomic::{AtomicU32, Ordering::SeqCst};\n \n #[test]\n fn test_clone_eq() {\n@@ -355,7 +356,7 @@ fn test_drain_filter_drop_panic_leak() {\n     struct D(i32);\n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+            if DROPS.fetch_add(1, SeqCst) == 1 {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n@@ -368,14 +369,14 @@ fn test_drain_filter_drop_panic_leak() {\n \n     catch_unwind(move || {\n         drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            PREDS.fetch_add(1u32 << d.0, SeqCst);\n             true\n         }))\n     })\n     .ok();\n \n-    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    assert_eq!(PREDS.load(SeqCst), 0x011);\n+    assert_eq!(DROPS.load(SeqCst), 3);\n }\n \n #[test]\n@@ -387,7 +388,7 @@ fn test_drain_filter_pred_panic_leak() {\n     struct D(i32);\n     impl Drop for D {\n         fn drop(&mut self) {\n-            DROPS.fetch_add(1, Ordering::SeqCst);\n+            DROPS.fetch_add(1, SeqCst);\n         }\n     }\n \n@@ -398,7 +399,7 @@ fn test_drain_filter_pred_panic_leak() {\n \n     catch_unwind(AssertUnwindSafe(|| {\n         drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            PREDS.fetch_add(1u32 << d.0, SeqCst);\n             match d.0 {\n                 0 => true,\n                 _ => panic!(),\n@@ -407,8 +408,8 @@ fn test_drain_filter_pred_panic_leak() {\n     }))\n     .ok();\n \n-    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-    assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+    assert_eq!(PREDS.load(SeqCst), 0x011);\n+    assert_eq!(DROPS.load(SeqCst), 1);\n     assert_eq!(set.len(), 2);\n     assert_eq!(set.first().unwrap().0, 4);\n     assert_eq!(set.last().unwrap().0, 8);\n@@ -498,8 +499,6 @@ fn test_extend_ref() {\n \n #[test]\n fn test_recovery() {\n-    use std::cmp::Ordering;\n-\n     #[derive(Debug)]\n     struct Foo(&'static str, i32);\n "}]}