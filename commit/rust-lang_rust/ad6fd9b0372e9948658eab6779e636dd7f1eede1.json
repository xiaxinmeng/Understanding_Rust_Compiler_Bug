{"sha": "ad6fd9b0372e9948658eab6779e636dd7f1eede1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNmZkOWIwMzcyZTk5NDg2NThlYWI2Nzc5ZTYzNmRkN2YxZWVkZTE=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-18T14:46:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-18T14:46:27Z"}, "message": "Rollup merge of #79039 - thomcc:weakly-relaxing, r=Amanieu\n\nTighten the bounds on atomic Ordering in std::sys::unix::weak::Weak\n\nThis moves reading this from multiple SeqCst reads to Relaxed read + Acquire fence if we are actually going to use the data.\n\nWould love to avoid the Acquire fence, but doing so would need Ordering::Consume, which neither Rust, nor LLVM supports (a shame, since this fence is hardly free on ARM, which is what I was hoping to improve).\n\nr? ``@Amanieu`` (Sorry for always picking you, but I know a lot of people wouldn't feel comfortable reviewing atomic ordering changes)", "tree": {"sha": "f3d4c05999977cea37512536a3789f1798ac2193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3d4c05999977cea37512536a3789f1798ac2193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad6fd9b0372e9948658eab6779e636dd7f1eede1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJftTPDCRBK7hj4Ov3rIwAAdHIIAGKbPKz/U2W1KHBm7hGPOMca\nO0wIceEUrIyDuEVOq2y6WsA0Y65Y9CVemXBqerdkDHWX8ZyoTwUqqY+GHRxxtKC+\nlv4i3FkfW1wezEov0kMXjMlDQOa/lKAOBcgYVy5AABg6xUFAQYbbxr+8vQd2Wf8q\nj4nzPT5YQuth95w5T8r5xHWSKDoU9ZQiDb/F5laYRkb4riWyMkmmprnDMtP3ffGi\nl+HRSx45xnpKGgeAhSK2gU9xX0NsQ2ZPE64GqKolzwYrFYRn8B/VhXxY3ue/sESv\niBVIGo8fd86c7HW8tlbMMsAk489Eg2XYvGGizoz5qmmtIFyt6bTKSkAhVvkobSA=\n=4xuK\n-----END PGP SIGNATURE-----\n", "payload": "tree f3d4c05999977cea37512536a3789f1798ac2193\nparent 92dcf6d733e48189f7c9fdd9da66fb55370590c3\nparent 55d7f736d8c62cc0a03594302538001ef3f3411d\nauthor Mara Bos <m-ou.se@m-ou.se> 1605710787 +0100\ncommitter GitHub <noreply@github.com> 1605710787 +0100\n\nRollup merge of #79039 - thomcc:weakly-relaxing, r=Amanieu\n\nTighten the bounds on atomic Ordering in std::sys::unix::weak::Weak\n\nThis moves reading this from multiple SeqCst reads to Relaxed read + Acquire fence if we are actually going to use the data.\n\nWould love to avoid the Acquire fence, but doing so would need Ordering::Consume, which neither Rust, nor LLVM supports (a shame, since this fence is hardly free on ARM, which is what I was hoping to improve).\n\nr? ``@Amanieu`` (Sorry for always picking you, but I know a lot of people wouldn't feel comfortable reviewing atomic ordering changes)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6fd9b0372e9948658eab6779e636dd7f1eede1", "html_url": "https://github.com/rust-lang/rust/commit/ad6fd9b0372e9948658eab6779e636dd7f1eede1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad6fd9b0372e9948658eab6779e636dd7f1eede1/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92dcf6d733e48189f7c9fdd9da66fb55370590c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/92dcf6d733e48189f7c9fdd9da66fb55370590c3", "html_url": "https://github.com/rust-lang/rust/commit/92dcf6d733e48189f7c9fdd9da66fb55370590c3"}, {"sha": "55d7f736d8c62cc0a03594302538001ef3f3411d", "url": "https://api.github.com/repos/rust-lang/rust/commits/55d7f736d8c62cc0a03594302538001ef3f3411d", "html_url": "https://github.com/rust-lang/rust/commit/55d7f736d8c62cc0a03594302538001ef3f3411d"}], "stats": {"total": 46, "additions": 40, "deletions": 6}, "files": [{"sha": "53d95dca4cd8272b27f3f1894db27e230d0320b8", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ad6fd9b0372e9948658eab6779e636dd7f1eede1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad6fd9b0372e9948658eab6779e636dd7f1eede1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=ad6fd9b0372e9948658eab6779e636dd7f1eede1", "patch": "@@ -24,7 +24,7 @@\n use crate::ffi::CStr;\n use crate::marker;\n use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::atomic::{self, AtomicUsize, Ordering};\n \n macro_rules! weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n@@ -47,15 +47,49 @@ impl<F> Weak<F> {\n     pub fn get(&self) -> Option<F> {\n         assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n         unsafe {\n-            if self.addr.load(Ordering::SeqCst) == 1 {\n-                self.addr.store(fetch(self.name), Ordering::SeqCst);\n-            }\n-            match self.addr.load(Ordering::SeqCst) {\n+            // Relaxed is fine here because we fence before reading through the\n+            // pointer (see the comment below).\n+            match self.addr.load(Ordering::Relaxed) {\n+                1 => self.initialize(),\n                 0 => None,\n-                addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+                addr => {\n+                    let func = mem::transmute_copy::<usize, F>(&addr);\n+                    // The caller is presumably going to read through this value\n+                    // (by calling the function we've dlsymed). This means we'd\n+                    // need to have loaded it with at least C11's consume\n+                    // ordering in order to be guaranteed that the data we read\n+                    // from the pointer isn't from before the pointer was\n+                    // stored. Rust has no equivalent to memory_order_consume,\n+                    // so we use an acquire fence (sorry, ARM).\n+                    //\n+                    // Now, in practice this likely isn't needed even on CPUs\n+                    // where relaxed and consume mean different things. The\n+                    // symbols we're loading are probably present (or not) at\n+                    // init, and even if they aren't the runtime dynamic loader\n+                    // is extremely likely have sufficient barriers internally\n+                    // (possibly implicitly, for example the ones provided by\n+                    // invoking `mprotect`).\n+                    //\n+                    // That said, none of that's *guaranteed*, and so we fence.\n+                    atomic::fence(Ordering::Acquire);\n+                    Some(func)\n+                }\n             }\n         }\n     }\n+\n+    // Cold because it should only happen during first-time initalization.\n+    #[cold]\n+    unsafe fn initialize(&self) -> Option<F> {\n+        let val = fetch(self.name);\n+        // This synchronizes with the acquire fence in `get`.\n+        self.addr.store(val, Ordering::Release);\n+\n+        match val {\n+            0 => None,\n+            addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+        }\n+    }\n }\n \n unsafe fn fetch(name: &str) -> usize {"}]}