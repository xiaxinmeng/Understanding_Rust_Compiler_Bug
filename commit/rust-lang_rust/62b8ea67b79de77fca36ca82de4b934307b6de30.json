{"sha": "62b8ea67b79de77fca36ca82de4b934307b6de30", "node_id": "C_kwDOAAsO6NoAKDYyYjhlYTY3Yjc5ZGU3N2ZjYTM2Y2E4MmRlNGI5MzQzMDdiNmRlMzA", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-02-17T22:52:52Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-03-24T05:31:57Z"}, "message": "Emit both subexp and standalone sugg for postfix\n\nThis solves the TODO.", "tree": {"sha": "1c2818418eefb84dcc63361b6a1bce2ddd7b90bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c2818418eefb84dcc63361b6a1bce2ddd7b90bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62b8ea67b79de77fca36ca82de4b934307b6de30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62b8ea67b79de77fca36ca82de4b934307b6de30", "html_url": "https://github.com/rust-lang/rust/commit/62b8ea67b79de77fca36ca82de4b934307b6de30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62b8ea67b79de77fca36ca82de4b934307b6de30/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7287f929b9c4a684be6ea8980970de7693eef841", "url": "https://api.github.com/repos/rust-lang/rust/commits/7287f929b9c4a684be6ea8980970de7693eef841", "html_url": "https://github.com/rust-lang/rust/commit/7287f929b9c4a684be6ea8980970de7693eef841"}], "stats": {"total": 101, "additions": 70, "deletions": 31}, "files": [{"sha": "26ca018685e0165235e68d56cae936ce337f3d2f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/62b8ea67b79de77fca36ca82de4b934307b6de30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b8ea67b79de77fca36ca82de4b934307b6de30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=62b8ea67b79de77fca36ca82de4b934307b6de30", "patch": "@@ -160,8 +160,10 @@ impl AttemptLocalParseRecovery {\n /// C-style `i++`, `--i`, etc.\n #[derive(Debug, Copy, Clone)]\n struct IncDecRecovery {\n-    /// This increment/decrement is not a subexpression.\n-    standalone: bool,\n+    /// Is this increment/decrement its own statement?\n+    ///\n+    /// This is `None` when we are unsure.\n+    standalone: Option<bool>,\n     /// Is this an increment or decrement?\n     op: IncOrDec,\n     /// Is this pre- or postfix?\n@@ -1225,7 +1227,7 @@ impl<'a> Parser<'a> {\n         prev_is_semi: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let kind = IncDecRecovery {\n-            standalone: prev_is_semi,\n+            standalone: Some(prev_is_semi),\n             op: IncOrDec::Inc,\n             fixity: UnaryFixity::Pre,\n         };\n@@ -1237,13 +1239,9 @@ impl<'a> Parser<'a> {\n         &mut self,\n         operand_expr: P<Expr>,\n         op_span: Span,\n-        prev_is_semi: bool,\n     ) -> PResult<'a, P<Expr>> {\n-        let kind = IncDecRecovery {\n-            standalone: prev_is_semi,\n-            op: IncOrDec::Inc,\n-            fixity: UnaryFixity::Post,\n-        };\n+        let kind =\n+            IncDecRecovery { standalone: None, op: IncOrDec::Inc, fixity: UnaryFixity::Post };\n \n         self.recover_from_inc_dec(operand_expr, kind, op_span)\n     }\n@@ -1272,25 +1270,44 @@ impl<'a> Parser<'a> {\n             UnaryFixity::Post => (base.span.shrink_to_lo(), op_span),\n         };\n \n-        if kind.standalone {\n-            self.inc_dec_standalone_recovery(err, kind, spans)\n-        } else {\n-            let Ok(base_src) = self.span_to_snippet(base.span)\n-                else { return help_base_case(err, base) };\n-            match kind.fixity {\n-                UnaryFixity::Pre => self.prefix_inc_dec_suggest(base_src, err, kind, spans),\n-                UnaryFixity::Post => self.postfix_inc_dec_suggest(base_src, err, kind, spans),\n+        match kind.standalone {\n+            Some(true) => self.inc_dec_standalone_recovery(&mut err, kind, spans, false),\n+            Some(false) => {\n+                let Ok(base_src) = self.span_to_snippet(base.span)\n+                    else { return help_base_case(err, base) };\n+                match kind.fixity {\n+                    UnaryFixity::Pre => {\n+                        self.prefix_inc_dec_suggest(base_src, &mut err, kind, spans)\n+                    }\n+                    UnaryFixity::Post => {\n+                        self.postfix_inc_dec_suggest(base_src, &mut err, kind, spans)\n+                    }\n+                }\n+            }\n+            None => {\n+                let Ok(base_src) = self.span_to_snippet(base.span)\n+                    else { return help_base_case(err, base) };\n+                match kind.fixity {\n+                    UnaryFixity::Pre => {\n+                        self.prefix_inc_dec_suggest(base_src, &mut err, kind, spans)\n+                    }\n+                    UnaryFixity::Post => {\n+                        self.postfix_inc_dec_suggest(base_src, &mut err, kind, spans)\n+                    }\n+                }\n+                self.inc_dec_standalone_recovery(&mut err, kind, spans, true)\n             }\n         }\n+        Err(err)\n     }\n \n     fn prefix_inc_dec_suggest(\n         &mut self,\n         base_src: String,\n-        mut err: DiagnosticBuilder<'a>,\n+        err: &mut DiagnosticBuilder<'a>,\n         kind: IncDecRecovery,\n         (pre_span, post_span): (Span, Span),\n-    ) -> PResult<'a, P<Expr>> {\n+    ) {\n         err.multipart_suggestion(\n             &format!(\"use `{}= 1` instead\", kind.op.chr()),\n             vec![\n@@ -1299,16 +1316,15 @@ impl<'a> Parser<'a> {\n             ],\n             Applicability::MachineApplicable,\n         );\n-        Err(err)\n     }\n \n     fn postfix_inc_dec_suggest(\n         &mut self,\n         base_src: String,\n-        mut err: DiagnosticBuilder<'a>,\n+        err: &mut DiagnosticBuilder<'a>,\n         kind: IncDecRecovery,\n         (pre_span, post_span): (Span, Span),\n-    ) -> PResult<'a, P<Expr>> {\n+    ) {\n         err.multipart_suggestion(\n             &format!(\"use `{}= 1` instead\", kind.op.chr()),\n             vec![\n@@ -1317,21 +1333,31 @@ impl<'a> Parser<'a> {\n             ],\n             Applicability::MachineApplicable,\n         );\n-        Err(err)\n     }\n \n     fn inc_dec_standalone_recovery(\n         &mut self,\n-        mut err: DiagnosticBuilder<'a>,\n+        err: &mut DiagnosticBuilder<'a>,\n         kind: IncDecRecovery,\n         (pre_span, post_span): (Span, Span),\n-    ) -> PResult<'a, P<Expr>> {\n+        maybe_not_standalone: bool,\n+    ) {\n+        let msg = if maybe_not_standalone {\n+            \"or, if you don't need to use it as an expression, change it to this\".to_owned()\n+        } else {\n+            format!(\"use `{}= 1` instead\", kind.op.chr())\n+        };\n+        let applicability = if maybe_not_standalone {\n+            // FIXME: Unspecified isn't right, but it's the least wrong option\n+            Applicability::Unspecified\n+        } else {\n+            Applicability::MachineApplicable\n+        };\n         err.multipart_suggestion(\n-            &format!(\"use `{}= 1` instead\", kind.op.chr()),\n+            &msg,\n             vec![(pre_span, String::new()), (post_span, format!(\" {}= 1\", kind.op.chr()))],\n-            Applicability::MachineApplicable,\n+            applicability,\n         );\n-        Err(err)\n     }\n \n     /// Tries to recover from associated item paths like `[T]::AssocItem` / `(T, U)::AssocItem`."}, {"sha": "c9864fb9fa31395f399a8d1cd513df080ecca593", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b8ea67b79de77fca36ca82de4b934307b6de30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b8ea67b79de77fca36ca82de4b934307b6de30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=62b8ea67b79de77fca36ca82de4b934307b6de30", "patch": "@@ -273,9 +273,7 @@ impl<'a> Parser<'a> {\n                 let op_span = self.prev_token.span.to(self.token.span);\n                 // Eat the second `+`\n                 self.bump();\n-                // TODO: implement\n-                let start_is_semi = false;\n-                lhs = self.maybe_recover_from_postfix_increment(lhs, op_span, start_is_semi)?;\n+                lhs = self.maybe_recover_from_postfix_increment(lhs, op_span)?;\n                 continue;\n             }\n "}, {"sha": "e5386c7bdbaa6e8fd294c3b7dc8640bfec8570a1", "filename": "src/test/ui/parser/increment-autofix.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62b8ea67b79de77fca36ca82de4b934307b6de30/src%2Ftest%2Fui%2Fparser%2Fincrement-autofix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62b8ea67b79de77fca36ca82de4b934307b6de30/src%2Ftest%2Fui%2Fparser%2Fincrement-autofix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fincrement-autofix.stderr?ref=62b8ea67b79de77fca36ca82de4b934307b6de30", "patch": "@@ -8,6 +8,11 @@ help: use `+= 1` instead\n    |\n LL |     { let tmp = i; i += 1; tmp };\n    |     +++++++++++  ~~~~~~~~~~~~~~~\n+help: or, if you don't need to use it as an expression, change it to this\n+   |\n+LL -     i++;\n+LL +     i += 1;\n+   | \n \n error: Rust has no postfix increment operator\n   --> $DIR/increment-autofix.rs:11:12\n@@ -19,6 +24,11 @@ help: use `+= 1` instead\n    |\n LL |     while { let tmp = i; i += 1; tmp } < 5 {\n    |           +++++++++++  ~~~~~~~~~~~~~~~\n+help: or, if you don't need to use it as an expression, change it to this\n+   |\n+LL -     while i++ < 5 {\n+LL +     while i += 1 < 5 {\n+   | \n \n error: Rust has no prefix increment operator\n   --> $DIR/increment-autofix.rs:19:5"}, {"sha": "43586c4c25efb4be06092e08842e23958c0f9f02", "filename": "src/test/ui/parser/increment-notfixed.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62b8ea67b79de77fca36ca82de4b934307b6de30/src%2Ftest%2Fui%2Fparser%2Fincrement-notfixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62b8ea67b79de77fca36ca82de4b934307b6de30/src%2Ftest%2Fui%2Fparser%2Fincrement-notfixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fincrement-notfixed.stderr?ref=62b8ea67b79de77fca36ca82de4b934307b6de30", "patch": "@@ -8,6 +8,11 @@ help: use `+= 1` instead\n    |\n LL |     { let tmp = foo.bar.qux; foo.bar.qux += 1; tmp };\n    |     +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n+help: or, if you don't need to use it as an expression, change it to this\n+   |\n+LL -     foo.bar.qux++;\n+LL +     foo.bar.qux += 1;\n+   | \n \n error: Rust has no prefix increment operator\n   --> $DIR/increment-notfixed.rs:18:5"}]}