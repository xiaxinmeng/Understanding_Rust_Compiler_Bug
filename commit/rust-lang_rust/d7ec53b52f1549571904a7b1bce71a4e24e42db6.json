{"sha": "d7ec53b52f1549571904a7b1bce71a4e24e42db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZWM1M2I1MmYxNTQ5NTcxOTA0YTdiMWJjZTcxYTRlMjRlNDJkYjY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-17T11:25:40Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-17T11:25:40Z"}, "message": "Merge pull request #192 from Manishearth/const_cmp\n\nConst cmp", "tree": {"sha": "565458c2a17e2db7081476808bbf436a8c0c8572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/565458c2a17e2db7081476808bbf436a8c0c8572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7ec53b52f1549571904a7b1bce71a4e24e42db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ec53b52f1549571904a7b1bce71a4e24e42db6", "html_url": "https://github.com/rust-lang/rust/commit/d7ec53b52f1549571904a7b1bce71a4e24e42db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7ec53b52f1549571904a7b1bce71a4e24e42db6/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5087913304596addd650a30a857371b505d28d90", "url": "https://api.github.com/repos/rust-lang/rust/commits/5087913304596addd650a30a857371b505d28d90", "html_url": "https://github.com/rust-lang/rust/commit/5087913304596addd650a30a857371b505d28d90"}, {"sha": "4394362836a2fb8ba0b8c225eb5ef0b441272897", "url": "https://api.github.com/repos/rust-lang/rust/commits/4394362836a2fb8ba0b8c225eb5ef0b441272897", "html_url": "https://github.com/rust-lang/rust/commit/4394362836a2fb8ba0b8c225eb5ef0b441272897"}], "stats": {"total": 99, "additions": 92, "deletions": 7}, "files": [{"sha": "e39faf9e39abecab96a4fa799ba12b635623c3b8", "filename": "src/consts.rs", "status": "modified", "additions": 87, "deletions": 6, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec53b52f1549571904a7b1bce71a4e24e42db6/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec53b52f1549571904a7b1bce71a4e24e42db6/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=d7ec53b52f1549571904a7b1bce71a4e24e42db6", "patch": "@@ -4,6 +4,8 @@ use rustc::middle::def::PathResolution;\n use rustc::middle::def::Def::*;\n use syntax::ast::*;\n use syntax::ptr::P;\n+use std::cmp::PartialOrd;\n+use std::cmp::Ordering::{self, Greater, Less, Equal};\n use std::rc::Rc;\n use std::ops::Deref;\n use self::ConstantVariant::*;\n@@ -52,8 +54,14 @@ impl Constant {\n     }\n }\n \n+impl PartialOrd for Constant {\n+    fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n+        self.constant.partial_cmp(&other.constant)\n+    }\n+}\n+\n /// a Lit_-like enum to fold constant `Expr`s into\n-#[derive(PartialEq, Eq, Debug, Clone)] //TODO: A better PartialEq, remove Eq\n+#[derive(Eq, Debug, Clone)]\n pub enum ConstantVariant {\n     /// a String \"abc\"\n     ConstantStr(String, StrStyle),\n@@ -92,6 +100,73 @@ impl ConstantVariant {\n     }\n }\n \n+impl PartialEq for ConstantVariant {\n+    fn eq(&self, other: &ConstantVariant) -> bool {\n+        match (self, other) {\n+            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) =>\n+                ls == rs && lsty == rsty,\n+            (&ConstantBinary(ref l),&ConstantBinary(ref r)) => l == r,\n+            (&ConstantByte(l), &ConstantByte(r)) => l == r,\n+            (&ConstantChar(l), &ConstantChar(r)) => l == r,\n+            (&ConstantInt(lv, lty), &ConstantInt(rv, rty)) => lv == rv &&\n+               is_negative(lty) == is_negative(rty),\n+            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) =>\n+                if match (lw, rw) {\n+                    (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n+                    _ => false,\n+                } {\n+                    match (ls.parse::<f64>(), rs.parse::<f64>()) {\n+                        (Ok(l), Ok(r)) => l.eq(&r),\n+                        _ => false,\n+                    }\n+                } else { false },\n+            (&ConstantBool(l), &ConstantBool(r)) => l == r,\n+            (&ConstantVec(ref l), &ConstantVec(ref r)) => l == r,\n+            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) =>\n+                ls == rs && lv == rv,\n+            (&ConstantTuple(ref l), &ConstantTuple(ref r)) => l == r,\n+            _ => false, //TODO: Are there inter-type equalities?\n+        }\n+    }\n+}\n+\n+impl PartialOrd for ConstantVariant {\n+    fn partial_cmp(&self, other: &ConstantVariant) -> Option<Ordering> {\n+        match (self, other) {\n+            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) =>\n+                if lsty != rsty { None } else { Some(ls.cmp(rs)) },\n+            (&ConstantByte(ref l), &ConstantByte(ref r)) => Some(l.cmp(r)),\n+            (&ConstantChar(ref l), &ConstantChar(ref r)) => Some(l.cmp(r)),\n+            (&ConstantInt(ref lv, lty), &ConstantInt(ref rv, rty)) =>\n+                Some(match (is_negative(lty), is_negative(rty)) {\n+                    (true, true) => lv.cmp(rv),\n+                    (false, false) => rv.cmp(lv),\n+                    (true, false) => Greater,\n+                    (false, true) => Less,\n+                }),\n+            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) =>\n+                if match (lw, rw) {\n+                    (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n+                    _ => false,\n+                } {\n+                    match (ls.parse::<f64>(), rs.parse::<f64>()) {\n+                        (Ok(ref l), Ok(ref r)) => l.partial_cmp(r),\n+                        _ => None,\n+                    }\n+                } else { None },\n+            (&ConstantBool(ref l), &ConstantBool(ref r)) => Some(l.cmp(r)),\n+            (&ConstantVec(ref l), &ConstantVec(ref r)) => l.partial_cmp(&r),\n+            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) =>\n+                match lv.partial_cmp(rv) {\n+                    Some(Equal) => Some(ls.cmp(rs)),\n+                    x => x,\n+                },\n+            (&ConstantTuple(ref l), &ConstantTuple(ref r)) => l.partial_cmp(r),\n+             _ => None, //TODO: Are there any useful inter-type orderings?\n+         }\n+    }\n+}\n+\n /// simple constant folding: Insert an expression, get a constant or none.\n pub fn constant(cx: &Context, e: &Expr) -> Option<Constant> {\n     match &e.node {\n@@ -300,7 +375,7 @@ fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr)\n                         }\n                     }\n                 },\n-                // TODO: float\n+                // TODO: float (would need bignum library?)\n                 _ => None\n             }),\n         BiSub => constant_binop_apply(cx, left, right, |l, r|\n@@ -334,16 +409,22 @@ fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr)\n         //BiShr,\n         BiEq => constant_binop_apply(cx, left, right,\n             |l, r| Some(ConstantBool(l == r))),\n-        //BiLt,\n-        //BiLe,\n         BiNe => constant_binop_apply(cx, left, right,\n             |l, r| Some(ConstantBool(l != r))),\n-        //BiGe,\n-        //BiGt,\n+        BiLt => constant_cmp(cx, left, right, Less, true),\n+        BiLe => constant_cmp(cx, left, right, Greater, false),\n+        BiGe => constant_cmp(cx, left, right, Less, false),\n+        BiGt => constant_cmp(cx, left, right, Greater, true),\n         _ => None,\n     }\n }\n \n+fn constant_cmp(cx: &Context, left: &Expr, right: &Expr, ordering: Ordering,\n+        b: bool) -> Option<Constant> {\n+    constant_binop_apply(cx, left, right, |l, r| l.partial_cmp(&r).map(|o|\n+        ConstantBool(b == (o == ordering))))\n+}\n+\n fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) ->\n         Option<ConstantVariant> {\n     if neg > pos {"}, {"sha": "a7d84ee0ae9a115f65651e8dd0ca519f292b7512", "filename": "tests/consts.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec53b52f1549571904a7b1bce71a4e24e42db6/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec53b52f1549571904a7b1bce71a4e24e42db6/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=d7ec53b52f1549571904a7b1bce71a4e24e42db6", "patch": "@@ -8,6 +8,7 @@ extern crate rustc;\n use clippy::consts::{constant, ConstantVariant};\n use clippy::consts::ConstantVariant::*;\n use syntax::ast::*;\n+use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n use std::mem;\n@@ -39,5 +40,8 @@ fn check(expect: ConstantVariant, expr: &Expr) {\n fn test_lit() {\n     check(ConstantBool(true), &lit(LitBool(true)));\n     check(ConstantBool(false), &lit(LitBool(false)));\n-\n+    check(ConstantInt(0, UnsuffixedIntLit(Plus)),\n+            &lit(LitInt(0, UnsuffixedIntLit(Plus))));\n+    check(ConstantStr(\"cool!\".into(), CookedStr), &lit(LitStr(\n+        InternedString::new(\"cool!\"), CookedStr)));\n }"}]}