{"sha": "d5e9033a0d380fefb5610c97ff1048c809251bba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZTkwMzNhMGQzODBmZWZiNTYxMGM5N2ZmMTA0OGM4MDkyNTFiYmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-17T02:35:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-17T02:35:50Z"}, "message": "auto merge of #9108 : blake2-ppc/rust/hazards-on-overflow, r=alexcrichton\n\nFix uint overflow bugs in std::{at_vec, vec, str}\r\n\r\nCloses #8742\r\n\r\nFix issue #8742, which summarized is: unsafe code in vec and str did assume\r\nthat a reservation for `X + Y` elements always succeeded, and didn't overflow.\r\n\r\nIntroduce the method `Vec::reserve_additional(n)` to make it easy to check for\r\noverflow in `Vec::push` and `Vec::push_all`.\r\n\r\nIn std::str, simplify and remove a lot of the unsafe code and use `push_str`\r\ninstead. With improvements to `.push_str` and the new function\r\n`vec::bytes::push_bytes`, it looks like this change has either no or positive\r\nimpact on performance.\r\n\r\nI believe there are many places still where `v.reserve(A + B)` still can overflow.\r\nThis by itself is not an issue unless followed by (unsafe) code that steps aside\r\nboundary checks.", "tree": {"sha": "86710ef0b5db291229c77c13263b565a412269f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86710ef0b5db291229c77c13263b565a412269f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5e9033a0d380fefb5610c97ff1048c809251bba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e9033a0d380fefb5610c97ff1048c809251bba", "html_url": "https://github.com/rust-lang/rust/commit/d5e9033a0d380fefb5610c97ff1048c809251bba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5e9033a0d380fefb5610c97ff1048c809251bba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "html_url": "https://github.com/rust-lang/rust/commit/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11"}, {"sha": "e211888407db32fcec53f4fa9eb84acdbdf59f87", "url": "https://api.github.com/repos/rust-lang/rust/commits/e211888407db32fcec53f4fa9eb84acdbdf59f87", "html_url": "https://github.com/rust-lang/rust/commit/e211888407db32fcec53f4fa9eb84acdbdf59f87"}], "stats": {"total": 270, "additions": 152, "deletions": 118}, "files": [{"sha": "42f511f722daba4323cd3cc6d9502b7294ea3974", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=d5e9033a0d380fefb5610c97ff1048c809251bba", "patch": "@@ -230,13 +230,16 @@ pub mod raw {\n     // Implementation detail. Shouldn't be public\n     #[allow(missing_doc)]\n     pub fn reserve_raw(ty: *TyDesc, ptr: *mut *mut Box<Vec<()>>, n: uint) {\n-\n+        // check for `uint` overflow\n         unsafe {\n-            let size_in_bytes = n * (*ty).size;\n-            if size_in_bytes > (**ptr).data.alloc {\n-                let total_size = size_in_bytes + sys::size_of::<Vec<()>>();\n+            if n > (**ptr).data.alloc / (*ty).size {\n+                let alloc = n * (*ty).size;\n+                let total_size = alloc + sys::size_of::<Vec<()>>();\n+                if alloc / (*ty).size != n || total_size < alloc {\n+                    fail!(\"vector size is too large: %u\", n);\n+                }\n                 (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n-                (**ptr).data.alloc = size_in_bytes;\n+                (**ptr).data.alloc = alloc;\n             }\n         }\n "}, {"sha": "38a4df270fc23cabfa2b56e1fa18d9b26917ea97", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=d5e9033a0d380fefb5610c97ff1048c809251bba", "patch": "@@ -101,7 +101,17 @@ pub fn next_power_of_two(n: uint) -> uint {\n     let mut tmp: uint = n - 1u;\n     let mut shift: uint = 1u;\n     while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n-    return tmp + 1u;\n+    tmp + 1u\n+}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`\n+#[inline]\n+pub fn next_power_of_two_opt(n: uint) -> Option<uint> {\n+    let halfbits: uint = sys::size_of::<uint>() * 4u;\n+    let mut tmp: uint = n - 1u;\n+    let mut shift: uint = 1u;\n+    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n+    tmp.checked_add(&1)\n }\n \n #[cfg(target_word_size = \"32\")]"}, {"sha": "1c48d6e7f1e1305ab569a57cb210554d2eb6d03b", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=d5e9033a0d380fefb5610c97ff1048c809251bba", "patch": "@@ -303,7 +303,7 @@ impl<T: Reader> ReaderUtil for T {\n             let start_len = buf.len();\n             let mut total_read = 0;\n \n-            buf.reserve_at_least(start_len + len);\n+            buf.reserve_additional(len);\n             vec::raw::set_len(buf, start_len + len);\n \n             do (|| {"}, {"sha": "bd484a5074c5ec38d057b4145d7a2d3fd0959beb", "filename": "src/libstd/str.rs", "status": "modified", "additions": 78, "deletions": 105, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=d5e9033a0d380fefb5610c97ff1048c809251bba", "patch": "@@ -22,8 +22,7 @@ use char;\n use char::Char;\n use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n-use num::Times;\n-use iter::{Iterator, FromIterator, Extendable};\n+use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Invert, DoubleEndedIterator, ExactSize};\n use libc;\n@@ -33,7 +32,6 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n-use unstable::raw::{Repr, Slice};\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n use default::Default;\n@@ -185,23 +183,15 @@ impl<'self, S: Str> StrVector for &'self [S] {\n     fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n+        // `len` calculation may overflow but push_str but will check boundaries\n         let len = self.iter().map(|s| s.as_slice().len()).sum();\n \n-        let mut s = with_capacity(len);\n+        let mut result = with_capacity(len);\n \n-        unsafe {\n-            do s.as_mut_buf |buf, _| {\n-                let mut buf = buf;\n-                for ss in self.iter() {\n-                    do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n-                        ptr::copy_memory(buf, ssbuf, sslen);\n-                        buf = buf.offset(sslen as int);\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n+        for s in self.iter() {\n+            result.push_str(s.as_slice())\n         }\n-        s\n+        result\n     }\n \n     /// Concatenate a vector of strings, placing a given separator between each.\n@@ -212,34 +202,21 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         if sep.is_empty() { return self.concat(); }\n \n         // this is wrong without the guarantee that `self` is non-empty\n+        // `len` calculation may overflow but push_str but will check boundaries\n         let len = sep.len() * (self.len() - 1)\n             + self.iter().map(|s| s.as_slice().len()).sum();\n-        let mut s = ~\"\";\n+        let mut result = with_capacity(len);\n         let mut first = true;\n \n-        s.reserve(len);\n-\n-        unsafe {\n-            do s.as_mut_buf |buf, _| {\n-                do sep.as_imm_buf |sepbuf, seplen| {\n-                    let mut buf = buf;\n-                    for ss in self.iter() {\n-                        do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n-                            if first {\n-                                first = false;\n-                            } else {\n-                                ptr::copy_memory(buf, sepbuf, seplen);\n-                                buf = buf.offset(seplen as int);\n-                            }\n-                            ptr::copy_memory(buf, ssbuf, sslen);\n-                            buf = buf.offset(sslen as int);\n-                        }\n-                    }\n-                }\n+        for s in self.iter() {\n+            if first {\n+                first = false;\n+            } else {\n+                result.push_str(sep);\n             }\n-            raw::set_len(&mut s, len);\n+            result.push_str(s.as_slice());\n         }\n-        s\n+        result\n     }\n }\n \n@@ -961,7 +938,6 @@ static TAG_CONT_U8: u8 = 128u8;\n \n /// Unsafe operations\n pub mod raw {\n-    use option::Some;\n     use cast;\n     use libc;\n     use ptr;\n@@ -1064,21 +1040,22 @@ pub mod raw {\n         }\n     }\n \n-    /// Appends a byte to a string. (Not UTF-8 safe).\n+    /// Appends a byte to a string.\n+    /// The caller must preserve the valid UTF-8 property.\n     #[inline]\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n-        let v: &mut ~[u8] = cast::transmute(s);\n-        v.push(b);\n+        as_owned_vec(s).push(b)\n     }\n \n-    /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n-    unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n-        let new_len = s.len() + bytes.len();\n-        s.reserve_at_least(new_len);\n-        for byte in bytes.iter() { push_byte(&mut *s, *byte); }\n+    /// Appends a vector of bytes to a string.\n+    /// The caller must preserve the valid UTF-8 property.\n+    #[inline]\n+    pub unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n+        vec::bytes::push_bytes(as_owned_vec(s), bytes);\n     }\n \n-    /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n+    /// Removes the last byte from a string and returns it.\n+    /// The caller must preserve the valid UTF-8 property.\n     pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n         let len = s.len();\n         assert!((len > 0u));\n@@ -1087,7 +1064,8 @@ pub mod raw {\n         return b;\n     }\n \n-    /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n+    /// Removes the first byte from a string and returns it.\n+    /// The caller must preserve the valid UTF-8 property.\n     pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = s.len();\n         assert!((len > 0u));\n@@ -1096,15 +1074,21 @@ pub mod raw {\n         return b;\n     }\n \n+    /// Access the str in its vector representation.\n+    /// The caller must preserve the valid UTF-8 property when modifying.\n+    #[inline]\n+    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n+        cast::transmute(s)\n+    }\n+\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n     /// modifying its buffers, so it is up to the caller to ensure that\n     /// the string is actually the specified size.\n     #[inline]\n     pub unsafe fn set_len(s: &mut ~str, new_len: uint) {\n-        let v: &mut ~[u8] = cast::transmute(s);\n-        vec::raw::set_len(v, new_len)\n+        vec::raw::set_len(as_owned_vec(s), new_len)\n     }\n \n     /// Sets the length of a string\n@@ -2061,22 +2045,11 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n-        do self.as_imm_buf |buf, len| {\n-            let mut ret = with_capacity(nn * len);\n-\n-            unsafe {\n-                do ret.as_mut_buf |rbuf, _len| {\n-                    let mut rbuf = rbuf;\n-\n-                    do nn.times {\n-                        ptr::copy_memory(rbuf, buf, len);\n-                        rbuf = rbuf.offset(len as int);\n-                    }\n-                }\n-                raw::set_len(&mut ret, nn * len);\n-            }\n-            ret\n+        let mut ret = with_capacity(nn * self.len());\n+        for _ in range(0, nn) {\n+            ret.push_str(*self);\n         }\n+        ret\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -2199,54 +2172,35 @@ impl OwnedStr for ~str {\n     /// Appends a string slice to the back of a string, without overallocating\n     #[inline]\n     fn push_str_no_overallocate(&mut self, rhs: &str) {\n-        unsafe {\n-            let llen = self.len();\n-            let rlen = rhs.len();\n-            self.reserve(llen + rlen);\n-            do self.as_imm_buf |lbuf, _llen| {\n-                do rhs.as_imm_buf |rbuf, _rlen| {\n-                    let dst = ptr::offset(lbuf, llen as int);\n-                    let dst = cast::transmute_mut_unsafe(dst);\n-                    ptr::copy_memory(dst, rbuf, rlen);\n-                }\n-            }\n-            raw::set_len(self, llen + rlen);\n-        }\n+        let new_cap = self.len() + rhs.len();\n+        self.reserve(new_cap);\n+        self.push_str(rhs);\n     }\n \n     /// Appends a string slice to the back of a string\n     #[inline]\n     fn push_str(&mut self, rhs: &str) {\n         unsafe {\n-            let llen = self.len();\n-            let rlen = rhs.len();\n-            self.reserve_at_least(llen + rlen);\n-            do self.as_imm_buf |lbuf, _llen| {\n-                do rhs.as_imm_buf |rbuf, _rlen| {\n-                    let dst = ptr::offset(lbuf, llen as int);\n-                    let dst = cast::transmute_mut_unsafe(dst);\n-                    ptr::copy_memory(dst, rbuf, rlen);\n-                }\n-            }\n-            raw::set_len(self, llen + rlen);\n+            raw::push_bytes(self, rhs.as_bytes());\n         }\n     }\n \n     /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n         let cur_len = self.len();\n-        self.reserve_at_least(cur_len + 4); // may use up to 4 bytes\n-\n-        // Attempt to not use an intermediate buffer by just pushing bytes\n-        // directly onto this string.\n+        // may use up to 4 bytes.\n         unsafe {\n-            let v = self.repr();\n-            let len = c.encode_utf8(cast::transmute(Slice {\n-                data: ((&(*v).data) as *u8).offset(cur_len as int),\n-                len: 4,\n-            }));\n-            raw::set_len(self, cur_len + len);\n+            raw::as_owned_vec(self).reserve_additional(4);\n+\n+            // Attempt to not use an intermediate buffer by just pushing bytes\n+            // directly onto this string.\n+            let used = do self.as_mut_buf |buf, _| {\n+                do vec::raw::mut_buf_as_slice(buf.offset(cur_len as int), 4) |slc| {\n+                    c.encode_utf8(slc)\n+                }\n+            };\n+            raw::set_len(self, cur_len + used);\n         }\n     }\n \n@@ -2306,8 +2260,7 @@ impl OwnedStr for ~str {\n     #[inline]\n     fn reserve(&mut self, n: uint) {\n         unsafe {\n-            let v: &mut ~[u8] = cast::transmute(self);\n-            (*v).reserve(n);\n+            raw::as_owned_vec(self).reserve(n)\n         }\n     }\n \n@@ -2329,7 +2282,7 @@ impl OwnedStr for ~str {\n     /// * n - The number of bytes to reserve space for\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(uint::next_power_of_two(n))\n+        self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n))\n     }\n \n     /// Returns the number of single-byte characters the string can hold without\n@@ -2359,8 +2312,9 @@ impl OwnedStr for ~str {\n \n     #[inline]\n     fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T {\n-        let v: &mut ~[u8] = unsafe { cast::transmute(self) };\n-        v.as_mut_buf(f)\n+        unsafe {\n+            raw::as_owned_vec(self).as_mut_buf(f)\n+        }\n     }\n }\n \n@@ -3912,4 +3866,23 @@ mod bench {\n             with_capacity(100);\n         }\n     }\n+\n+    #[bench]\n+    fn bench_push_str(bh: &mut BenchHarness) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        do bh.iter {\n+            let mut r = ~\"\";\n+            r.push_str(s);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_connect(bh: &mut BenchHarness) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let sep = \"\u2192\";\n+        let v = [s, s, s, s, s, s, s, s, s, s];\n+        do bh.iter {\n+            assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n+        }\n+    }\n }"}, {"sha": "9fc0eaf72b14d044de5d1fd8a0df90293de97d8e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9033a0d380fefb5610c97ff1048c809251bba/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d5e9033a0d380fefb5610c97ff1048c809251bba", "patch": "@@ -1245,6 +1245,7 @@ pub trait OwnedVector<T> {\n \n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n+    fn reserve_additional(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n     fn shrink_to_fit(&mut self);\n \n@@ -1300,6 +1301,11 @@ impl<T> OwnedVector<T> for ~[T] {\n      * # Arguments\n      *\n      * * n - The number of elements to reserve space for\n+     *\n+     * # Failure\n+     *\n+     * This method always succeeds in reserving space for `n` elements, or it does\n+     * not return.\n      */\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n@@ -1340,7 +1346,26 @@ impl<T> OwnedVector<T> for ~[T] {\n      */\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(uint::next_power_of_two(n));\n+        self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n));\n+    }\n+\n+    /**\n+     * Reserves capacity for at least `n` additional elements in the given vector.\n+     *\n+     * # Failure\n+     *\n+     * Fails if the new required capacity overflows uint.\n+     *\n+     * May also fail if `reserve` fails.\n+     */\n+    #[inline]\n+    fn reserve_additional(&mut self, n: uint) {\n+        if self.capacity() - self.len() < n {\n+            match self.len().checked_add(&n) {\n+                None => fail!(\"vec::reserve_additional: `uint` overflow\"),\n+                Some(new_cap) => self.reserve_at_least(new_cap)\n+            }\n+        }\n     }\n \n     /// Returns the number of elements the vector can hold without reallocating.\n@@ -1376,17 +1401,15 @@ impl<T> OwnedVector<T> for ~[T] {\n                 let repr: **Box<Vec<()>> = cast::transmute(&mut *self);\n                 let fill = (**repr).data.fill;\n                 if (**repr).data.alloc <= fill {\n-                    let new_len = self.len() + 1;\n-                    self.reserve_at_least(new_len);\n+                    self.reserve_additional(1);\n                 }\n \n                 push_fast(self, t);\n             } else {\n                 let repr: **Vec<()> = cast::transmute(&mut *self);\n                 let fill = (**repr).fill;\n                 if (**repr).alloc <= fill {\n-                    let new_len = self.len() + 1;\n-                    self.reserve_at_least(new_len);\n+                    self.reserve_additional(1);\n                 }\n \n                 push_fast(self, t);\n@@ -1432,7 +1455,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let self_len = self.len();\n         let rhs_len = rhs.len();\n         let new_len = self_len + rhs_len;\n-        self.reserve_at_least(new_len);\n+        self.reserve_additional(rhs.len());\n         unsafe { // Note: infallible.\n             let self_p = vec::raw::to_mut_ptr(*self);\n             let rhs_p = vec::raw::to_ptr(rhs);\n@@ -2221,6 +2244,23 @@ pub mod bytes {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n     }\n+\n+    /**\n+     * Allocate space in `dst` and append the data in `src`.\n+     */\n+    #[inline]\n+    pub fn push_bytes(dst: &mut ~[u8], src: &[u8]) {\n+        let old_len = dst.len();\n+        dst.reserve_additional(src.len());\n+        unsafe {\n+            do dst.as_mut_buf |p_dst, len_dst| {\n+                do src.as_imm_buf |p_src, len_src| {\n+                    ptr::copy_memory(p_dst.offset(len_dst as int), p_src, len_src)\n+                }\n+            }\n+            vec::raw::set_len(dst, old_len + src.len());\n+        }\n+    }\n }\n \n impl<A: Clone> Clone for ~[A] {\n@@ -3619,6 +3659,14 @@ mod tests {\n         v.push(2);\n     }\n \n+    #[test]\n+    #[should_fail]\n+    fn test_overflow_does_not_cause_segfault_managed() {\n+        let mut v = ~[@1];\n+        v.reserve(-1);\n+        v.push(@2);\n+    }\n+\n     #[test]\n     fn test_mut_split() {\n         let mut values = [1u8,2,3,4,5];"}]}