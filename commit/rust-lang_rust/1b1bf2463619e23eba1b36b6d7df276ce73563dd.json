{"sha": "1b1bf2463619e23eba1b36b6d7df276ce73563dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMWJmMjQ2MzYxOWUyM2ViYTFiMzZiNmQ3ZGYyNzZjZTczNTYzZGQ=", "commit": {"author": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2021-04-20T19:02:49Z"}, "committer": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2021-05-07T10:17:44Z"}, "message": "std panicking: Provide panic::always_abort\n\nWe must change the atomic read on panic entry to `Acquire`, to pick up\na possible an `always_panic` on another thread.\n\nWe add `count` to the names of panic_count::get and ::is_zaero,\nbecause now there is another reason why panic ought to maybe abort.\nRenaming these ensures that we have checked every call site to ensure\nthat they don't need further adjustment.\n\nSigned-off-by: Ian Jackson <ijackson@chiark.greenend.org.uk>\nCo-authored-by: Mara Bos <m-ou.se@m-ou.se>", "tree": {"sha": "f37787406be15b26ccf0c3116bc4ff9ac83da379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f37787406be15b26ccf0c3116bc4ff9ac83da379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b1bf2463619e23eba1b36b6d7df276ce73563dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1bf2463619e23eba1b36b6d7df276ce73563dd", "html_url": "https://github.com/rust-lang/rust/commit/1b1bf2463619e23eba1b36b6d7df276ce73563dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b1bf2463619e23eba1b36b6d7df276ce73563dd/comments", "author": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9f43a2a8f845ac7be462cc5300da2350995c546", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f43a2a8f845ac7be462cc5300da2350995c546", "html_url": "https://github.com/rust-lang/rust/commit/a9f43a2a8f845ac7be462cc5300da2350995c546"}], "stats": {"total": 100, "additions": 85, "deletions": 15}, "files": [{"sha": "1c1466492881c1d0daab137ee99f7d32e1a606fc", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1b1bf2463619e23eba1b36b6d7df276ce73563dd/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1bf2463619e23eba1b36b6d7df276ce73563dd/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=1b1bf2463619e23eba1b36b6d7df276ce73563dd", "patch": "@@ -461,5 +461,41 @@ pub fn resume_unwind(payload: Box<dyn Any + Send>) -> ! {\n     panicking::rust_panic_without_hook(payload)\n }\n \n+/// Make all future panics abort directly without running the panic hook or unwinding.\n+///\n+/// There is no way to undo this; the effect lasts until the process exits or\n+/// execs (or the equivalent).\n+///\n+/// # Use after fork\n+///\n+/// This function is particularly useful for calling after `libc::fork`.  After `fork`, in a\n+/// multithreaded program it is (on many platforms) not safe to call the allocator.  It is also\n+/// generally highly undesirable for an unwind to unwind past the `fork`, because that results in\n+/// the unwind propagating to code that was only ever expecting to run in the parent.\n+///\n+/// `panic::always_abort()` helps avoid both of these.  It directly avoids any further unwinding,\n+/// and if there is a panic, the abort will occur without allocating provided that the arguments to\n+/// panic can be formatted without allocating.\n+///\n+/// Examples\n+///\n+/// ```no_run\n+/// #![feature(panic_always_abort)]\n+/// use std::panic;\n+///\n+/// panic::always_abort();\n+///\n+/// let _ = panic::catch_unwind(|| {\n+///     panic!(\"inside the catch\");\n+/// });\n+///\n+/// // We will have aborted already, due to the panic.\n+/// unreachable!();\n+/// ```\n+#[unstable(feature = \"panic_always_abort\", issue = \"84438\")]\n+pub fn always_abort() {\n+    crate::panicking::panic_count::set_always_abort();\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "62476581f990f0739ebe9fe9795a1fd60408dad0", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1b1bf2463619e23eba1b36b6d7df276ce73563dd/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1bf2463619e23eba1b36b6d7df276ce73563dd/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=1b1bf2463619e23eba1b36b6d7df276ce73563dd", "patch": "@@ -180,7 +180,7 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n fn default_hook(info: &PanicInfo<'_>) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n-    let backtrace_env = if panic_count::get() >= 2 {\n+    let backtrace_env = if panic_count::get_count() >= 2 {\n         RustBacktrace::Print(crate::backtrace_rs::PrintFmt::Full)\n     } else {\n         backtrace::rust_backtrace_env()\n@@ -233,6 +233,8 @@ pub mod panic_count {\n     use crate::cell::Cell;\n     use crate::sync::atomic::{AtomicUsize, Ordering};\n \n+    pub const ALWAYS_ABORT_FLAG: usize = 1 << (usize::BITS - 1);\n+\n     // Panic count for the current thread.\n     thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = Cell::new(0) }\n \n@@ -241,15 +243,29 @@ pub mod panic_count {\n     // thread, if that thread currently views `GLOBAL_PANIC_COUNT` as being zero,\n     // then `LOCAL_PANIC_COUNT` in that thread is zero. This invariant holds before\n     // and after increase and decrease, but not necessarily during their execution.\n+    //\n+    // Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG)\n+    // records whether panic::always_abort() has been called.  This can only be\n+    // set, never cleared.\n+    //\n+    // This could be viewed as a struct containing a single bit and an n-1-bit\n+    // value, but if we wrote it like that it would be more than a single word,\n+    // and even a newtype around usize would be clumsy because we need atomics.\n+    // But we use such a tuple for the return type of increase().\n+    //\n+    // Stealing a bit is fine because it just amounts to assuming that each\n+    // panicking thread consumes at least 2 bytes of address space.\n     static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n-    pub fn increase() -> usize {\n-        GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n-        LOCAL_PANIC_COUNT.with(|c| {\n-            let next = c.get() + 1;\n-            c.set(next);\n-            next\n-        })\n+    pub fn increase() -> (bool, usize) {\n+        (\n+            GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Acquire) & ALWAYS_ABORT_FLAG != 0,\n+            LOCAL_PANIC_COUNT.with(|c| {\n+                let next = c.get() + 1;\n+                c.set(next);\n+                next\n+            }),\n+        )\n     }\n \n     pub fn decrease() {\n@@ -261,13 +277,19 @@ pub mod panic_count {\n         });\n     }\n \n-    pub fn get() -> usize {\n+    pub fn set_always_abort() {\n+        GLOBAL_PANIC_COUNT.fetch_or(ALWAYS_ABORT_FLAG, Ordering::Release);\n+    }\n+\n+    // Disregards ALWAYS_ABORT_FLAG\n+    pub fn get_count() -> usize {\n         LOCAL_PANIC_COUNT.with(|c| c.get())\n     }\n \n+    // Disregards ALWAYS_ABORT_FLAG\n     #[inline]\n-    pub fn is_zero() -> bool {\n-        if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) == 0 {\n+    pub fn count_is_zero() -> bool {\n+        if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) & !ALWAYS_ABORT_FLAG == 0 {\n             // Fast path: if `GLOBAL_PANIC_COUNT` is zero, all threads\n             // (including the current one) will have `LOCAL_PANIC_COUNT`\n             // equal to zero, so TLS access can be avoided.\n@@ -410,7 +432,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n /// Determines whether the current thread is unwinding because of panic.\n #[inline]\n pub fn panicking() -> bool {\n-    !panic_count::is_zero()\n+    !panic_count::count_is_zero()\n }\n \n /// The entry point for panicking with a formatted message.\n@@ -563,15 +585,27 @@ fn rust_panic_with_hook(\n     message: Option<&fmt::Arguments<'_>>,\n     location: &Location<'_>,\n ) -> ! {\n-    let panics = panic_count::increase();\n+    let (must_abort, panics) = panic_count::increase();\n \n     // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n     // the panic hook probably triggered the last panic, otherwise the\n     // double-panic check would have aborted the process. In this case abort the\n     // process real quickly as we don't want to try calling it again as it'll\n     // probably just panic again.\n-    if panics > 2 {\n-        util::dumb_print(format_args!(\"thread panicked while processing panic. aborting.\\n\"));\n+    if must_abort || panics > 2 {\n+        if panics > 2 {\n+            // Don't try to print the message in this case\n+            // - perhaps that is causing the recursive panics.\n+            util::dumb_print(format_args!(\"thread panicked while processing panic. aborting.\\n\"));\n+        } else {\n+            // Unfortunately, this does not print a backtrace, because creating\n+            // a `Backtrace` will allocate, which we must to avoid here.\n+            let panicinfo = PanicInfo::internal_constructor(message, location);\n+            util::dumb_print(format_args!(\n+                \"{}\\npanicked after panic::always_abort(), aborting.\\n\",\n+                panicinfo\n+            ));\n+        }\n         intrinsics::abort()\n     }\n "}]}