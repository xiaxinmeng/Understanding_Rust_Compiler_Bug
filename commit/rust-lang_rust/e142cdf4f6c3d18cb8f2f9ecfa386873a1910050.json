{"sha": "e142cdf4f6c3d18cb8f2f9ecfa386873a1910050", "node_id": "C_kwDOAAsO6NoAKGUxNDJjZGY0ZjZjM2QxOGNiOGYyZjllY2ZhMzg2ODczYTE5MTAwNTA", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-18T14:20:19Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-20T12:39:42Z"}, "message": "Remove FunctionCx::new_block", "tree": {"sha": "0e9875fadedac2d6a5a8269183624f4ab314ea6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e9875fadedac2d6a5a8269183624f4ab314ea6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e142cdf4f6c3d18cb8f2f9ecfa386873a1910050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e142cdf4f6c3d18cb8f2f9ecfa386873a1910050", "html_url": "https://github.com/rust-lang/rust/commit/e142cdf4f6c3d18cb8f2f9ecfa386873a1910050", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e142cdf4f6c3d18cb8f2f9ecfa386873a1910050/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "html_url": "https://github.com/rust-lang/rust/commit/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "f3d41f3f86c790ed4c2a1e94e2747e6e016b3c15", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e142cdf4f6c3d18cb8f2f9ecfa386873a1910050/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e142cdf4f6c3d18cb8f2f9ecfa386873a1910050/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=e142cdf4f6c3d18cb8f2f9ecfa386873a1910050", "patch": "@@ -96,9 +96,10 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n \n             debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n             let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n-            let mut trampoline = fx.new_block(name);\n-            trampoline.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n-            trampoline.llbb()\n+            let trampoline = Bx::append_block(fx.cx, fx.llfn, name);\n+            let mut trampoline_bx = Bx::build(fx.cx, trampoline);\n+            trampoline_bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n+            trampoline\n         } else {\n             lltarget\n         }\n@@ -1358,16 +1359,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //          bar();\n                 //      }\n                 Some(&mir::TerminatorKind::Abort) => {\n-                    let mut cs_bx = self.new_block(&format!(\"cs_funclet{:?}\", bb));\n-                    let mut cp_bx = self.new_block(&format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bx.llbb();\n+                    let cs_bb =\n+                        Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n+                    let cp_bb =\n+                        Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n+                    ret_llbb = cs_bb;\n \n-                    let cs = cs_bx.catch_switch(None, None, &[cp_bx.llbb()]);\n+                    let mut cs_bx = Bx::build(self.cx, cs_bb);\n+                    let cs = cs_bx.catch_switch(None, None, &[cp_bb]);\n \n                     // The \"null\" here is actually a RTTI type descriptor for the\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n+                    let mut cp_bx = Bx::build(self.cx, cp_bb);\n                     let null = cp_bx.const_null(\n                         cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n                     );\n@@ -1376,16 +1381,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     cp_bx.br(llbb);\n                 }\n                 _ => {\n-                    let mut cleanup_bx = self.new_block(&format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bx.llbb();\n+                    let cleanup_bb =\n+                        Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n+                    ret_llbb = cleanup_bb;\n+                    let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n                     funclet = cleanup_bx.cleanup_pad(None, &[]);\n                     cleanup_bx.br(llbb);\n                 }\n             }\n             self.funclets[bb] = Some(funclet);\n             ret_llbb\n         } else {\n-            let mut bx = self.new_block(\"cleanup\");\n+            let bb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n+            let mut bx = Bx::build(self.cx, bb);\n \n             let llpersonality = self.cx.eh_personality();\n             let llretty = self.landing_pad_type();\n@@ -1407,18 +1415,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     fn unreachable_block(&mut self) -> Bx::BasicBlock {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let mut bx = self.new_block(\"unreachable\");\n+            let llbb = Bx::append_block(self.cx, self.llfn, \"unreachable\");\n+            let mut bx = Bx::build(self.cx, llbb);\n             bx.unreachable();\n-            self.unreachable_block = Some(bx.llbb());\n-            bx.llbb()\n+            self.unreachable_block = Some(llbb);\n+            llbb\n         })\n     }\n \n     fn double_unwind_guard(&mut self) -> Bx::BasicBlock {\n         self.double_unwind_guard.unwrap_or_else(|| {\n             assert!(!base::wants_msvc_seh(self.cx.sess()));\n \n-            let mut bx = self.new_block(\"abort\");\n+            let llbb = Bx::append_block(self.cx, self.llfn, \"abort\");\n+            let mut bx = Bx::build(self.cx, llbb);\n             self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n \n             let llpersonality = self.cx.eh_personality();\n@@ -1436,20 +1446,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.apply_attrs_to_cleanup_callsite(llret);\n \n             bx.unreachable();\n-            let llbb = bx.llbb();\n \n             self.double_unwind_guard = Some(llbb);\n             llbb\n         })\n     }\n \n-    // FIXME(eddyb) replace with `append_sibling_block`\n-    // (which requires having a `Bx` already, and not all callers do).\n-    fn new_block(&self, name: &str) -> Bx {\n-        let llbb = Bx::append_block(self.cx, self.llfn, name);\n-        Bx::build(self.cx, llbb)\n-    }\n-\n     /// Get the backend `BasicBlock` for a MIR `BasicBlock`, either already\n     /// cached in `self.cached_llbbs`, or created on demand (and cached).\n     // FIXME(eddyb) rename `llbb` and other `ll`-prefixed things to use a"}]}