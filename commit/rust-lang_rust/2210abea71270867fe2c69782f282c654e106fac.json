{"sha": "2210abea71270867fe2c69782f282c654e106fac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMTBhYmVhNzEyNzA4NjdmZTJjNjk3ODJmMjgyYzY1NGUxMDZmYWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-14T13:02:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-14T13:06:16Z"}, "message": "keep root_span and tcx together", "tree": {"sha": "8ac7dd7e7b64bc036673f39aad6acb150c531bb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ac7dd7e7b64bc036673f39aad6acb150c531bb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2210abea71270867fe2c69782f282c654e106fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2210abea71270867fe2c69782f282c654e106fac", "html_url": "https://github.com/rust-lang/rust/commit/2210abea71270867fe2c69782f282c654e106fac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2210abea71270867fe2c69782f282c654e106fac/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6512fd4e959d1c19ee7b428a78696a53ab28bc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6512fd4e959d1c19ee7b428a78696a53ab28bc6", "html_url": "https://github.com/rust-lang/rust/commit/c6512fd4e959d1c19ee7b428a78696a53ab28bc6"}], "stats": {"total": 132, "additions": 60, "deletions": 72}, "files": [{"sha": "d62300b3f55414b198bfce5da10eede285c61366", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -27,7 +27,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     body: &'mir mir::Body<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx;\n+    let tcx = *ecx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -214,7 +214,7 @@ fn validate_and_turn_into_const<'tcx>(\n \n     val.map_err(|error| {\n         let err = error_to_const_error(&ecx, error, None);\n-        err.struct_error(ecx.tcx_at(), \"it is undefined behavior to use this value\", |mut diag| {\n+        err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n         })"}, {"sha": "cfe856abe36dda2ca6c6c073417d1c864c711138", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n \n                         let instance = ty::Instance::resolve_for_fn_ptr(\n-                            self.tcx,\n+                            *self.tcx,\n                             self.param_env,\n                             def_id,\n                             substs,\n@@ -91,7 +91,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n \n                         let instance = ty::Instance::resolve_closure(\n-                            self.tcx,\n+                            *self.tcx,\n                             def_id,\n                             substs,\n                             ty::ClosureKind::FnOnce,\n@@ -140,7 +140,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Handle cast from a univariant (ZST) enum.\n         match src.layout.variants {\n             Variants::Single { index } => {\n-                if let Some(discr) = src.layout.ty.discriminant_for_variant(self.tcx, index) {\n+                if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;\n                     return Ok(self.cast_from_scalar(discr.val, discr_layout, cast_ty).into());\n@@ -269,7 +269,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val =\n-                    Immediate::new_slice(ptr, length.eval_usize(self.tcx, self.param_env), self);\n+                    Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n             (&ty::Dynamic(..), &ty::Dynamic(..)) => {"}, {"sha": "519dfd5b54e343e3944d02429feba1e445cf82f9", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -33,11 +33,9 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n-    pub tcx: TyCtxt<'tcx>,\n-\n-    /// The span of the \"root\" of the evaluation, i.e., the const\n+    /// The span in this is the \"root\" of the evaluation, i.e., the const\n     /// we are evaluating (if this is CTFE).\n-    pub(super) root_span: Span,\n+    pub tcx: TyCtxtAt<'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n@@ -200,7 +198,7 @@ where\n {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n+        *self.tcx\n     }\n }\n \n@@ -219,7 +217,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx,\n \n     #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        self.tcx_at()\n+        self.tcx\n             .layout_of(self.param_env.and(ty))\n             .map_err(|layout| err_inval!(Layout(layout)).into())\n     }\n@@ -304,8 +302,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> Self {\n         InterpCx {\n             machine,\n-            tcx,\n-            root_span,\n+            tcx: tcx.at(root_span),\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n             vtables: FxHashMap::default(),\n@@ -318,14 +315,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .last()\n             .and_then(|f| f.current_source_info())\n             .map(|si| si.span)\n-            .unwrap_or(self.root_span)\n-    }\n-\n-    #[inline(always)]\n-    pub fn tcx_at(&self) -> TyCtxtAt<'tcx> {\n-        // Computing the current span has a non-trivial cost, and for cycle errors\n-        // the \"root span\" is good enough.\n-        self.tcx.at(self.root_span)\n+            .unwrap_or(self.tcx.span)\n     }\n \n     #[inline(always)]\n@@ -403,12 +393,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx_at(), self.param_env)\n+        ty.is_sized(self.tcx, self.param_env)\n     }\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, self.param_env, self.root_span)\n+        ty.is_freeze(*self.tcx, self.param_env, self.tcx.span)\n     }\n \n     pub fn load_mir(\n@@ -419,21 +409,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n         if let Some(did) = did.as_local() {\n-            if self.tcx_at().has_typeck_tables(did) {\n-                if let Some(error_reported) = self.tcx_at().typeck_tables_of(did).tainted_by_errors\n-                {\n+            if self.tcx.has_typeck_tables(did) {\n+                if let Some(error_reported) = self.tcx.typeck_tables_of(did).tainted_by_errors {\n                     throw_inval!(TypeckError(error_reported))\n                 }\n             }\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         if let Some(promoted) = promoted {\n-            return Ok(&self.tcx_at().promoted_mir(did)[promoted]);\n+            return Ok(&self.tcx.promoted_mir(did)[promoted]);\n         }\n         match instance {\n             ty::InstanceDef::Item(def_id) => {\n-                if self.tcx_at().is_mir_available(did) {\n-                    Ok(self.tcx_at().optimized_mir(did))\n+                if self.tcx.is_mir_available(did) {\n+                    Ok(self.tcx.optimized_mir(did))\n                 } else {\n                     throw_unsup!(NoMirFor(def_id))\n                 }\n@@ -474,7 +463,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n         trace!(\"param_env: {:#?}\", self.param_env);\n         trace!(\"substs: {:#?}\", substs);\n-        match ty::Instance::resolve(self.tcx, self.param_env, def_id, substs) {\n+        match ty::Instance::resolve(*self.tcx, self.param_env, def_id, substs) {\n             Ok(Some(instance)) => Ok(instance),\n             Ok(None) => throw_inval!(TooGeneric),\n \n@@ -493,7 +482,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(self.tcx_at(), layout, || {\n+                let layout = from_known_layout(self.tcx, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);\n@@ -645,7 +634,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n \n         // Now mark those locals as dead that we do not want to initialize\n-        match self.tcx_at().def_kind(instance.def_id()) {\n+        match self.tcx.def_kind(instance.def_id()) {\n             // statics and constants don't have `Storage*` statements, no need to look for them\n             //\n             // FIXME: The above is likely untrue. See\n@@ -860,7 +849,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         } else {\n             self.param_env\n         };\n-        let val = self.tcx.const_eval_global_id(param_env, gid, Some(self.root_span))?;\n+        let val = self.tcx.const_eval_global_id(param_env, gid, Some(self.tcx.span))?;\n \n         // Even though `ecx.const_eval` is called from `eval_const_to_op` we can never have a\n         // recursion deeper than one level, because the `tcx.const_eval` above is guaranteed to not\n@@ -891,7 +880,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // FIXME: We can hit delay_span_bug if this is an invalid const, interning finds\n         // that problem, but we never run validation to show an error. Can we ensure\n         // this does not happen?\n-        let val = self.tcx_at().const_eval_raw(param_env.and(gid))?;\n+        let val = self.tcx.const_eval_raw(param_env.and(gid))?;\n         self.raw_const_to_mplace(val)\n     }\n "}, {"sha": "3c724c79b4082448860d9fc256c272537a8342e6", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -93,7 +93,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // in the value the dangling reference lies.\n             // The `delay_span_bug` ensures that we don't forget such a check in validation.\n             if tcx.get_global_alloc(alloc_id).is_none() {\n-                tcx.sess.delay_span_bug(ecx.root_span, \"tried to intern dangling pointer\");\n+                tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n             }\n             // treat dangling pointers like other statics\n             // just to stop trying to recurse into them\n@@ -111,7 +111,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env, ecx.root_span));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env, ecx.tcx.span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n@@ -174,7 +174,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                     // they caused.  It also helps us to find cases where const-checking\n                     // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n                     // shows that part is not airtight).\n-                    mutable_memory_in_const(self.ecx.tcx_at(), \"`UnsafeCell`\");\n+                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n                 }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n@@ -192,7 +192,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n-        let tcx = self.ecx.tcx.at(self.ecx.root_span);\n+        let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, ref_mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n@@ -253,8 +253,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                         // caused (by somehow getting a mutable reference in a `const`).\n                         if ref_mutability == Mutability::Mut {\n                             match referenced_ty.kind {\n-                                ty::Array(_, n)\n-                                    if n.eval_usize(self.ecx.tcx, self.ecx.param_env) == 0 => {}\n+                                ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n                                 ty::Slice(_)\n                                     if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n                                         == 0 => {}\n@@ -358,7 +357,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             Ok(()) => {}\n             Err(error) => {\n                 ecx.tcx.sess.delay_span_bug(\n-                    ecx.root_span,\n+                    ecx.tcx.span,\n                     \"error during interning should later cause validation failure\",\n                 );\n                 // Some errors shouldn't come up because creating them causes\n@@ -407,7 +406,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n                     // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n                     ecx.tcx\n                         .sess\n-                        .span_err(ecx.root_span, \"untyped pointers are not allowed in constant\");\n+                        .span_err(ecx.tcx.span, \"untyped pointers are not allowed in constant\");\n                     // For better errors later, mark the allocation as immutable.\n                     alloc.mutability = Mutability::Not;\n                 }\n@@ -422,11 +421,11 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // Codegen does not like dangling pointers, and generally `tcx` assumes that\n             // all allocations referenced anywhere actually exist. So, make sure we error here.\n-            ecx.tcx.sess.span_err(ecx.root_span, \"encountered dangling pointer in final constant\");\n+            ecx.tcx.sess.span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n         } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't\n             // marked as dangling by local memory.  That should be impossible.\n-            span_bug!(ecx.root_span, \"encountered unknown alloc id {:?}\", alloc_id);\n+            span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }\n }"}, {"sha": "47e5b8b4fcec453a7be7951569878d52c76fa863", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];\n                 let input = args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(self.tcx);\n+                let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n@@ -374,7 +374,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx);\n+                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\","}, {"sha": "ddeed92f851248709ec48d8198660d7dbcb84dda", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -25,7 +25,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"find_closest_untracked_caller_location: checking frame {:?}\",\n                     frame.instance\n                 );\n-                !frame.instance.def.requires_caller_location(self.tcx)\n+                !frame.instance.def.requires_caller_location(*self.tcx)\n             })\n             // Assert that there is always such a frame.\n             .unwrap();\n@@ -58,7 +58,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let loc_ty = self\n             .tcx\n             .type_of(self.tcx.require_lang_item(PanicLocationLangItem, None))\n-            .subst(self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n+            .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n "}, {"sha": "38f5988d0eb3fd82eb27768994647d9c219f1d72", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -471,9 +471,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"eval_place_to_op: got {:?}\", *op);\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n-            self.tcx,\n+            *self.tcx,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n-                place.ty(&self.frame().body.local_decls, self.tcx).ty\n+                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n             op.layout,\n         ));\n@@ -554,7 +554,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // documentation).\n         let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n-        let layout = from_known_layout(self.tcx_at(), layout, || self.layout_of(val.ty))?;\n+        let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.create_memory_alloc(alloc);\n@@ -589,7 +589,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n \n         // Get type and layout of the discriminant.\n-        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(self.tcx))?;\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n         trace!(\"discriminant type: {:?}\", discr_layout.ty);\n \n         // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n@@ -601,7 +601,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // rather confusing.\n         let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n             Variants::Single { index } => {\n-                let discr = match op.layout.ty.discriminant_for_variant(self.tcx, index) {\n+                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     Some(discr) => {\n                         // This type actually has discriminants.\n                         assert_eq!(discr.ty, discr_layout.ty);\n@@ -630,7 +630,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n \n         // Get layout for tag.\n-        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(self.tcx))?;\n+        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n         let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n@@ -651,12 +651,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx).find(|(_, var)| var.val == discr_bits)\n+                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n-                            .discriminants(def_id, self.tcx)\n+                            .discriminants(def_id, *self.tcx)\n                             .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),"}, {"sha": "24b191e9b535ab6c2daf9f56db6813b69186dc5b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -651,9 +651,9 @@ where\n         self.dump_place(place_ty.place);\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n-            self.tcx,\n+            *self.tcx,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n-                place.ty(&self.frame().body.local_decls, self.tcx).ty\n+                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n             place_ty.layout,\n         ));\n@@ -779,7 +779,7 @@ where\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let tcx = self.tcx;\n+        let tcx = *self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n@@ -855,7 +855,7 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(self.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             span_bug!(\n                 self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n@@ -912,7 +912,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(self.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }\n@@ -1070,7 +1070,7 @@ where\n                 // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n \n                 let discr_val =\n-                    dest.layout.ty.discriminant_for_variant(self.tcx, variant_index).unwrap().val;\n+                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n \n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n@@ -1099,7 +1099,7 @@ where\n                         .expect(\"overflow computing relative variant idx\");\n                     // We need to use machine arithmetic when taking into account `niche_start`:\n                     // discr_val = variant_index_relative + niche_start_val\n-                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(self.tcx))?;\n+                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n                     let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n                     let variant_index_relative_val =\n                         ImmTy::from_uint(variant_index_relative, discr_layout);"}, {"sha": "cd7621ea9752b4ebc51a0d40394b060bb7a74346", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -69,7 +69,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (fn_val, caller_abi)\n                     }\n                     ty::FnDef(def_id, substs) => {\n-                        let sig = func.layout.ty.fn_sig(self.tcx);\n+                        let sig = func.layout.ty.fn_sig(*self.tcx);\n                         (FnVal::Instance(self.resolve(def_id, substs)?), sig.abi())\n                     }\n                     _ => span_bug!(\n@@ -96,7 +96,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ty = place.layout.ty;\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n-                let instance = Instance::resolve_drop_in_place(self.tcx, ty);\n+                let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_in_place(place, instance, target, unwind)?;\n             }\n \n@@ -227,9 +227,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // ABI check\n         {\n             let callee_abi = {\n-                let instance_ty = instance.ty_env(self.tcx, self.param_env);\n+                let instance_ty = instance.ty_env(*self.tcx, self.param_env);\n                 match instance_ty.kind {\n-                    ty::FnDef(..) => instance_ty.fn_sig(self.tcx).abi(),\n+                    ty::FnDef(..) => instance_ty.fn_sig(*self.tcx).abi(),\n                     ty::Closure(..) => Abi::RustCall,\n                     ty::Generator(..) => Abi::Rust,\n                     _ => bug!(\"unexpected callee ty: {:?}\", instance_ty),"}, {"sha": "a1d124bb7602ebb1408107d5840e90e073e56fbb", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2210abea71270867fe2c69782f282c654e106fac/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=2210abea71270867fe2c69782f282c654e106fac", "patch": "@@ -36,10 +36,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         let methods = if let Some(poly_trait_ref) = poly_trait_ref {\n-            let trait_ref = poly_trait_ref.with_self_ty(self.tcx, ty);\n+            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n             let trait_ref = self.tcx.erase_regions(&trait_ref);\n \n-            self.tcx_at().vtable_methods(trait_ref)\n+            self.tcx.vtable_methods(trait_ref)\n         } else {\n             &[]\n         };\n@@ -49,7 +49,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi.bytes();\n \n-        let tcx = self.tcx;\n+        let tcx = *self.tcx;\n         let ptr_size = self.pointer_size();\n         let ptr_align = tcx.data_layout.pointer_align.abi;\n         // /////////////////////////////////////////////////////////////////////////////////////////\n@@ -142,7 +142,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // to determine the type.\n         let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n-        let fn_sig = drop_instance.ty_env(self.tcx, self.param_env).fn_sig(self.tcx);\n+        let fn_sig = drop_instance.ty_env(*self.tcx, self.param_env).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n         // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n         let args = fn_sig.inputs();"}]}