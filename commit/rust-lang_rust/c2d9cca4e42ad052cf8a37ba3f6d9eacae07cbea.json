{"sha": "c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZDljY2E0ZTQyYWQwNTJjZjhhMzdiYTNmNmQ5ZWFjYWUwN2NiZWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-22T22:01:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-22T22:01:38Z"}, "message": "Merge #1895\n\n1895: Handle associated type shorthand (`T::Item`) (Second attempt) r=flodiebold a=flodiebold\n\nThis is only allowed for generic parameters (including `Self` in traits), and\r\nspecial care needs to be taken to not run into cycles while resolving it,\r\nbecause we use the where clauses of the generic parameter to find candidates for\r\nthe trait containing the associated type, but the where clauses may themselves\r\ncontain instances of short-hand associated types.\r\n\r\nIn some cases this is even fine, e.g. we might have `T: Trait<U::Item>, U:\r\nIterator`. If there is a cycle, we'll currently panic, which isn't great, but\r\nbetter than overflowing the stack...\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "9f800613bde5ef6b80ab6a637990a6be69995dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f800613bde5ef6b80ab6a637990a6be69995dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdh+9CCRBK7hj4Ov3rIwAAdHIIACMcy+s9W5dN2G0OOqzfr+dF\nzQ815A1lOvuM6OFlU+hnU5HwnMwY7umFx+yBGlaUkGdIZlMh84T9WdKaN4s+JwrS\nkXFYbVyGZCtQTx02nnZiO8j7vZoJqUAtOJ6aK55MwPyqtTXO+NFneU0GJVMywYqI\nrPjba7vqIkBt+DFFRpyrffir8I1MnfImd+kA3ADgxLzucVs6JpT/zuRbocndEma6\n5JPrrYZbN6dxYslTHfidabollQItb80Jdhbd+g6aMfPmx8FDcuySLVmJVDWj70TD\njStQDiL6EEcvGbX6djQbxswSXcqXrFELpGjEYJZj7RKCtWwmxy3fHL4b6nhwiMA=\n=IKSO\n-----END PGP SIGNATURE-----\n", "payload": "tree 9f800613bde5ef6b80ab6a637990a6be69995dd4\nparent efcbca95595d31bb4c2c6782530d5a7a64a4191f\nparent bc905d202c613a831f7c1abb846b612900a9b43a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1569189698 +0000\ncommitter GitHub <noreply@github.com> 1569189698 +0000\n\nMerge #1895\n\n1895: Handle associated type shorthand (`T::Item`) (Second attempt) r=flodiebold a=flodiebold\n\nThis is only allowed for generic parameters (including `Self` in traits), and\r\nspecial care needs to be taken to not run into cycles while resolving it,\r\nbecause we use the where clauses of the generic parameter to find candidates for\r\nthe trait containing the associated type, but the where clauses may themselves\r\ncontain instances of short-hand associated types.\r\n\r\nIn some cases this is even fine, e.g. we might have `T: Trait<U::Item>, U:\r\nIterator`. If there is a cycle, we'll currently panic, which isn't great, but\r\nbetter than overflowing the stack...\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "html_url": "https://github.com/rust-lang/rust/commit/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efcbca95595d31bb4c2c6782530d5a7a64a4191f", "url": "https://api.github.com/repos/rust-lang/rust/commits/efcbca95595d31bb4c2c6782530d5a7a64a4191f", "html_url": "https://github.com/rust-lang/rust/commit/efcbca95595d31bb4c2c6782530d5a7a64a4191f"}, {"sha": "bc905d202c613a831f7c1abb846b612900a9b43a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc905d202c613a831f7c1abb846b612900a9b43a", "html_url": "https://github.com/rust-lang/rust/commit/bc905d202c613a831f7c1abb846b612900a9b43a"}], "stats": {"total": 196, "additions": 173, "deletions": 23}, "files": [{"sha": "05259dcbb7e1104d10b4887b7fb36a8d2fccd81e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "patch": "@@ -164,6 +164,13 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n \n+    #[salsa::invoke(crate::ty::generic_predicates_for_param_query)]\n+    fn generic_predicates_for_param(\n+        &self,\n+        def: GenericDef,\n+        param_idx: u32,\n+    ) -> Arc<[GenericPredicate]>;\n+\n     #[salsa::invoke(crate::ty::generic_predicates_query)]\n     fn generic_predicates(&self, def: GenericDef) -> Arc<[GenericPredicate]>;\n "}, {"sha": "ccb7774920091259b7eac5d5cc0b652c58cd5291", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "patch": "@@ -26,8 +26,9 @@ pub struct GenericParam {\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n-#[derive(Clone, PartialEq, Eq, Debug, Default)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParams {\n+    pub(crate) def: GenericDef,\n     pub(crate) parent_params: Option<Arc<GenericParams>>,\n     pub(crate) params: Vec<GenericParam>,\n     pub(crate) where_predicates: Vec<WherePredicate>,\n@@ -69,15 +70,19 @@ impl GenericParams {\n         db: &(impl DefDatabase + AstDatabase),\n         def: GenericDef,\n     ) -> Arc<GenericParams> {\n-        let mut generics = GenericParams::default();\n         let parent = match def {\n             GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n             GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n             GenericDef::EnumVariant(it) => Some(it.parent_enum(db).into()),\n             GenericDef::Adt(_) | GenericDef::Trait(_) => None,\n             GenericDef::ImplBlock(_) => None,\n         };\n-        generics.parent_params = parent.map(|p| db.generic_params(p));\n+        let mut generics = GenericParams {\n+            def,\n+            params: Vec::new(),\n+            parent_params: parent.map(|p| db.generic_params(p)),\n+            where_predicates: Vec::new(),\n+        };\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         match def {"}, {"sha": "39f8e1d8a519659e3c681d7d21c5566cf76b27e6", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "patch": "@@ -344,6 +344,13 @@ impl Resolver {\n             })\n             .flat_map(|params| params.where_predicates.iter())\n     }\n+\n+    pub(crate) fn generic_def(&self) -> Option<crate::generics::GenericDef> {\n+        self.scopes.iter().find_map(|scope| match scope {\n+            Scope::GenericParams(params) => Some(params.def),\n+            _ => None,\n+        })\n+    }\n }\n \n impl Resolver {"}, {"sha": "36bfb10cef61f3045382195a437c40368b41dfc1", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "patch": "@@ -23,8 +23,8 @@ pub(crate) use autoderef::autoderef;\n pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub(crate) use lower::{\n-    callable_item_sig, generic_defaults_query, generic_predicates_query, type_for_def,\n-    type_for_field, TypableDef,\n+    callable_item_sig, generic_defaults_query, generic_predicates_for_param_query,\n+    generic_predicates_query, type_for_def, type_for_field, TypableDef,\n };\n pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n "}, {"sha": "8d71abc95d2103fd50aeb51f79980c258147410f", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 88, "deletions": 9, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "patch": "@@ -86,6 +86,35 @@ impl Ty {\n         }\n     }\n \n+    /// This is only for `generic_predicates_for_param`, where we can't just\n+    /// lower the self types of the predicates since that could lead to cycles.\n+    /// So we just check here if the `type_ref` resolves to a generic param, and which.\n+    fn from_hir_only_param(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        type_ref: &TypeRef,\n+    ) -> Option<u32> {\n+        let path = match type_ref {\n+            TypeRef::Path(path) => path,\n+            _ => return None,\n+        };\n+        if let crate::PathKind::Type(_) = &path.kind {\n+            return None;\n+        }\n+        if path.segments.len() > 1 {\n+            return None;\n+        }\n+        let resolution = match resolver.resolve_path_in_type_ns(db, path) {\n+            Some((it, None)) => it,\n+            _ => return None,\n+        };\n+        if let TypeNs::GenericParam(idx) = resolution {\n+            Some(idx)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub(crate) fn from_type_relative_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -189,11 +218,37 @@ impl Ty {\n     }\n \n     fn select_associated_type(\n-        _db: &impl HirDatabase,\n-        _resolver: &Resolver,\n-        _self_ty: Ty,\n-        _segment: &PathSegment,\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        self_ty: Ty,\n+        segment: &PathSegment,\n     ) -> Ty {\n+        let param_idx = match self_ty {\n+            Ty::Param { idx, .. } => idx,\n+            _ => return Ty::Unknown, // Error: Ambiguous associated type\n+        };\n+        let def = match resolver.generic_def() {\n+            Some(def) => def,\n+            None => return Ty::Unknown, // this can't actually happen\n+        };\n+        let predicates = db.generic_predicates_for_param(def, param_idx);\n+        let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n+            GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n+            _ => None,\n+        });\n+        let traits = traits_from_env.flat_map(|t| t.all_super_traits(db));\n+        for t in traits {\n+            if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n+                let generics = t.generic_params(db);\n+                let mut substs = Vec::new();\n+                substs.push(self_ty.clone());\n+                substs.extend(\n+                    iter::repeat(Ty::Unknown).take(generics.count_params_including_parent() - 1),\n+                );\n+                // FIXME handle type parameters on the segment\n+                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs.into() });\n+            }\n+        }\n         Ty::Unknown\n     }\n \n@@ -269,9 +324,10 @@ pub(super) fn substs_from_path_segment(\n     add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| def.generic_params(db)).unwrap_or_default();\n+    let def_generics = def_generic.map(|def| def.generic_params(db));\n \n-    let parent_param_count = def_generics.count_parent_params();\n+    let (parent_param_count, param_count) =\n+        def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n     substs.extend(iter::repeat(Ty::Unknown).take(parent_param_count));\n     if add_self_param {\n         // FIXME this add_self_param argument is kind of a hack: Traits have the\n@@ -283,7 +339,7 @@ pub(super) fn substs_from_path_segment(\n     if let Some(generic_args) = &segment.args_and_bindings {\n         // if args are provided, it should be all of them, but we can't rely on that\n         let self_param_correction = if add_self_param { 1 } else { 0 };\n-        let param_count = def_generics.params.len() - self_param_correction;\n+        let param_count = param_count - self_param_correction;\n         for arg in generic_args.args.iter().take(param_count) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n@@ -295,10 +351,10 @@ pub(super) fn substs_from_path_segment(\n     }\n     // add placeholders for args that were not provided\n     let supplied_params = substs.len();\n-    for _ in supplied_params..def_generics.count_params_including_parent() {\n+    for _ in supplied_params..parent_param_count + param_count {\n         substs.push(Ty::Unknown);\n     }\n-    assert_eq!(substs.len(), def_generics.count_params_including_parent());\n+    assert_eq!(substs.len(), parent_param_count + param_count);\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n@@ -491,6 +547,29 @@ pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     Ty::from_hir(db, &resolver, type_ref)\n }\n \n+/// This query exists only to be used when resolving short-hand associated types\n+/// like `T::Item`.\n+///\n+/// See the analogous query in rustc and its comment:\n+/// https://github.com/rust-lang/rust/blob/9150f844e2624eb013ec78ca08c1d416e6644026/src/librustc_typeck/astconv.rs#L46\n+/// This is a query mostly to handle cycles somewhat gracefully; e.g. the\n+/// following bounds are disallowed: `T: Foo<U::Item>, U: Foo<T::Item>`, but\n+/// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n+pub(crate) fn generic_predicates_for_param_query(\n+    db: &impl HirDatabase,\n+    def: GenericDef,\n+    param_idx: u32,\n+) -> Arc<[GenericPredicate]> {\n+    let resolver = def.resolver(db);\n+    let predicates = resolver\n+        .where_predicates_in_scope()\n+        // we have to filter out all other predicates *first*, before attempting to lower them\n+        .filter(|pred| Ty::from_hir_only_param(db, &resolver, &pred.type_ref) == Some(param_idx))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .collect::<Vec<_>>();\n+    predicates.into()\n+}\n+\n pub(crate) fn trait_env(\n     db: &impl HirDatabase,\n     resolver: &Resolver,"}, {"sha": "3ac1fbdd50df364144b79e12714e04b5c5ac0a6c", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "patch": "@@ -2740,17 +2740,17 @@ fn test() {\n     [202; 203) 't': T\n     [221; 223) '{}': ()\n     [234; 300) '{     ...(S); }': ()\n-    [244; 245) 'x': {unknown}\n-    [248; 252) 'foo1': fn foo1<S>(T) -> {unknown}\n-    [248; 255) 'foo1(S)': {unknown}\n+    [244; 245) 'x': u32\n+    [248; 252) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [248; 255) 'foo1(S)': u32\n     [253; 254) 'S': S\n     [265; 266) 'y': u32\n     [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n     [269; 276) 'foo2(S)': u32\n     [274; 275) 'S': S\n-    [286; 287) 'z': {unknown}\n-    [290; 294) 'foo3': fn foo3<S>(T) -> {unknown}\n-    [290; 297) 'foo3(S)': {unknown}\n+    [286; 287) 'z': u32\n+    [290; 294) 'foo3': fn foo3<S>(T) -> <T as Iterable>::Item\n+    [290; 297) 'foo3(S)': u32\n     [295; 296) 'S': S\n     \"###\n     );\n@@ -4080,7 +4080,7 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n }\n \n #[test]\n-fn unselected_projection_in_trait_env() {\n+fn unselected_projection_in_trait_env_1() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -4102,7 +4102,33 @@ fn test<T: Trait>() where T::Item: Trait2 {\n }\n \n #[test]\n-fn unselected_projection_in_trait_env_cycle() {\n+fn unselected_projection_in_trait_env_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+trait Trait2 {\n+    fn foo(&self) -> u32;\n+}\n+\n+fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n+    let x: T::Item = no_matter;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+// FIXME this is currently a Salsa panic; it would be nicer if it just returned\n+// in Unknown, and we should be able to do that once Salsa allows us to handle\n+// the cycle. But at least it doesn't overflow for now.\n+#[should_panic]\n+fn unselected_projection_in_trait_env_cycle_1() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -4121,6 +4147,28 @@ fn test<T: Trait>() where T: Trait2<T::Item> {\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+// FIXME this is currently a Salsa panic; it would be nicer if it just returned\n+// in Unknown, and we should be able to do that once Salsa allows us to handle\n+// the cycle. But at least it doesn't overflow for now.\n+#[should_panic]\n+fn unselected_projection_in_trait_env_cycle_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n+    let x: T::Item = no_matter<|>;\n+}\n+\"#,\n+    );\n+    // this is a legitimate cycle\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "cfecf75ee62e61f0ea4317d2c48b66bb10175d1a", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=c2d9cca4e42ad052cf8a37ba3f6d9eacae07cbea", "patch": "@@ -104,7 +104,11 @@ impl ToChalk for Ty {\n                     }\n                 }\n             }\n-            chalk_ir::Ty::Projection(_) => unimplemented!(),\n+            chalk_ir::Ty::Projection(proj) => {\n+                let associated_ty = from_chalk(db, proj.associated_ty_id);\n+                let parameters = from_chalk(db, proj.parameters);\n+                Ty::Projection(ProjectionTy { associated_ty, parameters })\n+            }\n             chalk_ir::Ty::ForAll(_) => unimplemented!(),\n             chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n             chalk_ir::Ty::InferenceVar(_iv) => panic!(\"unexpected chalk infer ty\"),"}]}