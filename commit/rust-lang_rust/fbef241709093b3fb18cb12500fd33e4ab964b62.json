{"sha": "fbef241709093b3fb18cb12500fd33e4ab964b62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZWYyNDE3MDkwOTNiM2ZiMThjYjEyNTAwZmQzM2U0YWI5NjRiNjI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-12-31T16:06:38Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-24T13:21:03Z"}, "message": "Add a lint to detect unconditional recursion.\n\nE.g. `fn foo() { foo() }`, or, more subtlely\n\n    impl Foo for Box<Foo+'static> {\n        fn bar(&self) {\n            self.bar();\n        }\n    }\n\nThe compiler will warn and point out the points where recursion occurs,\nif it determines that the function cannot return without calling itself.\n\nCloses #17899.", "tree": {"sha": "321f775a86430cc2dc03ad94b6f542252641f91f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/321f775a86430cc2dc03ad94b6f542252641f91f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbef241709093b3fb18cb12500fd33e4ab964b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbef241709093b3fb18cb12500fd33e4ab964b62", "html_url": "https://github.com/rust-lang/rust/commit/fbef241709093b3fb18cb12500fd33e4ab964b62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbef241709093b3fb18cb12500fd33e4ab964b62/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "000dc07f71baafc31da74e392ad5530fb6de9757", "url": "https://api.github.com/repos/rust-lang/rust/commits/000dc07f71baafc31da74e392ad5530fb6de9757", "html_url": "https://github.com/rust-lang/rust/commit/000dc07f71baafc31da74e392ad5530fb6de9757"}], "stats": {"total": 259, "additions": 258, "deletions": 1}, "files": [{"sha": "531bdc2941e0431ca0694bd4299db252e400d316", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 191, "deletions": 1, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/fbef241709093b3fb18cb12500fd33e4ab964b62/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbef241709093b3fb18cb12500fd33e4ab964b62/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=fbef241709093b3fb18cb12500fd33e4ab964b62", "patch": "@@ -32,10 +32,12 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n+use middle::cfg;\n use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n-use lint::{Context, LintPass, LintArray, Lint};\n+use lint::{Level, Context, LintPass, LintArray, Lint};\n \n+use std::collections::BitvSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{cmp, slice};\n@@ -1788,6 +1790,194 @@ impl LintPass for Stability {\n     }\n }\n \n+declare_lint! {\n+    pub UNCONDITIONAL_RECURSION,\n+    Warn,\n+    \"functions that cannot return without calling themselves\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnconditionalRecursion;\n+\n+\n+impl LintPass for UnconditionalRecursion {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![UNCONDITIONAL_RECURSION]\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, fn_kind: visit::FnKind, _: &ast::FnDecl,\n+                blk: &ast::Block, sp: Span, id: ast::NodeId) {\n+        type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n+                              ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n+\n+        let (name, checker) = match fn_kind {\n+            visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n+            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n+            // closures can't recur, so they don't matter.\n+            visit::FkFnBlock => return\n+        };\n+\n+        let impl_def_id = ty::impl_of_method(cx.tcx, ast_util::local_def(id))\n+            .unwrap_or(ast_util::local_def(ast::DUMMY_NODE_ID));\n+        assert!(ast_util::is_local(impl_def_id));\n+        let impl_node_id = impl_def_id.node;\n+\n+        // Walk through this function (say `f`) looking to see if\n+        // every possible path references itself, i.e. the function is\n+        // called recursively unconditionally. This is done by trying\n+        // to find a path from the entry node to the exit node that\n+        // *doesn't* call `f` by traversing from the entry while\n+        // pretending that calls of `f` are sinks (i.e. ignoring any\n+        // exit edges from them).\n+        //\n+        // NB. this has an edge case with non-returning statements,\n+        // like `loop {}` or `panic!()`: control flow never reaches\n+        // the exit node through these, so one can have a function\n+        // that never actually calls itselfs but is still picked up by\n+        // this lint:\n+        //\n+        //     fn f(cond: bool) {\n+        //         if !cond { panic!() } // could come from `assert!(cond)`\n+        //         f(false)\n+        //     }\n+        //\n+        // In general, functions of that form may be able to call\n+        // itself a finite number of times and then diverge. The lint\n+        // considers this to be an error for two reasons, (a) it is\n+        // easier to implement, and (b) it seems rare to actually want\n+        // to have behaviour like the above, rather than\n+        // e.g. accidentally recurring after an assert.\n+\n+        let cfg = cfg::CFG::new(cx.tcx, blk);\n+\n+        let mut work_queue = vec![cfg.entry];\n+        let mut reached_exit_without_self_call = false;\n+        let mut self_call_spans = vec![];\n+        let mut visited = BitvSet::new();\n+\n+        while let Some(idx) = work_queue.pop() {\n+            let cfg_id = idx.node_id();\n+            if idx == cfg.exit {\n+                // found a path!\n+                reached_exit_without_self_call = true;\n+                break\n+            } else if visited.contains(&cfg_id) {\n+                // already done\n+                continue\n+            }\n+            visited.insert(cfg_id);\n+            let node_id = cfg.graph.node_data(idx).id;\n+\n+            // is this a recursive call?\n+            if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n+\n+                self_call_spans.push(cx.tcx.map.span(node_id));\n+                // this is a self call, so we shouldn't explore past\n+                // this node in the CFG.\n+                continue\n+            }\n+            // add the successors of this node to explore the graph further.\n+            cfg.graph.each_outgoing_edge(idx, |_, edge| {\n+                let target_idx = edge.target();\n+                let target_cfg_id = target_idx.node_id();\n+                if !visited.contains(&target_cfg_id) {\n+                    work_queue.push(target_idx)\n+                }\n+                true\n+            });\n+        }\n+\n+        // check the number of sell calls because a function that\n+        // doesn't return (e.g. calls a `-> !` function or `loop { /*\n+        // no break */ }`) shouldn't be linted unless it actually\n+        // recurs.\n+        if !reached_exit_without_self_call && self_call_spans.len() > 0 {\n+            cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n+                         \"function cannot return without recurring\");\n+\n+            // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n+            if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n+                let sess = cx.sess();\n+                // offer some help to the programmer.\n+                for call in self_call_spans.iter() {\n+                    sess.span_note(*call, \"recursive call site\")\n+                }\n+                sess.span_help(sp, \"a `loop` may express intention better if this is on purpose\")\n+            }\n+        }\n+\n+        // all done\n+        return;\n+\n+        // Functions for identifying if the given NodeId `id`\n+        // represents a call to the function `fn_id`/method\n+        // `method_id`.\n+\n+        fn id_refers_to_this_fn<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      _: ast::NodeId,\n+                                      fn_id: ast::NodeId,\n+                                      _: ast::Ident,\n+                                      id: ast::NodeId) -> bool {\n+            tcx.def_map.borrow().get(&id)\n+                .map_or(false, |def| {\n+                    let did = def.def_id();\n+                    ast_util::is_local(did) && did.node == fn_id\n+                })\n+        }\n+\n+        // check if the method call `id` refers to method `method_id`\n+        // (with name `method_name` contained in impl `impl_id`).\n+        fn id_refers_to_this_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          impl_id: ast::NodeId,\n+                                          method_id: ast::NodeId,\n+                                          method_name: ast::Ident,\n+                                          id: ast::NodeId) -> bool {\n+            let did = match tcx.method_map.borrow().get(&ty::MethodCall::expr(id)) {\n+                None => return false,\n+                Some(m) => match m.origin {\n+                    // There's no way to know if a method call via a\n+                    // vtable is recursion, so we assume it's not.\n+                    ty::MethodTraitObject(_) => return false,\n+\n+                    // This `did` refers directly to the method definition.\n+                    ty::MethodStatic(did) | ty::MethodStaticUnboxedClosure(did) => did,\n+\n+                    // MethodTypeParam are methods from traits:\n+\n+                    // The `impl ... for ...` of this method call\n+                    // isn't known, e.g. it might be a default method\n+                    // in a trait, so we get the def-id of the trait\n+                    // method instead.\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n+                        ty::trait_item(tcx, trait_ref.def_id, method_num).def_id()\n+                    }\n+\n+                    // The `impl` is known, so we check that with a\n+                    // special case:\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { impl_def_id: Some(impl_def_id), .. }) => {\n+\n+                        let name = match tcx.map.expect_expr(id).node {\n+                            ast::ExprMethodCall(ref sp_ident, _, _) => sp_ident.node,\n+                            _ => tcx.sess.span_bug(\n+                                tcx.map.span(id),\n+                                \"non-method call expr behaving like a method call?\")\n+                        };\n+                        // it matches if it comes from the same impl,\n+                        // and has the same method name.\n+                        return ast_util::is_local(impl_def_id)\n+                            && impl_def_id.node == impl_id\n+                            && method_name.name == name.name\n+                    }\n+                }\n+            };\n+\n+            ast_util::is_local(did) && did.node == method_id\n+        }\n+    }\n+}\n+\n declare_lint! {\n     pub UNUSED_IMPORTS,\n     Warn,"}, {"sha": "3728e6f4980d94059716f9be70f466da79faa6e2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbef241709093b3fb18cb12500fd33e4ab964b62/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbef241709093b3fb18cb12500fd33e4ab964b62/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=fbef241709093b3fb18cb12500fd33e4ab964b62", "patch": "@@ -211,6 +211,7 @@ impl LintStore {\n                      UnusedAllocation,\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n+                     UnconditionalRecursion,\n         );\n \n         add_builtin_with_new!(sess,"}, {"sha": "0c3d1c6adea40c247440a8d77a039175b6630a45", "filename": "src/test/compile-fail/lint-unconditional-recursion.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fbef241709093b3fb18cb12500fd33e4ab964b62/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbef241709093b3fb18cb12500fd33e4ab964b62/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs?ref=fbef241709093b3fb18cb12500fd33e4ab964b62", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(unconditional_recursion)]\n+#![allow(dead_code)]\n+fn foo() { //~ ERROR function cannot return without recurring\n+    foo(); //~ NOTE recursive call site\n+}\n+\n+fn bar() {\n+    if true {\n+        bar()\n+    }\n+}\n+\n+fn baz() { //~ ERROR function cannot return without recurring\n+    if true {\n+        baz() //~ NOTE recursive call site\n+    } else {\n+        baz() //~ NOTE recursive call site\n+    }\n+}\n+\n+fn qux() {\n+    loop {}\n+}\n+\n+fn quz() -> bool { //~ ERROR function cannot return without recurring\n+    if true {\n+        while quz() {} //~ NOTE recursive call site\n+        true\n+    } else {\n+        loop { quz(); } //~ NOTE recursive call site\n+    }\n+}\n+\n+trait Foo {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        self.bar() //~ NOTE recursive call site\n+    }\n+}\n+\n+impl Foo for Box<Foo+'static> {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        loop {\n+            self.bar() //~ NOTE recursive call site\n+        }\n+    }\n+\n+}\n+\n+struct Baz;\n+impl Baz {\n+    fn qux(&self) { //~ ERROR function cannot return without recurring\n+        self.qux(); //~ NOTE recursive call site\n+    }\n+}\n+\n+fn main() {}"}]}