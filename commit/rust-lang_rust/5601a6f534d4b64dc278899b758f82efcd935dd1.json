{"sha": "5601a6f534d4b64dc278899b758f82efcd935dd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MDFhNmY1MzRkNGI2NGRjMjc4ODk5Yjc1OGY4MmVmY2Q5MzVkZDE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T21:37:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T23:30:27Z"}, "message": "Move metadata::cwriter::encode to metadata::tyencode", "tree": {"sha": "cae6081c2cf1fbdde0df8a49798ce127959d33ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cae6081c2cf1fbdde0df8a49798ce127959d33ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5601a6f534d4b64dc278899b758f82efcd935dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5601a6f534d4b64dc278899b758f82efcd935dd1", "html_url": "https://github.com/rust-lang/rust/commit/5601a6f534d4b64dc278899b758f82efcd935dd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5601a6f534d4b64dc278899b758f82efcd935dd1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba5c7a570d1bc6f28e7a2f4eb5cfd50b7c19f374", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba5c7a570d1bc6f28e7a2f4eb5cfd50b7c19f374", "html_url": "https://github.com/rust-lang/rust/commit/ba5c7a570d1bc6f28e7a2f4eb5cfd50b7c19f374"}], "stats": {"total": 507, "additions": 262, "deletions": 245}, "files": [{"sha": "3ec46ff43265f220eed8b463e061deefc4e76a51", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=5601a6f534d4b64dc278899b758f82efcd935dd1", "patch": "@@ -400,13 +400,13 @@ fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t, str crate_meta_name,\n     auto cx =\n         @rec(ds=metadata::cwriter::def_to_str,\n              tcx=tcx,\n-             abbrevs=metadata::cwriter::ac_no_abbrevs);\n+             abbrevs=metadata::tyencode::ac_no_abbrevs);\n     sha.reset();\n     sha.input_str(crate_meta_name);\n     sha.input_str(\"-\");\n     sha.input_str(crate_meta_name);\n     sha.input_str(\"-\");\n-    sha.input_str(metadata::cwriter::encode::ty_str(cx, t));\n+    sha.input_str(metadata::tyencode::ty_str(cx, t));\n     auto hash = truncated_sha1_result(sha);\n     // Prefix with _ so that it never blends into adjacent digits\n \n@@ -453,7 +453,6 @@ fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) ->\n    str {\n     auto f = metadata::cwriter::def_to_str;\n-    auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata::cwriter::ac_no_abbrevs);\n     auto s = pretty::ppaux::ty_to_short_str(ccx.tcx, t);\n     auto hash = get_symbol_hash(ccx, t);\n     ret mangle([name, s, hash]);"}, {"sha": "8932a1a30889f3fb921822431fe1db8509bcb780", "filename": "src/comp/metadata/cwriter.rs", "status": "modified", "additions": 2, "deletions": 236, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fmetadata%2Fcwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fmetadata%2Fcwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcwriter.rs?ref=5601a6f534d4b64dc278899b758f82efcd935dd1", "patch": "@@ -97,240 +97,6 @@ const uint tag_meta_item_key = 0x19u;\n const uint tag_meta_item_value = 0x20u;\n \n \n-// Type encoding\n-\n-// Compact string representation for ty.t values. API ty_str & parse_from_str.\n-// Extra parameters are for converting to/from def_ids in the string rep.\n-// Whatever format you choose should not contain pipe characters.\n-type ty_abbrev = rec(uint pos, uint len, str s);\n-\n-tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap[ty::t, ty_abbrev]); }\n-\n-mod encode {\n-    type ctxt =\n-        rec(fn(&def_id) -> str  ds, // Def -> str Callback:\n-\n-            ty::ctxt tcx, // The type context.\n-\n-            abbrev_ctxt abbrevs);\n-\n-    fn cx_uses_abbrevs(&@ctxt cx) -> bool {\n-        alt (cx.abbrevs) {\n-            case (ac_no_abbrevs) { ret false; }\n-            case (ac_use_abbrevs(_)) { ret true; }\n-        }\n-    }\n-    fn ty_str(&@ctxt cx, &ty::t t) -> str {\n-        assert (!cx_uses_abbrevs(cx));\n-        auto sw = io::string_writer();\n-        enc_ty(sw.get_writer(), cx, t);\n-        ret sw.get_str();\n-    }\n-    fn enc_ty(&io::writer w, &@ctxt cx, &ty::t t) {\n-        alt (cx.abbrevs) {\n-            case (ac_no_abbrevs) {\n-                auto result_str;\n-                alt (cx.tcx.short_names_cache.find(t)) {\n-                    case (some(?s)) { result_str = s; }\n-                    case (none) {\n-                        auto sw = io::string_writer();\n-                        enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n-                        result_str = sw.get_str();\n-                        cx.tcx.short_names_cache.insert(t, result_str);\n-                    }\n-                }\n-                w.write_str(result_str);\n-            }\n-            case (ac_use_abbrevs(?abbrevs)) {\n-                alt (abbrevs.find(t)) {\n-                    case (some(?a)) { w.write_str(a.s); ret; }\n-                    case (none) {\n-                        auto pos = w.get_buf_writer().tell();\n-                        auto ss = enc_sty(w, cx, ty::struct(cx.tcx, t));\n-                        auto end = w.get_buf_writer().tell();\n-                        auto len = end - pos;\n-                        fn estimate_sz(uint u) -> uint {\n-                            auto n = u;\n-                            auto len = 0u;\n-                            while (n != 0u) { len += 1u; n = n >> 4u; }\n-                            ret len;\n-                        }\n-                        auto abbrev_len =\n-                            3u + estimate_sz(pos) + estimate_sz(len);\n-                        if (abbrev_len < len) {\n-                            // I.e. it's actually an abbreviation.\n-\n-                            auto s =\n-                                \"#\" + uint::to_str(pos, 16u) + \":\" +\n-                                    uint::to_str(len, 16u) + \"#\";\n-                            auto a = rec(pos=pos, len=len, s=s);\n-                            abbrevs.insert(t, a);\n-                        }\n-                        ret;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    fn enc_mt(&io::writer w, &@ctxt cx, &ty::mt mt) {\n-        alt (mt.mut) {\n-            case (imm) { }\n-            case (mut) { w.write_char('m'); }\n-            case (maybe_mut) { w.write_char('?'); }\n-        }\n-        enc_ty(w, cx, mt.ty);\n-    }\n-    fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n-        alt (st) {\n-            case (ty::ty_nil) { w.write_char('n'); }\n-            case (ty::ty_bot) { w.write_char('z'); }\n-            case (ty::ty_bool) { w.write_char('b'); }\n-            case (ty::ty_int) { w.write_char('i'); }\n-            case (ty::ty_uint) { w.write_char('u'); }\n-            case (ty::ty_float) { w.write_char('l'); }\n-            case (ty::ty_machine(?mach)) {\n-                alt (mach) {\n-                    case (common::ty_u8) { w.write_str(\"Mb\"); }\n-                    case (common::ty_u16) { w.write_str(\"Mw\"); }\n-                    case (common::ty_u32) { w.write_str(\"Ml\"); }\n-                    case (common::ty_u64) { w.write_str(\"Md\"); }\n-                    case (common::ty_i8) { w.write_str(\"MB\"); }\n-                    case (common::ty_i16) { w.write_str(\"MW\"); }\n-                    case (common::ty_i32) { w.write_str(\"ML\"); }\n-                    case (common::ty_i64) { w.write_str(\"MD\"); }\n-                    case (common::ty_f32) { w.write_str(\"Mf\"); }\n-                    case (common::ty_f64) { w.write_str(\"MF\"); }\n-                }\n-            }\n-            case (ty::ty_char) { w.write_char('c'); }\n-            case (ty::ty_str) { w.write_char('s'); }\n-            case (ty::ty_istr) { w.write_char('S'); }\n-            case (ty::ty_tag(?def, ?tys)) {\n-                w.write_str(\"t[\");\n-                w.write_str(cx.ds(def));\n-                w.write_char('|');\n-                for (ty::t t in tys) { enc_ty(w, cx, t); }\n-                w.write_char(']');\n-            }\n-            case (ty::ty_box(?mt)) { w.write_char('@'); enc_mt(w, cx, mt); }\n-            case (ty::ty_ptr(?mt)) { w.write_char('*'); enc_mt(w, cx, mt); }\n-            case (ty::ty_vec(?mt)) { w.write_char('V'); enc_mt(w, cx, mt); }\n-            case (ty::ty_ivec(?mt)) { w.write_char('I'); enc_mt(w, cx, mt); }\n-            case (ty::ty_port(?t)) { w.write_char('P'); enc_ty(w, cx, t); }\n-            case (ty::ty_chan(?t)) { w.write_char('C'); enc_ty(w, cx, t); }\n-            case (ty::ty_tup(?mts)) {\n-                w.write_str(\"T[\");\n-                for (ty::mt mt in mts) { enc_mt(w, cx, mt); }\n-                w.write_char(']');\n-            }\n-            case (ty::ty_rec(?fields)) {\n-                w.write_str(\"R[\");\n-                for (ty::field field in fields) {\n-                    w.write_str(field.ident);\n-                    w.write_char('=');\n-                    enc_mt(w, cx, field.mt);\n-                }\n-                w.write_char(']');\n-            }\n-            case (ty::ty_fn(?proto, ?args, ?out, ?cf, ?constrs)) {\n-                enc_proto(w, proto);\n-                enc_ty_fn(w, cx, args, out, cf, constrs);\n-            }\n-            case (ty::ty_native_fn(?abi, ?args, ?out)) {\n-                w.write_char('N');\n-                alt (abi) {\n-                    case (native_abi_rust) { w.write_char('r'); }\n-                    case (native_abi_rust_intrinsic) {\n-                        w.write_char('i');\n-                    }\n-                    case (native_abi_cdecl) { w.write_char('c'); }\n-                    case (native_abi_llvm) { w.write_char('l'); }\n-                }\n-                enc_ty_fn(w, cx, args, out, return, []);\n-            }\n-            case (ty::ty_obj(?methods)) {\n-                w.write_str(\"O[\");\n-                for (ty::method m in methods) {\n-                    enc_proto(w, m.proto);\n-                    w.write_str(m.ident);\n-                    enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n-                }\n-                w.write_char(']');\n-            }\n-            case (ty::ty_res(?def, ?ty)) {\n-                w.write_char('r');\n-                w.write_str(cx.ds(def));\n-                w.write_char('|');\n-                enc_ty(w, cx, ty);\n-            }\n-            case (ty::ty_var(?id)) {\n-                w.write_char('X');\n-                w.write_str(common::istr(id));\n-            }\n-            case (ty::ty_native) { w.write_char('E'); }\n-            case (ty::ty_param(?id)) {\n-                w.write_char('p');\n-                w.write_str(common::uistr(id));\n-            }\n-            case (ty::ty_type) { w.write_char('Y'); }\n-            case (ty::ty_task) { w.write_char('a'); }\n-        }\n-    }\n-    fn enc_proto(&io::writer w, proto proto) {\n-        alt (proto) {\n-            case (proto_iter) { w.write_char('W'); }\n-            case (proto_fn) { w.write_char('F'); }\n-        }\n-    }\n-    fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n-                 &controlflow cf, &vec[@ty::constr_def] constrs) {\n-        w.write_char('[');\n-        for (ty::arg arg in args) {\n-            alt (arg.mode) {\n-                case (ty::mo_alias(?mut)) {\n-                    w.write_char('&');\n-                    if (mut) { w.write_char('m'); }\n-                }\n-                case (ty::mo_val) { }\n-            }\n-            enc_ty(w, cx, arg.ty);\n-        }\n-        w.write_char(']');\n-        auto colon = true;\n-        for (@ty::constr_def c in constrs) {\n-            if (colon) {\n-                w.write_char(':');\n-                colon = false;\n-            } else { w.write_char(';'); }\n-            enc_constr(w, cx, c);\n-        }\n-        alt (cf) {\n-            case (noreturn) { w.write_char('!'); }\n-            case (_) { enc_ty(w, cx, out); }\n-        }\n-\n-    }\n-    fn enc_constr(&io::writer w, &@ctxt cx, &@ty::constr_def c) {\n-        w.write_str(path_to_str(c.node.path));\n-        w.write_char('(');\n-        w.write_str(cx.ds(c.node.id));\n-        w.write_char('|');\n-        auto semi = false;\n-        for (@constr_arg a in c.node.args) {\n-            if (semi) { w.write_char(';'); } else { semi = true; }\n-            alt (a.node) {\n-                case (carg_base) { w.write_char('*'); }\n-                case (carg_ident(?i)) { \n-                    w.write_uint(i);\n-                }\n-                case (carg_lit(?l)) { w.write_str(lit_to_str(l)); }\n-            }\n-        }\n-        w.write_char(')');\n-    }\n-}\n-\n-\n // Returns a Plain Old LLVM String:\n fn C_postr(&str s) -> ValueRef {\n     ret llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n@@ -497,8 +263,8 @@ fn encode_type(&@trans::crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n     ebml::start_tag(ebml_w, tag_items_data_item_type);\n     auto f = def_to_str;\n     auto ty_str_ctxt =\n-        @rec(ds=f, tcx=cx.tcx, abbrevs=ac_use_abbrevs(cx.type_abbrevs));\n-    encode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n+        @rec(ds=f, tcx=cx.tcx, abbrevs=tyencode::ac_use_abbrevs(cx.type_abbrevs));\n+    tyencode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n     ebml::end_tag(ebml_w);\n }\n "}, {"sha": "287ad955948a36fdd4978915c1c1a1d6da594a79", "filename": "src/comp/metadata/tyencode.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=5601a6f534d4b64dc278899b758f82efcd935dd1", "patch": "@@ -0,0 +1,250 @@\n+// Type encoding\n+\n+import std::io;\n+import std::map::hashmap;\n+import std::option::some;\n+import std::option::none;\n+import std::uint;\n+import front::ast::*;\n+import middle::ty;\n+import pretty::ppaux::lit_to_str;\n+import util::common;\n+\n+type ctxt =\n+    rec(fn(&def_id) -> str  ds, // Def -> str Callback:\n+        ty::ctxt tcx, // The type context.\n+        abbrev_ctxt abbrevs);\n+\n+// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// Extra parameters are for converting to/from def_ids in the string rep.\n+// Whatever format you choose should not contain pipe characters.\n+type ty_abbrev = rec(uint pos, uint len, str s);\n+\n+tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap[ty::t, ty_abbrev]); }\n+\n+fn cx_uses_abbrevs(&@ctxt cx) -> bool {\n+    alt (cx.abbrevs) {\n+        case (ac_no_abbrevs) { ret false; }\n+        case (ac_use_abbrevs(_)) { ret true; }\n+    }\n+}\n+fn ty_str(&@ctxt cx, &ty::t t) -> str {\n+    assert (!cx_uses_abbrevs(cx));\n+    auto sw = io::string_writer();\n+    enc_ty(sw.get_writer(), cx, t);\n+    ret sw.get_str();\n+}\n+fn enc_ty(&io::writer w, &@ctxt cx, &ty::t t) {\n+    alt (cx.abbrevs) {\n+        case (ac_no_abbrevs) {\n+            auto result_str;\n+            alt (cx.tcx.short_names_cache.find(t)) {\n+                case (some(?s)) { result_str = s; }\n+                case (none) {\n+                    auto sw = io::string_writer();\n+                    enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n+                    result_str = sw.get_str();\n+                    cx.tcx.short_names_cache.insert(t, result_str);\n+                }\n+            }\n+            w.write_str(result_str);\n+        }\n+        case (ac_use_abbrevs(?abbrevs)) {\n+            alt (abbrevs.find(t)) {\n+                case (some(?a)) { w.write_str(a.s); ret; }\n+                case (none) {\n+                    auto pos = w.get_buf_writer().tell();\n+                    auto ss = enc_sty(w, cx, ty::struct(cx.tcx, t));\n+                    auto end = w.get_buf_writer().tell();\n+                    auto len = end - pos;\n+                    fn estimate_sz(uint u) -> uint {\n+                        auto n = u;\n+                        auto len = 0u;\n+                        while (n != 0u) { len += 1u; n = n >> 4u; }\n+                        ret len;\n+                    }\n+                    auto abbrev_len =\n+                        3u + estimate_sz(pos) + estimate_sz(len);\n+                    if (abbrev_len < len) {\n+                        // I.e. it's actually an abbreviation.\n+\n+                        auto s =\n+                            \"#\" + uint::to_str(pos, 16u) + \":\" +\n+                            uint::to_str(len, 16u) + \"#\";\n+                        auto a = rec(pos=pos, len=len, s=s);\n+                        abbrevs.insert(t, a);\n+                    }\n+                    ret;\n+                }\n+            }\n+        }\n+    }\n+}\n+fn enc_mt(&io::writer w, &@ctxt cx, &ty::mt mt) {\n+    alt (mt.mut) {\n+        case (imm) { }\n+        case (mut) { w.write_char('m'); }\n+        case (maybe_mut) { w.write_char('?'); }\n+    }\n+    enc_ty(w, cx, mt.ty);\n+}\n+fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n+    alt (st) {\n+        case (ty::ty_nil) { w.write_char('n'); }\n+        case (ty::ty_bot) { w.write_char('z'); }\n+        case (ty::ty_bool) { w.write_char('b'); }\n+        case (ty::ty_int) { w.write_char('i'); }\n+        case (ty::ty_uint) { w.write_char('u'); }\n+        case (ty::ty_float) { w.write_char('l'); }\n+        case (ty::ty_machine(?mach)) {\n+            alt (mach) {\n+                case (common::ty_u8) { w.write_str(\"Mb\"); }\n+                case (common::ty_u16) { w.write_str(\"Mw\"); }\n+                case (common::ty_u32) { w.write_str(\"Ml\"); }\n+                case (common::ty_u64) { w.write_str(\"Md\"); }\n+                case (common::ty_i8) { w.write_str(\"MB\"); }\n+                case (common::ty_i16) { w.write_str(\"MW\"); }\n+                case (common::ty_i32) { w.write_str(\"ML\"); }\n+                case (common::ty_i64) { w.write_str(\"MD\"); }\n+                case (common::ty_f32) { w.write_str(\"Mf\"); }\n+                case (common::ty_f64) { w.write_str(\"MF\"); }\n+            }\n+        }\n+        case (ty::ty_char) { w.write_char('c'); }\n+        case (ty::ty_str) { w.write_char('s'); }\n+        case (ty::ty_istr) { w.write_char('S'); }\n+        case (ty::ty_tag(?def, ?tys)) {\n+            w.write_str(\"t[\");\n+            w.write_str(cx.ds(def));\n+            w.write_char('|');\n+            for (ty::t t in tys) { enc_ty(w, cx, t); }\n+            w.write_char(']');\n+        }\n+        case (ty::ty_box(?mt)) { w.write_char('@'); enc_mt(w, cx, mt); }\n+        case (ty::ty_ptr(?mt)) { w.write_char('*'); enc_mt(w, cx, mt); }\n+        case (ty::ty_vec(?mt)) { w.write_char('V'); enc_mt(w, cx, mt); }\n+        case (ty::ty_ivec(?mt)) { w.write_char('I'); enc_mt(w, cx, mt); }\n+        case (ty::ty_port(?t)) { w.write_char('P'); enc_ty(w, cx, t); }\n+        case (ty::ty_chan(?t)) { w.write_char('C'); enc_ty(w, cx, t); }\n+        case (ty::ty_tup(?mts)) {\n+            w.write_str(\"T[\");\n+            for (ty::mt mt in mts) { enc_mt(w, cx, mt); }\n+            w.write_char(']');\n+        }\n+        case (ty::ty_rec(?fields)) {\n+            w.write_str(\"R[\");\n+            for (ty::field field in fields) {\n+                w.write_str(field.ident);\n+                w.write_char('=');\n+                enc_mt(w, cx, field.mt);\n+            }\n+            w.write_char(']');\n+        }\n+        case (ty::ty_fn(?proto, ?args, ?out, ?cf, ?constrs)) {\n+            enc_proto(w, proto);\n+            enc_ty_fn(w, cx, args, out, cf, constrs);\n+        }\n+        case (ty::ty_native_fn(?abi, ?args, ?out)) {\n+            w.write_char('N');\n+            alt (abi) {\n+                case (native_abi_rust) { w.write_char('r'); }\n+                case (native_abi_rust_intrinsic) {\n+                    w.write_char('i');\n+                }\n+                case (native_abi_cdecl) { w.write_char('c'); }\n+                case (native_abi_llvm) { w.write_char('l'); }\n+            }\n+            enc_ty_fn(w, cx, args, out, return, []);\n+        }\n+        case (ty::ty_obj(?methods)) {\n+            w.write_str(\"O[\");\n+            for (ty::method m in methods) {\n+                enc_proto(w, m.proto);\n+                w.write_str(m.ident);\n+                enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n+            }\n+            w.write_char(']');\n+        }\n+        case (ty::ty_res(?def, ?ty)) {\n+            w.write_char('r');\n+            w.write_str(cx.ds(def));\n+            w.write_char('|');\n+            enc_ty(w, cx, ty);\n+        }\n+        case (ty::ty_var(?id)) {\n+            w.write_char('X');\n+            w.write_str(common::istr(id));\n+        }\n+        case (ty::ty_native) { w.write_char('E'); }\n+        case (ty::ty_param(?id)) {\n+            w.write_char('p');\n+            w.write_str(common::uistr(id));\n+        }\n+        case (ty::ty_type) { w.write_char('Y'); }\n+        case (ty::ty_task) { w.write_char('a'); }\n+    }\n+}\n+fn enc_proto(&io::writer w, proto proto) {\n+    alt (proto) {\n+        case (proto_iter) { w.write_char('W'); }\n+        case (proto_fn) { w.write_char('F'); }\n+    }\n+}\n+fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n+             &controlflow cf, &vec[@ty::constr_def] constrs) {\n+    w.write_char('[');\n+    for (ty::arg arg in args) {\n+        alt (arg.mode) {\n+            case (ty::mo_alias(?mut)) {\n+                w.write_char('&');\n+                if (mut) { w.write_char('m'); }\n+            }\n+            case (ty::mo_val) { }\n+        }\n+        enc_ty(w, cx, arg.ty);\n+    }\n+    w.write_char(']');\n+    auto colon = true;\n+    for (@ty::constr_def c in constrs) {\n+        if (colon) {\n+            w.write_char(':');\n+            colon = false;\n+        } else { w.write_char(';'); }\n+        enc_constr(w, cx, c);\n+    }\n+    alt (cf) {\n+        case (noreturn) { w.write_char('!'); }\n+        case (_) { enc_ty(w, cx, out); }\n+    }\n+\n+}\n+fn enc_constr(&io::writer w, &@ctxt cx, &@ty::constr_def c) {\n+    w.write_str(ty::path_to_str(c.node.path));\n+    w.write_char('(');\n+    w.write_str(cx.ds(c.node.id));\n+    w.write_char('|');\n+    auto semi = false;\n+    for (@constr_arg a in c.node.args) {\n+        if (semi) { w.write_char(';'); } else { semi = true; }\n+        alt (a.node) {\n+            case (carg_base) { w.write_char('*'); }\n+            case (carg_ident(?i)) { \n+                w.write_uint(i);\n+            }\n+            case (carg_lit(?l)) { w.write_str(lit_to_str(l)); }\n+        }\n+    }\n+    w.write_char(')');\n+}\n+\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "5d4083c12f5c004132400772eb2b0a2e0e99e203", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5601a6f534d4b64dc278899b758f82efcd935dd1", "patch": "@@ -25,8 +25,6 @@ import std::option::some;\n import std::option::none;\n import std::fs;\n import front::ast;\n-import metadata::creader;\n-import metadata::cwriter;\n import driver::session;\n import middle::ty;\n import back::link;\n@@ -67,6 +65,9 @@ import link::mangle_exported_name;\n import link::crate_meta_name;\n import link::crate_meta_vers;\n import link::crate_meta_extras_hash;\n+import metadata::tyencode;\n+import metadata::creader;\n+import metadata::cwriter;\n import pretty::ppaux::ty_to_str;\n import pretty::ppaux::ty_to_short_str;\n import pretty::pprust::expr_to_str;\n@@ -149,7 +150,7 @@ type crate_ctxt =\n         namegen names,\n         std::sha1::sha1 sha,\n         hashmap[ty::t, str] type_sha1s,\n-        hashmap[ty::t, cwriter::ty_abbrev] type_abbrevs,\n+        hashmap[ty::t, tyencode::ty_abbrev] type_abbrevs,\n         hashmap[ty::t, str] type_short_names,\n         ty::ctxt tcx,\n         stats stats,\n@@ -8401,7 +8402,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n     auto tydescs = map::mk_hashmap[ty::t, @tydesc_info](hasher, eqer);\n     auto lltypes = map::mk_hashmap[ty::t, TypeRef](hasher, eqer);\n     auto sha1s = map::mk_hashmap[ty::t, str](hasher, eqer);\n-    auto abbrevs = map::mk_hashmap[ty::t, cwriter::ty_abbrev](hasher, eqer);\n+    auto abbrevs = map::mk_hashmap[ty::t, tyencode::ty_abbrev](hasher, eqer);\n     auto short_names = map::mk_hashmap[ty::t, str](hasher, eqer);\n     auto sha = std::sha1::mk_sha1();\n     auto ccx ="}, {"sha": "4037fe7e230d42ba6e354836ba839a024b3336b7", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=5601a6f534d4b64dc278899b758f82efcd935dd1", "patch": "@@ -150,8 +150,8 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n \n fn ty_to_short_str(&ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n-    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::cwriter::ac_no_abbrevs);\n-    auto s = metadata::cwriter::encode::ty_str(ecx, typ);\n+    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::tyencode::ac_no_abbrevs);\n+    auto s = metadata::tyencode::ty_str(ecx, typ);\n     if (str::byte_len(s) >= 32u) { s = str::substr(s, 0u, 32u); }\n     ret s;\n }"}, {"sha": "7a5fd9383336e0ef1ce942569be8ff15c964f905", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5601a6f534d4b64dc278899b758f82efcd935dd1/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=5601a6f534d4b64dc278899b758f82efcd935dd1", "patch": "@@ -63,6 +63,7 @@ mod back {\n }\n \n mod metadata {\n+    mod tyencode;\n     mod creader;\n     mod cwriter;\n }"}]}