{"sha": "1984ec5d20b9e9506f391661a17f04ba4f8ec5af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ODRlYzVkMjBiOWU5NTA2ZjM5MTY2MWExN2YwNGJhNGY4ZWM1YWY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-01T20:10:43Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-26T22:39:14Z"}, "message": "Fewer calls to arena.alloc.", "tree": {"sha": "418e7a0316ac8a9e4d66d695ea907bb4ac4fd1c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/418e7a0316ac8a9e4d66d695ea907bb4ac4fd1c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1984ec5d20b9e9506f391661a17f04ba4f8ec5af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1984ec5d20b9e9506f391661a17f04ba4f8ec5af", "html_url": "https://github.com/rust-lang/rust/commit/1984ec5d20b9e9506f391661a17f04ba4f8ec5af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1984ec5d20b9e9506f391661a17f04ba4f8ec5af/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82840353726668c624e46627ac11a1fec18d6d09", "url": "https://api.github.com/repos/rust-lang/rust/commits/82840353726668c624e46627ac11a1fec18d6d09", "html_url": "https://github.com/rust-lang/rust/commit/82840353726668c624e46627ac11a1fec18d6d09"}], "stats": {"total": 259, "additions": 121, "deletions": 138}, "files": [{"sha": "c6e2cf4cc9c929324972c4bf08c8eef0e34b3686", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1984ec5d20b9e9506f391661a17f04ba4f8ec5af/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1984ec5d20b9e9506f391661a17f04ba4f8ec5af/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1984ec5d20b9e9506f391661a17f04ba4f8ec5af", "patch": "@@ -2042,10 +2042,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n         });\n         let ty = ty.map(|ty| -> &'hir hir::Ty { self.arena.alloc(ty.into_inner()) });\n-        let init = l\n-            .init\n-            .as_ref()\n-            .map(|e| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(e)) });\n+        let init = l.init.as_ref().map(|e| -> &'hir hir::Expr<'hir> { self.lower_expr(e) });\n         (\n             hir::Local {\n                 hir_id: self.lower_node_id(l.id),\n@@ -2603,7 +2600,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         for (index, stmt) in b.stmts.iter().enumerate() {\n             if index == b.stmts.len() - 1 {\n                 if let StmtKind::Expr(ref e) = stmt.kind {\n-                    expr = Some(self.arena.alloc(self.lower_expr(e)));\n+                    expr = Some(self.lower_expr(e));\n                 } else {\n                     stmts.extend(self.lower_stmt(stmt));\n                 }\n@@ -2637,7 +2634,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n                 node\n             }\n-            PatKind::Lit(ref e) => hir::PatKind::Lit(self.arena.alloc(self.lower_expr(e))),\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n             PatKind::TupleStruct(ref path, ref pats) => {\n                 let qpath = self.lower_qpath(\n                     p.id,\n@@ -2687,8 +2684,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n             PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n             PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                self.arena.alloc(self.lower_expr(e1)),\n-                self.arena.alloc(self.lower_expr(e2)),\n+                self.lower_expr(e1),\n+                self.lower_expr(e2),\n                 self.lower_range_end(end),\n             ),\n             PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n@@ -2916,8 +2913,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => hir::StmtKind::Expr(self.arena.alloc(self.lower_expr(e))),\n-            StmtKind::Semi(ref e) => hir::StmtKind::Semi(self.arena.alloc(self.lower_expr(e))),\n+            StmtKind::Expr(ref e) => hir::StmtKind::Expr(self.lower_expr(e)),\n+            StmtKind::Semi(ref e) => hir::StmtKind::Semi(self.lower_expr(e)),\n             StmtKind::Mac(..) => panic!(\"shouldn't exist here\"),\n         };\n         smallvec![hir::Stmt { hir_id: self.lower_node_id(s.id), kind, span: s.span }]\n@@ -2975,7 +2972,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n \n-    fn block_expr(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Block<'hir> {\n+    fn block_expr(&mut self, expr: &'hir hir::Expr<'hir>) -> &'hir hir::Block<'hir> {\n         self.block_all(expr.span, &[], Some(expr))\n     }\n \n@@ -2984,21 +2981,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         stmts: &'hir [hir::Stmt<'hir>],\n         expr: Option<&'hir hir::Expr<'hir>>,\n-    ) -> hir::Block<'hir> {\n-        hir::Block {\n+    ) -> &'hir hir::Block<'hir> {\n+        let blk = hir::Block {\n             stmts,\n             expr,\n             hir_id: self.next_id(),\n             rules: hir::DefaultBlock,\n             span,\n             targeted_by_break: false,\n-        }\n+        };\n+        self.arena.alloc(blk)\n     }\n \n     /// Constructs a `true` or `false` literal pattern.\n     fn pat_bool(&mut self, span: Span, val: bool) -> &'hir hir::Pat<'hir> {\n         let expr = self.expr_bool(span, val);\n-        self.pat(span, hir::PatKind::Lit(self.arena.alloc(expr)))\n+        self.pat(span, hir::PatKind::Lit(expr))\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {"}, {"sha": "8061cf432812c5fb5a270f11da6b7920ce8906ed", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 105, "deletions": 120, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/1984ec5d20b9e9506f391661a17f04ba4f8ec5af/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1984ec5d20b9e9506f391661a17f04ba4f8ec5af/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=1984ec5d20b9e9506f391661a17f04ba4f8ec5af", "patch": "@@ -15,23 +15,25 @@ use rustc_error_codes::*;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n-        self.arena.alloc_from_iter(exprs.iter().map(|x| self.lower_expr(x)))\n+        self.arena.alloc_from_iter(exprs.iter().map(|x| self.lower_expr_mut(x)))\n     }\n \n-    pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr<'hir> {\n+    pub(super) fn lower_expr(&mut self, e: &Expr) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.lower_expr_mut(e))\n+    }\n+\n+    pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         let kind = match e.kind {\n-            ExprKind::Box(ref inner) => {\n-                hir::ExprKind::Box(self.arena.alloc(self.lower_expr(inner)))\n-            }\n+            ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n             ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n             ExprKind::Repeat(ref expr, ref count) => {\n-                let expr = self.arena.alloc(self.lower_expr(expr));\n+                let expr = self.lower_expr(expr);\n                 let count = self.lower_anon_const(count);\n                 hir::ExprKind::Repeat(expr, count)\n             }\n             ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n             ExprKind::Call(ref f, ref args) => {\n-                let f = self.arena.alloc(self.lower_expr(f));\n+                let f = self.lower_expr(f);\n                 hir::ExprKind::Call(f, self.lower_exprs(args))\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n@@ -49,28 +51,28 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n-                let lhs = self.arena.alloc(self.lower_expr(lhs));\n-                let rhs = self.arena.alloc(self.lower_expr(rhs));\n+                let lhs = self.lower_expr(lhs);\n+                let rhs = self.lower_expr(rhs);\n                 hir::ExprKind::Binary(binop, lhs, rhs)\n             }\n             ExprKind::Unary(op, ref ohs) => {\n                 let op = self.lower_unop(op);\n-                let ohs = self.arena.alloc(self.lower_expr(ohs));\n+                let ohs = self.lower_expr(ohs);\n                 hir::ExprKind::Unary(op, ohs)\n             }\n             ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.kind.clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n-                let expr = self.arena.alloc(self.lower_expr(expr));\n+                let expr = self.lower_expr(expr);\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                 hir::ExprKind::Cast(expr, self.arena.alloc(ty.into_inner()))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n-                let expr = self.arena.alloc(self.lower_expr(expr));\n+                let expr = self.lower_expr(expr);\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                 hir::ExprKind::Type(expr, self.arena.alloc(ty.into_inner()))\n             }\n             ExprKind::AddrOf(k, m, ref ohs) => {\n-                let ohs = self.arena.alloc(self.lower_expr(ohs));\n+                let ohs = self.lower_expr(ohs);\n                 hir::ExprKind::AddrOf(k, m, ohs)\n             }\n             ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n@@ -89,7 +91,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }),\n             ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n             ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n-                self.arena.alloc(self.lower_expr(expr)),\n+                self.lower_expr(expr),\n                 self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                 hir::MatchSource::Normal,\n             ),\n@@ -126,23 +128,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_block(blk, opt_label.is_some()),\n                 self.lower_label(opt_label),\n             ),\n-            ExprKind::Assign(ref el, ref er, span) => hir::ExprKind::Assign(\n-                self.arena.alloc(self.lower_expr(el)),\n-                self.arena.alloc(self.lower_expr(er)),\n-                span,\n-            ),\n+            ExprKind::Assign(ref el, ref er, span) => {\n+                hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n+            }\n             ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                 self.lower_binop(op),\n-                self.arena.alloc(self.lower_expr(el)),\n-                self.arena.alloc(self.lower_expr(er)),\n+                self.lower_expr(el),\n+                self.lower_expr(er),\n             ),\n-            ExprKind::Field(ref el, ident) => {\n-                hir::ExprKind::Field(self.arena.alloc(self.lower_expr(el)), ident)\n+            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(self.lower_expr(el), ident),\n+            ExprKind::Index(ref el, ref er) => {\n+                hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n             }\n-            ExprKind::Index(ref el, ref er) => hir::ExprKind::Index(\n-                self.arena.alloc(self.lower_expr(el)),\n-                self.arena.alloc(self.lower_expr(er)),\n-            ),\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n                 self.lower_expr_range_closed(e.span, e1, e2)\n             }\n@@ -160,25 +157,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::ExprKind::Path(qpath)\n             }\n             ExprKind::Break(opt_label, ref opt_expr) => {\n-                let opt_expr = opt_expr\n-                    .as_ref()\n-                    .map(|x| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(x)) });\n+                let opt_expr =\n+                    opt_expr.as_ref().map(|x| -> &'hir hir::Expr<'hir> { self.lower_expr(x) });\n                 hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n             }\n             ExprKind::Continue(opt_label) => {\n                 hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n             }\n             ExprKind::Ret(ref e) => {\n-                let e = e\n-                    .as_ref()\n-                    .map(|x| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(x)) });\n+                let e = e.as_ref().map(|x| -> &'hir hir::Expr<'hir> { self.lower_expr(x) });\n                 hir::ExprKind::Ret(e)\n             }\n             ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(asm),\n             ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                let maybe_expr = maybe_expr\n-                    .as_ref()\n-                    .map(|x| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(x)) });\n+                let maybe_expr =\n+                    maybe_expr.as_ref().map(|x| -> &'hir hir::Expr<'hir> { self.lower_expr(x) });\n                 hir::ExprKind::Struct(\n                     self.arena.alloc(self.lower_qpath(\n                         e.id,\n@@ -192,7 +185,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 )\n             }\n             ExprKind::Paren(ref ex) => {\n-                let mut ex = self.lower_expr(ex);\n+                let mut ex = self.lower_expr_mut(ex);\n                 // Include parens in span, but only if it is a super-span.\n                 if e.span.contains(ex.span) {\n                     ex.span = e.span;\n@@ -287,15 +280,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let then_arm = {\n             let pat = self.lower_pat(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pat, self.arena.alloc(expr))\n+            self.arm(pat, expr)\n         };\n         let else_arm = {\n             let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pat, self.arena.alloc(expr))\n+            self.arm(pat, expr)\n         };\n         hir::ExprKind::Match(\n-            self.arena.alloc(scrutinee),\n+            scrutinee,\n             arena_vec![self; then_arm, else_arm],\n             hir::MatchSource::Normal,\n         )\n@@ -316,7 +309,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             None => (self.expr_block_empty(span), false),\n             Some(els) => (self.lower_expr(els), true),\n         };\n-        let else_arm = self.arm(else_pat, self.arena.alloc(else_expr));\n+        let else_arm = self.arm(else_pat, else_expr);\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(then);\n@@ -336,18 +329,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, self.arena.alloc(cond), ThinVec::new());\n+                let cond = self.expr_drop_temps(span_block, cond, ThinVec::new());\n                 let pat = self.pat_bool(span, true);\n                 (pat, cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n         let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n \n-        hir::ExprKind::Match(\n-            self.arena.alloc(scrutinee),\n-            arena_vec![self; then_arm, else_arm],\n-            desugar,\n-        )\n+        hir::ExprKind::Match(scrutinee, arena_vec![self; then_arm, else_arm], desugar)\n     }\n \n     fn lower_expr_while_in_loop_scope(\n@@ -404,7 +393,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, self.arena.alloc(cond), ThinVec::new());\n+                let cond = self.expr_drop_temps(span_block, cond, ThinVec::new());\n                 // `true => <then>`:\n                 let pat = self.pat_bool(span, true);\n                 (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n@@ -415,14 +404,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `match <scrutinee> { ... }`\n         let match_expr = self.expr_match(\n             scrutinee.span,\n-            self.arena.alloc(scrutinee),\n+            scrutinee,\n             arena_vec![self; then_arm, else_arm],\n             desugar,\n         );\n \n         // `[opt_ident]: loop { ... }`\n         hir::ExprKind::Loop(\n-            self.arena.alloc(self.block_expr(self.arena.alloc(match_expr))),\n+            self.block_expr(self.arena.alloc(match_expr)),\n             self.lower_label(opt_label),\n             source,\n         )\n@@ -444,7 +433,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             // Final expression of the block (if present) or `()` with span at the end of block\n             let tail_expr = block.expr.take().map_or_else(\n                 || -> &'hir hir::Expr<'hir> {\n-                    this.arena.alloc(this.expr_unit(this.sess.source_map().end_point(try_span)))\n+                    this.expr_unit(this.sess.source_map().end_point(try_span))\n                 },\n                 |x: &'hir hir::Expr<'hir>| x,\n             );\n@@ -474,7 +463,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let path = &[sym::ops, sym::Try, method];\n         let constructor =\n             self.arena.alloc(self.expr_std_path(method_span, path, None, ThinVec::new()));\n-        self.arena.alloc(self.expr_call(overall_span, constructor, std::slice::from_ref(expr)))\n+        self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n@@ -483,10 +472,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             attrs: self.lower_attrs_arena(&arm.attrs),\n             pat: self.lower_pat(&arm.pat),\n             guard: match arm.guard {\n-                Some(ref x) => Some(hir::Guard::If(self.arena.alloc(self.lower_expr(x)))),\n+                Some(ref x) => Some(hir::Guard::If(self.lower_expr(x))),\n                 _ => None,\n             },\n-            body: self.arena.alloc(self.lower_expr(&arm.body)),\n+            body: self.lower_expr(&arm.body),\n             span: arm.span,\n         }\n     }\n@@ -588,7 +577,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         //     ::std::pin::Pin::new_unchecked(&mut pinned)\n         // })`\n         let poll_expr = {\n-            let pinned = self.arena.alloc(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n+            let pinned = self.expr_ident(span, pinned_ident, pinned_pat_hid);\n             let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n             let pin_ty_id = self.next_id();\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n@@ -601,11 +590,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let new_unchecked =\n                 self.arena.alloc(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n             let unsafe_expr = self.expr_unsafe(new_unchecked);\n-            self.arena.alloc(self.expr_call_std_path(\n+            self.expr_call_std_path(\n                 gen_future_span,\n                 &[sym::future, sym::poll_with_tls_context],\n                 arena_vec![self; unsafe_expr],\n-            ))\n+            )\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n@@ -614,7 +603,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ready_arm = {\n             let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n-            let x_expr = self.arena.alloc(self.expr_ident(span, x_ident, x_pat_hid));\n+            let x_expr = self.expr_ident(span, x_ident, x_pat_hid);\n             let ready_pat = self.pat_std_enum(\n                 span,\n                 &[sym::task, sym::Poll, sym::Ready],\n@@ -631,7 +620,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `::std::task::Poll::Pending => {}`\n         let pending_arm = {\n             let pending_pat = self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Pending], &[]);\n-            let empty_block = self.arena.alloc(self.expr_block_empty(span));\n+            let empty_block = self.expr_block_empty(span);\n             self.arm(pending_pat, empty_block)\n         };\n \n@@ -649,17 +638,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let unit = self.expr_unit(span);\n             let yield_expr = self.expr(\n                 span,\n-                hir::ExprKind::Yield(self.arena.alloc(unit), hir::YieldSource::Await),\n+                hir::ExprKind::Yield(unit, hir::YieldSource::Await),\n                 ThinVec::new(),\n             );\n             self.stmt_expr(span, yield_expr)\n         };\n \n-        let loop_block = self.arena.alloc(self.block_all(\n-            span,\n-            arena_vec![self; inner_match_stmt, yield_stmt],\n-            None,\n-        ));\n+        let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None);\n \n         // loop { .. }\n         let loop_expr = self.arena.alloc(hir::Expr {\n@@ -675,7 +660,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // match <expr> {\n         //     mut pinned => loop { .. }\n         // }\n-        let expr = self.arena.alloc(self.lower_expr(expr));\n+        let expr = self.lower_expr(expr);\n         hir::ExprKind::Match(expr, arena_vec![self; pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n \n@@ -696,7 +681,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             this.current_item = Some(fn_decl_span);\n             let mut generator_kind = None;\n             let body_id = this.lower_fn_body(decl, |this| {\n-                let e = this.lower_expr(body);\n+                let e = this.lower_expr_mut(body);\n                 generator_kind = this.generator_kind;\n                 e\n             });\n@@ -781,7 +766,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     async_ret_ty,\n                     body.span,\n                     hir::AsyncGeneratorKind::Closure,\n-                    |this| this.with_new_scopes(|this| this.lower_expr(body)),\n+                    |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n                 );\n                 this.expr(fn_decl_span, async_body, ThinVec::new())\n             });\n@@ -792,8 +777,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n     fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n         let id = self.next_id();\n-        let e1 = self.lower_expr(e1);\n-        let e2 = self.lower_expr(e2);\n+        let e1 = self.lower_expr_mut(e1);\n+        let e2 = self.lower_expr_mut(e2);\n         self.expr_call_std_assoc_fn(\n             id,\n             span,\n@@ -826,7 +811,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let fields = self.arena.alloc_from_iter(\n             e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e))).map(|(s, e)| {\n-                let expr = self.arena.alloc(self.lower_expr(&e));\n+                let expr = self.lower_expr(&e);\n                 let ident = Ident::new(Symbol::intern(s), e.span);\n                 self.field(ident, expr, e.span)\n             }),\n@@ -959,12 +944,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n         let hir_asm = hir::InlineAsm {\n             inner,\n-            inputs_exprs: self\n-                .arena\n-                .alloc_from_iter(asm.inputs.iter().map(|&(_, ref input)| self.lower_expr(input))),\n+            inputs_exprs: self.arena.alloc_from_iter(\n+                asm.inputs.iter().map(|&(_, ref input)| self.lower_expr_mut(input)),\n+            ),\n             outputs_exprs: self\n                 .arena\n-                .alloc_from_iter(asm.outputs.iter().map(|out| self.lower_expr(&out.expr))),\n+                .alloc_from_iter(asm.outputs.iter().map(|out| self.lower_expr_mut(&out.expr))),\n         };\n         hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n     }\n@@ -973,7 +958,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::Field {\n             hir_id: self.next_id(),\n             ident: f.ident,\n-            expr: self.arena.alloc(self.lower_expr(&f.expr)),\n+            expr: self.lower_expr(&f.expr),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n         }\n@@ -992,7 +977,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let expr =\n             opt_expr.as_ref().map(|x| self.lower_expr(x)).unwrap_or_else(|| self.expr_unit(span));\n \n-        hir::ExprKind::Yield(self.arena.alloc(expr), hir::YieldSource::Yield)\n+        hir::ExprKind::Yield(expr, hir::YieldSource::Yield)\n     }\n \n     /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n@@ -1023,7 +1008,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         opt_label: Option<Label>,\n     ) -> hir::Expr<'hir> {\n         // expand <head>\n-        let mut head = self.lower_expr(head);\n+        let mut head = self.lower_expr_mut(head);\n         let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n         head.span = desugared_span;\n \n@@ -1040,8 +1025,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let pat_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n-            let val_expr = self.arena.alloc(self.expr_ident(pat.span, val_ident, val_pat_hid));\n-            let next_expr = self.arena.alloc(self.expr_ident(pat.span, next_ident, next_pat_hid));\n+            let val_expr = self.expr_ident(pat.span, val_ident, val_pat_hid);\n+            let next_expr = self.expr_ident(pat.span, next_ident, next_pat_hid);\n             let assign = self.arena.alloc(self.expr(\n                 pat.span,\n                 hir::ExprKind::Assign(next_expr, val_expr, pat.span),\n@@ -1065,21 +1050,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n-            let iter = self.arena.alloc(self.expr_ident(desugared_span, iter, iter_pat_nid));\n+            let iter = self.expr_ident(desugared_span, iter, iter_pat_nid);\n             let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n             let next_path = &[sym::iter, sym::Iterator, sym::next];\n-            let next_expr = self.arena.alloc(self.expr_call_std_path(\n-                desugared_span,\n-                next_path,\n-                arena_vec![self; ref_mut_iter],\n-            ));\n+            let next_expr =\n+                self.expr_call_std_path(desugared_span, next_path, arena_vec![self; ref_mut_iter]);\n             let arms = arena_vec![self; pat_arm, break_arm];\n \n             self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n         };\n         let match_stmt = self.stmt_expr(desugared_span, match_expr);\n \n-        let next_expr = self.arena.alloc(self.expr_ident(desugared_span, next_ident, next_pat_hid));\n+        let next_expr = self.expr_ident(desugared_span, next_ident, next_pat_hid);\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n@@ -1104,11 +1086,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let body_expr = self.expr_block(body_block, ThinVec::new());\n         let body_stmt = self.stmt_expr(body.span, body_expr);\n \n-        let loop_block = self.arena.alloc(self.block_all(\n+        let loop_block = self.block_all(\n             e.span,\n             arena_vec![self; next_let, match_stmt, pat_let, body_stmt],\n             None,\n-        ));\n+        );\n \n         // `[opt_ident]: loop { ... }`\n         let kind =\n@@ -1126,11 +1108,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.arena.alloc(self.expr_call_std_path(\n-                desugared_span,\n-                into_iter_path,\n-                arena_vec![self; head],\n-            ))\n+            self.expr_call_std_path(desugared_span, into_iter_path, arena_vec![self; head])\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match(\n@@ -1146,7 +1124,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps(desugared_span, match_expr, e.attrs.clone())\n+        self.expr_drop_temps_mut(desugared_span, match_expr, e.attrs.clone())\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:\n@@ -1176,14 +1154,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `Try::into_result(<expr>)`\n         let scrutinee = {\n             // expand <expr>\n-            let sub_expr = self.lower_expr(sub_expr);\n+            let sub_expr = self.lower_expr_mut(sub_expr);\n \n             let path = &[sym::ops, sym::Try, sym::into_result];\n-            self.arena.alloc(self.expr_call_std_path(\n-                unstable_span,\n-                path,\n-                arena_vec![self; sub_expr],\n-            ))\n+            self.expr_call_std_path(unstable_span, path, arena_vec![self; sub_expr])\n         };\n \n         // `#[allow(unreachable_code)]`\n@@ -1220,12 +1194,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n             let from_expr = {\n                 let from_path = &[sym::convert, sym::From, sym::from];\n-                let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n-                self.arena.alloc(self.expr_call_std_path(\n-                    try_span,\n-                    from_path,\n-                    arena_vec![self; err_expr],\n-                ))\n+                let err_expr = self.expr_ident_mut(try_span, err_ident, err_local_nid);\n+                self.expr_call_std_path(try_span, from_path, arena_vec![self; err_expr])\n             };\n             let from_err_expr =\n                 self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n@@ -1265,9 +1235,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // =========================================================================\n \n     /// Constructs a `true` or `false` literal expression.\n-    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> hir::Expr<'hir> {\n+    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> &'hir hir::Expr<'hir> {\n         let lit = Spanned { span, node: LitKind::Bool(val) };\n-        self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new())\n+        self.arena.alloc(self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new()))\n     }\n \n     /// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.\n@@ -1281,6 +1251,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         expr: &'hir hir::Expr<'hir>,\n         attrs: AttrVec,\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_drop_temps_mut(span, expr, attrs))\n+    }\n+\n+    pub(super) fn expr_drop_temps_mut(\n+        &mut self,\n+        span: Span,\n+        expr: &'hir hir::Expr<'hir>,\n+        attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n     }\n@@ -1308,21 +1287,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         )\n     }\n \n-    fn expr_unit(&mut self, sp: Span) -> hir::Expr<'hir> {\n-        self.expr_tuple(sp, &[])\n-    }\n-\n-    fn expr_tuple(&mut self, sp: Span, exprs: &'hir [hir::Expr<'hir>]) -> hir::Expr<'hir> {\n-        self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new())\n+    fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), ThinVec::new()))\n     }\n \n     fn expr_call(\n         &mut self,\n         span: Span,\n         e: &'hir hir::Expr<'hir>,\n         args: &'hir [hir::Expr<'hir>],\n-    ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new()))\n     }\n \n     // Note: associated functions must use `expr_call_std_path`.\n@@ -1331,7 +1306,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         path_components: &[Symbol],\n         args: &'hir [hir::Expr<'hir>],\n-    ) -> hir::Expr<'hir> {\n+    ) -> &'hir hir::Expr<'hir> {\n         let path =\n             self.arena.alloc(self.expr_std_path(span, path_components, None, ThinVec::new()));\n         self.expr_call(span, path, args)\n@@ -1379,6 +1354,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         sp: Span,\n         ident: Ident,\n         binding: hir::HirId,\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_ident_mut(sp, ident, binding))\n+    }\n+\n+    pub(super) fn expr_ident_mut(\n+        &mut self,\n+        sp: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n     ) -> hir::Expr<'hir> {\n         self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n     }\n@@ -1422,9 +1406,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         )\n     }\n \n-    fn expr_block_empty(&mut self, span: Span) -> hir::Expr<'hir> {\n+    fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n         let blk = self.block_all(span, &[], None);\n-        self.expr_block(self.arena.alloc(blk), ThinVec::new())\n+        let expr = self.expr_block(blk, ThinVec::new());\n+        self.arena.alloc(expr)\n     }\n \n     pub(super) fn expr_block("}, {"sha": "ff7a67fb0ba7b43d878f58b4cff051f95a21b26c", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1984ec5d20b9e9506f391661a17f04ba4f8ec5af/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1984ec5d20b9e9506f391661a17f04ba4f8ec5af/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=1984ec5d20b9e9506f391661a17f04ba4f8ec5af", "patch": "@@ -1046,7 +1046,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (\n                 &[],\n                 match expr {\n-                    Some(expr) => this.lower_expr(expr),\n+                    Some(expr) => this.lower_expr_mut(expr),\n                     None => this.expr_err(span),\n                 },\n             )\n@@ -1230,10 +1230,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let body = this.block_all(\n                         desugared_span,\n                         this.arena.alloc_from_iter(statements),\n-                        Some(this.arena.alloc(user_body)),\n+                        Some(user_body),\n                     );\n \n-                    this.expr_block(this.arena.alloc(body), AttrVec::new())\n+                    this.expr_block(body, AttrVec::new())\n                 },\n             );\n "}]}