{"sha": "9552b9cfd22b9378bb2a86f8f0738f92c1982d20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NTJiOWNmZDIyYjkzNzhiYjJhODZmOGYwNzM4ZjkyYzE5ODJkMjA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-12-10T00:29:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-12-12T20:50:35Z"}, "message": "rustc_metadata: Refactor away `ExternCrateInfo`", "tree": {"sha": "c6ebf71f49e4bd3939f02d4cb2230cf2e72594c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6ebf71f49e4bd3939f02d4cb2230cf2e72594c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9552b9cfd22b9378bb2a86f8f0738f92c1982d20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9552b9cfd22b9378bb2a86f8f0738f92c1982d20", "html_url": "https://github.com/rust-lang/rust/commit/9552b9cfd22b9378bb2a86f8f0738f92c1982d20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9552b9cfd22b9378bb2a86f8f0738f92c1982d20/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "707d0708158dabd9b0a12af21a4b51bf1713cb9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/707d0708158dabd9b0a12af21a4b51bf1713cb9e", "html_url": "https://github.com/rust-lang/rust/commit/707d0708158dabd9b0a12af21a4b51bf1713cb9e"}], "stats": {"total": 80, "additions": 26, "deletions": 54}, "files": [{"sha": "9ca7f87f79d89fd1b2faf511658e191d0221a47b", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 26, "deletions": 54, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9552b9cfd22b9378bb2a86f8f0738f92c1982d20/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9552b9cfd22b9378bb2a86f8f0738f92c1982d20/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9552b9cfd22b9378bb2a86f8f0738f92c1982d20", "patch": "@@ -71,14 +71,6 @@ fn dump_crates(cstore: &CStore) {\n     });\n }\n \n-#[derive(Debug)]\n-struct ExternCrateInfo {\n-    ident: Symbol,\n-    name: Symbol,\n-    id: ast::NodeId,\n-    dep_kind: DepKind,\n-}\n-\n // Extra info about a crate loaded for plugins or exported macros.\n struct ExtensionCrate {\n     metadata: PMDSource,\n@@ -117,34 +109,6 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn extract_crate_info(&self, i: &ast::Item) -> Option<ExternCrateInfo> {\n-        match i.node {\n-            ast::ItemKind::ExternCrate(ref path_opt) => {\n-                debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n-                       i.ident, path_opt);\n-                let name = match *path_opt {\n-                    Some(name) => {\n-                        validate_crate_name(Some(self.sess), &name.as_str(),\n-                                            Some(i.span));\n-                        name\n-                    }\n-                    None => i.ident.name,\n-                };\n-                Some(ExternCrateInfo {\n-                    ident: i.ident.name,\n-                    name,\n-                    id: i.id,\n-                    dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n-                        DepKind::UnexportedMacrosOnly\n-                    } else {\n-                        DepKind::Explicit\n-                    },\n-                })\n-            }\n-            _ => None\n-        }\n-    }\n-\n     fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<CrateNum> {\n         let mut ret = None;\n@@ -478,17 +442,17 @@ impl<'a> CrateLoader<'a> {\n         })).collect()\n     }\n \n-    fn read_extension_crate(&mut self, span: Span, info: &ExternCrateInfo) -> ExtensionCrate {\n-        info!(\"read extension crate {} `extern crate {} as {}` dep_kind={:?}\",\n-              info.id, info.name, info.ident, info.dep_kind);\n+    fn read_extension_crate(&mut self, span: Span, orig_name: Symbol, rename: Symbol)\n+                            -> ExtensionCrate {\n+        info!(\"read extension crate `extern crate {} as {}`\", orig_name, rename);\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut target_only = false;\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n             span,\n-            ident: info.ident,\n-            crate_name: info.name,\n+            ident: orig_name,\n+            crate_name: rename,\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n@@ -625,12 +589,8 @@ impl<'a> CrateLoader<'a> {\n                                  span: Span,\n                                  name: &str)\n                                  -> Option<(PathBuf, CrateDisambiguator, DefIndex)> {\n-        let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n-             name: Symbol::intern(name),\n-             ident: Symbol::intern(name),\n-             id: ast::DUMMY_NODE_ID,\n-             dep_kind: DepKind::UnexportedMacrosOnly,\n-        });\n+        let name = Symbol::intern(name);\n+        let ekrate = self.read_extension_crate(span, name, name);\n \n         if ekrate.target_only {\n             // Need to abort before syntax expansion.\n@@ -1098,19 +1058,31 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n-            ast::ItemKind::ExternCrate(_) => {\n-                let info = self.extract_crate_info(item).unwrap();\n+            ast::ItemKind::ExternCrate(rename) => {\n+                debug!(\"resolving extern crate stmt. ident: {} rename: {:?}\", item.ident, rename);\n+                let rename = match rename {\n+                    Some(rename) => {\n+                        validate_crate_name(Some(self.sess), &rename.as_str(), Some(item.span));\n+                        rename\n+                    }\n+                    None => item.ident.name,\n+                };\n+                let dep_kind = if attr::contains_name(&item.attrs, \"no_link\") {\n+                    DepKind::UnexportedMacrosOnly\n+                } else {\n+                    DepKind::Explicit\n+                };\n+\n                 let (cnum, ..) = self.resolve_crate(\n-                    &None, info.ident, info.name, None, item.span, PathKind::Crate, info.dep_kind,\n+                    &None, item.ident.name, rename, None, item.span, PathKind::Crate, dep_kind,\n                 );\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n-                let len = definitions.def_path(def_id.index).data.len();\n+                let path_len = definitions.def_path(def_id.index).data.len();\n \n-                let extern_crate =\n-                    ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n+                let extern_crate = ExternCrate { def_id, span: item.span, direct: true, path_len };\n                 self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n-                self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+                self.cstore.add_extern_mod_stmt_cnum(item.id, cnum);\n             }\n             _ => {}\n         }"}]}