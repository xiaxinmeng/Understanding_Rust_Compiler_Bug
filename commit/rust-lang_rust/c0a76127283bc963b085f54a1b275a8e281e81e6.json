{"sha": "c0a76127283bc963b085f54a1b275a8e281e81e6", "node_id": "C_kwDOAAsO6NoAKGMwYTc2MTI3MjgzYmM5NjNiMDg1ZjU0YTFiMjc1YThlMjgxZTgxZTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-02T10:32:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-02T10:32:08Z"}, "message": "Auto merge of #103690 - GuillaumeGomez:visibility-on-demand, r=notriddle\n\nMake rustdoc Item::visibility computed on-demand\n\nThis is a take-over of https://github.com/rust-lang/rust/pull/91408.\n\nHelps with https://github.com/rust-lang/rust/issues/90852 (needs to use `ty::Visibility` directly too).\n\ncc `@camelid`\nr? `@notriddle`", "tree": {"sha": "aeef2abb571803d17c15c80f84cb6b2d44e6e1c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeef2abb571803d17c15c80f84cb6b2d44e6e1c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0a76127283bc963b085f54a1b275a8e281e81e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a76127283bc963b085f54a1b275a8e281e81e6", "html_url": "https://github.com/rust-lang/rust/commit/c0a76127283bc963b085f54a1b275a8e281e81e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0a76127283bc963b085f54a1b275a8e281e81e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "822f8c22f540b12f296d844ad5bf39aaa47bfeb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/822f8c22f540b12f296d844ad5bf39aaa47bfeb4", "html_url": "https://github.com/rust-lang/rust/commit/822f8c22f540b12f296d844ad5bf39aaa47bfeb4"}, {"sha": "5515e2c2a106c934351382c713560c026228e232", "url": "https://api.github.com/repos/rust-lang/rust/commits/5515e2c2a106c934351382c713560c026228e232", "html_url": "https://github.com/rust-lang/rust/commit/5515e2c2a106c934351382c713560c026228e232"}], "stats": {"total": 289, "additions": 144, "deletions": 145}, "files": [{"sha": "00bdbe41ee419195ad71dc7d9e902224580d92f6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -118,7 +118,6 @@ where\n         Some(Item {\n             name: None,\n             attrs: Default::default(),\n-            visibility: Inherited,\n             item_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n             kind: Box::new(ImplItem(Box::new(Impl {\n                 unsafety: hir::Unsafety::Normal,\n@@ -130,6 +129,7 @@ where\n                 kind: ImplKind::Auto,\n             }))),\n             cfg: None,\n+            inline_stmt_id: None,\n         })\n     }\n "}, {"sha": "d80637055829d80df93fd24be8dbeefc7725b090", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -97,7 +97,6 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                 impls.push(Item {\n                     name: None,\n                     attrs: Default::default(),\n-                    visibility: Inherited,\n                     item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: Box::new(ImplItem(Box::new(Impl {\n                         unsafety: hir::Unsafety::Normal,\n@@ -128,6 +127,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         ))),\n                     }))),\n                     cfg: None,\n+                    inline_stmt_id: None,\n                 });\n             }\n         }"}, {"sha": "ec93eefb7d1ee41fced88af72191b6b347e9773b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -20,7 +20,7 @@ use crate::clean::{\n     self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_assoc_item,\n     clean_middle_field, clean_middle_ty, clean_trait_ref_with_bindings, clean_ty,\n     clean_ty_generics, clean_variant_def, clean_visibility, utils, Attributes, AttributesExt,\n-    ImplKind, ItemId, Type, Visibility,\n+    ImplKind, ItemId, Type,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -152,18 +152,10 @@ pub(crate) fn try_inline(\n \n     let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs);\n     cx.inlined.insert(did.into());\n-    let mut item = clean::Item::from_def_id_and_attrs_and_parts(\n-        did,\n-        Some(name),\n-        kind,\n-        Box::new(attrs),\n-        cx,\n-        cfg,\n-    );\n-    if let Some(import_def_id) = import_def_id {\n-        // The visibility needs to reflect the one from the reexport and not from the \"source\" DefId.\n-        item.visibility = clean_visibility(cx.tcx.visibility(import_def_id));\n-    }\n+    let mut item =\n+        clean::Item::from_def_id_and_attrs_and_parts(did, Some(name), kind, Box::new(attrs), cfg);\n+    // The visibility needs to reflect the one from the reexport and not from the \"source\" DefId.\n+    item.inline_stmt_id = import_def_id;\n     ret.push(item);\n     Some(ret)\n }\n@@ -239,13 +231,7 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n         .tcx\n         .associated_items(did)\n         .in_definition_order()\n-        .map(|item| {\n-            // When building an external trait, the cleaned trait will have all items public,\n-            // which causes methods to have a `pub` prefix, which is invalid since items in traits\n-            // can not have a visibility prefix. Thus we override the visibility here manually.\n-            // See https://github.com/rust-lang/rust/issues/81274\n-            clean::Item { visibility: Visibility::Inherited, ..clean_middle_assoc_item(item, cx) }\n-        })\n+        .map(|item| clean_middle_assoc_item(item, cx))\n         .collect();\n \n     let predicates = cx.tcx.predicates_of(did);\n@@ -559,7 +545,6 @@ pub(crate) fn build_impl(\n             },\n         })),\n         Box::new(merged_attrs),\n-        cx,\n         cfg,\n     ));\n }\n@@ -607,7 +592,6 @@ fn build_module_items(\n                     name: None,\n                     attrs: Box::new(clean::Attributes::default()),\n                     item_id: ItemId::Primitive(prim_ty, did.krate),\n-                    visibility: clean::Public,\n                     kind: Box::new(clean::ImportItem(clean::Import::new_simple(\n                         item.ident.name,\n                         clean::ImportSource {\n@@ -626,6 +610,7 @@ fn build_module_items(\n                         true,\n                     ))),\n                     cfg: None,\n+                    inline_stmt_id: None,\n                 });\n             } else if let Some(i) = try_inline(cx, did, None, res, item.ident.name, None, visited) {\n                 items.extend(i)"}, {"sha": "1ce0d1e4ffd02c3bcf104d68971a9bac83f32153", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 55, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -1083,10 +1083,7 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n                 TyAssocTypeItem(Box::new(generics), bounds)\n             }\n         };\n-        let what_rustc_thinks =\n-            Item::from_def_id_and_parts(local_did, Some(trait_item.ident.name), inner, cx);\n-        // Trait items always inherit the trait's visibility -- we don't want to show `pub`.\n-        Item { visibility: Inherited, ..what_rustc_thinks }\n+        Item::from_def_id_and_parts(local_did, Some(trait_item.ident.name), inner, cx)\n     })\n }\n \n@@ -1117,18 +1114,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n             }\n         };\n \n-        let mut what_rustc_thinks =\n-            Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx);\n-\n-        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.owner_id.def_id));\n-\n-        // Trait impl items always inherit the impl's visibility --\n-        // we don't want to show `pub`.\n-        if impl_ref.is_some() {\n-            what_rustc_thinks.visibility = Inherited;\n-        }\n-\n-        what_rustc_thinks\n+        Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx)\n     })\n }\n \n@@ -1340,18 +1326,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n         }\n     };\n \n-    let mut what_rustc_thinks =\n-        Item::from_def_id_and_parts(assoc_item.def_id, Some(assoc_item.name), kind, cx);\n-\n-    let impl_ref = tcx.impl_trait_ref(tcx.parent(assoc_item.def_id));\n-\n-    // Trait impl items always inherit the impl's visibility --\n-    // we don't want to show `pub`.\n-    if impl_ref.is_some() {\n-        what_rustc_thinks.visibility = Visibility::Inherited;\n-    }\n-\n-    what_rustc_thinks\n+    Item::from_def_id_and_parts(assoc_item.def_id, Some(assoc_item.name), kind, cx)\n }\n \n fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n@@ -1821,23 +1796,7 @@ pub(crate) fn clean_field_with_def_id(\n     ty: Type,\n     cx: &mut DocContext<'_>,\n ) -> Item {\n-    let what_rustc_thinks =\n-        Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx);\n-    if is_field_vis_inherited(cx.tcx, def_id) {\n-        // Variant fields inherit their enum's visibility.\n-        Item { visibility: Visibility::Inherited, ..what_rustc_thinks }\n-    } else {\n-        what_rustc_thinks\n-    }\n-}\n-\n-fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let parent = tcx.parent(def_id);\n-    match tcx.def_kind(parent) {\n-        DefKind::Struct | DefKind::Union => false,\n-        DefKind::Variant => true,\n-        parent_kind => panic!(\"unexpected parent kind: {:?}\", parent_kind),\n-    }\n+    Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx)\n }\n \n pub(crate) fn clean_visibility(vis: ty::Visibility<DefId>) -> Visibility {\n@@ -1861,10 +1820,7 @@ pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocCont\n             fields: variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n         }),\n     };\n-    let what_rustc_thinks =\n-        Item::from_def_id_and_parts(variant.def_id, Some(variant.name), VariantItem(kind), cx);\n-    // don't show `pub` for variants, which always inherit visibility\n-    Item { visibility: Inherited, ..what_rustc_thinks }\n+    Item::from_def_id_and_parts(variant.def_id, Some(variant.name), VariantItem(kind), cx)\n }\n \n fn clean_variant_data<'tcx>(\n@@ -2038,10 +1994,7 @@ fn clean_maybe_renamed_item<'tcx>(\n \n fn clean_variant<'tcx>(variant: &hir::Variant<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n     let kind = VariantItem(clean_variant_data(&variant.data, &variant.disr_expr, cx));\n-    let what_rustc_thinks =\n-        Item::from_hir_id_and_parts(variant.id, Some(variant.ident.name), kind, cx);\n-    // don't show `pub` for variants, which are always public\n-    Item { visibility: Inherited, ..what_rustc_thinks }\n+    Item::from_hir_id_and_parts(variant.id, Some(variant.ident.name), kind, cx)\n }\n \n fn clean_impl<'tcx>(\n@@ -2114,6 +2067,7 @@ fn clean_extern_crate<'tcx>(\n                 }\n         });\n \n+    let krate_owner_def_id = krate.owner_id.to_def_id();\n     if please_inline {\n         let mut visited = FxHashSet::default();\n \n@@ -2122,7 +2076,7 @@ fn clean_extern_crate<'tcx>(\n         if let Some(items) = inline::try_inline(\n             cx,\n             cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n-            Some(krate.owner_id.to_def_id()),\n+            Some(krate_owner_def_id),\n             res,\n             name,\n             Some(attrs),\n@@ -2137,9 +2091,9 @@ fn clean_extern_crate<'tcx>(\n         name: Some(name),\n         attrs: Box::new(Attributes::from_ast(attrs)),\n         item_id: crate_def_id.into(),\n-        visibility: clean_visibility(ty_vis),\n         kind: Box::new(ExternCrateItem { src: orig_name }),\n         cfg: attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),\n+        inline_stmt_id: Some(krate_owner_def_id),\n     }]\n }\n "}, {"sha": "439311f0640295084a72103806b9e791b678de3f", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 66, "deletions": 18, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -24,7 +24,7 @@ use rustc_hir::{BodyId, Mutability};\n use rustc_hir_analysis::check::intrinsic::intrinsic_operation_unsafety;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n@@ -348,12 +348,12 @@ pub(crate) struct Item {\n     /// Optional because not every item has a name, e.g. impls.\n     pub(crate) name: Option<Symbol>,\n     pub(crate) attrs: Box<Attributes>,\n-    pub(crate) visibility: Visibility,\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n     pub(crate) kind: Box<ItemKind>,\n     pub(crate) item_id: ItemId,\n-\n+    /// This is the `DefId` of the `use` statement if the item was inlined.\n+    pub(crate) inline_stmt_id: Option<DefId>,\n     pub(crate) cfg: Option<Arc<Cfg>>,\n }\n \n@@ -364,9 +364,7 @@ impl fmt::Debug for Item {\n         let alternate = f.alternate();\n         // hand-picked fields that don't bloat the logs too much\n         let mut fmt = f.debug_struct(\"Item\");\n-        fmt.field(\"name\", &self.name)\n-            .field(\"visibility\", &self.visibility)\n-            .field(\"item_id\", &self.item_id);\n+        fmt.field(\"name\", &self.name).field(\"item_id\", &self.item_id);\n         // allow printing the full item if someone really wants to\n         if alternate {\n             fmt.field(\"attrs\", &self.attrs).field(\"kind\", &self.kind).field(\"cfg\", &self.cfg);\n@@ -388,6 +386,15 @@ pub(crate) fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n     ))\n }\n \n+fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let parent = tcx.parent(def_id);\n+    match tcx.def_kind(parent) {\n+        DefKind::Struct | DefKind::Union => false,\n+        DefKind::Variant => true,\n+        parent_kind => panic!(\"unexpected parent kind: {:?}\", parent_kind),\n+    }\n+}\n+\n impl Item {\n     pub(crate) fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n@@ -462,7 +469,6 @@ impl Item {\n             name,\n             kind,\n             Box::new(Attributes::from_ast(ast_attrs)),\n-            cx,\n             ast_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),\n         )\n     }\n@@ -472,21 +478,18 @@ impl Item {\n         name: Option<Symbol>,\n         kind: ItemKind,\n         attrs: Box<Attributes>,\n-        cx: &mut DocContext<'_>,\n         cfg: Option<Arc<Cfg>>,\n     ) -> Item {\n         trace!(\"name={:?}, def_id={:?} cfg={:?}\", name, def_id, cfg);\n \n-        // Primitives and Keywords are written in the source code as private modules.\n-        // The modules need to be private so that nobody actually uses them, but the\n-        // keywords and primitives that they are documenting are public.\n-        let visibility = if matches!(&kind, ItemKind::KeywordItem | ItemKind::PrimitiveItem(..)) {\n-            Visibility::Public\n-        } else {\n-            clean_visibility(cx.tcx.visibility(def_id))\n-        };\n-\n-        Item { item_id: def_id.into(), kind: Box::new(kind), name, attrs, visibility, cfg }\n+        Item {\n+            item_id: def_id.into(),\n+            kind: Box::new(kind),\n+            name,\n+            attrs,\n+            cfg,\n+            inline_stmt_id: None,\n+        }\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n@@ -702,6 +705,51 @@ impl Item {\n         };\n         Some(header)\n     }\n+\n+    pub(crate) fn visibility(&self, tcx: TyCtxt<'_>) -> Visibility {\n+        let def_id = match self.item_id {\n+            // Anything but DefId *shouldn't* matter, but return a reasonable value anyway.\n+            ItemId::Auto { .. } | ItemId::Blanket { .. } => return Visibility::Inherited,\n+            // Primitives and Keywords are written in the source code as private modules.\n+            // The modules need to be private so that nobody actually uses them, but the\n+            // keywords and primitives that they are documenting are public.\n+            ItemId::Primitive(..) => return Visibility::Public,\n+            ItemId::DefId(def_id) => def_id,\n+        };\n+\n+        match *self.kind {\n+            // Explication on `ItemId::Primitive` just above.\n+            ItemKind::KeywordItem | ItemKind::PrimitiveItem(_) => return Visibility::Public,\n+            // Variant fields inherit their enum's visibility.\n+            StructFieldItem(..) if is_field_vis_inherited(tcx, def_id) => {\n+                return Visibility::Inherited;\n+            }\n+            // Variants always inherit visibility\n+            VariantItem(..) => return Visibility::Inherited,\n+            // Trait items inherit the trait's visibility\n+            AssocConstItem(..) | TyAssocConstItem(..) | AssocTypeItem(..) | TyAssocTypeItem(..)\n+            | TyMethodItem(..) | MethodItem(..) => {\n+                let assoc_item = tcx.associated_item(def_id);\n+                let is_trait_item = match assoc_item.container {\n+                    ty::TraitContainer => true,\n+                    ty::ImplContainer => {\n+                        // Trait impl items always inherit the impl's visibility --\n+                        // we don't want to show `pub`.\n+                        tcx.impl_trait_ref(tcx.parent(assoc_item.def_id)).is_some()\n+                    }\n+                };\n+                if is_trait_item {\n+                    return Visibility::Inherited;\n+                }\n+            }\n+            _ => {}\n+        }\n+        let def_id = match self.inline_stmt_id {\n+            Some(inlined) => inlined,\n+            None => def_id,\n+        };\n+        clean_visibility(tcx.visibility(def_id))\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "adf501a0240316b25848b4f2addf86b2063ac3be", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -747,11 +747,12 @@ fn assoc_const(\n     extra: &str,\n     cx: &Context<'_>,\n ) {\n+    let tcx = cx.tcx();\n     write!(\n         w,\n         \"{extra}{vis}const <a{href} class=\\\"constant\\\">{name}</a>: {ty}\",\n         extra = extra,\n-        vis = it.visibility.print_with_space(it.item_id, cx),\n+        vis = it.visibility(tcx).print_with_space(it.item_id, cx),\n         href = assoc_href_attr(it, link, cx),\n         name = it.name.as_ref().unwrap(),\n         ty = ty.print(cx),\n@@ -764,7 +765,7 @@ fn assoc_const(\n         //        This hurts readability in this context especially when more complex expressions\n         //        are involved and it doesn't add much of value.\n         //        Find a way to print constants here without all that jazz.\n-        write!(w, \"{}\", Escape(&default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx()))));\n+        write!(w, \"{}\", Escape(&default.value(tcx).unwrap_or_else(|| default.expr(tcx))));\n     }\n }\n \n@@ -805,14 +806,15 @@ fn assoc_method(\n     cx: &Context<'_>,\n     render_mode: RenderMode,\n ) {\n-    let header = meth.fn_header(cx.tcx()).expect(\"Trying to get header from a non-function item\");\n+    let tcx = cx.tcx();\n+    let header = meth.fn_header(tcx).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n-    let vis = meth.visibility.print_with_space(meth.item_id, cx).to_string();\n+    let vis = meth.visibility(tcx).print_with_space(meth.item_id, cx).to_string();\n     // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n     // this condition.\n     let constness = match render_mode {\n         RenderMode::Normal => {\n-            print_constness_with_space(&header.constness, meth.const_stability(cx.tcx()))\n+            print_constness_with_space(&header.constness, meth.const_stability(tcx))\n         }\n         RenderMode::ForDeref { .. } => \"\",\n     };"}, {"sha": "13df08280b5a852bc36a1c5fe97bb39278d50a2e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -318,6 +318,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n             );\n         }\n \n+        let tcx = cx.tcx();\n         match *myitem.kind {\n             clean::ExternCrateItem { ref src } => {\n                 use crate::html::format::anchor;\n@@ -327,14 +328,14 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                     Some(src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        myitem.visibility(tcx).print_with_space(myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), src, cx),\n                         myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        myitem.visibility(tcx).print_with_space(myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n                 }\n@@ -384,7 +385,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                      </div>\\\n                      {stab_tags_before}{stab_tags}{stab_tags_after}\",\n                     stab = stab.unwrap_or_default(),\n-                    vis = myitem.visibility.print_with_space(myitem.item_id, cx),\n+                    vis = myitem.visibility(tcx).print_with_space(myitem.item_id, cx),\n                     imp = import.print(cx),\n                 );\n                 w.write_str(ITEM_TABLE_ROW_CLOSE);\n@@ -408,7 +409,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 let stab = myitem.stability_class(cx.tcx());\n                 let add = if stab.is_some() { \" \" } else { \"\" };\n \n-                let visibility_emoji = match myitem.visibility {\n+                let visibility_emoji = match myitem.visibility(tcx) {\n                     clean::Visibility::Restricted(_) => {\n                         \"<span title=\\\"Restricted Visibility\\\">&nbsp;\ud83d\udd12</span> \"\n                     }\n@@ -496,12 +497,13 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n }\n \n fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &clean::Function) {\n-    let header = it.fn_header(cx.tcx()).expect(\"printing a function which isn't a function\");\n-    let constness = print_constness_with_space(&header.constness, it.const_stability(cx.tcx()));\n+    let tcx = cx.tcx();\n+    let header = it.fn_header(tcx).expect(\"printing a function which isn't a function\");\n+    let constness = print_constness_with_space(&header.constness, it.const_stability(tcx));\n     let unsafety = header.unsafety.print_with_space();\n     let abi = print_abi_with_space(header.abi).to_string();\n     let asyncness = header.asyncness.print_with_space();\n-    let visibility = it.visibility.print_with_space(it.item_id, cx).to_string();\n+    let visibility = it.visibility(tcx).print_with_space(it.item_id, cx).to_string();\n     let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n@@ -539,6 +541,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n }\n \n fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Trait) {\n+    let tcx = cx.tcx();\n     let bounds = bounds(&t.bounds, false, cx);\n     let required_types = t.items.iter().filter(|m| m.is_ty_associated_type()).collect::<Vec<_>>();\n     let provided_types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n@@ -549,8 +552,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     let count_types = required_types.len() + provided_types.len();\n     let count_consts = required_consts.len() + provided_consts.len();\n     let count_methods = required_methods.len() + provided_methods.len();\n-    let must_implement_one_of_functions =\n-        cx.tcx().trait_def(t.def_id).must_implement_one_of.clone();\n+    let must_implement_one_of_functions = tcx.trait_def(t.def_id).must_implement_one_of.clone();\n \n     // Output the trait definition\n     wrap_into_item_decl(w, |w| {\n@@ -559,9 +561,9 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             write!(\n                 w,\n                 \"{}{}{}trait {}{}{}\",\n-                it.visibility.print_with_space(it.item_id, cx),\n-                t.unsafety(cx.tcx()).print_with_space(),\n-                if t.is_auto(cx.tcx()) { \"auto \" } else { \"\" },\n+                it.visibility(tcx).print_with_space(it.item_id, cx),\n+                t.unsafety(tcx).print_with_space(),\n+                if t.is_auto(tcx) { \"auto \" } else { \"\" },\n                 it.name.unwrap(),\n                 t.generics.print(cx),\n                 bounds\n@@ -1020,7 +1022,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n     let extern_crates = extern_crates\n         .into_iter()\n-        .map(|cnum| cx.shared.tcx.crate_name(cnum).to_string())\n+        .map(|cnum| tcx.crate_name(cnum).to_string())\n         .collect::<Vec<_>>()\n         .join(\",\");\n     let (extern_before, extern_after) =\n@@ -1084,7 +1086,7 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            write!(w, \"{}\", it.visibility.print_with_space(it.item_id, cx));\n+            write!(w, \"{}\", it.visibility(cx.tcx()).print_with_space(it.item_id, cx));\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n@@ -1173,14 +1175,15 @@ fn print_tuple_struct_fields(w: &mut Buffer, cx: &Context<'_>, s: &[clean::Item]\n }\n \n fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::Enum) {\n+    let tcx = cx.tcx();\n     let count_variants = e.variants().count();\n     wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"enum\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             write!(\n                 w,\n                 \"{}enum {}{}\",\n-                it.visibility.print_with_space(it.item_id, cx),\n+                it.visibility(tcx).print_with_space(it.item_id, cx),\n                 it.name.unwrap(),\n                 e.generics.print(cx),\n             );\n@@ -1268,10 +1271,10 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             w.write_str(\"</code>\");\n             render_stability_since_raw(\n                 w,\n-                variant.stable_since(cx.tcx()),\n-                variant.const_stability(cx.tcx()),\n-                it.stable_since(cx.tcx()),\n-                it.const_stable_since(cx.tcx()),\n+                variant.stable_since(tcx),\n+                variant.const_stability(tcx),\n+                it.stable_since(tcx),\n+                it.const_stable_since(tcx),\n             );\n             w.write_str(\"</h3>\");\n \n@@ -1389,12 +1392,13 @@ fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &clean::Constant) {\n     wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"const\", |w| {\n+            let tcx = cx.tcx();\n             render_attributes_in_code(w, it);\n \n             write!(\n                 w,\n                 \"{vis}const {name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.item_id, cx),\n+                vis = it.visibility(tcx).print_with_space(it.item_id, cx),\n                 name = it.name.unwrap(),\n                 typ = c.type_.print(cx),\n             );\n@@ -1408,9 +1412,9 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n             //            ` = 100i32;`\n             //        instead?\n \n-            let value = c.value(cx.tcx());\n-            let is_literal = c.is_literal(cx.tcx());\n-            let expr = c.expr(cx.tcx());\n+            let value = c.value(tcx);\n+            let is_literal = c.is_literal(tcx);\n+            let expr = c.expr(tcx);\n             if value.is_some() || is_literal {\n                 write!(w, \" = {expr};\", expr = Escape(&expr));\n             } else {\n@@ -1495,7 +1499,7 @@ fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n             write!(\n                 w,\n                 \"{vis}static {mutability}{name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.item_id, cx),\n+                vis = it.visibility(cx.tcx()).print_with_space(it.item_id, cx),\n                 mutability = s.mutability.print_with_space(),\n                 name = it.name.unwrap(),\n                 typ = s.type_.print(cx)\n@@ -1513,7 +1517,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n             write!(\n                 w,\n                 \"    {}type {};\\n}}\",\n-                it.visibility.print_with_space(it.item_id, cx),\n+                it.visibility(cx.tcx()).print_with_space(it.item_id, cx),\n                 it.name.unwrap(),\n             );\n         });\n@@ -1666,7 +1670,8 @@ fn render_union(\n     tab: &str,\n     cx: &Context<'_>,\n ) {\n-    write!(w, \"{}union {}\", it.visibility.print_with_space(it.item_id, cx), it.name.unwrap(),);\n+    let tcx = cx.tcx();\n+    write!(w, \"{}union {}\", it.visibility(tcx).print_with_space(it.item_id, cx), it.name.unwrap(),);\n \n     let where_displayed = g\n         .map(|g| {\n@@ -1693,7 +1698,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(field.item_id, cx),\n+                field.visibility(tcx).print_with_space(field.item_id, cx),\n                 field.name.unwrap(),\n                 ty.print(cx),\n                 tab\n@@ -1720,10 +1725,11 @@ fn render_struct(\n     structhead: bool,\n     cx: &Context<'_>,\n ) {\n+    let tcx = cx.tcx();\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(it.item_id, cx),\n+        it.visibility(tcx).print_with_space(it.item_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.unwrap()\n     );\n@@ -1753,7 +1759,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(field.item_id, cx),\n+                        field.visibility(tcx).print_with_space(field.item_id, cx),\n                         field.name.unwrap(),\n                         ty.print(cx),\n                     );\n@@ -1785,7 +1791,7 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(field.item_id, cx),\n+                            field.visibility(tcx).print_with_space(field.item_id, cx),\n                             ty.print(cx),\n                         )\n                     }"}, {"sha": "4962eb8f8e176dbeaebb8dbe85cf65c52f780876", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -48,7 +48,8 @@ impl JsonRenderer<'_> {\n             .map(rustc_ast_pretty::pprust::attribute_to_string)\n             .collect();\n         let span = item.span(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, visibility, item_id, cfg: _ } = item;\n+        let visibility = item.visibility(self.tcx);\n+        let clean::Item { name, attrs: _, kind: _, item_id, cfg: _, .. } = item;\n         let inner = match *item.kind {\n             clean::KeywordItem => return None,\n             clean::StrippedItem(ref inner) => {"}, {"sha": "3bac5a8e5d7490cd8614790559a83b2f68917616", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -11,6 +11,6 @@ pub(crate) const STRIP_PRIV_IMPORTS: Pass = Pass {\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-pub(crate) fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n-    ImportStripper.fold_crate(krate)\n+pub(crate) fn strip_priv_imports(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+    ImportStripper { tcx: cx.tcx }.fold_crate(krate)\n }"}, {"sha": "8fc42462de9696cba2fe15bb85c3ba1c9a6c6113", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -22,13 +22,13 @@ pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) ->\n     // strip all private items\n     {\n         let mut stripper = Stripper {\n-            tcx: cx.tcx,\n             retained: &mut retained,\n             effective_visibilities: &cx.cache.effective_visibilities,\n             update_retained: true,\n             is_json_output,\n+            tcx: cx.tcx,\n         };\n-        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n+        krate = ImportStripper { tcx: cx.tcx }.fold_crate(stripper.fold_crate(krate));\n     }\n \n     // strip all impls referencing private items"}, {"sha": "b2047360ccd9a2c34155fc82df77654e3ea7b324", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a76127283bc963b085f54a1b275a8e281e81e6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=c0a76127283bc963b085f54a1b275a8e281e81e6", "patch": "@@ -2,7 +2,6 @@\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n-\n use std::mem;\n \n use crate::clean::{self, Item, ItemId, ItemIdSet, NestedAttributesExt};\n@@ -11,11 +10,11 @@ use crate::formats::cache::Cache;\n use crate::visit_lib::RustdocEffectiveVisibilities;\n \n pub(crate) struct Stripper<'a, 'tcx> {\n-    pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) retained: &'a mut ItemIdSet,\n     pub(crate) effective_visibilities: &'a RustdocEffectiveVisibilities,\n     pub(crate) update_retained: bool,\n     pub(crate) is_json_output: bool,\n+    pub(crate) tcx: TyCtxt<'tcx>,\n }\n \n // We need to handle this differently for the JSON output because some non exported items could\n@@ -35,7 +34,7 @@ fn is_item_reachable(\n     }\n }\n \n-impl<'a> DocFolder for Stripper<'a, '_> {\n+impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match *i.kind {\n             clean::StrippedItem(..) => {\n@@ -82,13 +81,13 @@ impl<'a> DocFolder for Stripper<'a, '_> {\n             }\n \n             clean::StructFieldItem(..) => {\n-                if !i.visibility.is_public() {\n+                if !i.visibility(self.tcx).is_public() {\n                     return Some(strip_item(i));\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.item_id.is_local() && !i.visibility.is_public() {\n+                if i.item_id.is_local() && !i.visibility(self.tcx).is_public() {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = strip_item(self.fold_item_recur(i));\n@@ -239,12 +238,16 @@ impl<'a> DocFolder for ImplStripper<'a, '_> {\n }\n \n /// This stripper discards all private import statements (`use`, `extern crate`)\n-pub(crate) struct ImportStripper;\n+pub(crate) struct ImportStripper<'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n+}\n \n-impl DocFolder for ImportStripper {\n+impl<'tcx> DocFolder for ImportStripper<'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match *i.kind {\n-            clean::ExternCrateItem { .. } | clean::ImportItem(..) if !i.visibility.is_public() => {\n+            clean::ExternCrateItem { .. } | clean::ImportItem(..)\n+                if !i.visibility(self.tcx).is_public() =>\n+            {\n                 None\n             }\n             _ => Some(self.fold_item_recur(i)),"}]}