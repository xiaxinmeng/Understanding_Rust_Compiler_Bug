{"sha": "f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OWUwMGIzZDE0OWQ3OGI4ZmUyMTI1MTkxMmQ5YzdmYTc4YjlmMTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-16T23:49:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-16T23:49:37Z"}, "message": "auto merge of #6543 : catamorphism/rust/traits-cleanup, r=nikomatsakis\n\nr? @nikomatsakis Impls can implement either zero or one traits; this has been true\r\nmore or less since we removed classes. So I got rid of the comments\r\nsaying \"we should support multiple traits\" and changed the code to\r\nmake it clear that we don't. This is just cleanup, and doesn't break\r\nany existing tests.", "tree": {"sha": "26574116677ce4e28257981fbf506f41a2f544b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26574116677ce4e28257981fbf506f41a2f544b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "html_url": "https://github.com/rust-lang/rust/commit/f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00eef96a007a817533e78860e97b251258177d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/00eef96a007a817533e78860e97b251258177d5f", "html_url": "https://github.com/rust-lang/rust/commit/00eef96a007a817533e78860e97b251258177d5f"}, {"sha": "65b7903ba3aab91c68d09e192f907a68b7308ee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/65b7903ba3aab91c68d09e192f907a68b7308ee4", "html_url": "https://github.com/rust-lang/rust/commit/65b7903ba3aab91c68d09e192f907a68b7308ee4"}], "stats": {"total": 77, "additions": 37, "deletions": 40}, "files": [{"sha": "5a0820202a99a09e853a93445c920148f1e03605", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "patch": "@@ -234,14 +234,13 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     }\n }\n \n-// Given a def_id for an impl or class, return the traits it implements,\n-// or the empty vector if it's not for an impl or for a class that implements\n-// traits\n-pub fn get_impl_traits(tcx: ty::ctxt,\n-                       def: ast::def_id) -> ~[@ty::TraitRef] {\n+// Given a def_id for an impl, return the trait it implements,\n+// if there is one.\n+pub fn get_impl_trait(tcx: ty::ctxt,\n+                      def: ast::def_id) -> Option<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_impl_traits(cdata, def.node, tcx)\n+    decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n pub fn get_impl_method(cstore: @mut cstore::CStore,"}, {"sha": "43073728e8351871c4b27d0ca442735af2f5143e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "patch": "@@ -415,19 +415,20 @@ pub fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-pub fn get_impl_traits(cdata: cmd,\n+pub fn get_impl_trait(cdata: cmd,\n                        id: ast::node_id,\n-                       tcx: ty::ctxt) -> ~[@ty::TraitRef]\n+                       tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n-    let mut results = ~[];\n+    let mut result = None;\n     for reader::tagged_docs(item_doc, tag_item_trait_ref) |tp| {\n         let trait_ref =\n             @parse_trait_ref_data(tp.data, cdata.cnum, tp.start, tcx,\n                                   |_, did| translate_def_id(cdata, did));\n-        results.push(trait_ref);\n+        result = Some(trait_ref);\n+        break;\n     };\n-    results\n+    result\n }\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,"}, {"sha": "6eb2540f1df65bd80a15e1a95dcb2f2a1fcca341", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "patch": "@@ -795,8 +795,11 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n     let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n-    // XXX: This should support multiple traits.\n-    let trt_id = ty::impl_trait_refs(tcx, impl_id)[0].def_id;\n+    let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n+        Some(t_id) => t_id.def_id,\n+        None       => ccx.sess.bug(\"make_impl_vtable: don't know how to \\\n+                                    make a vtable for a type impl!\")\n+    };\n \n     let has_tps =\n         !ty::lookup_item_type(ccx.tcx, impl_id).generics.type_param_defs.is_empty();"}, {"sha": "c51fba8a62b71d0a5ff237050db85a675b011bf2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "patch": "@@ -3883,23 +3883,23 @@ pub fn trait_method_def_ids(cx: ctxt, id: ast::def_id) -> @~[def_id] {\n         || @csearch::get_trait_method_def_ids(cx.cstore, id))\n }\n \n-pub fn impl_trait_refs(cx: ctxt, id: ast::def_id) -> ~[@TraitRef] {\n+pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n     if id.crate == ast::local_crate {\n-        debug!(\"(impl_traits) searching for trait impl %?\", id);\n+        debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n         match cx.items.find(&id.node) {\n            Some(&ast_map::node_item(@ast::item {\n                         node: ast::item_impl(_, opt_trait, _, _),\n                         _},\n                     _)) => {\n                match opt_trait {\n-                   Some(t) => ~[ty::node_id_to_trait_ref(cx, t.ref_id)],\n-                   None => ~[]\n+                   Some(t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n+                   None => None\n                }\n            }\n-           _ => ~[]\n+           _ => None\n         }\n     } else {\n-        csearch::get_impl_traits(cx, id)\n+        csearch::get_impl_trait(cx, id)\n     }\n }\n "}, {"sha": "2e2b4550f6331278c56afbee247eff4f659cd8ff", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "patch": "@@ -261,24 +261,14 @@ fn lookup_vtable(vcx: &VtableContext,\n                         }\n                         impls_seen.insert(im.did);\n \n-                        // ty::impl_traits gives us the list of all\n-                        // traits that im implements. Again, usually\n-                        // there's just one.\n+                        // ty::impl_traits gives us the trait im implements,\n+                        // if there is one (there's either zero or one).\n                         //\n-                        // For example, if im represented the struct\n-                        // in:\n-                        //\n-                        //   struct foo : baz<int>, bar, quux { ... }\n-                        //\n-                        // then ty::impl_traits would return\n-                        //\n-                        //   ~[baz<int>, bar, quux]\n-                        //\n-                        // For each of the traits foo implements, if\n-                        // it's the same trait as trait_ref, we need to\n+                        // If foo implements a trait t, and if t is the\n+                        // same trait as trait_ref, we need to\n                         // unify it with trait_ref in order to get all\n                         // the ty vars sorted out.\n-                        for ty::impl_trait_refs(tcx, im.did).each |&of_trait_ref|\n+                        for ty::impl_trait_ref(tcx, im.did).each |&of_trait_ref|\n                         {\n                             if of_trait_ref.def_id != trait_ref.def_id { loop; }\n \n@@ -456,8 +446,12 @@ fn connect_trait_tps(vcx: &VtableContext,\n {\n     let tcx = vcx.tcx();\n \n-    // XXX: This should work for multiple traits.\n-    let impl_trait_ref = ty::impl_trait_refs(tcx, impl_did)[0];\n+    let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {\n+        Some(t) => t,\n+        None => vcx.tcx().sess.span_bug(location_info.span,\n+                                  \"connect_trait_tps invoked on a type impl\")\n+    };\n+\n     let impl_trait_ref = (*impl_trait_ref).subst(tcx, impl_substs);\n     relate_trait_refs(vcx, location_info, &impl_trait_ref, trait_ref);\n }"}, {"sha": "311aa551601dc0052bc841dd83563988e222b904", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89e00b3d149d78b8fe21251912d9c7fa78b9f15/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f89e00b3d149d78b8fe21251912d9c7fa78b9f15", "patch": "@@ -16,7 +16,7 @@\n \n \n use driver;\n-use metadata::csearch::{each_path, get_impl_traits};\n+use metadata::csearch::{each_path, get_impl_trait};\n use metadata::csearch::{get_impls_for_mod};\n use metadata::csearch;\n use metadata::cstore::{CStore, iter_crate_data};\n@@ -898,13 +898,13 @@ pub impl CoherenceChecker {\n \n             let self_type = lookup_item_type(self.crate_context.tcx,\n                                              implementation.did);\n-            let associated_traits = get_impl_traits(self.crate_context.tcx,\n+            let associated_traits = get_impl_trait(self.crate_context.tcx,\n                                                     implementation.did);\n \n             // Do a sanity check to make sure that inherent methods have base\n             // types.\n \n-            if associated_traits.len() == 0 {\n+            if associated_traits.is_none() {\n                 match get_base_type_def_id(self.inference_context,\n                                            dummy_sp(),\n                                            self_type.ty) {\n@@ -940,7 +940,7 @@ pub impl CoherenceChecker {\n                 Some(base_type_def_id) => {\n                     // inherent methods apply to `impl Type` but not\n                     // `impl Trait for Type`:\n-                    if associated_traits.len() == 0 {\n+                    if associated_traits.is_none() {\n                         self.add_inherent_method(base_type_def_id,\n                                                  *implementation);\n                     }"}]}