{"sha": "e35fd748114c22df6d08991980c4f7e199414497", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNWZkNzQ4MTE0YzIyZGY2ZDA4OTkxOTgwYzRmN2UxOTk0MTQ0OTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-17T23:41:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-17T23:41:36Z"}, "message": "Auto merge of #27169 - huonw:simd, r=alexcrichton\n\nThis implements https://github.com/rust-lang/rfcs/pull/1199 (except for doing all the platform intrinsics).\r\n\r\nThings remaining for SIMD (not necessarily in this PR):\r\n\r\n- [x] I (@huonw) am signed up to ensure the compiler matches the RFC, when it lands\r\n- [x] the platform specific intrinsics aren't properly type checked at the moment (LLVM will throw a \"random\" assertion)\r\n- [ ] there's a lot of useful intrinsics that are missing, including whole platforms (mips, powerpc)\r\n- [ ] the target-feature `cfg` detection/adding is not so great at the moment\r\n- [x] I think the platform specific intrinsics should go in their own `extern` ABI (i.e. not `\"rust-intrinsic\"`)\r\n\r\n(I'm adjusting the RFC to reflect the latter.)\r\n\r\nI think it would be very nice for this to land without requiring the RFC to land first, because of the first point, and because this is the only way for any further work to happen/be experimented with, without requiring people to build/install/multirust a compiler from a custom branch.\r\n\r\nr? @alexcrichton", "tree": {"sha": "1741be330092cf63fa429a6c529430a55db52a54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1741be330092cf63fa429a6c529430a55db52a54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e35fd748114c22df6d08991980c4f7e199414497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e35fd748114c22df6d08991980c4f7e199414497", "html_url": "https://github.com/rust-lang/rust/commit/e35fd748114c22df6d08991980c4f7e199414497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e35fd748114c22df6d08991980c4f7e199414497/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d992728c331128810704d16d8026aa4fa2e0c87", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d992728c331128810704d16d8026aa4fa2e0c87", "html_url": "https://github.com/rust-lang/rust/commit/6d992728c331128810704d16d8026aa4fa2e0c87"}, {"sha": "02e97342c136d2d13411ebd0a687100d8be248e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/02e97342c136d2d13411ebd0a687100d8be248e0", "html_url": "https://github.com/rust-lang/rust/commit/02e97342c136d2d13411ebd0a687100d8be248e0"}], "stats": {"total": 4063, "additions": 3032, "deletions": 1031}, "files": [{"sha": "aeb336f844facd6efc0efb665f2f37466fdac595", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -56,7 +56,7 @@ TARGET_CRATES := libc std flate arena term \\\n \t\t alloc_system\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n-                rustc_data_structures\n+                rustc_data_structures rustc_platform_intrinsics\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n TOOLS := compiletest rustdoc rustc rustbook error-index-generator\n \n@@ -74,15 +74,16 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n \t\t     rustc_trans rustc_privacy rustc_lint\n \n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n-\t                log syntax serialize rustc_llvm\n-DEPS_rustc_typeck := rustc syntax\n+\t                log syntax serialize rustc_llvm rustc_platform_intrinsics\n+DEPS_rustc_typeck := rustc syntax rustc_platform_intrinsics\n DEPS_rustc_borrowck := rustc log graphviz syntax\n DEPS_rustc_resolve := rustc log syntax\n DEPS_rustc_privacy := rustc log syntax\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n+DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\"}, {"sha": "e226e9fa1549b6eaad23f4708cdc21d887dadeea", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -78,7 +78,8 @@\n #![feature(optin_builtin_traits)]\n #![feature(reflect)]\n #![feature(rustc_attrs)]\n-#![feature(simd)]\n+#![cfg_attr(stage0, feature(simd))]\n+#![cfg_attr(not(stage0), feature(repr_simd, platform_intrinsics))]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n \n@@ -150,7 +151,13 @@ pub mod iter;\n pub mod option;\n pub mod raw;\n pub mod result;\n+\n+#[cfg(stage0)]\n+#[path = \"simd_old.rs\"]\n+pub mod simd;\n+#[cfg(not(stage0))]\n pub mod simd;\n+\n pub mod slice;\n pub mod str;\n pub mod hash;"}, {"sha": "fb39b3accc34454fc86758548a6d4bc9bcda872f", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 67, "deletions": 24, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -10,25 +10,12 @@\n \n //! SIMD vectors.\n //!\n-//! These types can be used for accessing basic SIMD operations. Each of them\n-//! implements the standard arithmetic operator traits (Add, Sub, Mul, Div,\n-//! Rem, Shl, Shr) through compiler magic, rather than explicitly. Currently\n+//! These types can be used for accessing basic SIMD operations. Currently\n //! comparison operators are not implemented. To use SSE3+, you must enable\n //! the features, like `-C target-feature=sse3,sse4.1,sse4.2`, or a more\n //! specific `target-cpu`. No other SIMD intrinsics or high-level wrappers are\n //! provided beyond this module.\n //!\n-//! ```rust\n-//! #![feature(core_simd)]\n-//!\n-//! fn main() {\n-//!     use std::simd::f32x4;\n-//!     let a = f32x4(40.0, 41.0, 42.0, 43.0);\n-//!     let b = f32x4(1.0, 1.1, 3.4, 9.8);\n-//!     println!(\"{:?}\", a + b);\n-//! }\n-//! ```\n-//!\n //! # Stability Note\n //!\n //! These are all experimental. The interface may change entirely, without\n@@ -37,64 +24,120 @@\n #![unstable(feature = \"core_simd\",\n             reason = \"needs an RFC to flesh out the design\",\n             issue = \"27731\")]\n+#![deprecated(since = \"1.3.0\",\n+              reason = \"use the external `simd` crate instead\")]\n \n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n+#![allow(deprecated)]\n+\n+use ops::{Add, Sub, Mul, Div, Shl, Shr, BitAnd, BitOr, BitXor};\n+\n+// FIXME(stage0): the contents of macro can be inlined.\n+// ABIs are verified as valid as soon as they are parsed, i.e. before\n+// `cfg` stripping. The `platform-intrinsic` ABI is new, so stage0\n+// doesn't know about it, but it still errors out when it hits it\n+// (despite this being in a `cfg(not(stage0))` module).\n+macro_rules! argh {\n+    () => {\n+        extern \"platform-intrinsic\" {\n+            fn simd_add<T>(x: T, y: T) -> T;\n+            fn simd_sub<T>(x: T, y: T) -> T;\n+            fn simd_mul<T>(x: T, y: T) -> T;\n+            fn simd_div<T>(x: T, y: T) -> T;\n+            fn simd_shl<T>(x: T, y: T) -> T;\n+            fn simd_shr<T>(x: T, y: T) -> T;\n+            fn simd_and<T>(x: T, y: T) -> T;\n+            fn simd_or<T>(x: T, y: T) -> T;\n+            fn simd_xor<T>(x: T, y: T) -> T;\n+        }\n+    }\n+}\n+argh!();\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct f64x2(pub f64, pub f64);\n+\n+macro_rules! impl_traits {\n+    ($($trayt: ident, $method: ident, $func: ident: $($ty: ty),*;)*) => {\n+        $($(\n+            impl $trayt<$ty> for $ty {\n+                type Output = Self;\n+                fn $method(self, other: Self) -> Self {\n+                    unsafe {\n+                        $func(self, other)\n+                    }\n+                }\n+            }\n+            )*)*\n+    }\n+}\n+\n+impl_traits! {\n+    Add, add, simd_add: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2;\n+    Sub, sub, simd_sub: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2;\n+    Mul, mul, simd_mul: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2;\n+\n+    Div, div, simd_div: f32x4, f64x2;\n+\n+    Shl, shl, simd_shl: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n+    Shr, shr, simd_shr: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n+    BitAnd, bitand, simd_and: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n+    BitOr, bitor, simd_or: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n+    BitXor, bitxor, simd_xor: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n+}"}, {"sha": "7ecd08bea3574fc192b3d9d2811b39e2922d264a", "filename": "src/libcore/simd_old.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibcore%2Fsimd_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibcore%2Fsimd_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd_old.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! SIMD vectors.\n+//!\n+//! These types can be used for accessing basic SIMD operations. Each of them\n+//! implements the standard arithmetic operator traits (Add, Sub, Mul, Div,\n+//! Rem, Shl, Shr) through compiler magic, rather than explicitly. Currently\n+//! comparison operators are not implemented. To use SSE3+, you must enable\n+//! the features, like `-C target-feature=sse3,sse4.1,sse4.2`, or a more\n+//! specific `target-cpu`. No other SIMD intrinsics or high-level wrappers are\n+//! provided beyond this module.\n+//!\n+//! ```rust\n+//! # #![feature(core_simd)]\n+//! fn main() {\n+//!     use std::simd::f32x4;\n+//!     let a = f32x4(40.0, 41.0, 42.0, 43.0);\n+//!     let b = f32x4(1.0, 1.1, 3.4, 9.8);\n+//!     println!(\"{:?}\", a + b);\n+//! }\n+//! ```\n+//!\n+//! # Stability Note\n+//!\n+//! These are all experimental. The interface may change entirely, without\n+//! warning.\n+\n+#![unstable(feature = \"core_simd\",\n+            reason = \"needs an RFC to flesh out the design\")]\n+\n+#![allow(non_camel_case_types)]\n+#![allow(missing_docs)]\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n+                 pub i8, pub i8, pub i8, pub i8,\n+                 pub i8, pub i8, pub i8, pub i8,\n+                 pub i8, pub i8, pub i8, pub i8);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n+                 pub i16, pub i16, pub i16, pub i16);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct i64x2(pub i64, pub i64);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n+                 pub u8, pub u8, pub u8, pub u8,\n+                 pub u8, pub u8, pub u8, pub u8,\n+                 pub u8, pub u8, pub u8, pub u8);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n+                 pub u16, pub u16, pub u16, pub u16);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct u64x2(pub u64, pub u64);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[simd]\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct f64x2(pub f64, pub f64);"}, {"sha": "3f182b4d2b5bb4e40531428b80793ecab5932048", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -704,7 +704,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n     }\n \n     fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n-        if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+        if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic || fm.abi == abi::PlatformIntrinsic {\n             return;\n         }\n "}, {"sha": "d9e6e8c12f1e3b4d6e16c01d20a413f2047e3342", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -1501,7 +1501,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n-        if abi == abi::RustIntrinsic {\n+        if abi == abi::RustIntrinsic || abi == abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);"}, {"sha": "d7a58f4cdd08c80bfaa34a2757cc1e11f6ec1971", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -3312,10 +3312,10 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n            variants: Vec<VariantDefData<'tcx, 'container>>) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n-        if attrs.iter().any(|item| item.check_name(\"fundamental\")) {\n+        if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n-        if attrs.iter().any(|item| item.check_name(\"simd\")) {\n+        if tcx.lookup_simd(did) {\n             flags = flags | AdtFlags::IS_SIMD;\n         }\n         if Some(did) == tcx.lang_items.phantom_data() {\n@@ -6116,6 +6116,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// Determine whether an item is annotated with `#[simd]`\n     pub fn lookup_simd(&self, did: DefId) -> bool {\n         self.has_attr(did, \"simd\")\n+            || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n     }\n \n     /// Obtain the representation annotation for a struct definition."}, {"sha": "346e7a7bf9886284802d5f8ee34ae8411ea4a830", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -406,8 +406,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     //\n     // baz! should not use this definition unless foo is enabled.\n \n-    krate = time(time_passes, \"configuration 1\", move ||\n-                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate));\n+    let mut feature_gated_cfgs = vec![];\n+    krate = time(time_passes, \"configuration 1\", ||\n+                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate,\n+                                                          &mut feature_gated_cfgs));\n \n     *sess.crate_types.borrow_mut() =\n         collect_crate_types(sess, &krate.attrs);\n@@ -511,6 +513,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                           cfg,\n                                           macros,\n                                           syntax_exts,\n+                                          &mut feature_gated_cfgs,\n                                           krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &_old_path);\n@@ -536,7 +539,17 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     // strip again, in case expansion added anything with a #[cfg].\n     krate = time(time_passes, \"configuration 2\", ||\n-                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate));\n+                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate,\n+                                                          &mut feature_gated_cfgs));\n+\n+    time(time_passes, \"gated configuration checking\", || {\n+        let features = sess.features.borrow();\n+        feature_gated_cfgs.sort();\n+        feature_gated_cfgs.dedup();\n+        for cfg in &feature_gated_cfgs {\n+            cfg.check_and_emit(sess.diagnostic(), &features);\n+        }\n+    });\n \n     krate = time(time_passes, \"maybe building test harness\", ||\n                  syntax::test::modify_for_testing(&sess.parse_sess,"}, {"sha": "60eaffd71cbc6a91bd1ab5dfa341cdf787a8fe08", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -89,6 +89,7 @@ pub mod test;\n \n pub mod driver;\n pub mod pretty;\n+pub mod target_features;\n \n \n const BUG_REPORT_URL: &'static str =\n@@ -136,7 +137,8 @@ pub fn run_compiler<'a>(args: &[String],\n     if sess.unstable_options() {\n         sess.opts.show_span = matches.opt_str(\"show-span\");\n     }\n-    let cfg = config::build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess);\n+    target_features::add_configuration(&mut cfg, &sess);\n \n     do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile));\n "}, {"sha": "ca76046acf0fb684d28953e99b4c037fa02fdb98", "filename": "src/librustc_driver/target_features.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::{ast, attr};\n+use rustc::session::Session;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token::intern_and_get_ident as intern;\n+\n+/// Add `target_feature = \"...\"` cfgs for a variety of platform\n+/// specific features (SSE, NEON etc.).\n+///\n+/// This uses a scheme similar to that employed by clang: reimplement\n+/// the target feature knowledge. *Theoretically* we could query LLVM\n+/// since that has perfect knowledge about what things are enabled in\n+/// code-generation, however, it is extremely non-obvious how to do\n+/// this successfully. Each platform defines a subclass of a\n+/// SubtargetInfo, which knows all this information, but the ways to\n+/// query them do not seem to be public.\n+pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n+    let tf = InternedString::new(\"target_feature\");\n+    macro_rules! fillout {\n+        ($($func: ident, $name: expr;)*) => {{\n+            $(if $func(sess) {\n+                cfg.push(attr::mk_name_value_item_str(tf.clone(), intern($name)))\n+            })*\n+        }}\n+    }\n+    fillout! {\n+        has_sse, \"sse\";\n+        has_sse2, \"sse2\";\n+        has_sse3, \"sse3\";\n+        has_ssse3, \"ssse3\";\n+        has_sse41, \"sse4.1\";\n+        has_sse42, \"sse4.2\";\n+        has_avx, \"avx\";\n+        has_avx2, \"avx2\";\n+        has_neon, \"neon\";\n+        has_vfp, \"vfp\";\n+    }\n+}\n+\n+\n+fn features_contain(sess: &Session, s: &str) -> bool {\n+    sess.target.target.options.features.contains(s) ||\n+        sess.opts.cg.target_feature.contains(s)\n+}\n+\n+pub fn has_sse(sess: &Session) -> bool {\n+    features_contain(sess, \"+sse\") ||\n+        has_sse2(sess)\n+}\n+pub fn has_sse2(sess: &Session) -> bool {\n+    // x86-64 requires at least SSE2 support\n+    sess.target.target.arch == \"x86_64\" ||\n+        features_contain(sess, \"+sse2\") ||\n+        has_sse3(sess)\n+}\n+pub fn has_sse3(sess: &Session) -> bool {\n+    features_contain(sess, \"+sse3\") ||\n+        has_ssse3(sess)\n+}\n+pub fn has_ssse3(sess: &Session) -> bool {\n+    features_contain(sess, \"+ssse3\") ||\n+        has_sse41(sess)\n+}\n+pub fn has_sse41(sess: &Session) -> bool {\n+    features_contain(sess, \"+sse4.1\") ||\n+        has_sse42(sess)\n+}\n+pub fn has_sse42(sess: &Session) -> bool {\n+    features_contain(sess, \"+sse4.2\") ||\n+        has_avx(sess)\n+}\n+pub fn has_avx(sess: &Session) -> bool {\n+    features_contain(sess, \"+avx\") ||\n+        has_avx2(sess)\n+}\n+pub fn has_avx2(sess: &Session) -> bool {\n+    features_contain(sess, \"+avx2\")\n+}\n+\n+pub fn has_neon(sess: &Session) -> bool {\n+    // AArch64 requires NEON support\n+    sess.target.target.arch == \"aarch64\" ||\n+        features_contain(sess, \"+neon\")\n+}\n+pub fn has_vfp(sess: &Session) -> bool {\n+    // AArch64 requires VFP support\n+    sess.target.target.arch == \"aarch64\" ||\n+        features_contain(sess, \"+vfp\")\n+}"}, {"sha": "523ab7b527a14e9b870230b0822a0980e8446361", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -603,6 +603,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 match bare_fn.abi {\n                     abi::Rust |\n                     abi::RustIntrinsic |\n+                    abi::PlatformIntrinsic |\n                     abi::RustCall => {\n                         return FfiUnsafe(\n                             \"found function pointer with Rust calling \\\n@@ -717,7 +718,9 @@ impl LintPass for ImproperCTypes {\n         }\n \n         match it.node {\n-            ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n+            ast::ItemForeignMod(ref nmod)\n+                if nmod.abi != abi::RustIntrinsic &&\n+                   nmod.abi != abi::PlatformIntrinsic => {\n                 for ni in &nmod.items {\n                     match ni.node {\n                         ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),"}, {"sha": "e7b11e45fd6c724d94450a89793e008f7630be86", "filename": "src/librustc_platform_intrinsics/aarch64.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Faarch64.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Intrinsic, i, f, v};\n+use rustc::middle::ty;\n+\n+macro_rules! p {\n+    ($name: expr, ($($inputs: tt),*) -> $output: tt) => {\n+        plain!(concat!(\"llvm.aarch64.neon.\", $name), ($($inputs),*) -> $output)\n+    }\n+}\n+pub fn find<'tcx>(_tcx: &ty::ctxt<'tcx>, name: &str) -> Option<Intrinsic> {\n+    Some(match name {\n+        \"vmaxvq_u8\" => p!(\"umaxv.i8.v16i8\", (i8x16) -> i8),\n+        \"vmaxvq_u16\" => p!(\"umaxv.i16.v8i16\", (i16x8) -> i16),\n+        \"vmaxvq_u32\" => p!(\"umaxv.i32.v4i32\", (i32x4) -> i32),\n+\n+        \"vmaxvq_s8\" => p!(\"smaxv.i8.v16i8\", (i8x16) -> i8),\n+        \"vmaxvq_s16\" => p!(\"smaxv.i16.v8i16\", (i16x8) -> i16),\n+        \"vmaxvq_s32\" => p!(\"smaxv.i32.v4i32\", (i32x4) -> i32),\n+\n+        \"vminvq_u8\" => p!(\"uminv.i8.v16i8\", (i8x16) -> i8),\n+        \"vminvq_u16\" => p!(\"uminv.i16.v8i16\", (i16x8) -> i16),\n+        \"vminvq_u32\" => p!(\"uminv.i32.v4i32\", (i32x4) -> i32),\n+        \"vminvq_s8\" => p!(\"sminv.i8.v16i8\", (i8x16) -> i8),\n+        \"vminvq_s16\" => p!(\"sminv.i16.v8i16\", (i16x8) -> i16),\n+        \"vminvq_s32\" => p!(\"sminv.i32.v4i32\", (i32x4) -> i32),\n+\n+        \"vsqrtq_f32\" => plain!(\"llvm.sqrt.v4f32\", (f32x4) -> f32x4),\n+        \"vsqrtq_f64\" => plain!(\"llvm.sqrt.v2f64\", (f64x2) -> f64x2),\n+\n+        \"vrsqrteq_f32\" => p!(\"vrsqrte.v4f32\", (f32x4) -> f32x4),\n+        \"vrsqrteq_f64\" => p!(\"vrsqrte.v2f64\", (f64x2) -> f64x2),\n+        \"vrecpeq_f32\" => p!(\"vrecpe.v4f32\", (f32x4) -> f32x4),\n+        \"vrecpeq_f64\" => p!(\"vrecpe.v2f64\", (f64x2) -> f64x2),\n+\n+        \"vmaxq_f32\" => p!(\"fmax.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"vmaxq_f64\" => p!(\"fmax.v2f64\", (f64x2, f64x2) -> f64x2),\n+\n+        \"vminq_f32\" => p!(\"fmin.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"vminq_f64\" => p!(\"fmin.v2f64\", (f64x2, f64x2) -> f64x2),\n+        _ => return None,\n+    })\n+}"}, {"sha": "f29f7e384b4fb22dfd7939298a06525254be5dae", "filename": "src/librustc_platform_intrinsics/arm.rs", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Farm.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,347 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Intrinsic, i, f, v};\n+use rustc::middle::ty;\n+\n+macro_rules! p {\n+    ($name: expr, ($($inputs: tt),*) -> $output: tt) => {\n+        plain!(concat!(\"llvm.arm.neon.\", $name), ($($inputs),*) -> $output)\n+    }\n+}\n+pub fn find<'tcx>(_tcx: &ty::ctxt<'tcx>, name: &str) -> Option<Intrinsic> {\n+    if !name.starts_with(\"v\") { return None }\n+    Some(match &name[\"v\".len()..] {\n+        \"sqrtq_f32\" => plain!(\"llvm.sqrt.v4f32\", (f32x4) -> f32x4),\n+        \"sqrtq_f64\" => plain!(\"llvm.sqrt.v2f64\", (f64x2) -> f64x2),\n+\n+        \"hadd_s8\" => p!(\"vhadds.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"haddq_s8\" => p!(\"vhadds.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"hadd_s16\" => p!(\"vhadds.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"haddq_s16\" => p!(\"vhadds.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"hadd_s32\" => p!(\"vhadds.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"haddq_s32\" => p!(\"vhadds.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"hadd_u8\" => p!(\"vhaddu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"haddq_u8\" => p!(\"vhaddu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"hadd_u16\" => p!(\"vhaddu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"haddq_u16\" => p!(\"vhaddu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"hadd_u32\" => p!(\"vhaddu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"haddq_u32\" => p!(\"vhaddu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"rhadd_s8\" => p!(\"vrhadds.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"rhaddq_s8\" => p!(\"vrhadds.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"rhadd_s16\" => p!(\"vrhadds.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"rhaddq_s16\" => p!(\"vrhadds.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"rhadd_s32\" => p!(\"vrhadds.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"rhaddq_s32\" => p!(\"vrhadds.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"rhadd_u8\" => p!(\"vrhaddu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"rhaddq_u8\" => p!(\"vrhaddu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"rhadd_u16\" => p!(\"vrhaddu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"rhaddq_u16\" => p!(\"vrhaddu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"rhadd_u32\" => p!(\"vrhaddu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"rhaddq_u32\" => p!(\"vrhaddu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qadd_s8\" => p!(\"vqadds.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qaddq_s8\" => p!(\"vqadds.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qadd_s16\" => p!(\"vqadds.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qaddq_s16\" => p!(\"vqadds.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qadd_s32\" => p!(\"vqadds.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qaddq_s32\" => p!(\"vqadds.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qadd_s64\" => p!(\"vqaddu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qaddq_s64\" => p!(\"vqaddu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"qadd_u8\" => p!(\"vqaddu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qaddq_u8\" => p!(\"vqaddu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qadd_u16\" => p!(\"vqaddu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qaddq_u16\" => p!(\"vqaddu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qadd_u32\" => p!(\"vqaddu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qaddq_u32\" => p!(\"vqaddu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qadd_u64\" => p!(\"vqaddu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qaddq_u64\" => p!(\"vqaddu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"raddhn_s16\" => p!(\"vraddhn.v8i8\", (i16x8, i16x8) -> i8x8),\n+        \"raddhn_s32\" => p!(\"vraddhn.v4i16\", (i32x4, i32x4) -> i16x4),\n+        \"raddhn_s64\" => p!(\"vraddhn.v2i32\", (i64x2, i64x2) -> i32x2),\n+        \"fma_f32\" => plain!(\"llvm.fma.v2f32\", (f32x2, f32x2, f32x2) -> f32x2),\n+        \"fmaq_f32\" => plain!(\"llvm.fma.v4f32\", (f32x4, f32x4, f32x4) -> f32x4),\n+        \"qdmulh_s16\" => p!(\"vqdmulh.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qdmulhq_s16\" => p!(\"vqdmulh.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qdmulh_s32\" => p!(\"vqdmulh.v2i32\", (i32x2, i32x2) -> i32x4),\n+        \"qdmulhq_s32\" => p!(\"vqdmulh.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qrdmulh_s16\" => p!(\"vqrdmulh.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qrdmulhqr_s16\" => p!(\"vqrdmulh.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qrdmulh_s32\" => p!(\"vqrdmulh.v2i32\", (i32x2, i32x2) -> i32x4),\n+        \"qrdmulhqr_s32\" => p!(\"vqrdmulh.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"mull_s8\" => p!(\"vmulls.v8i16\", (i8x8, i8x8) -> i16x8),\n+        \"mull_s16\" => p!(\"vmulls.v4i32\", (i16x4, i16x4) -> i32x4),\n+        \"mull_s32\" => p!(\"vmulls.v2i64\", (i32x2, i32x2) -> i64x2),\n+        \"mull_u8\" => p!(\"vmullu.v8i16\", (i8x8, i8x8) -> i16x8),\n+        \"mull_u16\" => p!(\"vmullu.v4i32\", (i16x4, i16x4) -> i32x4),\n+        \"mull_u32\" => p!(\"vmullu.v2i64\", (i32x2, i32x2) -> i64x2),\n+        \"qdmull_s16\" => p!(\"vqdmull.v4i32\", (i16x4, i16x4) -> i32x4),\n+        \"qdmull_s32\" => p!(\"vqdmull.v2i64\", (i32x2, i32x2) -> i64x2),\n+        \"hsub_s8\" => p!(\"vhsubs.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"hsubq_s8\" => p!(\"vhsubs.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"hsub_s16\" => p!(\"vhsubs.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"hsubq_s16\" => p!(\"vhsubs.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"hsub_s32\" => p!(\"vhsubs.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"hsubq_s32\" => p!(\"vhsubs.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"hsub_u8\" => p!(\"vhsubu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"hsubq_u8\" => p!(\"vhsubu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"hsub_u16\" => p!(\"vhsubu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"hsubq_u16\" => p!(\"vhsubu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"hsub_u32\" => p!(\"vhsubu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"hsubq_u32\" => p!(\"vhsubu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qsub_s8\" => p!(\"vqsubs.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qsubq_s8\" => p!(\"vqsubs.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qsub_s16\" => p!(\"vqsubs.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qsubq_s16\" => p!(\"vqsubs.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qsub_s32\" => p!(\"vqsubs.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qsubq_s32\" => p!(\"vqsubs.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qsub_s64\" => p!(\"vqsubu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qsubq_s64\" => p!(\"vqsubu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"qsub_u8\" => p!(\"vqsubu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qsubq_u8\" => p!(\"vqsubu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qsub_u16\" => p!(\"vqsubu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qsubq_u16\" => p!(\"vqsubu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qsub_u32\" => p!(\"vqsubu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qsubq_u32\" => p!(\"vqsubu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qsub_u64\" => p!(\"vqsubu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qsubq_u64\" => p!(\"vqsubu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"abd_s8\" => p!(\"vabds.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"abdq_s8\" => p!(\"vabds.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"abd_s16\" => p!(\"vabds.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"abdq_s16\" => p!(\"vabds.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"abd_s32\" => p!(\"vabds.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"abdq_s32\" => p!(\"vabds.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"abd_u8\" => p!(\"vabdu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"abdq_u8\" => p!(\"vabdu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"abd_u16\" => p!(\"vabdu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"abdq_u16\" => p!(\"vabdu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"abd_u32\" => p!(\"vabdu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"abdq_u32\" => p!(\"vabdu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"abd_f32\" => p!(\"vabds.v2f32\", (f32x2, f32x2) -> f32x2),\n+        \"abdq_f32\" => p!(\"vabds.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"max_s8\" => p!(\"vmaxs.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"maxq_s8\" => p!(\"vmaxs.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"max_s16\" => p!(\"vmaxs.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"maxq_s16\" => p!(\"vmaxs.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"max_s32\" => p!(\"vmaxs.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"maxq_s32\" => p!(\"vmaxs.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"max_u8\" => p!(\"vmaxu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"maxq_u8\" => p!(\"vmaxu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"max_u16\" => p!(\"vmaxu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"maxq_u16\" => p!(\"vmaxu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"max_u32\" => p!(\"vmaxu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"maxq_u32\" => p!(\"vmaxu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"max_f32\" => p!(\"vmaxs.v2f32\", (f32x2, f32x2) -> f32x2),\n+        \"maxq_f32\" => p!(\"vmaxs.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"min_s8\" => p!(\"vmins.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"minq_s8\" => p!(\"vmins.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"min_s16\" => p!(\"vmins.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"minq_s16\" => p!(\"vmins.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"min_s32\" => p!(\"vmins.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"minq_s32\" => p!(\"vmins.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"min_u8\" => p!(\"vminu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"minq_u8\" => p!(\"vminu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"min_u16\" => p!(\"vminu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"minq_u16\" => p!(\"vminu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"min_u32\" => p!(\"vminu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"minq_u32\" => p!(\"vminu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"min_f32\" => p!(\"vmins.v2f32\", (f32x2, f32x2) -> f32x2),\n+        \"minq_f32\" => p!(\"vmins.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"shl_s8\" => p!(\"vshifts.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"shlq_s8\" => p!(\"vshifts.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"shl_s16\" => p!(\"vshifts.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"shlq_s16\" => p!(\"vshifts.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"shl_s32\" => p!(\"vshifts.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"shlq_s32\" => p!(\"vshifts.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"shl_s64\" => p!(\"vshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"shlq_s64\" => p!(\"vshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"shl_u8\" => p!(\"vshiftu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"shlq_u8\" => p!(\"vshiftu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"shl_u16\" => p!(\"vshiftu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"shlq_u16\" => p!(\"vshiftu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"shl_u32\" => p!(\"vshiftu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"shlq_u32\" => p!(\"vshiftu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"shl_u64\" => p!(\"vshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"shlq_u64\" => p!(\"vshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"qshl_s8\" => p!(\"vqshifts.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qshlq_s8\" => p!(\"vqshifts.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qshl_s16\" => p!(\"vqshifts.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qshlq_s16\" => p!(\"vqshifts.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qshl_s32\" => p!(\"vqshifts.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qshlq_s32\" => p!(\"vqshifts.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qshl_s64\" => p!(\"vqshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qshlq_s64\" => p!(\"vqshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"qshl_u8\" => p!(\"vqshiftu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qshlq_u8\" => p!(\"vqshiftu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qshl_u16\" => p!(\"vqshiftu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qshlq_u16\" => p!(\"vqshiftu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qshl_u32\" => p!(\"vqshiftu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qshlq_u32\" => p!(\"vqshiftu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qshl_u64\" => p!(\"vqshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qshlq_u64\" => p!(\"vqshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"rshl_s8\" => p!(\"vrshifts.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"rshlr_s8\" => p!(\"vrshifts.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"rshl_s16\" => p!(\"vrshifts.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"rshlr_s16\" => p!(\"vrshifts.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"rshl_s32\" => p!(\"vrshifts.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"rshlr_s32\" => p!(\"vrshifts.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"rshl_s64\" => p!(\"vrshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"rshlr_s64\" => p!(\"vrshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"rshl_u8\" => p!(\"vrshiftu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"rshlr_u8\" => p!(\"vrshiftu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"rshl_u16\" => p!(\"vrshiftu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"rshlr_u16\" => p!(\"vrshiftu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"rshl_u32\" => p!(\"vrshiftu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"rshlr_u32\" => p!(\"vrshiftu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"rshl_u64\" => p!(\"vrshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"rshlr_u64\" => p!(\"vrshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"qrshl_s8\" => p!(\"vqrshifts.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qrshlqr_s8\" => p!(\"vqrshifts.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qrshl_s16\" => p!(\"vqrshifts.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qrshlqr_s16\" => p!(\"vqrshifts.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qrshl_s32\" => p!(\"vqrshifts.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qrshlqr_s32\" => p!(\"vqrshifts.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qrshl_s64\" => p!(\"vqrshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qrshlqr_s64\" => p!(\"vqrshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"qrshl_u8\" => p!(\"vqrshiftu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qrshlqr_u8\" => p!(\"vqrshiftu.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qrshl_u16\" => p!(\"vqrshiftu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qrshlqr_u16\" => p!(\"vqrshiftu.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qrshl_u32\" => p!(\"vqrshiftu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qrshlqr_u32\" => p!(\"vqrshiftu.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"qrshl_u64\" => p!(\"vqrshiftu.v1i64\", (i64x1, i64x1) -> i64x1),\n+        \"qrshlqr_u64\" => p!(\"vqrshiftu.v2i64\", (i64x2, i64x2) -> i64x2),\n+        \"qmovn_s16\" => p!(\"vqmovns.v8i8\", (i16x8) -> i8x8),\n+        \"qmovn_s32\" => p!(\"vqmovns.v4i16\", (i32x4) -> i16x4),\n+        \"qmovn_s64\" => p!(\"vqmovns.v2i32\", (i64x2) -> i32x2),\n+        \"qmovn_u16\" => p!(\"vqmovnu.v8i8\", (i16x8) -> i8x8),\n+        \"qmovn_u32\" => p!(\"vqmovnu.v4i16\", (i32x4) -> i16x4),\n+        \"qmovn_u64\" => p!(\"vqmovnu.v2i32\", (i64x2) -> i32x2),\n+        \"qmovun_s16\" => p!(\"vqmovnsu.v8i8\", (i16x8) -> i8x8),\n+        \"qmovun_s32\" => p!(\"vqmovnsu.v4i16\", (i32x4) -> i16x4),\n+        \"qmovun_s64\" => p!(\"vqmovnsu.v2i32\", (i64x2) -> i32x2),\n+        \"abs_s8\" => p!(\"vabs.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"absq_s8\" => p!(\"vabs.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"abs_s16\" => p!(\"vabs.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"absq_s16\" => p!(\"vabs.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"abs_s32\" => p!(\"vabs.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"absq_s32\" => p!(\"vabs.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"abs_f32\" => p!(\"vabs.v2f32\", (f32x2, f32x2) -> f32x2),\n+        \"absq_f32\" => p!(\"vabs.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"qabs_s8\" => p!(\"vqabs.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"qabsq_s8\" => p!(\"vqabs.v16i8\", (i8x16, i8x16) -> i8x16),\n+        \"qabs_s16\" => p!(\"vqabs.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"qabsq_s16\" => p!(\"vqabs.v8i16\", (i16x8, i16x8) -> i16x8),\n+        \"qabs_s32\" => p!(\"vqabs.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"qabsq_s32\" => p!(\"vqabs.v4i32\", (i32x4, i32x4) -> i32x4),\n+        \"neg_s8\" => p!(\"vneg.v8i8\", (i8x8) -> i8x8),\n+        \"negq_s8\" => p!(\"vneg.v16i8\", (i8x16) -> i8x16),\n+        \"neg_s16\" => p!(\"vneg.v4i16\", (i16x4) -> i16x4),\n+        \"negq_s16\" => p!(\"vneg.v8i16\", (i16x8) -> i16x8),\n+        \"neg_s32\" => p!(\"vneg.v2i32\", (i32x2) -> i32x2),\n+        \"negq_s32\" => p!(\"vneg.v4i32\", (i32x4) -> i32x4),\n+        \"neg_f32\" => p!(\"vneg.v2f32\", (f32x2) -> f32x2),\n+        \"negq_f32\" => p!(\"vneg.v4f32\", (f32x4) -> f32x4),\n+        \"qneg_s8\" => p!(\"vqneg.v8i8\", (i8x8) -> i8x8),\n+        \"qnegq_s8\" => p!(\"vqneg.v16i8\", (i8x16) -> i8x16),\n+        \"qneg_s16\" => p!(\"vqneg.v4i16\", (i16x4) -> i16x4),\n+        \"qnegq_s16\" => p!(\"vqneg.v8i16\", (i16x8) -> i16x8),\n+        \"qneg_s32\" => p!(\"vqneg.v2i32\", (i32x2) -> i32x2),\n+        \"qnegq_s32\" => p!(\"vqneg.v4i32\", (i32x4) -> i32x4),\n+        \"cls_s8\" => p!(\"vcls.v8i8\", (i8x8) -> i8x8),\n+        \"clsq_s8\" => p!(\"vcls.v16i8\", (i8x16) -> i8x16),\n+        \"cls_s16\" => p!(\"vcls.v4i16\", (i16x4) -> i16x4),\n+        \"clsq_s16\" => p!(\"vcls.v8i16\", (i16x8) -> i16x8),\n+        \"cls_s32\" => p!(\"vcls.v2i32\", (i32x2) -> i32x2),\n+        \"clsq_s32\" => p!(\"vcls.v4i32\", (i32x4) -> i32x4),\n+        \"clz_s8\" => p!(\"vclz.v8i8\", (i8x8) -> i8x8),\n+        \"clzq_s8\" => p!(\"vclz.v16i8\", (i8x16) -> i8x16),\n+        \"clz_s16\" => p!(\"vclz.v4i16\", (i16x4) -> i16x4),\n+        \"clzq_s16\" => p!(\"vclz.v8i16\", (i16x8) -> i16x8),\n+        \"clz_s32\" => p!(\"vclz.v2i32\", (i32x2) -> i32x2),\n+        \"clzq_s32\" => p!(\"vclz.v4i32\", (i32x4) -> i32x4),\n+        \"cnt_s8\" => p!(\"vcnt.v8i8\", (i8x8) -> i8x8),\n+        \"cntq_s8\" => p!(\"vcnt.v16i8\", (i8x16) -> i8x16),\n+        \"recpe_u32\" => p!(\"vrecpe.v2i32\", (i32x2) -> i32x2),\n+        \"recpeq_u32\" => p!(\"vrecpe.v4i32\", (i32x4) -> i32x4),\n+        \"recpe_f32\" => p!(\"vrecpe.v2f32\", (f32x2) -> f32x2),\n+        \"recpeq_f32\" => p!(\"vrecpe.v4f32\", (f32x4) -> f32x4),\n+        \"recps_f32\" => p!(\"vrecps.v2f32\", (f32x2, f32x2) -> f32x2),\n+        \"recpsq_f32\" => p!(\"vrecps.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"rsqrte_u32\" => p!(\"vrsqrte.v2i32\", (i32x2) -> i32x2),\n+        \"rsqrteq_u32\" => p!(\"vrsqrte.v4i32\", (i32x4) -> i32x4),\n+        \"rsqrte_f32\" => p!(\"vrsqrte.v2f32\", (f32x2) -> f32x2),\n+        \"rsqrteq_f32\" => p!(\"vrsqrte.v4f32\", (f32x4) -> f32x4),\n+        \"rsqrts_f32\" => p!(\"vrsqrts.v2f32\", (f32x2, f32x2) -> f32x2),\n+        \"rsqrtsq_f32\" => p!(\"vrsqrts.v4f32\", (f32x4, f32x4) -> f32x4),\n+        \"bsl_s8\" => p!(\"vsl.v8i8\", (i8x8, i8x8, i8x8) -> i8x8),\n+        \"bslq_s8\" => p!(\"vsl.v16i8\", (i8x16, i8x16, i8x16) -> i8x16),\n+        \"padd_s8\" => p!(\"vpadd.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"padd_s16\" => p!(\"vpadd.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"padd_s32\" => p!(\"vpadd.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"padd_u8\" => p!(\"vpadd.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"padd_u16\" => p!(\"vpadd.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"padd_u32\" => p!(\"vpadd.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"padd_f32\" => p!(\"vpadd.v2f32\", (f32x2, f32x2) -> f32x2),\n+        \"paddl_s8\" => p!(\"vpaddls.v4i16.v8i8\", (i8x8) -> i16x4),\n+        \"paddlq_s8\" => p!(\"vpaddls.v8i16.v16i8\", (i8x16) -> i16x8),\n+        \"paddl_s16\" => p!(\"vpaddls.v2i32.v4i16\", (i16x4) -> i32x2),\n+        \"paddlq_s16\" => p!(\"vpaddls.v4i32.v8i16\", (i16x8) -> i32x4),\n+        \"paddl_s32\" => p!(\"vpaddls.v1i64.v2i32\", (i32x2) -> i64x1),\n+        \"paddlq_s32\" => p!(\"vpaddls.v2i64.v4i32\", (i32x4) -> i64x2),\n+        \"paddl_u8\" => p!(\"vpaddlu.v4i16.v8i8\", (i8x8) -> i16x4),\n+        \"paddlq_u8\" => p!(\"vpaddlu.v8i16.v16i8\", (i8x16) -> i16x8),\n+        \"paddl_u16\" => p!(\"vpaddlu.v2i32.v4i16\", (i16x4) -> i32x2),\n+        \"paddlq_u16\" => p!(\"vpaddlu.v4i32.v8i16\", (i16x8) -> i32x4),\n+        \"paddl_u32\" => p!(\"vpaddlu.v1i64.v2i32\", (i32x2) -> i64x1),\n+        \"paddlq_u32\" => p!(\"vpaddlu.v2i64.v4i32\", (i32x4) -> i64x2),\n+        \"padal_s8\" => p!(\"vpadals.v4i16.v8i8\", (i16x4, i8x8) -> i16x4),\n+        \"padalq_s8\" => p!(\"vpadals.v8i16.v16i8\", (i16x8, i8x16) -> i16x8),\n+        \"padal_s16\" => p!(\"vpadals.v2i32.v4i16\", (i32x2, i16x4) -> i32x2),\n+        \"padalq_s16\" => p!(\"vpadals.v4i32.v8i16\", (i32x4, i16x8) -> i32x4),\n+        \"padal_s32\" => p!(\"vpadals.v1i64.v2i32\", (i64x1, i32x2) -> i64x1),\n+        \"padalq_s32\" => p!(\"vpadals.v2i64.v4i32\", (i64x2, i32x4) -> i64x2),\n+        \"padal_u8\" => p!(\"vpadalu.v4i16.v8i8\", (i16x4, i8x8) -> i16x4),\n+        \"padalq_u8\" => p!(\"vpadalu.v8i16.v16i8\", (i16x8, i8x16) -> i16x8),\n+        \"padal_u16\" => p!(\"vpadalu.v2i32.v4i16\", (i32x2, i16x4) -> i32x2),\n+        \"padalq_u16\" => p!(\"vpadalu.v4i32.v8i16\", (i32x4, i16x8) -> i32x4),\n+        \"padal_u32\" => p!(\"vpadalu.v1i64.v2i32\", (i64x1, i32x2) -> i64x1),\n+        \"padalq_u32\" => p!(\"vpadalu.v2i64.v4i32\", (i64x2, i32x4) -> i64x2),\n+        \"pmax_s16\" => p!(\"vpmaxs.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"pmax_s32\" => p!(\"vpmaxs.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"pmax_s8\" => p!(\"vpmaxs.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"pmax_u16\" => p!(\"vpmaxu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"pmax_u32\" => p!(\"vpmaxu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"pmax_u8\" => p!(\"vpmaxu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"pmin_s16\" => p!(\"vpmins.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"pmin_s32\" => p!(\"vpmins.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"pmin_s8\" => p!(\"vpmins.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"pmin_u16\" => p!(\"vpminu.v4i16\", (i16x4, i16x4) -> i16x4),\n+        \"pmin_u32\" => p!(\"vpminu.v2i32\", (i32x2, i32x2) -> i32x2),\n+        \"pmin_u8\" => p!(\"vpminu.v8i8\", (i8x8, i8x8) -> i8x8),\n+        \"tbl1_s8\" => p!(\"vtbl1\", (i8x8, i8x8) -> i8x8),\n+        \"tbl1_u8\" => p!(\"vtbl1\", (i8x8, i8x8) -> i8x8),\n+        // these aren't exactly the C intrinsics (they take one argument)\n+        \"tbl2_s8\" => p!(\"vtbl2\", (i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbl2_u8\" => p!(\"vtbl2\", (i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbl3_s8\" => p!(\"vtbl3\", (i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbl3_u8\" => p!(\"vtbl3\", (i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbl4_s8\" => p!(\"vtbl4\", (i8x8, i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbl4_u8\" => p!(\"vtbl4\", (i8x8, i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx1_s8\" => p!(\"vtbx1\", (i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx1_u8\" => p!(\"vtbx1\", (i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx2_s8\" => p!(\"vtbx2\", (i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx2_u8\" => p!(\"vtbx2\", (i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx3_s8\" => p!(\"vtbx3\", (i8x8, i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx3_u8\" => p!(\"vtbx3\", (i8x8, i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx4_s8\" => p!(\"vtbx4\", (i8x8, i8x8, i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        \"tbx4_u8\" => p!(\"vtbx4\", (i8x8, i8x8, i8x8, i8x8, i8x8, i8x8) -> i8x8),\n+        _ => return None,\n+    })\n+}"}, {"sha": "134b4c66419b6c4408d9aa9006b269b68364bb40", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(stage0, feature(custom_attribute))]\n+#![crate_name = \"rustc_platform_intrinsics\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![staged_api]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![feature(staged_api, rustc_private)]\n+\n+extern crate rustc_llvm as llvm;\n+extern crate rustc;\n+\n+use rustc::middle::ty;\n+\n+pub struct Intrinsic {\n+    pub inputs: Vec<Type>,\n+    pub output: Type,\n+\n+    pub definition: IntrinsicDef,\n+}\n+\n+#[derive(Clone, Hash, Eq, PartialEq)]\n+pub enum Type {\n+    Integer(u8),\n+    Float(u8),\n+    Pointer(Box<Type>),\n+    Vector(Box<Type>, u8),\n+}\n+\n+pub enum IntrinsicDef {\n+    Named(&'static str),\n+}\n+\n+fn i(width: u8) -> Type { Type::Integer(width) }\n+fn f(width: u8) -> Type { Type::Float(width) }\n+fn v(x: Type, length: u8) -> Type { Type::Vector(Box::new(x), length) }\n+\n+macro_rules! ty {\n+    (f32x8) => (v(f(32), 8));\n+    (f64x4) => (v(f(64), 4));\n+\n+    (i8x32) => (v(i(8), 32));\n+    (i16x16) => (v(i(16), 16));\n+    (i32x8) => (v(i(32), 8));\n+    (i64x4) => (v(i(64), 4));\n+\n+    (f32x4) => (v(f(32), 4));\n+    (f64x2) => (v(f(64), 2));\n+\n+    (i8x16) => (v(i(8), 16));\n+    (i16x8) => (v(i(16), 8));\n+    (i32x4) => (v(i(32), 4));\n+    (i64x2) => (v(i(64), 2));\n+\n+    (f32x2) => (v(f(32), 2));\n+    (i8x8) => (v(i(8), 8));\n+    (i16x4) => (v(i(16), 4));\n+    (i32x2) => (v(i(32), 2));\n+    (i64x1)=> (v(i(64), 1));\n+\n+    (i64) => (i(64));\n+    (i32) => (i(32));\n+    (i16) => (i(16));\n+    (i8) => (i(8));\n+    (f32) => (f(32));\n+    (f64) => (f(64));\n+}\n+macro_rules! plain {\n+    ($name: expr, ($($inputs: tt),*) -> $output: tt) => {\n+        Intrinsic {\n+            inputs: vec![$(ty!($inputs)),*],\n+            output: ty!($output),\n+            definition: ::IntrinsicDef::Named($name)\n+        }\n+    }\n+}\n+\n+mod x86;\n+mod arm;\n+mod aarch64;\n+\n+impl Intrinsic {\n+    pub fn find<'tcx>(tcx: &ty::ctxt<'tcx>, name: &str) -> Option<Intrinsic> {\n+        if name.starts_with(\"x86_\") {\n+            x86::find(tcx, &name[\"x86_\".len()..])\n+        } else if name.starts_with(\"arm_\") {\n+            arm::find(tcx, &name[\"arm_\".len()..])\n+        } else if name.starts_with(\"aarch64_\") {\n+            aarch64::find(tcx, &name[\"aarch64_\".len()..])\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "cab7ab2fecb82c755be50559709386f5546aebb8", "filename": "src/librustc_platform_intrinsics/x86.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_platform_intrinsics%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fx86.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,188 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Intrinsic, i, f, v};\n+use rustc::middle::ty;\n+\n+macro_rules! p {\n+    ($name: expr, ($($inputs: tt),*) -> $output: tt) => {\n+        plain!(concat!(\"llvm.x86.\", $name), ($($inputs),*) -> $output)\n+    }\n+}\n+\n+pub fn find<'tcx>(_tcx: &ty::ctxt<'tcx>, name: &str) -> Option<Intrinsic> {\n+    if name.starts_with(\"mm_\") {\n+        Some(match &name[\"mm_\".len()..] {\n+            \"sqrt_ps\" => plain!(\"llvm.sqrt.v4f32\", (f32x4) -> f32x4),\n+            \"sqrt_pd\" => plain!(\"llvm.sqrt.v2f64\", (f64x2) -> f64x2),\n+\n+            \"movemask_ps\" => p!(\"sse.movmsk.ps\", (f32x4) -> i32),\n+            \"max_ps\" => p!(\"sse.max.ps\", (f32x4, f32x4) -> f32x4),\n+            \"min_ps\" => p!(\"sse.min.ps\", (f32x4, f32x4) -> f32x4),\n+            \"rsqrt_ps\" => p!(\"sse.rsqrt.ps\", (f32x4) -> f32x4),\n+            \"rcp_ps\" => p!(\"sse.rcp.ps\", (f32x4) -> f32x4),\n+\n+            \"adds_epi16\" => p!(\"sse2.padds.w\", (i16x8, i16x8) -> i16x8),\n+            \"adds_epi8\" => p!(\"sse2.padds.b\", (i8x16, i8x16) -> i8x16),\n+            \"adds_epu16\" => p!(\"sse2.paddus.w\", (i16x8, i16x8) -> i16x8),\n+            \"adds_epu8\" => p!(\"sse2.paddus.b\", (i8x16, i8x16) -> i8x16),\n+            \"avg_epu16\" => p!(\"sse2.pavg.w\", (i16x8, i16x8) -> i16x8),\n+            \"avg_epu8\" => p!(\"sse2.pavg.b\", (i8x16, i8x16) -> i8x16),\n+            \"madd_epi16\" => p!(\"sse2.pmadd.wd\", (i16x8, i16x8) -> i32x4),\n+            \"max_epi16\" => p!(\"sse2.pmaxs.w\", (i16x8, i16x8) -> i16x8),\n+            \"max_epu8\" => p!(\"sse2.pmaxu.b\", (i8x16, i8x16) -> i8x16),\n+            \"max_pd\" => p!(\"sse2.max.pd\", (f64x2, f64x2) -> f64x2),\n+            \"min_epi16\" => p!(\"sse2.pmins.w\", (i16x8, i16x8) -> i16x8),\n+            \"min_epu8\" => p!(\"sse2.pminu.b\", (i8x16, i8x16) -> i8x16),\n+            \"min_pd\" => p!(\"sse2.min.pd\", (f64x2, f64x2) -> f64x2),\n+            \"movemask_pd\" => p!(\"sse2.movmsk.pd\", (f64x2) -> i32),\n+            \"movemask_epi8\" => p!(\"sse2.pmovmskb.128\", (i8x16) -> i32),\n+            \"mul_epu32\" => p!(\"sse2.pmulu.dq\", (i32x4, i32x4) -> i64x2),\n+            \"mulhi_epi16\" => p!(\"sse2.pmulh.w\", (i8x16, i8x16) -> i8x16),\n+            \"mulhi_epu16\" => p!(\"sse2.pmulhu.w\", (i8x16, i8x16) -> i8x16),\n+            \"packs_epi16\" => p!(\"sse2.packsswb.128\", (i16x8, i16x8) -> i8x16),\n+            \"packs_epi32\" => p!(\"sse2.packssdw.128\", (i32x4, i32x4) -> i16x8),\n+            \"packus_epi16\" => p!(\"sse2.packuswb.128\", (i16x8, i16x8) -> i8x16),\n+            \"sad_epu8\" => p!(\"sse2.psad.bw\", (i8x16, i8x16) -> i64x2),\n+            \"subs_epi16\" => p!(\"sse2.psubs.w\", (i16x8, i16x8) -> i16x8),\n+            \"subs_epi8\" => p!(\"sse2.psubs.b\", (i8x16, i8x16) -> i8x16),\n+            \"subs_epu16\" => p!(\"sse2.psubus.w\", (i16x8, i16x8) -> i16x8),\n+            \"subs_epu8\" => p!(\"sse2.psubus.b\", (i8x16, i8x16) -> i8x16),\n+\n+            \"addsub_pd\" => p!(\"sse3.addsub.pd\", (f64x2, f64x2) -> f64x2),\n+            \"addsub_ps\" => p!(\"sse3.addsub.ps\", (f32x4, f32x4) -> f32x4),\n+            \"hadd_pd\" => p!(\"sse3.hadd.pd\", (f64x2, f64x2) -> f64x2),\n+            \"hadd_ps\" => p!(\"sse3.hadd.ps\", (f32x4, f32x4) -> f32x4),\n+            \"hsub_pd\" => p!(\"sse3.hsub.pd\", (f64x2, f64x2) -> f64x2),\n+            \"hsub_ps\" => p!(\"sse3.hsub.ps\", (f32x4, f32x4) -> f32x4),\n+\n+            \"abs_epi16\" => p!(\"ssse3.pabs.w.128\", (i16x8) -> i16x8),\n+            \"abs_epi32\" => p!(\"ssse3.pabs.d.128\", (i32x4) -> i32x4),\n+            \"abs_epi8\" => p!(\"ssse3.pabs.b.128\", (i8x16) -> i8x16),\n+            \"hadd_epi16\" => p!(\"ssse3.phadd.w.128\", (i16x8, i16x8) -> i16x8),\n+            \"hadd_epi32\" => p!(\"ssse3.phadd.d.128\", (i32x4, i32x4) -> i32x4),\n+            \"hadds_epi16\" => p!(\"ssse3.phadd.sw.128\", (i16x8, i16x8) -> i16x8),\n+            \"hsub_epi16\" => p!(\"ssse3.phsub.w.128\", (i16x8, i16x8) -> i16x8),\n+            \"hsub_epi32\" => p!(\"ssse3.phsub.d.128\", (i32x4, i32x4) -> i32x4),\n+            \"hsubs_epi16\" => p!(\"ssse3.phsub.sw.128\", (i16x8, i16x8) -> i16x8),\n+            \"maddubs_epi16\" => p!(\"ssse3.pmadd.ub.sw.128\", (i8x16, i8x16) -> i16x8),\n+            \"mulhrs_epi16\" => p!(\"ssse3.pmul.hr.sw.128\", (i16x8, i16x8) -> i16x8),\n+            \"shuffle_epi8\" => p!(\"ssse3.pshuf.b.128\", (i8x16, i8x16) -> i8x16),\n+            \"sign_epi16\" => p!(\"ssse3.psign.w.128\", (i16x8, i16x8) -> i16x8),\n+            \"sign_epi32\" => p!(\"ssse3.psign.d.128\", (i32x4, i32x4) -> i32x4),\n+            \"sign_epi8\" => p!(\"ssse3.psign.b.128\", (i8x16, i8x16) -> i8x16),\n+\n+            \"max_epi32\" => p!(\"sse41.pmaxsd\", (i32x4, i32x4) -> i32x4),\n+            \"max_epi8\" => p!(\"sse41.pmaxsb\", (i8x16, i8x16) -> i8x16),\n+            \"max_epu16\" => p!(\"sse41.pmaxuw\", (i16x8, i16x8) -> i16x8),\n+            \"max_epu32\" => p!(\"sse41.pmaxud\", (i32x4, i32x4) -> i32x4),\n+            \"min_epi32\" => p!(\"sse41.pminsd\", (i32x4, i32x4) -> i32x4),\n+            \"min_epi8\" => p!(\"sse41.pminsb\", (i8x16, i8x16) -> i8x16),\n+            \"min_epu16\" => p!(\"sse41.pminuw\", (i16x8, i16x8) -> i16x8),\n+            \"min_epu32\" => p!(\"sse41.pminud\", (i32x4, i32x4) -> i32x4),\n+            \"minpos_epu16\" => p!(\"sse41.phminposuw\", (i16x8) -> i16x8),\n+            \"mul_epi32\" => p!(\"sse41.muldq\", (i32x4, i32x4) -> i64x2),\n+            \"packus_epi32\" => p!(\"sse41.packusdw\", (i32x4, i32x4) -> i16x8),\n+            \"testc_si128\" => p!(\"sse41.ptestc\", (i64x2, i64x2) -> i32),\n+            \"testnzc_si128\" => p!(\"sse41.ptestnzc\", (i64x2, i64x2) -> i32),\n+            \"testz_si128\" => p!(\"sse41.ptestz\", (i64x2, i64x2) -> i32),\n+\n+            \"permutevar_pd\" => p!(\"avx.vpermilvar.pd\", (f64x2, i64x2) -> f64x2),\n+            \"permutevar_ps\" => p!(\"avx.vpermilvar.ps\", (f32x4, i32x4) -> f32x4),\n+            \"testc_pd\" => p!(\"avx.vtestc.pd\", (f64x2, f64x2) -> i32),\n+            \"testc_ps\" => p!(\"avx.vtestc.ps\", (f32x4, f32x4) -> i32),\n+            \"testnzc_pd\" => p!(\"avx.vtestnzc.pd\", (f64x2, f64x2) -> i32),\n+            \"testnzc_ps\" => p!(\"avx.vtestnzc.ps\", (f32x4, f32x4) -> i32),\n+            \"testz_pd\" => p!(\"avx.vtestz.pd\", (f64x2, f64x2) -> i32),\n+            \"testz_ps\" => p!(\"avx.vtestz.ps\", (f32x4, f32x4) -> i32),\n+\n+            _ => return None\n+        })\n+    } else if name.starts_with(\"mm256_\") {\n+        Some(match &name[\"mm256_\".len()..] {\n+            \"addsub_pd\" => p!(\"avx.addsub.pd.256\", (f64x4, f64x4) -> f64x4),\n+            \"addsub_ps\" => p!(\"avx.addsub.ps.256\", (f32x8, f32x8) -> f32x8),\n+            \"hadd_pd\" => p!(\"avx.hadd.pd.256\", (f64x4, f64x4) -> f64x4),\n+            \"hadd_ps\" => p!(\"avx.hadd.ps.256\", (f32x8, f32x8) -> f32x8),\n+            \"hsub_pd\" => p!(\"avx.hsub.pd.256\", (f64x4, f64x4) -> f64x4),\n+            \"hsub_ps\" => p!(\"avx.hsub.ps.256\", (f32x8, f32x8) -> f32x8),\n+            \"max_pd\" => p!(\"avx.max.pd.256\", (f64x4, f64x4) -> f64x4),\n+            \"max_ps\" => p!(\"avx.max.ps.256\", (f32x8, f32x8) -> f32x8),\n+            \"min_pd\" => p!(\"avx.min.pd.256\", (f64x4, f64x4) -> f64x4),\n+            \"min_ps\" => p!(\"avx.min.ps.256\", (f32x8, f32x8) -> f32x8),\n+            \"permutevar_pd\" => p!(\"avx.vpermilvar.pd.256\", (f64x4, i64x4) -> f64x4),\n+            \"permutevar_ps\" => p!(\"avx.vpermilvar.ps.256\", (f32x8, i32x8) -> f32x8),\n+            \"rcp_ps\" => p!(\"avx.rcp.ps.256\", (f32x8) -> f32x8),\n+            \"rsqrt_ps\" => p!(\"avx.rsqrt.ps.256\", (f32x8) -> f32x8),\n+            \"sqrt_pd\" => p!(\"llvm.sqrt.v4f64\", (f64x4) -> f64x4),\n+            \"sqrt_ps\" => p!(\"llvm.sqrt.v8f32\", (f32x8) -> f32x8),\n+            \"testc_pd\" => p!(\"avx.vtestc.pd.256\", (f64x4, f64x4) -> i32),\n+            \"testc_ps\" => p!(\"avx.vtestc.ps.256\", (f32x8, f32x8) -> i32),\n+            \"testnzc_pd\" => p!(\"avx.vtestnzc.pd.256\", (f64x4, f64x4) -> i32),\n+            \"testnzc_ps\" => p!(\"avx.vtestnzc.ps.256\", (f32x8, f32x8) -> i32),\n+            \"testz_pd\" => p!(\"avx.vtestz.pd.256\", (f64x4, f64x4) -> i32),\n+            \"testz_ps\" => p!(\"avx.vtestz.ps.256\", (f32x8, f32x8) -> i32),\n+\n+            \"abs_epi16\" => p!(\"avx2.pabs.w\", (i16x16) -> i16x16),\n+            \"abs_epi32\" => p!(\"avx2.pabs.d\", (i32x8) -> i32x8),\n+            \"abs_epi8\" => p!(\"avx2.pabs.b\", (i8x32) -> i8x32),\n+            \"adds_epi16\" => p!(\"avx2.padds.w\", (i16x16, i16x16) -> i16x16),\n+            \"adds_epi8\" => p!(\"avx2.padds.b\", (i8x32, i8x32) -> i8x32),\n+            \"adds_epu16\" => p!(\"avx2.paddus.w\", (i16x16, i16x16) -> i16x16),\n+            \"adds_epu8\" => p!(\"avx2.paddus.b\", (i8x32, i8x32) -> i8x32),\n+            \"avg_epu16\" => p!(\"avx2.pavg.w\", (i16x16, i16x16) -> i16x16),\n+            \"avg_epu8\" => p!(\"avx2.pavg.b\", (i8x32, i8x32) -> i8x32),\n+            \"hadd_epi16\" => p!(\"avx2.phadd.w\", (i16x16, i16x16) -> i16x16),\n+            \"hadd_epi32\" => p!(\"avx2.phadd.d\", (i32x8, i32x8) -> i32x8),\n+            \"hadds_epi16\" => p!(\"avx2.phadd.sw\", (i16x16, i16x16) -> i16x16),\n+            \"hsub_epi16\" => p!(\"avx2.phsub.w\", (i16x16, i16x16) -> i16x16),\n+            \"hsub_epi32\" => p!(\"avx2.phsub.d\", (i32x8, i32x8) -> i32x8),\n+            \"hsubs_epi16\" => p!(\"avx2.phsub.sw\", (i16x16, i16x16) -> i16x16),\n+            \"madd_epi16\" => p!(\"avx2.pmadd.wd\", (i16x16, i16x16) -> i32x8),\n+            \"maddubs_epi16\" => p!(\"avx2.pmadd.ub.sw\", (i8x32, i8x32) -> i16x16),\n+            \"max_epi16\" => p!(\"avx2.pmaxs.w\", (i16x16, i16x16) -> i16x16),\n+            \"max_epi32\" => p!(\"avx2.pmaxs.d\", (i32x8, i32x8) -> i32x8),\n+            \"max_epi8\" => p!(\"avx2.pmaxs.b\", (i8x32, i8x32) -> i8x32),\n+            \"max_epu16\" => p!(\"avx2.pmaxu.w\", (i16x16, i16x16) -> i16x16),\n+            \"max_epu32\" => p!(\"avx2.pmaxu.d\", (i32x8, i32x8) -> i32x8),\n+            \"max_epu8\" => p!(\"avx2.pmaxu.b\", (i8x32, i8x32) -> i8x32),\n+            \"min_epi16\" => p!(\"avx2.pmins.w\", (i16x16, i16x16) -> i16x16),\n+            \"min_epi32\" => p!(\"avx2.pmins.d\", (i32x8, i32x8) -> i32x8),\n+            \"min_epi8\" => p!(\"avx2.pmins.b\", (i8x32, i8x32) -> i8x32),\n+            \"min_epu16\" => p!(\"avx2.pminu.w\", (i16x16, i16x16) -> i16x16),\n+            \"min_epu32\" => p!(\"avx2.pminu.d\", (i32x8, i32x8) -> i32x8),\n+            \"min_epu8\" => p!(\"avx2.pminu.b\", (i8x32, i8x32) -> i8x32),\n+            \"mul_epi32\" => p!(\"avx2.mul.dq\", (i32x8, i32x8) -> i64x4),\n+            \"mul_epu32\" => p!(\"avx2.mulu.dq\", (i32x8, i32x8) -> i64x4),\n+            \"mulhi_epi16\" => p!(\"avx2.pmulh.w\", (i8x32, i8x32) -> i8x32),\n+            \"mulhi_epu16\" => p!(\"avx2.pmulhu.w\", (i8x32, i8x32) -> i8x32),\n+            \"mulhrs_epi16\" => p!(\"avx2.pmul.hr.sw\", (i16x16, i16x16) -> i16x16),\n+            \"packs_epi16\" => p!(\"avx2.packsswb\", (i16x16, i16x16) -> i8x32),\n+            \"packs_epi32\" => p!(\"avx2.packssdw\", (i32x8, i32x8) -> i16x16),\n+            \"packus_epi16\" => p!(\"avx2.packuswb\", (i16x16, i16x16) -> i8x32),\n+            \"packus_epi32\" => p!(\"avx2.packusdw\", (i32x8, i32x8) -> i16x16),\n+            \"permutevar8x32_epi32\" => p!(\"avx2.permd\", (i32x8, i32x8) -> i32x8),\n+            \"permutevar8x32_ps\" => p!(\"avx2.permps\", (f32x8, i32x8) -> i32x8),\n+            \"sad_epu8\" => p!(\"avx2.psad.bw\", (i8x32, i8x32) -> i64x4),\n+            \"shuffle_epi8\" => p!(\"avx2.pshuf.b\", (i8x32, i8x32) -> i8x32),\n+            \"sign_epi16\" => p!(\"avx2.psign.w\", (i16x16, i16x16) -> i16x16),\n+            \"sign_epi32\" => p!(\"avx2.psign.d\", (i32x8, i32x8) -> i32x8),\n+            \"sign_epi8\" => p!(\"avx2.psign.b\", (i8x32, i8x32) -> i8x32),\n+            \"subs_epi16\" => p!(\"avx2.psubs.w\", (i16x16, i16x16) -> i16x16),\n+            \"subs_epi8\" => p!(\"avx2.psubs.b\", (i8x32, i8x32) -> i8x32),\n+            \"subs_epu16\" => p!(\"avx2.psubus.w\", (i16x16, i16x16) -> i16x16),\n+            \"subs_epu8\" => p!(\"avx2.psubus.b\", (i8x32, i8x32) -> i8x32),\n+\n+            _ => return None,\n+        })\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "23f21f337f30238c26b15c3bc163e48c0f81e819", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -54,6 +54,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_llvm as llvm;\n+extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n \n #[macro_use] extern crate log;"}, {"sha": "0d34cce919a64993b5208924be3b5366f80be141", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -615,6 +615,9 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n         attr::ReprPacked => {\n             cx.tcx().sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n+        attr::ReprSimd => {\n+            cx.tcx().sess.bug(\"range_to_inttype: found ReprSimd on an enum\");\n+        }\n     }\n     for &ity in attempts {\n         if bounds_usable(cx, ity, bounds) {"}, {"sha": "6be2bb0846463146ad71490219486f598b209e21", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -91,7 +91,7 @@ use std::collections::{HashMap, HashSet};\n use std::mem;\n use std::str;\n use std::{i8, i16, i32, i64};\n-use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n+use syntax::abi::{Rust, RustCall, RustIntrinsic, PlatformIntrinsic, Abi};\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -348,17 +348,14 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n                                       t: Ty<'tcx>,\n+                                      ret_ty: Type,\n                                       op: ast::BinOp_,\n                                       debug_loc: DebugLoc)\n                                       -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n-            // The comparison operators for floating point vectors are challenging.\n-            // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n-            // then bitcast to a floating point vector, the result will be `-NaN`\n-            // for each truth value. Because of this they are unsupported.\n-            bcx.sess().bug(\"compare_simd_types: comparison operators \\\n-                            not supported for floating point SIMD types\")\n+            let cmp = bin_op_to_fcmp_predicate(bcx.ccx(), op);\n+            return SExt(bcx, FCmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty);\n         },\n         ty::TyUint(_) => false,\n         ty::TyInt(_) => true,\n@@ -370,7 +367,7 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), val_ty(lhs))\n+    SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty)\n }\n \n // Iterates through the elements of a structural type.\n@@ -674,7 +671,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 Rust | RustCall => {\n                     get_extern_rust_fn(ccx, t, &name[..], did)\n                 }\n-                RustIntrinsic => {\n+                RustIntrinsic | PlatformIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {"}, {"sha": "d201114fd82f97b57eb919e92e49e118ebd48f9e", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -150,7 +150,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefFn(did, _) if match expr_ty.sty {\n-                ty::TyBareFn(_, ref f) => f.abi == synabi::RustIntrinsic,\n+                ty::TyBareFn(_, ref f) => f.abi == synabi::RustIntrinsic ||\n+                                          f.abi == synabi::PlatformIntrinsic,\n                 _ => false\n             } => {\n                 let substs = common::node_id_substs(bcx.ccx(),\n@@ -671,7 +672,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             (d.llfn, Some(d.llself))\n         }\n         Intrinsic(node, substs) => {\n-            assert!(abi == synabi::RustIntrinsic);\n+            assert!(abi == synabi::RustIntrinsic || abi == synabi::PlatformIntrinsic);\n             assert!(dest.is_some());\n \n             let call_info = match debug_loc {\n@@ -701,7 +702,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     // Intrinsics should not become actual functions.\n     // We trans them in place in `trans_intrinsic_call`\n-    assert!(abi != synabi::RustIntrinsic);\n+    assert!(abi != synabi::RustIntrinsic && abi != synabi::PlatformIntrinsic);\n \n     let is_rust_fn = abi == synabi::Rust || abi == synabi::RustCall;\n "}, {"sha": "9ba45e0d481a3e04315a496603b028e1877343b4", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -1797,7 +1797,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if is_simd {\n-            base::compare_simd_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n+            base::compare_simd_types(bcx, lhs, rhs, intype, val_ty(lhs), op.node, binop_debug_loc)\n         } else {\n             base::compare_scalar_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n         }"}, {"sha": "b316d105d0cdf7d9b7c86cb4422cbc600b41ad33", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -34,7 +34,7 @@ use middle::subst::Substs;\n use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n-use syntax::abi::{RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n+use syntax::abi::{PlatformIntrinsic, RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::ast;\n@@ -81,6 +81,10 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n             // Intrinsics are emitted at the call site\n             ccx.sess().bug(\"asked to register intrinsic fn\");\n         }\n+        PlatformIntrinsic => {\n+            // Intrinsics are emitted at the call site\n+            ccx.sess().bug(\"asked to register platform intrinsic fn\");\n+        }\n \n         Rust => {\n             // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n@@ -475,7 +479,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n \n         if let ast::ForeignItemFn(ref decl, _) = foreign_item.node {\n             match foreign_mod.abi {\n-                Rust | RustIntrinsic => {}\n+                Rust | RustIntrinsic | PlatformIntrinsic => {}\n                 abi => {\n                     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n@@ -612,7 +616,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // normal Rust function. This will be the type of the wrappee fn.\n         match t.sty {\n             ty::TyBareFn(_, ref f) => {\n-                assert!(f.abi != Rust && f.abi != RustIntrinsic);\n+                assert!(f.abi != Rust && f.abi != RustIntrinsic && f.abi != PlatformIntrinsic);\n             }\n             _ => {\n                 ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {:?}, \\"}, {"sha": "ded748e9894a01b383c21cbb565bb5218def2978", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 315, "deletions": 2, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -11,6 +11,8 @@\n #![allow(non_upper_case_globals)]\n \n use arena::TypedArena;\n+use intrinsics::{self, Intrinsic};\n+use libc;\n use llvm;\n use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef, TypeKind};\n use middle::subst;\n@@ -23,6 +25,7 @@ use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n+use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n@@ -37,8 +40,11 @@ use middle::ty::{self, Ty, HasTypeFlags};\n use middle::subst::Substs;\n use syntax::abi::{self, RustIntrinsic};\n use syntax::ast;\n+use syntax::ptr::P;\n use syntax::parse::token;\n \n+use std::cmp::Ordering;\n+\n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n     let name = match &*item.ident.name.as_str() {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n@@ -342,6 +348,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n+    // save the actual AST arguments for later (some places need to do\n+    // const-evaluation on them)\n+    let expr_arguments = match args {\n+        callee::ArgExprs(args) => Some(args),\n+        _ => None,\n+    };\n+\n     // Push the arguments.\n     let mut llargs = Vec::new();\n     bcx = callee::trans_args(bcx,\n@@ -800,7 +813,16 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 _ => C_null(llret_ty)\n             }\n         }\n-\n+        (_, name) if name.starts_with(\"simd_\") => {\n+            generic_simd_intrinsic(bcx, name,\n+                                   substs,\n+                                   callee_ty,\n+                                   expr_arguments,\n+                                   &llargs,\n+                                   ret_ty, llret_ty,\n+                                   call_debug_location,\n+                                   call_info)\n+        }\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n         (_, name) if name.starts_with(\"atomic_\") => {\n@@ -897,7 +919,40 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         }\n \n-        (_, _) => ccx.sess().span_bug(foreign_item.span, \"unknown intrinsic\")\n+        (_, _) => {\n+            let intr = match Intrinsic::find(tcx, &name) {\n+                Some(intr) => intr,\n+                None => ccx.sess().span_bug(foreign_item.span, \"unknown intrinsic\"),\n+            };\n+            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type) -> Type {\n+                use intrinsics::Type::*;\n+                match *t {\n+                    Integer(x) => Type::ix(ccx, x as u64),\n+                    Float(x) => {\n+                        match x {\n+                            32 => Type::f32(ccx),\n+                            64 => Type::f64(ccx),\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                    Pointer(_) => unimplemented!(),\n+                    Vector(ref t, length) => Type::vector(&ty_to_type(ccx, t),\n+                                                          length as u64)\n+                }\n+            }\n+\n+            let inputs = intr.inputs.iter().map(|t| ty_to_type(ccx, t)).collect::<Vec<_>>();\n+            let outputs = ty_to_type(ccx, &intr.output);\n+            match intr.definition {\n+                intrinsics::IntrinsicDef::Named(name) => {\n+                    let f = declare::declare_cfn(ccx,\n+                                                 name,\n+                                                 Type::func(&inputs, &outputs),\n+                                                 tcx.mk_nil());\n+                    Call(bcx, f, &llargs, None, call_debug_location)\n+                }\n+            }\n+        }\n     };\n \n     if val_ty(llval) != Type::void(ccx) &&\n@@ -1263,3 +1318,261 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     *ccx.rust_try_fn().borrow_mut() = Some(rust_try);\n     return rust_try\n }\n+\n+fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n+    (bcx: Block<'blk, 'tcx>,\n+     name: &str,\n+     substs: subst::Substs<'tcx>,\n+     callee_ty: Ty<'tcx>,\n+     args: Option<&[P<ast::Expr>]>,\n+     llargs: &[ValueRef],\n+     ret_ty: Ty<'tcx>,\n+     llret_ty: Type,\n+     call_debug_location: DebugLoc,\n+     call_info: NodeIdAndSpan) -> ValueRef\n+{\n+    // macros for error handling:\n+    macro_rules! emit_error {\n+        ($msg: tt) => {\n+            emit_error!($msg, )\n+        };\n+        ($msg: tt, $($fmt: tt)*) => {\n+            bcx.sess().span_err(call_info.span,\n+                                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n+                                                 $msg),\n+                                         name, $($fmt)*));\n+        }\n+    }\n+    macro_rules! require {\n+        ($cond: expr, $($fmt: tt)*) => {\n+            if !$cond {\n+                emit_error!($($fmt)*);\n+                return C_null(llret_ty)\n+            }\n+        }\n+    }\n+    macro_rules! require_simd {\n+        ($ty: expr, $position: expr) => {\n+            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+        }\n+    }\n+\n+\n+\n+    let tcx = bcx.tcx();\n+    let arg_tys = match callee_ty.sty {\n+        ty::TyBareFn(_, ref f) => {\n+            bcx.tcx().erase_late_bound_regions(&f.sig.inputs())\n+        }\n+        _ => unreachable!()\n+    };\n+\n+    // every intrinsic takes a SIMD vector as its first argument\n+    require_simd!(arg_tys[0], \"input\");\n+    let in_ty = arg_tys[0];\n+    let in_elem = arg_tys[0].simd_type(tcx);\n+    let in_len = arg_tys[0].simd_size(tcx);\n+\n+    let comparison = match name {\n+        \"simd_eq\" => Some(ast::BiEq),\n+        \"simd_ne\" => Some(ast::BiNe),\n+        \"simd_lt\" => Some(ast::BiLt),\n+        \"simd_le\" => Some(ast::BiLe),\n+        \"simd_gt\" => Some(ast::BiGt),\n+        \"simd_ge\" => Some(ast::BiGe),\n+        _ => None\n+    };\n+\n+    if let Some(cmp_op) = comparison {\n+        require_simd!(ret_ty, \"return\");\n+\n+        let out_len = ret_ty.simd_size(tcx);\n+        require!(in_len == out_len,\n+                 \"expected return type with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\",\n+                 in_len, in_ty,\n+                 ret_ty, out_len);\n+        require!(llret_ty.element_type().kind() == llvm::Integer,\n+                 \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n+                 ret_ty,\n+                 ret_ty.simd_type(tcx));\n+\n+        return compare_simd_types(bcx,\n+                                  llargs[0],\n+                                  llargs[1],\n+                                  in_elem,\n+                                  llret_ty,\n+                                  cmp_op,\n+                                  call_debug_location)\n+    }\n+\n+    if name.starts_with(\"simd_shuffle\") {\n+        let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n+            Ok(n) => n,\n+            Err(_) => tcx.sess.span_bug(call_info.span,\n+                                        \"bad `simd_shuffle` instruction only caught in trans?\")\n+        };\n+\n+        require_simd!(ret_ty, \"return\");\n+\n+        let out_len = ret_ty.simd_size(tcx);\n+        require!(out_len == n,\n+                 \"expected return type of length {}, found `{}` with length {}\",\n+                 n, ret_ty, out_len);\n+        require!(in_elem == ret_ty.simd_type(tcx),\n+                 \"expected return element type `{}` (element of input `{}`), \\\n+                  found `{}` with element type `{}`\",\n+                 in_elem, in_ty,\n+                 ret_ty, ret_ty.simd_type(tcx));\n+\n+        let total_len = in_len as u64 * 2;\n+\n+        let vector = match args {\n+            Some(args) => &args[2],\n+            None => bcx.sess().span_bug(call_info.span,\n+                                        \"intrinsic call with unexpected argument shape\"),\n+        };\n+        let vector = consts::const_expr(bcx.ccx(), vector, tcx.mk_substs(substs), None).0;\n+\n+        let indices: Option<Vec<_>> = (0..n)\n+            .map(|i| {\n+                let arg_idx = i;\n+                let val = const_get_elt(bcx.ccx(), vector, &[i as libc::c_uint]);\n+                let c = const_to_opt_uint(val);\n+                match c {\n+                    None => {\n+                        emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n+                        None\n+                    }\n+                    Some(idx) if idx >= total_len => {\n+                        emit_error!(\"shuffle index #{} is out of bounds (limit {})\",\n+                                    arg_idx, total_len);\n+                        None\n+                    }\n+                    Some(idx) => Some(C_i32(bcx.ccx(), idx as i32)),\n+                }\n+            })\n+            .collect();\n+        let indices = match indices {\n+            Some(i) => i,\n+            None => return C_null(llret_ty)\n+        };\n+\n+        return ShuffleVector(bcx, llargs[0], llargs[1], C_vector(&indices))\n+    }\n+\n+    if name == \"simd_insert\" {\n+        require!(in_elem == arg_tys[2],\n+                 \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, arg_tys[2]);\n+        return InsertElement(bcx, llargs[0], llargs[2], llargs[1])\n+    }\n+    if name == \"simd_extract\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return ExtractElement(bcx, llargs[0], llargs[1])\n+    }\n+\n+    if name == \"simd_cast\" {\n+        require_simd!(ret_ty, \"return\");\n+        let out_len = ret_ty.simd_size(tcx);\n+        require!(in_len == out_len,\n+                 \"expected return type with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\",\n+                 in_len, in_ty,\n+                 ret_ty, out_len);\n+        // casting cares about nominal type, not just structural type\n+        let out_elem = ret_ty.simd_type(tcx);\n+\n+        if in_elem == out_elem { return llargs[0]; }\n+\n+        enum Style { Float, Int(/* is signed? */ bool), Unsupported }\n+\n+        let (in_style, in_width) = match in_elem.sty {\n+            // vectors of pointer-sized integers should've been\n+            // disallowed before here, so this unwrap is safe.\n+            ty::TyInt(i) => (Style::Int(true), i.bit_width().unwrap()),\n+            ty::TyUint(u) => (Style::Int(false), u.bit_width().unwrap()),\n+            ty::TyFloat(f) => (Style::Float, f.bit_width()),\n+            _ => (Style::Unsupported, 0)\n+        };\n+        let (out_style, out_width) = match out_elem.sty {\n+            ty::TyInt(i) => (Style::Int(true), i.bit_width().unwrap()),\n+            ty::TyUint(u) => (Style::Int(false), u.bit_width().unwrap()),\n+            ty::TyFloat(f) => (Style::Float, f.bit_width()),\n+            _ => (Style::Unsupported, 0)\n+        };\n+\n+        match (in_style, out_style) {\n+            (Style::Int(in_is_signed), Style::Int(_)) => {\n+                return match in_width.cmp(&out_width) {\n+                    Ordering::Greater => Trunc(bcx, llargs[0], llret_ty),\n+                    Ordering::Equal => llargs[0],\n+                    Ordering::Less => if in_is_signed {\n+                        SExt(bcx, llargs[0], llret_ty)\n+                    } else {\n+                        ZExt(bcx, llargs[0], llret_ty)\n+                    }\n+                }\n+            }\n+            (Style::Int(in_is_signed), Style::Float) => {\n+                return if in_is_signed {\n+                    SIToFP(bcx, llargs[0], llret_ty)\n+                } else {\n+                    UIToFP(bcx, llargs[0], llret_ty)\n+                }\n+            }\n+            (Style::Float, Style::Int(out_is_signed)) => {\n+                return if out_is_signed {\n+                    FPToSI(bcx, llargs[0], llret_ty)\n+                } else {\n+                    FPToUI(bcx, llargs[0], llret_ty)\n+                }\n+            }\n+            (Style::Float, Style::Float) => {\n+                return match in_width.cmp(&out_width) {\n+                    Ordering::Greater => FPTrunc(bcx, llargs[0], llret_ty),\n+                    Ordering::Equal => llargs[0],\n+                    Ordering::Less => FPExt(bcx, llargs[0], llret_ty)\n+                }\n+            }\n+            _ => {/* Unsupported. Fallthrough. */}\n+        }\n+        require!(false,\n+                 \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n+                 in_ty, in_elem,\n+                 ret_ty, out_elem);\n+    }\n+    macro_rules! arith {\n+        ($($name: ident: $($($p: ident),* => $call: expr),*;)*) => {\n+            $(\n+                if name == stringify!($name) {\n+                    match in_elem.sty {\n+                        $(\n+                            $(ty::$p(_))|* => {\n+                                return $call(bcx, llargs[0], llargs[1], call_debug_location)\n+                            }\n+                            )*\n+                        _ => {},\n+                    }\n+                    require!(false,\n+                             \"unsupported operation on `{}` with element `{}`\",\n+                             in_ty,\n+                             in_elem)\n+                })*\n+        }\n+    }\n+    arith! {\n+        simd_add: TyUint, TyInt => Add, TyFloat => FAdd;\n+        simd_sub: TyUint, TyInt => Sub, TyFloat => FSub;\n+        simd_mul: TyUint, TyInt => Mul, TyFloat => FMul;\n+        simd_div: TyFloat => FDiv;\n+        simd_shl: TyUint, TyInt => Shl;\n+        simd_shr: TyUint => LShr, TyInt => AShr;\n+        simd_and: TyUint, TyInt => And;\n+        simd_or: TyUint, TyInt => Or;\n+        simd_xor: TyUint, TyInt => Xor;\n+    }\n+    bcx.sess().span_bug(call_info.span, \"unknown SIMD intrinsic\");\n+}"}, {"sha": "6527136b60294e79600063508a987fc6448bdffd", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -90,7 +90,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         });\n \n     if let ast_map::NodeForeignItem(_) = map_node {\n-        if ccx.tcx().map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n+        let abi = ccx.tcx().map.get_foreign_abi(fn_id.node);\n+        if abi != abi::RustIntrinsic && abi != abi::PlatformIntrinsic {\n             // Foreign externs don't have to be monomorphized.\n             return (get_item_val(ccx, fn_id.node), mono_ty, true);\n         }"}, {"sha": "2e2f11bd133d8a0f92cb04a4b8d5e155588a4b91", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -182,6 +182,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         None => ()\n     }\n \n+    debug!(\"sizing_type_of {:?}\", t);\n     let llsizingty = match t.sty {\n         _ if !type_is_sized(cx.tcx(), t) => {\n             Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n@@ -223,7 +224,13 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::TyStruct(..) => {\n             if t.is_simd() {\n-                let llet = type_of(cx, t.simd_type(cx.tcx()));\n+                let e = t.simd_type(cx.tcx());\n+                if !e.is_machine() {\n+                    cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                              a non-machine element type `{}`\",\n+                                             t, e))\n+                }\n+                let llet = type_of(cx, e);\n                 let n = t.simd_size(cx.tcx()) as u64;\n                 ensure_array_fits_in_address_space(cx, llet, n, t);\n                 Type::vector(&llet, n)\n@@ -240,6 +247,10 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n     };\n \n+    debug!(\"--> mapped t={:?} to llsizingty={}\",\n+            t,\n+            cx.tn().type_to_string(llsizingty));\n+\n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n     llsizingty\n }\n@@ -405,7 +416,13 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       }\n       ty::TyStruct(def, ref substs) => {\n           if t.is_simd() {\n-              let llet = in_memory_type_of(cx, t.simd_type(cx.tcx()));\n+              let e = t.simd_type(cx.tcx());\n+              if !e.is_machine() {\n+                  cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                            a non-machine element type `{}`\",\n+                                           t, e))\n+              }\n+              let llet = in_memory_type_of(cx, e);\n               let n = t.simd_size(cx.tcx()) as u64;\n               ensure_array_fits_in_address_space(cx, llet, n, t);\n               Type::vector(&llet, n)\n@@ -426,8 +443,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyError(..) => cx.sess().bug(\"type_of with TyError\"),\n     };\n \n-    debug!(\"--> mapped t={:?} {:?} to llty={}\",\n-            t,\n+    debug!(\"--> mapped t={:?} to llty={}\",\n             t,\n             cx.tn().type_to_string(llty));\n "}, {"sha": "636f17db38c36302789cf2319fbaf63d353e2933", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,509 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Type-checking for the rust-intrinsic and platform-intrinsic\n+//! intrinsics that the compiler exposes.\n+\n+use astconv::AstConv;\n+use intrinsics;\n+use middle::subst;\n+use middle::ty::FnSig;\n+use middle::ty::{self, Ty};\n+use middle::ty_fold::TypeFolder;\n+use {CrateCtxt, require_same_types};\n+\n+use std::collections::{HashMap};\n+use syntax::abi;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+\n+fn equate_intrinsic_type<'a, 'tcx>(tcx: &ty::ctxt<'tcx>, it: &ast::ForeignItem,\n+                                   n_tps: usize,\n+                                   abi: abi::Abi,\n+                                   inputs: Vec<ty::Ty<'tcx>>,\n+                                   output: ty::FnOutput<'tcx>) {\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: ast::Unsafety::Unsafe,\n+        abi: abi,\n+        sig: ty::Binder(FnSig {\n+            inputs: inputs,\n+            output: output,\n+            variadic: false,\n+        }),\n+    }));\n+    let i_ty = tcx.lookup_item_type(local_def(it.id));\n+    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    if i_n_tps != n_tps {\n+        span_err!(tcx.sess, it.span, E0094,\n+            \"intrinsic has wrong number of type \\\n+             parameters: found {}, expected {}\",\n+             i_n_tps, n_tps);\n+    } else {\n+        require_same_types(tcx,\n+                           None,\n+                           false,\n+                           it.span,\n+                           i_ty.ty,\n+                           fty,\n+                           || {\n+                format!(\"intrinsic has wrong type: expected `{}`\",\n+                         fty)\n+            });\n+    }\n+}\n+\n+/// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n+/// and in libcore/intrinsics.rs\n+pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n+    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n+        let name = token::intern(&format!(\"P{}\", n));\n+        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+    }\n+\n+    let tcx = ccx.tcx;\n+    let name = it.ident.name.as_str();\n+    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n+        let split : Vec<&str> = name.split('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+\n+        //We only care about the operation here\n+        let (n_tps, inputs, output) = match split[1] {\n+            \"cxchg\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n+                                param(ccx, 0),\n+                                param(ccx, 0)),\n+                        param(ccx, 0)),\n+            \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n+                       param(ccx, 0)),\n+            \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+                        tcx.mk_nil()),\n+\n+            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n+            \"min\"  | \"umax\" | \"umin\" => {\n+                (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+                 param(ccx, 0))\n+            }\n+            \"fence\" | \"singlethreadfence\" => {\n+                (0, Vec::new(), tcx.mk_nil())\n+            }\n+            op => {\n+                span_err!(tcx.sess, it.span, E0092,\n+                    \"unrecognized atomic operation function: `{}`\", op);\n+                return;\n+            }\n+        };\n+        (n_tps, inputs, ty::FnConverging(output))\n+    } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n+        (0, Vec::new(), ty::FnDiverging)\n+    } else {\n+        let (n_tps, inputs, output) = match &name[..] {\n+            \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n+            \"size_of\" |\n+            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n+            \"size_of_val\" |  \"min_align_of_val\" => {\n+                (1, vec![\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n+                                    param(ccx, 0))\n+                 ], ccx.tcx.types.usize)\n+            }\n+            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n+            \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n+            \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n+            \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n+            \"move_val_init\" => {\n+                (1,\n+                 vec!(\n+                    tcx.mk_mut_ptr(param(ccx, 0)),\n+                    param(ccx, 0)\n+                  ),\n+               tcx.mk_nil())\n+            }\n+            \"drop_in_place\" => {\n+                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n+            }\n+            \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n+\n+            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n+            \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n+            \"offset\" | \"arith_offset\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  ccx.tcx.types.isize\n+               ),\n+               tcx.mk_ptr(ty::TypeAndMut {\n+                   ty: param(ccx, 0),\n+                   mutbl: ast::MutImmutable\n+               }))\n+            }\n+            \"copy\" | \"copy_nonoverlapping\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.types.usize,\n+               ),\n+               tcx.mk_nil())\n+            }\n+            \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  tcx.types.usize,\n+               ),\n+               tcx.mk_nil())\n+            }\n+            \"write_bytes\" | \"volatile_set_memory\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.types.u8,\n+                  tcx.types.usize,\n+               ),\n+               tcx.mk_nil())\n+            }\n+            \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"powif32\" => {\n+               (0,\n+                vec!( tcx.types.f32, tcx.types.i32 ),\n+                tcx.types.f32)\n+            }\n+            \"powif64\" => {\n+               (0,\n+                vec!( tcx.types.f64, tcx.types.i32 ),\n+                tcx.types.f64)\n+            }\n+            \"sinf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sinf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"cosf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"cosf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"powf32\" => {\n+               (0,\n+                vec!( tcx.types.f32, tcx.types.f32 ),\n+                tcx.types.f32)\n+            }\n+            \"powf64\" => {\n+               (0,\n+                vec!( tcx.types.f64, tcx.types.f64 ),\n+                tcx.types.f64)\n+            }\n+            \"expf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"expf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"exp2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"exp2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"logf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"logf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log10f32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log10f64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"fmaf32\" => {\n+                (0,\n+                 vec!( tcx.types.f32, tcx.types.f32, tcx.types.f32 ),\n+                 tcx.types.f32)\n+            }\n+            \"fmaf64\" => {\n+                (0,\n+                 vec!( tcx.types.f64, tcx.types.f64, tcx.types.f64 ),\n+                 tcx.types.f64)\n+            }\n+            \"fabsf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"fabsf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"copysignf32\"  => (0, vec!( tcx.types.f32, tcx.types.f32 ), tcx.types.f32),\n+            \"copysignf64\"  => (0, vec!( tcx.types.f64, tcx.types.f64 ), tcx.types.f64),\n+            \"floorf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"floorf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ceilf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"ceilf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"truncf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"truncf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"rintf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"rintf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"nearbyintf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"nearbyintf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"roundf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"roundf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ctpop8\"       => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctpop16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctpop32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctpop64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"ctlz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctlz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctlz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctlz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"cttz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"cttz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"cttz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"cttz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"bswap16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"bswap32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+\n+            \"volatile_load\" =>\n+                (1, vec!( tcx.mk_imm_ptr(param(ccx, 0)) ), param(ccx, 0)),\n+            \"volatile_store\" =>\n+                (1, vec!( tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ), tcx.mk_nil()),\n+\n+            \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i8, tcx.types.i8),\n+                tcx.mk_tup(vec!(tcx.types.i8, tcx.types.bool))),\n+\n+            \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i16, tcx.types.i16),\n+                tcx.mk_tup(vec!(tcx.types.i16, tcx.types.bool))),\n+\n+            \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i32, tcx.types.i32),\n+                tcx.mk_tup(vec!(tcx.types.i32, tcx.types.bool))),\n+\n+            \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i64, tcx.types.i64),\n+                tcx.mk_tup(vec!(tcx.types.i64, tcx.types.bool))),\n+\n+            \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.u8, tcx.types.u8),\n+                tcx.mk_tup(vec!(tcx.types.u8, tcx.types.bool))),\n+\n+            \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.u16, tcx.types.u16),\n+                tcx.mk_tup(vec!(tcx.types.u16, tcx.types.bool))),\n+\n+            \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n+                (0, vec!(tcx.types.u32, tcx.types.u32),\n+                tcx.mk_tup(vec!(tcx.types.u32, tcx.types.bool))),\n+\n+            \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.u64, tcx.types.u64),\n+                tcx.mk_tup(vec!(tcx.types.u64, tcx.types.bool))),\n+\n+            \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n+                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+\n+            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n+                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+\n+            \"return_address\" => (0, vec![], tcx.mk_imm_ptr(tcx.types.u8)),\n+\n+            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n+\n+            \"discriminant_value\" => (1, vec![\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n+                                   param(ccx, 0))], tcx.types.u64),\n+\n+            \"try\" => {\n+                let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n+                let fn_ty = ty::BareFnTy {\n+                    unsafety: ast::Unsafety::Normal,\n+                    abi: abi::Rust,\n+                    sig: ty::Binder(FnSig {\n+                        inputs: vec![mut_u8],\n+                        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+                        variadic: false,\n+                    }),\n+                };\n+                let fn_ty = tcx.mk_bare_fn(fn_ty);\n+                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8], mut_u8)\n+            }\n+\n+            ref other => {\n+                span_err!(tcx.sess, it.span, E0093,\n+                          \"unrecognized intrinsic function: `{}`\", *other);\n+                return;\n+            }\n+        };\n+        (n_tps, inputs, ty::FnConverging(output))\n+    };\n+    equate_intrinsic_type(\n+        tcx,\n+        it,\n+        n_tps,\n+        abi::RustIntrinsic,\n+        inputs,\n+        output\n+        )\n+}\n+\n+/// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n+pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n+                                     it: &ast::ForeignItem) {\n+    let param = |n| {\n+        let name = token::intern(&format!(\"P{}\", n));\n+        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+    };\n+\n+    let tcx = ccx.tcx;\n+    let i_ty = tcx.lookup_item_type(local_def(it.id));\n+    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    let name = it.ident.name.as_str();\n+\n+    let (n_tps, inputs, output) = match &*name {\n+        \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {\n+            (2, vec![param(0), param(0)], param(1))\n+        }\n+        \"simd_add\" | \"simd_sub\" | \"simd_mul\" |\n+        \"simd_div\" | \"simd_shl\" | \"simd_shr\" |\n+        \"simd_and\" | \"simd_or\" | \"simd_xor\" => {\n+            (1, vec![param(0), param(0)], param(0))\n+        }\n+        \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n+        \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n+        \"simd_cast\" => (2, vec![param(0)], param(1)),\n+        name if name.starts_with(\"simd_shuffle\") => {\n+            match name[\"simd_shuffle\".len()..].parse() {\n+                Ok(n) => {\n+                    let params = vec![param(0), param(0),\n+                                      tcx.mk_ty(ty::TyArray(tcx.types.u32, n))];\n+                    (2, params, param(1))\n+                }\n+                Err(_) => {\n+                    span_err!(tcx.sess, it.span, E0439,\n+                              \"invalid `simd_shuffle`, needs length: `{}`\", name);\n+                    return\n+                }\n+            }\n+        }\n+        _ => {\n+            match intrinsics::Intrinsic::find(tcx, &name) {\n+                Some(intr) => {\n+                    // this function is a platform specific intrinsic\n+                    if i_n_tps != 0 {\n+                        span_err!(tcx.sess, it.span, E0440,\n+                                  \"platform-specific intrinsic has wrong number of type \\\n+                                   parameters: found {}, expected 0\",\n+                                  i_n_tps);\n+                        return\n+                    }\n+\n+                    let mut structural_to_nomimal = HashMap::new();\n+\n+                    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n+                    let input_pairs = intr.inputs.iter().zip(&sig.inputs);\n+                    for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n+                        match_intrinsic_type_to_type(tcx, &format!(\"argument {}\", i + 1), it.span,\n+                                                     &mut structural_to_nomimal, expected_arg, arg);\n+                    }\n+                    match_intrinsic_type_to_type(tcx, \"return value\", it.span,\n+                                                 &mut structural_to_nomimal,\n+                                                 &intr.output, sig.output.unwrap());\n+                    return\n+                }\n+                None => {\n+                    span_err!(tcx.sess, it.span, E0441,\n+                              \"unrecognized platform-specific intrinsic function: `{}`\", name);\n+                    return;\n+                }\n+            }\n+        }\n+    };\n+\n+    equate_intrinsic_type(\n+        tcx,\n+        it,\n+        n_tps,\n+        abi::PlatformIntrinsic,\n+        inputs,\n+        ty::FnConverging(output)\n+        )\n+}\n+\n+// walk the expected type and the actual type in lock step, checking they're\n+// the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n+// exactly the right element type\n+fn match_intrinsic_type_to_type<'tcx, 'a>(\n+        tcx: &ty::ctxt<'tcx>,\n+        position: &str,\n+        span: Span,\n+        structural_to_nominal: &mut HashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n+        expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n+{\n+    use intrinsics::Type::*;\n+\n+    let simple_error = |real: &str, expected: &str| {\n+        span_err!(tcx.sess, span, E0442,\n+                  \"intrinsic {} has wrong type: found {}, expected {}\",\n+                  position, real, expected)\n+    };\n+\n+    match *expected {\n+        Integer(bits) => match (bits, &t.sty) {\n+            (8, &ty::TyInt(ast::TyI8)) | (8, &ty::TyUint(ast::TyU8)) |\n+            (16, &ty::TyInt(ast::TyI16)) | (16, &ty::TyUint(ast::TyU16)) |\n+            (32, &ty::TyInt(ast::TyI32)) | (32, &ty::TyUint(ast::TyU32)) |\n+            (64, &ty::TyInt(ast::TyI64)) | (64, &ty::TyUint(ast::TyU64)) => {},\n+            _ => simple_error(&format!(\"`{}`\", t),\n+                              &format!(\"`i{n}` or `u{n}`\", n = bits)),\n+        },\n+        Float(bits) => match (bits, &t.sty) {\n+            (32, &ty::TyFloat(ast::TyF32)) |\n+            (64, &ty::TyFloat(ast::TyF64)) => {},\n+            _ => simple_error(&format!(\"`{}`\", t),\n+                              &format!(\"`f{n}`\", n = bits)),\n+        },\n+        Pointer(_) => unimplemented!(),\n+        Vector(ref inner_expected, len) => {\n+            if !t.is_simd() {\n+                simple_error(&format!(\"non-simd type `{}`\", t),\n+                             \"simd type\");\n+                return;\n+            }\n+            let t_len = t.simd_size(tcx);\n+            if len as usize != t_len {\n+                simple_error(&format!(\"vector with length {}\", t_len),\n+                             &format!(\"length {}\", len));\n+                return;\n+            }\n+            let t_ty = t.simd_type(tcx);\n+            {\n+                // check that a given structural type always has the same an intrinsic definition\n+                let previous = structural_to_nominal.entry(expected).or_insert(t);\n+                if *previous != t {\n+                    // this gets its own error code because it is non-trivial\n+                    span_err!(tcx.sess, span, E0443,\n+                              \"intrinsic {} has wrong type: found `{}`, expected `{}` which \\\n+                               was used for this vector type previously in this signature\",\n+                              position,\n+                              t,\n+                              *previous);\n+                    return;\n+                }\n+            }\n+            match_intrinsic_type_to_type(tcx,\n+                                         position,\n+                                         span,\n+                                         structural_to_nominal,\n+                                         inner_expected,\n+                                         t_ty)\n+        }\n+    }\n+}"}, {"sha": "aaa0111cae098a0684a54dbebb7798f124c51667", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 323, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -101,15 +101,15 @@ use middle::ty_fold::{TypeFolder, TypeFoldable};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::Session;\n-use {CrateCtxt, lookup_full_def, require_same_types};\n+use {CrateCtxt, lookup_full_def};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::HashSet;\n+use std::collections::{HashSet};\n use std::mem::replace;\n use std::slice;\n use syntax::{self, abi, attr};\n@@ -139,6 +139,7 @@ mod cast;\n mod closure;\n mod callee;\n mod compare_method;\n+mod intrinsic;\n mod op;\n \n /// closures defined within the function.  For example:\n@@ -716,7 +717,11 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemForeignMod(ref m) => {\n         if m.abi == abi::RustIntrinsic {\n             for item in &m.items {\n-                check_intrinsic_type(ccx, &**item);\n+                intrinsic::check_intrinsic_type(ccx, &**item);\n+            }\n+        } else if m.abi == abi::PlatformIntrinsic {\n+            for item in &m.items {\n+                intrinsic::check_platform_intrinsic_type(ccx, &**item);\n             }\n         } else {\n             for item in &m.items {\n@@ -4212,10 +4217,6 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n \n pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     let t = tcx.node_id_to_type(id);\n-    if t.needs_subst() {\n-        span_err!(tcx.sess, sp, E0074, \"SIMD vector cannot be generic\");\n-        return;\n-    }\n     match t.sty {\n         ty::TyStruct(def, substs) => {\n             let fields = &def.struct_variant().fields;\n@@ -4228,10 +4229,14 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }\n-            if !e.is_machine() {\n-                span_err!(tcx.sess, sp, E0077,\n-                    \"SIMD vector element type should be machine type\");\n-                return;\n+            match e.sty {\n+                ty::TyParam(_) => { /* struct<T>(T, T, T, T) is ok */ }\n+                _ if e.is_machine()  => { /* struct(u8, u8, u8, u8) is ok */ }\n+                _ => {\n+                    span_err!(tcx.sess, sp, E0077,\n+                              \"SIMD vector element type should be machine type\");\n+                    return;\n+                }\n             }\n         }\n         _ => ()\n@@ -4317,6 +4322,9 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             \"discriminant type specified here\");\n                     }\n                 }\n+                attr::ReprSimd => {\n+                    ccx.tcx.sess.bug(\"range_to_inttype: found ReprSimd on an enum\");\n+                }\n                 attr::ReprPacked => {\n                     ccx.tcx.sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n                 }\n@@ -4976,315 +4984,3 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n }\n-\n-/// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n-/// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n-    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = token::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(subst::FnSpace, n, name)\n-    }\n-\n-    let tcx = ccx.tcx;\n-    let name = it.ident.name.as_str();\n-    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n-        let split : Vec<&str> = name.split('_').collect();\n-        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n-\n-        //We only care about the operation here\n-        let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n-                                param(ccx, 0),\n-                                param(ccx, 0)),\n-                        param(ccx, 0)),\n-            \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n-                       param(ccx, 0)),\n-            \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n-                        tcx.mk_nil()),\n-\n-            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n-            \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n-                 param(ccx, 0))\n-            }\n-            \"fence\" | \"singlethreadfence\" => {\n-                (0, Vec::new(), tcx.mk_nil())\n-            }\n-            op => {\n-                span_err!(tcx.sess, it.span, E0092,\n-                    \"unrecognized atomic operation function: `{}`\", op);\n-                return;\n-            }\n-        };\n-        (n_tps, inputs, ty::FnConverging(output))\n-    } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n-        (0, Vec::new(), ty::FnDiverging)\n-    } else {\n-        let (n_tps, inputs, output) = match &name[..] {\n-            \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n-            \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n-            \"size_of_val\" |  \"min_align_of_val\" => {\n-                (1, vec![\n-                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n-                                                                  ty::BrAnon(0))),\n-                                    param(ccx, 0))\n-                 ], ccx.tcx.types.usize)\n-            }\n-            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n-            \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n-            \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n-            \"move_val_init\" => {\n-                (1,\n-                 vec!(\n-                    tcx.mk_mut_ptr(param(ccx, 0)),\n-                    param(ccx, 0)\n-                  ),\n-               tcx.mk_nil())\n-            }\n-            \"drop_in_place\" => {\n-                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n-            }\n-            \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n-\n-            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n-            \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n-            \"offset\" | \"arith_offset\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutImmutable\n-                  }),\n-                  ccx.tcx.types.isize\n-               ),\n-               tcx.mk_ptr(ty::TypeAndMut {\n-                   ty: param(ccx, 0),\n-                   mutbl: ast::MutImmutable\n-               }))\n-            }\n-            \"copy\" | \"copy_nonoverlapping\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutImmutable\n-                  }),\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutMutable\n-                  }),\n-                  tcx.types.usize,\n-               ),\n-               tcx.mk_nil())\n-            }\n-            \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutMutable\n-                  }),\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutImmutable\n-                  }),\n-                  tcx.types.usize,\n-               ),\n-               tcx.mk_nil())\n-            }\n-            \"write_bytes\" | \"volatile_set_memory\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutMutable\n-                  }),\n-                  tcx.types.u8,\n-                  tcx.types.usize,\n-               ),\n-               tcx.mk_nil())\n-            }\n-            \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"powif32\" => {\n-               (0,\n-                vec!( tcx.types.f32, tcx.types.i32 ),\n-                tcx.types.f32)\n-            }\n-            \"powif64\" => {\n-               (0,\n-                vec!( tcx.types.f64, tcx.types.i32 ),\n-                tcx.types.f64)\n-            }\n-            \"sinf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"sinf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"cosf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"cosf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"powf32\" => {\n-               (0,\n-                vec!( tcx.types.f32, tcx.types.f32 ),\n-                tcx.types.f32)\n-            }\n-            \"powf64\" => {\n-               (0,\n-                vec!( tcx.types.f64, tcx.types.f64 ),\n-                tcx.types.f64)\n-            }\n-            \"expf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"expf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"exp2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"exp2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"logf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"logf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"log10f32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"log10f64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"log2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"log2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"fmaf32\" => {\n-                (0,\n-                 vec!( tcx.types.f32, tcx.types.f32, tcx.types.f32 ),\n-                 tcx.types.f32)\n-            }\n-            \"fmaf64\" => {\n-                (0,\n-                 vec!( tcx.types.f64, tcx.types.f64, tcx.types.f64 ),\n-                 tcx.types.f64)\n-            }\n-            \"fabsf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"fabsf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"copysignf32\"  => (0, vec!( tcx.types.f32, tcx.types.f32 ), tcx.types.f32),\n-            \"copysignf64\"  => (0, vec!( tcx.types.f64, tcx.types.f64 ), tcx.types.f64),\n-            \"floorf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"floorf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"ceilf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"ceilf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"truncf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"truncf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"rintf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"rintf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"nearbyintf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"nearbyintf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"roundf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"roundf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"ctpop8\"       => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n-            \"ctpop16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"ctpop32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"ctpop64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-            \"ctlz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n-            \"ctlz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"ctlz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"ctlz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-            \"cttz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n-            \"cttz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"cttz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"cttz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-            \"bswap16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"bswap32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-\n-            \"volatile_load\" =>\n-                (1, vec!( tcx.mk_imm_ptr(param(ccx, 0)) ), param(ccx, 0)),\n-            \"volatile_store\" =>\n-                (1, vec!( tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ), tcx.mk_nil()),\n-\n-            \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i8, tcx.types.i8),\n-                tcx.mk_tup(vec!(tcx.types.i8, tcx.types.bool))),\n-\n-            \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i16, tcx.types.i16),\n-                tcx.mk_tup(vec!(tcx.types.i16, tcx.types.bool))),\n-\n-            \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i32, tcx.types.i32),\n-                tcx.mk_tup(vec!(tcx.types.i32, tcx.types.bool))),\n-\n-            \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i64, tcx.types.i64),\n-                tcx.mk_tup(vec!(tcx.types.i64, tcx.types.bool))),\n-\n-            \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.u8, tcx.types.u8),\n-                tcx.mk_tup(vec!(tcx.types.u8, tcx.types.bool))),\n-\n-            \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.u16, tcx.types.u16),\n-                tcx.mk_tup(vec!(tcx.types.u16, tcx.types.bool))),\n-\n-            \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n-                (0, vec!(tcx.types.u32, tcx.types.u32),\n-                tcx.mk_tup(vec!(tcx.types.u32, tcx.types.bool))),\n-\n-            \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.u64, tcx.types.u64),\n-                tcx.mk_tup(vec!(tcx.types.u64, tcx.types.bool))),\n-\n-            \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n-\n-            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n-\n-            \"return_address\" => (0, vec![], tcx.mk_imm_ptr(tcx.types.u8)),\n-\n-            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n-\n-            \"discriminant_value\" => (1, vec![\n-                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n-                                                                  ty::BrAnon(0))),\n-                                    param(ccx, 0))], tcx.types.u64),\n-\n-            \"try\" => {\n-                let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let fn_ty = ty::BareFnTy {\n-                    unsafety: ast::Unsafety::Normal,\n-                    abi: abi::Rust,\n-                    sig: ty::Binder(FnSig {\n-                        inputs: vec![mut_u8],\n-                        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n-                        variadic: false,\n-                    }),\n-                };\n-                let fn_ty = tcx.mk_bare_fn(fn_ty);\n-                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8], mut_u8)\n-            }\n-\n-            ref other => {\n-                span_err!(tcx.sess, it.span, E0093,\n-                    \"unrecognized intrinsic function: `{}`\", *other);\n-                return;\n-            }\n-        };\n-        (n_tps, inputs, ty::FnConverging(output))\n-    };\n-    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: ast::Unsafety::Unsafe,\n-        abi: abi::RustIntrinsic,\n-        sig: ty::Binder(FnSig {\n-            inputs: inputs,\n-            output: output,\n-            variadic: false,\n-        }),\n-    }));\n-    let i_ty = ccx.tcx.lookup_item_type(local_def(it.id));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n-    if i_n_tps != n_tps {\n-        span_err!(tcx.sess, it.span, E0094,\n-            \"intrinsic has wrong number of type \\\n-             parameters: found {}, expected {}\",\n-             i_n_tps, n_tps);\n-    } else {\n-        require_same_types(tcx,\n-                           None,\n-                           false,\n-                           it.span,\n-                           i_ty.ty,\n-                           fty,\n-                           || {\n-                format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty)\n-            });\n-    }\n-}"}, {"sha": "59856a4a9c639c022859aad6f5b140e389cabd84", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 46, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -82,18 +82,6 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     check_expr(fcx, lhs_expr);\n     let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n \n-    // Annoyingly, SIMD ops don't fit into the PartialEq/PartialOrd\n-    // traits, because their return type is not bool. Perhaps this\n-    // should change, but for now if LHS is SIMD we go down a\n-    // different path that bypassess all traits.\n-    if lhs_ty.is_simd() {\n-        check_expr_coercable_to_type(fcx, rhs_expr, lhs_ty);\n-        let rhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n-        let return_ty = enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-        fcx.write_ty(expr.id, return_ty);\n-        return;\n-    }\n-\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             // && and || are a simple case.\n@@ -154,12 +142,6 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         BinOpCategory::Shift => {\n-            // For integers, the shift amount can be of any integral\n-            // type. For simd, the type must match exactly.\n-            if lhs_ty.is_simd() {\n-                demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n-            }\n-\n             // result type is same as LHS always\n             lhs_ty\n         }\n@@ -174,27 +156,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         BinOpCategory::Comparison => {\n             // both LHS and RHS and result will have the same type\n             demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n-\n-            // if this is simd, result is same as lhs, else bool\n-            if lhs_ty.is_simd() {\n-                let unit_ty = lhs_ty.simd_type(tcx);\n-                debug!(\"enforce_builtin_binop_types: lhs_ty={:?} unit_ty={:?}\",\n-                       lhs_ty,\n-                       unit_ty);\n-                if !unit_ty.is_integral() {\n-                    tcx.sess.span_err(\n-                        lhs_expr.span,\n-                        &format!(\"binary comparison operation `{}` not supported \\\n-                                  for floating point SIMD vector `{}`\",\n-                                 ast_util::binop_to_string(op.node),\n-                                 lhs_ty));\n-                    tcx.types.err\n-                } else {\n-                    lhs_ty\n-                }\n-            } else {\n-                tcx.mk_bool()\n-            }\n+            tcx.mk_bool()\n         }\n     }\n }\n@@ -427,29 +389,25 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>,\n \n         BinOpCategory::Shift => {\n             lhs.references_error() || rhs.references_error() ||\n-                lhs.is_integral() && rhs.is_integral() ||\n-                lhs.is_simd() && rhs.is_simd()\n+                lhs.is_integral() && rhs.is_integral()\n         }\n \n         BinOpCategory::Math => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n-                lhs.is_floating_point() && rhs.is_floating_point() ||\n-                lhs.is_simd() && rhs.is_simd()\n+                lhs.is_floating_point() && rhs.is_floating_point()\n         }\n \n         BinOpCategory::Bitwise => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n                 lhs.is_floating_point() && rhs.is_floating_point() ||\n-                lhs.is_simd() && rhs.is_simd() ||\n                 lhs.is_bool() && rhs.is_bool()\n         }\n \n         BinOpCategory::Comparison => {\n             lhs.references_error() || rhs.references_error() ||\n-                lhs.is_scalar() && rhs.is_scalar() ||\n-                lhs.is_simd() && rhs.is_simd()\n+                lhs.is_scalar() && rhs.is_scalar()\n         }\n     }\n }"}, {"sha": "b0f07c14bc9003bc2c62290ffd4dbf1ba95270fe", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -2772,5 +2772,11 @@ register_diagnostics! {\n            // type because its default value `{}` references the type `Self`\"\n     E0399, // trait items need to be implemented because the associated\n            // type `{}` was overridden\n-    E0436  // functional record update requires a struct\n+    E0436,  // functional record update requires a struct\n+    E0439, // invalid `simd_shuffle`, needs length: `{}`\n+    E0440, // platform-specific intrinsic has wrong number of type parameters\n+    E0441, // unrecognized platform-specific intrinsic function\n+    E0442, // intrinsic {} has wrong type: found {}, expected {}\n+    E0443, // intrinsic {} has wrong type: found `{}`, expected `{}` which\n+           // was used for this vector type previously in this signature\n }"}, {"sha": "82a605cd14fa4050ce04292395e4ec903ff150fc", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -96,6 +96,7 @@ This API is completely unstable and subject to change.\n extern crate arena;\n extern crate fmt_macros;\n extern crate rustc;\n+extern crate rustc_platform_intrinsics as intrinsics;\n \n pub use rustc::lint;\n pub use rustc::metadata;"}, {"sha": "81399938f27c51782d7cc8f66303ecbeec19c54c", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -10,7 +10,7 @@\n pub use self::MaybeTyped::*;\n \n use rustc_lint;\n-use rustc_driver::driver;\n+use rustc_driver::{driver, target_features};\n use rustc::session::{self, config};\n use rustc::middle::{privacy, ty};\n use rustc::ast_map;\n@@ -119,7 +119,8 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                                        span_diagnostic_handler);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n-    let cfg = config::build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess);\n+    target_features::add_configuration(&mut cfg, &sess);\n \n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n "}, {"sha": "bc7252fa33a868c61e297f6c73742d3e23eb814b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -294,6 +294,7 @@ pub use core::mem;\n pub use core::ops;\n pub use core::ptr;\n pub use core::raw;\n+#[allow(deprecated)]\n pub use core::simd;\n pub use core::result;\n pub use core::option;"}, {"sha": "78f969bfbeb5b3207225f0dcd1c55046820f93e1", "filename": "src/libstd/rt/unwind/seh64_gnu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibstd%2Frt%2Funwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibstd%2Frt%2Funwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh64_gnu.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -21,7 +21,6 @@ use self::EXCEPTION_DISPOSITION::*;\n use rt::dwarf::eh;\n use core::mem;\n use core::ptr;\n-use simd;\n use libc::{c_void, c_ulonglong, DWORD, LPVOID};\n type ULONG_PTR = c_ulonglong;\n "}, {"sha": "d36ca709c5c94c61e9c84ab38ac34993128a9207", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -194,6 +194,8 @@ mod arch {\n \n #[cfg(target_arch = \"x86_64\")]\n mod arch {\n+    #![allow(deprecated)]\n+\n     use libc::{c_longlong, c_ulonglong};\n     use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n     use simd;"}, {"sha": "c0fe541ead510356ecd3b8e7e119ccf40c5debe0", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -47,6 +47,7 @@ pub enum Abi {\n     System,\n     RustIntrinsic,\n     RustCall,\n+    PlatformIntrinsic,\n }\n \n #[allow(non_camel_case_types)]\n@@ -95,6 +96,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: System, name: \"system\" },\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\" },\n     AbiData {abi: RustCall, name: \"rust-call\" },\n+    AbiData {abi: PlatformIntrinsic, name: \"platform-intrinsic\" }\n ];\n \n /// Returns the ABI with the given name (if any)."}, {"sha": "2d72c8fe2a48ca288c80975ba0d94fdd3a392076", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -1339,6 +1339,15 @@ impl IntTy {\n             TyI16 | TyI32 | TyI64  => 3,\n         }\n     }\n+    pub fn bit_width(&self) -> Option<usize> {\n+        Some(match *self {\n+            TyIs => return None,\n+            TyI8 => 8,\n+            TyI16 => 16,\n+            TyI32 => 32,\n+            TyI64 => 64,\n+        })\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n@@ -1357,6 +1366,15 @@ impl UintTy {\n             TyU16 | TyU32 | TyU64  => 3,\n         }\n     }\n+    pub fn bit_width(&self) -> Option<usize> {\n+        Some(match *self {\n+            TyUs => return None,\n+            TyU8 => 8,\n+            TyU16 => 16,\n+            TyU32 => 32,\n+            TyU64 => 64,\n+        })\n+    }\n }\n \n impl fmt::Debug for UintTy {\n@@ -1395,6 +1413,12 @@ impl FloatTy {\n             TyF32 | TyF64 => 3, // add F128 handling here\n         }\n     }\n+    pub fn bit_width(&self) -> usize {\n+        match *self {\n+            TyF32 => 32,\n+            TyF64 => 64,\n+        }\n+    }\n }\n \n // Bind a type to an associated type: `A=Foo`."}, {"sha": "7540c2ff831e932976a2e0feca58e781fd25a542", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -19,6 +19,7 @@ use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, Meta\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n+use feature_gate::GatedCfg;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::{InternedString, intern_and_get_ident};\n use parse::token;\n@@ -357,24 +358,28 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem) -> bool {\n+pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n+                   feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n     match cfg.node {\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n+            mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n+            mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n                 diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 return false;\n             }\n-            !cfg_matches(diagnostic, cfgs, &*mis[0])\n+            !cfg_matches(diagnostic, cfgs, &*mis[0], feature_gated_cfgs)\n         }\n         ast::MetaList(ref pred, _) => {\n             diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n             false\n         },\n-        ast::MetaWord(_) | ast::MetaNameValue(..) => contains(cfgs, cfg),\n+        ast::MetaWord(_) | ast::MetaNameValue(..) => {\n+            feature_gated_cfgs.extend(GatedCfg::gate(cfg));\n+            contains(cfgs, cfg)\n+        }\n     }\n }\n \n@@ -579,6 +584,7 @@ pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAt\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => Some(ReprExtern),\n                             \"packed\" => Some(ReprPacked),\n+                            \"simd\" => Some(ReprSimd),\n                             _ => match int_type_of_word(&word) {\n                                 Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n@@ -628,6 +634,7 @@ pub enum ReprAttr {\n     ReprInt(Span, IntType),\n     ReprExtern,\n     ReprPacked,\n+    ReprSimd,\n }\n \n impl ReprAttr {\n@@ -636,7 +643,8 @@ impl ReprAttr {\n             ReprAny => false,\n             ReprInt(_sp, ity) => ity.is_ffi_safe(),\n             ReprExtern => true,\n-            ReprPacked => false\n+            ReprPacked => false,\n+            ReprSimd => true,\n         }\n     }\n }"}, {"sha": "faf0b51c8de0eda798c088a140ed32b2c880ac73", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -10,6 +10,7 @@\n \n use attr::AttrMetaMethods;\n use diagnostic::SpanHandler;\n+use feature_gate::GatedCfg;\n use fold::Folder;\n use {ast, fold, attr};\n use codemap::{Spanned, respan};\n@@ -25,10 +26,13 @@ struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate) -> ast::Crate {\n-    let krate = process_cfg_attr(diagnostic, krate);\n+pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n+                                feature_gated_cfgs: &mut Vec<GatedCfg>)\n+                                -> ast::Crate\n+{\n+    let krate = process_cfg_attr(diagnostic, krate, feature_gated_cfgs);\n     let config = krate.config.clone();\n-    strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs))\n+    strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs, feature_gated_cfgs))\n }\n \n impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n@@ -248,7 +252,8 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n+fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute],\n+          feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n     attrs.iter().all(|attr| {\n         let mis = match attr.node.value.node {\n             ast::MetaList(_, ref mis) if attr.check_name(\"cfg\") => mis,\n@@ -260,25 +265,29 @@ fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attr\n             return true;\n         }\n \n-        attr::cfg_matches(diagnostic, cfg, &*mis[0])\n+        attr::cfg_matches(diagnostic, cfg, &*mis[0],\n+                          feature_gated_cfgs)\n     })\n }\n \n-struct CfgAttrFolder<'a> {\n+struct CfgAttrFolder<'a, 'b> {\n     diag: &'a SpanHandler,\n     config: ast::CrateConfig,\n+    feature_gated_cfgs: &'b mut Vec<GatedCfg>\n }\n \n // Process `#[cfg_attr]`.\n-fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate) -> ast::Crate {\n+fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate,\n+                    feature_gated_cfgs: &mut Vec<GatedCfg>) -> ast::Crate {\n     let mut fld = CfgAttrFolder {\n         diag: diagnostic,\n         config: krate.config.clone(),\n+        feature_gated_cfgs: feature_gated_cfgs,\n     };\n     fld.fold_crate(krate)\n }\n \n-impl<'a> fold::Folder for CfgAttrFolder<'a> {\n+impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n     fn fold_attribute(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n             return fold::noop_fold_attribute(attr, self);\n@@ -299,7 +308,8 @@ impl<'a> fold::Folder for CfgAttrFolder<'a> {\n             }\n         };\n \n-        if attr::cfg_matches(self.diag, &self.config[..], &cfg) {\n+        if attr::cfg_matches(self.diag, &self.config[..], &cfg,\n+                             self.feature_gated_cfgs) {\n             Some(respan(mi.span, ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: attr.node.style,"}, {"sha": "ef11a2bd66e804bd5e80a915b0785a78c6c2af42", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -17,6 +17,7 @@ use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION, CompilerExpansion};\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n+use feature_gate::GatedCfg;\n use parse;\n use parse::parser;\n use parse::token;\n@@ -632,6 +633,7 @@ pub struct ExtCtxt<'a> {\n     pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n+    pub feature_gated_cfgs: &'a mut Vec<GatedCfg>,\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub exported_macros: Vec<ast::MacroDef>,\n@@ -642,7 +644,8 @@ pub struct ExtCtxt<'a> {\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n-               ecfg: expand::ExpansionConfig<'a>) -> ExtCtxt<'a> {\n+               ecfg: expand::ExpansionConfig<'a>,\n+               feature_gated_cfgs: &'a mut Vec<GatedCfg>) -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,\n@@ -651,6 +654,7 @@ impl<'a> ExtCtxt<'a> {\n             mod_path: Vec::new(),\n             ecfg: ecfg,\n             crate_root: None,\n+            feature_gated_cfgs: feature_gated_cfgs,\n             exported_macros: Vec::new(),\n             syntax_env: env,\n             recursion_count: 0,"}, {"sha": "aa654e30530afc1e8b01ecdb229cffc708660fc2", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -34,6 +34,7 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &*cfg);\n+    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &*cfg,\n+                                        cx.feature_gated_cfgs);\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "f8f63e94ee574b04472e1e69af9476ff9f9d0a14", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -739,7 +739,7 @@ fn find_repr_type_name(diagnostic: &SpanHandler,\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprAny | attr::ReprPacked => continue,\n+                attr::ReprAny | attr::ReprPacked | attr::ReprSimd => continue,\n                 attr::ReprExtern => \"i32\",\n \n                 attr::ReprInt(_, attr::SignedInt(ast::TyIs)) => \"isize\","}, {"sha": "4f89b3494d403954c1a6e2f768b8f555ca6a0d03", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -21,7 +21,7 @@ use attr::AttrMetaMethods;\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, CompilerExpansion};\n use ext::base::*;\n-use feature_gate::{self, Features};\n+use feature_gate::{self, Features, GatedCfg};\n use fold;\n use fold::*;\n use parse;\n@@ -1687,8 +1687,10 @@ pub fn expand_crate<'feat>(parse_sess: &parse::ParseSess,\n                            // these are the macros being imported to this crate:\n                            imported_macros: Vec<ast::MacroDef>,\n                            user_exts: Vec<NamedSyntaxExtension>,\n+                           feature_gated_cfgs: &mut Vec<GatedCfg>,\n                            c: Crate) -> Crate {\n-    let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n+    let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg,\n+                              feature_gated_cfgs);\n     if std_inject::no_core(&c) {\n         cx.crate_root = None;\n     } else if std_inject::no_std(&c) {\n@@ -1878,7 +1880,7 @@ mod tests {\n             src,\n             Vec::new(), &sess);\n         // should fail:\n-        expand_crate(&sess,test_ecfg(),vec!(),vec!(),crate_ast);\n+        expand_crate(&sess,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast);\n     }\n \n     // make sure that macros can't escape modules\n@@ -1891,7 +1893,7 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n-        expand_crate(&sess,test_ecfg(),vec!(),vec!(),crate_ast);\n+        expand_crate(&sess,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast);\n     }\n \n     // macro_use modules should allow macros to escape\n@@ -1903,14 +1905,14 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n-        expand_crate(&sess, test_ecfg(), vec!(), vec!(), crate_ast);\n+        expand_crate(&sess, test_ecfg(), vec!(), vec!(), &mut vec![], crate_ast);\n     }\n \n     fn expand_crate_str(crate_str: String) -> ast::Crate {\n         let ps = parse::ParseSess::new();\n         let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n         // the cfg argument actually does matter, here...\n-        expand_crate(&ps,test_ecfg(),vec!(),vec!(),crate_ast)\n+        expand_crate(&ps,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast)\n     }\n \n     // find the pat_ident paths in a crate"}, {"sha": "f5a0a2f4718b9d6d38ca3b60cb8c3cf6c43edb8e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -37,6 +37,7 @@ use visit::Visitor;\n use parse::token::{self, InternedString};\n \n use std::ascii::AsciiExt;\n+use std::cmp;\n \n // If you change this list without updating src/doc/reference.md, @cmr will be sad\n // Don't ever remove anything from this list; set them to 'Removed'.\n@@ -177,6 +178,15 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     // Allows macros to appear in the type position.\n \n     (\"type_macros\", \"1.3.0\", Active),\n+\n+    // allow `repr(simd)`, and importing the various simd intrinsics\n+    (\"repr_simd\", \"1.4.0\", Active),\n+\n+    // Allows cfg(target_feature = \"...\").\n+    (\"cfg_target_feature\", \"1.4.0\", Active),\n+\n+    // allow `extern \"platform-intrinsic\" { ... }`\n+    (\"platform_intrinsics\", \"1.4.0\", Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -324,6 +334,59 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"recursion_limit\", CrateLevel),\n ];\n \n+macro_rules! cfg_fn {\n+    (|$x: ident| $e: expr) => {{\n+        fn f($x: &Features) -> bool {\n+            $e\n+        }\n+        f as fn(&Features) -> bool\n+    }}\n+}\n+// cfg(...)'s that are feature gated\n+const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)] = &[\n+    // (name in cfg, feature, function to check if the feature is enabled)\n+    (\"target_feature\", \"cfg_target_feature\", cfg_fn!(|x| x.cfg_target_feature)),\n+];\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct GatedCfg {\n+    span: Span,\n+    index: usize,\n+}\n+impl Ord for GatedCfg {\n+    fn cmp(&self, other: &GatedCfg) -> cmp::Ordering {\n+        (self.span.lo.0, self.span.hi.0, self.index)\n+            .cmp(&(other.span.lo.0, other.span.hi.0, other.index))\n+    }\n+}\n+impl PartialOrd for GatedCfg {\n+    fn partial_cmp(&self, other: &GatedCfg) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl GatedCfg {\n+    pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n+        let name = cfg.name();\n+        GATED_CFGS.iter()\n+                  .position(|info| info.0 == name)\n+                  .map(|idx| {\n+                      GatedCfg {\n+                          span: cfg.span,\n+                          index: idx\n+                      }\n+                  })\n+    }\n+    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+        let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n+        if !has_feature(features) {\n+            let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n+            emit_feature_err(diagnostic, feature, self.span, &explain);\n+        }\n+    }\n+}\n+\n+\n #[derive(PartialEq, Copy, Clone, Debug)]\n pub enum AttributeType {\n     /// Normal, builtin attribute that is consumed\n@@ -369,6 +432,7 @@ pub struct Features {\n     pub static_recursion: bool,\n     pub default_type_parameter_fallback: bool,\n     pub type_macros: bool,\n+    pub cfg_target_feature: bool,\n }\n \n impl Features {\n@@ -396,6 +460,7 @@ impl Features {\n             static_recursion: false,\n             default_type_parameter_fallback: false,\n             type_macros: false,\n+            cfg_target_feature: false,\n         }\n     }\n }\n@@ -630,10 +695,16 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                        across platforms, it is recommended to \\\n                                        use `#[link(name = \\\"foo\\\")]` instead\")\n                 }\n-                if foreign_module.abi == Abi::RustIntrinsic {\n-                    self.gate_feature(\"intrinsics\",\n-                                      i.span,\n-                                      \"intrinsics are subject to change\")\n+                let maybe_feature = match foreign_module.abi {\n+                    Abi::RustIntrinsic => Some((\"intrinsics\", \"intrinsics are subject to change\")),\n+                    Abi::PlatformIntrinsic => {\n+                        Some((\"platform_intrinsics\",\n+                              \"platform intrinsics are experimental and possibly buggy\"))\n+                    }\n+                    _ => None\n+                };\n+                if let Some((feature, msg)) = maybe_feature {\n+                    self.gate_feature(feature, i.span, msg)\n                 }\n             }\n \n@@ -660,6 +731,20 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 if attr::contains_name(&i.attrs[..], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n+                    self.context.span_handler.span_warn(i.span,\n+                                                        \"the `#[simd]` attribute is deprecated, \\\n+                                                         use `#[repr(simd)]` instead\");\n+                }\n+                for attr in &i.attrs {\n+                    if attr.name() == \"repr\" {\n+                        for item in attr.meta_item_list().unwrap_or(&[]) {\n+                            if item.name() == \"simd\" {\n+                                self.gate_feature(\"repr_simd\", i.span,\n+                                                  \"SIMD types are experimental and possibly buggy\");\n+\n+                            }\n+                        }\n+                    }\n                 }\n             }\n \n@@ -900,6 +985,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         static_recursion: cx.has_feature(\"static_recursion\"),\n         default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n         type_macros: cx.has_feature(\"type_macros\"),\n+        cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n     }\n }\n "}, {"sha": "26fb287ce35d1bbfc0f878952d756f0568cd7012", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -246,11 +246,13 @@ fn generate_test_harness(sess: &ParseSess,\n                          krate: ast::Crate,\n                          cfg: &ast::CrateConfig,\n                          sd: &diagnostic::SpanHandler) -> ast::Crate {\n+    let mut feature_gated_cfgs = vec![];\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n         ext_cx: ExtCtxt::new(sess, cfg.clone(),\n-                             ExpansionConfig::default(\"test\".to_string())),\n+                             ExpansionConfig::default(\"test\".to_string()),\n+                             &mut feature_gated_cfgs),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main: reexport_test_harness_main,"}, {"sha": "a6c77eaf7c63091839277a74df50700125029bbe", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -91,7 +91,7 @@ fn mult<F>(v: &[f64], out: &mut [f64], start: usize, a: F)\n         for (j, chunk) in v.chunks(2).enumerate().map(|(j, s)| (2 * j, s)) {\n             let top = f64x2(chunk[0], chunk[1]);\n             let bot = f64x2(a(i, j), a(i, j + 1));\n-            sum += top / bot;\n+            sum = sum + top / bot;\n         }\n         let f64x2(a, b) = sum;\n         *slot = a + b;"}, {"sha": "7832e1c7c51520e7978b491b2bad1426d52f65c2", "filename": "src/test/compile-fail/feature-gate-cfg-target-feature.rs", "status": "renamed", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-feature.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n+#[cfg(target_feature = \"x\")] //~ ERROR `cfg(target_feature)` is experimental\n+#[cfg_attr(target_feature = \"x\", x)] //~ ERROR `cfg(target_feature)` is experimental\n+struct Foo(u64, u64);\n \n-#![feature(core_simd)]\n-\n-use std::simd::i32x4;\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#[cfg(not(any(all(target_feature = \"x\"))))] //~ ERROR `cfg(target_feature)` is experimental\n+fn foo() {}\n \n fn main() {\n-    let _x = i32x4(-1, 0, 0, 0) >> id(i32x4(32, 0, 0, 0));\n+    cfg!(target_feature = \"x\");\n+    //~^ ERROR `cfg(target_feature)` is experimental and subject to change\n }", "previous_filename": "src/test/run-fail/overflowing-simd-rsh-1.rs"}, {"sha": "fdafb2ad950c9bc037c2bc3c6e69cca80bf60529", "filename": "src/test/compile-fail/feature-gate-repr-simd.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr-simd.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[simd]\n-pub struct i64x2(i64, i64); //~ ERROR: SIMD types are experimental\n+#[repr(simd)]\n+struct Foo(u64, u64); //~ error: SIMD types are experimental\n \n fn main() {}", "previous_filename": "src/test/compile-fail/gated-simd.rs"}, {"sha": "f7bd2fcbceb4fe42334170a2add8fafce0ac654a", "filename": "src/test/compile-fail/feature-gate-simd-ffi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(simd, core_simd)]\n-#![allow(dead_code)]\n+#![feature(repr_simd, core_simd)]\n+#![allow(dead_code, deprecated)]\n \n use std::simd::f32x4;\n \n-#[simd] #[derive(Copy, Clone)] #[repr(C)] struct LocalSimd(u8, u8);\n+#[repr(simd)] #[derive(Copy, Clone)] #[repr(C)] struct LocalSimd(u8, u8);\n \n extern {\n     fn foo() -> f32x4; //~ ERROR use of SIMD type"}, {"sha": "feffe5c0b06c8e09fc10dcd75c68c9cec4ff21f6", "filename": "src/test/compile-fail/simd-binop.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-#![feature(core)]\n-\n-use std::simd::f32x4;\n-\n-fn main() {\n-\n-    let _ = f32x4(0.0, 0.0, 0.0, 0.0) == f32x4(0.0, 0.0, 0.0, 0.0);\n-    //~^ ERROR binary comparison operation `==` not supported for floating point SIMD vector `core::simd::f32x4`\n-\n-    let _ = f32x4(0.0, 0.0, 0.0, 0.0) != f32x4(0.0, 0.0, 0.0, 0.0);\n-    //~^ ERROR binary comparison operation `!=` not supported for floating point SIMD vector `core::simd::f32x4`\n-\n-    let _ = f32x4(0.0, 0.0, 0.0, 0.0) < f32x4(0.0, 0.0, 0.0, 0.0);\n-    //~^ ERROR binary comparison operation `<` not supported for floating point SIMD vector `core::simd::f32x4`\n-\n-    let _ = f32x4(0.0, 0.0, 0.0, 0.0) <= f32x4(0.0, 0.0, 0.0, 0.0);\n-    //~^ ERROR binary comparison operation `<=` not supported for floating point SIMD vector `core::simd::f32x4`\n-\n-    let _ = f32x4(0.0, 0.0, 0.0, 0.0) >= f32x4(0.0, 0.0, 0.0, 0.0);\n-    //~^ ERROR binary comparison operation `>=` not supported for floating point SIMD vector `core::simd::f32x4`\n-\n-    let _ = f32x4(0.0, 0.0, 0.0, 0.0) > f32x4(0.0, 0.0, 0.0, 0.0);\n-    //~^ ERROR binary comparison operation `>` not supported for floating point SIMD vector `core::simd::f32x4`\n-\n-}"}, {"sha": "effa1ed04d8ecf5e9c062b8bb3c302eea3d239cf", "filename": "src/test/compile-fail/simd-intrinsic-declaration-type.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-declaration-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-declaration-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-declaration-type.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+struct u16x8(u16, u16, u16, u16, u16, u16, u16, u16);\n+\n+#[repr(simd)]\n+struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,\n+             i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+struct i64x2(i64, i64);\n+\n+// signed vs. unsigned doesn't matter\n+mod i {\n+    use i16x8;\n+    extern \"platform-intrinsic\" {\n+        fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8;\n+    }\n+}\n+mod u {\n+    use u16x8;\n+    extern \"platform-intrinsic\" {\n+        fn x86_mm_adds_epi16(x: u16x8, y: u16x8) -> u16x8;\n+    }\n+}\n+// but lengths do\n+extern \"platform-intrinsic\" {\n+    fn x86_mm_adds_epi16(x: i8x16, y: i32x4) -> i64x2;\n+    //~^ ERROR intrinsic argument 1 has wrong type\n+    //~^^ ERROR intrinsic argument 2 has wrong type\n+    //~^^^ ERROR intrinsic return value has wrong type\n+}\n+// and so does int vs. float\n+extern \"platform-intrinsic\" {\n+    fn x86_mm_max_ps(x: i32x4, y: i32x4) -> i32x4;\n+    //~^ ERROR intrinsic argument 1 has wrong type\n+    //~^^ ERROR intrinsic argument 2 has wrong type\n+    //~^^^ ERROR intrinsic return value has wrong type\n+}\n+\n+\n+fn main() {}"}, {"sha": "35c368f4cbedb5bb399156b590bbc7ad1f43dfdd", "filename": "src/test/compile-fail/simd-intrinsic-generic-arithmetic.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(x: T, y: T) -> T;\n+    fn simd_sub<T>(x: T, y: T) -> T;\n+    fn simd_mul<T>(x: T, y: T) -> T;\n+    fn simd_div<T>(x: T, y: T) -> T;\n+    fn simd_shl<T>(x: T, y: T) -> T;\n+    fn simd_shr<T>(x: T, y: T) -> T;\n+    fn simd_and<T>(x: T, y: T) -> T;\n+    fn simd_or<T>(x: T, y: T) -> T;\n+    fn simd_xor<T>(x: T, y: T) -> T;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+    let y = u32x4(0, 0, 0, 0);\n+    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n+\n+    unsafe {\n+        simd_add(x, x);\n+        simd_add(y, y);\n+        simd_add(z, z);\n+        simd_sub(x, x);\n+        simd_sub(y, y);\n+        simd_sub(z, z);\n+        simd_mul(x, x);\n+        simd_mul(y, y);\n+        simd_mul(z, z);\n+\n+        simd_div(z, z);\n+\n+        simd_shl(x, x);\n+        simd_shl(y, y);\n+        simd_shr(x, x);\n+        simd_shr(y, y);\n+        simd_and(x, x);\n+        simd_and(y, y);\n+        simd_or(x, x);\n+        simd_or(y, y);\n+        simd_xor(x, x);\n+        simd_xor(y, y);\n+\n+\n+        simd_add(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_sub(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_mul(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_div(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_shl(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_shr(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_and(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_or(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_xor(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+\n+\n+        simd_div(x, x);\n+//~^ ERROR unsupported operation on `i32x4` with element `i32`\n+        simd_div(y, y);\n+//~^ ERROR unsupported operation on `u32x4` with element `u32`\n+        simd_shl(z, z);\n+//~^ ERROR unsupported operation on `f32x4` with element `f32`\n+        simd_shr(z, z);\n+//~^ ERROR unsupported operation on `f32x4` with element `f32`\n+        simd_and(z, z);\n+//~^ ERROR unsupported operation on `f32x4` with element `f32`\n+        simd_or(z, z);\n+//~^ ERROR unsupported operation on `f32x4` with element `f32`\n+        simd_xor(z, z);\n+//~^ ERROR unsupported operation on `f32x4` with element `f32`\n+    }\n+}"}, {"sha": "4999b790b130a4e79cb9b9e4ea63b001f0ef93d8", "filename": "src/test/compile-fail/simd-intrinsic-generic-cast.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x8(i32, i32, i32, i32,\n+             i32, i32, i32, i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x8(f32, f32, f32, f32,\n+             f32, f32, f32, f32);\n+\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_cast<T, U>(x: T) -> U;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+\n+    unsafe {\n+        simd_cast::<i32, i32>(0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_cast::<i32, i32x4>(0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_cast::<i32x4, i32>(x);\n+        //~^ ERROR expected SIMD return type, found non-SIMD `i32`\n+        simd_cast::<_, i32x8>(x);\n+//~^ ERROR return type with length 4 (same as input type `i32x4`), found `i32x8` with length 8\n+    }\n+}"}, {"sha": "617b03a87117b75b3ff97d26c88c1f1b9b6ca2e0", "filename": "src/test/compile-fail/simd-intrinsic-generic-comparison.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i16x8(i16, i16, i16, i16,\n+             i16, i16, i16, i16);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_eq<T, U>(x: T, y: T) -> U;\n+    fn simd_ne<T, U>(x: T, y: T) -> U;\n+    fn simd_lt<T, U>(x: T, y: T) -> U;\n+    fn simd_le<T, U>(x: T, y: T) -> U;\n+    fn simd_gt<T, U>(x: T, y: T) -> U;\n+    fn simd_ge<T, U>(x: T, y: T) -> U;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+\n+    unsafe {\n+        simd_eq::<i32, i32>(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_ne::<i32, i32>(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_lt::<i32, i32>(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_le::<i32, i32>(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_gt::<i32, i32>(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_ge::<i32, i32>(0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+\n+        simd_eq::<_, i32>(x, x);\n+        //~^ ERROR expected SIMD return type, found non-SIMD `i32`\n+        simd_ne::<_, i32>(x, x);\n+        //~^ ERROR expected SIMD return type, found non-SIMD `i32`\n+        simd_lt::<_, i32>(x, x);\n+        //~^ ERROR expected SIMD return type, found non-SIMD `i32`\n+        simd_le::<_, i32>(x, x);\n+        //~^ ERROR expected SIMD return type, found non-SIMD `i32`\n+        simd_gt::<_, i32>(x, x);\n+        //~^ ERROR expected SIMD return type, found non-SIMD `i32`\n+        simd_ge::<_, i32>(x, x);\n+        //~^ ERROR expected SIMD return type, found non-SIMD `i32`\n+\n+        simd_eq::<_, i16x8>(x, x);\n+//~^ ERROR return type with length 4 (same as input type `i32x4`), found `i16x8` with length 8\n+        simd_ne::<_, i16x8>(x, x);\n+//~^ ERROR return type with length 4 (same as input type `i32x4`), found `i16x8` with length 8\n+        simd_lt::<_, i16x8>(x, x);\n+//~^ ERROR return type with length 4 (same as input type `i32x4`), found `i16x8` with length 8\n+        simd_le::<_, i16x8>(x, x);\n+//~^ ERROR return type with length 4 (same as input type `i32x4`), found `i16x8` with length 8\n+        simd_gt::<_, i16x8>(x, x);\n+//~^ ERROR return type with length 4 (same as input type `i32x4`), found `i16x8` with length 8\n+        simd_ge::<_, i16x8>(x, x);\n+//~^ ERROR return type with length 4 (same as input type `i32x4`), found `i16x8` with length 8\n+    }\n+}"}, {"sha": "b0198c411d5679ec1e06727969e619c9fe0fad78", "filename": "src/test/compile-fail/simd-intrinsic-generic-elements.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x2(i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x3(i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x8(i32, i32, i32, i32,\n+             i32, i32, i32, i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x2(f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x3(f32, f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x8(f32, f32, f32, f32,\n+             f32, f32, f32, f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_insert<T, E>(x: T, idx: u32, y: E) -> T;\n+    fn simd_extract<T, E>(x: T, idx: u32) -> E;\n+\n+    fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;\n+    fn simd_shuffle3<T, U>(x: T, y: T, idx: [u32; 3]) -> U;\n+    fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;\n+    fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+\n+    unsafe {\n+        simd_insert(0, 0, 0);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_insert(x, 0, 1.0);\n+        //~^ ERROR expected inserted type `i32` (element of input `i32x4`), found `f64`\n+        simd_extract::<_, f32>(x, 0);\n+        //~^ ERROR expected return type `i32` (element of input `i32x4`), found `f32`\n+\n+        simd_shuffle2::<i32, i32>(0, 0, [0; 2]);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_shuffle3::<i32, i32>(0, 0, [0; 3]);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_shuffle4::<i32, i32>(0, 0, [0; 4]);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+        simd_shuffle8::<i32, i32>(0, 0, [0; 8]);\n+        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n+\n+        simd_shuffle2::<_, f32x2>(x, x, [0; 2]);\n+//~^ ERROR element type `i32` (element of input `i32x4`), found `f32x2` with element type `f32`\n+        simd_shuffle3::<_, f32x3>(x, x, [0; 3]);\n+//~^ ERROR element type `i32` (element of input `i32x4`), found `f32x3` with element type `f32`\n+        simd_shuffle4::<_, f32x4>(x, x, [0; 4]);\n+//~^ ERROR element type `i32` (element of input `i32x4`), found `f32x4` with element type `f32`\n+        simd_shuffle8::<_, f32x8>(x, x, [0; 8]);\n+//~^ ERROR element type `i32` (element of input `i32x4`), found `f32x8` with element type `f32`\n+\n+        simd_shuffle2::<_, i32x8>(x, x, [0; 2]);\n+        //~^ ERROR expected return type of length 2, found `i32x8` with length 8\n+        simd_shuffle3::<_, i32x4>(x, x, [0; 3]);\n+        //~^ ERROR expected return type of length 3, found `i32x4` with length 4\n+        simd_shuffle4::<_, i32x3>(x, x, [0; 4]);\n+        //~^ ERROR expected return type of length 4, found `i32x3` with length 3\n+        simd_shuffle8::<_, i32x2>(x, x, [0; 8]);\n+        //~^ ERROR expected return type of length 8, found `i32x2` with length 2\n+    }\n+}"}, {"sha": "0d0bf240f720a2f117367c394485974b4fd4ce26", "filename": "src/test/compile-fail/simd-intrinsic-single-nominal-type.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-single-nominal-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-single-nominal-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-single-nominal-type.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+struct A(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+struct B(i16, i16, i16, i16, i16, i16, i16, i16);\n+\n+// each intrinsic definition has to use the same nominal type for any\n+// vector structure throughout that declaration (i.e. every instance\n+// of i16x8 in each `fn ...;` needs to be either A or B)\n+\n+extern \"platform-intrinsic\" {\n+    fn x86_mm_adds_epi16(x: A, y: A) -> B;\n+    //~^ ERROR intrinsic return value has wrong type: found `B`, expected `A`\n+    fn x86_mm_subs_epi16(x: A, y: B) -> A;\n+    //~^ ERROR intrinsic argument 2 has wrong type: found `B`, expected `A`\n+\n+    // ok:\n+    fn x86_mm_max_epi16(x: B, y: B) -> B;\n+    fn x86_mm_min_epi16(x: A, y: A) -> A;\n+}\n+\n+fn main() {}"}, {"sha": "336855eb5e18b2bca8fdd6d3f65bfcfbd9f6e0ef", "filename": "src/test/compile-fail/simd-type-generic-monomorphisation.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-type-generic-monomorphisation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-type-generic-monomorphisation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-type-generic-monomorphisation.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core_simd)]\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+// error-pattern:monomorphising SIMD type `Simd2<X>` with a non-machine element type `X`\n+\n+struct X(Vec<i32>);\n+#[repr(simd)]\n+struct Simd2<T>(T, T);\n \n-use std::simd::i32x4;\n fn main() {\n-    let foo = i32x4(1,2,3,4);\n-    let bar = i32x4(40,30,20,10);\n-    let baz = foo + bar;\n-    assert!(baz.0 == 41 && baz.1 == 32 && baz.2 == 23 && baz.3 == 14);\n+    let _ = Simd2(X(vec![]), X(vec![]));\n }", "previous_filename": "src/test/run-pass/issue-23037.rs"}, {"sha": "cde63aa0cd1641b9f81a08c7a3e612f838c705c7", "filename": "src/test/compile-fail/simd-type.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Fcompile-fail%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-type.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -8,18 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(simd)]\n+#![feature(repr_simd)]\n \n-#[simd]\n-struct vec4<T>(T, T, T, T); //~ ERROR SIMD vector cannot be generic\n-\n-#[simd]\n+#[repr(simd)]\n struct empty; //~ ERROR SIMD vector cannot be empty\n \n-#[simd]\n+#[repr(simd)]\n struct i64f64(i64, f64); //~ ERROR SIMD vector should be homogeneous\n \n-#[simd]\n+#[repr(simd)]\n struct int4(isize, isize, isize, isize); //~ ERROR SIMD vector element type should be machine type\n \n fn main() {}"}, {"sha": "eac38037b4bc1a12e6d0077da7806e474a2c9760", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -23,9 +23,11 @@ use syntax::print::pprust;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n+    let mut feature_gated_cfgs = vec![];\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()));\n+        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n+        &mut feature_gated_cfgs);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "a3bce00ee07cc1f9c1b5287152c08ef6587b7500", "filename": "src/test/run-fail/overflowing-simd-lsh-1.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-1.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n-\n-#![feature(core_simd)]\n-\n-use std::simd::i32x4;\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn main() {\n-    let _x = i32x4(1, 0, 0, 0) << id(i32x4(32, 0, 0, 0));\n-}"}, {"sha": "e119bd03c888419f1922dee450b40b1151c7a3a5", "filename": "src/test/run-fail/overflowing-simd-lsh-2.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-2.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n-\n-#![feature(core_simd)]\n-\n-use std::simd::i32x4;\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn main() {\n-    let _x = i32x4(1, 0, 0, 0) << id(i32x4(-1, 0, 0, 0));\n-}"}, {"sha": "4fb7fa958f041039355aa010d689dfc3331386c4", "filename": "src/test/run-fail/overflowing-simd-lsh-3.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-3.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n-\n-#![feature(core_simd)]\n-\n-use std::simd::u64x2;\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn main() {\n-    let _x = u64x2(1, 0) << id(u64x2(64, 0));\n-}"}, {"sha": "2fc177ced9ddb9ce08cca217e698fc2f1fd39df2", "filename": "src/test/run-fail/overflowing-simd-lsh-4.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-4.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n-\n-// This function is checking that our automatic truncation does not\n-// sidestep the overflow checking.\n-\n-#![feature(core_simd)]\n-\n-use std::simd::i8x16;\n-\n-fn eq_i8x16(i8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): i8x16,\n-            i8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): i8x16)\n-            -> bool\n-{\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n-        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n-        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n-}\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn main() {\n-    // this signals overflow when checking is on\n-    let x = i8x16(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n-        << id(i8x16(17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n-\n-    // ... but when checking is off, the fallback will truncate the\n-    // input to its lower three bits (= 1). Note that this is *not*\n-    // the behavior of the x86 processor for 8- and 16-bit types,\n-    // but it is necessary to avoid undefined behavior from LLVM.\n-    //\n-    // We check that here, by ensuring the result has only been\n-    // shifted by one place; if overflow checking is turned off, then\n-    // this assertion will pass (and the compiletest driver will\n-    // report that the test did not produce the error expected above).\n-    assert!(eq_i8x16(x, i8x16(2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n-}"}, {"sha": "2852e147f837d5874e87823ece4627f4954e313c", "filename": "src/test/run-fail/overflowing-simd-rsh-2.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-2.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n-\n-#![feature(core_simd)]\n-\n-use std::simd::i32x4;\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn main() {\n-    let _x = i32x4(0, 0, 0, -1) >> id(i32x4(0, 0, 0, -1));\n-}"}, {"sha": "057eaa3f91aa0b19075f707c3ae7435478573d1f", "filename": "src/test/run-fail/overflowing-simd-rsh-3.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-3.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n-\n-#![feature(core_simd)]\n-\n-use std::simd::i64x2;\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn main() {\n-    let _x = i64x2(0, -1) >> id(i64x2(0, 64));\n-}"}, {"sha": "a850fff691917b9211bfa17b5ad63390a03a1ef1", "filename": "src/test/run-fail/overflowing-simd-rsh-4.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-4.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n-// compile-flags: -C debug-assertions\n-\n-// This function is checking that our (type-based) automatic\n-// truncation does not sidestep the overflow checking.\n-\n-#![feature(core_simd)]\n-\n-use std::simd::i8x16;\n-\n-fn eq_i8x16(i8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): i8x16,\n-            i8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): i8x16)\n-            -> bool\n-{\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n-        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n-        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n-}\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn main() {\n-    // this signals overflow when checking is on\n-    let x = i8x16(2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n-        >> id(i8x16(17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n-\n-    // ... but when checking is off, the fallback will truncate the\n-    // input to its lower three bits (= 1). Note that this is *not*\n-    // the behavior of the x86 processor for 8- and 16-bit types,\n-    // but it is necessary to avoid undefined behavior from LLVM.\n-    //\n-    // We check that here, by ensuring the result is not zero; if\n-    // overflow checking is turned off, then this assertion will pass\n-    // (and the compiletest driver will report that the test did not\n-    // produce the error expected above).\n-    assert!(eq_i8x16(x, i8x16(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n-}"}, {"sha": "c0c4b1e7f3f312e4516c38d1e2fea8368eedf4c1", "filename": "src/test/run-make/simd-ffi/simd.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -15,12 +15,12 @@\n #![feature(no_core)]\n #![no_core]\n \n-#![feature(simd, simd_ffi, link_llvm_intrinsics, lang_items)]\n+#![feature(repr_simd, simd_ffi, link_llvm_intrinsics, lang_items)]\n \n \n #[repr(C)]\n #[derive(Copy)]\n-#[simd]\n+#[repr(simd)]\n pub struct f32x4(f32, f32, f32, f32);\n \n \n@@ -35,7 +35,7 @@ pub fn foo(x: f32x4) -> f32x4 {\n \n #[repr(C)]\n #[derive(Copy)]\n-#[simd]\n+#[repr(simd)]\n pub struct i32x4(i32, i32, i32, i32);\n \n "}, {"sha": "e272a5fe4f6cd091ddcb66c1e9e06a3fd5b858d4", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -19,9 +19,11 @@ use syntax::print::pprust::*;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n+    let mut feature_gated_cfgs = vec![];\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()));\n+        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n+        &mut feature_gated_cfgs);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "c786064ba01ae4c9f2c5ecba52beeea9f6f95f3b", "filename": "src/test/run-pass/issue-17170.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fissue-17170.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fissue-17170.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17170.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(simd)]\n+#![feature(repr_simd)]\n \n-#[simd]\n+#[repr(simd)]\n struct T(f64, f64, f64);\n \n static X: T = T(0.0, 0.0, 0.0);"}, {"sha": "f56c3fefbe8f35078bcafbfcb6581db40451ec8c", "filename": "src/test/run-pass/issue-24258.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fissue-24258.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fissue-24258.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24258.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -C debug-assertions\n-\n-#![feature(core_simd)]\n-\n-use std::simd::u32x4;\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn eq_u32x4(u32x4(x0, x1, x2, x3): u32x4, u32x4(y0, y1, y2, y3): u32x4) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-}\n-\n-fn main() {\n-    assert!(eq_u32x4(u32x4(1, 1, 1, 1) << id(u32x4(1, 1, 1, 1)), u32x4(2, 2, 2, 2)));\n-}"}, {"sha": "4f5119f6a84e928e9a4b4a43aa2f95e3a1fbb0e3", "filename": "src/test/run-pass/simd-binop.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-binop.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,76 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![feature(core_simd)]\n-\n-use std::simd::{i32x4, f32x4, u32x4};\n-\n-fn eq_u32x4(u32x4(x0, x1, x2, x3): u32x4, u32x4(y0, y1, y2, y3): u32x4) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-}\n-\n-fn eq_f32x4(f32x4(x0, x1, x2, x3): f32x4, f32x4(y0, y1, y2, y3): f32x4) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-}\n-\n-fn eq_i32x4(i32x4(x0, x1, x2, x3): i32x4, i32x4(y0, y1, y2, y3): i32x4) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-}\n-\n-pub fn main() {\n-    // arithmetic operators\n-\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) + u32x4(4, 3, 2, 1), u32x4(5, 5, 5, 5)));\n-    assert!(eq_u32x4(u32x4(4, 5, 6, 7) - u32x4(4, 3, 2, 1), u32x4(0, 2, 4, 6)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) * u32x4(4, 3, 2, 1), u32x4(4, 6, 6, 4)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) / u32x4(4, 3, 2, 1), u32x4(0, 0, 1, 4)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) & u32x4(4, 3, 2, 1), u32x4(0, 2, 2, 0)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) | u32x4(4, 3, 2, 1), u32x4(5, 3, 3, 5)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) ^ u32x4(4, 3, 2, 1), u32x4(5, 1, 1, 5)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) << u32x4(4, 3, 2, 1), u32x4(16, 16, 12, 8)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, 4) >> u32x4(4, 3, 2, 1), u32x4(0, 0, 0, 2)));\n-\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) + i32x4(4, 3, 2, 1), i32x4(5, 5, 5, 5)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) - i32x4(4, 3, 2, 1), i32x4(-3, -1, 1, 3)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) * i32x4(4, 3, 2, 1), i32x4(4, 6, 6, 4)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) / i32x4(4, 3, 2, 1), i32x4(0, 0, 1, 4)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) & i32x4(4, 3, 2, 1), i32x4(0, 2, 2, 0)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) | i32x4(4, 3, 2, 1), i32x4(5, 3, 3, 5)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) ^ i32x4(4, 3, 2, 1), i32x4(5, 1, 1, 5)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) << i32x4(4, 3, 2, 1), i32x4(16, 16, 12, 8)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, 4) >> i32x4(4, 3, 2, 1), i32x4(0, 0, 0, 2)));\n-\n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) + f32x4(4.0, 3.0, 2.0, 1.0),\n-            f32x4(5.0, 5.0, 5.0, 5.0)));\n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) - f32x4(4.0, 3.0, 2.0, 1.0),\n-            f32x4(-3.0, -1.0, 1.0, 3.0)));\n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) * f32x4(4.0, 3.0, 2.0, 1.0),\n-            f32x4(4.0, 6.0, 6.0, 4.0)));\n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) / f32x4(4.0, 4.0, 2.0, 1.0),\n-            f32x4(0.25, 0.5, 1.5, 4.0)));\n-\n-    // comparison operators\n-\n-    // check !0/-1 to ensure operators are using the correct signedness.\n-    assert!(eq_u32x4(u32x4(1, 2, 3, !0) == u32x4(3, 2, 1, 0), u32x4(0, !0, 0, 0)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, !0) != u32x4(3, 2, 1, 0), u32x4(!0, 0, !0, !0)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, !0) < u32x4(3, 2, 1, 0), u32x4(!0, 0, 0, 0)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, !0) <= u32x4(3, 2, 1, 0), u32x4(!0, !0, 0, 0)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, !0) >= u32x4(3, 2, 1, 0), u32x4(0, !0, !0, !0)));\n-    assert!(eq_u32x4(u32x4(1, 2, 3, !0) > u32x4(3, 2, 1, 0), u32x4(0, 0, !0, !0)));\n-\n-    assert!(eq_i32x4(i32x4(1, 2, 3, -1) == i32x4(3, 2, 1, 0), i32x4(0, !0, 0, 0)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, -1) != i32x4(3, 2, 1, 0), i32x4(!0, 0, !0, !0)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, -1) < i32x4(3, 2, 1, 0), i32x4(!0, 0, 0, !0)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, -1) <= i32x4(3, 2, 1, 0), i32x4(!0, !0, 0, !0)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, -1) >= i32x4(3, 2, 1, 0), i32x4(0, !0, !0, 0)));\n-    assert!(eq_i32x4(i32x4(1, 2, 3, -1) > i32x4(3, 2, 1, 0), i32x4(0, 0, !0, 0)));\n-}"}, {"sha": "ef40a6ce96bd465df56a262e3aa3bc0d648d067b", "filename": "src/test/run-pass/simd-generics.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-generics.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -10,14 +10,18 @@\n \n \n \n-#![feature(simd)]\n+#![feature(repr_simd, platform_intrinsics)]\n \n use std::ops;\n \n-#[simd]\n+#[repr(simd)]\n #[derive(Copy, Clone)]\n struct f32x4(f32, f32, f32, f32);\n \n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(x: T, y: T) -> T;\n+}\n+\n fn add<T: ops::Add<Output=T>>(lhs: T, rhs: T) -> T {\n     lhs + rhs\n }\n@@ -26,7 +30,7 @@ impl ops::Add for f32x4 {\n     type Output = f32x4;\n \n     fn add(self, rhs: f32x4) -> f32x4 {\n-        self + rhs\n+        unsafe {simd_add(self, rhs)}\n     }\n }\n "}, {"sha": "5d4ecbb5f81722a4f32f24f50905cd56056c00ef", "filename": "src/test/run-pass/simd-intrinsic-generic-arithmetic.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-arithmetic.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+macro_rules! all_eq {\n+    ($a: expr, $b: expr) => {{\n+        let a = $a;\n+        let b = $b;\n+        assert!(a.0 == b.0 && a.1 == b.1 && a.2 == b.2 && a.3 == b.3);\n+    }}\n+}\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(x: T, y: T) -> T;\n+    fn simd_sub<T>(x: T, y: T) -> T;\n+    fn simd_mul<T>(x: T, y: T) -> T;\n+    fn simd_div<T>(x: T, y: T) -> T;\n+    fn simd_shl<T>(x: T, y: T) -> T;\n+    fn simd_shr<T>(x: T, y: T) -> T;\n+    fn simd_and<T>(x: T, y: T) -> T;\n+    fn simd_or<T>(x: T, y: T) -> T;\n+    fn simd_xor<T>(x: T, y: T) -> T;\n+}\n+\n+fn main() {\n+    let x1 = i32x4(1, 2, 3, 4);\n+    let y1 = u32x4(1, 2, 3, 4);\n+    let z1 = f32x4(1.0, 2.0, 3.0, 4.0);\n+    let x2 = i32x4(2, 3, 4, 5);\n+    let y2 = u32x4(2, 3, 4, 5);\n+    let z2 = f32x4(2.0, 3.0, 4.0, 5.0);\n+\n+    unsafe {\n+        all_eq!(simd_add(x1, x2), i32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(x2, x1), i32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(y1, y2), u32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(y2, y1), u32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(z1, z2), f32x4(3.0, 5.0, 7.0, 9.0));\n+        all_eq!(simd_add(z2, z1), f32x4(3.0, 5.0, 7.0, 9.0));\n+\n+        all_eq!(simd_mul(x1, x2), i32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(x2, x1), i32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(y1, y2), u32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(y2, y1), u32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(z1, z2), f32x4(2.0, 6.0, 12.0, 20.0));\n+        all_eq!(simd_mul(z2, z1), f32x4(2.0, 6.0, 12.0, 20.0));\n+\n+        all_eq!(simd_sub(x2, x1), i32x4(1, 1, 1, 1));\n+        all_eq!(simd_sub(x1, x2), i32x4(-1, -1, -1, -1));\n+        all_eq!(simd_sub(y2, y1), u32x4(1, 1, 1, 1));\n+        all_eq!(simd_sub(y1, y2), u32x4(!0, !0, !0, !0));\n+        all_eq!(simd_sub(z2, z1), f32x4(1.0, 1.0, 1.0, 1.0));\n+        all_eq!(simd_sub(z1, z2), f32x4(-1.0, -1.0, -1.0, -1.0));\n+\n+        all_eq!(simd_div(z1, z2), f32x4(1.0/2.0, 2.0/3.0, 3.0/4.0, 4.0/5.0));\n+        all_eq!(simd_div(z2, z1), f32x4(2.0/1.0, 3.0/2.0, 4.0/3.0, 5.0/4.0));\n+\n+        all_eq!(simd_shl(x1, x2), i32x4(1 << 2, 2 << 3, 3 << 4, 4 << 5));\n+        all_eq!(simd_shl(x2, x1), i32x4(2 << 1, 3 << 2, 4 << 3, 5 << 4));\n+        all_eq!(simd_shl(y1, y2), u32x4(1 << 2, 2 << 3, 3 << 4, 4 << 5));\n+        all_eq!(simd_shl(y2, y1), u32x4(2 << 1, 3 << 2, 4 << 3, 5 << 4));\n+\n+        // test right-shift by assuming left-shift is correct\n+        all_eq!(simd_shr(simd_shl(x1, x2), x2), x1);\n+        all_eq!(simd_shr(simd_shl(x2, x1), x1), x2);\n+        all_eq!(simd_shr(simd_shl(y1, y2), y2), y1);\n+        all_eq!(simd_shr(simd_shl(y2, y1), y1), y2);\n+\n+        // ensure we get logical vs. arithmetic shifts correct\n+        let (a, b, c, d) = (-12, -123, -1234, -12345);\n+        all_eq!(simd_shr(i32x4(a, b, c, d), x1), i32x4(a >> 1, b >> 2, c >> 3, d >> 4));\n+        all_eq!(simd_shr(u32x4(a as u32, b as u32, c as u32, d as u32), y1),\n+                u32x4((a as u32) >> 1, (b as u32) >> 2, (c as u32) >> 3, (d as u32) >> 4));\n+\n+        all_eq!(simd_and(x1, x2), i32x4(0, 2, 0, 4));\n+        all_eq!(simd_and(x2, x1), i32x4(0, 2, 0, 4));\n+        all_eq!(simd_and(y1, y2), u32x4(0, 2, 0, 4));\n+        all_eq!(simd_and(y2, y1), u32x4(0, 2, 0, 4));\n+\n+        all_eq!(simd_or(x1, x2), i32x4(3, 3, 7, 5));\n+        all_eq!(simd_or(x2, x1), i32x4(3, 3, 7, 5));\n+        all_eq!(simd_or(y1, y2), u32x4(3, 3, 7, 5));\n+        all_eq!(simd_or(y2, y1), u32x4(3, 3, 7, 5));\n+\n+        all_eq!(simd_xor(x1, x2), i32x4(3, 1, 7, 1));\n+        all_eq!(simd_xor(x2, x1), i32x4(3, 1, 7, 1));\n+        all_eq!(simd_xor(y1, y2), u32x4(3, 1, 7, 1));\n+        all_eq!(simd_xor(y2, y1), u32x4(3, 1, 7, 1));\n+\n+    }\n+}"}, {"sha": "a20dd3ef72a54cd831eebf714931095419dd00ad", "filename": "src/test/run-pass/simd-intrinsic-generic-cast.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics, concat_idents,\n+           type_macros, test)]\n+#![allow(non_camel_case_types)]\n+\n+extern crate test;\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct i8x4(i8, i8, i8, i8);\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct u32x4(u32, u32, u32, u32);\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct u8x4(u8, u8, u8, u8);\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct f32x4(f32, f32, f32, f32);\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct f64x4(f64, f64, f64, f64);\n+\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_cast<T, U>(x: T) -> U;\n+}\n+\n+const A: i32 = -1234567;\n+const B: i32 = 12345678;\n+const C: i32 = -123456789;\n+const D: i32 = 1234567890;\n+\n+trait Foo {\n+    fn is_float() -> bool { false }\n+    fn in_range(x: i32) -> bool;\n+}\n+impl Foo for i32 {\n+    fn in_range(_: i32) -> bool { true }\n+}\n+impl Foo for i8 {\n+    fn in_range(x: i32) -> bool { -128 <= x && x < 128 }\n+}\n+impl Foo for u32 {\n+    fn in_range(x: i32) -> bool { 0 <= x }\n+}\n+impl Foo for u8 {\n+    fn in_range(x: i32) -> bool { 0 <= x && x < 128 }\n+}\n+impl Foo for f32 {\n+    fn is_float() -> bool { true }\n+    fn in_range(_: i32) -> bool { true }\n+}\n+impl Foo for f64 {\n+    fn is_float() -> bool { true }\n+    fn in_range(_: i32) -> bool { true }\n+}\n+\n+fn main() {\n+    macro_rules! test {\n+        ($from: ident, $to: ident) => {{\n+            // force the casts to actually happen, or else LLVM/rustc\n+            // may fold them and get slightly different results.\n+            let (a, b, c, d) = test::black_box((A as $from, B as $from, C as $from, D as $from));\n+            // the SIMD vectors are all FOOx4, so we can concat_idents\n+            // so we don't have to pass in the extra args to the macro\n+            let mut from = simd_cast(concat_idents!($from, x4)(a, b, c, d));\n+            let mut to = concat_idents!($to, x4)(a as $to,\n+                                                 b as $to,\n+                                                 c as $to,\n+                                                 d as $to);\n+            // assist type inference, it needs to know what `from` is\n+            // for the `if` statements.\n+            to == from;\n+\n+            // there are platform differences for some out of range\n+            // casts, so we just normalize such things: it's OK for\n+            // \"invalid\" calculations to result in nonsense answers.\n+            // (E.g. negative float to unsigned integer goes through a\n+            // library routine on the default i686 platforms, and the\n+            // implementation of that routine differs on e.g. Linux\n+            // vs. OSX, resulting in different answers.)\n+            if $from::is_float() {\n+                if !$to::in_range(A) { from.0 = 0 as $to; to.0 = 0 as $to; }\n+                if !$to::in_range(B) { from.1 = 0 as $to; to.1 = 0 as $to; }\n+                if !$to::in_range(C) { from.2 = 0 as $to; to.2 = 0 as $to; }\n+                if !$to::in_range(D) { from.3 = 0 as $to; to.3 = 0 as $to; }\n+            }\n+\n+            assert!(to == from,\n+                    \"{} -> {} ({:?} != {:?})\", stringify!($from), stringify!($to),\n+                    from, to);\n+        }}\n+    }\n+    macro_rules! tests {\n+        (: $($to: ident),*) => { () };\n+        // repeating the list twice is easier than writing a cartesian\n+        // product macro\n+        ($from: ident $(, $from_: ident)*: $($to: ident),*) => {\n+            fn $from() { unsafe { $( test!($from, $to); )* } }\n+            tests!($($from_),*: $($to),*)\n+        };\n+        ($($types: ident),*) => {{\n+            tests!($($types),* : $($types),*);\n+            $($types();)*\n+        }}\n+    }\n+\n+    // test various combinations, including truncation,\n+    // signed/unsigned extension, and floating point casts.\n+    tests!(i32, i8, u32, u8, f32);\n+    tests!(i32, u32, f32, f64)\n+}"}, {"sha": "5802fb30bd68045f59e1a31e2376057316b04da7", "filename": "src/test/run-pass/simd-intrinsic-generic-comparison.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-comparison.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics, concat_idents)]\n+#![allow(non_camel_case_types)]\n+\n+use std::f32::NAN;\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_eq<T, U>(x: T, y: T) -> U;\n+    fn simd_ne<T, U>(x: T, y: T) -> U;\n+    fn simd_lt<T, U>(x: T, y: T) -> U;\n+    fn simd_le<T, U>(x: T, y: T) -> U;\n+    fn simd_gt<T, U>(x: T, y: T) -> U;\n+    fn simd_ge<T, U>(x: T, y: T) -> U;\n+}\n+\n+macro_rules! cmp {\n+    ($method: ident($lhs: expr, $rhs: expr)) => {{\n+        let lhs = $lhs;\n+        let rhs = $rhs;\n+        let e: u32x4 = concat_idents!(simd_, $method)($lhs, $rhs);\n+        // assume the scalar version is correct/the behaviour we want.\n+        assert!((e.0 != 0) == lhs.0 .$method(&rhs.0));\n+        assert!((e.1 != 0) == lhs.1 .$method(&rhs.1));\n+        assert!((e.2 != 0) == lhs.2 .$method(&rhs.2));\n+        assert!((e.3 != 0) == lhs.3 .$method(&rhs.3));\n+    }}\n+}\n+macro_rules! tests {\n+    ($($lhs: ident, $rhs: ident;)*) => {{\n+        $(\n+            (|| {\n+                cmp!(eq($lhs, $rhs));\n+                cmp!(ne($lhs, $rhs));\n+\n+                // test both directions\n+                cmp!(lt($lhs, $rhs));\n+                cmp!(lt($rhs, $lhs));\n+\n+                cmp!(le($lhs, $rhs));\n+                cmp!(le($rhs, $lhs));\n+\n+                cmp!(gt($lhs, $rhs));\n+                cmp!(gt($rhs, $lhs));\n+\n+                cmp!(ge($lhs, $rhs));\n+                cmp!(ge($rhs, $lhs));\n+            })();\n+            )*\n+    }}\n+}\n+fn main() {\n+    // 13 vs. -100 tests that we get signed vs. unsigned comparisons\n+    // correct (i32: 13 > -100, u32: 13 < -100).    let i1 = i32x4(10, -11, 12, 13);\n+    let i1 = i32x4(10, -11, 12, 13);\n+    let i2 = i32x4(5, -5, 20, -100);\n+    let i3 = i32x4(10, -11, 20, -100);\n+\n+    let u1 = u32x4(10, !11+1, 12, 13);\n+    let u2 = u32x4(5, !5+1, 20, !100+1);\n+    let u3 = u32x4(10, !11+1, 20, !100+1);\n+\n+    let f1 = f32x4(10.0, -11.0, 12.0, 13.0);\n+    let f2 = f32x4(5.0, -5.0, 20.0, -100.0);\n+    let f3 = f32x4(10.0, -11.0, 20.0, -100.0);\n+\n+    unsafe {\n+        tests! {\n+            i1, i1;\n+            u1, u1;\n+            f1, f1;\n+\n+            i1, i2;\n+            u1, u2;\n+            f1, f2;\n+\n+            i1, i3;\n+            u1, u3;\n+            f1, f3;\n+        }\n+    }\n+\n+    // NAN comparisons are special:\n+    // -11 (*)    13\n+    // -5        -100 (*)\n+    let f4 = f32x4(NAN, f1.1, NAN, f2.3);\n+\n+    unsafe {\n+        tests! {\n+            f1, f4;\n+            f2, f4;\n+            f4, f4;\n+        }\n+    }\n+}"}, {"sha": "f0444c27170561550a80c85b48e8e4f3f17dd2c1", "filename": "src/test/run-pass/simd-intrinsic-generic-elements.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x2(i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x3(i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x8(i32, i32, i32, i32,\n+             i32, i32, i32, i32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_insert<T, E>(x: T, idx: u32, y: E) -> T;\n+    fn simd_extract<T, E>(x: T, idx: u32) -> E;\n+\n+    fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;\n+    fn simd_shuffle3<T, U>(x: T, y: T, idx: [u32; 3]) -> U;\n+    fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;\n+    fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n+}\n+\n+macro_rules! all_eq {\n+    ($a: expr, $b: expr) => {{\n+        let a = $a;\n+        let b = $b;\n+        // type inference works better with the concrete type on the\n+        // left, but humans work better with the expected on the\n+        // right.\n+        assert!(b == a,\n+                \"{:?} != {:?}\", a, b);\n+    }}\n+}\n+\n+fn main() {\n+    let x2 = i32x2(20, 21);\n+    let x3 = i32x3(30, 31, 32);\n+    let x4 = i32x4(40, 41, 42, 43);\n+    let x8 = i32x8(80, 81, 82, 83, 84, 85, 86, 87);\n+    unsafe {\n+        all_eq!(simd_insert(x2, 0, 100), i32x2(100, 21));\n+        all_eq!(simd_insert(x2, 1, 100), i32x2(20, 100));\n+\n+        all_eq!(simd_insert(x3, 0, 100), i32x3(100, 31, 32));\n+        all_eq!(simd_insert(x3, 1, 100), i32x3(30, 100, 32));\n+        all_eq!(simd_insert(x3, 2, 100), i32x3(30, 31, 100));\n+\n+        all_eq!(simd_insert(x4, 0, 100), i32x4(100, 41, 42, 43));\n+        all_eq!(simd_insert(x4, 1, 100), i32x4(40, 100, 42, 43));\n+        all_eq!(simd_insert(x4, 2, 100), i32x4(40, 41, 100, 43));\n+        all_eq!(simd_insert(x4, 3, 100), i32x4(40, 41, 42, 100));\n+\n+        all_eq!(simd_insert(x8, 0, 100), i32x8(100, 81, 82, 83, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 1, 100), i32x8(80, 100, 82, 83, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 2, 100), i32x8(80, 81, 100, 83, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 3, 100), i32x8(80, 81, 82, 100, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 4, 100), i32x8(80, 81, 82, 83, 100, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 5, 100), i32x8(80, 81, 82, 83, 84, 100, 86, 87));\n+        all_eq!(simd_insert(x8, 6, 100), i32x8(80, 81, 82, 83, 84, 85, 100, 87));\n+        all_eq!(simd_insert(x8, 7, 100), i32x8(80, 81, 82, 83, 84, 85, 86, 100));\n+\n+        all_eq!(simd_extract(x2, 0), 20);\n+        all_eq!(simd_extract(x2, 1), 21);\n+\n+        all_eq!(simd_extract(x3, 0), 30);\n+        all_eq!(simd_extract(x3, 1), 31);\n+        all_eq!(simd_extract(x3, 2), 32);\n+\n+        all_eq!(simd_extract(x4, 0), 40);\n+        all_eq!(simd_extract(x4, 1), 41);\n+        all_eq!(simd_extract(x4, 2), 42);\n+        all_eq!(simd_extract(x4, 3), 43);\n+\n+        all_eq!(simd_extract(x8, 0), 80);\n+        all_eq!(simd_extract(x8, 1), 81);\n+        all_eq!(simd_extract(x8, 2), 82);\n+        all_eq!(simd_extract(x8, 3), 83);\n+        all_eq!(simd_extract(x8, 4), 84);\n+        all_eq!(simd_extract(x8, 5), 85);\n+        all_eq!(simd_extract(x8, 6), 86);\n+        all_eq!(simd_extract(x8, 7), 87);\n+    }\n+\n+    let y2 = i32x2(120, 121);\n+    let y3 = i32x3(130, 131, 132);\n+    let y4 = i32x4(140, 141, 142, 143);\n+    let y8 = i32x8(180, 181, 182, 183, 184, 185, 186, 187);\n+    unsafe {\n+        all_eq!(simd_shuffle2(x2, y2, [3, 0]), i32x2(121, 20));\n+        all_eq!(simd_shuffle3(x2, y2, [3, 0, 1]), i32x3(121, 20, 21));\n+        all_eq!(simd_shuffle4(x2, y2, [3, 0, 1, 2]), i32x4(121, 20, 21, 120));\n+        all_eq!(simd_shuffle8(x2, y2, [3, 0, 1, 2, 1, 2, 3, 0]),\n+                i32x8(121, 20, 21, 120, 21, 120, 121, 20));\n+\n+        all_eq!(simd_shuffle2(x3, y3, [4, 2]), i32x2(131, 32));\n+        all_eq!(simd_shuffle3(x3, y3, [4, 2, 3]), i32x3(131, 32, 130));\n+        all_eq!(simd_shuffle4(x3, y3, [4, 2, 3, 0]), i32x4(131, 32, 130, 30));\n+        all_eq!(simd_shuffle8(x3, y3, [4, 2, 3, 0, 1, 5, 5, 1]),\n+                i32x8(131, 32, 130, 30, 31, 132, 132, 31));\n+\n+        all_eq!(simd_shuffle2(x4, y4, [7, 2]), i32x2(143, 42));\n+        all_eq!(simd_shuffle3(x4, y4, [7, 2, 5]), i32x3(143, 42, 141));\n+        all_eq!(simd_shuffle4(x4, y4, [7, 2, 5, 0]), i32x4(143, 42, 141, 40));\n+        all_eq!(simd_shuffle8(x4, y4, [7, 2, 5, 0, 3, 6, 4, 1]),\n+                i32x8(143, 42, 141, 40, 43, 142, 140, 41));\n+\n+        all_eq!(simd_shuffle2(x8, y8, [11, 5]), i32x2(183, 85));\n+        all_eq!(simd_shuffle3(x8, y8, [11, 5, 15]), i32x3(183, 85, 187));\n+        all_eq!(simd_shuffle4(x8, y8, [11, 5, 15, 0]), i32x4(183, 85, 187, 80));\n+        all_eq!(simd_shuffle8(x8, y8, [11, 5, 15, 0, 3, 8, 12, 1]),\n+                i32x8(183, 85, 187, 80, 83, 180, 184, 81));\n+    }\n+\n+}"}, {"sha": "fee4637f07f2114f9ba2119ad60f5e48254b9d5f", "filename": "src/test/run-pass/simd-shift-near-oflo.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fsimd-shift-near-oflo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fsimd-shift-near-oflo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-shift-near-oflo.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -C debug-assertions\n-\n-// Check that we do *not* overflow on a number of edge cases.\n-// (compare with test/run-fail/overflowing-{lsh,rsh}*.rs)\n-\n-#![feature(core_simd)]\n-\n-use std::simd::{i8x16, i16x8, i32x4, i64x2, u8x16, u16x8, u32x4, u64x2};\n-\n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n-fn single_i8x16(x: i8) -> i8x16 { i8x16(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x) }\n-fn single_u8x16(x: u8) -> u8x16 { u8x16(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x) }\n-fn single_i16x8(x: i16) -> i16x8 { i16x8(0, 0, 0, 0, 0, 0, 0, x) }\n-fn single_u16x8(x: u16) -> u16x8 { u16x8(0, 0, 0, 0, 0, 0, 0, x) }\n-fn single_i32x4(x: i32) -> i32x4 { i32x4(0, 0, 0, x) }\n-fn single_u32x4(x: u32) -> u32x4 { u32x4(0, 0, 0, x) }\n-fn single_i64x2(x: i64) -> i64x2 { i64x2(0, x) }\n-fn single_u64x2(x: u64) -> u64x2 { u64x2(0, x) }\n-\n-fn eq_i8x16(i8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): i8x16,\n-            i8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): i8x16)\n-            -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n-        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n-        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n-}\n-fn eq_u8x16(u8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): u8x16,\n-            u8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): u8x16)\n-            -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n-        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n-        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n-}\n-fn eq_i16x8(i16x8(x0, x1, x2, x3, x4, x5, x6, x7): i16x8,\n-            i16x8(y0, y1, y2, y3, y4, y5, y6, y7): i16x8) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n-}\n-fn eq_u16x8(u16x8(x0, x1, x2, x3, x4, x5, x6, x7): u16x8,\n-            u16x8(y0, y1, y2, y3, y4, y5, y6, y7): u16x8) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n-}\n-fn eq_i32x4(i32x4(x0, x1, x2, x3): i32x4, i32x4(y0, y1, y2, y3): i32x4) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-}\n-fn eq_u32x4(u32x4(x0, x1, x2, x3): u32x4, u32x4(y0, y1, y2, y3): u32x4) -> bool {\n-    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n-}\n-fn eq_i64x2(i64x2(x0, x1): i64x2, i64x2(y0, y1): i64x2) -> bool {\n-    (x0 == y0) && (x1 == y1)\n-}\n-fn eq_u64x2(u64x2(x0, x1): u64x2, u64x2(y0, y1): u64x2) -> bool {\n-    (x0 == y0) && (x1 == y1)\n-}\n-\n-fn main() {\n-    test_left_shift();\n-    test_right_shift();\n-}\n-\n-fn test_left_shift() {\n-    // negative rhs can panic, but values in [0,N-1] are okay for iN\n-\n-    macro_rules! tests {\n-        ($single:ident, $eq:ident, $max_rhs:expr, $expect:expr) => { {\n-            let x = $single(1) << id($single(0));\n-            assert!($eq(x, $single(1)));\n-            let x = $single(1) << id($single($max_rhs));\n-            assert!($eq(x, $single($expect)));\n-            // high-order bits on LHS are silently discarded without panic.\n-            let x = $single(3) << id($single($max_rhs));\n-            assert!($eq(x, $single($expect)));\n-        } }\n-    }\n-\n-    let x = single_i8x16(1) << id(single_i8x16(0));\n-    assert!(eq_i8x16(x, single_i8x16(1)));\n-    let x = single_u8x16(1) << id(single_u8x16(0));\n-    assert!(eq_u8x16(x, single_u8x16(1)));\n-    let x = single_i8x16(1) << id(single_i8x16(7));\n-    assert!(eq_i8x16(x, single_i8x16(std::i8::MIN)));\n-    let x = single_u8x16(1) << id(single_u8x16(7));\n-    assert!(eq_u8x16(x, single_u8x16(0x80)));\n-    // high-order bits on LHS are silently discarded without panic.\n-    let x = single_i8x16(3) << id(single_i8x16(7));\n-    assert!(eq_i8x16(x, single_i8x16(std::i8::MIN)));\n-    let x = single_u8x16(3) << id(single_u8x16(7));\n-    assert!(eq_u8x16(x, single_u8x16(0x80)));\n-\n-    // above is (approximately) expanded from:\n-    tests!(single_i8x16, eq_i8x16, 7, std::i8::MIN);\n-    tests!(single_u8x16, eq_u8x16, 7, 0x80_u8);\n-\n-    tests!(single_i16x8, eq_i16x8, 15, std::i16::MIN);\n-    tests!(single_u16x8, eq_u16x8, 15, 0x8000_u16);\n-\n-    tests!(single_i32x4, eq_i32x4, 31, std::i32::MIN);\n-    tests!(single_u32x4, eq_u32x4, 31, 0x8000_0000_u32);\n-\n-    tests!(single_i64x2, eq_i64x2, 63, std::i64::MIN);\n-    tests!(single_u64x2, eq_u64x2, 63, 0x8000_0000_0000_0000_u64);\n-}\n-\n-fn test_right_shift() {\n-    // negative rhs can panic, but values in [0,N-1] are okay for iN\n-\n-    macro_rules! tests {\n-        ($single_i:ident, $eq_i:ident, $single_u:ident, $eq_u:ident,\n-         $max_rhs:expr, $signbit_i:expr, $highbit_i:expr, $highbit_u:expr) => { {\n-            let x = $single_i(1) >> id($single_i(0));\n-            assert!($eq_i(x, $single_i(1)));\n-            let x = $single_u(1) >> id($single_u(0));\n-            assert!($eq_u(x, $single_u(1)));\n-            let x = $single_u($highbit_i) >> id($single_u($max_rhs-1));\n-            assert!($eq_u(x, $single_u(1)));\n-            let x = $single_u($highbit_u) >> id($single_u($max_rhs));\n-            assert!($eq_u(x, $single_u(1)));\n-            // sign-bit is carried by arithmetic right shift\n-            let x = $single_i($signbit_i) >> id($single_i($max_rhs));\n-            assert!($eq_i(x, $single_i(-1)));\n-            // low-order bits on LHS are silently discarded without panic.\n-            let x = $single_u($highbit_i + 1) >> id($single_u($max_rhs-1));\n-            assert!($eq_u(x, $single_u(1)));\n-            let x = $single_u($highbit_u + 1) >> id($single_u($max_rhs));\n-            assert!($eq_u(x, $single_u(1)));\n-            let x = $single_i($signbit_i + 1) >> id($single_i($max_rhs));\n-            assert!($eq_i(x, $single_i(-1)));\n-        } }\n-    }\n-\n-    tests!(single_i8x16, eq_i8x16, single_u8x16, eq_u8x16,\n-           7, std::i8::MIN, 0x40_u8, 0x80_u8);\n-    tests!(single_i16x8, eq_i16x8, single_u16x8, eq_u16x8,\n-           15, std::i16::MIN, 0x4000_u16, 0x8000_u16);\n-    tests!(single_i32x4, eq_i32x4, single_u32x4, eq_u32x4,\n-           31, std::i32::MIN, 0x4000_0000_u32, 0x8000_0000_u32);\n-    tests!(single_i64x2, eq_i64x2, single_u64x2, eq_u64x2,\n-           63, std::i64::MIN, 0x4000_0000_0000_0000_u64, 0x8000_0000_0000_0000_u64);\n-}"}, {"sha": "b8d7cd8414176964ef23a66f1609a8022cf043f2", "filename": "src/test/run-pass/simd-size-align.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-size-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-size-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-size-align.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![feature(simd)]\n+#![feature(repr_simd)]\n #![allow(non_camel_case_types)]\n \n use std::mem;\n@@ -46,26 +46,26 @@ fn main() {\n     check::<f32x8>();\n }\n \n-#[simd] struct u8x2(u8, u8);\n-#[simd] struct u8x3(u8, u8, u8);\n-#[simd] struct u8x4(u8, u8, u8, u8);\n-#[simd] struct u8x5(u8, u8, u8, u8, u8);\n-#[simd] struct u8x6(u8, u8, u8, u8, u8, u8);\n-#[simd] struct u8x7(u8, u8, u8, u8, u8, u8, u8);\n-#[simd] struct u8x8(u8, u8, u8, u8, u8, u8, u8, u8);\n+#[repr(simd)] struct u8x2(u8, u8);\n+#[repr(simd)] struct u8x3(u8, u8, u8);\n+#[repr(simd)] struct u8x4(u8, u8, u8, u8);\n+#[repr(simd)] struct u8x5(u8, u8, u8, u8, u8);\n+#[repr(simd)] struct u8x6(u8, u8, u8, u8, u8, u8);\n+#[repr(simd)] struct u8x7(u8, u8, u8, u8, u8, u8, u8);\n+#[repr(simd)] struct u8x8(u8, u8, u8, u8, u8, u8, u8, u8);\n \n-#[simd] struct i16x2(i16, i16);\n-#[simd] struct i16x3(i16, i16, i16);\n-#[simd] struct i16x4(i16, i16, i16, i16);\n-#[simd] struct i16x5(i16, i16, i16, i16, i16);\n-#[simd] struct i16x6(i16, i16, i16, i16, i16, i16);\n-#[simd] struct i16x7(i16, i16, i16, i16, i16, i16, i16);\n-#[simd] struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)] struct i16x2(i16, i16);\n+#[repr(simd)] struct i16x3(i16, i16, i16);\n+#[repr(simd)] struct i16x4(i16, i16, i16, i16);\n+#[repr(simd)] struct i16x5(i16, i16, i16, i16, i16);\n+#[repr(simd)] struct i16x6(i16, i16, i16, i16, i16, i16);\n+#[repr(simd)] struct i16x7(i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)] struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n \n-#[simd] struct f32x2(f32, f32);\n-#[simd] struct f32x3(f32, f32, f32);\n-#[simd] struct f32x4(f32, f32, f32, f32);\n-#[simd] struct f32x5(f32, f32, f32, f32, f32);\n-#[simd] struct f32x6(f32, f32, f32, f32, f32, f32);\n-#[simd] struct f32x7(f32, f32, f32, f32, f32, f32, f32);\n-#[simd] struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);\n+#[repr(simd)] struct f32x2(f32, f32);\n+#[repr(simd)] struct f32x3(f32, f32, f32);\n+#[repr(simd)] struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)] struct f32x5(f32, f32, f32, f32, f32);\n+#[repr(simd)] struct f32x6(f32, f32, f32, f32, f32, f32);\n+#[repr(simd)] struct f32x7(f32, f32, f32, f32, f32, f32, f32);\n+#[repr(simd)] struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);"}, {"sha": "2883b80a25b9e39fc73eea490c8ed46c41761a13", "filename": "src/test/run-pass/simd-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35fd748114c22df6d08991980c4f7e199414497/src%2Ftest%2Frun-pass%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-type.rs?ref=e35fd748114c22df6d08991980c4f7e199414497", "patch": "@@ -11,9 +11,9 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(simd)]\n+#![feature(repr_simd)]\n \n-#[simd]\n+#[repr(simd)]\n struct RGBA {\n     r: f32,\n     g: f32,"}]}