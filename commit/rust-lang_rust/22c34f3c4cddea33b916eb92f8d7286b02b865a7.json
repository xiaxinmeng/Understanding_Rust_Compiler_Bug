{"sha": "22c34f3c4cddea33b916eb92f8d7286b02b865a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyYzM0ZjNjNGNkZGVhMzNiOTE2ZWI5MmY4ZDcyODZiMDJiODY1YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T04:36:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T04:36:55Z"}, "message": "auto merge of #12172 : alexcrichton/rust/green-improvements, r=brson\n\nThese commits pick off some low-hanging fruit which were slowing down spawning green threads. The major speedup comes from fixing a bug in stack caching where we never used any cached stacks!\r\n\r\nThe program I used to benchmark is at the end. It was compiled with `rustc --opt-level=3 bench.rs --test` and run as `RUST_THREADS=1 ./bench --bench`. I chose to use `RUST_THREADS=1` due to #11730 as the profiles I was getting interfered too much when all the schedulers were in play (and shouldn't be after #11730 is fixed). All of the units below are in ns/iter as reported by `--bench` (lower is better).\r\n\r\n|               | green | native | raw    |\r\n| ------------- | ----- | ------ | ------ |\r\n| osx before    | 12699 | 24030  | 19734  |\r\n| linux before  | 10223 | 125983 | 122647 |\r\n| osx after     |  3847 | 25771  | 20835  |\r\n| linux after   |  2631 | 135398 | 122765 |\r\n\r\nNote that this is *not* a benchmark of spawning green tasks vs native tasks. I put in the native numbers just to get a ballpark of where green tasks are. This is benchmark is *clearly* benefiting from stack caching. Also, OSX is clearly not 5x faster than linux, I think my VM is just much slower.\r\n\r\nAll in all, this ended up being a nice 4x speedup for spawning a green task when you're using a cached stack.\r\n\r\n```rust\r\nextern mod extra;\r\nextern mod native;\r\nuse std::rt::thread::Thread;\r\n\r\n#[bench]\r\nfn green(bh: &mut extra::test::BenchHarness) {\r\n    let (p, c) = SharedChan::new();\r\n    bh.iter(|| {\r\n        let c = c.clone();\r\n        spawn(proc() {\r\n            c.send(());\r\n        });\r\n        p.recv();\r\n    });\r\n}\r\n\r\n#[bench]\r\nfn native(bh: &mut extra::test::BenchHarness) {\r\n    let (p, c) = SharedChan::new();\r\n    bh.iter(|| {\r\n        let c = c.clone();\r\n        native::task::spawn(proc() {\r\n            c.send(());\r\n        });\r\n        p.recv();\r\n    });\r\n}\r\n\r\n#[bench]\r\nfn raw(bh: &mut extra::test::BenchHarness) {\r\n    bh.iter(|| {\r\n        Thread::start(proc() {}).join()\r\n    });\r\n}\r\n```", "tree": {"sha": "dd36da3994499e5bac9aba767edc126f36d54f67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd36da3994499e5bac9aba767edc126f36d54f67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22c34f3c4cddea33b916eb92f8d7286b02b865a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22c34f3c4cddea33b916eb92f8d7286b02b865a7", "html_url": "https://github.com/rust-lang/rust/commit/22c34f3c4cddea33b916eb92f8d7286b02b865a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22c34f3c4cddea33b916eb92f8d7286b02b865a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68129d299b54806b6aa4ec9f3a0755854db7b491", "url": "https://api.github.com/repos/rust-lang/rust/commits/68129d299b54806b6aa4ec9f3a0755854db7b491", "html_url": "https://github.com/rust-lang/rust/commit/68129d299b54806b6aa4ec9f3a0755854db7b491"}, {"sha": "301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "url": "https://api.github.com/repos/rust-lang/rust/commits/301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "html_url": "https://github.com/rust-lang/rust/commit/301ff0c2df3d26a5b287ab61d80f5ca7845e827b"}], "stats": {"total": 372, "additions": 231, "deletions": 141}, "files": [{"sha": "80231ad2ba4bca60b487649f6367c1668dd4a36b", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -57,7 +57,7 @@ TOOLS := compiletest rustdoc rustc\n \n DEPS_std := native:rustrt native:compiler-rt\n DEPS_extra := std term sync serialize getopts collections\n-DEPS_green := std\n+DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std extra term serialize collections"}, {"sha": "10b73c6b39533feebf171478d231cd3eefd55f57", "filename": "mk/rt.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -35,7 +35,7 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rustrt sundown uv_support morestack miniz\n+NATIVE_LIBS := rustrt sundown uv_support morestack miniz context_switch\n \n # $(1) is the target triple\n define NATIVE_LIBRARIES\n@@ -54,9 +54,10 @@ NATIVE_DEPS_rustrt_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c \\\n \t\t\trust_test_helpers.c \\\n \t\t\trust_try.ll \\\n-\t\t\tarch/$$(HOST_$(1))/_context.S \\\n \t\t\tarch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n+NATIVE_DEPS_context_switch_$(1) := \\\n+\t\t\tarch/$$(HOST_$(1))/_context.S\n \n ################################################################################\n # You shouldn't find it that necessary to edit anything below this line."}, {"sha": "58188ede13cb6a8e559a276f9effee05589f54b6", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 60, "deletions": 53, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::libc::c_void;\n use std::uint;\n use std::cast::{transmute, transmute_mut_unsafe,\n                 transmute_region, transmute_mut_region};\n use stack::Stack;\n use std::unstable::stack;\n+use std::unstable::raw;\n \n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n@@ -22,47 +22,33 @@ use std::unstable::stack;\n // the registers are sometimes empty, but the discriminant would\n // then misalign the regs again.\n pub struct Context {\n-    /// The context entry point, saved here for later destruction\n-    priv start: Option<~proc()>,\n     /// Hold the registers while the task or scheduler is suspended\n     priv regs: ~Registers,\n     /// Lower bound and upper bound for the stack\n     priv stack_bounds: Option<(uint, uint)>,\n }\n \n+pub type InitFn = extern \"C\" fn(uint, *(), *()) -> !;\n+\n impl Context {\n     pub fn empty() -> Context {\n         Context {\n-            start: None,\n             regs: new_regs(),\n             stack_bounds: None,\n         }\n     }\n \n     /// Create a new context that will resume execution by running proc()\n-    pub fn new(start: proc(), stack: &mut Stack) -> Context {\n-        // The C-ABI function that is the task entry point\n-        //\n-        // Note that this function is a little sketchy. We're taking a\n-        // procedure, transmuting it to a stack-closure, and then calling to\n-        // closure. This leverages the fact that the representation of these two\n-        // types is the same.\n-        //\n-        // The reason that we're doing this is that this procedure is expected\n-        // to never return. The codegen which frees the environment of the\n-        // procedure occurs *after* the procedure has completed, and this means\n-        // that we'll never actually free the procedure.\n-        //\n-        // To solve this, we use this transmute (to not trigger the procedure\n-        // deallocation here), and then store a copy of the procedure in the\n-        // `Context` structure returned. When the `Context` is deallocated, then\n-        // the entire procedure box will be deallocated as well.\n-        extern fn task_start_wrapper(f: &proc()) {\n-            unsafe {\n-                let f: &|| = transmute(f);\n-                (*f)()\n-            }\n-        }\n+    ///\n+    /// The `init` function will be run with `arg` and the `start` procedure\n+    /// split up into code and env pointers. It is required that the `init`\n+    /// function never return.\n+    ///\n+    /// FIXME: this is basically an awful the interface. The main reason for\n+    ///        this is to reduce the number of allocations made when a green\n+    ///        task is spawned as much as possible\n+    pub fn new(init: InitFn, arg: uint, start: proc(),\n+               stack: &mut Stack) -> Context {\n \n         let sp: *uint = stack.end();\n         let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n@@ -74,14 +60,10 @@ impl Context {\n                                 transmute_region(&*regs));\n         };\n \n-        // FIXME #7767: Putting main into a ~ so it's a thin pointer and can\n-        // be passed to the spawn function.  Another unfortunate\n-        // allocation\n-        let start = ~start;\n-\n         initialize_call_frame(&mut *regs,\n-                              task_start_wrapper as *c_void,\n-                              unsafe { transmute(&*start) },\n+                              init,\n+                              arg,\n+                              unsafe { transmute(start) },\n                               sp);\n \n         // Scheduler tasks don't have a stack in the \"we allocated it\" sense,\n@@ -96,7 +78,6 @@ impl Context {\n             Some((stack_base as uint, sp as uint))\n         };\n         return Context {\n-            start: Some(start),\n             regs: regs,\n             stack_bounds: bounds,\n         }\n@@ -138,7 +119,7 @@ impl Context {\n     }\n }\n \n-#[link(name = \"rustrt\", kind = \"static\")]\n+#[link(name = \"context_switch\", kind = \"static\")]\n extern {\n     fn rust_swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n }\n@@ -185,13 +166,17 @@ fn new_regs() -> ~Registers {\n }\n \n #[cfg(target_arch = \"x86\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n \n+    // x86 has interesting stack alignment requirements, so do some alignment\n+    // plus some offsetting to figure out what the actual stack should be.\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n \n-    unsafe { *sp = arg as uint };\n+    unsafe { *mut_offset(sp, 2) = procedure.env as uint };\n+    unsafe { *mut_offset(sp, 1) = procedure.code as uint };\n+    unsafe { *mut_offset(sp, 0) = arg as uint };\n     let sp = mut_offset(sp, -1);\n     unsafe { *sp = 0 }; // The final return address\n \n@@ -215,14 +200,18 @@ fn new_regs() -> ~Registers { ~([0, .. 34]) }\n fn new_regs() -> ~Registers { ~([0, .. 22]) }\n \n #[cfg(target_arch = \"x86_64\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n+    extern { fn rust_bootstrap_green_task(); }\n \n     // Redefinitions from rt/arch/x86_64/regs.h\n-    static RUSTRT_ARG0: uint = 3;\n     static RUSTRT_RSP: uint = 1;\n     static RUSTRT_IP: uint = 8;\n     static RUSTRT_RBP: uint = 2;\n+    static RUSTRT_R12: uint = 4;\n+    static RUSTRT_R13: uint = 5;\n+    static RUSTRT_R14: uint = 6;\n+    static RUSTRT_R15: uint = 7;\n \n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -1);\n@@ -231,13 +220,23 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n     unsafe { *sp = 0; }\n \n     rtdebug!(\"creating call frame\");\n-    rtdebug!(\"fptr {}\", fptr);\n-    rtdebug!(\"arg {}\", arg);\n+    rtdebug!(\"fptr {:#x}\", fptr as uint);\n+    rtdebug!(\"arg {:#x}\", arg);\n     rtdebug!(\"sp {}\", sp);\n \n-    regs[RUSTRT_ARG0] = arg as uint;\n+    // These registers are frobbed by rust_bootstrap_green_task into the right\n+    // location so we can invoke the \"real init function\", `fptr`.\n+    regs[RUSTRT_R12] = arg as uint;\n+    regs[RUSTRT_R13] = procedure.code as uint;\n+    regs[RUSTRT_R14] = procedure.env as uint;\n+    regs[RUSTRT_R15] = fptr as uint;\n+\n+    // These registers are picked up by the regulard context switch paths. These\n+    // will put us in \"mostly the right context\" except for frobbing all the\n+    // arguments to the right place. We have the small trampoline code inside of\n+    // rust_bootstrap_green_task to do that.\n     regs[RUSTRT_RSP] = sp as uint;\n-    regs[RUSTRT_IP] = fptr as uint;\n+    regs[RUSTRT_IP] = rust_bootstrap_green_task as uint;\n \n     // Last base pointer on the stack should be 0\n     regs[RUSTRT_RBP] = 0;\n@@ -250,18 +249,26 @@ type Registers = [uint, ..32];\n fn new_regs() -> ~Registers { ~([0, .. 32]) }\n \n #[cfg(target_arch = \"arm\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n+    extern { fn rust_bootstrap_green_task(); }\n+\n     let sp = align_down(sp);\n     // sp of arm eabi is 8-byte aligned\n     let sp = mut_offset(sp, -2);\n \n     // The final return address. 0 indicates the bottom of the stack\n     unsafe { *sp = 0; }\n \n-    regs[0] = arg as uint;   // r0\n-    regs[13] = sp as uint;   // #53 sp, r13\n-    regs[14] = fptr as uint; // #60 pc, r15 --> lr\n+    // ARM uses the same technique as x86_64 to have a landing pad for the start\n+    // of all new green tasks. Neither r1/r2 are saved on a context switch, so\n+    // the shim will copy r3/r4 into r1/r2 and then execute the function in r5\n+    regs[0] = arg as uint;              // r0\n+    regs[3] = procedure.code as uint;   // r3\n+    regs[4] = procedure.env as uint;    // r4\n+    regs[5] = fptr as uint;             // r5\n+    regs[13] = sp as uint;                          // #52 sp, r13\n+    regs[14] = rust_bootstrap_green_task as uint;   // #56 pc, r14 --> lr\n }\n \n #[cfg(target_arch = \"mips\")]\n@@ -271,8 +278,8 @@ type Registers = [uint, ..32];\n fn new_regs() -> ~Registers { ~([0, .. 32]) }\n \n #[cfg(target_arch = \"mips\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n     let sp = align_down(sp);\n     // sp of mips o32 is 8-byte aligned\n     let sp = mut_offset(sp, -2);"}, {"sha": "b20892886c6dacd450d4f08256f9f37cf390e146", "filename": "src/libgreen/coroutine.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fcoroutine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fcoroutine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcoroutine.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -11,8 +11,6 @@\n // Coroutines represent nothing more than a context and a stack\n // segment.\n \n-use std::rt::env;\n-\n use context::Context;\n use stack::{StackPool, Stack};\n \n@@ -31,22 +29,6 @@ pub struct Coroutine {\n }\n \n impl Coroutine {\n-    pub fn new(stack_pool: &mut StackPool,\n-               stack_size: Option<uint>,\n-               start: proc())\n-               -> Coroutine {\n-        let stack_size = match stack_size {\n-            Some(size) => size,\n-            None => env::min_stack()\n-        };\n-        let mut stack = stack_pool.take_stack(stack_size);\n-        let initial_context = Context::new(start, &mut stack);\n-        Coroutine {\n-            current_stack_segment: stack,\n-            saved_context: initial_context\n-        }\n-    }\n-\n     pub fn empty() -> Coroutine {\n         Coroutine {\n             current_stack_segment: unsafe { Stack::dummy_stack() },"}, {"sha": "b224b0cabf365414df028e817d3686fac4094198", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -756,7 +756,7 @@ impl Scheduler {\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(mut ~self, cur: ~GreenTask) {\n+    pub fn terminate_current_task(mut ~self, cur: ~GreenTask) -> ! {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();"}, {"sha": "8a5e6be17c87d1f6f49ead6a87f8fe04e68ef2b5", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -138,9 +138,9 @@ impl StackPool {\n \n     pub fn take_stack(&mut self, min_size: uint) -> Stack {\n         // Ideally this would be a binary search\n-        match self.stacks.iter().position(|s| s.min_size < min_size) {\n+        match self.stacks.iter().position(|s| min_size <= s.min_size) {\n             Some(idx) => self.stacks.swap_remove(idx),\n-            None      => Stack::new(min_size)\n+            None => Stack::new(min_size)\n         }\n     }\n \n@@ -156,3 +156,33 @@ extern {\n                                     end: *libc::uintptr_t) -> libc::c_uint;\n     fn rust_valgrind_stack_deregister(id: libc::c_uint);\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::StackPool;\n+\n+    #[test]\n+    fn stack_pool_caches() {\n+        let mut p = StackPool::new();\n+        let s = p.take_stack(10);\n+        p.give_stack(s);\n+        let s = p.take_stack(4);\n+        assert_eq!(s.min_size, 10);\n+        p.give_stack(s);\n+        let s = p.take_stack(14);\n+        assert_eq!(s.min_size, 14);\n+        p.give_stack(s);\n+    }\n+\n+    #[test]\n+    fn stack_pool_caches_exact() {\n+        let mut p = StackPool::new();\n+        let mut s = p.take_stack(10);\n+        s.valgrind_id = 100;\n+        p.give_stack(s);\n+\n+        let s = p.take_stack(10);\n+        assert_eq!(s.min_size, 10);\n+        assert_eq!(s.valgrind_id, 100);\n+    }\n+}"}, {"sha": "2aca72e35f19dd22ec45e2a651a7d09bf137b20f", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -19,13 +19,16 @@\n //! values.\n \n use std::cast;\n+use std::rt::env;\n use std::rt::Runtime;\n-use std::rt::rtio;\n use std::rt::local::Local;\n-use std::rt::task::{Task, BlockedTask};\n+use std::rt::rtio;\n+use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::task::TaskOpts;\n use std::unstable::mutex::Mutex;\n+use std::unstable::raw;\n \n+use context::Context;\n use coroutine::Coroutine;\n use sched::{Scheduler, SchedHandle, RunOnce};\n use stack::StackPool;\n@@ -75,6 +78,50 @@ pub enum Home {\n     HomeSched(SchedHandle),\n }\n \n+/// Trampoline code for all new green tasks which are running around. This\n+/// function is passed through to Context::new as the initial rust landing pad\n+/// for all green tasks. This code is actually called after the initial context\n+/// switch onto a green thread.\n+///\n+/// The first argument to this function is the `~GreenTask` pointer, and the\n+/// next two arguments are the user-provided procedure for running code.\n+///\n+/// The goal for having this weird-looking function is to reduce the number of\n+/// allocations done on a green-task startup as much as possible.\n+extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n+    // Acquire ownership of the `proc()`\n+    let start: proc() = unsafe {\n+        cast::transmute(raw::Procedure { code: code, env: env })\n+    };\n+\n+    // Acquire ownership of the `~GreenTask`\n+    let mut task: ~GreenTask = unsafe { cast::transmute(task) };\n+\n+    // First code after swap to this new context. Run our cleanup job\n+    task.pool_id = {\n+        let sched = task.sched.get_mut_ref();\n+        sched.run_cleanup_job();\n+        sched.task_state.increment();\n+        sched.pool_id\n+    };\n+\n+    // Convert our green task to a libstd task and then execute the code\n+    // requested. This is the \"try/catch\" block for this green task and\n+    // is the wrapper for *all* code run in the task.\n+    let mut start = Some(start);\n+    let task = task.swap().run(|| start.take_unwrap()());\n+\n+    // Once the function has exited, it's time to run the termination\n+    // routine. This means we need to context switch one more time but\n+    // clean ourselves up on the other end. Since we have no way of\n+    // preserving a handle to the GreenTask down to this point, this\n+    // unfortunately must call `GreenTask::convert`. In order to avoid\n+    // this we could add a `terminate` function to the `Runtime` trait\n+    // in libstd, but that seems less appropriate since the coversion\n+    // method exists.\n+    GreenTask::convert(task).terminate()\n+}\n+\n impl GreenTask {\n     /// Creates a new green task which is not homed to any particular scheduler\n     /// and will not have any contained Task structure.\n@@ -89,9 +136,20 @@ impl GreenTask {\n                      stack_size: Option<uint>,\n                      home: Home,\n                      start: proc()) -> ~GreenTask {\n+        // Allocate ourselves a GreenTask structure\n         let mut ops = GreenTask::new_typed(None, TypeGreen(Some(home)));\n-        let start = GreenTask::build_start_wrapper(start, ops.as_uint());\n-        ops.coroutine = Some(Coroutine::new(stack_pool, stack_size, start));\n+\n+        // Allocate a stack for us to run on\n+        let stack_size = stack_size.unwrap_or_else(|| env::min_stack());\n+        let mut stack = stack_pool.take_stack(stack_size);\n+        let context = Context::new(bootstrap_green_task, ops.as_uint(), start,\n+                                   &mut stack);\n+\n+        // Package everything up in a coroutine and return\n+        ops.coroutine = Some(Coroutine {\n+            current_stack_segment: stack,\n+            saved_context: context,\n+        });\n         return ops;\n     }\n \n@@ -131,8 +189,7 @@ impl GreenTask {\n             task.stdout = stdout;\n             match notify_chan {\n                 Some(chan) => {\n-                    let on_exit = proc(task_result) { chan.send(task_result) };\n-                    task.death.on_exit = Some(on_exit);\n+                    task.death.on_exit = Some(SendMessage(chan));\n                 }\n                 None => {}\n             }\n@@ -157,46 +214,6 @@ impl GreenTask {\n         }\n     }\n \n-    /// Builds a function which is the actual starting execution point for a\n-    /// rust task. This function is the glue necessary to execute the libstd\n-    /// task and then clean up the green thread after it exits.\n-    ///\n-    /// The second argument to this function is actually a transmuted copy of\n-    /// the `GreenTask` pointer. Context switches in the scheduler silently\n-    /// transfer ownership of the `GreenTask` to the other end of the context\n-    /// switch, so because this is the first code that is running in this task,\n-    /// it must first re-acquire ownership of the green task.\n-    pub fn build_start_wrapper(start: proc(), ops: uint) -> proc() {\n-        proc() {\n-            // First code after swap to this new context. Run our\n-            // cleanup job after we have re-acquired ownership of the green\n-            // task.\n-            let mut task: ~GreenTask = unsafe { GreenTask::from_uint(ops) };\n-            task.pool_id = {\n-                let sched = task.sched.get_mut_ref();\n-                sched.run_cleanup_job();\n-                sched.task_state.increment();\n-                sched.pool_id\n-            };\n-\n-            // Convert our green task to a libstd task and then execute the code\n-            // requested. This is the \"try/catch\" block for this green task and\n-            // is the wrapper for *all* code run in the task.\n-            let mut start = Some(start);\n-            let task = task.swap().run(|| start.take_unwrap()());\n-\n-            // Once the function has exited, it's time to run the termination\n-            // routine. This means we need to context switch one more time but\n-            // clean ourselves up on the other end. Since we have no way of\n-            // preserving a handle to the GreenTask down to this point, this\n-            // unfortunately must call `GreenTask::convert`. In order to avoid\n-            // this we could add a `terminate` function to the `Runtime` trait\n-            // in libstd, but that seems less appropriate since the coversion\n-            // method exists.\n-            GreenTask::convert(task).terminate();\n-        }\n-    }\n-\n     pub fn give_home(&mut self, new_home: Home) {\n         match self.task_type {\n             TypeGreen(ref mut home) => { *home = Some(new_home); }\n@@ -279,9 +296,9 @@ impl GreenTask {\n         Local::put(self.swap());\n     }\n \n-    fn terminate(mut ~self) {\n+    fn terminate(mut ~self) -> ! {\n         let sched = self.sched.take_unwrap();\n-        sched.terminate_current_task(self);\n+        sched.terminate_current_task(self)\n     }\n \n     // This function is used to remotely wakeup this green task back on to its"}, {"sha": "a9c3afbbb16c8d0f6bf5f7cc5aa603be6c3dd2d5", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -18,7 +18,7 @@ use std::cast;\n use std::rt::env;\n use std::rt::local::Local;\n use std::rt::rtio;\n-use std::rt::task::{Task, BlockedTask};\n+use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::rt::thread::Thread;\n use std::rt;\n use std::task::TaskOpts;\n@@ -68,10 +68,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n     task.stderr = stderr;\n     task.stdout = stdout;\n     match notify_chan {\n-        Some(chan) => {\n-            let on_exit = proc(task_result) { chan.send(task_result) };\n-            task.death.on_exit = Some(on_exit);\n-        }\n+        Some(chan) => { task.death.on_exit = Some(SendMessage(chan)); }\n         None => {}\n     }\n "}, {"sha": "7acce2ecb5ba95baaf3a5c4c2287dc723a00dec8", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -23,6 +23,7 @@ use rt::local::Local;\n use rt::task::Task;\n use unstable::raw;\n use vec::ImmutableVector;\n+use vec_ng::Vec;\n \n // This has no meaning with out rtdebug also turned on.\n #[cfg(rtdebug)]\n@@ -33,7 +34,7 @@ static MAGIC: u32 = 0xbadc0ffe;\n pub type Box = raw::Box<()>;\n \n pub struct MemoryRegion {\n-    priv allocations: ~[*AllocHeader],\n+    priv allocations: Vec<*AllocHeader>,\n     priv live_allocations: uint,\n }\n \n@@ -48,7 +49,7 @@ impl LocalHeap {\n     #[inline]\n     pub fn new() -> LocalHeap {\n         let region = MemoryRegion {\n-            allocations: ~[],\n+            allocations: Vec::new(),\n             live_allocations: 0,\n         };\n         LocalHeap {\n@@ -248,8 +249,8 @@ impl MemoryRegion {\n     fn release(&mut self, alloc: &AllocHeader) {\n         alloc.assert_sane();\n         if TRACK_ALLOCATIONS > 1 {\n-            rtassert!(self.allocations[alloc.index] == alloc as *AllocHeader);\n-            self.allocations[alloc.index] = ptr::null();\n+            rtassert!(self.allocations.as_slice()[alloc.index] == alloc as *AllocHeader);\n+            self.allocations.as_mut_slice()[alloc.index] = ptr::null();\n         }\n     }\n     #[cfg(not(rtdebug))]\n@@ -260,8 +261,8 @@ impl MemoryRegion {\n     fn update(&mut self, alloc: &mut AllocHeader, orig: *AllocHeader) {\n         alloc.assert_sane();\n         if TRACK_ALLOCATIONS > 1 {\n-            rtassert!(self.allocations[alloc.index] == orig);\n-            self.allocations[alloc.index] = &*alloc as *AllocHeader;\n+            rtassert!(self.allocations.as_slice()[alloc.index] == orig);\n+            self.allocations.as_mut_slice()[alloc.index] = &*alloc as *AllocHeader;\n         }\n     }\n     #[cfg(not(rtdebug))]\n@@ -274,7 +275,7 @@ impl Drop for MemoryRegion {\n         if self.live_allocations != 0 {\n             rtabort!(\"leaked managed memory ({} objects)\", self.live_allocations);\n         }\n-        rtassert!(self.allocations.iter().all(|s| s.is_null()));\n+        rtassert!(self.allocations.as_slice().iter().all(|s| s.is_null()));\n     }\n }\n "}, {"sha": "0719523af775fd3058b1c5a82c3b9bcf8dbd4220", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -17,6 +17,7 @@ use any::AnyOwnExt;\n use cast;\n use cleanup;\n use clone::Clone;\n+use comm::Chan;\n use io::Writer;\n use iter::{Iterator, Take};\n use local_data;\n@@ -67,11 +68,17 @@ pub enum BlockedTask {\n     Shared(UnsafeArc<AtomicUint>),\n }\n \n+pub enum DeathAction {\n+    /// Action to be done with the exit code. If set, also makes the task wait\n+    /// until all its watched children exit before collecting the status.\n+    Execute(proc(TaskResult)),\n+    /// A channel to send the result of the task on when the task exits\n+    SendMessage(Chan<TaskResult>),\n+}\n+\n /// Per-task state related to task death, killing, failure, etc.\n pub struct Death {\n-    // Action to be done with the exit code. If set, also makes the task wait\n-    // until all its watched children exit before collecting the status.\n-    on_exit: Option<proc(TaskResult)>,\n+    on_exit: Option<DeathAction>,\n }\n \n pub struct BlockedTasks {\n@@ -381,7 +388,8 @@ impl Death {\n     /// Collect failure exit codes from children and propagate them to a parent.\n     pub fn collect_failure(&mut self, result: TaskResult) {\n         match self.on_exit.take() {\n-            Some(f) => f(result),\n+            Some(Execute(f)) => f(result),\n+            Some(SendMessage(ch)) => { ch.try_send(result); }\n             None => {}\n         }\n     }"}, {"sha": "c25422d24e91164fe9ab24a9944c3d208f67c0de", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -41,6 +41,12 @@ pub struct Closure {\n     env: *(),\n }\n \n+/// The representation of a Rust procedure (`proc()`)\n+pub struct Procedure {\n+    code: *(),\n+    env: *(),\n+}\n+\n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n pub trait Repr<T> {"}, {"sha": "fb6db57414a564ac7894835a6100674dd7617e78", "filename": "src/rt/arch/arm/_context.S", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Frt%2Farch%2Farm%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Frt%2Farch%2Farm%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2F_context.S?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -51,3 +51,11 @@ rust_swap_registers:\n \tmsr cpsr_cxsf, r2\n \n \tmov pc, lr\n+\n+// For reasons of this existence, see the comments in x86_64/_context.S\n+.globl rust_bootstrap_green_task\n+rust_bootstrap_green_task:\n+        mov r0, r0\n+        mov r1, r3\n+        mov r2, r4\n+        mov pc, r5"}, {"sha": "36caf7720c40c5ece1a138bd524c86884fb0364b", "filename": "src/rt/arch/x86_64/_context.S", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Frt%2Farch%2Fx86_64%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/22c34f3c4cddea33b916eb92f8d7286b02b865a7/src%2Frt%2Farch%2Fx86_64%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2F_context.S?ref=22c34f3c4cddea33b916eb92f8d7286b02b865a7", "patch": "@@ -157,3 +157,36 @@ SWAP_REGISTERS:\n         // Jump to the instruction pointer\n         // found in regs:\n         jmp *(RUSTRT_IP*8)(ARG1)\n+\n+// This function below, rust_bootstrap_green_task, is used to initialize a green\n+// task. This code is the very first code that is run whenever a green task\n+// starts. The only assumptions that this code makes is that it has a register\n+// context previously set up by Context::new() and some values are in some\n+// special registers.\n+//\n+// In theory the register context could be set up and then the context switching\n+// would plop us directly into some 'extern \"C\" fn', but not all platforms have\n+// the argument registers saved throughout a context switch (linux doesn't save\n+// rdi/rsi, the first two argument registers). Instead of modifying all context\n+// switches, instead the initial data for starting a green thread is shoved into\n+// unrelated registers (r12/13, etc) which always need to be saved on context\n+// switches anyway.\n+//\n+// With this strategy we get the benefit of being able to pass a fair bit of\n+// contextual data from the start of a green task to its init function, as well\n+// as not hindering any context switches.\n+//\n+// If you alter this code in any way, you likely need to update\n+// src/libgreen/context.rs as well.\n+\n+#if defined(__APPLE__)\n+#define BOOTSTRAP _rust_bootstrap_green_task\n+#else\n+#define BOOTSTRAP rust_bootstrap_green_task\n+#endif\n+.globl BOOTSTRAP\n+BOOTSTRAP:\n+    mov %r12, RUSTRT_ARG0_S\n+    mov %r13, RUSTRT_ARG1_S\n+    mov %r14, RUSTRT_ARG2_S\n+    jmpq *%r15"}]}