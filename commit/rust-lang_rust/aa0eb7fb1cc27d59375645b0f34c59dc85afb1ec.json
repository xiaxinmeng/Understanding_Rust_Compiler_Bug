{"sha": "aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "node_id": "C_kwDOAAsO6NoAKGFhMGViN2ZiMWNjMjdkNTkzNzU2NDViMGYzNGM1OWRjODVhZmIxZWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-19T13:58:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-19T13:58:09Z"}, "message": "Auto merge of #10206 - Niki4tap:one_unsafe_op_per_block, r=Alexendoo\n\nAdd `multiple_unsafe_ops_per_block` lint\n\nAdds a lint, which restricts an `unsafe` block to only one unsafe operation.\n\nCloses #10064\n\n---\n\nchangelog: New lint: [`multiple_unsafe_ops_per_block`]\n[#10206](https://github.com/rust-lang/rust-clippy/pull/10206)\n<!-- changelog_checked -->", "tree": {"sha": "1367f7042f146cc29593e52e39655347ccf65cc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1367f7042f146cc29593e52e39655347ccf65cc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "html_url": "https://github.com/rust-lang/rust/commit/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36e3e26464c1db3be35bd8ff8872d96a97eb8c5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/36e3e26464c1db3be35bd8ff8872d96a97eb8c5e", "html_url": "https://github.com/rust-lang/rust/commit/36e3e26464c1db3be35bd8ff8872d96a97eb8c5e"}, {"sha": "875e36f7e459776d3e51b7c089ab89b0821b6122", "url": "https://api.github.com/repos/rust-lang/rust/commits/875e36f7e459776d3e51b7c089ab89b0821b6122", "html_url": "https://github.com/rust-lang/rust/commit/875e36f7e459776d3e51b7c089ab89b0821b6122"}], "stats": {"total": 428, "additions": 428, "deletions": 0}, "files": [{"sha": "84f4654f34e47077c092efcf98644013ad18f974", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "patch": "@@ -4383,6 +4383,7 @@ Released 2018-09-13\n [`multi_assignments`]: https://rust-lang.github.io/rust-clippy/master/index.html#multi_assignments\n [`multiple_crate_versions`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_crate_versions\n [`multiple_inherent_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_inherent_impl\n+[`multiple_unsafe_ops_per_block`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_unsafe_ops_per_block\n [`must_use_candidate`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_candidate\n [`must_use_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_unit\n [`mut_from_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_from_ref"}, {"sha": "36a366fc97474b98ff457a6493e2fa9ecd8ef343", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "patch": "@@ -422,6 +422,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::module_style::MOD_MODULE_FILES_INFO,\n     crate::module_style::SELF_NAMED_MODULE_FILES_INFO,\n     crate::multi_assignments::MULTI_ASSIGNMENTS_INFO,\n+    crate::multiple_unsafe_ops_per_block::MULTIPLE_UNSAFE_OPS_PER_BLOCK_INFO,\n     crate::mut_key::MUTABLE_KEY_TYPE_INFO,\n     crate::mut_mut::MUT_MUT_INFO,\n     crate::mut_reference::UNNECESSARY_MUT_PASSED_INFO,"}, {"sha": "5c4b604104417e86b99c28a6d6a1f6a172c33a0f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "patch": "@@ -198,6 +198,7 @@ mod missing_trait_methods;\n mod mixed_read_write_in_expression;\n mod module_style;\n mod multi_assignments;\n+mod multiple_unsafe_ops_per_block;\n mod mut_key;\n mod mut_mut;\n mod mut_reference;\n@@ -908,6 +909,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(fn_null_check::FnNullCheck));\n     store.register_late_pass(|_| Box::new(permissions_set_readonly_false::PermissionsSetReadonlyFalse));\n     store.register_late_pass(|_| Box::new(size_of_ref::SizeOfRef));\n+    store.register_late_pass(|_| Box::new(multiple_unsafe_ops_per_block::MultipleUnsafeOpsPerBlock));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "18e61c75eece31b2a421cc939482f0b3019465d0", "filename": "clippy_lints/src/multiple_unsafe_ops_per_block.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/clippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/clippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs?ref=aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "patch": "@@ -0,0 +1,185 @@\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then,\n+    visitors::{for_each_expr_with_closures, Descend, Visitable},\n+};\n+use core::ops::ControlFlow::Continue;\n+use hir::{\n+    def::{DefKind, Res},\n+    BlockCheckMode, ExprKind, QPath, UnOp, Unsafety,\n+};\n+use rustc_ast::Mutability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `unsafe` blocks that contain more than one unsafe operation.\n+    ///\n+    /// ### Why is this bad?\n+    /// Combined with `undocumented_unsafe_blocks`,\n+    /// this lint ensures that each unsafe operation must be independently justified.\n+    /// Combined with `unused_unsafe`, this lint also ensures\n+    /// elimination of unnecessary unsafe blocks through refactoring.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// /// Reads a `char` from the given pointer.\n+    /// ///\n+    /// /// # Safety\n+    /// ///\n+    /// /// `ptr` must point to four consecutive, initialized bytes which\n+    /// /// form a valid `char` when interpreted in the native byte order.\n+    /// fn read_char(ptr: *const u8) -> char {\n+    ///     // SAFETY: The caller has guaranteed that the value pointed\n+    ///     // to by `bytes` is a valid `char`.\n+    ///     unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// /// Reads a `char` from the given pointer.\n+    /// ///\n+    /// /// # Safety\n+    /// ///\n+    /// /// - `ptr` must be 4-byte aligned, point to four consecutive\n+    /// ///   initialized bytes, and be valid for reads of 4 bytes.\n+    /// /// - The bytes pointed to by `ptr` must represent a valid\n+    /// ///   `char` when interpreted in the native byte order.\n+    /// fn read_char(ptr: *const u8) -> char {\n+    ///     // SAFETY: `ptr` is 4-byte aligned, points to four consecutive\n+    ///     // initialized bytes, and is valid for reads of 4 bytes.\n+    ///     let int_value = unsafe { *ptr.cast::<u32>() };\n+    ///\n+    ///     // SAFETY: The caller has guaranteed that the four bytes\n+    ///     // pointed to by `bytes` represent a valid `char`.\n+    ///     unsafe { char::from_u32_unchecked(int_value) }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.68.0\"]\n+    pub MULTIPLE_UNSAFE_OPS_PER_BLOCK,\n+    restriction,\n+    \"more than one unsafe operation per `unsafe` block\"\n+}\n+declare_lint_pass!(MultipleUnsafeOpsPerBlock => [MULTIPLE_UNSAFE_OPS_PER_BLOCK]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MultipleUnsafeOpsPerBlock {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n+        if !matches!(block.rules, BlockCheckMode::UnsafeBlock(_)) {\n+            return;\n+        }\n+        let mut unsafe_ops = vec![];\n+        collect_unsafe_exprs(cx, block, &mut unsafe_ops);\n+        if unsafe_ops.len() > 1 {\n+            span_lint_and_then(\n+                cx,\n+                MULTIPLE_UNSAFE_OPS_PER_BLOCK,\n+                block.span,\n+                &format!(\n+                    \"this `unsafe` block contains {} unsafe operations, expected only one\",\n+                    unsafe_ops.len()\n+                ),\n+                |diag| {\n+                    for (msg, span) in unsafe_ops {\n+                        diag.span_note(span, msg);\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn collect_unsafe_exprs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    node: impl Visitable<'tcx>,\n+    unsafe_ops: &mut Vec<(&'static str, Span)>,\n+) {\n+    for_each_expr_with_closures(cx, node, |expr| {\n+        match expr.kind {\n+            ExprKind::InlineAsm(_) => unsafe_ops.push((\"inline assembly used here\", expr.span)),\n+\n+            ExprKind::Field(e, _) => {\n+                if cx.typeck_results().expr_ty(e).is_union() {\n+                    unsafe_ops.push((\"union field access occurs here\", expr.span));\n+                }\n+            },\n+\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                hir::Path {\n+                    res: Res::Def(DefKind::Static(Mutability::Mut), _),\n+                    ..\n+                },\n+            )) => {\n+                unsafe_ops.push((\"access of a mutable static occurs here\", expr.span));\n+            },\n+\n+            ExprKind::Unary(UnOp::Deref, e) if cx.typeck_results().expr_ty_adjusted(e).is_unsafe_ptr() => {\n+                unsafe_ops.push((\"raw pointer dereference occurs here\", expr.span));\n+            },\n+\n+            ExprKind::Call(path_expr, _) => match path_expr.kind {\n+                ExprKind::Path(QPath::Resolved(\n+                    _,\n+                    hir::Path {\n+                        res: Res::Def(kind, def_id),\n+                        ..\n+                    },\n+                )) if kind.is_fn_like() => {\n+                    let sig = cx.tcx.bound_fn_sig(*def_id);\n+                    if sig.0.unsafety() == Unsafety::Unsafe {\n+                        unsafe_ops.push((\"unsafe function call occurs here\", expr.span));\n+                    }\n+                },\n+\n+                ExprKind::Path(QPath::TypeRelative(..)) => {\n+                    if let Some(sig) = cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(path_expr.hir_id)\n+                        .map(|def_id| cx.tcx.bound_fn_sig(def_id))\n+                    {\n+                        if sig.0.unsafety() == Unsafety::Unsafe {\n+                            unsafe_ops.push((\"unsafe function call occurs here\", expr.span));\n+                        }\n+                    }\n+                },\n+\n+                _ => {},\n+            },\n+\n+            ExprKind::MethodCall(..) => {\n+                if let Some(sig) = cx\n+                    .typeck_results()\n+                    .type_dependent_def_id(expr.hir_id)\n+                    .map(|def_id| cx.tcx.bound_fn_sig(def_id))\n+                {\n+                    if sig.0.unsafety() == Unsafety::Unsafe {\n+                        unsafe_ops.push((\"unsafe method call occurs here\", expr.span));\n+                    }\n+                }\n+            },\n+\n+            ExprKind::AssignOp(_, lhs, rhs) | ExprKind::Assign(lhs, rhs, _) => {\n+                if matches!(\n+                    lhs.kind,\n+                    ExprKind::Path(QPath::Resolved(\n+                        _,\n+                        hir::Path {\n+                            res: Res::Def(DefKind::Static(Mutability::Mut), _),\n+                            ..\n+                        }\n+                    ))\n+                ) {\n+                    unsafe_ops.push((\"modification of a mutable static occurs here\", expr.span));\n+                    collect_unsafe_exprs(cx, rhs, unsafe_ops);\n+                    return Continue(Descend::No);\n+                }\n+            },\n+\n+            _ => {},\n+        };\n+\n+        Continue::<(), _>(Descend::Yes)\n+    });\n+}"}, {"sha": "41263535df6736f6775cd037e9ca358a31e6d31b", "filename": "tests/ui/multiple_unsafe_ops_per_block.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/tests%2Fui%2Fmultiple_unsafe_ops_per_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/tests%2Fui%2Fmultiple_unsafe_ops_per_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmultiple_unsafe_ops_per_block.rs?ref=aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "patch": "@@ -0,0 +1,110 @@\n+#![allow(unused)]\n+#![allow(deref_nullptr)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::drop_copy)]\n+#![warn(clippy::multiple_unsafe_ops_per_block)]\n+\n+use core::arch::asm;\n+\n+fn raw_ptr() -> *const () {\n+    core::ptr::null()\n+}\n+\n+unsafe fn not_very_safe() {}\n+\n+struct Sample;\n+\n+impl Sample {\n+    unsafe fn not_very_safe(&self) {}\n+}\n+\n+#[allow(non_upper_case_globals)]\n+const sample: Sample = Sample;\n+\n+union U {\n+    i: i32,\n+    u: u32,\n+}\n+\n+static mut STATIC: i32 = 0;\n+\n+fn test1() {\n+    unsafe {\n+        STATIC += 1;\n+        not_very_safe();\n+    }\n+}\n+\n+fn test2() {\n+    let u = U { i: 0 };\n+\n+    unsafe {\n+        drop(u.u);\n+        *raw_ptr();\n+    }\n+}\n+\n+fn test3() {\n+    unsafe {\n+        asm!(\"nop\");\n+        sample.not_very_safe();\n+        STATIC = 0;\n+    }\n+}\n+\n+fn test_all() {\n+    let u = U { i: 0 };\n+    unsafe {\n+        drop(u.u);\n+        drop(STATIC);\n+        sample.not_very_safe();\n+        not_very_safe();\n+        *raw_ptr();\n+        asm!(\"nop\");\n+    }\n+}\n+\n+// no lint\n+fn correct1() {\n+    unsafe {\n+        STATIC += 1;\n+    }\n+}\n+\n+// no lint\n+fn correct2() {\n+    unsafe {\n+        STATIC += 1;\n+    }\n+\n+    unsafe {\n+        *raw_ptr();\n+    }\n+}\n+\n+// no lint\n+fn correct3() {\n+    let u = U { u: 0 };\n+\n+    unsafe {\n+        not_very_safe();\n+    }\n+\n+    unsafe {\n+        drop(u.i);\n+    }\n+}\n+\n+// tests from the issue (https://github.com/rust-lang/rust-clippy/issues/10064)\n+\n+unsafe fn read_char_bad(ptr: *const u8) -> char {\n+    unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n+}\n+\n+// no lint\n+unsafe fn read_char_good(ptr: *const u8) -> char {\n+    let int_value = unsafe { *ptr.cast::<u32>() };\n+    unsafe { core::char::from_u32_unchecked(int_value) }\n+}\n+\n+fn main() {}"}, {"sha": "f6b8341795d235db0b6f8b48da351f2d632954b7", "filename": "tests/ui/multiple_unsafe_ops_per_block.stderr", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/tests%2Fui%2Fmultiple_unsafe_ops_per_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec/tests%2Fui%2Fmultiple_unsafe_ops_per_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmultiple_unsafe_ops_per_block.stderr?ref=aa0eb7fb1cc27d59375645b0f34c59dc85afb1ec", "patch": "@@ -0,0 +1,129 @@\n+error: this `unsafe` block contains 2 unsafe operations, expected only one\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:32:5\n+   |\n+LL | /     unsafe {\n+LL | |         STATIC += 1;\n+LL | |         not_very_safe();\n+LL | |     }\n+   | |_____^\n+   |\n+note: modification of a mutable static occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:33:9\n+   |\n+LL |         STATIC += 1;\n+   |         ^^^^^^^^^^^\n+note: unsafe function call occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:34:9\n+   |\n+LL |         not_very_safe();\n+   |         ^^^^^^^^^^^^^^^\n+   = note: `-D clippy::multiple-unsafe-ops-per-block` implied by `-D warnings`\n+\n+error: this `unsafe` block contains 2 unsafe operations, expected only one\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:41:5\n+   |\n+LL | /     unsafe {\n+LL | |         drop(u.u);\n+LL | |         *raw_ptr();\n+LL | |     }\n+   | |_____^\n+   |\n+note: union field access occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:42:14\n+   |\n+LL |         drop(u.u);\n+   |              ^^^\n+note: raw pointer dereference occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:43:9\n+   |\n+LL |         *raw_ptr();\n+   |         ^^^^^^^^^^\n+\n+error: this `unsafe` block contains 3 unsafe operations, expected only one\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:48:5\n+   |\n+LL | /     unsafe {\n+LL | |         asm!(\"nop\");\n+LL | |         sample.not_very_safe();\n+LL | |         STATIC = 0;\n+LL | |     }\n+   | |_____^\n+   |\n+note: inline assembly used here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:49:9\n+   |\n+LL |         asm!(\"nop\");\n+   |         ^^^^^^^^^^^\n+note: unsafe method call occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:50:9\n+   |\n+LL |         sample.not_very_safe();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+note: modification of a mutable static occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:51:9\n+   |\n+LL |         STATIC = 0;\n+   |         ^^^^^^^^^^\n+\n+error: this `unsafe` block contains 6 unsafe operations, expected only one\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:57:5\n+   |\n+LL | /     unsafe {\n+LL | |         drop(u.u);\n+LL | |         drop(STATIC);\n+LL | |         sample.not_very_safe();\n+...  |\n+LL | |         asm!(\"nop\");\n+LL | |     }\n+   | |_____^\n+   |\n+note: union field access occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:58:14\n+   |\n+LL |         drop(u.u);\n+   |              ^^^\n+note: access of a mutable static occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:59:14\n+   |\n+LL |         drop(STATIC);\n+   |              ^^^^^^\n+note: unsafe method call occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:60:9\n+   |\n+LL |         sample.not_very_safe();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+note: unsafe function call occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:61:9\n+   |\n+LL |         not_very_safe();\n+   |         ^^^^^^^^^^^^^^^\n+note: raw pointer dereference occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:62:9\n+   |\n+LL |         *raw_ptr();\n+   |         ^^^^^^^^^^\n+note: inline assembly used here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:63:9\n+   |\n+LL |         asm!(\"nop\");\n+   |         ^^^^^^^^^^^\n+\n+error: this `unsafe` block contains 2 unsafe operations, expected only one\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:101:5\n+   |\n+LL |     unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: unsafe function call occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:101:14\n+   |\n+LL |     unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: raw pointer dereference occurs here\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:101:39\n+   |\n+LL |     unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n+   |                                       ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}]}