{"sha": "8f81593d6c9b731973c0f8e57548948101dda928", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmODE1OTNkNmM5YjczMTk3M2MwZjhlNTc1NDg5NDgxMDFkZGE5Mjg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-01-22T00:52:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-08T04:50:59Z"}, "message": "rustc_target: switch homogeneous_aggregate to returning Result.", "tree": {"sha": "109ca837470dbe102901d29e5b54fe7105170ca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/109ca837470dbe102901d29e5b54fe7105170ca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f81593d6c9b731973c0f8e57548948101dda928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f81593d6c9b731973c0f8e57548948101dda928", "html_url": "https://github.com/rust-lang/rust/commit/8f81593d6c9b731973c0f8e57548948101dda928", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f81593d6c9b731973c0f8e57548948101dda928/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d28952631b37f422a6c0bd9660c20b0b40f5bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d28952631b37f422a6c0bd9660c20b0b40f5bf9", "html_url": "https://github.com/rust-lang/rust/commit/1d28952631b37f422a6c0bd9660c20b0b40f5bf9"}], "stats": {"total": 197, "additions": 108, "deletions": 89}, "files": [{"sha": "c8bac5aebc6340a667ac7ff36d3eccef0147d635", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -6,7 +6,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "59ec87e3c9e095c0aeafed053ad24c1049a50a0c", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -7,7 +7,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "748fd2b6579ff1f1bcb9072d7809f07e9b006222", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 80, "deletions": 61, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -219,26 +219,47 @@ impl CastTarget {\n     }\n }\n \n-/// Returns value from the `homogeneous_aggregate` test function.\n+/// Return value from the `homogeneous_aggregate` test function.\n #[derive(Copy, Clone, Debug)]\n pub enum HomogeneousAggregate {\n     /// Yes, all the \"leaf fields\" of this struct are passed in the\n     /// same way (specified in the `Reg` value).\n     Homogeneous(Reg),\n \n-    /// There are distinct leaf fields passed in different ways,\n-    /// or this is uninhabited.\n-    Heterogeneous,\n-\n     /// There are no leaf fields at all.\n     NoData,\n }\n \n+/// Error from the `homogeneous_aggregate` test function, indicating\n+/// there are distinct leaf fields passed in different ways,\n+/// or this is uninhabited.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Heterogeneous;\n+\n impl HomogeneousAggregate {\n     /// If this is a homogeneous aggregate, returns the homogeneous\n     /// unit, else `None`.\n     pub fn unit(self) -> Option<Reg> {\n-        if let HomogeneousAggregate::Homogeneous(r) = self { Some(r) } else { None }\n+        match self {\n+            HomogeneousAggregate::Homogeneous(reg) => Some(reg),\n+            HomogeneousAggregate::NoData => None,\n+        }\n+    }\n+\n+    /// Try to combine two `HomogeneousAggregate`s, e.g. from two fields in\n+    /// the same `struct`. Only succeeds if only one of them has any data,\n+    /// or both units are identical.\n+    fn merge(self, other: HomogeneousAggregate) -> Result<HomogeneousAggregate, Heterogeneous> {\n+        match (self, other) {\n+            (x, HomogeneousAggregate::NoData) | (HomogeneousAggregate::NoData, x) => Ok(x),\n+\n+            (HomogeneousAggregate::Homogeneous(a), HomogeneousAggregate::Homogeneous(b)) => {\n+                if a != b {\n+                    return Err(Heterogeneous);\n+                }\n+                Ok(self)\n+            }\n+        }\n     }\n }\n \n@@ -250,8 +271,8 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n         }\n     }\n \n-    /// Returns `true` if this layout is an aggregate containing fields of only\n-    /// a single type (e.g., `(u32, u32)`). Such aggregates are often\n+    /// Returns `Homogeneous` if this layout is an aggregate containing fields of\n+    /// only a single type (e.g., `(u32, u32)`). Such aggregates are often\n     /// special-cased in ABIs.\n     ///\n     /// Note: We generally ignore fields of zero-sized type when computing\n@@ -260,94 +281,92 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     /// This is public so that it can be used in unit tests, but\n     /// should generally only be relevant to the ABI details of\n     /// specific targets.\n-    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> HomogeneousAggregate\n+    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> Result<HomogeneousAggregate, Heterogeneous>\n     where\n         Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = Self>,\n     {\n         match self.abi {\n-            Abi::Uninhabited => HomogeneousAggregate::Heterogeneous,\n+            Abi::Uninhabited => Err(Heterogeneous),\n \n             // The primitive for this algorithm.\n             Abi::Scalar(ref scalar) => {\n                 let kind = match scalar.value {\n                     abi::Int(..) | abi::Pointer => RegKind::Integer,\n                     abi::F32 | abi::F64 => RegKind::Float,\n                 };\n-                HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size })\n+                Ok(HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size }))\n             }\n \n             Abi::Vector { .. } => {\n                 assert!(!self.is_zst());\n-                HomogeneousAggregate::Homogeneous(Reg { kind: RegKind::Vector, size: self.size })\n+                Ok(HomogeneousAggregate::Homogeneous(Reg {\n+                    kind: RegKind::Vector,\n+                    size: self.size,\n+                }))\n             }\n \n             Abi::ScalarPair(..) | Abi::Aggregate { .. } => {\n-                let mut total = Size::ZERO;\n-                let mut result = None;\n-\n-                let is_union = match self.fields {\n-                    FieldPlacement::Array { count, .. } => {\n-                        if count > 0 {\n-                            return self.field(cx, 0).homogeneous_aggregate(cx);\n-                        } else {\n-                            return HomogeneousAggregate::NoData;\n-                        }\n-                    }\n-                    FieldPlacement::Union(_) => true,\n-                    FieldPlacement::Arbitrary { .. } => false,\n-                };\n+                // Helper for computing `homogenous_aggregate`, allowing a custom\n+                // starting offset (TODO(eddyb): use this to handle variants).\n+                let from_fields_at =\n+                    |layout: Self,\n+                     start: Size|\n+                     -> Result<(HomogeneousAggregate, Size), Heterogeneous> {\n+                        let is_union = match layout.fields {\n+                            FieldPlacement::Array { count, .. } => {\n+                                assert_eq!(start, Size::ZERO);\n+\n+                                let result = if count > 0 {\n+                                    layout.field(cx, 0).homogeneous_aggregate(cx)?\n+                                } else {\n+                                    HomogeneousAggregate::NoData\n+                                };\n+                                return Ok((result, layout.size));\n+                            }\n+                            FieldPlacement::Union(_) => true,\n+                            FieldPlacement::Arbitrary { .. } => false,\n+                        };\n \n-                for i in 0..self.fields.count() {\n-                    if !is_union && total != self.fields.offset(i) {\n-                        return HomogeneousAggregate::Heterogeneous;\n-                    }\n+                        let mut result = HomogeneousAggregate::NoData;\n+                        let mut total = start;\n \n-                    let field = self.field(cx, i);\n+                        for i in 0..layout.fields.count() {\n+                            if !is_union && total != layout.fields.offset(i) {\n+                                return Err(Heterogeneous);\n+                            }\n \n-                    match (result, field.homogeneous_aggregate(cx)) {\n-                        (_, HomogeneousAggregate::NoData) => {\n-                            // Ignore fields that have no data\n-                        }\n-                        (_, HomogeneousAggregate::Heterogeneous) => {\n-                            // The field itself must be a homogeneous aggregate.\n-                            return HomogeneousAggregate::Heterogeneous;\n-                        }\n-                        // If this is the first field, record the unit.\n-                        (None, HomogeneousAggregate::Homogeneous(unit)) => {\n-                            result = Some(unit);\n-                        }\n-                        // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), HomogeneousAggregate::Homogeneous(unit)) => {\n-                            if prev_unit != unit {\n-                                return HomogeneousAggregate::Heterogeneous;\n+                            let field = layout.field(cx, i);\n+\n+                            result = result.merge(field.homogeneous_aggregate(cx)?)?;\n+\n+                            // Keep track of the offset (without padding).\n+                            let size = field.size;\n+                            if is_union {\n+                                total = total.max(size);\n+                            } else {\n+                                total += size;\n                             }\n                         }\n-                    }\n \n-                    // Keep track of the offset (without padding).\n-                    let size = field.size;\n-                    if is_union {\n-                        total = total.max(size);\n-                    } else {\n-                        total += size;\n-                    }\n-                }\n+                        Ok((result, total))\n+                    };\n+\n+                let (mut result, mut total) = from_fields_at(*self, Size::ZERO)?;\n \n                 // There needs to be no padding.\n                 if total != self.size {\n-                    HomogeneousAggregate::Heterogeneous\n+                    Err(Heterogeneous)\n                 } else {\n                     match result {\n-                        Some(reg) => {\n+                        HomogeneousAggregate::Homogeneous(_) => {\n                             assert_ne!(total, Size::ZERO);\n-                            HomogeneousAggregate::Homogeneous(reg)\n                         }\n-                        None => {\n+                        HomogeneousAggregate::NoData => {\n                             assert_eq!(total, Size::ZERO);\n-                            HomogeneousAggregate::NoData\n                         }\n                     }\n+                    Ok(result)\n                 }\n             }\n         }"}, {"sha": "93c4e97de10b94308b49b89c149f27f6a86d7fa2", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -22,7 +22,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n         if (abi == ELFv1 && arg.layout.size > unit.size)"}, {"sha": "c80f8316feb72cde3352dc6d5ef522bc9008a80a", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -8,7 +8,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n         if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;"}, {"sha": "9aab64ef272b2ccd0c2f6ca808a35e228e6f6517", "filename": "src/librustc_target/abi/call/wasm32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -7,7 +7,7 @@ where\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n     if val.layout.is_aggregate() {\n-        if let Some(unit) = val.layout.homogeneous_aggregate(cx).unit() {\n+        if let Some(unit) = val.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()) {\n             let size = val.layout.size;\n             if unit.size == size {\n                 val.cast_to(Uniform { unit, total: size });"}, {"sha": "e776a8b3fe4a96d0f215100d6e210e2956ae80cc", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -100,7 +100,7 @@ where\n             };\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogeneous_aggregate(cx).unit().unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(cx).unwrap().unit().unwrap();\n             assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;"}, {"sha": "7eecd99dc016ae4a256cf5398f18fae718d1e009", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -20,7 +20,7 @@ pub struct Middle {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type TestMiddle = Middle;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n pub struct Final {\n@@ -31,6 +31,6 @@ pub struct Final {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type TestFinal = Final;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n fn main() { }"}, {"sha": "cd3fb5ca5ea402124e930cf29bd16f8042f6d053", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -1,10 +1,10 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:22:1\n    |\n LL | pub type TestMiddle = Middle;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:33:1\n    |\n LL | pub type TestFinal = Final;"}, {"sha": "ec2c9b70224b5d4a8a31c375532da38284c668ed", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -52,22 +52,22 @@ pub struct WithEmptyRustEnum {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test1 = BaseCase;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test2 = WithPhantomData;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test3 = WithEmptyRustStruct;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test4 = WithTransitivelyEmptyRustStruct;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test5 = WithEmptyRustEnum;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n fn main() { }"}, {"sha": "ec2b08bf02d655a435129bb43427820d76d489de", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -1,28 +1,28 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:54:1\n    |\n LL | pub type Test1 = BaseCase;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:58:1\n    |\n LL | pub type Test2 = WithPhantomData;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:62:1\n    |\n LL | pub type Test3 = WithEmptyRustStruct;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:66:1\n    |\n LL | pub type Test4 = WithTransitivelyEmptyRustStruct;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:70:1\n    |\n LL | pub type Test5 = WithEmptyRustEnum;"}, {"sha": "1a662ba44677d647f0a3d7d634451650bd1fe624", "filename": "src/test/ui/layout/zero-sized-array-union.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -57,7 +57,7 @@ struct Baz1 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz1 = Baz1;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz2 {\n@@ -68,7 +68,7 @@ struct Baz2 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz2 = Baz2;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz3 {\n@@ -79,7 +79,7 @@ struct Baz3 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz3 = Baz3;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz4 {\n@@ -90,6 +90,6 @@ struct Baz4 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz4 = Baz4;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n fn main() { }"}, {"sha": "43b1588266bb7cdd2f0c68a59af02c880672824b", "filename": "src/test/ui/layout/zero-sized-array-union.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f81593d6c9b731973c0f8e57548948101dda928/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr?ref=8f81593d6c9b731973c0f8e57548948101dda928", "patch": "@@ -1,22 +1,22 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:59:1\n    |\n LL | type TestBaz1 = Baz1;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:70:1\n    |\n LL | type TestBaz2 = Baz2;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:81:1\n    |\n LL | type TestBaz3 = Baz3;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:92:1\n    |\n LL | type TestBaz4 = Baz4;"}]}