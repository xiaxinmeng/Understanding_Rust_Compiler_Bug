{"sha": "b97cc955c2b2d9494607434352e0898ee0eca0b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5N2NjOTU1YzJiMmQ5NDk0NjA3NDM0MzUyZTA4OThlZTBlY2EwYjg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-13T02:15:54Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:06:17Z"}, "message": "Ported effect checker from oldvisit to <V:Visitor> trait API.", "tree": {"sha": "1761110c7f5ab129d317135dbec39771316d1e28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1761110c7f5ab129d317135dbec39771316d1e28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b97cc955c2b2d9494607434352e0898ee0eca0b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b97cc955c2b2d9494607434352e0898ee0eca0b8", "html_url": "https://github.com/rust-lang/rust/commit/b97cc955c2b2d9494607434352e0898ee0eca0b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b97cc955c2b2d9494607434352e0898ee0eca0b8/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "635d91737aa4aacc79a74d0743d20d3e8390751c", "url": "https://api.github.com/repos/rust-lang/rust/commits/635d91737aa4aacc79a74d0743d20d3e8390751c", "html_url": "https://github.com/rust-lang/rust/commit/635d91737aa4aacc79a74d0743d20d3e8390751c"}], "stats": {"total": 115, "additions": 65, "deletions": 50}, "files": [{"sha": "de0be2a0bc510e2d513cb3cef1ce76627d1d7e19", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b97cc955c2b2d9494607434352e0898ee0eca0b8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97cc955c2b2d9494607434352e0898ee0eca0b8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=b97cc955c2b2d9494607434352e0898ee0eca0b8", "patch": "@@ -20,8 +20,10 @@ use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n use syntax::ast::{expr_unary, unsafe_fn, expr_path};\n use syntax::ast;\n use syntax::codemap::span;\n-use syntax::oldvisit::{fk_item_fn, fk_method};\n-use syntax::oldvisit;\n+use syntax::visit::{fk_item_fn, fk_method};\n+use syntax::visit;\n+use syntax::visit::{Visitor,fn_kind};\n+use syntax::ast::{fn_decl,Block,NodeId,expr};\n \n #[deriving(Eq)]\n enum UnsafeContext {\n@@ -45,120 +47,133 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n-                   method_map: method_map,\n-                   crate: &ast::Crate) {\n-    let context = @mut Context {\n-        method_map: method_map,\n-        unsafe_context: SafeContext,\n-    };\n+struct EffectCheckVisitor {\n+    tcx: ty::ctxt,\n+    context: @mut Context,\n+}\n \n-    let require_unsafe: @fn(span: span,\n-                            description: &str) = |span, description| {\n-        match context.unsafe_context {\n+impl EffectCheckVisitor {\n+    fn require_unsafe(&mut self, span: span, description: &str) {\n+        match self.context.unsafe_context {\n             SafeContext => {\n                 // Report an error.\n-                tcx.sess.span_err(span,\n+                self.tcx.sess.span_err(span,\n                                   fmt!(\"%s requires unsafe function or block\",\n                                        description))\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n                 debug!(\"effect: recording unsafe block as used: %?\", block_id);\n-                let _ = tcx.used_unsafe.insert(block_id);\n+                let _ = self.tcx.used_unsafe.insert(block_id);\n             }\n             UnsafeFn => {}\n         }\n-    };\n+    }\n+}\n+\n+impl Visitor<()> for EffectCheckVisitor {\n+    fn visit_fn(&mut self, fn_kind:&fn_kind, fn_decl:&fn_decl,\n+                block:&Block, span:span, node_id:NodeId, _:()) {\n \n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: |fn_kind, fn_decl, block, span, node_id, (_, visitor)| {\n             let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n                 fk_item_fn(_, _, purity, _) => (true, purity == unsafe_fn),\n                 fk_method(_, _, method) => (true, method.purity == unsafe_fn),\n                 _ => (false, false),\n             };\n \n-            let old_unsafe_context = context.unsafe_context;\n+            let old_unsafe_context = self.context.unsafe_context;\n             if is_unsafe_fn {\n-                context.unsafe_context = UnsafeFn\n+                self.context.unsafe_context = UnsafeFn\n             } else if is_item_fn {\n-                context.unsafe_context = SafeContext\n+                self.context.unsafe_context = SafeContext\n             }\n \n-            oldvisit::visit_fn(fn_kind,\n+            visit::walk_fn(self,\n+                           fn_kind,\n                             fn_decl,\n                             block,\n                             span,\n                             node_id,\n-                            ((),\n-                             visitor));\n+                            ());\n+\n+            self.context.unsafe_context = old_unsafe_context\n+    }\n \n-            context.unsafe_context = old_unsafe_context\n-        },\n+    fn visit_block(&mut self, block:&Block, _:()) {\n \n-        visit_block: |block, (_, visitor)| {\n-            let old_unsafe_context = context.unsafe_context;\n+            let old_unsafe_context = self.context.unsafe_context;\n             if block.rules == ast::UnsafeBlock &&\n-                    context.unsafe_context == SafeContext {\n-                context.unsafe_context = UnsafeBlock(block.id)\n+                    self.context.unsafe_context == SafeContext {\n+                self.context.unsafe_context = UnsafeBlock(block.id)\n             }\n \n-            oldvisit::visit_block(block, ((), visitor));\n+            visit::walk_block(self, block, ());\n \n-            context.unsafe_context = old_unsafe_context\n-        },\n+            self.context.unsafe_context = old_unsafe_context\n+    }\n+\n+    fn visit_expr(&mut self, expr:@expr, _:()) {\n \n-        visit_expr: |expr, (_, visitor)| {\n             match expr.node {\n                 expr_method_call(callee_id, _, _, _, _, _) => {\n-                    let base_type = ty::node_id_to_type(tcx, callee_id);\n+                    let base_type = ty::node_id_to_type(self.tcx, callee_id);\n                     debug!(\"effect: method call case, base type is %s\",\n-                           ppaux::ty_to_str(tcx, base_type));\n+                           ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n-                        require_unsafe(expr.span,\n+                        self.require_unsafe(expr.span,\n                                        \"invocation of unsafe method\")\n                     }\n                 }\n                 expr_call(base, _, _) => {\n-                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    let base_type = ty::node_id_to_type(self.tcx, base.id);\n                     debug!(\"effect: call case, base type is %s\",\n-                           ppaux::ty_to_str(tcx, base_type));\n+                           ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n-                        require_unsafe(expr.span, \"call to unsafe function\")\n+                        self.require_unsafe(expr.span, \"call to unsafe function\")\n                     }\n                 }\n                 expr_unary(_, deref, base) => {\n-                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    let base_type = ty::node_id_to_type(self.tcx, base.id);\n                     debug!(\"effect: unary case, base type is %s\",\n-                           ppaux::ty_to_str(tcx, base_type));\n+                           ppaux::ty_to_str(self.tcx, base_type));\n                     match ty::get(base_type).sty {\n                         ty_ptr(_) => {\n-                            require_unsafe(expr.span,\n+                            self.require_unsafe(expr.span,\n                                            \"dereference of unsafe pointer\")\n                         }\n                         _ => {}\n                     }\n                 }\n                 expr_inline_asm(*) => {\n-                    require_unsafe(expr.span, \"use of inline assembly\")\n+                    self.require_unsafe(expr.span, \"use of inline assembly\")\n                 }\n                 expr_path(*) => {\n-                    match ty::resolve_expr(tcx, expr) {\n+                    match ty::resolve_expr(self.tcx, expr) {\n                         ast::def_static(_, true) => {\n-                            require_unsafe(expr.span, \"use of mutable static\")\n+                            self.require_unsafe(expr.span, \"use of mutable static\")\n                         }\n                         _ => {}\n                     }\n                 }\n                 _ => {}\n             }\n \n-            oldvisit::visit_expr(expr, ((), visitor))\n-        },\n+            visit::walk_expr(self, expr, ());\n+    }\n+}\n \n-        .. *oldvisit::default_visitor()\n-    });\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: method_map,\n+                   crate: &ast::Crate) {\n+    let context = @mut Context {\n+        method_map: method_map,\n+        unsafe_context: SafeContext,\n+    };\n+\n+    let mut visitor = EffectCheckVisitor {\n+        tcx: tcx,\n+        context: context,\n+    };\n \n-    oldvisit::visit_crate(crate, ((), visitor))\n+    visit::walk_crate(&mut visitor, crate, ());\n }"}]}