{"sha": "8b1f85caede44808e62542cfdff04787d70f8f7f", "node_id": "C_kwDOAAsO6NoAKDhiMWY4NWNhZWRlNDQ4MDhlNjI1NDJjZmRmZjA0Nzg3ZDcwZjhmN2Y", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-04-25T23:13:24Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-04-25T23:13:24Z"}, "message": "Windows: Iterative `remove_dir_all`\n\nThis will allow better strategies for use of memory and File handles. However, fully taking advantage of that is left to future work.", "tree": {"sha": "7ea660ad6975a6818af9375a1d8444fd2e11e029", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ea660ad6975a6818af9375a1d8444fd2e11e029"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b1f85caede44808e62542cfdff04787d70f8f7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmJnKxQACgkQcTRy8vRW\nJ95Rtg//fVyFdlxEOc+wmKNw2i//1Aw6g90IR2QYjNlYlMjLQXti2kkkSnDUBlSZ\nzN9F734B7Y1yGEJkx+uruq/BXS+7+D/n363WiGeYBCKwqbJyCnkqlfCcFR2UFCrk\ni/X76RedYsfdt2hrl467au8TAWWKZZAW3rO/3giKqZuqArZKqujmuegUdKAXgC8a\n4/ex1Z0KbeiB+4MIv6z/GE6X9fs1ZQxTiQ6XG2j6eAnh0W0UnNB6zTnsLwZg7PU4\nbM+nnBACbmjfi+gwEXDXHrGROKHDWWk6ahb0A55VQvUhLwNVqmQw9ue6YWPo/2X9\nZ34TVdpS0QjW+bA+Q7GgqJHFUg1yxfMcNk4ZK3Yzrf8ZiMEQzPTYLC1gmfNrv+BN\ncBPTusxnqmP9eKXars5B7bBFazsgyKFR5/kgewNIq6Ps4sJXKlGIiYDyzzlOm4f+\nfEgaCd3gbZsJhr+G7cIvMwuGfJfDHQ1lI1RXyJP/vLFD8vSbPHFz5LW6SzFanKON\ncEclbWTU/aGIixUudzRLhjTOL3BDGkXBkK7NK6Pc479t9hJ0HUK8ANxLhIR314kB\nJKJEfP40CLlD8EaS0JfeDajsl49/d1HxMH1CA8wreOFIbAzOugM9Sl4oYhuiyBmv\n8r4PzjMn2FjDG7dyNs3RXmLTpnl2YnGkzpsqGwoOkipfhEni6Zk=\n=FWIF\n-----END PGP SIGNATURE-----", "payload": "tree 7ea660ad6975a6818af9375a1d8444fd2e11e029\nparent 7417110cefda899a685a77557ac2bd7d7ee07e54\nauthor Chris Denton <christophersdenton@gmail.com> 1650928404 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1650928404 +0100\n\nWindows: Iterative `remove_dir_all`\n\nThis will allow better strategies for use of memory and File handles. However, fully taking advantage of that is left to future work.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b1f85caede44808e62542cfdff04787d70f8f7f", "html_url": "https://github.com/rust-lang/rust/commit/8b1f85caede44808e62542cfdff04787d70f8f7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b1f85caede44808e62542cfdff04787d70f8f7f/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7417110cefda899a685a77557ac2bd7d7ee07e54", "url": "https://api.github.com/repos/rust-lang/rust/commits/7417110cefda899a685a77557ac2bd7d7ee07e54", "html_url": "https://github.com/rust-lang/rust/commit/7417110cefda899a685a77557ac2bd7d7ee07e54"}], "stats": {"total": 144, "additions": 67, "deletions": 77}, "files": [{"sha": "618cbbb1817ec9f4612fb94e5a82bc3986a704ae", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 67, "deletions": 77, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8b1f85caede44808e62542cfdff04787d70f8f7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b1f85caede44808e62542cfdff04787d70f8f7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=8b1f85caede44808e62542cfdff04787d70f8f7f", "patch": "@@ -680,7 +680,7 @@ impl<'a> DirBuffIter<'a> {\n     }\n }\n impl<'a> Iterator for DirBuffIter<'a> {\n-    type Item = &'a [u16];\n+    type Item = (&'a [u16], bool);\n     fn next(&mut self) -> Option<Self::Item> {\n         use crate::mem::size_of;\n         let buffer = &self.buffer?[self.cursor..];\n@@ -689,14 +689,16 @@ impl<'a> Iterator for DirBuffIter<'a> {\n         // SAFETY: The buffer contains a `FILE_ID_BOTH_DIR_INFO` struct but the\n         // last field (the file name) is unsized. So an offset has to be\n         // used to get the file name slice.\n-        let (name, next_entry) = unsafe {\n+        let (name, is_directory, next_entry) = unsafe {\n             let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n             let next_entry = (*info).NextEntryOffset as usize;\n             let name = crate::slice::from_raw_parts(\n                 (*info).FileName.as_ptr().cast::<u16>(),\n                 (*info).FileNameLength as usize / size_of::<u16>(),\n             );\n-            (name, next_entry)\n+            let is_directory = ((*info).FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) != 0;\n+\n+            (name, is_directory, next_entry)\n         };\n \n         if next_entry == 0 {\n@@ -709,7 +711,7 @@ impl<'a> Iterator for DirBuffIter<'a> {\n         const DOT: u16 = b'.' as u16;\n         match name {\n             [DOT] | [DOT, DOT] => self.next(),\n-            _ => Some(name),\n+            _ => Some((name, is_directory)),\n         }\n     }\n }\n@@ -994,89 +996,77 @@ pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n     if (file.basic_info()?.FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) == 0 {\n         return Err(io::Error::from_raw_os_error(c::ERROR_DIRECTORY as _));\n     }\n-    let mut delete: fn(&File) -> io::Result<()> = File::posix_delete;\n-    let result = match delete(&file) {\n-        Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n-            match remove_dir_all_recursive(&file, delete) {\n-                // Return unexpected errors.\n-                Err(e) if e.kind() != io::ErrorKind::DirectoryNotEmpty => return Err(e),\n-                result => result,\n-            }\n-        }\n-        // If POSIX delete is not supported for this filesystem then fallback to win32 delete.\n-        Err(e)\n-            if e.raw_os_error() == Some(c::ERROR_NOT_SUPPORTED as i32)\n-                || e.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) =>\n-        {\n-            delete = File::win32_delete;\n-            Err(e)\n-        }\n-        result => result,\n-    };\n-    if result.is_ok() {\n-        Ok(())\n-    } else {\n-        // This is a fallback to make sure the directory is actually deleted.\n-        // Otherwise this function is prone to failing with `DirectoryNotEmpty`\n-        // due to possible delays between marking a file for deletion and the\n-        // file actually being deleted from the filesystem.\n-        //\n-        // So we retry a few times before giving up.\n-        for _ in 0..5 {\n-            match remove_dir_all_recursive(&file, delete) {\n-                Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n-                result => return result,\n+\n+    match remove_dir_all_iterative(&file, File::posix_delete) {\n+        Err(e) => {\n+            if let Some(code) = e.raw_os_error() {\n+                match code as u32 {\n+                    // If POSIX delete is not supported for this filesystem then fallback to win32 delete.\n+                    c::ERROR_NOT_SUPPORTED\n+                    | c::ERROR_INVALID_FUNCTION\n+                    | c::ERROR_INVALID_PARAMETER => {\n+                        remove_dir_all_iterative(&file, File::win32_delete)\n+                    }\n+                    _ => Err(e),\n+                }\n+            } else {\n+                Err(e)\n             }\n         }\n-        // Try one last time.\n-        delete(&file)\n+        ok => ok,\n     }\n }\n \n-fn remove_dir_all_recursive(f: &File, delete: fn(&File) -> io::Result<()>) -> io::Result<()> {\n+fn remove_dir_all_iterative(f: &File, delete: fn(&File) -> io::Result<()>) -> io::Result<()> {\n     let mut buffer = DirBuff::new();\n-    let mut restart = true;\n-    // Fill the buffer and iterate the entries.\n-    while f.fill_dir_buff(&mut buffer, restart)? {\n-        for name in buffer.iter() {\n-            // Open the file without following symlinks and try deleting it.\n-            // We try opening will all needed permissions and if that is denied\n-            // fallback to opening without `FILE_LIST_DIRECTORY` permission.\n-            // Note `SYNCHRONIZE` permission is needed for synchronous access.\n-            let mut result =\n-                open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY);\n-            if matches!(&result, Err(e) if e.kind() == io::ErrorKind::PermissionDenied) {\n-                result = open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE);\n-            }\n-            match result {\n-                Ok(file) => match delete(&file) {\n-                    Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n-                        // Iterate the directory's files.\n-                        // Ignore `DirectoryNotEmpty` errors here. They will be\n-                        // caught when `remove_dir_all` tries to delete the top\n-                        // level directory. It can then decide if to retry or not.\n-                        match remove_dir_all_recursive(&file, delete) {\n-                            Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n-                            result => result?,\n-                        }\n+    let mut dirlist = vec![f.duplicate()?];\n+\n+    // FIXME: This is a hack so we can push to the dirlist vec after borrowing from it.\n+    fn copy_handle(f: &File) -> mem::ManuallyDrop<File> {\n+        unsafe { mem::ManuallyDrop::new(File::from_raw_handle(f.as_raw_handle())) }\n+    }\n+\n+    while let Some(dir) = dirlist.last() {\n+        let dir = copy_handle(dir);\n+\n+        // Fill the buffer and iterate the entries.\n+        let more_data = dir.fill_dir_buff(&mut buffer, false)?;\n+        for (name, is_directory) in buffer.iter() {\n+            if is_directory {\n+                let child_dir = open_link_no_reparse(\n+                    &dir,\n+                    name,\n+                    c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY,\n+                )?;\n+                dirlist.push(child_dir);\n+            } else {\n+                const MAX_RETRIES: u32 = 10;\n+                for i in 1..=MAX_RETRIES {\n+                    let result = open_link_no_reparse(&dir, name, c::SYNCHRONIZE | c::DELETE);\n+                    match result {\n+                        Ok(f) => delete(&f)?,\n+                        // Already deleted, so skip.\n+                        Err(e) if e.kind() == io::ErrorKind::NotFound => break,\n+                        // Retry a few times if the file is locked or a delete is already in progress.\n+                        Err(e)\n+                            if i < MAX_RETRIES\n+                                && (e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n+                                    || e.raw_os_error()\n+                                        == Some(c::ERROR_SHARING_VIOLATION as _)) => {}\n+                        // Otherwise return the error.\n+                        Err(e) => return Err(e),\n                     }\n-                    result => result?,\n-                },\n-                // Ignore error if a delete is already in progress or the file\n-                // has already been deleted. It also ignores sharing violations\n-                // (where a file is locked by another process) as these are\n-                // usually temporary.\n-                Err(e)\n-                    if e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n-                        || e.kind() == io::ErrorKind::NotFound\n-                        || e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {}\n-                Err(e) => return Err(e),\n+                }\n+            }\n+        }\n+        // If there were no more files then delete the directory.\n+        if !more_data {\n+            if let Some(dir) = dirlist.pop() {\n+                delete(&dir)?;\n             }\n         }\n-        // Continue reading directory entries without restarting from the beginning,\n-        restart = false;\n     }\n-    delete(&f)\n+    Ok(())\n }\n \n pub fn readlink(path: &Path) -> io::Result<PathBuf> {"}]}