{"sha": "c1335510d505ade8d1f2805ebf1a2beb5db8de07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMzM1NTEwZDUwNWFkZThkMWYyODA1ZWJmMWEyYmViNWRiOGRlMDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T19:08:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T19:09:09Z"}, "message": "rustc: Eliminate the direct use of ty.t.struct", "tree": {"sha": "647eb89ac2477e059fba17bdb76ca050eaab04a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/647eb89ac2477e059fba17bdb76ca050eaab04a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1335510d505ade8d1f2805ebf1a2beb5db8de07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1335510d505ade8d1f2805ebf1a2beb5db8de07", "html_url": "https://github.com/rust-lang/rust/commit/c1335510d505ade8d1f2805ebf1a2beb5db8de07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1335510d505ade8d1f2805ebf1a2beb5db8de07/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eb1479746224625f95b9b76379d18ac1cb72355", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb1479746224625f95b9b76379d18ac1cb72355", "html_url": "https://github.com/rust-lang/rust/commit/9eb1479746224625f95b9b76379d18ac1cb72355"}], "stats": {"total": 229, "additions": 118, "deletions": 111}, "files": [{"sha": "e37b6913a204bad329fdfb91f9d46810ca5a433a", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=c1335510d505ade8d1f2805ebf1a2beb5db8de07", "patch": "@@ -546,7 +546,7 @@ fn get_tag_variants(session.session sess,\n         auto item = find_item(did._1, items);\n         auto ctor_ty = item_type(item, external_crate_id, tystore);\n         let vec[@ty.t] arg_tys = vec();\n-        alt (ctor_ty.struct) {\n+        alt (ty.struct(ctor_ty)) {\n             case (ty.ty_fn(_, ?args, _)) {\n                 for (ty.arg a in args) {\n                     arg_tys += vec(a.ty);"}, {"sha": "0325e32e089bf56ed5a80c10f5ba76172fd0bbd2", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=c1335510d505ade8d1f2805ebf1a2beb5db8de07", "patch": "@@ -53,7 +53,7 @@ const uint tag_index_table = 0x15u;\n type def_str = fn(ast.def_id) -> str;\n \n fn ty_str(@ty.t t, def_str ds) -> str {\n-    ret sty_str(t.struct, ds);\n+    ret sty_str(ty.struct(t), ds);\n }\n \n fn mt_str(&ty.mt mt, def_str ds) -> str {"}, {"sha": "7f723994f5781719aa6a57c1522d00f38c31467a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c1335510d505ade8d1f2805ebf1a2beb5db8de07", "patch": "@@ -683,7 +683,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n \n     let TypeRef llty = 0 as TypeRef;\n \n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_native) { llty = T_ptr(T_i8()); }\n         case (ty.ty_nil) { llty = T_nil(); }\n         case (ty.ty_bool) { llty = T_bool(); }\n@@ -789,7 +789,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n }\n \n fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n-    alt (arg.ty.struct) {\n+    alt (ty.struct(arg.ty)) {\n         case (ty.ty_param(_)) {\n             if (arg.mode == ast.alias) {\n                 ret T_typaram_ptr(cx.ccx.tn);\n@@ -811,7 +811,7 @@ fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n \n fn type_of_ty_param_count_and_ty(@local_ctxt lcx,\n                                  ty.ty_param_count_and_ty tpt) -> TypeRef {\n-    alt (tpt._1.struct) {\n+    alt (ty.struct(tpt._1)) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             auto llfnty = type_of_fn(lcx.ccx, proto, inputs, output, tpt._0);\n             ret T_fn_pair(lcx.ccx.tn, llfnty);\n@@ -1148,7 +1148,7 @@ fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n // types.\n fn simplify_type(@crate_ctxt ccx, @ty.t typ) -> @ty.t {\n     fn simplifier(@crate_ctxt ccx, @ty.t typ) -> @ty.t {\n-        alt (typ.struct) {\n+        alt (ty.struct(typ)) {\n             case (ty.ty_box(_)) {\n                 ret ty.mk_imm_box(ccx.tystore, ty.mk_nil(ccx.tystore));\n             }\n@@ -1172,7 +1172,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n \n     auto tid;\n     let vec[@ty.t] subtys;\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_tag(?tid_, ?subtys_)) {\n             tid = tid_;\n             subtys = subtys_;\n@@ -1232,7 +1232,7 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n         ret res(bcx, off);\n     }\n \n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_param(?p)) {\n             auto szptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n             ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n@@ -1287,7 +1287,7 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n }\n \n fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_param(?p)) {\n             auto aptr = field_of_tydesc(cx, t, abi.tydesc_field_align);\n             ret res(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n@@ -1526,7 +1526,7 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t) ->\n                   mutable vec[uint] defs);\n \n     fn linearizer(@rr r, @ty.t t) {\n-        alt(t.struct) {\n+        alt(ty.struct(t)) {\n             case (ty.ty_param(?pid)) {\n                 let bool seen = false;\n                 for (uint d in r.defs) {\n@@ -1797,7 +1797,7 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n fn make_drop_glue(@block_ctxt cx, ValueRef v0, @ty.t t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     auto rslt;\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_str) {\n             auto v = cx.build.Load(v0);\n             rslt = decr_refcnt_and_if_zero\n@@ -2353,7 +2353,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         ret res(next_cx, r.val);\n     }\n \n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_tup(?args)) {\n             let int i = 0;\n             for (ty.mt arg in args) {\n@@ -2427,7 +2427,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                 if (_vec.len[@ty.t](variant.args) > 0u) {\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n-                    alt (fn_ty.struct) {\n+                    alt (ty.struct(fn_ty)) {\n                         case (ty.ty_fn(_, ?args, _)) {\n                             auto j = 0;\n                             for (ty.arg a in args) {\n@@ -2623,7 +2623,7 @@ fn iter_sequence(@block_ctxt cx,\n         ret iter_sequence_inner(cx, p0, p1, elt_ty, f);\n     }\n \n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_vec(?elt)) {\n             ret iter_sequence_body(cx, v, elt.ty, f, false);\n         }\n@@ -2850,7 +2850,7 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n }\n \n fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_int) {\n             auto struct_ty = ty.mk_mach(cx.tystore,\n                                         cx.sess.get_targ_cfg().int_type);\n@@ -2914,7 +2914,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n         case (ast.neg) {\n             sub = autoderef(sub.bcx, sub.val,\n                             ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n-            if(e_ty.struct == ty.ty_float) {\n+            if(ty.struct(e_ty) == ty.ty_float) {\n                 ret res(sub.bcx, sub.bcx.build.FNeg(sub.val));\n             }\n             else {\n@@ -3005,7 +3005,7 @@ fn trans_vec_append(@block_ctxt cx, @ty.t t,\n     auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tystore, t);\n \n     auto skip_null = C_bool(false);\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_str) { skip_null = C_bool(true); }\n         case (_) { }\n     }\n@@ -3045,7 +3045,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, @ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> result {\n \n     auto is_float = false;\n-    alt (intype.struct) {\n+    alt (ty.struct(intype)) {\n         case (ty.ty_float) {\n             is_float = true;\n         }\n@@ -3123,7 +3123,7 @@ fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n     let @ty.t t1 = t;\n \n     while (true) {\n-        alt (t1.struct) {\n+        alt (ty.struct(t1)) {\n             case (ty.ty_box(?mt)) {\n                 auto body = cx.build.GEP(v1,\n                                          vec(C_int(0),\n@@ -3154,7 +3154,7 @@ fn autoderefed_ty(@ty.t t) -> @ty.t {\n     let @ty.t t1 = t;\n \n     while (true) {\n-        alt (t1.struct) {\n+        alt (ty.struct(t1)) {\n             case (ty.ty_box(?mt)) {\n                 t1 = mt.ty;\n             }\n@@ -3990,7 +3990,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     auto v_tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n                         cx.fcx.lcx.ccx.tystore,\n                         cx.fcx.lcx.ccx.type_cache, vid);\n-                    alt (v_tyt._1.struct) {\n+                    alt (ty.struct(v_tyt._1)) {\n                         case (ty.ty_fn(_, _, _)) {\n                             // N-ary variant.\n                             ret lval_generic_fn(cx, v_tyt, vid, ann);\n@@ -4052,7 +4052,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n     auto r = autoderef(cx, v, t0);\n     auto t = autoderefed_ty(t0);\n \n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_tup(_)) {\n             let uint ix = ty.field_num(cx.fcx.lcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n@@ -4820,7 +4820,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n              &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty = t;\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_vec(?mt)) {\n             unit_ty = mt.ty;\n         }\n@@ -4914,7 +4914,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n     }\n \n     let vec[ty.field] ty_fields = vec();\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_rec(?flds)) { ty_fields = flds; }\n     }\n \n@@ -5170,7 +5170,7 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n     if (ty.type_is_fp(e_ty)) {\n         let TypeRef tr;\n         let bool is32bit = false;\n-        alt (e_ty.struct) {\n+        alt (ty.struct(e_ty)) {\n             case (ty.ty_machine(util.common.ty_f32)) {\n                 tr = T_f32();\n                 is32bit = true;\n@@ -5196,7 +5196,7 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n             uval.bcx.build.Br(after_cx.llbb);\n         }\n     } else {\n-        alt (e_ty.struct) {\n+        alt (ty.struct(e_ty)) {\n             case (ty.ty_str) {\n                 auto v = vp2i(sub.bcx, sub.val);\n                 trans_upcall(sub.bcx,\n@@ -5382,7 +5382,7 @@ fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n \n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_port(?t)) {\n             unit_ty = t;\n         }\n@@ -5437,7 +5437,7 @@ fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     auto chan_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n-    alt (chan_ty.struct) {\n+    alt (ty.struct(chan_ty)) {\n         case (ty.ty_chan(?t)) {\n             unit_ty = t;\n         }\n@@ -5915,7 +5915,7 @@ fn is_terminated(@block_ctxt cx) -> bool {\n }\n \n fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n-    alt (ty.ann_to_type(ann).struct) {\n+    alt (ty.struct(ty.ann_to_type(ann))) {\n         case (ty.ty_fn(_, ?arg_tys, _)) {\n             ret arg_tys;\n         }\n@@ -5924,7 +5924,7 @@ fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n }\n \n fn ret_ty_of_fn_ty(@ty.t t) -> @ty.t {\n-    alt (t.struct) {\n+    alt (ty.struct(t)) {\n         case (ty.ty_fn(_, _, ?ret_ty)) {\n             ret ret_ty;\n         }\n@@ -6060,7 +6060,7 @@ fn trans_vtbl(@local_ctxt cx,\n     for (@ast.method m in meths) {\n \n         auto llfnty = T_nil();\n-        alt (node_ann_type(cx.ccx, m.node.ann).struct) {\n+        alt (ty.struct(node_ann_type(cx.ccx, m.node.ann))) {\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx.ccx, proto,\n                                          some[TypeRef](llself_ty),\n@@ -6099,7 +6099,7 @@ fn trans_dtor(@local_ctxt cx,\n               &@ast.method dtor) -> ValueRef {\n \n     auto llfnty = T_nil();\n-    alt (node_ann_type(cx.ccx, dtor.node.ann).struct) {\n+    alt (ty.struct(node_ann_type(cx.ccx, dtor.node.ann))) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfnty = type_of_fn_full(cx.ccx, proto,\n                                      some[TypeRef](llself_ty),\n@@ -6423,7 +6423,7 @@ fn decl_fn_and_pair(@crate_ctxt ccx,\n \n     auto llfty;\n     auto llpairty;\n-    alt (node_ann_type(ccx, ann).struct) {\n+    alt (ty.struct(node_ann_type(ccx, ann))) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfty = type_of_fn(ccx, proto, inputs, output,\n                                _vec.len[ast.ty_param](ty_params));\n@@ -6482,7 +6482,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n \n fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, @ty.t x)\n         -> TypeRef {\n-    alt (x.struct) {\n+    alt (ty.struct(x)) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n             ret type_of_fn(cx, ast.proto_fn, args, out, ty_param_count);\n         }"}, {"sha": "42b6c9088a3720de6d6ff359fa5de9cbe7940291", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c1335510d505ade8d1f2805ebf1a2beb5db8de07", "patch": "@@ -36,10 +36,12 @@ fn method_ty_to_fn_ty(@type_store tystore, method m) -> @ty.t {\n     ret mk_fn(tystore, m.proto, m.inputs, m.output);\n }\n \n-// Never construct these manually. These are interned.\n+// Never construct these manually. These are interned. Also don't assume that\n+// you can access the fields of this type directly; soon these will just be\n+// uints, and that won't work anymore.\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n-// outside world, to enforce the above invariant.\n+// outside world, to enforce the above invariants.\n type t = rec(sty struct, option.t[str] cname, uint hash);\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -211,6 +213,10 @@ fn mk_type(@type_store ts) -> @t         { ret gen_ty(ts, ty_type); }\n fn mk_native(@type_store ts) -> @t       { ret gen_ty(ts, ty_native); }\n \n \n+// Returns the one-level-deep type structure of the given type.\n+fn struct(@t typ) -> sty { ret typ.struct; }\n+\n+\n // Stringification\n \n fn path_to_str(&ast.path pth) -> str {\n@@ -264,7 +270,7 @@ fn ty_to_str(&@t typ) -> str {\n             s += _str.connect(_vec.map[arg,str](f, inputs), \", \");\n             s += \")\";\n \n-            if (output.struct != ty_nil) {\n+            if (struct(output) != ty_nil) {\n                 s += \" -> \" + ty_to_str(output);\n             }\n             ret s;\n@@ -291,7 +297,7 @@ fn ty_to_str(&@t typ) -> str {\n     }\n \n     auto s = \"\";\n-    alt (typ.struct) {\n+    alt (struct(typ)) {\n         case (ty_native)       { s += \"native\";                     }\n         case (ty_nil)          { s += \"()\";                         }\n         case (ty_bool)         { s += \"bool\";                       }\n@@ -377,7 +383,7 @@ fn ty_to_str(&@t typ) -> str {\n type ty_walk = fn(@t);\n \n fn walk_ty(ty_walk walker, @t ty) {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n@@ -441,7 +447,7 @@ type ty_fold = fn(@t) -> @t;\n \n fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n     auto ty = ty_0;\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n@@ -542,13 +548,13 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n // Type utilities\n \n fn rename(@type_store tystore, @t typ, str new_cname) -> @t {\n-    ret gen_ty_full(tystore, typ.struct, some[str](new_cname));\n+    ret gen_ty_full(tystore, struct(typ), some[str](new_cname));\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n fn copy_cname(@type_store tystore, @t struct_ty, @t cname_ty) -> @t {\n-    ret gen_ty_full(tystore, struct_ty.struct, cname_ty.cname);\n+    ret gen_ty_full(tystore, struct(struct_ty), cname_ty.cname);\n }\n \n // FIXME: remove me when == works on these tags.\n@@ -561,23 +567,23 @@ fn mode_is_alias(ast.mode m) -> bool {\n }\n \n fn type_is_nil(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_nil) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n fn type_is_bool(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_bool) { ret true; }\n         case (_) { ret false; }\n     }\n }\n \n \n fn type_is_structural(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n         case (ty_tag(_,_))  { ret true; }\n@@ -589,7 +595,7 @@ fn type_is_structural(@t ty) -> bool {\n }\n \n fn type_is_sequence(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_str)    { ret true; }\n         case (ty_vec(_))    { ret true; }\n         case (_)            { ret false; }\n@@ -598,7 +604,7 @@ fn type_is_sequence(@t ty) -> bool {\n }\n \n fn sequence_element_type(@type_store tystore, @t ty) -> @t {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_str)      { ret mk_mach(tystore, common.ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n     }\n@@ -607,7 +613,7 @@ fn sequence_element_type(@type_store tystore, @t ty) -> @t {\n \n \n fn type_is_tup_like(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_box(_))    { ret true; }\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n@@ -619,7 +625,7 @@ fn type_is_tup_like(@t ty) -> bool {\n \n fn get_element_type(@t ty, uint i) -> @t {\n     check (type_is_tup_like(ty));\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_tup(?mts)) {\n             ret mts.(i).ty;\n         }\n@@ -631,15 +637,15 @@ fn get_element_type(@t ty, uint i) -> @t {\n }\n \n fn type_is_box(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_box(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n fn type_is_boxed(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_str) { ret true; }\n         case (ty_vec(_)) { ret true; }\n         case (ty_box(_)) { ret true; }\n@@ -651,7 +657,7 @@ fn type_is_boxed(@t ty) -> bool {\n }\n \n fn type_is_scalar(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_nil) { ret true; }\n         case (ty_bool) { ret true; }\n         case (ty_int) { ret true; }\n@@ -669,15 +675,15 @@ fn type_is_scalar(@t ty) -> bool {\n // FIXME: should we just return true for native types in\n // type_is_scalar?\n fn type_is_native(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_native) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n fn type_has_dynamic_size(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n             while (i < _vec.len[mt](mts)) {\n@@ -706,7 +712,7 @@ fn type_has_dynamic_size(@t ty) -> bool {\n }\n \n fn type_is_integral(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_int) { ret true; }\n         case (ty_uint) { ret true; }\n         case (ty_machine(?m)) {\n@@ -730,7 +736,7 @@ fn type_is_integral(@t ty) -> bool {\n }\n \n fn type_is_fp(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n                 case (common.ty_f32) { ret true; }\n@@ -747,7 +753,7 @@ fn type_is_fp(@t ty) -> bool {\n }\n \n fn type_is_signed(@t ty) -> bool {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n@@ -764,7 +770,7 @@ fn type_is_signed(@t ty) -> bool {\n }\n \n fn type_param(@t ty) -> option.t[uint] {\n-    alt (ty.struct) {\n+    alt (struct(ty)) {\n         case (ty_param(?id)) { ret some[uint](id); }\n         case (_)             { /* fall through */  }\n     }\n@@ -1225,7 +1231,7 @@ fn eq_ty_full(&@t a, &@t b) -> bool {\n     }\n \n     // Check structures.\n-    ret equal_type_structures(a.struct, b.struct);\n+    ret equal_type_structures(struct(a), struct(b));\n }\n \n // This is the equality function the public should use. It works as long as\n@@ -1292,7 +1298,7 @@ fn triv_ann(@ty.t typ) -> ast.ann {\n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(@t ty) -> uint {\n     fn counter(@mutable vec[uint] param_indices, @t ty) {\n-        alt (ty.struct) {\n+        alt (struct(ty)) {\n             case (ty_param(?param_idx)) {\n                 auto seen = false;\n                 for (uint other_param_idx in *param_indices) {\n@@ -1317,7 +1323,7 @@ fn count_ty_params(@t ty) -> uint {\n \n fn type_contains_vars(@t typ) -> bool {\n     fn checker(@mutable bool flag, @t typ) {\n-        alt (typ.struct) {\n+        alt (struct(typ)) {\n             case (ty_var(_)) { *flag = true; }\n             case (_) { /* fall through */ }\n         }\n@@ -1332,37 +1338,37 @@ fn type_contains_vars(@t typ) -> bool {\n // Type accessors for substructures of types\n \n fn ty_fn_args(@t fty) -> vec[arg] {\n-    alt (fty.struct) {\n+    alt (struct(fty)) {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n         case (ty.ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n \n fn ty_fn_proto(@t fty) -> ast.proto {\n-    alt (fty.struct) {\n+    alt (struct(fty)) {\n         case (ty.ty_fn(?p, _, _)) { ret p; }\n     }\n     fail;\n }\n \n fn ty_fn_abi(@t fty) -> ast.native_abi {\n-    alt (fty.struct) {\n+    alt (struct(fty)) {\n         case (ty.ty_native_fn(?a, _, _)) { ret a; }\n     }\n     fail;\n }\n \n fn ty_fn_ret(@t fty) -> @t {\n-    alt (fty.struct) {\n+    alt (struct(fty)) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n         case (ty.ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n fn is_fn_ty(@t fty) -> bool {\n-    alt (fty.struct) {\n+    alt (struct(fty)) {\n         case (ty.ty_fn(_, _, _)) { ret true; }\n         case (ty.ty_native_fn(_, _, _)) { ret true; }\n         case (_) { ret false; }\n@@ -1675,7 +1681,7 @@ mod Unify {\n \n     // Simple structural type comparison.\n     fn struct_cmp(@ty.t expected, @ty.t actual) -> result {\n-        if (expected.struct == actual.struct) {\n+        if (struct(expected) == struct(actual)) {\n             ret ures_ok(expected);\n         }\n \n@@ -1840,7 +1846,7 @@ mod Unify {\n                           a_meth.inputs, a_meth.output);\n         alt (r) {\n             case (ures_ok(?tfn)) {\n-                alt (tfn.struct) {\n+                alt (struct(tfn)) {\n                     case (ty_fn(?proto, ?ins, ?out)) {\n                         result_meths += vec(rec(inputs = ins,\n                                                 output = out\n@@ -1880,12 +1886,12 @@ mod Unify {\n         // Fast path.\n         if (eq_ty(expected, actual)) { ret ures_ok(expected); }\n \n-        alt (actual.struct) {\n+        alt (struct(actual)) {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty.ty_var(?actual_id)) {\n                 auto actual_n = get_or_create_set(cx, actual_id);\n-                alt (expected.struct) {\n+                alt (struct(expected)) {\n                     case (ty.ty_var(?expected_id)) {\n                         auto expected_n = get_or_create_set(cx, expected_id);\n                         UFind.union(cx.sets, expected_n, actual_n);\n@@ -1921,7 +1927,7 @@ mod Unify {\n                 ret ures_ok(result_ty);\n             }\n             case (ty.ty_bound_param(?actual_id)) {\n-                alt (expected.struct) {\n+                alt (struct(expected)) {\n                     case (ty.ty_local(_)) {\n                         log_err \"TODO: bound param unifying with local\";\n                         fail;\n@@ -1935,7 +1941,7 @@ mod Unify {\n             case (_) { /* empty */ }\n         }\n \n-        alt (expected.struct) {\n+        alt (struct(expected)) {\n             case (ty.ty_nil)        { ret struct_cmp(expected, actual); }\n             case (ty.ty_bool)       { ret struct_cmp(expected, actual); }\n             case (ty.ty_int)        { ret struct_cmp(expected, actual); }\n@@ -1949,7 +1955,7 @@ mod Unify {\n             case (ty.ty_param(_))   { ret struct_cmp(expected, actual); }\n \n             case (ty.ty_tag(?expected_id, ?expected_tps)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_tag(?actual_id, ?actual_tps)) {\n                         if (expected_id._0 != actual_id._0 ||\n                                 expected_id._1 != actual_id._1) {\n@@ -1991,7 +1997,7 @@ mod Unify {\n             }\n \n             case (ty.ty_box(?expected_mt)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_box(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n@@ -2023,7 +2029,7 @@ mod Unify {\n             }\n \n             case (ty.ty_vec(?expected_mt)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_vec(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n@@ -2055,7 +2061,7 @@ mod Unify {\n             }\n \n             case (ty.ty_port(?expected_sub)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_port(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n@@ -2077,7 +2083,7 @@ mod Unify {\n             }\n \n             case (ty.ty_chan(?expected_sub)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_chan(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n@@ -2099,7 +2105,7 @@ mod Unify {\n             }\n \n             case (ty.ty_tup(?expected_elems)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_tup(?actual_elems)) {\n                         auto expected_len = _vec.len[ty.mt](expected_elems);\n                         auto actual_len = _vec.len[ty.mt](actual_elems);\n@@ -2153,7 +2159,7 @@ mod Unify {\n             }\n \n             case (ty.ty_rec(?expected_fields)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_rec(?actual_fields)) {\n                         auto expected_len = _vec.len[field](expected_fields);\n                         auto actual_len = _vec.len[field](actual_fields);\n@@ -2217,7 +2223,7 @@ mod Unify {\n             }\n \n             case (ty.ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n                         ret unify_fn(cx, ep, ap,\n                                      expected, actual,\n@@ -2233,7 +2239,7 @@ mod Unify {\n \n             case (ty.ty_native_fn(?e_abi, ?expected_inputs,\n                                   ?expected_output)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_native_fn(?a_abi, ?actual_inputs,\n                                           ?actual_output)) {\n                         ret unify_native_fn(cx, e_abi, a_abi,\n@@ -2248,7 +2254,7 @@ mod Unify {\n             }\n \n             case (ty.ty_obj(?expected_meths)) {\n-                alt (actual.struct) {\n+                alt (struct(actual)) {\n                     case (ty.ty_obj(?actual_meths)) {\n                         ret unify_obj(cx, expected, actual,\n                                       expected_meths, actual_meths);\n@@ -2301,7 +2307,7 @@ mod Unify {\n     // Performs type binding substitution.\n     fn substitute(@ctxt cx, vec[@t] set_types, @t typ) -> @t {\n         fn substituter(@ctxt cx, vec[@t] types, @t typ) -> @t {\n-            alt (typ.struct) {\n+            alt (struct(typ)) {\n                 case (ty_var(?id)) {\n                     alt (cx.var_ids.find(id)) {\n                         case (some[uint](?n)) {\n@@ -2434,7 +2440,7 @@ fn substitute_type_params(@type_store tystore,\n                           vec[@t] bindings,\n                           @t typ) -> @t {\n     fn replacer(vec[@t] bindings, @t typ) -> @t {\n-        alt (typ.struct) {\n+        alt (struct(typ)) {\n             case (ty_bound_param(?param_index)) {\n                 ret bindings.(param_index);\n             }\n@@ -2449,7 +2455,7 @@ fn substitute_type_params(@type_store tystore,\n // Converts type parameters in a type to bound type parameters.\n fn bind_params_in_type(@type_store tystore, @t typ) -> @t {\n     fn binder(@type_store tystore, @t typ) -> @t {\n-        alt (typ.struct) {\n+        alt (struct(typ)) {\n             case (ty_bound_param(?index)) {\n                 log_err \"bind_params_in_type() called on type that already \" +\n                     \"has bound params in it\";"}, {"sha": "6d2e06e039b4c429a5bb8e265b53ad723186ba81", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1335510d505ade8d1f2805ebf1a2beb5db8de07/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c1335510d505ade8d1f2805ebf1a2beb5db8de07", "patch": "@@ -20,6 +20,7 @@ import middle.ty.method;\n import middle.ty.mode_is_alias;\n import middle.ty.pat_ty;\n import middle.ty.path_to_str;\n+import middle.ty.struct;\n import middle.ty.triv_ann;\n import middle.ty.ty_to_str;\n import middle.ty.type_is_integral;\n@@ -80,7 +81,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n                         vec[@ty.t] supplied,\n                         &span sp) -> @ty.t {\n     fn substituter(@crate_ctxt ccx, vec[@ty.t] supplied, @ty.t typ) -> @ty.t {\n-        alt (typ.struct) {\n+        alt (struct(typ)) {\n             case (ty.ty_bound_param(?pid)) { ret supplied.(pid); }\n             case (_) { ret typ; }\n         }\n@@ -686,9 +687,9 @@ mod Collect {\n     }\n \n     fn get_ctor_obj_methods(@ty.t t) -> vec[method] {\n-        alt (t.struct) {\n+        alt (struct(t)) {\n             case (ty.ty_fn(_,_,?tobj)) {\n-                alt (tobj.struct) {\n+                alt (struct(tobj)) {\n                     case (ty.ty_obj(?tm)) {\n                         ret tm;\n                     }\n@@ -923,7 +924,7 @@ tag autoderef_kind {\n fn strip_boxes(@ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (true) {\n-        alt (t1.struct) {\n+        alt (struct(t1)) {\n             case (ty.ty_box(?inner)) { t1 = inner.ty; }\n             case (_) { ret t1; }\n         }\n@@ -945,7 +946,7 @@ fn count_boxes(@ty.t t) -> uint {\n     auto n = 0u;\n     auto t1 = t;\n     while (true) {\n-        alt (t1.struct) {\n+        alt (struct(t1)) {\n             case (ty.ty_box(?inner)) { n += 1u; t1 = inner.ty; }\n             case (_) { ret n; }\n         }\n@@ -1039,7 +1040,7 @@ fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n \n     auto tpt = ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache,\n                                    vid);\n-    alt (tpt._1.struct) {\n+    alt (struct(tpt._1)) {\n         case (ty.ty_fn(_, ?ins, _)) {\n             // N-ary variant.\n             for (ty.arg arg in ins) {\n@@ -1108,7 +1109,7 @@ mod Pushdown {\n                 // Take the variant's type parameters out of the expected\n                 // type.\n                 auto tag_tps;\n-                alt (expected.struct) {\n+                alt (struct(expected)) {\n                     case (ty.ty_tag(_, ?tps)) { tag_tps = tps; }\n                     case (_) {\n                         log_err \"tag pattern type not actually a tag?!\";\n@@ -1158,7 +1159,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[@ast.expr] es_1 = vec();\n-                alt (t.struct) {\n+                alt (struct(t)) {\n                     case (ty.ty_vec(?mt)) {\n                         for (@ast.expr e_0 in es_0) {\n                             es_1 += vec(pushdown_expr(fcx, mt.ty, e_0));\n@@ -1175,7 +1176,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[ast.elt] elts_1 = vec();\n-                alt (t.struct) {\n+                alt (struct(t)) {\n                     case (ty.ty_tup(?mts)) {\n                         auto i = 0u;\n                         for (ast.elt elt_0 in es_0) {\n@@ -1199,7 +1200,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[ast.field] fields_1 = vec();\n-                alt (t.struct) {\n+                alt (struct(t)) {\n                     case (ty.ty_rec(?field_mts)) {\n                         alt (base_0) {\n                             case (none[@ast.expr]) {\n@@ -1412,7 +1413,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let @ast.expr es_1;\n-                alt (t.struct) {\n+                alt (struct(t)) {\n                     case (ty.ty_chan(?subty)) {\n                         auto pt = ty.mk_port(fcx.ccx.tystore, subty);\n                         es_1 = pushdown_expr(fcx, pt, es);\n@@ -1514,7 +1515,7 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         -> ast.ann {\n     fn resolver(@fn_ctxt fcx, @ty.t typ) -> @ty.t {\n-        alt (typ.struct) {\n+        alt (struct(typ)) {\n             case (ty.ty_local(?lid)) { ret fcx.locals.get(lid); }\n             case (_)                 { ret typ; }\n         }\n@@ -1603,7 +1604,7 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                                            fcx.ccx.type_cache, vdef._0);\n             auto ann = instantiate_path(fcx, p, tpt, pat.span);\n \n-            alt (t.struct) {\n+            alt (struct(t)) {\n                 // N-ary variants have function types.\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n                     auto arg_len = _vec.len[arg](args);\n@@ -1691,7 +1692,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         auto rt_0 = next_ty_var(fcx.ccx);\n         auto t_0;\n-        alt (expr_ty(fcx.ccx.tystore, f_0).struct) {\n+        alt (struct(expr_ty(fcx.ccx.tystore, f_0))) {\n             case (ty.ty_fn(?proto, _, _))   {\n                 t_0 = ty.mk_fn(fcx.ccx.tystore, proto, arg_tys_0, rt_0);\n             }\n@@ -1800,7 +1801,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                        rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast.deref) {\n-                    alt (oper_t.struct) {\n+                    alt (struct(oper_t)) {\n                         case (ty.ty_box(?inner)) {\n                             oper_t = inner.ty;\n                         }\n@@ -1970,7 +1971,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto chan_t = ty.mk_chan(fcx.ccx.tystore, rhs_t);\n             auto lhs_1 = Pushdown.pushdown_expr(fcx, chan_t, lhs_0);\n             auto item_t;\n-            alt (expr_ty(fcx.ccx.tystore, lhs_1).struct) {\n+            alt (struct(expr_ty(fcx.ccx.tystore, lhs_1))) {\n                 case (ty.ty_chan(?it)) {\n                     item_t = it;\n                 }\n@@ -1993,7 +1994,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto port_t = ty.mk_port(fcx.ccx.tystore, lhs_t1);\n             auto rhs_1 = Pushdown.pushdown_expr(fcx, port_t, rhs_0);\n             auto item_t;\n-            alt (expr_ty(fcx.ccx.tystore, rhs_0).struct) {\n+            alt (struct(expr_ty(fcx.ccx.tystore, rhs_0))) {\n                 case (ty.ty_port(?it)) {\n                     item_t = it;\n                 }\n@@ -2163,7 +2164,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto proto_1;\n             let vec[ty.arg] arg_tys_1 = vec();\n             auto rt_1;\n-            alt (expr_ty(fcx.ccx.tystore, result._0).struct) {\n+            alt (struct(expr_ty(fcx.ccx.tystore, result._0))) {\n                 case (ty.ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2201,7 +2202,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // Pull the return type out of the type of the function.\n             auto rt_1 = ty.mk_nil(fcx.ccx.tystore);  // FIXME: typestate botch\n-            alt (expr_ty(fcx.ccx.tystore, f_1).struct) {\n+            alt (struct(expr_ty(fcx.ccx.tystore, f_1))) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n                 case (ty.ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n                 case (_) {\n@@ -2233,7 +2234,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // Grab this method's type out of the current object type\n \n             // this_obj_ty is an @ty.t\n-            alt (this_obj_ty.struct) {\n+            alt (struct(this_obj_ty)) {\n                 case (ty.ty_obj(?methods)) {\n                     for (ty.method method in methods) {\n                         if (method.ident == id) {\n@@ -2257,9 +2258,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto args_1 = result._1;\n \n             // Check the return type\n-            alt (expr_ty(fcx.ccx.tystore, f_1).struct) {\n+            alt (struct(expr_ty(fcx.ccx.tystore, f_1))) {\n                 case (ty.ty_fn(_,_,?rt)) {\n-                    alt (rt.struct) {\n+                    alt (struct(rt)) {\n                         case (ty.ty_nil) {\n                             // This is acceptable\n                         }\n@@ -2373,7 +2374,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                     let vec[field] base_fields = vec();\n \n-                    alt (bexpr_t.struct) {\n+                    alt (struct(bexpr_t)) {\n                         case (ty.ty_rec(?flds)) {\n                             base_fields = flds;\n                         }\n@@ -2412,7 +2413,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_field(?base, ?field, _)) {\n             auto base_1 = check_expr(fcx, base);\n             auto base_t = strip_boxes(expr_ty(fcx.ccx.tystore, base_1));\n-            alt (base_t.struct) {\n+            alt (struct(base_t)) {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n                                                expr.span, field);\n@@ -2473,7 +2474,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto idx_1 = check_expr(fcx, idx);\n             auto idx_t = expr_ty(fcx.ccx.tystore, idx_1);\n \n-            alt (base_t.struct) {\n+            alt (struct(base_t)) {\n                 case (ty.ty_vec(?mt)) {\n                     if (! type_is_integral(idx_t)) {\n                         fcx.ccx.sess.span_err\n@@ -2520,7 +2521,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_chan(?x, _)) {\n             auto expr_1 = check_expr(fcx, x);\n             auto port_t = expr_ty(fcx.ccx.tystore, expr_1);\n-            alt (port_t.struct) {\n+            alt (struct(port_t)) {\n                 case (ty.ty_port(?subtype)) {\n                     auto ct = ty.mk_chan(fcx.ccx.tystore, subtype);\n                     auto ann = triv_ann(ct);"}]}