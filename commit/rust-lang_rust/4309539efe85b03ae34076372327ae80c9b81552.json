{"sha": "4309539efe85b03ae34076372327ae80c9b81552", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMDk1MzllZmU4NWIwM2FlMzQwNzYzNzIzMjdhZTgwYzliODE1NTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-07T12:00:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-07T12:00:27Z"}, "message": "cargo miri: refactor how we detect what to interpret and how we run cargo rustc, fix running unit tests", "tree": {"sha": "0aa1cdd96f41c128db92f15290088009cae9cf55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aa1cdd96f41c128db92f15290088009cae9cf55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4309539efe85b03ae34076372327ae80c9b81552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4309539efe85b03ae34076372327ae80c9b81552", "html_url": "https://github.com/rust-lang/rust/commit/4309539efe85b03ae34076372327ae80c9b81552", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4309539efe85b03ae34076372327ae80c9b81552/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e36a90de98b77bc3dccaa2910206ab15581c1755", "url": "https://api.github.com/repos/rust-lang/rust/commits/e36a90de98b77bc3dccaa2910206ab15581c1755", "html_url": "https://github.com/rust-lang/rust/commit/e36a90de98b77bc3dccaa2910206ab15581c1755"}], "stats": {"total": 346, "additions": 176, "deletions": 170}, "files": [{"sha": "b952aeea2f7f4a19658168358d34abe170ab5bdb", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 175, "deletions": 169, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/4309539efe85b03ae34076372327ae80c9b81552/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4309539efe85b03ae34076372327ae80c9b81552/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=4309539efe85b03ae34076372327ae80c9b81552", "patch": "@@ -7,10 +7,10 @@ use std::io::{self, Write, BufRead};\n use std::process::Command;\n use std::fs::{self, File};\n \n-const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates\n+const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and runs test suites\n \n Usage:\n-    cargo miri [subcommand] [options] [--] [<opts>...]\n+    cargo miri [subcommand] [options] [--] [<miri opts>...]\n \n Subcommands:\n     run                      Run binaries (default)\n@@ -22,12 +22,13 @@ Common options:\n     --features               Features to compile for the package\n     -V, --version            Print version info and exit\n \n-Other options are the same as `cargo rustc`.\n+Other [options] are the same as `cargo rustc`.  Everything after the \"--\" is\n+passed verbatim to Miri.\n \n-The feature `cargo-miri` is automatically defined for convenience. You can use\n+The config flag `miri` is automatically defined for convenience. You can use\n it to configure the resource limits\n \n-    #![cfg_attr(feature = \"cargo-miri\", memory_size = 42)]\n+    #![cfg_attr(miri, memory_size = 42)]\n \n available resource limits are `memory_size`, `step_limit`, `stack_limit`\n \"#;\n@@ -53,23 +54,32 @@ fn show_error(msg: String) -> ! {\n     std::process::exit(1)\n }\n \n+// Determines whether a --flag is present\n+fn has_arg_flag(name: &str) -> bool {\n+    let mut args = std::env::args().take_while(|val| val != \"--\");\n+    args.any(|val| val == name)\n+}\n+\n+/// Gets the value of a --flag\n fn get_arg_flag_value(name: &str) -> Option<String> {\n     // stop searching at `--`\n-    let mut args = std::env::args().skip_while(|val| !(val.starts_with(name) || val == \"--\"));\n-\n-    match args.next() {\n-        Some(ref p) if p == \"--\" => None,\n-        Some(ref p) if p == name => args.next(),\n-        Some(p) => {\n-            // Make sure this really starts with `$name=`, we didn't test for the `=` yet.\n-            let v = &p[name.len()..]; // strip leading `$name`\n-            if v.starts_with('=') {\n-                Some(v[1..].to_owned()) // strip leading `=`\n-            } else {\n-                None\n-            }\n-        },\n-        None => None,\n+    let mut args = std::env::args().take_while(|val| val != \"--\");\n+    loop {\n+        let arg = match args.next() {\n+            Some(arg) => arg,\n+            None => return None,\n+        };\n+        if !arg.starts_with(name) {\n+            continue;\n+        }\n+        let suffix = &arg[name.len()..]; // strip leading `name`\n+        if suffix.is_empty() {\n+            // This argument is exactly `name`, the next one is the value\n+            return args.next();\n+        } else if suffix.starts_with('=') {\n+            // This argument is `name=value`, get the value\n+            return Some(suffix[1..].to_owned()); // strip leading `=`\n+        }\n     }\n }\n \n@@ -272,167 +282,163 @@ fn main() {\n         // each applicable target, but with the RUSTC env var set to the `cargo-miri`\n         // binary so that we come back in the other branch, and dispatch\n         // the invocations to rustc and miri, respectively.\n-\n-        let (subcommand, skip) = match std::env::args().nth(2).deref() {\n-            Some(\"test\") => (MiriCommand::Test, 3),\n-            Some(\"run\") => (MiriCommand::Run, 3),\n-            Some(\"setup\") => (MiriCommand::Setup, 3),\n-            // Default command, if there is an option or nothing\n-            Some(s) if s.starts_with(\"-\") => (MiriCommand::Run, 2),\n-            None => (MiriCommand::Run, 2),\n-            // Unvalid command\n-            Some(s) => {\n-                show_error(format!(\"Unknown command `{}`\", s))\n-            }\n-        };\n-\n-        // We always setup\n-        let ask = subcommand != MiriCommand::Setup;\n-        setup(ask);\n-        if subcommand == MiriCommand::Setup {\n-            // Stop here.\n-            return;\n-        }\n-\n-        // Now run the command.\n-        for target in list_targets() {\n-            let args = std::env::args().skip(skip);\n-            let kind = target.kind.get(0).expect(\n-                \"badly formatted cargo metadata: target::kind is an empty array\",\n-            );\n-            match (subcommand, &kind[..]) {\n-                (MiriCommand::Test, \"test\") => {\n-                    // For test binaries we call `cargo rustc --test target -- <rustc args>`\n-                    if let Err(code) = process(\n-                        vec![\"--test\".to_string(), target.name].into_iter().chain(\n-                            args,\n-                        ),\n-                    )\n-                    {\n-                        std::process::exit(code);\n-                    }\n-                }\n-                (MiriCommand::Test, \"lib\") => {\n-                    // For libraries we call `cargo rustc -- --test <rustc args>`\n-                    // Notice now that `--test` is a rustc arg rather than a cargo arg. This tells\n-                    // rustc to build a test harness which calls all #[test] functions.\n-                    // We then execute that harness just like any other binary.\n-                    if let Err(code) = process(\n-                        vec![\"--\".to_string(), \"--test\".to_string()].into_iter().chain(\n-                            args,\n-                        ),\n-                    )\n-                    {\n-                        std::process::exit(code);\n-                    }\n-                }\n-                (MiriCommand::Run, \"bin\") => {\n-                    // For ordinary binaries we call `cargo rustc --bin target -- <rustc args>`\n-                    if let Err(code) = process(\n-                        vec![\"--bin\".to_string(), target.name].into_iter().chain(\n-                            args,\n-                        ),\n-                    )\n-                    {\n-                        std::process::exit(code);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n+        in_cargo_miri();\n     } else if let Some(\"rustc\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n         // This arm is executed when cargo-miri runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n         // Dependencies get dispatched to rustc, the final test/binary to miri.\n+        inside_cargo_rustc();\n+    } else {\n+        show_error(format!(\"Must be called with either `miri` or `rustc` as first argument.\"))\n+    }\n+}\n \n-        let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n-        let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-        let sys_root = if let Ok(sysroot) = ::std::env::var(\"MIRI_SYSROOT\") {\n-            sysroot\n-        } else if let (Some(home), Some(toolchain)) = (home, toolchain) {\n-            format!(\"{}/toolchains/{}\", home, toolchain)\n-        } else {\n-            option_env!(\"RUST_SYSROOT\")\n-                .map(|s| s.to_owned())\n-                .or_else(|| {\n-                    Command::new(\"rustc\")\n-                        .arg(\"--print\")\n-                        .arg(\"sysroot\")\n-                        .output()\n-                        .ok()\n-                        .and_then(|out| String::from_utf8(out.stdout).ok())\n-                        .map(|s| s.trim().to_owned())\n-                })\n-                .expect(\"need to specify RUST_SYSROOT env var during miri compilation, or use rustup or multirust\")\n-        };\n+fn in_cargo_miri() {\n+    let (subcommand, skip) = match std::env::args().nth(2).deref() {\n+        Some(\"test\") => (MiriCommand::Test, 3),\n+        Some(\"run\") => (MiriCommand::Run, 3),\n+        Some(\"setup\") => (MiriCommand::Setup, 3),\n+        // Default command, if there is an option or nothing\n+        Some(s) if s.starts_with(\"-\") => (MiriCommand::Run, 2),\n+        None => (MiriCommand::Run, 2),\n+        // Unvalid command\n+        Some(s) => {\n+            show_error(format!(\"Unknown command `{}`\", s))\n+        }\n+    };\n+    let verbose = has_arg_flag(\"-v\");\n \n-        // this conditional check for the --sysroot flag is there so users can call `cargo-miri` directly\n-        // without having to pass --sysroot or anything\n-        let rustc_args = std::env::args().skip(2);\n-        let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n-            rustc_args.collect()\n-        } else {\n-            rustc_args\n-                .chain(Some(\"--sysroot\".to_owned()))\n-                .chain(Some(sys_root))\n-                .collect()\n-        };\n-        args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n-        args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-miri\"\"#.to_owned()]);\n-\n-        // this check ensures that dependencies are built but not interpreted and the final crate is\n-        // interpreted but not built\n-        let miri_enabled = std::env::args().any(|s| s == \"--emit=dep-info,metadata\");\n-        let mut command = if miri_enabled {\n-            let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n-            path.set_file_name(\"miri\");\n-            Command::new(path)\n-        } else {\n-            Command::new(\"rustc\")\n-        };\n-        command.args(&args);\n+    // We always setup\n+    let ask = subcommand != MiriCommand::Setup;\n+    setup(ask);\n+    if subcommand == MiriCommand::Setup {\n+        // Stop here.\n+        return;\n+    }\n \n-        match command.status() {\n-            Ok(exit) => {\n-                if !exit.success() {\n-                    std::process::exit(exit.code().unwrap_or(42));\n-                }\n+    // Now run the command.\n+    for target in list_targets() {\n+        let mut args = std::env::args().skip(skip);\n+        let kind = target.kind.get(0).expect(\n+            \"badly formatted cargo metadata: target::kind is an empty array\",\n+        );\n+        // Now we run `cargo rustc $FLAGS $ARGS`, giving the user the\n+        // change to add additional flags.  \"FLAGS\" is set to identify\n+        // this target.  The user gets to control what gets actually passed to Miri.\n+        // However, we need to add a flag to what gets passed to rustc for the finaly\n+        // binary, so that we know to interpret that with Miri.\n+        // So after the first \"--\", we add \"-Zcargo-miri-marker\".\n+        let mut cmd = Command::new(\"cargo\");\n+        cmd.arg(\"rustc\");\n+        match (subcommand, &kind[..]) {\n+            (MiriCommand::Run, \"bin\") => {\n+                // FIXME: We just run all the binaries here.\n+                // We should instead support `cargo miri --bin foo`.\n+                cmd.arg(\"--bin\").arg(target.name);\n+            }\n+            (MiriCommand::Test, \"test\") => {\n+                cmd.arg(\"--test\").arg(target.name);\n             }\n-            Err(ref e) if miri_enabled => panic!(\"error during miri run: {:?}\", e),\n-            Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n+            (MiriCommand::Test, \"lib\") |\n+            (MiriCommand::Test, \"bin\") => {\n+                cmd.arg(format!(\"--{}\", kind)).arg(target.name).arg(\"--profile\").arg(\"test\");\n+            }\n+            // The remaining targets we do not even want to build\n+            _ => continue,\n+        }\n+        // add user-defined args until first \"--\"\n+        while let Some(arg) = args.next() {\n+            if arg == \"--\" {\n+                break;\n+            }\n+            cmd.arg(arg);\n+        }\n+        // add \"--\" \"-Zcargo-miri-marker\" and the remaining user flags\n+        cmd\n+            .arg(\"--\")\n+            .arg(\"cargo-miri-marker\")\n+            .args(args);\n+        let path = std::env::current_exe().expect(\"current executable path invalid\");\n+        cmd.env(\"RUSTC_WRAPPER\", path);\n+        if verbose {\n+            eprintln!(\"+ {:?}\", cmd);\n+        }\n+\n+        let exit_status = cmd\n+            .spawn()\n+            .expect(\"could not run cargo\")\n+            .wait()\n+            .expect(\"failed to wait for cargo?\");\n+\n+        if !exit_status.success() {\n+            std::process::exit(exit_status.code().unwrap_or(-1))\n         }\n-    } else {\n-        show_error(format!(\"Must be called with either `miri` or `rustc` as first argument.\"))\n     }\n }\n \n-fn process<I>(old_args: I) -> Result<(), i32>\n-where\n-    I: Iterator<Item = String>,\n-{\n-    let mut args = vec![\"rustc\".to_owned()];\n+fn inside_cargo_rustc() {\n+    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n+    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n+    let sys_root = if let Ok(sysroot) = ::std::env::var(\"MIRI_SYSROOT\") {\n+        sysroot\n+    } else if let (Some(home), Some(toolchain)) = (home, toolchain) {\n+        format!(\"{}/toolchains/{}\", home, toolchain)\n+    } else {\n+        option_env!(\"RUST_SYSROOT\")\n+            .map(|s| s.to_owned())\n+            .or_else(|| {\n+                Command::new(\"rustc\")\n+                    .arg(\"--print\")\n+                    .arg(\"sysroot\")\n+                    .output()\n+                    .ok()\n+                    .and_then(|out| String::from_utf8(out.stdout).ok())\n+                    .map(|s| s.trim().to_owned())\n+            })\n+            .expect(\"need to specify RUST_SYSROOT env var during miri compilation, or use rustup or multirust\")\n+    };\n \n-    let mut found_dashes = false;\n-    for arg in old_args {\n-        found_dashes |= arg == \"--\";\n-        args.push(arg);\n-    }\n-    if !found_dashes {\n-        args.push(\"--\".to_owned());\n-    }\n-    args.push(\"--emit=dep-info,metadata\".to_owned());\n-\n-    let path = std::env::current_exe().expect(\"current executable path invalid\");\n-    let exit_status = Command::new(\"cargo\")\n-        .args(&args)\n-        .env(\"RUSTC_WRAPPER\", path)\n-        .spawn()\n-        .expect(\"could not run cargo\")\n-        .wait()\n-        .expect(\"failed to wait for cargo?\");\n-\n-    if exit_status.success() {\n-        Ok(())\n+    // this conditional check for the --sysroot flag is there so users can call `cargo-miri` directly\n+    // without having to pass --sysroot or anything\n+    let rustc_args = std::env::args().skip(2);\n+    let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n+        rustc_args.collect()\n+    } else {\n+        rustc_args\n+            .chain(Some(\"--sysroot\".to_owned()))\n+            .chain(Some(sys_root))\n+            .collect()\n+    };\n+    args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n+\n+    // see if we have cargo-miri-marker, which means we want to interpret this crate in Miri\n+    // (and remove the marker).\n+    let needs_miri = if let Some(pos) = args.iter().position(|arg| arg == \"cargo-miri-marker\") {\n+        args.remove(pos);\n+        true\n     } else {\n-        Err(exit_status.code().unwrap_or(-1))\n+        false\n+    };\n+\n+\n+    let mut command = if needs_miri {\n+        let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n+        path.set_file_name(\"miri\");\n+        Command::new(path)\n+    } else {\n+        Command::new(\"rustc\")\n+    };\n+    command.args(&args);\n+    if has_arg_flag(\"-v\") {\n+        eprintln!(\"+ {:?}\", command);\n+    }\n+\n+    match command.status() {\n+        Ok(exit) => {\n+            if !exit.success() {\n+                std::process::exit(exit.code().unwrap_or(42));\n+            }\n+        }\n+        Err(ref e) if needs_miri => panic!(\"error during miri run: {:?}\", e),\n+        Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n     }\n }"}, {"sha": "4ff3e011c6ae5b2deede9ed99c3956902dcaf997", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4309539efe85b03ae34076372327ae80c9b81552/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4309539efe85b03ae34076372327ae80c9b81552/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4309539efe85b03ae34076372327ae80c9b81552", "patch": "@@ -54,7 +54,7 @@ pub use crate::stacked_borrows::{Borrow, Stack, Stacks, BorStackItem};\n pub fn miri_default_args() -> &'static [&'static str] {\n     // The flags here should be kept in sync with what bootstrap adds when `test-miri` is\n     // set, which happens in `bootstrap/bin/rustc.rs` in the rustc sources.\n-    &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\"]\n+    &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\", \"--cfg=miri\"]\n }\n \n // Used by priroda"}]}