{"sha": "08e7d945629b32b32c34d5df84d881292e6f0451", "node_id": "C_kwDOAAsO6NoAKDA4ZTdkOTQ1NjI5YjMyYjMyYzM0ZDVkZjg0ZDg4MTI5MmU2ZjA0NTE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-07T01:17:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-07T01:31:40Z"}, "message": "avoid some string copies...", "tree": {"sha": "0c2f5ab97a1ab33fe5d9463bb05ed7faf62dd4cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c2f5ab97a1ab33fe5d9463bb05ed7faf62dd4cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08e7d945629b32b32c34d5df84d881292e6f0451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08e7d945629b32b32c34d5df84d881292e6f0451", "html_url": "https://github.com/rust-lang/rust/commit/08e7d945629b32b32c34d5df84d881292e6f0451", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08e7d945629b32b32c34d5df84d881292e6f0451/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "465538245a3a8768b9bf33d4fdd448cf32f29921", "url": "https://api.github.com/repos/rust-lang/rust/commits/465538245a3a8768b9bf33d4fdd448cf32f29921", "html_url": "https://github.com/rust-lang/rust/commit/465538245a3a8768b9bf33d4fdd448cf32f29921"}], "stats": {"total": 220, "additions": 140, "deletions": 80}, "files": [{"sha": "e8bac4625f71053d0784513a8f32821a2cdcdf20", "filename": "cargo-miri/src/arg.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Farg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Farg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Farg.rs?ref=08e7d945629b32b32c34d5df84d881292e6f0451", "patch": "@@ -0,0 +1,134 @@\n+//! Utilities for dealing with argument flags\n+\n+use std::borrow::Cow;\n+use std::env;\n+\n+/// Determines whether a `--flag` is present.\n+pub fn has_arg_flag(name: &str) -> bool {\n+    num_arg_flag(name) > 0\n+}\n+\n+/// Determines how many times a `--flag` is present.\n+pub fn num_arg_flag(name: &str) -> usize {\n+    env::args().take_while(|val| val != \"--\").filter(|val| val == name).count()\n+}\n+\n+/// Yields all values of command line flag `name` as `Ok(arg)`, and all other arguments except\n+/// the flag as `Err(arg)`. (The flag `name` itself is not yielded at all, only its values are.)\n+pub struct ArgSplitFlagValue<'a, I> {\n+    args: Option<I>,\n+    name: &'a str,\n+}\n+\n+impl<'a, I: Iterator> ArgSplitFlagValue<'a, I> {\n+    fn new(args: I, name: &'a str) -> Self {\n+        Self { args: Some(args), name }\n+    }\n+}\n+\n+impl<'s, I: Iterator<Item = Cow<'s, str>>> Iterator for ArgSplitFlagValue<'_, I> {\n+    // If the original iterator was all `Owned`, then we will only ever yield `Owned`\n+    // (so `into_owned()` is cheap).\n+    type Item = Result<Cow<'s, str>, Cow<'s, str>>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let Some(args) = self.args.as_mut() else {\n+            // We already canceled this iterator.\n+            return None;\n+        };\n+        let arg = args.next()?;\n+        if arg == \"--\" {\n+            // Stop searching at `--`.\n+            self.args = None;\n+            return None;\n+        }\n+        // These branches cannot be merged if we want to avoid the allocation in the `Borrowed` branch.\n+        match &arg {\n+            Cow::Borrowed(arg) =>\n+                if let Some(suffix) = arg.strip_prefix(self.name) {\n+                    // Strip leading `name`.\n+                    if suffix.is_empty() {\n+                        // This argument is exactly `name`; the next one is the value.\n+                        return args.next().map(Ok);\n+                    } else if let Some(suffix) = suffix.strip_prefix('=') {\n+                        // This argument is `name=value`; get the value.\n+                        return Some(Ok(Cow::Borrowed(suffix)));\n+                    }\n+                },\n+            Cow::Owned(arg) =>\n+                if let Some(suffix) = arg.strip_prefix(self.name) {\n+                    // Strip leading `name`.\n+                    if suffix.is_empty() {\n+                        // This argument is exactly `name`; the next one is the value.\n+                        return args.next().map(Ok);\n+                    } else if let Some(suffix) = suffix.strip_prefix('=') {\n+                        // This argument is `name=value`; get the value. We need to do an allocation\n+                        // here as a `String` cannot be subsliced (what would the lifetime be?).\n+                        return Some(Ok(Cow::Owned(suffix.to_owned())));\n+                    }\n+                },\n+        }\n+        Some(Err(arg))\n+    }\n+}\n+\n+impl<'a, I: Iterator<Item = String> + 'a> ArgSplitFlagValue<'a, I> {\n+    pub fn from_string_iter(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = Result<String, String>> + 'a {\n+        ArgSplitFlagValue::new(args.map(Cow::Owned), name).map(|x| {\n+            match x {\n+                Ok(Cow::Owned(s)) => Ok(s),\n+                Err(Cow::Owned(s)) => Err(s),\n+                _ => panic!(\"iterator converted owned to borrowed\"),\n+            }\n+        })\n+    }\n+}\n+\n+impl<'x: 'a, 'a, I: Iterator<Item = &'x str> + 'a> ArgSplitFlagValue<'a, I> {\n+    pub fn from_str_iter(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = Result<&'x str, &'x str>> + 'a {\n+        ArgSplitFlagValue::new(args.map(Cow::Borrowed), name).map(|x| {\n+            match x {\n+                Ok(Cow::Borrowed(s)) => Ok(s),\n+                Err(Cow::Borrowed(s)) => Err(s),\n+                _ => panic!(\"iterator converted borrowed to owned\"),\n+            }\n+        })\n+    }\n+}\n+\n+/// Yields all values of command line flag `name`.\n+pub struct ArgFlagValueIter;\n+\n+impl ArgFlagValueIter {\n+    pub fn from_string_iter<'a, I: Iterator<Item = String> + 'a>(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = String> + 'a {\n+        ArgSplitFlagValue::from_string_iter(args, name).filter_map(Result::ok)\n+    }\n+}\n+\n+impl ArgFlagValueIter {\n+    pub fn from_str_iter<'x: 'a, 'a, I: Iterator<Item = &'x str> + 'a>(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = &'x str> + 'a {\n+        ArgSplitFlagValue::from_str_iter(args, name).filter_map(Result::ok)\n+    }\n+}\n+\n+/// Gets the values of a `--flag`.\n+pub fn get_arg_flag_values(name: &str) -> impl Iterator<Item = String> + '_ {\n+    ArgFlagValueIter::from_string_iter(env::args(), name)\n+}\n+\n+/// Gets the value of a `--flag`.\n+pub fn get_arg_flag_value(name: &str) -> Option<String> {\n+    get_arg_flag_values(name).next()\n+}"}, {"sha": "f809eecf96af8f4b39e68f7803c18bdcc322e1b2", "filename": "cargo-miri/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fmain.rs?ref=08e7d945629b32b32c34d5df84d881292e6f0451", "patch": "@@ -1,6 +1,7 @@\n #![feature(let_else)]\n #![allow(clippy::useless_format, clippy::derive_partial_eq_without_eq)]\n \n+mod arg;\n mod phases;\n mod setup;\n mod util;"}, {"sha": "d0c0dafe071afa8c63cf9744e886cec41c50595c", "filename": "cargo-miri/src/phases.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fphases.rs?ref=08e7d945629b32b32c34d5df84d881292e6f0451", "patch": "@@ -119,7 +119,7 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     // Forward all arguments before `--` other than `--target-dir` and its value to Cargo.\n     // (We want to *change* the target-dir value, so we must not forward it.)\n     let mut target_dir = None;\n-    for arg in ArgSplitFlagValue::new(&mut args, \"--target-dir\") {\n+    for arg in ArgSplitFlagValue::from_string_iter(&mut args, \"--target-dir\") {\n         match arg {\n             Ok(value) => {\n                 if target_dir.is_some() {\n@@ -310,7 +310,8 @@ pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n             let mut cmd = miri();\n \n             // Ensure --emit argument for a check-only build is present.\n-            if let Some(val) = ArgFlagValueIter::new(env.args.clone().into_iter(), \"--emit\").next()\n+            if let Some(val) =\n+                ArgFlagValueIter::from_str_iter(env.args.iter().map(|s| s as &str), \"--emit\").next()\n             {\n                 // For `no_run` tests, rustdoc passes a `--emit` flag; make sure it has the right shape.\n                 assert_eq!(val, \"metadata\");"}, {"sha": "04cfd2077bb7226eb044103f38cc1ba7a47d33f3", "filename": "cargo-miri/src/util.rs", "status": "modified", "additions": 2, "deletions": 78, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e7d945629b32b32c34d5df84d881292e6f0451/cargo-miri%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Futil.rs?ref=08e7d945629b32b32c34d5df84d881292e6f0451", "patch": "@@ -4,7 +4,6 @@ use std::ffi::OsString;\n use std::fmt::Write as _;\n use std::fs::{self, File};\n use std::io::{self, BufWriter, Read, Write};\n-use std::iter::TakeWhile;\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n@@ -13,6 +12,8 @@ use cargo_metadata::{Metadata, MetadataCommand};\n use rustc_version::VersionMeta;\n use serde::{Deserialize, Serialize};\n \n+pub use crate::arg::*;\n+\n /// The information to run a crate with the given environment.\n #[derive(Clone, Serialize, Deserialize)]\n pub struct CrateRunEnv {\n@@ -74,83 +75,6 @@ pub fn show_error(msg: String) -> ! {\n     std::process::exit(1)\n }\n \n-/// Determines whether a `--flag` is present.\n-pub fn has_arg_flag(name: &str) -> bool {\n-    num_arg_flag(name) > 0\n-}\n-\n-/// Determines how many times a `--flag` is present.\n-pub fn num_arg_flag(name: &str) -> usize {\n-    env::args().take_while(|val| val != \"--\").filter(|val| val == name).count()\n-}\n-\n-/// Yields all values of command line flag `name` as `Ok(arg)`, and all other arguments except\n-/// the flag as `Err(arg)`. (The flag `name` itself is not yielded at all, only its values are.)\n-pub struct ArgSplitFlagValue<'a, I> {\n-    args: TakeWhile<I, fn(&String) -> bool>,\n-    name: &'a str,\n-}\n-\n-impl<'a, I: Iterator<Item = String>> ArgSplitFlagValue<'a, I> {\n-    pub fn new(args: I, name: &'a str) -> Self {\n-        Self {\n-            // Stop searching at `--`.\n-            args: args.take_while(|val| val != \"--\"),\n-            name,\n-        }\n-    }\n-}\n-\n-impl<I: Iterator<Item = String>> Iterator for ArgSplitFlagValue<'_, I> {\n-    type Item = Result<String, String>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let arg = self.args.next()?;\n-        if let Some(suffix) = arg.strip_prefix(self.name) {\n-            // Strip leading `name`.\n-            if suffix.is_empty() {\n-                // This argument is exactly `name`; the next one is the value.\n-                return self.args.next().map(Ok);\n-            } else if let Some(suffix) = suffix.strip_prefix('=') {\n-                // This argument is `name=value`; get the value.\n-                return Some(Ok(suffix.to_owned()));\n-            }\n-        }\n-        Some(Err(arg))\n-    }\n-}\n-\n-/// Yields all values of command line flag `name`.\n-pub struct ArgFlagValueIter<'a, I>(ArgSplitFlagValue<'a, I>);\n-\n-impl<'a, I: Iterator<Item = String>> ArgFlagValueIter<'a, I> {\n-    pub fn new(args: I, name: &'a str) -> Self {\n-        Self(ArgSplitFlagValue::new(args, name))\n-    }\n-}\n-\n-impl<I: Iterator<Item = String>> Iterator for ArgFlagValueIter<'_, I> {\n-    type Item = String;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        loop {\n-            if let Ok(value) = self.0.next()? {\n-                return Some(value);\n-            }\n-        }\n-    }\n-}\n-\n-/// Gets the values of a `--flag`.\n-pub fn get_arg_flag_values<'a>(name: &'a str) -> impl Iterator<Item = String> + 'a {\n-    ArgFlagValueIter::new(env::args(), name)\n-}\n-\n-/// Gets the value of a `--flag`.\n-pub fn get_arg_flag_value(name: &str) -> Option<String> {\n-    get_arg_flag_values(name).next()\n-}\n-\n /// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n pub fn escape_for_toml(s: &str) -> String {\n     // We want to surround this string in quotes `\"`. So we first escape all quotes,"}]}