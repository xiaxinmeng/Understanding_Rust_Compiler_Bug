{"sha": "9e305a8a23dc6f8e71dadc2670448ed14bf5962d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMzA1YThhMjNkYzZmOGU3MWRhZGMyNjcwNDQ4ZWQxNGJmNTk2MmQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-12T21:48:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:24Z"}, "message": "type_check/mod.rs: rustfmt", "tree": {"sha": "a261b8e35370e56a007afec8724ff793006b4171", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a261b8e35370e56a007afec8724ff793006b4171"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e305a8a23dc6f8e71dadc2670448ed14bf5962d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e305a8a23dc6f8e71dadc2670448ed14bf5962d", "html_url": "https://github.com/rust-lang/rust/commit/9e305a8a23dc6f8e71dadc2670448ed14bf5962d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e305a8a23dc6f8e71dadc2670448ed14bf5962d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f31698c263c6fc3a6e5d0ba07b2ea9b882a5c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f31698c263c6fc3a6e5d0ba07b2ea9b882a5c9c", "html_url": "https://github.com/rust-lang/rust/commit/2f31698c263c6fc3a6e5d0ba07b2ea9b882a5c9c"}], "stats": {"total": 237, "additions": 100, "deletions": 137}, "files": [{"sha": "5ebaec1874aefceac651342ba9dd581f678f7aaa", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 100, "deletions": 137, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/9e305a8a23dc6f8e71dadc2670448ed14bf5962d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e305a8a23dc6f8e71dadc2670448ed14bf5962d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9e305a8a23dc6f8e71dadc2670448ed14bf5962d", "patch": "@@ -17,12 +17,12 @@ use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, Outlives\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n+use borrow_check::nll::renumber;\n use borrow_check::nll::type_check::free_region_relations::{\n     CreateResult, UniversalRegionRelations,\n };\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n-use borrow_check::nll::renumber;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n@@ -35,13 +35,13 @@ use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::*;\n-use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n+use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use rustc::ty::subst::Subst;\n+use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -161,11 +161,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             Some(&mut borrowck_context),\n             Some(&universal_region_relations),\n             |cx| {\n-                cx.equate_inputs_and_outputs(\n-                    mir,\n-                    universal_regions,\n-                    &normalized_inputs_and_output,\n-                );\n+                cx.equate_inputs_and_outputs(mir, universal_regions, &normalized_inputs_and_output);\n                 liveness::generate(cx, mir, elements, flow_inits, move_data);\n             },\n         );\n@@ -377,14 +373,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n \n-        if let Err(terr) = self.cx\n-            .eq_types(\n-                constant.literal.ty,\n-                constant.ty,\n-                location.to_locations(),\n-                ConstraintCategory::Boring,\n-            )\n-        {\n+        if let Err(terr) = self.cx.eq_types(\n+            constant.literal.ty,\n+            constant.ty,\n+            location.to_locations(),\n+            ConstraintCategory::Boring,\n+        ) {\n             span_mirbug!(\n                 self,\n                 constant,\n@@ -429,12 +423,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) = self.cx.eq_types(\n-                    ty,\n-                    sty,\n-                    location.to_locations(),\n-                    ConstraintCategory::Boring,\n-                ) {\n+                if let Err(terr) =\n+                    self.cx\n+                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n+                {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -955,66 +947,55 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let parent_def_id = infcx.tcx.closure_base_def_id(self.mir_def_id);\n-        let opaque_type_map =\n-            self.fully_perform_op(\n-                locations,\n-                category,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        let mut obligations = ObligationAccumulator::default();\n-\n-                        let dummy_body_id = ObligationCause::dummy().body_id;\n-                        let (output_ty, opaque_type_map) =\n-                            obligations.add(infcx.instantiate_opaque_types(\n-                                parent_def_id,\n-                                dummy_body_id,\n-                                param_env,\n-                                &anon_ty,\n-                            ));\n+        let opaque_type_map = self.fully_perform_op(\n+            locations,\n+            category,\n+            CustomTypeOp::new(\n+                |infcx| {\n+                    let mut obligations = ObligationAccumulator::default();\n+\n+                    let dummy_body_id = ObligationCause::dummy().body_id;\n+                    let (output_ty, opaque_type_map) =\n+                        obligations.add(infcx.instantiate_opaque_types(\n+                            parent_def_id,\n+                            dummy_body_id,\n+                            param_env,\n+                            &anon_ty,\n+                        ));\n+                    debug!(\n+                        \"eq_opaque_type_and_type: \\\n+                         instantiated output_ty={:?} \\\n+                         opaque_type_map={:#?} \\\n+                         revealed_ty={:?}\",\n+                        output_ty, opaque_type_map, revealed_ty\n+                    );\n+                    obligations.add(infcx\n+                        .at(&ObligationCause::dummy(), param_env)\n+                        .eq(output_ty, revealed_ty)?);\n+\n+                    for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                        let opaque_defn_ty = tcx.type_of(opaque_def_id);\n+                        let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n+                        let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n                         debug!(\n-                            \"eq_opaque_type_and_type: \\\n-                             instantiated output_ty={:?} \\\n-                             opaque_type_map={:#?} \\\n-                             revealed_ty={:?}\",\n-                            output_ty,\n-                            opaque_type_map,\n-                            revealed_ty\n-                        );\n-                        obligations.add(\n-                            infcx\n-                                .at(&ObligationCause::dummy(), param_env)\n-                                .eq(output_ty, revealed_ty)?,\n+                            \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n+                            opaque_decl.concrete_ty, opaque_defn_ty\n                         );\n+                        obligations.add(infcx\n+                            .at(&ObligationCause::dummy(), param_env)\n+                            .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+                    }\n \n-                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n-                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n-                            let opaque_defn_ty = renumber::renumber_regions(\n-                                infcx,\n-                                &opaque_defn_ty,\n-                            );\n-                            debug!(\n-                                \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n-                                opaque_decl.concrete_ty,\n-                                opaque_defn_ty\n-                            );\n-                            obligations.add(\n-                                infcx\n-                                    .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n-                            );\n-                        }\n-\n-                        debug!(\"eq_opaque_type_and_type: equated\");\n+                    debug!(\"eq_opaque_type_and_type: equated\");\n \n-                        Ok(InferOk {\n-                            value: Some(opaque_type_map),\n-                            obligations: obligations.into_vec(),\n-                        })\n-                    },\n-                    || \"input_output\".to_string(),\n-                ),\n-            )?;\n+                    Ok(InferOk {\n+                        value: Some(opaque_type_map),\n+                        obligations: obligations.into_vec(),\n+                    })\n+                },\n+                || \"input_output\".to_string(),\n+            ),\n+        )?;\n \n         let universal_region_relations = match self.universal_region_relations {\n             Some(rel) => rel,\n@@ -1035,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             infcx.constrain_opaque_type(\n                                 opaque_def_id,\n                                 &opaque_decl,\n-                                universal_region_relations\n+                                universal_region_relations,\n                             );\n                             Ok(InferOk {\n                                 value: (),\n@@ -1073,12 +1054,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types_or_anon(\n-                    rv_ty,\n-                    place_ty,\n-                    location.to_locations(),\n-                    category,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n+                {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -1117,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.prove_trait_ref(\n                         trait_ref,\n                         location.to_locations(),\n-                    ConstraintCategory::SizedBound,\n+                        ConstraintCategory::SizedBound,\n                     );\n                 }\n             }\n@@ -1148,15 +1126,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::AscribeUserType(ref place, variance, c_ty) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) =\n-                    self.relate_type_and_user_type(\n-                        place_ty,\n-                        variance,\n-                        c_ty,\n-                        Locations::All(stmt.source_info.span),\n-                        ConstraintCategory::TypeAnnotation,\n-                    )\n-                {\n+                if let Err(terr) = self.relate_type_and_user_type(\n+                    place_ty,\n+                    variance,\n+                    c_ty,\n+                    Locations::All(stmt.source_info.span),\n+                    ConstraintCategory::TypeAnnotation,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -1208,12 +1184,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let rv_ty = value.ty(mir, tcx);\n \n                 let locations = term_location.to_locations();\n-                if let Err(terr) = self.sub_types(\n-                    rv_ty,\n-                    place_ty,\n-                    locations,\n-                    ConstraintCategory::Assignment,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n+                {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1327,8 +1300,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ty,\n                             term_location.to_locations(),\n                             ConstraintCategory::Return,\n-                        )\n-                        {\n+                        ) {\n                             span_mirbug!(\n                                 self,\n                                 term,\n@@ -1366,12 +1338,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let locations = term_location.to_locations();\n \n-                if let Err(terr) = self.sub_types_or_anon(\n-                    sig.output(),\n-                    dest_ty,\n-                    locations,\n-                    category,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types_or_anon(sig.output(), dest_ty, locations, category)\n+                {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1539,12 +1508,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(\n-        &mut self,\n-        mir: &Mir<'tcx>,\n-        local: Local,\n-        local_decl: &LocalDecl<'tcx>,\n-    ) {\n+    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1713,13 +1677,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -1739,13 +1703,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -1768,13 +1732,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -2277,4 +2241,3 @@ impl<'tcx> ObligationAccumulator<'tcx> {\n         self.obligations\n     }\n }\n-"}]}