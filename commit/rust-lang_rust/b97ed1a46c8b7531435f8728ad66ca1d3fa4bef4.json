{"sha": "b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5N2VkMWE0NmM4Yjc1MzE0MzVmODcyOGFkNjZjYTFkM2ZhNGJlZjQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-24T07:38:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-24T07:38:29Z"}, "message": "Miri casts: do not blindly rely on dest type", "tree": {"sha": "fdabd10eb9eca49af2b87d70ddce68c72f14ab0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdabd10eb9eca49af2b87d70ddce68c72f14ab0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4", "html_url": "https://github.com/rust-lang/rust/commit/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbc6f2c70cf3d3cc3722cbd194e600d560d40758", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc6f2c70cf3d3cc3722cbd194e600d560d40758", "html_url": "https://github.com/rust-lang/rust/commit/fbc6f2c70cf3d3cc3722cbd194e600d560d40758"}], "stats": {"total": 127, "additions": 76, "deletions": 51}, "files": [{"sha": "18483c70951b4b8f415878d8b5d6bf149e80cdfd", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 73, "deletions": 49, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4", "patch": "@@ -1,6 +1,5 @@\n use std::convert::TryFrom;\n \n-use super::{FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::{Float, FloatConvert};\n use rustc_ast::ast::FloatTy;\n@@ -12,25 +11,40 @@ use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::sym;\n use rustc_target::abi::{LayoutOf, Size, Variants};\n \n+use super::{truncate, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy};\n+\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n-        kind: CastKind,\n+        cast_kind: CastKind,\n+        cast_ty: Ty<'tcx>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::CastKind::*;\n-        match kind {\n+        // FIXME: In which cases should we trigger UB when the source is uninit?\n+        match cast_kind {\n             Pointer(PointerCast::Unsize) => {\n+                assert_eq!(\n+                    cast_ty, dest.layout.ty,\n+                    \"mismatch of cast type {} and place type {}\",\n+                    cast_ty, dest.layout.ty\n+                );\n                 self.unsize_into(src, dest)?;\n             }\n \n-            Misc | Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer) => {\n+            Misc => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.cast_immediate(src, dest.layout)?;\n+                let res = self.misc_cast(src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n+            Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer) => {\n+                // These are NOPs, but can be wide pointers.\n+                let v = self.read_immediate(src)?;\n+                self.write_immediate(*v, dest)?;\n+            }\n+\n             Pointer(PointerCast::ReifyFnPointer) => {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.kind {\n@@ -61,12 +75,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::UnsafeFnPointer) => {\n                 let src = self.read_immediate(src)?;\n-                match dest.layout.ty.kind {\n+                match cast_ty.kind {\n                     ty::FnPtr(_) => {\n                         // No change to value\n                         self.write_immediate(*src, dest)?;\n                     }\n-                    _ => bug!(\"fn to unsafe fn cast on {:?}\", dest.layout.ty),\n+                    _ => bug!(\"fn to unsafe fn cast on {:?}\", cast_ty),\n                 }\n             }\n \n@@ -95,21 +109,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn cast_immediate(\n+    fn misc_cast(\n         &self,\n         src: ImmTy<'tcx, M::PointerTag>,\n-        dest_layout: TyAndLayout<'tcx>,\n+        cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n         use rustc_middle::ty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, dest_layout.ty);\n+        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind {\n             // Floating point\n             Float(FloatTy::F32) => {\n-                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty).into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, cast_ty).into());\n             }\n             Float(FloatTy::F64) => {\n-                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, dest_layout.ty).into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, cast_ty).into());\n             }\n             // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n             // are represented as integers.\n@@ -124,69 +138,79 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ),\n         }\n \n+        // # First handle non-scalar source values.\n+\n         // Handle cast from a univariant (ZST) enum.\n         match src.layout.variants {\n             Variants::Single { index } => {\n                 if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;\n-                    return Ok(self\n-                        .cast_from_int_like(discr.val, discr_layout, dest_layout)\n-                        .into());\n+                    return Ok(self.cast_from_scalar(discr.val, discr_layout, cast_ty).into());\n                 }\n             }\n             Variants::Multiple { .. } => {}\n         }\n \n-        // Handle casting the metadata away from a fat pointer.\n-        if src.layout.ty.is_unsafe_ptr()\n-            && dest_layout.ty.is_unsafe_ptr()\n-            && dest_layout.size != src.layout.size\n-        {\n-            assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n-            assert_eq!(dest_layout.size, self.memory.pointer_size());\n-            assert!(dest_layout.ty.is_unsafe_ptr());\n-            match *src {\n-                Immediate::ScalarPair(data, _) => return Ok(data.into()),\n-                Immediate::Scalar(..) => bug!(\n-                    \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n-                    *src,\n-                    src.layout.ty,\n-                    dest_layout.ty\n-                ),\n-            };\n-        }\n-\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n-        if src.layout.ty.is_any_ptr() && dest_layout.ty.is_unsafe_ptr() {\n-            // The only possible size-unequal case was handled above.\n-            assert_eq!(src.layout.size, dest_layout.size);\n-            return Ok(*src);\n+        if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n+            let dest_layout = self.layout_of(cast_ty)?;\n+            if dest_layout.size == src.layout.size {\n+                // Thin or fat pointer that just hast the ptr kind of target type changed.\n+                return Ok(*src);\n+            } else {\n+                // Casting the metadata away from a fat ptr.\n+                assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n+                assert_eq!(dest_layout.size, self.memory.pointer_size());\n+                assert!(src.layout.ty.is_unsafe_ptr());\n+                return match *src {\n+                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                    Immediate::Scalar(..) => bug!(\n+                        \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n+                        *src,\n+                        src.layout.ty,\n+                        cast_ty\n+                    ),\n+                };\n+            }\n         }\n \n+        // # The remaining source values are scalar.\n+\n         // For all remaining casts, we either\n         // (a) cast a raw ptr to usize, or\n         // (b) cast from an integer-like (including bool, char, enums).\n         // In both cases we want the bits.\n         let bits = self.force_bits(src.to_scalar()?, src.layout.size)?;\n-        Ok(self.cast_from_int_like(bits, src.layout, dest_layout).into())\n+        Ok(self.cast_from_scalar(bits, src.layout, cast_ty).into())\n     }\n \n-    pub(super) fn cast_from_int_like(\n+    pub(super) fn cast_from_scalar(\n         &self,\n-        v: u128, // raw bits\n+        v: u128, // raw bits (there is no ScalarTy so we separate data+layout)\n         src_layout: TyAndLayout<'tcx>,\n-        dest_layout: TyAndLayout<'tcx>,\n+        cast_ty: Ty<'tcx>,\n     ) -> Scalar<M::PointerTag> {\n         // Let's make sure v is sign-extended *if* it has a signed type.\n-        let signed = src_layout.abi.is_signed();\n+        let signed = src_layout.abi.is_signed(); // also checks that abi is `Scalar`.\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n-        trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n+        trace!(\"cast_from_scalar: {}, {} -> {}\", v, src_layout.ty, cast_ty);\n         use rustc_middle::ty::TyKind::*;\n-        match dest_layout.ty.kind {\n+        match cast_ty.kind {\n             Int(_) | Uint(_) | RawPtr(_) => {\n-                let v = self.truncate(v, dest_layout);\n-                Scalar::from_uint(v, dest_layout.size)\n+                let size = match cast_ty.kind {\n+                    // FIXME: Isn't there a helper for this? The same pattern occurs below.\n+                    Int(t) => {\n+                        t.bit_width().map(Size::from_bits).unwrap_or_else(|| self.pointer_size())\n+                    }\n+                    Uint(t) => {\n+                        t.bit_width().map(Size::from_bits).unwrap_or_else(|| self.pointer_size())\n+                    }\n+                    RawPtr(_) => self.pointer_size(),\n+                    _ => bug!(),\n+                };\n+                let v = truncate(v, size);\n+                Scalar::from_uint(v, size)\n             }\n \n             Float(FloatTy::F32) if signed => Scalar::from_f32(Single::from_i128(v as i128).value),\n@@ -200,7 +224,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => bug!(\"invalid int to {:?} cast\", dest_layout.ty),\n+            _ => bug!(\"invalid int to {:?} cast\", cast_ty),\n         }\n     }\n \n@@ -283,7 +307,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"Unsizing {:?} into {:?}\", src, dest);\n+        trace!(\"Unsizing {:?} of type {} into {:?}\", *src, src.layout.ty, dest.layout.ty);\n         match (&src.layout.ty.kind, &dest.layout.ty.kind) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, d, _) | &ty::RawPtr(TypeAndMut { ty: d, .. }))\n             | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: d, .. })) => {"}, {"sha": "fd9815975c19f613efa5beca7d398a5149840404", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b97ed1a46c8b7531435f8728ad66ca1d3fa4bef4", "patch": "@@ -253,9 +253,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), dest)?;\n             }\n \n-            Cast(kind, ref operand, _) => {\n+            Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n-                self.cast(src, kind, dest)?;\n+                let cast_ty = self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty);\n+                self.cast(src, cast_kind, cast_ty, dest)?;\n             }\n \n             Discriminant(place) => {"}]}