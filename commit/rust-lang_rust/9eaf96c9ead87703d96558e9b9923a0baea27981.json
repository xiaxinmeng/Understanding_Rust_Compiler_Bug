{"sha": "9eaf96c9ead87703d96558e9b9923a0baea27981", "node_id": "C_kwDOAAsO6NoAKDllYWY5NmM5ZWFkODc3MDNkOTY1NThlOWI5OTIzYTBiYWVhMjc5ODE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-27T12:40:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-27T12:40:46Z"}, "message": "Auto merge of #12643 - Veykril:macro-compl, r=Veykril\n\nfix: Fix completions for locals not working properly inside macro calls", "tree": {"sha": "59170a0761b9392c0ebbeae2a2f7105f4af1b0b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59170a0761b9392c0ebbeae2a2f7105f4af1b0b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eaf96c9ead87703d96558e9b9923a0baea27981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eaf96c9ead87703d96558e9b9923a0baea27981", "html_url": "https://github.com/rust-lang/rust/commit/9eaf96c9ead87703d96558e9b9923a0baea27981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eaf96c9ead87703d96558e9b9923a0baea27981/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c3954682df28b8caa2b1ff954347230c8e7982a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c3954682df28b8caa2b1ff954347230c8e7982a", "html_url": "https://github.com/rust-lang/rust/commit/4c3954682df28b8caa2b1ff954347230c8e7982a"}, {"sha": "bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "html_url": "https://github.com/rust-lang/rust/commit/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0"}], "stats": {"total": 64, "additions": 45, "deletions": 19}, "files": [{"sha": "9bdde5e6e0f1c7329942e221da970964b80961e2", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9eaf96c9ead87703d96558e9b9923a0baea27981/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eaf96c9ead87703d96558e9b9923a0baea27981/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=9eaf96c9ead87703d96558e9b9923a0baea27981", "patch": "@@ -67,10 +67,7 @@ impl SourceAnalyzer {\n         let scopes = db.expr_scopes(def);\n         let scope = match offset {\n             None => scope_for(&scopes, &source_map, node),\n-            Some(offset) => {\n-                let file_id = node.file_id.original_file(db.upcast());\n-                scope_for_offset(db, &scopes, &source_map, InFile::new(file_id.into(), offset))\n-            }\n+            Some(offset) => scope_for_offset(db, &scopes, &source_map, node.file_id, offset),\n         };\n         let resolver = resolver_for_scope(db.upcast(), def, scope);\n         SourceAnalyzer {\n@@ -91,10 +88,7 @@ impl SourceAnalyzer {\n         let scopes = db.expr_scopes(def);\n         let scope = match offset {\n             None => scope_for(&scopes, &source_map, node),\n-            Some(offset) => {\n-                let file_id = node.file_id.original_file(db.upcast());\n-                scope_for_offset(db, &scopes, &source_map, InFile::new(file_id.into(), offset))\n-            }\n+            Some(offset) => scope_for_offset(db, &scopes, &source_map, node.file_id, offset),\n         };\n         let resolver = resolver_for_scope(db.upcast(), def, scope);\n         SourceAnalyzer { resolver, def: Some((def, body, source_map)), infer: None, file_id }\n@@ -585,14 +579,15 @@ fn scope_for_offset(\n     db: &dyn HirDatabase,\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n-    offset: InFile<TextSize>,\n+    from_file: HirFileId,\n+    offset: TextSize,\n ) -> Option<ScopeId> {\n     scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n             let InFile { file_id, value } = source_map.expr_syntax(*id).ok()?;\n-            if offset.file_id == file_id {\n+            if from_file == file_id {\n                 let root = db.parse_or_expand(file_id)?;\n                 let node = value.to_node(&root);\n                 return Some((node.syntax().text_range(), scope));\n@@ -602,17 +597,15 @@ fn scope_for_offset(\n             let source = iter::successors(file_id.call_node(db.upcast()), |it| {\n                 it.file_id.call_node(db.upcast())\n             })\n-            .find(|it| it.file_id == offset.file_id)\n+            .find(|it| it.file_id == from_file)\n             .filter(|it| it.value.kind() == SyntaxKind::MACRO_CALL)?;\n             Some((source.value.text_range(), scope))\n         })\n-        .filter(|(expr_range, _scope)| {\n-            expr_range.start() <= offset.value && offset.value <= expr_range.end()\n-        })\n+        .filter(|(expr_range, _scope)| expr_range.start() <= offset && offset <= expr_range.end())\n         // find containing scope\n         .min_by_key(|(expr_range, _scope)| expr_range.len())\n         .map(|(expr_range, scope)| {\n-            adjust(db, scopes, source_map, expr_range, offset).unwrap_or(*scope)\n+            adjust(db, scopes, source_map, expr_range, from_file, offset).unwrap_or(*scope)\n         })\n }\n \n@@ -623,23 +616,24 @@ fn adjust(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n     expr_range: TextRange,\n-    offset: InFile<TextSize>,\n+    from_file: HirFileId,\n+    offset: TextSize,\n ) -> Option<ScopeId> {\n     let child_scopes = scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n             let source = source_map.expr_syntax(*id).ok()?;\n             // FIXME: correctly handle macro expansion\n-            if source.file_id != offset.file_id {\n+            if source.file_id != from_file {\n                 return None;\n             }\n             let root = source.file_syntax(db.upcast());\n             let node = source.value.to_node(&root);\n             Some((node.syntax().text_range(), scope))\n         })\n         .filter(|&(range, _)| {\n-            range.start() <= offset.value && expr_range.contains_range(range) && range != expr_range\n+            range.start() <= offset && expr_range.contains_range(range) && range != expr_range\n         });\n \n     child_scopes"}, {"sha": "b371c978808fd99fdb62d097fa8369332f344a45", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eaf96c9ead87703d96558e9b9923a0baea27981/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eaf96c9ead87703d96558e9b9923a0baea27981/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=9eaf96c9ead87703d96558e9b9923a0baea27981", "patch": "@@ -506,7 +506,11 @@ impl<'a> CompletionContext<'a> {\n \n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n         let token = sema.descend_into_macros_single(original_token.clone());\n-        let scope = sema.scope_at_offset(&token.parent()?, offset)?;\n+\n+        // adjust for macro input, this still fails if there is no token written yet\n+        let scope_offset = if original_token == token { offset } else { token.text_range().end() };\n+        let scope = sema.scope_at_offset(&token.parent()?, scope_offset)?;\n+\n         let krate = scope.krate();\n         let module = scope.module();\n "}, {"sha": "39cb41485b1cfa5273801c0765d609434829e3c6", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9eaf96c9ead87703d96558e9b9923a0baea27981/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eaf96c9ead87703d96558e9b9923a0baea27981/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=9eaf96c9ead87703d96558e9b9923a0baea27981", "patch": "@@ -782,3 +782,31 @@ fn main() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn completes_locals_from_macros() {\n+    check(\n+        r#\"\n+\n+macro_rules! x {\n+    ($x:ident, $expr:expr) => {\n+        let $x = 0;\n+        $expr\n+    };\n+}\n+fn main() {\n+    x! {\n+        foobar, {\n+            f$0\n+        }\n+    };\n+}\n+\"#,\n+        expect![[r#\"\n+            fn main() fn()\n+            lc foobar i32\n+            ma x!(\u2026)  macro_rules! x\n+            bt u32\n+        \"#]],\n+    )\n+}"}]}