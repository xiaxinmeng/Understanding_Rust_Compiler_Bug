{"sha": "ed4f13e5c796120cc0c051825116a29374b6745b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNGYxM2U1Yzc5NjEyMGNjMGMwNTE4MjUxMTZhMjkzNzRiNjc0NWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T15:38:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T15:38:34Z"}, "message": "remove FnSignatureInfo from hir", "tree": {"sha": "db8873da2a5f2d5a0daefd347ed0b28c575c8343", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db8873da2a5f2d5a0daefd347ed0b28c575c8343"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed4f13e5c796120cc0c051825116a29374b6745b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed4f13e5c796120cc0c051825116a29374b6745b", "html_url": "https://github.com/rust-lang/rust/commit/ed4f13e5c796120cc0c051825116a29374b6745b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed4f13e5c796120cc0c051825116a29374b6745b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f74702d94b393d2f37bcda0fdfd6213fad460b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f74702d94b393d2f37bcda0fdfd6213fad460b", "html_url": "https://github.com/rust-lang/rust/commit/a3f74702d94b393d2f37bcda0fdfd6213fad460b"}], "stats": {"total": 252, "additions": 115, "deletions": 137}, "files": [{"sha": "911ac39553c90321a46f29b3a3a334a604cdd7eb", "filename": "crates/ra_analysis/src/call_info.rs", "status": "modified", "additions": 112, "deletions": 10, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs?ref=ed4f13e5c796120cc0c051825116a29374b6745b", "patch": "@@ -1,16 +1,17 @@\n+use std::cmp::{max, min};\n+\n use ra_db::{SyntaxDatabase, Cancelable};\n use ra_syntax::{\n     AstNode, SyntaxNode, TextUnit, TextRange,\n     SyntaxKind::FN_DEF,\n-    ast::{self, ArgListOwner},\n+    ast::{self, ArgListOwner, DocCommentsOwner},\n };\n use ra_editor::find_node_at_offset;\n-use hir::FnSignatureInfo;\n \n use crate::{FilePosition, CallInfo, db::RootDatabase};\n \n pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n-    let (sig_info, active_parameter) = ctry!(call_info_(db, position)?);\n+    let (sig_info, active_parameter) = ctry!(signature_and_active_param(db, position)?);\n     let res = CallInfo {\n         label: sig_info.label,\n         doc: sig_info.doc,\n@@ -21,7 +22,7 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable\n }\n \n /// Computes parameter information for the given call expression.\n-fn call_info_(\n+fn signature_and_active_param(\n     db: &RootDatabase,\n     position: FilePosition,\n ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n@@ -39,12 +40,7 @@ fn call_info_(\n             let fn_file = db.source_file(symbol.file_id);\n             let fn_def = symbol.ptr.resolve(&fn_file);\n             let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n-            let descr = ctry!(hir::source_binder::function_from_source(\n-                db,\n-                symbol.file_id,\n-                fn_def\n-            )?);\n-            if let Some(descriptor) = descr.signature_info(db) {\n+            if let Some(descriptor) = FnSignatureInfo::new(fn_def) {\n                 // If we have a calling expression let's find which argument we are on\n                 let mut current_parameter = None;\n \n@@ -129,6 +125,112 @@ impl<'a> FnCallNode<'a> {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+struct FnSignatureInfo {\n+    label: String,\n+    params: Vec<String>,\n+    doc: Option<String>,\n+}\n+\n+impl FnSignatureInfo {\n+    fn new(node: &ast::FnDef) -> Option<Self> {\n+        let mut doc = None;\n+\n+        // Strip the body out for the label.\n+        let mut label: String = if let Some(body) = node.body() {\n+            let body_range = body.syntax().range();\n+            let label: String = node\n+                .syntax()\n+                .children()\n+                .filter(|child| !child.range().is_subrange(&body_range))\n+                .map(|node| node.text().to_string())\n+                .collect();\n+            label\n+        } else {\n+            node.syntax().text().to_string()\n+        };\n+\n+        if let Some((comment_range, docs)) = FnSignatureInfo::extract_doc_comments(node) {\n+            let comment_range = comment_range\n+                .checked_sub(node.syntax().range().start())\n+                .unwrap();\n+            let start = comment_range.start().to_usize();\n+            let end = comment_range.end().to_usize();\n+\n+            // Remove the comment from the label\n+            label.replace_range(start..end, \"\");\n+\n+            // Massage markdown\n+            let mut processed_lines = Vec::new();\n+            let mut in_code_block = false;\n+            for line in docs.lines() {\n+                if line.starts_with(\"```\") {\n+                    in_code_block = !in_code_block;\n+                }\n+\n+                let line = if in_code_block && line.starts_with(\"```\") && !line.contains(\"rust\") {\n+                    \"```rust\".into()\n+                } else {\n+                    line.to_string()\n+                };\n+\n+                processed_lines.push(line);\n+            }\n+\n+            if !processed_lines.is_empty() {\n+                doc = Some(processed_lines.join(\"\\n\"));\n+            }\n+        }\n+\n+        let params = FnSignatureInfo::param_list(node);\n+\n+        Some(FnSignatureInfo {\n+            params,\n+            label: label.trim().to_owned(),\n+            doc,\n+        })\n+    }\n+\n+    fn extract_doc_comments(node: &ast::FnDef) -> Option<(TextRange, String)> {\n+        if node.doc_comments().count() == 0 {\n+            return None;\n+        }\n+\n+        let comment_text = node.doc_comment_text();\n+\n+        let (begin, end) = node\n+            .doc_comments()\n+            .map(|comment| comment.syntax().range())\n+            .map(|range| (range.start().to_usize(), range.end().to_usize()))\n+            .fold((std::usize::MAX, std::usize::MIN), |acc, range| {\n+                (min(acc.0, range.0), max(acc.1, range.1))\n+            });\n+\n+        let range = TextRange::from_to(TextUnit::from_usize(begin), TextUnit::from_usize(end));\n+\n+        Some((range, comment_text))\n+    }\n+\n+    fn param_list(node: &ast::FnDef) -> Vec<String> {\n+        let mut res = vec![];\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                res.push(self_param.syntax().text().to_string())\n+            }\n+\n+            // Maybe use param.pat here? See if we can just extract the name?\n+            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n+            res.extend(\n+                param_list\n+                    .params()\n+                    .filter_map(|p| p.pat())\n+                    .map(|pat| pat.syntax().text().to_string()),\n+            );\n+        }\n+        res\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "771a349c8c6e6cf390074c41bf2fedb46b2bc06e", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=ed4f13e5c796120cc0c051825116a29374b6745b", "patch": "@@ -40,7 +40,6 @@ pub use crate::{\n     completion::{CompletionItem, CompletionItemKind, InsertText},\n     runnables::{Runnable, RunnableKind},\n };\n-pub use hir::FnSignatureInfo;\n pub use ra_editor::{Fold, FoldKind, HighlightedRange, LineIndex, Severity, StructureNode};\n \n pub use ra_db::{"}, {"sha": "2cfc4caa42f6e1011fc8c0c8d70dec19b3e70b3b", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 3, "deletions": 124, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=ed4f13e5c796120cc0c051825116a29374b6745b", "patch": "@@ -1,14 +1,11 @@\n mod scope;\n \n-use std::{\n-    cmp::{max, min},\n-    sync::Arc,\n-};\n+use std::sync::Arc;\n \n use ra_db::Cancelable;\n use ra_syntax::{\n-    TextRange, TextUnit, TreePtr,\n-    ast::{self, AstNode, DocCommentsOwner, NameOwner},\n+    TreePtr,\n+    ast::{self, AstNode},\n };\n \n use crate::{DefId, DefKind, HirDatabase, ty::InferenceResult, Module, Crate, impl_block::ImplBlock, expr::{Body, BodySyntaxMapping}, type_ref::{TypeRef, Mutability}, Name};\n@@ -57,11 +54,6 @@ impl Function {\n         db.fn_signature(self.def_id)\n     }\n \n-    pub fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n-        let syntax = self.syntax(db);\n-        FnSignatureInfo::new(&syntax)\n-    }\n-\n     pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n         db.infer(self.def_id)\n     }\n@@ -132,116 +124,3 @@ pub(crate) fn fn_signature(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignat\n     let sig = FnSignature { args, ret_type };\n     Arc::new(sig)\n }\n-\n-#[derive(Debug, Clone)]\n-pub struct FnSignatureInfo {\n-    pub name: String,\n-    pub label: String,\n-    pub ret_type: Option<String>,\n-    pub params: Vec<String>,\n-    pub doc: Option<String>,\n-}\n-\n-impl FnSignatureInfo {\n-    fn new(node: &ast::FnDef) -> Option<Self> {\n-        let name = node.name()?.text().to_string();\n-\n-        let mut doc = None;\n-\n-        // Strip the body out for the label.\n-        let mut label: String = if let Some(body) = node.body() {\n-            let body_range = body.syntax().range();\n-            let label: String = node\n-                .syntax()\n-                .children()\n-                .filter(|child| !child.range().is_subrange(&body_range))\n-                .map(|node| node.text().to_string())\n-                .collect();\n-            label\n-        } else {\n-            node.syntax().text().to_string()\n-        };\n-\n-        if let Some((comment_range, docs)) = FnSignatureInfo::extract_doc_comments(node) {\n-            let comment_range = comment_range\n-                .checked_sub(node.syntax().range().start())\n-                .unwrap();\n-            let start = comment_range.start().to_usize();\n-            let end = comment_range.end().to_usize();\n-\n-            // Remove the comment from the label\n-            label.replace_range(start..end, \"\");\n-\n-            // Massage markdown\n-            let mut processed_lines = Vec::new();\n-            let mut in_code_block = false;\n-            for line in docs.lines() {\n-                if line.starts_with(\"```\") {\n-                    in_code_block = !in_code_block;\n-                }\n-\n-                let line = if in_code_block && line.starts_with(\"```\") && !line.contains(\"rust\") {\n-                    \"```rust\".into()\n-                } else {\n-                    line.to_string()\n-                };\n-\n-                processed_lines.push(line);\n-            }\n-\n-            if !processed_lines.is_empty() {\n-                doc = Some(processed_lines.join(\"\\n\"));\n-            }\n-        }\n-\n-        let params = FnSignatureInfo::param_list(node);\n-        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n-\n-        Some(FnSignatureInfo {\n-            name,\n-            ret_type,\n-            params,\n-            label: label.trim().to_owned(),\n-            doc,\n-        })\n-    }\n-\n-    fn extract_doc_comments(node: &ast::FnDef) -> Option<(TextRange, String)> {\n-        if node.doc_comments().count() == 0 {\n-            return None;\n-        }\n-\n-        let comment_text = node.doc_comment_text();\n-\n-        let (begin, end) = node\n-            .doc_comments()\n-            .map(|comment| comment.syntax().range())\n-            .map(|range| (range.start().to_usize(), range.end().to_usize()))\n-            .fold((std::usize::MAX, std::usize::MIN), |acc, range| {\n-                (min(acc.0, range.0), max(acc.1, range.1))\n-            });\n-\n-        let range = TextRange::from_to(TextUnit::from_usize(begin), TextUnit::from_usize(end));\n-\n-        Some((range, comment_text))\n-    }\n-\n-    fn param_list(node: &ast::FnDef) -> Vec<String> {\n-        let mut res = vec![];\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                res.push(self_param.syntax().text().to_string())\n-            }\n-\n-            // Maybe use param.pat here? See if we can just extract the name?\n-            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n-            res.extend(\n-                param_list\n-                    .params()\n-                    .filter_map(|p| p.pat())\n-                    .map(|pat| pat.syntax().text().to_string()),\n-            );\n-        }\n-        res\n-    }\n-}"}, {"sha": "197d8c4fd61760d8408b8dc69b5229bd03ce5d49", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4f13e5c796120cc0c051825116a29374b6745b/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=ed4f13e5c796120cc0c051825116a29374b6745b", "patch": "@@ -53,8 +53,6 @@ pub use self::{\n     impl_block::{ImplBlock, ImplItem},\n };\n \n-pub use self::function::FnSignatureInfo;\n-\n pub use self::code_model_api::{\n     Crate, CrateDependency,\n     Module, ModuleSource, Problem,"}]}