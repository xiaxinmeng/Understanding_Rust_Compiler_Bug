{"sha": "11dbb69bd14f52940d54981b883814d52153dc57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZGJiNjliZDE0ZjUyOTQwZDU0OTgxYjg4MzgxNGQ1MjE1M2RjNTc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-20T23:08:09Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-26T16:21:17Z"}, "message": "remove csearch from the rest of rustc", "tree": {"sha": "b33dde623fa2a4ea890a46878c0fef4c7b489d09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b33dde623fa2a4ea890a46878c0fef4c7b489d09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11dbb69bd14f52940d54981b883814d52153dc57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11dbb69bd14f52940d54981b883814d52153dc57", "html_url": "https://github.com/rust-lang/rust/commit/11dbb69bd14f52940d54981b883814d52153dc57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11dbb69bd14f52940d54981b883814d52153dc57/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5fbefa3af48ed44b002a7423d6cbd74e4018c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5fbefa3af48ed44b002a7423d6cbd74e4018c9c", "html_url": "https://github.com/rust-lang/rust/commit/f5fbefa3af48ed44b002a7423d6cbd74e4018c9c"}], "stats": {"total": 364, "additions": 242, "deletions": 122}, "files": [{"sha": "39c9ac32801c0f3e57458c26c493df2d4165445d", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -242,7 +242,7 @@ impl<'a> CrateReader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n+            let source = self.sess.cstore.do_get_used_crate_source(cnum).unwrap();\n             if let Some(locs) = self.sess.opts.externs.get(name) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();\n@@ -414,7 +414,7 @@ impl<'a> CrateReader<'a> {\n                 if explicitly_linked && !data.explicitly_linked.get() {\n                     data.explicitly_linked.set(explicitly_linked);\n                 }\n-                (cnum, data, self.sess.cstore.get_used_crate_source(cnum).unwrap())\n+                (cnum, data, self.sess.cstore.do_get_used_crate_source(cnum).unwrap())\n             }\n             LookupResult::Loaded(library) => {\n                 self.register_crate(root, ident, name, span, library,"}, {"sha": "6cfec87e7049e2d37f89d1309df342ada68ea5c3", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -159,7 +159,7 @@ impl CStore {\n         I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n-            let origin = self.get_used_crate_source(k);\n+            let origin = self.do_get_used_crate_source(k);\n             origin.as_ref().map(|cs| { assert!(k == cs.cnum); });\n             i(k, &**v, origin);\n         }\n@@ -172,8 +172,9 @@ impl CStore {\n         }\n     }\n \n-    pub fn get_used_crate_source(&self, cnum: ast::CrateNum)\n-                                     -> Option<CrateSource> {\n+    // TODO: killdo\n+    pub fn do_get_used_crate_source(&self, cnum: ast::CrateNum)\n+                                    -> Option<CrateSource> {\n         self.used_crate_sources.borrow_mut()\n             .iter().find(|source| source.cnum == cnum).cloned()\n     }\n@@ -196,8 +197,9 @@ impl CStore {\n     // In order to get this left-to-right dependency ordering, we perform a\n     // topological sort of all crates putting the leaves at the right-most\n     // positions.\n-    pub fn get_used_crates(&self, prefer: LinkagePreference)\n-                           -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n+    // TODO: killdo\n+    pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n+                              -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n         fn visit(cstore: &CStore, cnum: ast::CrateNum,\n                  ordering: &mut Vec<ast::CrateNum>) {"}, {"sha": "23ae8df0e97b9da4ee403c721c68a61906504aa1", "filename": "src/librustc/metadata/util.rs", "status": "modified", "additions": 143, "deletions": 6, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmetadata%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmetadata%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Futil.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -11,24 +11,36 @@\n use front::map as ast_map;\n use metadata::cstore;\n use metadata::decoder;\n+use metadata::encoder;\n+use metadata::loader;\n use middle::astencode;\n+use middle::def;\n use middle::lang_items;\n-use middle::ty;\n+use middle::ty::{self, Ty};\n use middle::def_id::{DefId, DefIndex};\n+use util::nodemap::{NodeMap, NodeSet};\n \n use std::any::Any;\n+use std::cell::RefCell;\n use std::rc::Rc;\n+use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n+use rustc_back::target::Target;\n use rustc_front::hir;\n \n+pub use metadata::common::LinkMeta;\n+pub use metadata::creader::validate_crate_name;\n pub use metadata::csearch::FoundAst;\n+pub use metadata::cstore::CrateSource;\n pub use metadata::cstore::LinkagePreference;\n+pub use metadata::cstore::NativeLibraryKind;\n pub use metadata::decoder::DecodeInlinedItem;\n pub use metadata::decoder::DefLike;\n pub use metadata::inline::InlinedItem;\n \n pub use self::DefLike::{DlDef, DlField, DlImpl};\n+pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n pub struct ChildItem {\n     pub def: DefLike,\n@@ -54,6 +66,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn item_super_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                              -> ty::GenericPredicates<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n+    fn item_symbol(&self, def: DefId) -> String;\n     fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n@@ -86,14 +99,21 @@ pub trait CrateStore<'tcx> : Any {\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_impl(&self, did: DefId) -> bool;\n     fn is_static_method(&self, did: DefId) -> bool;\n+    fn is_extern_fn(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool;\n+    fn is_static(&self, did: DefId) -> bool;\n \n-    // metadata\n+    // crate metadata\n     fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n                                     -> Vec<(ast::CrateNum, LinkagePreference)>;\n     fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>;\n     fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>;\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n+    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n+    fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n+    fn crate_name(&self, cnum: ast::CrateNum) -> String;\n     fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n+    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n+    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n \n     // resolve\n     fn def_path(&self, def: DefId) -> ast_map::DefPath;\n@@ -102,9 +122,24 @@ pub trait CrateStore<'tcx> : Any {\n     fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n     fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n \n-    // misc.\n+    // misc. metadata\n     fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                           -> FoundAst<'tcx>;\n+\n+    // utility functions\n+    fn metadata_filename(&self) -> &str;\n+    fn metadata_section_name(&self, target: &Target) -> &str;\n+    fn encode_type(&self, tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n+    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n+    fn encode_metadata(&self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       reexports: &def::ExportMap,\n+                       item_symbols: &RefCell<NodeMap<String>>,\n+                       link_meta: &LinkMeta,\n+                       reachable: &NodeSet,\n+                       krate: &hir::Crate) -> Vec<u8>;\n+    fn metadata_encoding_version(&self) -> &[u8];\n }\n \n impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n@@ -165,6 +200,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_item_attrs(&*cdata, def_id.index)\n     }\n \n+    fn item_symbol(&self, def: DefId) -> String\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_symbol(&cdata, def.index)\n+    }\n+\n     fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n@@ -285,21 +326,36 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_const_fn(&cdata, did.index)\n     }\n \n-    fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool {\n+    fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n+    {\n         let cdata = self.get_crate_data(trait_def_id.krate);\n         decoder::is_defaulted_trait(&*cdata, trait_def_id.index)\n     }\n \n-    fn is_impl(&self, did: DefId) -> bool {\n+    fn is_impl(&self, did: DefId) -> bool\n+    {\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_impl(&*cdata, did.index)\n     }\n \n-    fn is_static_method(&self, def: DefId) -> bool {\n+    fn is_static_method(&self, def: DefId) -> bool\n+    {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::is_static_method(&*cdata, def.index)\n     }\n \n+    fn is_extern_fn(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_extern_fn(&*cdata, did.index, tcx)\n+    }\n+\n+    fn is_static(&self, did: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_static(&*cdata, did.index)\n+    }\n+\n     fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n                                 -> Vec<(ast::CrateNum, LinkagePreference)>\n     {\n@@ -329,6 +385,21 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).staged_api\n     }\n \n+    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool\n+    {\n+        self.get_crate_data(cnum).explicitly_linked.get()\n+    }\n+\n+    fn is_allocator(&self, cnum: ast::CrateNum) -> bool\n+    {\n+        self.get_crate_data(cnum).is_allocator()\n+    }\n+\n+    fn crate_name(&self, cnum: ast::CrateNum) -> String\n+    {\n+        self.get_crate_data(cnum).name.clone()\n+    }\n+\n     fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(cnum);\n@@ -338,6 +409,18 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n+    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_native_libraries(&*cdata)\n+    }\n+\n+    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_reachable_ids(&*cdata)\n+    }\n+\n     fn def_path(&self, def: DefId) -> ast_map::DefPath\n     {\n         let cdata = self.get_crate_data(def.krate);\n@@ -396,4 +479,58 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let decode_inlined_item = Box::new(astencode::decode_inlined_item);\n         decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n     }\n+\n+    fn metadata_filename(&self) -> &str\n+    {\n+        loader::METADATA_FILENAME\n+    }\n+\n+    fn metadata_section_name(&self, target: &Target) -> &str\n+    {\n+        loader::meta_section_name(target)\n+    }\n+    fn encode_type(&self, tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>\n+    {\n+        encoder::encoded_ty(tcx, ty)\n+    }\n+\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    {\n+        self.do_get_used_crates(prefer)\n+    }\n+\n+    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource\n+    {\n+        self.do_get_used_crate_source(cnum).unwrap()\n+    }\n+\n+    fn encode_metadata(&self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       reexports: &def::ExportMap,\n+                       item_symbols: &RefCell<NodeMap<String>>,\n+                       link_meta: &LinkMeta,\n+                       reachable: &NodeSet,\n+                       krate: &hir::Crate) -> Vec<u8>\n+    {\n+        let encode_inlined_item: encoder::EncodeInlinedItem =\n+            Box::new(|ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii));\n+\n+        let encode_params = encoder::EncodeParams {\n+            diag: tcx.sess.diagnostic(),\n+            tcx: tcx,\n+            reexports: reexports,\n+            item_symbols: item_symbols,\n+            link_meta: link_meta,\n+            cstore: self,\n+            encode_inlined_item: encode_inlined_item,\n+            reachable: reachable\n+        };\n+        encoder::encode_metadata(encode_params, krate)\n+\n+    }\n+\n+    fn metadata_encoding_version(&self) -> &[u8]\n+    {\n+        encoder::metadata_encoding_version\n+    }\n }"}, {"sha": "786d2a8b81f0d2ee196b491072c1b4c31c6cb337", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -124,7 +124,7 @@ fn calculate_type(sess: &session::Session,\n                 None => {}\n             }\n             sess.cstore.iter_crate_data(|cnum, data| {\n-                let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+                let src = sess.cstore.used_crate_source(cnum);\n                 if src.rlib.is_some() { return }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n                                  data.name));\n@@ -152,14 +152,14 @@ fn calculate_type(sess: &session::Session,\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n     sess.cstore.iter_crate_data(|cnum, data| {\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", data.name);\n             add_library(sess, cnum, RequireDynamic, &mut formats);\n             let deps = sess.cstore.dylib_dependency_formats(cnum);\n             for &(depnum, style) in &deps {\n                 info!(\"adding {:?}: {}\", style,\n-                      sess.cstore.get_crate_data(depnum).name.clone());\n+                      sess.cstore.crate_name(depnum));\n                 add_library(sess, depnum, style, &mut formats);\n             }\n         }\n@@ -180,7 +180,7 @@ fn calculate_type(sess: &session::Session,\n     // If the crate hasn't been included yet and it's not actually required\n     // (e.g. it's an allocator) then we skip it here as well.\n     sess.cstore.iter_crate_data(|cnum, data| {\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n            data.explicitly_linked.get() {\n@@ -205,7 +205,7 @@ fn calculate_type(sess: &session::Session,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n         let cnum = (cnum + 1) as ast::CrateNum;\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let src = sess.cstore.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n@@ -216,10 +216,10 @@ fn calculate_type(sess: &session::Session,\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                let data = sess.cstore.get_crate_data(cnum);\n+                let name = sess.cstore.crate_name(cnum);\n                 sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n-                                 data.name, kind));\n+                                  name, kind));\n             }\n         }\n     }\n@@ -241,9 +241,8 @@ fn add_library(sess: &session::Session,\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n             if link2 != link || link == RequireStatic {\n-                let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                   shows up once\", data.name));\n+                                   shows up once\", sess.cstore.crate_name(cnum)));\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }\n@@ -253,15 +252,15 @@ fn add_library(sess: &session::Session,\n }\n \n fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n-    let crates = sess.cstore.get_used_crates(RequireStatic);\n+    let crates = sess.cstore.used_crates(RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n         return None\n     }\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n     let mut ret = (1..sess.cstore.next_crate_num()).map(|cnum| {\n-        if sess.cstore.get_crate_data(cnum).explicitly_linked.get() {\n+        if sess.cstore.is_explicitly_linked(cnum) {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -288,7 +287,7 @@ fn activate_allocator(sess: &session::Session, list: &mut DependencyList) {\n     let mut allocator_found = false;\n     for (i, slot) in list.iter().enumerate() {\n         let cnum = (i + 1) as ast::CrateNum;\n-        if !sess.cstore.get_crate_data(cnum).is_allocator() {\n+        if !sess.cstore.is_allocator(cnum) {\n             continue\n         }\n         if let Linkage::NotLinked = *slot {\n@@ -314,18 +313,18 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n     let mut allocator = None;\n     for (i, linkage) in list.iter().enumerate() {\n         let cnum = (i + 1) as ast::CrateNum;\n-        let data = sess.cstore.get_crate_data(cnum);\n-        if !data.is_allocator() {\n+        if !sess.cstore.is_allocator(cnum) {\n             continue\n         }\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n         if let Some(prev_alloc) = allocator {\n-            let prev = sess.cstore.get_crate_data(prev_alloc);\n+            let prev_name = sess.cstore.crate_name(prev_alloc);\n+            let cur_name = sess.cstore.crate_name(cnum);\n             sess.err(&format!(\"cannot link together two \\\n                                allocators: {} and {}\",\n-                              prev.name(), data.name()));\n+                              prev_name, cur_name));\n         }\n         allocator = Some(cnum);\n     }"}, {"sha": "5101e69204d109cc6ca689797d4bbe3d48cfb21b", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -76,6 +76,7 @@ use front::map as ast_map;\n use rustc_front::hir;\n use rustc_front::print::pprust;\n \n+use metadata::util::CrateStore;\n use middle::def;\n use middle::def_id::DefId;\n use middle::infer::{self, TypeOrigin};\n@@ -498,8 +499,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 // We compare strings because PathMod and PathName can be different\n                 // for imported and non-imported crates\n                 if exp_path == found_path {\n-                    let crate_name = self.tcx.sess.cstore\n-                                         .get_crate_data(did1.krate).name();\n+                    let crate_name = self.tcx.sess.cstore.crate_name(did1.krate);\n                     self.tcx.sess.span_note(sp, &format!(\"Perhaps two different versions \\\n                                                           of crate `{}` are being used?\",\n                                                           crate_name));"}, {"sha": "d7f9002a4f45646958f759af8a6a87121433f17a", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -21,10 +21,11 @@ use std::process::{Command, Output, Stdio};\n use std::ptr;\n use std::str;\n \n+use metadata::util::CrateStore;\n+\n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n-use rustc::metadata::loader::METADATA_FILENAME;\n use rustc::session::Session;\n use rustc_back::tempdir::TempDir;\n \n@@ -169,11 +170,13 @@ impl<'a> ArchiveBuilder<'a> {\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n+        let metadata_filename =\n+            self.config.sess.cstore.metadata_filename().to_owned();\n \n         self.add_archive(rlib, &name[..], move |fname: &str| {\n             let skip_obj = lto && fname.starts_with(&obj_start)\n                 && fname.ends_with(\".o\");\n-            skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n+            skip_obj || fname.ends_with(bc_ext) || fname == metadata_filename\n         })\n     }\n "}, {"sha": "621c99a871714c4d2214511c7c365fb0e08d90c8", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -19,9 +19,10 @@ use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputType};\n use session::search_paths::PathKind;\n use session::Session;\n-use metadata::common::LinkMeta;\n-use metadata::loader::METADATA_FILENAME;\n-use metadata::{encoder, cstore, filesearch, csearch, creader};\n+use metadata::{util as mdutil};\n+use metadata::filesearch;\n+use metadata::util::{CrateStore, LinkMeta};\n+use metadata::util::{LinkagePreference, NativeLibraryKind};\n use middle::dependency_format::Linkage;\n use middle::ty::{self, Ty};\n use rustc::front::map::DefPath;\n@@ -137,7 +138,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, &s[..], span);\n+        mdutil::validate_crate_name(sess, &s[..], span);\n         s\n     };\n \n@@ -216,7 +217,7 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n         symbol_hasher.input_str(&meta[..]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input(&encoder::encoded_ty(tcx, t));\n+    symbol_hasher.input(&tcx.sess.cstore.encode_type(tcx, t));\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from(\"h\");\n     hash.push_str(&truncated_hash_result(symbol_hasher));\n@@ -504,7 +505,7 @@ pub fn filename_for_input(sess: &Session,\n \n pub fn each_linked_rlib(sess: &Session,\n                         f: &mut FnMut(ast::CrateNum, &Path)) {\n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic).into_iter();\n+    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable).or_else(|| {\n         fmts.get(&config::CrateTypeStaticlib)\n@@ -516,7 +517,7 @@ pub fn each_linked_rlib(sess: &Session,\n             Linkage::NotLinked | Linkage::IncludedFromDylib => continue,\n             _ => {}\n         }\n-        let name = sess.cstore.get_crate_data(cnum).name.clone();\n+        let name = sess.cstore.crate_name(cnum).clone();\n         let path = match path {\n             Some(p) => p,\n             None => {\n@@ -623,8 +624,9 @@ fn link_rlib<'a>(sess: &'a Session,\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n-            cstore::NativeStatic => ab.add_native_library(&l),\n-            cstore::NativeFramework | cstore::NativeUnknown => {}\n+            NativeLibraryKind::NativeStatic => ab.add_native_library(&l),\n+            NativeLibraryKind::NativeFramework |\n+            NativeLibraryKind::NativeUnknown => {}\n         }\n     }\n \n@@ -666,7 +668,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // contain the metadata in a separate file. We use a temp directory\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n-            let metadata = tmpdir.join(METADATA_FILENAME);\n+            let metadata = tmpdir.join(sess.cstore.metadata_filename());\n             match fs::File::create(&metadata).and_then(|mut f| {\n                 f.write_all(&trans.metadata)\n             }) {\n@@ -805,10 +807,10 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n     let mut all_native_libs = vec![];\n \n     each_linked_rlib(sess, &mut |cnum, path| {\n-        let name = sess.cstore.get_crate_data(cnum).name();\n+        let name = sess.cstore.crate_name(cnum);\n         ab.add_rlib(path, &name, sess.lto()).unwrap();\n \n-        let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n+        let native_libs = sess.cstore.native_libraries(cnum);\n         all_native_libs.extend(native_libs);\n     });\n \n@@ -824,9 +826,9 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n \n     for &(kind, ref lib) in &all_native_libs {\n         let name = match kind {\n-            cstore::NativeStatic => \"static library\",\n-            cstore::NativeUnknown => \"library\",\n-            cstore::NativeFramework => \"framework\",\n+            NativeLibraryKind::NativeStatic => \"static library\",\n+            NativeLibraryKind::NativeUnknown => \"library\",\n+            NativeLibraryKind::NativeFramework => \"framework\",\n         };\n         sess.note(&format!(\"{}: {}\", name, *lib));\n     }\n@@ -1049,7 +1051,7 @@ fn link_args(cmd: &mut Linker,\n             path\n         };\n         let mut rpath_config = RPathConfig {\n-            used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n+            used_crates: sess.cstore.used_crates(LinkagePreference::RequireDynamic),\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n@@ -1089,10 +1091,10 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n     let libs = libs.borrow();\n \n     let staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n-        if kind == cstore::NativeStatic {Some(l)} else {None}\n+        if kind == NativeLibraryKind::NativeStatic {Some(l)} else {None}\n     });\n     let others = libs.iter().filter(|&&(_, kind)| {\n-        kind != cstore::NativeStatic\n+        kind != NativeLibraryKind::NativeStatic\n     });\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -1116,9 +1118,9 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n \n     for &(ref l, kind) in others {\n         match kind {\n-            cstore::NativeUnknown => cmd.link_dylib(l),\n-            cstore::NativeFramework => cmd.link_framework(l),\n-            cstore::NativeStatic => unreachable!(),\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(l),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(l),\n+            NativeLibraryKind::NativeStatic => unreachable!(),\n         }\n     }\n }\n@@ -1147,13 +1149,13 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n-    let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+    let deps = sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n \n     for &(cnum, _) in &deps {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let src = sess.cstore.used_crate_source(cnum);\n         match data[cnum as usize - 1] {\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n@@ -1217,7 +1219,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n         time(sess.time_passes(), &format!(\"altering {}.rlib\", name), || {\n             let cfg = archive_config(sess, &dst, Some(cratepath));\n             let mut archive = ArchiveBuilder::new(cfg);\n-            archive.remove_file(METADATA_FILENAME);\n+            archive.remove_file(sess.cstore.metadata_filename());\n             archive.update_symbols();\n \n             let mut any_objects = false;\n@@ -1292,14 +1294,14 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n     // This passes RequireStatic, but the actual requirement doesn't matter,\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n+    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic);\n     for (cnum, _) in crates {\n-        let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n+        let libs = sess.cstore.native_libraries(cnum);\n         for &(kind, ref lib) in &libs {\n             match kind {\n-                cstore::NativeUnknown => cmd.link_dylib(lib),\n-                cstore::NativeFramework => cmd.link_framework(lib),\n-                cstore::NativeStatic => {\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(lib),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(lib),\n+                NativeLibraryKind::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");\n                 }\n             }"}, {"sha": "8235df581c8360af062a1191f996da0059a34f44", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -16,7 +16,7 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use back::archive;\n-use metadata::csearch;\n+use metadata::util::CrateStore;\n use middle::dependency_format::Linkage;\n use session::Session;\n use session::config::CrateTypeDylib;\n@@ -342,9 +342,9 @@ impl<'a> Linker for MsvcLinker<'a> {\n                     None\n                 }\n             }).flat_map(|cnum| {\n-                csearch::get_reachable_ids(cstore, cnum)\n+                cstore.reachable_ids(cnum)\n             }).map(|did| {\n-                csearch::get_symbol(cstore, did)\n+                cstore.item_symbol(did)\n             });\n             for symbol in symbols {\n                 try!(writeln!(f, \"  {}\", symbol));"}, {"sha": "4f823b82daad3dd0795b851ebe6d4a76928acad2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -34,8 +34,6 @@ use back::{link, abi};\n use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n-use metadata::{csearch, encoder, loader};\n-use middle::astencode;\n use middle::cfg;\n use middle::def_id::DefId;\n use middle::infer;\n@@ -44,6 +42,7 @@ use middle::weak_lang_items;\n use middle::pat_util::simple_name;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, HasTypeFlags};\n+use metadata::util::CrateStore;\n use rustc::front::map as hir_map;\n use rustc_mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n@@ -199,7 +198,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let f = declare::declare_rust_fn(ccx, name, fn_ty);\n \n-    let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n+    let attrs = ccx.sess().cstore.item_attrs(did);\n     attributes::from_fn_attrs(ccx, &attrs[..], f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -230,7 +229,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   did: DefId,\n                                   t: Ty<'tcx>)\n                                   -> ValueRef {\n-    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n+    let name = ccx.sess().cstore.item_symbol(did);\n     let ty = type_of(ccx, t);\n     match ccx.externs().borrow_mut().get(&name) {\n         Some(n) => return *n,\n@@ -874,7 +873,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      did: DefId,\n                                      t: Ty<'tcx>)\n                                      -> ValueRef {\n-    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n+    let name = ccx.sess().cstore.item_symbol(did);\n     match t.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n@@ -885,7 +884,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n-                    let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n+                    let attrs = ccx.sess().cstore.item_attrs(did);\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name, &attrs)\n                 }\n             }\n@@ -2513,10 +2512,9 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                                                                .as_local_node_id(start_def_id) {\n                     get_item_val(ccx, start_node_id)\n                 } else {\n-                    let start_fn_type = csearch::get_type(ccx.tcx(), start_def_id).ty;\n+                    let start_fn_type = ccx.tcx().lookup_item_type(start_def_id).ty;\n                     trans_external_path(ccx, start_def_id, start_fn_type)\n                 };\n-\n                 let args = {\n                     let opaque_rust_main =\n                         llvm::LLVMBuildPointerCast(bld,\n@@ -2552,7 +2550,7 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n-            let sym = csearch::get_symbol(&ccx.sess().cstore, did);\n+            let sym = ccx.sess().cstore.item_symbol(did);\n             debug!(\"found item {} in other crate...\", sym);\n             return sym;\n         }\n@@ -2602,7 +2600,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let v = match i.node {\n                 hir::ItemStatic(..) => {\n                     // If this static came from an external crate, then\n-                    // we need to get the symbol from csearch instead of\n+                    // we need to get the symbol from metadata instead of\n                     // using the current crate's name/version\n                     // information in the hash of the symbol\n                     let sym = sym();\n@@ -2757,22 +2755,6 @@ fn register_method(ccx: &CrateContext,\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>,\n-                                            ie: encoder::EncodeInlinedItem<'a>,\n-                                            reachable: &'a NodeSet)\n-                                            -> encoder::EncodeParams<'a, 'tcx> {\n-    encoder::EncodeParams {\n-        diag: cx.sess().diagnostic(),\n-        tcx: cx.tcx(),\n-        reexports: cx.export_map(),\n-        item_symbols: cx.item_symbols(),\n-        link_meta: cx.link_meta(),\n-        cstore: &cx.sess().cstore,\n-        encode_inlined_item: ie,\n-        reachable: reachable,\n-    }\n-}\n-\n pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &NodeSet) -> Vec<u8> {\n     use flate;\n \n@@ -2785,14 +2767,13 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &N\n         return Vec::new();\n     }\n \n-    let encode_inlined_item: encoder::EncodeInlinedItem = Box::new(|ecx, rbml_w, ii| {\n-        astencode::encode_inlined_item(ecx, rbml_w, ii)\n-    });\n-\n-    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item, reachable);\n-    let metadata = encoder::encode_metadata(encode_parms, krate);\n-    let mut compressed = encoder::metadata_encoding_version.to_vec();\n+    let cstore = &cx.tcx().sess.cstore;\n+    let metadata = cstore.encode_metadata(\n+        cx.tcx(), cx.export_map(), cx.item_symbols(), cx.link_meta(), reachable,\n+        krate);\n+    let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.push_all(&flate::deflate_bytes(&metadata));\n+\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[..]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n@@ -2804,7 +2785,8 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &N\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let name = loader::meta_section_name(&cx.sess().target.target);\n+        let name =\n+            cx.tcx().sess.cstore.metadata_section_name(&cx.sess().target.target);\n         let name = CString::new(name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr())\n     }\n@@ -3106,12 +3088,12 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // the final product, so LTO needs to preserve them.\n     if sess.lto() {\n         sess.cstore.iter_crate_data(|cnum, _| {\n-            let syms = csearch::get_reachable_ids(&sess.cstore, cnum);\n+            let syms = sess.cstore.reachable_ids(cnum);\n             reachable_symbols.extend(syms.into_iter().filter(|did| {\n-                csearch::is_extern_fn(&sess.cstore, *did, shared_ccx.tcx()) ||\n-                csearch::is_static(&sess.cstore, *did)\n+                sess.cstore.is_extern_fn(shared_ccx.tcx(), *did) ||\n+                sess.cstore.is_static(*did)\n             }).map(|did| {\n-                csearch::get_symbol(&sess.cstore, did)\n+                sess.cstore.item_symbol(did)\n             }));\n         });\n     }"}, {"sha": "6178ffe14d6300dd6c49dd3e591c944f7de85e50", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -9,9 +9,7 @@\n // except according to those terms.\n \n use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n-use metadata::csearch;\n-use metadata::inline::InlinedItem;\n-use middle::astencode;\n+use metadata::util::{CrateStore, FoundAst, InlinedItem};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n@@ -41,17 +39,13 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n         }\n     }\n \n-    let csearch_result =\n-        csearch::maybe_get_item_ast(\n-            ccx.tcx(), fn_id,\n-            Box::new(astencode::decode_inlined_item));\n-\n-    let inline_id = match csearch_result {\n-        csearch::FoundAst::NotFound => {\n+    let inlined = ccx.tcx().sess.cstore.maybe_get_item_ast(ccx.tcx(), fn_id);\n+    let inline_id = match inlined {\n+        FoundAst::NotFound => {\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n         }\n-        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n+        FoundAst::Found(&InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n@@ -94,12 +88,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n \n             item.id\n         }\n-        csearch::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n+        FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             item.id\n         }\n-        csearch::FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n+        FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n@@ -129,11 +123,11 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             trans_item(ccx, &**item);\n             my_id\n         }\n-        csearch::FoundAst::FoundParent(_, _) => {\n+        FoundAst::FoundParent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n                             with a non-item parent\");\n         }\n-        csearch::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n+        FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n             ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n \n@@ -153,7 +147,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             // don't.\n             trait_item.id\n         }\n-        csearch::FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n+        FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n             ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n "}, {"sha": "6a50ceba2f0337ae8abb1534599e8f39a2369d55", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -12,6 +12,7 @@\n //! same type.\n \n use metadata::cstore::LOCAL_CRATE;\n+use metadata::util::CrateStore;\n use middle::def_id::DefId;\n use middle::traits;\n use middle::ty;\n@@ -156,9 +157,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             span_note!(self.tcx.sess, self.span_of_impl(impl2),\n                        \"note conflicting implementation here\");\n         } else {\n-            let crate_store = &self.tcx.sess.cstore;\n-            let cdata = crate_store.get_crate_data(impl2.krate);\n-            self.tcx.sess.note(&format!(\"conflicting implementation in crate `{}`\", cdata.name));\n+            let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n+            self.tcx.sess.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n         }\n     }\n "}, {"sha": "b722beef2c904742d38979f8df3ef87c8f5fa995", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11dbb69bd14f52940d54981b883814d52153dc57/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dbb69bd14f52940d54981b883814d52153dc57/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=11dbb69bd14f52940d54981b883814d52153dc57", "patch": "@@ -27,6 +27,7 @@ use std::thread::Builder;\n use rustc::front::map as ast_map;\n use rustc::llvm;\n use rustc::metadata::cstore::RequireDynamic;\n+use rustc::metadata::util::CrateStore;\n use rustc::middle::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n use rustc::session::build_session;"}]}