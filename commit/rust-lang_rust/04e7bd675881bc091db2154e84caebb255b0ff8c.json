{"sha": "04e7bd675881bc091db2154e84caebb255b0ff8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZTdiZDY3NTg4MWJjMDkxZGIyMTU0ZTg0Y2FlYmIyNTViMGZmOGM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-07T02:49:08Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-07T02:49:08Z"}, "message": "More UTF-16 wrapping on win32. Close #1927.", "tree": {"sha": "6420ef3a15db3d250bbb27bca6e4bd6070a7b9ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6420ef3a15db3d250bbb27bca6e4bd6070a7b9ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04e7bd675881bc091db2154e84caebb255b0ff8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04e7bd675881bc091db2154e84caebb255b0ff8c", "html_url": "https://github.com/rust-lang/rust/commit/04e7bd675881bc091db2154e84caebb255b0ff8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04e7bd675881bc091db2154e84caebb255b0ff8c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf8f5b7606b87c26901abc0f6e271f48828bcf5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf8f5b7606b87c26901abc0f6e271f48828bcf5b", "html_url": "https://github.com/rust-lang/rust/commit/cf8f5b7606b87c26901abc0f6e271f48828bcf5b"}], "stats": {"total": 208, "additions": 122, "deletions": 86}, "files": [{"sha": "4e8389d34fcaa78a680422da7ab479029eff89e1", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/04e7bd675881bc091db2154e84caebb255b0ff8c/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04e7bd675881bc091db2154e84caebb255b0ff8c/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=04e7bd675881bc091db2154e84caebb255b0ff8c", "patch": "@@ -493,6 +493,9 @@ mod consts {\n             const O_TEXT : int = 16384;\n             const O_BINARY : int = 32768;\n             const O_NOINHERIT: int = 128;\n+\n+            const ERROR_SUCCESS : int = 0;\n+            const ERROR_INSUFFICIENT_BUFFER : int = 122;\n         }\n     }\n \n@@ -1105,15 +1108,17 @@ mod funcs {\n                                        nsize: DWORD) -> DWORD;\n             fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;\n \n-            fn GetModuleFileNameA(hModule: HMODULE,\n-                                  lpFilename: LPSTR,\n+            fn GetModuleFileNameW(hModule: HMODULE,\n+                                  lpFilename: LPWSTR,\n                                   nSize: DWORD) -> DWORD;\n-            fn CreateDirectoryA(lpPathName: LPCSTR,\n+            fn CreateDirectoryW(lpPathName: LPCWSTR,\n                                 lpSecurityAttributes:\n                                 LPSECURITY_ATTRIBUTES) -> BOOL;\n-            fn DeleteFileA(lpPathName: LPCSTR) -> BOOL;\n-            fn RemoveDirectoryA(lpPathName: LPCSTR) -> BOOL;\n-            fn SetCurrentDirectoryA(lpPathName: LPCSTR) -> BOOL;\n+            fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n+            fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+            fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+\n+            fn GetLastError() -> DWORD;\n         }\n \n         #[abi = \"cdecl\"]"}, {"sha": "0258c7b55f6b4a9582af16d6997d56eb8e195742", "filename": "src/libcore/os.rs", "status": "modified", "additions": 111, "deletions": 80, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/04e7bd675881bc091db2154e84caebb255b0ff8c/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04e7bd675881bc091db2154e84caebb255b0ff8c/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=04e7bd675881bc091db2154e84caebb255b0ff8c", "patch": "@@ -14,9 +14,13 @@\n // facts of which OS the user is on -- they should be given the opportunity\n // to write OS-ignorant code by default.\n \n-import libc::{c_char, c_void, c_int, c_uint, size_t, mode_t, pid_t, FILE};\n+import libc::{c_char, c_void, c_int, c_uint, size_t, ssize_t,\n+              mode_t, pid_t, FILE};\n import libc::{close, fclose};\n \n+import option::{some, none};\n+import option = option::t;\n+\n import getcwd = rustrt::rust_getcwd;\n import consts::*;\n \n@@ -46,15 +50,48 @@ fn env() -> [(str,str)] {\n     ret pairs;\n }\n \n+const tmpbuf_sz : uint = 1000u;\n+\n fn as_c_charp<T>(s: str, f: fn(*c_char) -> T) -> T {\n     str::as_buf(s) {|b| f(b as *c_char) }\n }\n \n-fn as_utf16_p<T>(s: str, f: fn(*u16) -> T) -> T {\n-    let t = str::to_utf16(s);\n-    // \"null terminate\"\n-    t += [0u16];\n-    vec::as_buf(t, f)\n+fn fill_charp_buf(f: fn(*mutable c_char, size_t) -> bool)\n+    -> option<str> {\n+    let buf = vec::to_mut(vec::init_elt(tmpbuf_sz, 0u8 as c_char));\n+    vec::as_mut_buf(buf) { |b|\n+        if f(b, tmpbuf_sz as size_t) {\n+            some(str::from_cstr(b as str::sbuf))\n+        } else {\n+            none\n+        }\n+    }\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+mod win32 {\n+    import dword = libc::types::os::arch::extra::DWORD;\n+\n+    fn fill_utf16_buf_and_decode(f: fn(*mutable u16, dword) -> dword)\n+        -> option<str> {\n+        let buf = vec::to_mut(vec::init_elt(tmpbuf_sz, 0u16));\n+        vec::as_mut_buf(buf) {|b|\n+            let k : dword = f(b, tmpbuf_sz as dword);\n+            if k == (0 as dword) {\n+                none\n+            } else {\n+                let sub = vec::slice(buf, 0u, k as uint);\n+                option::some::<str>(str::from_utf16(sub))\n+            }\n+        }\n+    }\n+\n+    fn as_utf16_p<T>(s: str, f: fn(*u16) -> T) -> T {\n+        let t = str::to_utf16(s);\n+        // Null terminate before passing on.\n+        t += [0u16];\n+        vec::as_buf(t, f)\n+    }\n }\n \n \n@@ -74,19 +111,11 @@ fn getenv(n: str) -> option<str> unsafe {\n #[cfg(target_os = \"win32\")]\n fn getenv(n: str) -> option<str> unsafe {\n     import libc::types::os::arch::extra::*;\n-    import libc::funcs::extra::kernel32;\n+    import libc::funcs::extra::kernel32::*;\n+    import win32::*;\n     as_utf16_p(n) {|u|\n-        let bufsize = 1023u;\n-        let buf = vec::to_mut(vec::init_elt(bufsize, 0u16));\n-        vec::as_mut_buf(buf) {|b|\n-            let k = kernel32::GetEnvironmentVariableW(u, b,\n-                                                      bufsize as DWORD);\n-            if k != (0 as DWORD) {\n-                let sub = vec::slice(buf, 0u, k as uint);\n-                option::some::<str>(str::from_utf16(sub))\n-            } else {\n-                option::none::<str>\n-            }\n+        fill_utf16_buf_and_decode() {|buf, sz|\n+            GetEnvironmentVariableW(u, buf, sz)\n         }\n     }\n }\n@@ -99,7 +128,6 @@ fn setenv(n: str, v: str) {\n \n     // FIXME: remove this when export globs work properly.\n     import libc::funcs::posix01::unistd::setenv;\n-\n     as_c_charp(n) {|nbuf|\n         as_c_charp(v) {|vbuf|\n             setenv(nbuf, vbuf, 1i32);\n@@ -111,10 +139,11 @@ fn setenv(n: str, v: str) {\n #[cfg(target_os = \"win32\")]\n fn setenv(n: str, v: str) {\n     // FIXME: remove imports when export globs work properly.\n-    import libc::funcs::extra::kernel32;\n+    import libc::funcs::extra::kernel32::*;\n+    import win32::*;\n     as_utf16_p(n) {|nbuf|\n         as_utf16_p(v) {|vbuf|\n-            kernel32::SetEnvironmentVariableW(nbuf, vbuf);\n+            SetEnvironmentVariableW(nbuf, vbuf);\n         }\n     }\n }\n@@ -244,59 +273,57 @@ fn dll_filename(base: str) -> str {\n     fn pre() -> str { \"\" }\n }\n \n-fn self_exe_path() -> option<path> unsafe {\n-    let bufsize = 1023u;\n-    let buf = vec::to_mut(vec::init_elt(bufsize, 0u8 as c_char));\n-    // FIXME: This does not handle the case where the buffer is too small\n-    ret vec::as_mut_buf(buf) {|pbuf|\n-        if load_self(pbuf as *mutable c_char, bufsize as c_uint) {\n-            let path = str::from_cstr(pbuf as str::sbuf);\n-            option::some(path::dirname(path) + path::path_sep())\n-        } else {\n-            option::none\n-        }\n-    };\n+\n+fn self_exe_path() -> option<path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n-        // FIXME: remove imports when export globs work properly.\n+    fn load_self() -> option<path> unsafe {\n         import libc::funcs::bsd44::*;\n         import libc::consts::os::extra::*;\n-        let mib = [CTL_KERN as c_int,\n-                   KERN_PROC as c_int,\n-                   KERN_PROC_PATHNAME as c_int, -1 as c_int];\n-        ret sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n-                   pth as *mutable c_void, ptr::mut_addr_of(plen as size_t),\n-                   ptr::null(), 0u as size_t)\n-            == (0 as c_int);\n+        fill_charp_buf() {|buf, sz|\n+            let mib = [CTL_KERN as c_int,\n+                       KERN_PROC as c_int,\n+                       KERN_PROC_PATHNAME as c_int, -1 as c_int];\n+            sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n+                   buf as *mutable c_void, ptr::mut_addr_of(sz),\n+                   ptr::null(), 0u as size_t) != (0 as c_int)\n+        }\n     }\n \n     #[cfg(target_os = \"linux\")]\n-    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n-        // FIXME: remove imports when export globs work properly.\n+    fn load_self() -> option<path> unsafe {\n         import libc::funcs::posix01::unistd::readlink;\n-        as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n-            ret readlink(proc_self_buf, pth, plen as size_t) != -1;\n+        fill_charp_buf() {|buf, sz|\n+            as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n+                readlink(proc_self_buf, buf, sz) != (-1 as ssize_t)\n+            }\n         }\n     }\n \n-    #[cfg(target_os = \"win32\")]\n-    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n+    #[cfg(target_os = \"macos\")]\n+    fn load_self() -> option<path> unsafe {\n         // FIXME: remove imports when export globs work properly.\n-        import libc::types::os::arch::extra::*;\n-        import libc::funcs::extra::kernel32;\n-        ret kernel32::GetModuleFileNameA(0u, pth, plen) != (0 as DWORD);\n+        import libc::funcs::extra::*;\n+        fill_charp_buf() {|buf, sz|\n+            _NSGetExecutablePath(buf, ptr::mut_addr_of(sz as u32))\n+                == (0 as c_int)\n+        }\n     }\n \n-    #[cfg(target_os = \"macos\")]\n-    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n+    #[cfg(target_os = \"win32\")]\n+    fn load_self() -> option<path> unsafe {\n         // FIXME: remove imports when export globs work properly.\n-        import libc::funcs::extra::*;\n-        let mplen = plen;\n-        ret _NSGetExecutablePath(pth, ptr::mut_addr_of(mplen))\n-            == (0 as c_int);\n+        import libc::types::os::arch::extra::*;\n+        import libc::funcs::extra::kernel32::*;\n+        import win32::*;\n+        fill_utf16_buf_and_decode() {|buf, sz|\n+            GetModuleFileNameW(0u, buf, sz)\n+        }\n     }\n \n+    option::map(load_self()) {|pth|\n+        path::dirname(pth) + path::path_sep()\n+    }\n }\n \n \n@@ -356,9 +383,9 @@ Function: path_is_dir\n Indicates whether a path represents a directory.\n */\n fn path_is_dir(p: path) -> bool {\n-    ret str::as_buf(p, {|buf|\n+    str::as_buf(p) {|buf|\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n-    });\n+    }\n }\n \n /*\n@@ -367,9 +394,9 @@ Function: path_exists\n Indicates whether a path exists.\n */\n fn path_exists(p: path) -> bool {\n-    ret str::as_buf(p, {|buf|\n+    str::as_buf(p) {|buf|\n         rustrt::rust_path_exists(buf) != 0 as c_int\n-    });\n+    }\n }\n \n // FIXME: under Windows, we should prepend the current drive letter to paths\n@@ -404,24 +431,25 @@ fn make_dir(p: path, mode: c_int) -> bool {\n     ret mkdir(p, mode);\n \n     #[cfg(target_os = \"win32\")]\n-    fn mkdir(_p: path, _mode: c_int) -> bool unsafe {\n+    fn mkdir(p: path, _mode: c_int) -> bool unsafe {\n+        // FIXME: remove imports when export globs work properly.\n+        import libc::types::os::arch::extra::*;\n+        import libc::funcs::extra::kernel32::*;\n+        import win32::*;\n         // FIXME: turn mode into something useful?\n-        ret as_c_charp(_p, {|buf|\n-            // FIXME: remove imports when export globs work properly.\n-            import libc::types::os::arch::extra::*;\n-            import libc::funcs::extra::kernel32;\n-            kernel32::CreateDirectoryA(\n-                buf, unsafe::reinterpret_cast(0)) != (0 as BOOL)\n-        });\n+        as_utf16_p(p) {|buf|\n+            CreateDirectoryW(buf, unsafe::reinterpret_cast(0))\n+                != (0 as BOOL)\n+        }\n     }\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     fn mkdir(p: path, mode: c_int) -> bool {\n-        ret as_c_charp(p) {|c|\n+        as_c_charp(p) {|c|\n             libc::mkdir(c, mode as mode_t) == (0 as c_int)\n-        };\n+        }\n     }\n }\n \n@@ -468,10 +496,11 @@ fn remove_dir(p: path) -> bool {\n     #[cfg(target_os = \"win32\")]\n     fn rmdir(p: path) -> bool {\n         // FIXME: remove imports when export globs work properly.\n-        import libc::funcs::extra::kernel32;\n+        import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n-        ret as_c_charp(p) {|buf|\n-            kernel32::RemoveDirectoryA(buf) != (0 as BOOL)\n+        import win32::*;\n+        ret as_utf16_p(p) {|buf|\n+            RemoveDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n@@ -491,10 +520,11 @@ fn change_dir(p: path) -> bool {\n     #[cfg(target_os = \"win32\")]\n     fn chdir(p: path) -> bool {\n         // FIXME: remove imports when export globs work properly.\n-        import libc::funcs::extra::kernel32;\n+        import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n-        ret as_c_charp(p) {|buf|\n-            kernel32::SetCurrentDirectoryA(buf) != (0 as BOOL)\n+        import win32::*;\n+        ret as_utf16_p(p) {|buf|\n+            SetCurrentDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n@@ -519,10 +549,11 @@ fn remove_file(p: path) -> bool {\n     #[cfg(target_os = \"win32\")]\n     fn unlink(p: path) -> bool {\n         // FIXME: remove imports when export globs work properly.\n-        import libc::funcs::extra::kernel32;\n+        import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n-        ret as_c_charp(p) {|buf|\n-            kernel32::DeleteFileA(buf) != (0 as BOOL)\n+        import win32::*;\n+        ret as_utf16_p(p) {|buf|\n+            DeleteFileW(buf) != (0 as BOOL)\n         };\n     }\n "}]}