{"sha": "82f17ab91714bcc8bd2a5591e90db690d449d38c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZjE3YWI5MTcxNGJjYzhiZDJhNTU5MWU5MGRiNjkwZDQ0OWQzOGM=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-03-16T23:48:44Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:23:32Z"}, "message": "Implement basic support for concurrency (Linux only).", "tree": {"sha": "9471f8a74435c3715aeb3429b68a4310654fde63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9471f8a74435c3715aeb3429b68a4310654fde63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82f17ab91714bcc8bd2a5591e90db690d449d38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82f17ab91714bcc8bd2a5591e90db690d449d38c", "html_url": "https://github.com/rust-lang/rust/commit/82f17ab91714bcc8bd2a5591e90db690d449d38c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82f17ab91714bcc8bd2a5591e90db690d449d38c/comments", "author": null, "committer": null, "parents": [{"sha": "e06df3a8817cc5d5e157d4f7614c981e3320170b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e06df3a8817cc5d5e157d4f7614c981e3320170b", "html_url": "https://github.com/rust-lang/rust/commit/e06df3a8817cc5d5e157d4f7614c981e3320170b"}], "stats": {"total": 647, "additions": 571, "deletions": 76}, "files": [{"sha": "b0a59c64d1e16f8e027e47f30c7a7db128c5381e", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -205,7 +205,8 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n     // Perform the main execution.\n     let res: InterpResult<'_, i64> = (|| {\n         // Main loop.\n-        while ecx.step()? {\n+        while ecx.schedule()? {\n+            assert!(ecx.step()?);\n             ecx.process_diagnostics();\n         }\n         // Read the return code pointer *before* we run TLS destructors, to assert"}, {"sha": "c042526be64c1723f17a07168b6e6f314eb9e412", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -12,6 +12,7 @@ extern crate rustc_ast;\n #[macro_use] extern crate rustc_middle;\n extern crate rustc_data_structures;\n extern crate rustc_hir;\n+extern crate rustc_index;\n extern crate rustc_mir;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -26,6 +27,7 @@ mod operator;\n mod range_map;\n mod shims;\n mod stacked_borrows;\n+mod threads;\n \n // Make all those symbols available in the same place as our own.\n pub use rustc_mir::interpret::*;\n@@ -60,6 +62,7 @@ pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n     EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, Stack, Stacks, Tag,\n };\n+pub use crate::threads::EvalContextExt as ThreadsEvalContextExt;\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "9d1fa9b78c32d984c955e2615a50776c9720355d", "filename": "src/machine.rs", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -26,6 +26,8 @@ use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n \n+pub use crate::threads::{ThreadId, ThreadSet, ThreadLocalStorage};\n+\n // Some global facts about the emulated machine.\n pub const PAGE_SIZE: u64 = 4 * 1024; // FIXME: adjust to target architecture\n pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but where we start assigning integer addresses to allocations\n@@ -107,6 +109,7 @@ pub struct AllocExtra {\n pub struct MemoryExtra {\n     pub stacked_borrows: Option<stacked_borrows::MemoryExtra>,\n     pub intptrcast: intptrcast::MemoryExtra,\n+    pub tls: ThreadLocalStorage,\n \n     /// Mapping extern static names to their canonical allocation.\n     extern_statics: FxHashMap<Symbol, AllocId>,\n@@ -143,6 +146,7 @@ impl MemoryExtra {\n             rng: RefCell::new(rng),\n             tracked_alloc_id,\n             check_alignment,\n+            tls: Default::default(),\n         }\n     }\n \n@@ -251,8 +255,8 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// The \"time anchor\" for this machine's monotone clock (for `Instant` simulation).\n     pub(crate) time_anchor: Instant,\n \n-    /// The call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>>,\n+    /// The set of threads.\n+    pub(crate) threads: ThreadSet<'mir, 'tcx>,\n \n     /// Precomputed `TyLayout`s for primitive data types that are commonly used inside Miri.\n     pub(crate) layouts: PrimitiveLayouts<'tcx>,\n@@ -282,7 +286,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             panic_payload: None,\n             time_anchor: Instant::now(),\n             layouts,\n-            stack: Vec::default(),\n+            threads: Default::default(),\n         }\n     }\n }\n@@ -326,6 +330,19 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         memory_extra.check_alignment\n     }\n \n+    #[inline(always)]\n+    fn stack<'a>(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+        ecx.active_thread_stack()\n+    }\n+\n+    fn stack_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+        ecx.active_thread_stack_mut()\n+    }\n+\n     #[inline(always)]\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         ecx.machine.validate\n@@ -418,29 +435,39 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     fn canonical_alloc_id(mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n         let tcx = mem.tcx;\n-        // Figure out if this is an extern static, and if yes, which one.\n-        let def_id = match tcx.alloc_map.lock().get(id) {\n-            Some(GlobalAlloc::Static(def_id)) if tcx.is_foreign_item(def_id) => def_id,\n+        let alloc = tcx.alloc_map.lock().get(id);\n+        match alloc {\n+            Some(GlobalAlloc::Static(def_id)) if tcx.is_foreign_item(def_id) => {\n+                // Figure out if this is an extern static, and if yes, which one.\n+                let attrs = tcx.get_attrs(def_id);\n+                let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n+                    Some(name) => name,\n+                    None => tcx.item_name(def_id),\n+                };\n+                // Check if we know this one.\n+                if let Some(canonical_id) = mem.extra.extern_statics.get(&link_name) {\n+                    trace!(\"canonical_alloc_id: {:?} ({}) -> {:?}\", id, link_name, canonical_id);\n+                    *canonical_id\n+                } else {\n+                    // Return original id; `Memory::get_static_alloc` will throw an error.\n+                    id\n+                }\n+            },\n+            Some(GlobalAlloc::Static(def_id)) if tcx.has_attr(def_id, sym::thread_local) => {\n+                // We have a thread local, so we need to get a unique allocation id for it.\n+                mem.extra.tls.get_or_register_allocation(*tcx, id)\n+            },\n             _ => {\n                 // No need to canonicalize anything.\n-                return id;\n+                id\n             }\n-        };\n-        let attrs = tcx.get_attrs(def_id);\n-        let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n-            Some(name) => name,\n-            None => tcx.item_name(def_id),\n-        };\n-        // Check if we know this one.\n-        if let Some(canonical_id) = mem.extra.extern_statics.get(&link_name) {\n-            trace!(\"canonical_alloc_id: {:?} ({}) -> {:?}\", id, link_name, canonical_id);\n-            *canonical_id\n-        } else {\n-            // Return original id; `Memory::get_static_alloc` will throw an error.\n-            id\n         }\n     }\n \n+    fn resolve_thread_local_allocation_id(extra: &Self::MemoryExtra, id: AllocId) -> AllocId {\n+        extra.tls.resolve_allocation(id)\n+    }\n+\n     fn init_allocation_extra<'b>(\n         memory_extra: &MemoryExtra,\n         id: AllocId,"}, {"sha": "47b661061d69095eb7d7086bd7881adbe30f1874", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 93, "deletions": 8, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -6,6 +6,7 @@ use std::convert::TryFrom;\n use log::trace;\n \n use crate::*;\n+use rustc_index::vec::Idx;\n use rustc_middle::mir;\n use rustc_target::abi::{Align, LayoutOf, Size};\n \n@@ -221,13 +222,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"pthread_getspecific\" => {\n                 let key = this.force_bits(this.read_scalar(args[0])?.not_undef()?, args[0].layout.size)?;\n-                let ptr = this.machine.tls.load_tls(key, this)?;\n+                let active_thread = this.get_active_thread()?;\n+                let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n                 let key = this.force_bits(this.read_scalar(args[0])?.not_undef()?, args[0].layout.size)?;\n+                let active_thread = this.get_active_thread()?;\n                 let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n+                this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;\n@@ -291,11 +294,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n-            // Better error for attempts to create a thread\n-            \"pthread_create\" => {\n-                throw_unsup_format!(\"Miri does not support threading\");\n-            }\n-\n             // Miscellaneous\n             \"isatty\" => {\n                 let _fd = this.read_scalar(args[0])?.to_i32()?;\n@@ -316,7 +314,94 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n+            // Threading\n+            \"pthread_create\" => {\n+                assert_eq!(args.len(), 4);\n+                let func = args[2];\n+                let fn_ptr = this.read_scalar(func)?.not_undef()?;\n+                let fn_val = this.memory.get_fn(fn_ptr)?;\n+                let instance = match fn_val {\n+                    rustc_mir::interpret::FnVal::Instance(instance) => instance,\n+                    _ => unreachable!(),\n+                };\n+                let thread_info_place = this.deref_operand(args[0])?;\n+                let thread_info_type = args[0].layout.ty\n+                    .builtin_deref(true)\n+                    .ok_or_else(|| err_ub_format!(\n+                        \"wrong signature used for `pthread_create`: first argument must be a raw pointer.\"\n+                    ))?\n+                    .ty;\n+                let thread_info_layout = this.layout_of(thread_info_type)?;\n+                let func_arg = match *args[3] {\n+                    rustc_mir::interpret::Operand::Immediate(immediate) => immediate,\n+                    _ => unreachable!(),\n+                };\n+                let func_args = [func_arg];\n+                let ret_place =\n+                    this.allocate(this.layout_of(this.tcx.types.usize)?, MiriMemoryKind::Machine.into());\n+                let new_thread_id = this.create_thread()?;\n+                let old_thread_id = this.set_active_thread(new_thread_id)?;\n+                this.call_function(\n+                    instance,\n+                    &func_args[..],\n+                    Some(ret_place.into()),\n+                    StackPopCleanup::None { cleanup: true },\n+                )?;\n+                this.set_active_thread(old_thread_id)?;\n+                this.write_scalar(\n+                    Scalar::from_uint(new_thread_id.index() as u128, thread_info_layout.size),\n+                    thread_info_place.into(),\n+                )?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_join\" => {\n+                assert_eq!(args.len(), 2);\n+                assert!(\n+                    this.is_null(this.read_scalar(args[1])?.not_undef()?)?,\n+                    \"Miri supports pthread_join only with retval==NULL\"\n+                );\n+                let thread = this.read_scalar(args[0])?.not_undef()?.to_machine_usize(this)?;\n+                this.join_thread(thread.into())?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_detach\" => {\n+                let thread = this.read_scalar(args[0])?.not_undef()?.to_machine_usize(this)?;\n+                this.detach_thread(thread.into())?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            \"pthread_attr_getguardsize\" => {\n+                assert_eq!(args.len(), 2);\n+\n+                let guard_size = this.deref_operand(args[1])?;\n+                let guard_size_type = args[1].layout.ty\n+                    .builtin_deref(true)\n+                    .ok_or_else(|| err_ub_format!(\n+                        \"wrong signature used for `pthread_attr_getguardsize`: first argument must be a raw pointer.\"\n+                    ))?\n+                    .ty;\n+                let guard_size_layout = this.layout_of(guard_size_type)?;\n+                this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), guard_size.into())?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            \"prctl\" => {\n+                let option = this.read_scalar(args[0])?.not_undef()?.to_i32()?;\n+                assert_eq!(option, 0xf, \"Miri supports only PR_SET_NAME\");\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\""}, {"sha": "a58444b21bff1d6bbd37a25e93f4b373a13aacda", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -144,13 +144,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"TlsGetValue\" => {\n                 let key = u128::from(this.read_scalar(args[0])?.to_u32()?);\n-                let ptr = this.machine.tls.load_tls(key, this)?;\n+                let active_thread = this.get_active_thread()?;\n+                let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n                 let key = u128::from(this.read_scalar(args[0])?.to_u32()?);\n+                let active_thread = this.get_active_thread()?;\n                 let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n+                this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n \n                 // Return success (`1`).\n                 this.write_scalar(Scalar::from_i32(1), dest)?;"}, {"sha": "d16acb75003703ee5c1b989590f79911d71d81de", "filename": "src/shims/tls.rs", "status": "modified", "additions": 60, "deletions": 38, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -1,22 +1,24 @@\n //! Implement thread-local storage.\n \n use std::collections::BTreeMap;\n+use std::collections::btree_map::Entry;\n \n use log::trace;\n \n use rustc_middle::ty;\n use rustc_target::abi::{Size, HasDataLayout};\n \n-use crate::{HelpersEvalContextExt, InterpResult, MPlaceTy, Scalar, StackPopCleanup, Tag};\n+use crate::{HelpersEvalContextExt, ThreadsEvalContextExt, InterpResult, MPlaceTy, Scalar, StackPopCleanup, Tag};\n+use crate::machine::ThreadId;\n \n pub type TlsKey = u128;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n     /// The data for this key. None is used to represent NULL.\n     /// (We normalize this early to avoid having to do a NULL-ptr-test each time we access the data.)\n     /// Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n-    data: Option<Scalar<Tag>>,\n+    data: BTreeMap<ThreadId, Scalar<Tag>>,\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -52,7 +54,7 @@ impl<'tcx> TlsData<'tcx> {\n     pub fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>, max_size: Size) -> InterpResult<'tcx, TlsKey> {\n         let new_key = self.next_key;\n         self.next_key += 1;\n-        self.keys.insert(new_key, TlsEntry { data: None, dtor }).unwrap_none();\n+        self.keys.insert(new_key, TlsEntry { data: Default::default(), dtor }).unwrap_none();\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n \n         if max_size.bits() < 128 && new_key >= (1u128 << max_size.bits() as u128) {\n@@ -74,22 +76,34 @@ impl<'tcx> TlsData<'tcx> {\n     pub fn load_tls(\n         &self,\n         key: TlsKey,\n+        thread_id: ThreadId,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         match self.keys.get(&key) {\n-            Some(&TlsEntry { data, .. }) => {\n-                trace!(\"TLS key {} loaded: {:?}\", key, data);\n-                Ok(data.unwrap_or_else(|| Scalar::null_ptr(cx).into()))\n+            Some(TlsEntry { data, .. }) => {\n+                let value = data.get(&thread_id).cloned();\n+                trace!(\"TLS key {} for thread {:?} loaded: {:?}\", key, thread_id, value);\n+                Ok(value.unwrap_or_else(|| Scalar::null_ptr(cx).into()))\n             }\n             None => throw_ub_format!(\"loading from a non-existing TLS key: {}\", key),\n         }\n     }\n \n-    pub fn store_tls(&mut self, key: TlsKey, new_data: Option<Scalar<Tag>>) -> InterpResult<'tcx> {\n+    pub fn store_tls(\n+        &mut self,\n+         key: TlsKey, thread_id: ThreadId, new_data: Option<Scalar<Tag>>) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(TlsEntry { data, .. }) => {\n-                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n-                *data = new_data;\n+                match new_data {\n+                    Some(ptr) => {\n+                        trace!(\"TLS key {} for thread {:?} stored: {:?}\", key, thread_id, ptr);\n+                        data.insert(thread_id, ptr);\n+                    }\n+                    None => {\n+                        trace!(\"TLS key {} for thread {:?} removed\", key, thread_id);\n+                        data.remove(&thread_id);\n+                    }\n+                }\n                 Ok(())\n             }\n             None => throw_ub_format!(\"storing to a non-existing TLS key: {}\", key),\n@@ -131,7 +145,8 @@ impl<'tcx> TlsData<'tcx> {\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-    ) -> Option<(ty::Instance<'tcx>, Scalar<Tag>, TlsKey)> {\n+        thread_id: ThreadId,\n+    ) -> Option<(ty::Instance<'tcx>, ThreadId, Scalar<Tag>, TlsKey)> {\n         use std::collections::Bound::*;\n \n         let thread_local = &mut self.keys;\n@@ -142,12 +157,15 @@ impl<'tcx> TlsData<'tcx> {\n         for (&key, TlsEntry { data, dtor }) in\n             thread_local.range_mut((start, Unbounded))\n         {\n-            if let Some(data_scalar) = *data {\n-                if let Some(dtor) = dtor {\n-                    let ret = Some((*dtor, data_scalar, key));\n-                    *data = None;\n-                    return ret;\n+            match data.entry(thread_id) {\n+                Entry::Occupied(entry) => {\n+                    let (thread_id, data_scalar) = entry.remove_entry();\n+                    if let Some(dtor) = dtor {\n+                        let ret = Some((dtor, thread_id, data_scalar, key));\n+                        return ret;\n+                    }\n                 }\n+                Entry::Vacant(_) => {}\n             }\n         }\n         None\n@@ -156,6 +174,7 @@ impl<'tcx> TlsData<'tcx> {\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Run TLS destructors for the currently active thread.\n     fn run_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         assert!(!this.machine.tls.dtors_running, \"running TLS dtors twice\");\n@@ -204,28 +223,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Now run the \"keyed\" destructors.\n-        let mut dtor = this.machine.tls.fetch_tls_dtor(None);\n-        while let Some((instance, ptr, key)) = dtor {\n-            trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-            assert!(!this.is_null(ptr).unwrap(), \"data can't be NULL when dtor is called!\");\n-\n-            let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n-            this.call_function(\n-                instance,\n-                &[ptr.into()],\n-                Some(ret_place),\n-                StackPopCleanup::None { cleanup: true },\n-            )?;\n-\n-            // step until out of stackframes\n-            this.run()?;\n-\n-            // Fetch next dtor after `key`.\n-            dtor = match this.machine.tls.fetch_tls_dtor(Some(key)) {\n-                dtor @ Some(_) => dtor,\n-                // We ran each dtor once, start over from the beginning.\n-                None => this.machine.tls.fetch_tls_dtor(None),\n-            };\n+        for thread_id in this.get_all_thread_ids() {\n+            this.set_active_thread(thread_id)?;\n+            let mut dtor = this.machine.tls.fetch_tls_dtor(None, thread_id);\n+            while let Some((instance, thread_id, ptr, key)) = dtor {\n+                trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, thread_id);\n+                assert!(!this.is_null(ptr).unwrap(), \"Data can't be NULL when dtor is called!\");\n+\n+                let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n+                this.call_function(\n+                    instance,\n+                    &[ptr.into()],\n+                    Some(ret_place),\n+                    StackPopCleanup::None { cleanup: true },\n+                )?;\n+\n+                // step until out of stackframes\n+                this.run()?;\n+\n+                // Fetch next dtor after `key`.\n+                dtor = match this.machine.tls.fetch_tls_dtor(Some(key), thread_id) {\n+                    dtor @ Some(_) => dtor,\n+                    // We ran each dtor once, start over from the beginning.\n+                    None => this.machine.tls.fetch_tls_dtor(None, thread_id),\n+                };\n+            }\n         }\n         Ok(())\n     }"}, {"sha": "14ee58c2ee3e6960b1ea8e396840691a58a78169", "filename": "src/threads.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/src%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthreads.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -0,0 +1,303 @@\n+//! Implements threads.\n+\n+use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n+\n+use log::trace;\n+\n+use rustc_middle::ty;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+use crate::*;\n+\n+/// A thread identifier.\n+#[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n+pub struct ThreadId(usize);\n+\n+impl Idx for ThreadId {\n+    fn new(idx: usize) -> Self {\n+        ThreadId(idx)\n+    }\n+    fn index(self) -> usize {\n+        self.0\n+    }\n+}\n+\n+impl From<u64> for ThreadId {\n+    fn from(id: u64) -> Self {\n+        Self(id as usize)\n+    }\n+}\n+\n+/// The state of a thread.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum ThreadState {\n+    /// The thread is enabled and can be executed.\n+    Enabled,\n+    /// The thread tried to join the specified thread and is blocked until that\n+    /// thread terminates.\n+    Blocked(ThreadId),\n+    /// The thread has terminated its execution (we do not delete terminated\n+    /// threads.)\n+    Terminated,\n+}\n+\n+/// A thread.\n+pub struct Thread<'mir, 'tcx> {\n+    state: ThreadState,\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>>,\n+    /// Is the thread detached?\n+    ///\n+    /// A thread is detached if its join handle was destroyed and no other\n+    /// thread can join it.\n+    detached: bool,\n+}\n+\n+impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n+    /// Check if the thread terminated. If yes, change the state to terminated\n+    /// and return `true`.\n+    fn check_terminated(&mut self) -> bool {\n+        if self.state == ThreadState::Enabled {\n+            if self.stack.is_empty() {\n+                self.state = ThreadState::Terminated;\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{:?}\", self.state)\n+    }\n+}\n+\n+impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n+    fn default() -> Self {\n+        Self { state: ThreadState::Enabled, stack: Vec::new(), detached: false }\n+    }\n+}\n+\n+/// A set of threads.\n+#[derive(Debug)]\n+pub struct ThreadSet<'mir, 'tcx> {\n+    /// Identifier of the currently active thread.\n+    active_thread: ThreadId,\n+    /// Threads used in the program.\n+    ///\n+    /// Note that this vector also contains terminated threads.\n+    threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n+\n+    /// List of threads that just terminated. TODO: Cleanup.\n+    terminated_threads: Vec<ThreadId>,\n+}\n+\n+impl<'mir, 'tcx> Default for ThreadSet<'mir, 'tcx> {\n+    fn default() -> Self {\n+        let mut threads = IndexVec::new();\n+        threads.push(Default::default());\n+        Self {\n+            active_thread: ThreadId::new(0),\n+            threads: threads,\n+            terminated_threads: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> ThreadSet<'mir, 'tcx> {\n+    /// Borrow the stack of the active thread.\n+    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n+        &self.threads[self.active_thread].stack\n+    }\n+    /// Mutably borrow the stack of the active thread.\n+    fn active_thread_stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n+        &mut self.threads[self.active_thread].stack\n+    }\n+    /// Create a new thread and returns its id.\n+    fn create_thread(&mut self) -> ThreadId {\n+        let new_thread_id = ThreadId::new(self.threads.len());\n+        self.threads.push(Default::default());\n+        new_thread_id\n+    }\n+    /// Set an active thread and return the id of the thread that was active before.\n+    fn set_active_thread(&mut self, id: ThreadId) -> ThreadId {\n+        let active_thread_id = self.active_thread;\n+        self.active_thread = id;\n+        assert!(self.active_thread.index() < self.threads.len());\n+        active_thread_id\n+    }\n+    /// Get the id of the currently active thread.\n+    fn get_active_thread(&self) -> ThreadId {\n+        self.active_thread\n+    }\n+    /// Mark the thread as detached, which means that no other thread will try\n+    /// to join it and the thread is responsible for cleaning up.\n+    fn detach_thread(&mut self, id: ThreadId) {\n+        self.threads[id].detached = true;\n+    }\n+    /// Mark that the active thread tries to join the thread with `joined_thread_id`.\n+    fn join_thread(&mut self, joined_thread_id: ThreadId) {\n+        assert!(!self.threads[joined_thread_id].detached, \"Bug: trying to join a detached thread.\");\n+        assert_ne!(joined_thread_id, self.active_thread, \"Bug: trying to join itself\");\n+        assert!(\n+            self.threads\n+                .iter()\n+                .all(|thread| thread.state != ThreadState::Blocked(joined_thread_id)),\n+            \"Bug: multiple threads try to join the same thread.\"\n+        );\n+        if self.threads[joined_thread_id].state != ThreadState::Terminated {\n+            // The joined thread is still running, we need to wait for it.\n+            self.threads[self.active_thread].state = ThreadState::Blocked(joined_thread_id);\n+            trace!(\n+                \"{:?} blocked on {:?} when trying to join\",\n+                self.active_thread,\n+                joined_thread_id\n+            );\n+        }\n+    }\n+    /// Get ids of all threads ever allocated.\n+    fn get_all_thread_ids(&mut self) -> Vec<ThreadId> {\n+        (0..self.threads.len()).map(ThreadId::new).collect()\n+    }\n+    /// Decide which thread to run next.\n+    ///\n+    /// Returns `false` if all threads terminated.\n+    fn schedule(&mut self) -> InterpResult<'tcx, bool> {\n+        if self.threads[self.active_thread].check_terminated() {\n+            // Check if we need to unblock any threads.\n+            for (i, thread) in self.threads.iter_enumerated_mut() {\n+                if thread.state == ThreadState::Blocked(self.active_thread) {\n+                    trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n+                    thread.state = ThreadState::Enabled;\n+                }\n+            }\n+        }\n+        if self.threads[self.active_thread].state == ThreadState::Enabled {\n+            return Ok(true);\n+        }\n+        if let Some(enabled_thread) =\n+            self.threads.iter().position(|thread| thread.state == ThreadState::Enabled)\n+        {\n+            self.active_thread = ThreadId::new(enabled_thread);\n+            return Ok(true);\n+        }\n+        if self.threads.iter().all(|thread| thread.state == ThreadState::Terminated) {\n+            Ok(false)\n+        } else {\n+            throw_machine_stop!(TerminationInfo::Abort(Some(format!(\"execution deadlocked\"))))\n+        }\n+    }\n+}\n+\n+/// In Rust, a thread local variable is just a specially marked static. To\n+/// ensure a property that each memory allocation has a globally unique\n+/// allocation identifier, we create a fresh allocation id for each thread. This\n+/// data structure keeps the track of the created allocation identifiers and\n+/// their relation to the original static allocations.\n+#[derive(Clone, Debug, Default)]\n+pub struct ThreadLocalStorage {\n+    /// A map from a thread local allocation identifier to the static from which\n+    /// it was created.\n+    thread_local_origin: RefCell<FxHashMap<AllocId, AllocId>>,\n+    /// A map from a thread local static and thread id to the unique thread\n+    /// local allocation.\n+    thread_local_allocations: RefCell<FxHashMap<(AllocId, ThreadId), AllocId>>,\n+    /// The currently active thread.\n+    active_thread: Option<ThreadId>,\n+}\n+\n+impl ThreadLocalStorage {\n+    /// For static allocation identifier `original_id` get a thread local\n+    /// allocation identifier. If it is not allocated yet, allocate.\n+    pub fn get_or_register_allocation(&self, tcx: ty::TyCtxt<'_>, original_id: AllocId) -> AllocId {\n+        match self\n+            .thread_local_allocations\n+            .borrow_mut()\n+            .entry((original_id, self.active_thread.unwrap()))\n+        {\n+            Entry::Occupied(entry) => *entry.get(),\n+            Entry::Vacant(entry) => {\n+                let fresh_id = tcx.alloc_map.lock().reserve();\n+                entry.insert(fresh_id);\n+                self.thread_local_origin.borrow_mut().insert(fresh_id, original_id);\n+                trace!(\n+                    \"get_or_register_allocation(original_id={:?}) -> {:?}\",\n+                    original_id,\n+                    fresh_id\n+                );\n+                fresh_id\n+            }\n+        }\n+    }\n+    /// For thread local allocation identifier `alloc_id`, retrieve the original\n+    /// static allocation identifier from which it was created.\n+    pub fn resolve_allocation(&self, alloc_id: AllocId) -> AllocId {\n+        trace!(\"resolve_allocation(alloc_id: {:?})\", alloc_id);\n+        if let Some(original_id) = self.thread_local_origin.borrow().get(&alloc_id) {\n+            trace!(\"resolve_allocation(alloc_id: {:?}) -> {:?}\", alloc_id, original_id);\n+            *original_id\n+        } else {\n+            alloc_id\n+        }\n+    }\n+    /// Set which thread is currently active.\n+    fn set_active_thread(&mut self, active_thread: ThreadId) {\n+        self.active_thread = Some(active_thread);\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn create_thread(&mut self) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_mut();\n+        Ok(this.machine.threads.create_thread())\n+    }\n+    fn detach_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.detach_thread(thread_id);\n+        Ok(())\n+    }\n+    fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.join_thread(joined_thread_id);\n+        Ok(())\n+    }\n+    fn set_active_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_mut();\n+        this.memory.extra.tls.set_active_thread(thread_id);\n+        Ok(this.machine.threads.set_active_thread(thread_id))\n+    }\n+    fn get_active_thread(&self) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_ref();\n+        Ok(this.machine.threads.get_active_thread())\n+    }\n+    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.active_thread_stack()\n+    }\n+    fn active_thread_stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.active_thread_stack_mut()\n+    }\n+    fn get_all_thread_ids(&mut self) -> Vec<ThreadId> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.get_all_thread_ids()\n+    }\n+    /// Decide which thread to run next.\n+    ///\n+    /// Returns `false` if all threads terminated.\n+    fn schedule(&mut self) -> InterpResult<'tcx, bool> {\n+        let this = self.eval_context_mut();\n+        // Find the next thread to run.\n+        if this.machine.threads.schedule()? {\n+            let active_thread = this.machine.threads.get_active_thread();\n+            this.memory.extra.tls.set_active_thread(active_thread);\n+            Ok(true)\n+        } else {\n+            Ok(false)\n+        }\n+    }\n+}"}, {"sha": "450dea99f552f78b0f4c472fad1c8ccf7962f2b0", "filename": "tests/compile-fail/thread-spawn.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e06df3a8817cc5d5e157d4f7614c981e3320170b/tests%2Fcompile-fail%2Fthread-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e06df3a8817cc5d5e157d4f7614c981e3320170b/tests%2Fcompile-fail%2Fthread-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fthread-spawn.rs?ref=e06df3a8817cc5d5e157d4f7614c981e3320170b", "patch": "@@ -1,7 +0,0 @@\n-use std::thread;\n-\n-// error-pattern: Miri does not support threading\n-\n-fn main() {\n-    thread::spawn(|| {});\n-}"}, {"sha": "5c295d1702dd8e0a46a9eaee677a5b63bc669c6e", "filename": "tests/run-pass/concurrency/simple.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/82f17ab91714bcc8bd2a5591e90db690d449d38c/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f17ab91714bcc8bd2a5591e90db690d449d38c/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs?ref=82f17ab91714bcc8bd2a5591e90db690d449d38c", "patch": "@@ -0,0 +1,59 @@\n+use std::thread;\n+\n+fn create_and_detach() {\n+    thread::spawn(|| ());\n+}\n+\n+fn create_and_join() {\n+    thread::spawn(|| ()).join().unwrap();\n+}\n+\n+fn create_and_get_result() {\n+    let nine = thread::spawn(|| 5 + 4).join().unwrap();\n+    assert_eq!(nine, 9);\n+}\n+\n+fn create_and_leak_result() {\n+    thread::spawn(|| 7);\n+}\n+\n+fn create_nested_and_detach() {\n+    thread::spawn(|| {\n+        thread::spawn(|| ());\n+    });\n+}\n+\n+fn create_nested_and_join() {\n+    let handle = thread::spawn(|| thread::spawn(|| ()));\n+    let handle_nested = handle.join().unwrap();\n+    handle_nested.join().unwrap();\n+}\n+\n+fn create_move_in() {\n+    let x = String::from(\"Hello!\");\n+    thread::spawn(move || {\n+        assert_eq!(x.len(), 6);\n+    })\n+    .join()\n+    .unwrap();\n+}\n+\n+fn create_move_out() {\n+    let result = thread::spawn(|| {\n+        String::from(\"Hello!\")\n+    })\n+    .join()\n+    .unwrap();\n+    assert_eq!(result.len(), 6);\n+}\n+\n+fn main() {\n+    create_and_detach();\n+    create_and_join();\n+    create_and_get_result();\n+    create_and_leak_result();\n+    create_nested_and_detach();\n+    create_nested_and_join();\n+    create_move_in();\n+    create_move_out();\n+}"}]}