{"sha": "d0ad30ad976f09367da931de22a762019de25073", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYWQzMGFkOTc2ZjA5MzY3ZGE5MzFkZTIyYTc2MjAxOWRlMjUwNzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-08T16:44:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-08T16:44:29Z"}, "message": "Merge #2501 #2502 #2503\n\n2501: Fix coercion from &Foo to an inference variable in a reference r=matklad a=flodiebold\n\nWe didn't try to unify within the reference, but we should.\n\n2502: Delay legacy macro expansion r=matklad a=edwin0cheng\n\nThis PR make the following changes:\r\n\r\n* Delay legacy macro expansion such that we concentrated all item collecting macro expansion in one place.\r\n* Add `MacroDirective` to replace 3-tuples \r\n* After this refactoring, no macro is expanded recursively, hence we can remove the `MacroStackMonitor` and we handle the expansion limit by the fix-point loop count. \n\n2503: Code: check whether the LSP binary is in PATH r=matklad a=lnicola\n\nI'm not really sure about the TS changes. I just made a couple of functions async and it seems to work.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>", "tree": {"sha": "03f0b913b6fdeda01ee41f782df35c24a6591f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f0b913b6fdeda01ee41f782df35c24a6591f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ad30ad976f09367da931de22a762019de25073", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd7ShtCRBK7hj4Ov3rIwAAdHIIAARTWAmhfVbc/EzkJU14BWyo\ntQWYjZiZDMqrOyqvYNn6yxhO6vIX5cJPrtGY1T0sRltAEVs77zMLfhWoXxR38hXV\nrjaM29tIhWyPdWgXkwc0QdzSvgEqXHc6UB5HqKn4TyOyYQ9bGreLpKKH1FmVyfb4\n+PTrk2t5I8BPUs512S5/8w2oOJtvJyCBs2mOanlRU+/zTwwrciWNcvTjwHetOwkf\ny4cHRwHPcE1b94y4eAmww71xWxKSw3sRYnoUQNwdcOrt9XcUcHjry57GaqcXedpJ\ncX+70CxeOQsb2xQ3ghIMgt3s8LcbUMqMFm1o+40bvuHtaCN737Za+MguLvSsR00=\n=G0Y5\n-----END PGP SIGNATURE-----\n", "payload": "tree 03f0b913b6fdeda01ee41f782df35c24a6591f08\nparent d27b03388326c91c7fb242e64bcc6037bb9140fe\nparent d0c9bb0abf764a3143fc0d13297d73184bc10397\nparent 3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4\nparent 78e8934976fa3135c151d2b6b395ce57e832f90e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575823469 +0000\ncommitter GitHub <noreply@github.com> 1575823469 +0000\n\nMerge #2501 #2502 #2503\n\n2501: Fix coercion from &Foo to an inference variable in a reference r=matklad a=flodiebold\n\nWe didn't try to unify within the reference, but we should.\n\n2502: Delay legacy macro expansion r=matklad a=edwin0cheng\n\nThis PR make the following changes:\r\n\r\n* Delay legacy macro expansion such that we concentrated all item collecting macro expansion in one place.\r\n* Add `MacroDirective` to replace 3-tuples \r\n* After this refactoring, no macro is expanded recursively, hence we can remove the `MacroStackMonitor` and we handle the expansion limit by the fix-point loop count. \n\n2503: Code: check whether the LSP binary is in PATH r=matklad a=lnicola\n\nI'm not really sure about the TS changes. I just made a couple of functions async and it seems to work.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ad30ad976f09367da931de22a762019de25073", "html_url": "https://github.com/rust-lang/rust/commit/d0ad30ad976f09367da931de22a762019de25073", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ad30ad976f09367da931de22a762019de25073/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d27b03388326c91c7fb242e64bcc6037bb9140fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27b03388326c91c7fb242e64bcc6037bb9140fe", "html_url": "https://github.com/rust-lang/rust/commit/d27b03388326c91c7fb242e64bcc6037bb9140fe"}, {"sha": "d0c9bb0abf764a3143fc0d13297d73184bc10397", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0c9bb0abf764a3143fc0d13297d73184bc10397", "html_url": "https://github.com/rust-lang/rust/commit/d0c9bb0abf764a3143fc0d13297d73184bc10397"}, {"sha": "3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4", "html_url": "https://github.com/rust-lang/rust/commit/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4"}, {"sha": "78e8934976fa3135c151d2b6b395ce57e832f90e", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e8934976fa3135c151d2b6b395ce57e832f90e", "html_url": "https://github.com/rust-lang/rust/commit/78e8934976fa3135c151d2b6b395ce57e832f90e"}], "stats": {"total": 298, "additions": 140, "deletions": 158}, "files": [{"sha": "979e4ef88ae91069bc069764868367a27740bfe0", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -37,7 +37,8 @@ $ cargo xtask install\n $ cargo xtask install --server\n ```\n \n-For non-standard setup of VS Code and other editors, see [./docs/user](./docs/user).\n+For non-standard setup of VS Code and other editors, or if the language server\n+cannot start, see [./docs/user](./docs/user).\n \n ## Documentation\n "}, {"sha": "a80067979fa3dd785975afe695793fdc41708611", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 57, "deletions": 149, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -12,7 +12,7 @@ use hir_expand::{\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n use ra_syntax::ast;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n@@ -63,42 +63,12 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         unexpanded_macros: Vec::new(),\n         unexpanded_attribute_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n-        macro_stack_monitor: MacroStackMonitor::default(),\n-        poison_macros: FxHashSet::default(),\n         cfg_options,\n     };\n     collector.collect();\n     collector.finish()\n }\n \n-#[derive(Default)]\n-struct MacroStackMonitor {\n-    counts: FxHashMap<MacroDefId, u32>,\n-\n-    /// Mainly use for test\n-    validator: Option<Box<dyn Fn(u32) -> bool>>,\n-}\n-\n-impl MacroStackMonitor {\n-    fn increase(&mut self, macro_def_id: MacroDefId) {\n-        *self.counts.entry(macro_def_id).or_default() += 1;\n-    }\n-\n-    fn decrease(&mut self, macro_def_id: MacroDefId) {\n-        *self.counts.entry(macro_def_id).or_default() -= 1;\n-    }\n-\n-    fn is_poison(&self, macro_def_id: MacroDefId) -> bool {\n-        let cur = *self.counts.get(&macro_def_id).unwrap_or(&0);\n-\n-        if let Some(validator) = &self.validator {\n-            validator(cur)\n-        } else {\n-            cur > 100\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n enum PartialResolvedImport {\n     /// None of any namespaces is resolved\n@@ -127,32 +97,24 @@ struct ImportDirective {\n     status: PartialResolvedImport,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct MacroDirective {\n+    module_id: LocalModuleId,\n+    ast_id: AstId<ast::MacroCall>,\n+    path: Path,\n+    legacy: Option<MacroCallId>,\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n-    unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n+    unexpanded_macros: Vec<MacroDirective>,\n     unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, Path)>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n-\n-    /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n-    /// To prevent stack overflow, we add a deep counter here for prevent that.\n-    macro_stack_monitor: MacroStackMonitor,\n-    /// Some macros are not well-behavior, which leads to infinite loop\n-    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n-    /// We mark it down and skip it in collector\n-    ///\n-    /// FIXME:\n-    /// Right now it only handle a poison macro in a single crate,\n-    /// such that if other crate try to call that macro,\n-    /// the whole process will do again until it became poisoned in that crate.\n-    /// We should handle this macro set globally\n-    /// However, do we want to put it as a global variable?\n-    poison_macros: FxHashSet<MacroDefId>,\n-\n     cfg_options: &'a CfgOptions,\n }\n \n@@ -556,18 +518,24 @@ where\n             std::mem::replace(&mut self.unexpanded_attribute_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, ast_id, path)| {\n+        macros.retain(|directive| {\n+            if let Some(call_id) = directive.legacy {\n+                res = ReachedFixedPoint::No;\n+                resolved.push((directive.module_id, call_id));\n+                return false;\n+            }\n+\n             let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n                 ResolveMode::Other,\n-                *module_id,\n-                path,\n+                directive.module_id,\n+                &directive.path,\n                 BuiltinShadowMode::Module,\n             );\n \n             if let Some(def) = resolved_res.resolved_def.take_macros() {\n-                let call_id = def.as_call_id(self.db, MacroCallKind::FnLike(*ast_id));\n-                resolved.push((*module_id, call_id, def));\n+                let call_id = def.as_call_id(self.db, MacroCallKind::FnLike(directive.ast_id));\n+                resolved.push((directive.module_id, call_id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -579,7 +547,7 @@ where\n \n             if let Some(def) = resolved_res {\n                 let call_id = def.as_call_id(self.db, MacroCallKind::Attr(*ast_id));\n-                resolved.push((*module_id, call_id, def));\n+                resolved.push((*module_id, call_id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -590,8 +558,8 @@ where\n         self.unexpanded_macros = macros;\n         self.unexpanded_attribute_macros = attribute_macros;\n \n-        for (module_id, macro_call_id, macro_def_id) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id);\n+        for (module_id, macro_call_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id);\n         }\n \n         res\n@@ -611,36 +579,18 @@ where\n         None\n     }\n \n-    fn collect_macro_expansion(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        macro_call_id: MacroCallId,\n-        macro_def_id: MacroDefId,\n-    ) {\n-        if self.poison_macros.contains(&macro_def_id) {\n-            return;\n-        }\n-\n-        self.macro_stack_monitor.increase(macro_def_id);\n-\n-        if !self.macro_stack_monitor.is_poison(macro_def_id) {\n-            let file_id: HirFileId = macro_call_id.as_file();\n-            let raw_items = self.db.raw_items(file_id);\n-            let mod_dir = self.mod_dirs[&module_id].clone();\n-            ModCollector {\n-                def_collector: &mut *self,\n-                file_id,\n-                module_id,\n-                raw_items: &raw_items,\n-                mod_dir,\n-            }\n-            .collect(raw_items.items());\n-        } else {\n-            log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n-            self.poison_macros.insert(macro_def_id);\n+    fn collect_macro_expansion(&mut self, module_id: LocalModuleId, macro_call_id: MacroCallId) {\n+        let file_id: HirFileId = macro_call_id.as_file();\n+        let raw_items = self.db.raw_items(file_id);\n+        let mod_dir = self.mod_dirs[&module_id].clone();\n+        ModCollector {\n+            def_collector: &mut *self,\n+            file_id,\n+            module_id,\n+            raw_items: &raw_items,\n+            mod_dir,\n         }\n-\n-        self.macro_stack_monitor.decrease(macro_def_id);\n+        .collect(raw_items.items());\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -908,15 +858,20 @@ where\n             return;\n         }\n \n-        // Case 2: try to resolve in legacy scope and expand macro_rules, triggering\n-        // recursive item collection.\n+        // Case 2: try to resolve in legacy scope and expand macro_rules\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n             let macro_call_id =\n                 macro_def.as_call_id(self.def_collector.db, MacroCallKind::FnLike(ast_id));\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_def);\n+            self.def_collector.unexpanded_macros.push(MacroDirective {\n+                module_id: self.module_id,\n+                path: mac.path.clone(),\n+                ast_id,\n+                legacy: Some(macro_call_id),\n+            });\n+\n             return;\n         }\n \n@@ -926,7 +881,13 @@ where\n         if path.is_ident() {\n             path.kind = PathKind::Self_;\n         }\n-        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n+\n+        self.def_collector.unexpanded_macros.push(MacroDirective {\n+            module_id: self.module_id,\n+            path,\n+            ast_id,\n+            legacy: None,\n+        });\n     }\n \n     fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {\n@@ -951,19 +912,13 @@ fn is_macro_rules(path: &Path) -> bool {\n \n #[cfg(test)]\n mod tests {\n+    use crate::{db::DefDatabase, test_db::TestDB};\n     use ra_arena::Arena;\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use rustc_hash::FxHashSet;\n-\n-    use crate::{db::DefDatabase, test_db::TestDB};\n \n     use super::*;\n \n-    fn do_collect_defs(\n-        db: &impl DefDatabase,\n-        def_map: CrateDefMap,\n-        monitor: MacroStackMonitor,\n-    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n+    fn do_collect_defs(db: &impl DefDatabase, def_map: CrateDefMap) -> CrateDefMap {\n         let mut collector = DefCollector {\n             db,\n             def_map,\n@@ -973,19 +928,13 @@ mod tests {\n             unexpanded_macros: Vec::new(),\n             unexpanded_attribute_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n-            macro_stack_monitor: monitor,\n-            poison_macros: FxHashSet::default(),\n             cfg_options: &CfgOptions::default(),\n         };\n         collector.collect();\n-        (collector.def_map, collector.poison_macros)\n+        collector.def_map\n     }\n \n-    fn do_limited_resolve(\n-        code: &str,\n-        limit: u32,\n-        poison_limit: u32,\n-    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n+    fn do_resolve(code: &str) -> CrateDefMap {\n         let (db, _file_id) = TestDB::with_single_file(&code);\n         let krate = db.test_crate();\n \n@@ -1003,59 +952,18 @@ mod tests {\n                 diagnostics: Vec::new(),\n             }\n         };\n-\n-        let mut monitor = MacroStackMonitor::default();\n-        monitor.validator = Some(Box::new(move |count| {\n-            assert!(count < limit);\n-            count >= poison_limit\n-        }));\n-\n-        do_collect_defs(&db, def_map, monitor)\n+        do_collect_defs(&db, def_map)\n     }\n \n     #[test]\n-    fn test_macro_expand_limit_width() {\n-        do_limited_resolve(\n+    fn test_macro_expand_will_stop() {\n+        do_resolve(\n             r#\"\n         macro_rules! foo {\n             ($($ty:ty)*) => { foo!($($ty)*, $($ty)*); }\n         }\n foo!(KABOOM);\n         \"#,\n-            16,\n-            1000,\n         );\n     }\n-\n-    #[test]\n-    fn test_macro_expand_poisoned() {\n-        let (_, poison_macros) = do_limited_resolve(\n-            r#\"\n-        macro_rules! foo {\n-            ($ty:ty) => { foo!($ty); }\n-        }\n-foo!(KABOOM);\n-        \"#,\n-            100,\n-            16,\n-        );\n-\n-        assert_eq!(poison_macros.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_macro_expand_normal() {\n-        let (_, poison_macros) = do_limited_resolve(\n-            r#\"\n-        macro_rules! foo {\n-            ($ident:ident) => { struct $ident {} }\n-        }\n-foo!(Bar);\n-        \"#,\n-            16,\n-            16,\n-        );\n-\n-        assert_eq!(poison_macros.len(), 0);\n-    }\n }"}, {"sha": "0f4dac45edf2b454117bc9ed96af9e133815205e", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -332,7 +332,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     // It will not recurse to `coerce`.\n                     return self.table.unify_substs(st1, st2, 0);\n                 }\n-                _ => {}\n+                _ => {\n+                    if self.table.unify_inner_trivial(&derefed_ty, &to_ty) {\n+                        return true;\n+                    }\n+                }\n             }\n         }\n "}, {"sha": "ac9e3872a5bdcc672e9481b800dca2c06093cf7c", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -403,3 +403,40 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn coerce_autoderef_generic() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+struct Foo;\n+fn takes_ref<T>(x: &T) -> T { *x }\n+fn test() {\n+    takes_ref(&Foo);\n+    takes_ref(&&Foo);\n+    takes_ref(&&&Foo);\n+}\n+\"#, true),\n+        @r###\"\n+    [29; 30) 'x': &T\n+    [41; 47) '{ *x }': T\n+    [43; 45) '*x': T\n+    [44; 45) 'x': &T\n+    [58; 127) '{     ...oo); }': ()\n+    [64; 73) 'takes_ref': fn takes_ref<Foo>(&T) -> T\n+    [64; 79) 'takes_ref(&Foo)': Foo\n+    [74; 78) '&Foo': &Foo\n+    [75; 78) 'Foo': Foo\n+    [85; 94) 'takes_ref': fn takes_ref<&Foo>(&T) -> T\n+    [85; 101) 'takes_...&&Foo)': &Foo\n+    [95; 100) '&&Foo': &&Foo\n+    [96; 100) '&Foo': &Foo\n+    [97; 100) 'Foo': Foo\n+    [107; 116) 'takes_ref': fn takes_ref<&&Foo>(&T) -> T\n+    [107; 124) 'takes_...&&Foo)': &&Foo\n+    [117; 123) '&&&Foo': &&&Foo\n+    [118; 123) '&&Foo': &&Foo\n+    [119; 123) '&Foo': &Foo\n+    [120; 123) 'Foo': Foo\n+    \"###\n+    );\n+}"}, {"sha": "04c3493426b6abd6ff2a19d529f2c70626d2f67e", "filename": "docs/user/README.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -204,4 +204,19 @@ Installation:\n \n * You can now invoke the command palette and type LSP enable to locally/globally enable the rust-analyzer LSP (type LSP enable, then choose either locally or globally, then select rust-analyzer)\n \n-* Note that `ra_lsp_server` binary must be in `$PATH` for this to work. If it's not the case, you can specify full path to the binary, which is typically `.cargo/bin/ra_lsp_server`.\n+### Setting up the `PATH` variable\n+\n+On Unix systems, `rustup` adds `~/.cargo/bin` to `PATH` by modifying the shell's\n+startup file. Depending on your configuration, your Desktop Environment might not\n+actually load it. If you find that `rust-analyzer` only runs when starting the\n+editor from the terminal, you will have to set up your `PATH` variable manually.\n+\n+There are a couple of ways to do that:\n+\n+- for Code, set `rust-analyzer.raLspServerPath` to `~/.cargo/bin` (the `~` is\n+  automatically resolved by the extension)\n+- copy the binary to a location that is already in `PATH`, e.g. `/usr/local/bin`\n+- on Linux, use PAM to configure the `PATH` variable, by e.g. putting\n+  `PATH DEFAULT=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:@{HOME}/.cargo/bin:@{HOME}/.local/bin`\n+  in your `~/.pam_environment` file; note that this might interfere with other\n+  defaults set by the system administrator via `/etc/environment`."}, {"sha": "099aaaaa2ad48291173e110f8723eef5e5dc996d", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -763,6 +763,11 @@\n                 \"chalk\": \"^2.0.1\"\n             }\n         },\n+        \"lookpath\": {\n+            \"version\": \"1.0.3\",\n+            \"resolved\": \"https://registry.npmjs.org/lookpath/-/lookpath-1.0.3.tgz\",\n+            \"integrity\": \"sha512-XIdgzlX26g10XnzyZdO/4obybEmfGnZyWQZ2DgmmEfVB79X+n3lhUoIzMe501C6s7RmCpAo66OPegWc+CsxYMg==\"\n+        },\n         \"magic-string\": {\n             \"version\": \"0.25.3\",\n             \"resolved\": \"https://registry.npmjs.org/magic-string/-/magic-string-0.25.3.tgz\","}, {"sha": "5dea8fac0a9a8bf4281e11427fa4664c478e50d6", "filename": "editors/code/package.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -31,6 +31,7 @@\n         \"singleQuote\": true\n     },\n     \"dependencies\": {\n+        \"lookpath\": \"^1.0.3\",\n         \"seedrandom\": \"^3.0.1\",\n         \"vscode-languageclient\": \"^5.3.0-next.4\"\n     },"}, {"sha": "6637c3bf0bd45e374e3af827bddfa64f7b58455e", "filename": "editors/code/src/extension.ts", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fextension.ts?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -14,7 +14,7 @@ import * as events from './events';\n import * as notifications from './notifications';\n import { Server } from './server';\n \n-export function activate(context: vscode.ExtensionContext) {\n+export async function activate(context: vscode.ExtensionContext) {\n     function disposeOnDeactivation(disposable: vscode.Disposable) {\n         context.subscriptions.push(disposable);\n     }\n@@ -159,7 +159,11 @@ export function activate(context: vscode.ExtensionContext) {\n     });\n \n     // Start the language server, finally!\n-    startServer();\n+    try {\n+        await startServer();\n+    } catch (e) {\n+        vscode.window.showErrorMessage(e.message);\n+    }\n \n     if (Server.config.displayInlayHints) {\n         const hintsUpdater = new HintsUpdater();\n@@ -204,10 +208,10 @@ export function deactivate(): Thenable<void> {\n     return Server.client.stop();\n }\n \n-async function reloadServer(startServer: () => void) {\n+async function reloadServer(startServer: () => Promise<void>) {\n     if (Server.client != null) {\n         vscode.window.showInformationMessage('Reloading rust-analyzer...');\n         await Server.client.stop();\n-        startServer();\n+        await startServer();\n     }\n }"}, {"sha": "e717ab294d7f355e25c9d4e8f1b6e16be631897b", "filename": "editors/code/src/server.ts", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fsrc%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad30ad976f09367da931de22a762019de25073/editors%2Fcode%2Fsrc%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fserver.ts?ref=d0ad30ad976f09367da931de22a762019de25073", "patch": "@@ -1,3 +1,4 @@\n+import { lookpath } from 'lookpath';\n import { homedir } from 'os';\n import * as lc from 'vscode-languageclient';\n \n@@ -17,7 +18,7 @@ export class Server {\n     public static config = new Config();\n     public static client: lc.LanguageClient;\n \n-    public static start(\n+    public static async start(\n         notificationHandlers: Iterable<[string, lc.GenericNotificationHandler]>\n     ) {\n         // '.' Is the fallback if no folder is open\n@@ -27,8 +28,14 @@ export class Server {\n             folder = workspace.workspaceFolders[0].uri.fsPath.toString();\n         }\n \n+        const command = expandPathResolving(this.config.raLspServerPath);\n+        if (!(await lookpath(command))) {\n+            throw new Error(\n+                `Cannot find rust-analyzer server \\`${command}\\` in PATH.`\n+            );\n+        }\n         const run: lc.Executable = {\n-            command: expandPathResolving(this.config.raLspServerPath),\n+            command,\n             options: { cwd: folder }\n         };\n         const serverOptions: lc.ServerOptions = {"}]}