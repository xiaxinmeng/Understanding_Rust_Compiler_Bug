{"sha": "a937d1875eba9367c9a4b43d1a9b113ecbf72b37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MzdkMTg3NWViYTkzNjdjOWE0YjQzZDFhOWIxMTNlY2JmNzJiMzc=", "commit": {"author": {"name": "Derek Chiang", "email": "derekchiang93@gmail.com", "date": "2014-01-22T15:39:09Z"}, "committer": {"name": "Derek Chiang", "email": "derekchiang93@gmail.com", "date": "2014-01-25T16:59:29Z"}, "message": "Implement barrier.", "tree": {"sha": "6a15d6b822ded2e8eb05bbaba60d6e372a40dc5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a15d6b822ded2e8eb05bbaba60d6e372a40dc5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a937d1875eba9367c9a4b43d1a9b113ecbf72b37", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a937d1875eba9367c9a4b43d1a9b113ecbf72b37", "html_url": "https://github.com/rust-lang/rust/commit/a937d1875eba9367c9a4b43d1a9b113ecbf72b37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a937d1875eba9367c9a4b43d1a9b113ecbf72b37/comments", "author": {"login": "derekchiang", "id": 1535686, "node_id": "MDQ6VXNlcjE1MzU2ODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/derekchiang", "html_url": "https://github.com/derekchiang", "followers_url": "https://api.github.com/users/derekchiang/followers", "following_url": "https://api.github.com/users/derekchiang/following{/other_user}", "gists_url": "https://api.github.com/users/derekchiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/derekchiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/derekchiang/subscriptions", "organizations_url": "https://api.github.com/users/derekchiang/orgs", "repos_url": "https://api.github.com/users/derekchiang/repos", "events_url": "https://api.github.com/users/derekchiang/events{/privacy}", "received_events_url": "https://api.github.com/users/derekchiang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "derekchiang", "id": 1535686, "node_id": "MDQ6VXNlcjE1MzU2ODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/derekchiang", "html_url": "https://github.com/derekchiang", "followers_url": "https://api.github.com/users/derekchiang/followers", "following_url": "https://api.github.com/users/derekchiang/following{/other_user}", "gists_url": "https://api.github.com/users/derekchiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/derekchiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/derekchiang/subscriptions", "organizations_url": "https://api.github.com/users/derekchiang/orgs", "repos_url": "https://api.github.com/users/derekchiang/repos", "events_url": "https://api.github.com/users/derekchiang/events{/privacy}", "received_events_url": "https://api.github.com/users/derekchiang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de57a22b9a8c8416cace31c9bd3ec4c9a6888017", "url": "https://api.github.com/repos/rust-lang/rust/commits/de57a22b9a8c8416cace31c9bd3ec4c9a6888017", "html_url": "https://github.com/rust-lang/rust/commit/de57a22b9a8c8416cace31c9bd3ec4c9a6888017"}], "stats": {"total": 95, "additions": 95, "deletions": 0}, "files": [{"sha": "c4277bddac7187e680b66deba0e62dbdd39e58e0", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a937d1875eba9367c9a4b43d1a9b113ecbf72b37/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a937d1875eba9367c9a4b43d1a9b113ecbf72b37/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=a937d1875eba9367c9a4b43d1a9b113ecbf72b37", "patch": "@@ -27,6 +27,8 @@ use std::unstable::finally::Finally;\n use std::util;\n use std::util::NonCopyable;\n \n+use arc::MutexArc;\n+\n /****************************************************************************\n  * Internals\n  ****************************************************************************/\n@@ -682,6 +684,67 @@ impl<'a> RWLockReadMode<'a> {\n     pub fn read<U>(&self, blk: || -> U) -> U { blk() }\n }\n \n+/// A barrier enables multiple tasks to synchronize the beginning\n+/// of some computation.\n+/// ```rust\n+/// use extra::sync::Barrier;\n+///\n+/// let barrier = Barrier::new(10);\n+/// 10.times(|| {\n+///     let c = barrier.clone();\n+///     // The same messages will be printed together.\n+///     // You will NOT see any interleaving.\n+///     do spawn {\n+///         println!(\"before wait\");\n+///         c.wait();\n+///         println!(\"after wait\");\n+///     }\n+/// });\n+/// ```\n+#[deriving(Clone)]\n+pub struct Barrier {\n+    priv arc: MutexArc<BarrierState>,\n+    priv num_tasks: uint,\n+}\n+\n+// The inner state of a double barrier\n+struct BarrierState {\n+    priv count: uint,\n+    priv generation_id: uint,\n+}\n+\n+impl Barrier {\n+    /// Create a new barrier that can block a given number of tasks.\n+    pub fn new(num_tasks: uint) -> Barrier {\n+        Barrier {\n+            arc: MutexArc::new(BarrierState {\n+                count: 0,\n+                generation_id: 0,\n+            }),\n+            num_tasks: num_tasks,\n+        }\n+    }\n+\n+    /// Block the current task until a certain number of tasks is waiting.\n+    pub fn wait(&self) {\n+        self.arc.access_cond(|state, cond| {\n+            let local_gen = state.generation_id;\n+            state.count += 1;\n+            if state.count < self.num_tasks {\n+                // We need a while loop to guard against spurious wakeups.\n+                // http://en.wikipedia.org/wiki/Spurious_wakeup\n+                while local_gen == state.generation_id && state.count < self.num_tasks {\n+                    cond.wait();\n+                }\n+            } else {\n+                state.count = 0;\n+                state.generation_id += 1;\n+                cond.broadcast();\n+            }\n+        });\n+    }\n+}\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n@@ -693,6 +756,7 @@ mod tests {\n     use std::cast;\n     use std::result;\n     use std::task;\n+    use std::comm::{SharedChan, Empty};\n \n     /************************************************************************\n      * Semaphore tests\n@@ -1315,4 +1379,35 @@ mod tests {\n             })\n         })\n     }\n+\n+    /************************************************************************\n+     * Barrier tests\n+     ************************************************************************/\n+    #[test]\n+    fn test_barrier() {\n+        let barrier = Barrier::new(10);\n+        let (port, chan) = SharedChan::new();\n+\n+        9.times(|| {\n+            let c = barrier.clone();\n+            let chan = chan.clone();\n+            do spawn {\n+                c.wait();\n+                chan.send(true);\n+            }\n+        });\n+\n+        // At this point, all spawned tasks should be blocked,\n+        // so we shouldn't get anything from the port\n+        assert!(match port.try_recv() {\n+            Empty => true,\n+            _ => false,\n+        });\n+\n+        barrier.wait();\n+        // Now, the barrier is cleared and we should get data.\n+        9.times(|| {\n+            port.recv();\n+        });\n+    }\n }"}]}