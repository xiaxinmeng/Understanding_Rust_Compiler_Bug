{"sha": "e387ec9cbf53af36228684b3d095228a1b351f16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzODdlYzljYmY1M2FmMzYyMjg2ODRiM2QwOTUyMjhhMWIzNTFmMTY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-26T16:17:22Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-26T16:57:48Z"}, "message": "Fix ABI for Indirect arguments\n\nIn case of PassMode::Indirect, the ownership of the backing storage is\ntransfered to the callee. This means that the caller must copy the\nargument if it wants to use it again later.\n\nFixes #691", "tree": {"sha": "2d945fcf09518bfbcffba93aa6e1cd7347c258e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d945fcf09518bfbcffba93aa6e1cd7347c258e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e387ec9cbf53af36228684b3d095228a1b351f16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e387ec9cbf53af36228684b3d095228a1b351f16", "html_url": "https://github.com/rust-lang/rust/commit/e387ec9cbf53af36228684b3d095228a1b351f16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e387ec9cbf53af36228684b3d095228a1b351f16/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2abc12daada0f7a12285902eb3faacd279316e11", "url": "https://api.github.com/repos/rust-lang/rust/commits/2abc12daada0f7a12285902eb3faacd279316e11", "html_url": "https://github.com/rust-lang/rust/commit/2abc12daada0f7a12285902eb3faacd279316e11"}], "stats": {"total": 96, "additions": 61, "deletions": 35}, "files": [{"sha": "0478d4b198afcdc4ad63ac4621da10830ce5e69d", "filename": "src/abi/mod.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e387ec9cbf53af36228684b3d095228a1b351f16/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e387ec9cbf53af36228684b3d095228a1b351f16/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=e387ec9cbf53af36228684b3d095228a1b351f16", "patch": "@@ -235,27 +235,20 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n         // not mutated by the current function, this is necessary to support unsized arguments.\n         if let ArgKind::Normal(Some(val)) = arg_kind {\n             if let Some((addr, meta)) = val.try_to_ptr() {\n-                let local_decl = &fx.mir.local_decls[local];\n-                //                       v this ! is important\n-                let internally_mutable = !val\n-                    .layout()\n-                    .ty\n-                    .is_freeze(fx.tcx.at(local_decl.source_info.span), ParamEnv::reveal_all());\n-                if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n-                    // We wont mutate this argument, so it is fine to borrow the backing storage\n-                    // of this argument, to prevent a copy.\n-\n-                    let place = if let Some(meta) = meta {\n-                        CPlace::for_ptr_with_extra(addr, meta, val.layout())\n-                    } else {\n-                        CPlace::for_ptr(addr, val.layout())\n-                    };\n-\n-                    self::comments::add_local_place_comments(fx, place, local);\n-\n-                    assert_eq!(fx.local_map.push(place), local);\n-                    continue;\n-                }\n+                // Ownership of the value at the backing storage for an argument is passed to the\n+                // callee per the ABI, so it is fine to borrow the backing storage of this argument\n+                // to prevent a copy.\n+\n+                let place = if let Some(meta) = meta {\n+                    CPlace::for_ptr_with_extra(addr, meta, val.layout())\n+                } else {\n+                    CPlace::for_ptr(addr, val.layout())\n+                };\n+\n+                self::comments::add_local_place_comments(fx, place, local);\n+\n+                assert_eq!(fx.local_map.push(place), local);\n+                continue;\n             }\n         }\n \n@@ -291,6 +284,22 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     fx.bcx.ins().jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n }\n \n+struct CallArgument<'tcx> {\n+    value: CValue<'tcx>,\n+    is_owned: bool,\n+}\n+\n+// FIXME avoid intermediate `CValue` before calling `adjust_arg_for_abi`\n+fn codegen_call_argument_operand<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    operand: &Operand<'tcx>,\n+) -> CallArgument<'tcx> {\n+    CallArgument {\n+        value: codegen_operand(fx, operand),\n+        is_owned: matches!(operand, Operand::Move(_)),\n+    }\n+}\n+\n pub(crate) fn codegen_terminator_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n@@ -361,28 +370,31 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // Unpack arguments tuple for closures\n     let mut args = if fn_sig.abi == Abi::RustCall {\n         assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n-        let self_arg = codegen_operand(fx, &args[0]);\n-        let pack_arg = codegen_operand(fx, &args[1]);\n+        let self_arg = codegen_call_argument_operand(fx, &args[0]);\n+        let pack_arg = codegen_call_argument_operand(fx, &args[1]);\n \n-        let tupled_arguments = match pack_arg.layout().ty.kind() {\n+        let tupled_arguments = match pack_arg.value.layout().ty.kind() {\n             ty::Tuple(ref tupled_arguments) => tupled_arguments,\n             _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n         };\n \n         let mut args = Vec::with_capacity(1 + tupled_arguments.len());\n         args.push(self_arg);\n         for i in 0..tupled_arguments.len() {\n-            args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n+            args.push(CallArgument {\n+                value: pack_arg.value.value_field(fx, mir::Field::new(i)),\n+                is_owned: pack_arg.is_owned,\n+            });\n         }\n         args\n     } else {\n-        args.iter().map(|arg| codegen_operand(fx, arg)).collect::<Vec<_>>()\n+        args.iter().map(|arg| codegen_call_argument_operand(fx, arg)).collect::<Vec<_>>()\n     };\n \n     // Pass the caller location for `#[track_caller]`.\n     if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n         let caller_location = fx.get_caller_location(span);\n-        args.push(caller_location);\n+        args.push(CallArgument { value: caller_location, is_owned: false });\n     }\n \n     let args = args;\n@@ -404,7 +416,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 );\n             }\n \n-            let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n+            let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0].value, idx);\n             let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n             let sig = fx.bcx.import_signature(sig);\n \n@@ -441,7 +453,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 args.into_iter()\n                     .enumerate()\n                     .skip(if first_arg_override.is_some() { 1 } else { 0 })\n-                    .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n+                    .map(|(i, arg)| {\n+                        adjust_arg_for_abi(fx, arg.value, &fn_abi.args[i], arg.is_owned).into_iter()\n+                    })\n                     .flatten(),\n             )\n             .collect::<Vec<Value>>();\n@@ -529,15 +543,15 @@ pub(crate) fn codegen_drop<'tcx>(\n                         TypeAndMut { ty, mutbl: crate::rustc_hir::Mutability::Mut },\n                     )),\n                 );\n-                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);\n+                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0], true);\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n \n                 if drop_instance.def.requires_caller_location(fx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n                     let caller_location = fx.get_caller_location(span);\n                     call_args.extend(\n-                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1]).into_iter(),\n+                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1], false).into_iter(),\n                     );\n                 }\n "}, {"sha": "44eae706ea8f6df56448214f8afab5383bc67ade", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e387ec9cbf53af36228684b3d095228a1b351f16/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e387ec9cbf53af36228684b3d095228a1b351f16/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=e387ec9cbf53af36228684b3d095228a1b351f16", "patch": "@@ -227,6 +227,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+    is_owned: bool,\n ) -> SmallVec<[Value; 2]> {\n     assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n     match arg_abi.mode {\n@@ -237,10 +238,21 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             smallvec![a, b]\n         }\n         PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n-        PassMode::Indirect { .. } => match arg.force_stack(fx) {\n-            (ptr, None) => smallvec![ptr.get_addr(fx)],\n-            (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n-        },\n+        PassMode::Indirect { .. } => {\n+            if is_owned {\n+                match arg.force_stack(fx) {\n+                    (ptr, None) => smallvec![ptr.get_addr(fx)],\n+                    (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n+                }\n+            } else {\n+                // Ownership of the value at the backing storage for an argument is passed to the\n+                // callee per the ABI, so we must make a copy of the argument unless the argument\n+                // local is moved.\n+                let place = CPlace::new_stack_slot(fx, arg.layout());\n+                place.write_cvalue(fx, arg);\n+                smallvec![place.to_ptr().get_addr(fx)]\n+            }\n+        }\n     }\n }\n "}]}