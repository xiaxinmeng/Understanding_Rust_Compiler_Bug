{"sha": "d0512b1055eac15db86d83c994fb546cbfa62676", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNTEyYjEwNTVlYWMxNWRiODZkODNjOTk0ZmI1NDZjYmZhNjI2NzY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T09:48:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T12:36:09Z"}, "message": "Convert vec::[mut_]slice to methods, remove vec::const_slice.", "tree": {"sha": "ee6cc275e50b1dd6ba004b306f4c909dd45ba09f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee6cc275e50b1dd6ba004b306f4c909dd45ba09f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0512b1055eac15db86d83c994fb546cbfa62676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0512b1055eac15db86d83c994fb546cbfa62676", "html_url": "https://github.com/rust-lang/rust/commit/d0512b1055eac15db86d83c994fb546cbfa62676", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0512b1055eac15db86d83c994fb546cbfa62676/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "html_url": "https://github.com/rust-lang/rust/commit/f1e09d6f1faa6e4d7d4d19123d1633fce370e145"}], "stats": {"total": 349, "additions": 151, "deletions": 198}, "files": [{"sha": "a31e0b961f7f2bad7e72b9a740ca620ebe6ba9f9", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -321,8 +321,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        vec::slice(props.error_patterns, next_err_idx,\n-                   props.error_patterns.len());\n+        props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n         fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n                            missing_patterns[0]), ProcRes);"}, {"sha": "e9c6ac722124daa4a7d2f419681cd80f9d132556", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use core::uint;\n-use core::vec;\n \n use digest::Digest;\n \n@@ -118,7 +117,7 @@ impl Engine512 {\n         }\n \n         while in.len() - i >= 8 {\n-            let w = to_u64(vec::slice(in, i, i + 8));\n+            let w = to_u64(in.slice(i, i + 8));\n             self.process_word(w);\n             self.bit_counter.add_bytes(8);\n             i += 8;\n@@ -274,43 +273,43 @@ impl Engine512 {\n     fn result_512(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n-        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n-        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n-        from_u64(self.H6, vec::mut_slice(out, 48, 56));\n-        from_u64(self.H7, vec::mut_slice(out, 56, 64));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n+        from_u64(self.H4, out.mut_slice(32, 40));\n+        from_u64(self.H5, out.mut_slice(40, 48));\n+        from_u64(self.H6, out.mut_slice(48, 56));\n+        from_u64(self.H7, out.mut_slice(56, 64));\n     }\n \n     fn result_384(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n-        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n-        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n+        from_u64(self.H4, out.mut_slice(32, 40));\n+        from_u64(self.H5, out.mut_slice(40, 48));\n     }\n \n     fn result_256(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n     }\n \n     fn result_224(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u32((self.H3 >> 32) as u32, vec::mut_slice(out, 24, 28));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u32((self.H3 >> 32) as u32, out.mut_slice(24, 28));\n     }\n }\n \n@@ -400,7 +399,7 @@ impl Engine256 {\n         }\n \n         while in.len() - i >= 4 {\n-            let w = to_u32(vec::slice(in, i, i + 4));\n+            let w = to_u32(in.slice(i, i + 4));\n             self.process_word(w);\n             self.length_bytes += 4;\n             i += 4;\n@@ -556,26 +555,26 @@ impl Engine256 {\n     fn result_256(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n-        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n-        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n-        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n-        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n-        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n-        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n-        from_u32(self.H7, vec::mut_slice(out, 28, 32));\n+        from_u32(self.H0, out.mut_slice(0, 4));\n+        from_u32(self.H1, out.mut_slice(4, 8));\n+        from_u32(self.H2, out.mut_slice(8, 12));\n+        from_u32(self.H3, out.mut_slice(12, 16));\n+        from_u32(self.H4, out.mut_slice(16, 20));\n+        from_u32(self.H5, out.mut_slice(20, 24));\n+        from_u32(self.H6, out.mut_slice(24, 28));\n+        from_u32(self.H7, out.mut_slice(28, 32));\n     }\n \n     fn result_224(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n-        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n-        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n-        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n-        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n-        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n-        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n+        from_u32(self.H0, out.mut_slice(0, 4));\n+        from_u32(self.H1, out.mut_slice(4, 8));\n+        from_u32(self.H2, out.mut_slice(8, 12));\n+        from_u32(self.H3, out.mut_slice(12, 16));\n+        from_u32(self.H4, out.mut_slice(16, 20));\n+        from_u32(self.H5, out.mut_slice(20, 24));\n+        from_u32(self.H6, out.mut_slice(24, 28));\n     }\n }\n "}, {"sha": "92a027100daf4ab63d3b8822bdc4e1847a59330b", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -85,7 +85,6 @@ pub mod reader {\n     use core::ptr::offset;\n     use core::str;\n     use core::unstable::intrinsics::bswap32;\n-    use core::vec;\n \n     // ebml reading\n \n@@ -248,7 +247,7 @@ pub mod reader {\n     }\n \n     pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n-        f(vec::slice(*d.data, d.start, d.end))\n+        f(d.data.slice(d.start, d.end))\n     }\n \n "}, {"sha": "f8ecac373a6c7741cbf351d9a440c1a95812600c", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -976,9 +976,7 @@ impl io::Writer for TcpSocketBuf {\n         let socket_data_ptr: *TcpSocketData =\n             &(*((*(self.data)).sock).socket_data);\n         let w_result = write_common_impl(socket_data_ptr,\n-                                         vec::slice(data,\n-                                                    0,\n-                                                    data.len()).to_owned());\n+                                         data.slice(0, data.len()).to_owned());\n         if w_result.is_err() {\n             let err_data = w_result.get_err();\n             debug!("}, {"sha": "1ac913e8a00d181ab4712dd6da80dec84bca26b8", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -298,9 +298,8 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n-            return (BigUint::from_slice(vec::slice(a.data, mid,\n-                                                   a.data.len())),\n-                    BigUint::from_slice(vec::slice(a.data, 0, mid)));\n+            return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n+                    BigUint::from_slice(a.data.slice(0, mid)));\n         }\n \n \n@@ -413,7 +412,7 @@ impl Integer for BigUint {\n                 return (Zero::zero(), Zero::zero(), copy *a);\n             }\n \n-            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n+            let an = a.data.slice(a.data.len() - n, a.data.len());\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n@@ -578,7 +577,7 @@ impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = uint::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(vec::slice(buf, start, end), radix) {\n+            match uint::parse_bytes(buf.slice(start, end), radix) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n                 // Some(d) => n += BigUint::from_uint(d) * power,\n                 Some(d) => n = n + BigUint::from_uint(d) * power,\n@@ -634,7 +633,7 @@ impl BigUint {\n         if n_unit == 0 { return copy *self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n-            vec::slice(self.data, n_unit, self.data.len())\n+            self.data.slice(n_unit, self.data.len())\n         );\n     }\n \n@@ -1132,7 +1131,7 @@ impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(vec::slice(buf, start, buf.len()), radix)\n+        return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n             .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n@@ -1176,7 +1175,7 @@ mod biguint_tests {\n         let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n         for data.iter().enumerate().advance |(i, ni)| {\n-            for vec::slice(data, i, data.len()).iter().enumerate().advance |(j0, nj)| {\n+            for data.slice(i, data.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = j0 + i;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1654,7 +1653,7 @@ mod bigint_tests {\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n         for nums.iter().enumerate().advance |(i, ni)| {\n-            for vec::slice(nums, i, nums.len()).iter().enumerate().advance |(j0, nj)| {\n+            for nums.slice(i, nums.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = i + j0;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);"}, {"sha": "5377dfadbaa1162125b36eaf4ae02eed43799879", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -57,8 +57,8 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n                 a_ix += 1;\n             } else { rs.push(copy b[b_ix]); b_ix += 1; }\n         }\n-        rs.push_all(vec::slice(a, a_ix, a_len));\n-        rs.push_all(vec::slice(b, b_ix, b_len));\n+        rs.push_all(a.slice(a_ix, a_len));\n+        rs.push_all(b.slice(b_ix, b_len));\n         rs\n     }\n }\n@@ -201,12 +201,12 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     loop {\n         let run_len: uint = {\n             // This scope contains the slice `arr` here:\n-            let arr = vec::mut_slice(array, idx, size);\n+            let arr = array.mut_slice(idx, size);\n             let mut run_len: uint = count_run_ascending(arr);\n \n             if run_len < min_run {\n                 let force = if remaining <= min_run {remaining} else {min_run};\n-                let slice = vec::mut_slice(arr, 0, force);\n+                let slice = arr.mut_slice(0, force);\n                 binarysort(slice, run_len);\n                 run_len = force;\n             }\n@@ -443,14 +443,14 @@ impl<T:Copy + Ord> MergeState<T> {\n         }\n \n         let k = { // constrain lifetime of slice below\n-            let slice = vec::slice(array, b1, b1+l1);\n+            let slice = array.slice(b1, b1+l1);\n             gallop_right(&array[b2], slice, 0)\n         };\n         b1 += k;\n         l1 -= k;\n         if l1 != 0 {\n             let l2 = { // constrain lifetime of slice below\n-                let slice = vec::slice(array, b2, b2+l2);\n+                let slice = array.slice(b2, b2+l2);\n                 gallop_left(&array[b1+l1-1],slice,l2-1)\n             };\n             if l2 > 0 {\n@@ -526,7 +526,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 assert!(len1 > 1 && len2 != 0);\n \n                 count1 = {\n-                    let tmp_view = vec::slice(tmp, c1, c1+len1);\n+                    let tmp_view = tmp.slice(c1, c1+len1);\n                     gallop_right(&array[c2], tmp_view, 0)\n                 };\n                 if count1 != 0 {\n@@ -539,7 +539,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 if len2 == 0 { break_outer = true; break; }\n \n                 count2 = {\n-                    let tmp_view = vec::slice(array, c2, c2+len2);\n+                    let tmp_view = array.slice(c2, c2+len2);\n                     gallop_left(&tmp[c1], tmp_view, 0)\n                 };\n                 if count2 != 0 {\n@@ -638,7 +638,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 assert!(len2 > 1 && len1 != 0);\n \n                 { // constrain scope of tmp_view:\n-                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n+                    let tmp_view = array.mut_slice(base1, base1+len1);\n                     count1 = len1 - gallop_right(\n                         &tmp[c2], tmp_view, len1-1);\n                 }\n@@ -655,7 +655,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n                 let count2;\n                 { // constrain scope of tmp_view\n-                    let tmp_view = vec::mut_slice(tmp, 0, len2);\n+                    let tmp_view = tmp.mut_slice(0, len2);\n                     count2 = len2 - gallop_left(&array[c1],\n                                                 tmp_view,\n                                                 len2-1);\n@@ -1111,7 +1111,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n+                let part = arr.slice(0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort\n@@ -1183,7 +1183,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n+                let part = arr.slice(0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort"}, {"sha": "dce2b7fe3dfb009cb88e433d99f32519889ca2e9", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -154,7 +154,7 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let mut path = ~[];\n     for uint::range(start_idx, len1 - 1) |_i| { path.push(~\"..\"); };\n \n-    path.push_all(vec::slice(split2, start_idx, len2 - 1));\n+    path.push_all(split2.slice(start_idx, len2 - 1));\n \n     return if !path.is_empty() {\n         Path(\"\").push_many(path)"}, {"sha": "39cce41b386929450259c8825c9ebb174109604e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -60,7 +60,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n     let belt = tag_index_buckets_bucket_elt;\n     for reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n-        if eq_fn(vec::slice(*elt.data, elt.start + 4u, elt.end)) {\n+        if eq_fn(elt.data.slice(elt.start + 4u, elt.end)) {\n             return Some(reader::doc_at(d.data, pos).doc);\n         }\n     };\n@@ -72,7 +72,7 @@ pub type GetCrateDataCb<'self> = &'self fn(ast::crate_num) -> cmd;\n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(\n-            vec::slice(bytes, 0u, 4u), 0u, 4u) as int\n+            bytes.slice(0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n     lookup_hash(items,"}, {"sha": "58fac69659ce5979b06b404a35103c9c775829af", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -20,7 +20,6 @@ use middle::ty;\n \n use core::str;\n use core::uint;\n-use core::vec;\n use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n@@ -519,8 +518,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n         fail!();\n     }\n \n-    let crate_part = vec::slice(buf, 0u, colon_idx);\n-    let def_part = vec::slice(buf, colon_idx + 1u, len);\n+    let crate_part = buf.slice(0u, colon_idx);\n+    let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,"}, {"sha": "93202f3fd558bb01bf72e66f79e2f487653f07b0", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -132,7 +132,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n-            let gens = vec::mut_slice(self.gens, start, end);\n+            let gens = self.gens.mut_slice(start, end);\n             set_bit(gens, bit);\n         }\n     }\n@@ -143,7 +143,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n-            let kills = vec::mut_slice(self.kills, start, end);\n+            let kills = self.kills.mut_slice(start, end);\n             set_bit(kills, bit);\n         }\n     }\n@@ -216,7 +216,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             return true;\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n-        let on_entry = vec::slice(self.on_entry, start, end);\n+        let on_entry = self.on_entry.slice(start, end);\n         debug!(\"each_bit_on_entry_frozen(id=%?, on_entry=%s)\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n@@ -229,7 +229,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         //! Only useful after `propagate()` has been called.\n \n         let (start, end) = self.compute_id_range(id);\n-        let on_entry = vec::slice(self.on_entry, start, end);\n+        let on_entry = self.on_entry.slice(start, end);\n         debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n@@ -241,7 +241,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         //! Iterates through each bit in the gen set for `id`.\n \n         let (start, end) = self.compute_id_range(id);\n-        let gens = vec::slice(self.gens, start, end);\n+        let gens = self.gens.slice(start, end);\n         debug!(\"each_gen_bit(id=%?, gens=%s)\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n@@ -255,7 +255,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             return true;\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n-        let gens = vec::slice(self.gens, start, end);\n+        let gens = self.gens.slice(start, end);\n         debug!(\"each_gen_bit(id=%?, gens=%s)\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n@@ -338,17 +338,17 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n \n             if self.nodeid_to_bitset.contains_key(&id) {\n                 let (start, end) = self.compute_id_range_frozen(id);\n-                let on_entry = vec::slice(self.on_entry, start, end);\n+                let on_entry = self.on_entry.slice(start, end);\n                 let entry_str = bits_to_str(on_entry);\n \n-                let gens = vec::slice(self.gens, start, end);\n+                let gens = self.gens.slice(start, end);\n                 let gens_str = if gens.iter().any_(|&u| u != 0) {\n                     fmt!(\" gen: %s\", bits_to_str(gens))\n                 } else {\n                     ~\"\"\n                 };\n \n-                let kills = vec::slice(self.kills, start, end);\n+                let kills = self.kills.slice(start, end);\n                 let kills_str = if kills.iter().any_(|&u| u != 0) {\n                     fmt!(\" kill: %s\", bits_to_str(kills))\n                 } else {\n@@ -953,7 +953,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                id, bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             join_bits(&self.dfcx.oper, pred_bits, on_entry)\n         };\n         if changed {\n@@ -970,7 +970,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                id, mut_bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             let changed = join_bits(&self.dfcx.oper, reslice(pred_bits), on_entry);\n             copy_bits(reslice(on_entry), pred_bits);\n             changed"}, {"sha": "ca0d544198e8fb797ad6d5d17e7e2aed3d38e5ec", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -17,7 +17,6 @@ use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n-use core::vec;\n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n use syntax::codemap::span;"}, {"sha": "7e17a947d303fe8c12c405cef87fbe1416a5700e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -388,9 +388,9 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n         match br.pats[col].node {\n             ast::pat_ident(_, path, Some(inner)) => {\n                 let pats = vec::append(\n-                    vec::slice(br.pats, 0u, col).to_owned(),\n+                    br.pats.slice(0u, col).to_owned(),\n                     vec::append(~[inner],\n-                                vec::slice(br.pats, col + 1u,\n+                                br.pats.slice(col + 1u,\n                                            br.pats.len())));\n \n                 let binding_info =\n@@ -437,8 +437,8 @@ pub fn enter_match<'r>(bcx: block,\n             Some(sub) => {\n                 let pats =\n                     vec::append(\n-                        vec::append(sub, vec::slice(br.pats, 0u, col)),\n-                        vec::slice(br.pats, col + 1u, br.pats.len()));\n+                        vec::append(sub, br.pats.slice(0u, col)),\n+                        br.pats.slice(col + 1u, br.pats.len()));\n \n                 let this = br.pats[col];\n                 match this.node {\n@@ -1290,7 +1290,7 @@ pub fn compile_submatch(bcx: block,\n         match data.arm.guard {\n             Some(guard_expr) => {\n                 bcx = compile_guard(bcx, guard_expr, m[0].data,\n-                                    vec::slice(m, 1, m.len()),\n+                                    m.slice(1, m.len()),\n                                     vals, chk);\n             }\n             _ => ()\n@@ -1309,8 +1309,8 @@ pub fn compile_submatch(bcx: block,\n         }\n     };\n \n-    let vals_left = vec::append(vec::slice(vals, 0u, col).to_owned(),\n-                                vec::slice(vals, col + 1u, vals.len()));\n+    let vals_left = vec::append(vals.slice(0u, col).to_owned(),\n+                                vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     let mut pat_span = dummy_sp();"}, {"sha": "fd3ebd3d951599c2df31efaf6f77129904086959", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -419,10 +419,9 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n             });\n         for cleanup_pos.iter().advance |i| {\n             scope_info.cleanups =\n-                vec::append(vec::slice(scope_info.cleanups, 0u, *i).to_owned(),\n-                            vec::slice(scope_info.cleanups,\n-                                      *i + 1u,\n-                                      scope_info.cleanups.len()));\n+                vec::append(scope_info.cleanups.slice(0u, *i).to_owned(),\n+                            scope_info.cleanups.slice(*i + 1u,\n+                                                      scope_info.cleanups.len()));\n             shrink_scope_clean(scope_info, *i);\n         }\n     }"}, {"sha": "38e4f087b0ecd980a049b4f03a89f7d4f50e827c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -528,7 +528,7 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     } = ty::lookup_item_type(tcx, mth_did);\n     let n_r_m_tps = r_m_generics.type_param_defs.len(); // rcvr + method tps\n     let m_type_param_defs =\n-        vec::slice(*r_m_generics.type_param_defs, n_r_m_tps - n_m_tps, n_r_m_tps);\n+        r_m_generics.type_param_defs.slice(n_r_m_tps - n_m_tps, n_r_m_tps);\n \n     // Flatten out to find the number of vtables the method expects.\n     let m_vtables = ty::count_traits_and_supertraits(tcx, m_type_param_defs);"}, {"sha": "a586cb83fa180056dace49f4b70f3d4d94707ffa", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -55,7 +55,7 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::{libc, io, os, task, vec};\n+use std::{libc, io, os, task};\n use std::cell::Cell;\n use extra::rl;\n \n@@ -430,7 +430,7 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n \n             if !cmd.is_empty() {\n                 let args = if len > 1 {\n-                    vec::slice(split, 1, len).to_owned()\n+                    split.slice(1, len).to_owned()\n                 } else { ~[] };\n \n                 match run_cmd(repl, in, out, cmd, args, use_rl) {"}, {"sha": "ebdea2537ac38e3828a40eb9b2e37e028dcb49d6", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -12,7 +12,7 @@ use target::*;\n use package_id::PkgId;\n use core::path::Path;\n use core::option::*;\n-use core::{os, run, str, vec};\n+use core::{os, run, str};\n use context::*;\n use crate::Crate;\n use messages::*;\n@@ -146,8 +146,7 @@ impl PkgSrc {\n     fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n         assert!(p.components.len() > prefix);\n         let mut sub = Path(\"\");\n-        for vec::slice(p.components, prefix,\n-                       p.components.len()).iter().advance |c| {\n+        for p.components.slice(prefix, p.components.len()).iter().advance |c| {\n             sub = sub.push(*c);\n         }\n         debug!(\"found crate %s\", sub.to_str());"}, {"sha": "4d9c08f25da742611e75395087b604410c57ca30", "filename": "src/libstd/io.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -65,7 +65,7 @@ use str::StrSlice;\n use to_str::ToStr;\n use uint;\n use vec;\n-use vec::{ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n+use vec::{MutableVector, ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n \n #[allow(non_camel_case_types)] // not sure what to do about this\n pub type fd_t = c_int;\n@@ -698,7 +698,7 @@ impl<T:Reader> ReaderUtil for T {\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n             if nbread > 0 {\n-                bytes = vec::slice(bytes, offset, bytes.len()).to_owned();\n+                bytes = bytes.slice(offset, bytes.len()).to_owned();\n             }\n         }\n         chars\n@@ -1053,7 +1053,7 @@ impl Reader for BytesReader {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - *self.pos);\n \n-        let view = vec::slice(self.bytes, *self.pos, self.bytes.len());\n+        let view = self.bytes.slice(*self.pos, self.bytes.len());\n         vec::bytes::copy_memory(bytes, view, count);\n \n         *self.pos += count;\n@@ -1663,7 +1663,7 @@ impl Writer for BytesWriter {\n         unsafe {\n             vec::raw::set_len(bytes, count);\n \n-            let view = vec::mut_slice(*bytes, *self.pos, count);\n+            let view = bytes.mut_slice(*self.pos, count);\n             vec::bytes::copy_memory(view, v, v_len);\n         }\n \n@@ -1909,8 +1909,7 @@ mod tests {\n                 if len <= ivals.len() {\n                     assert_eq!(res.len(), len);\n                 }\n-                assert!(vec::slice(ivals, 0u, res.len()) ==\n-                             vec::map(res, |x| *x as int));\n+                assert!(ivals.slice(0u, res.len()) == vec::map(res, |x| *x as int));\n             }\n         }\n         let mut i = 0;"}, {"sha": "5534c5befc2b2cfb548da7d43f27b7547d7fab53", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -134,7 +134,7 @@ pub mod win32 {\n                     }\n                 }\n                 if k != 0 && done {\n-                    let sub = vec::slice(buf, 0u, k as uint);\n+                    let sub = buf.slice(0, k as uint);\n                     res = option::Some(str::from_utf16(sub));\n                 }\n             }"}, {"sha": "5320bd0f42ee1bec609c8588ce1e73db5c38f812", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -298,7 +298,7 @@ impl<T: Reader> ReaderUtil for T {\n             do (|| {\n                 while total_read < len {\n                     let len = buf.len();\n-                    let slice = vec::mut_slice(*buf, start_len + total_read, len);\n+                    let slice = buf.mut_slice(start_len + total_read, len);\n                     match self.read(slice) {\n                         Some(nread) => {\n                             total_read += nread;"}, {"sha": "c93945a6a9aa9eeddba2784b6b6b2c050122470b", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -86,7 +86,7 @@ impl Reader for MemReader {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = vec::mut_slice(buf, 0, write_len);\n+            let output = buf.mut_slice(0, write_len);\n             assert_eq!(input.len(), output.len());\n             vec::bytes::copy_memory(output, input, write_len);\n         }"}, {"sha": "c8dc5aa7f79923cb8edb9549f129672abee3cbe1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -251,17 +251,17 @@ pub fn head_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n }\n \n /// Returns a vector containing all but the first element of a slice\n-pub fn tail<'r,T>(v: &'r [T]) -> &'r [T] { slice(v, 1, v.len()) }\n+pub fn tail<'r,T>(v: &'r [T]) -> &'r [T] { v.slice(1, v.len()) }\n \n /// Returns a vector containing all but the first `n` elements of a slice\n-pub fn tailn<'r,T>(v: &'r [T], n: uint) -> &'r [T] { slice(v, n, v.len()) }\n+pub fn tailn<'r,T>(v: &'r [T], n: uint) -> &'r [T] { v.slice(n, v.len()) }\n \n /// Returns a vector containing all but the last element of a slice\n-pub fn init<'r,T>(v: &'r [T]) -> &'r [T] { slice(v, 0, v.len() - 1) }\n+pub fn init<'r,T>(v: &'r [T]) -> &'r [T] { v.slice(0, v.len() - 1) }\n \n /// Returns a vector containing all but the last `n' elements of a slice\n pub fn initn<'r,T>(v: &'r [T], n: uint) -> &'r [T] {\n-    slice(v, 0, v.len() - n)\n+    v.slice(0, v.len() - n)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n@@ -276,47 +276,6 @@ pub fn last_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n     if v.len() == 0 { None } else { Some(&v[v.len() - 1]) }\n }\n \n-/// Return a slice that points into another slice.\n-#[inline]\n-pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    do as_imm_buf(v) |p, _len| {\n-        unsafe {\n-            transmute((ptr::offset(p, start),\n-                       (end - start) * sys::nonzero_size_of::<T>()))\n-        }\n-    }\n-}\n-\n-/// Return a slice that points into another slice.\n-#[inline]\n-pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n-                    -> &'r mut [T] {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    do as_mut_buf(v) |p, _len| {\n-        unsafe {\n-            transmute((ptr::mut_offset(p, start),\n-                       (end - start) * sys::nonzero_size_of::<T>()))\n-        }\n-    }\n-}\n-\n-/// Return a slice that points into another slice.\n-#[inline]\n-pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n-                      -> &'r const [T] {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    do as_const_buf(v) |p, _len| {\n-        unsafe {\n-            transmute((ptr::const_offset(p, start),\n-                       (end - start) * sys::nonzero_size_of::<T>()))\n-        }\n-    }\n-}\n-\n /// Copies\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n@@ -330,12 +289,12 @@ pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i).to_owned());\n+                result.push(v.slice(start, i).to_owned());\n                 start = i + 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln).to_owned());\n+    result.push(v.slice(start, ln).to_owned());\n     result\n }\n \n@@ -354,14 +313,14 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i).to_owned());\n+                result.push(v.slice(start, i).to_owned());\n                 // Make sure to skip the separator.\n                 start = i + 1u;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln).to_owned());\n+    result.push(v.slice(start, ln).to_owned());\n     result\n }\n \n@@ -379,12 +338,12 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1, end).to_owned());\n+                result.push(v.slice(i + 1, end).to_owned());\n                 end = i;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end).to_owned());\n+    result.push(v.slice(0u, end).to_owned());\n     reverse(result);\n     result\n }\n@@ -404,14 +363,14 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0u, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1u, end).to_owned());\n+                result.push(v.slice(i + 1u, end).to_owned());\n                 // Make sure to skip the separator.\n                 end = i;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end).to_owned());\n+    result.push(v.slice(0u, end).to_owned());\n     reverse(result);\n     result\n }\n@@ -487,15 +446,15 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         // popped. For the moment it unsafely exists at both the head and last\n         // positions\n         {\n-            let first_slice = slice(*v, 0, 1);\n-            let last_slice = slice(*v, next_ln, ln);\n+            let first_slice = v.slice(0, 1);\n+            let last_slice = v.slice(next_ln, ln);\n             raw::copy_memory(transmute(last_slice), first_slice, 1);\n         }\n \n         // Memcopy everything to the left one element\n         {\n-            let init_slice = slice(*v, 0, next_ln);\n-            let tail_slice = slice(*v, 1, ln);\n+            let init_slice = v.slice(0, next_ln);\n+            let tail_slice = v.slice(1, ln);\n             raw::copy_memory(transmute(init_slice),\n                              tail_slice,\n                              next_ln);\n@@ -1689,7 +1648,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n-        slice(*self, start, end)\n+    assert!(start <= end);\n+    assert!(end <= self.len());\n+        do as_imm_buf(*self) |p, _len| {\n+            unsafe {\n+                transmute((ptr::offset(p, start),\n+                           (end - start) * sys::nonzero_size_of::<T>()))\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -2042,9 +2008,17 @@ pub trait MutableVector<'self, T> {\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n+    /// Return a slice that points into another slice.\n     #[inline]\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n-        mut_slice(self, start, end)\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        do as_mut_buf(self) |p, _len| {\n+            unsafe {\n+                transmute((ptr::mut_offset(p, start),\n+                           (end - start) * sys::nonzero_size_of::<T>()))\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -2713,30 +2687,30 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n-        let v_a = slice(vec_fixed, 1u, vec_fixed.len()).to_owned();\n+        let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_owned();\n         assert_eq!(v_a.len(), 3u);\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n-        let v_b = slice(vec_stack, 1u, 3u).to_owned();\n+        let v_b = vec_stack.slice(1u, 3u).to_owned();\n         assert_eq!(v_b.len(), 2u);\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n-        let v_c = slice(vec_managed, 0u, 3u).to_owned();\n+        let v_c = vec_managed.slice(0u, 3u).to_owned();\n         assert_eq!(v_c.len(), 3u);\n         assert_eq!(v_c[0], 1);\n         assert_eq!(v_c[1], 2);\n         assert_eq!(v_c[2], 3);\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n-        let v_d = slice(vec_unique, 1u, 6u).to_owned();\n+        let v_d = vec_unique.slice(1u, 6u).to_owned();\n         assert_eq!(v_d.len(), 5u);\n         assert_eq!(v_d[0], 2);\n         assert_eq!(v_d[1], 3);"}, {"sha": "c7f33587f3157bfe67671901f7c6dc7a124620a1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -13,7 +13,6 @@ use codemap;\n \n use std::io;\n use std::uint;\n-use std::vec;\n use extra::term;\n \n pub type Emitter = @fn(cmsp: Option<(@codemap::CodeMap, span)>,\n@@ -250,7 +249,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     let mut elided = false;\n     let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n     if display_lines.len() > max_lines {\n-        display_lines = vec::slice(display_lines, 0u, max_lines).to_owned();\n+        display_lines = display_lines.slice(0u, max_lines).to_owned();\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "787cf696cc34851fce7aa37b4bb7f085fd6e68e3", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -29,7 +29,7 @@ macro_rules! bench (\n \n fn main() {\n     let argv = os::args();\n-    let tests = vec::slice(argv, 1, argv.len());\n+    let tests = argv.slice(1, argv.len());\n \n     bench!(shift_push);\n     bench!(read_line);"}, {"sha": "5ebcfe164ce77f17d36f22cb5d7c8dcc7c3b689f", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -96,7 +96,7 @@ impl RepeatFasta {\n \n             copy_memory(buf, alu, alu_len);\n             let buf_len = buf.len();\n-            copy_memory(vec::mut_slice(buf, alu_len, buf_len),\n+            copy_memory(buf.mut_slice(alu_len, buf_len),\n                         alu,\n                         LINE_LEN);\n "}, {"sha": "57683fa3dbf0c6eda9dd8fb6793dbf893d34b24b", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -90,7 +90,7 @@ fn find(mm: &HashMap<~[u8], uint>, key: ~str) -> uint {\n \n // given a map, increment the counter for a key\n fn update_freq(mm: &mut HashMap<~[u8], uint>, key: &[u8]) {\n-    let key = vec::slice(key, 0, key.len()).to_owned();\n+    let key = key.to_owned();\n     let newval = match mm.pop(&key) {\n         Some(v) => v + 1,\n         None => 1\n@@ -107,11 +107,11 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n \n    let len = bb.len();\n    while ii < len - (nn - 1u) {\n-      it(vec::slice(bb, ii, ii+nn));\n+      it(bb.slice(ii, ii+nn));\n       ii += 1u;\n    }\n \n-   return vec::slice(bb, len - (nn - 1u), len).to_owned();\n+   return bb.slice(len - (nn - 1u), len).to_owned();\n }\n \n fn make_sequence_processor(sz: uint,"}, {"sha": "405aa68c483ba74470405e99cad98a9f72be61c1", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -8,7 +8,7 @@ use std::libc::{STDIN_FILENO, c_int, fdopen, fgets, fileno, fopen, fstat};\n use std::libc::{stat, strlen};\n use std::ptr::null;\n use std::unstable::intrinsics::init;\n-use std::vec::{reverse, slice};\n+use std::vec::{reverse};\n use extra::sort::quick_sort3;\n \n static LINE_LEN: uint = 80;\n@@ -194,7 +194,7 @@ fn unpack_symbol(c: u8) -> u8 {\n \n fn next_char<'a>(mut buf: &'a [u8]) -> &'a [u8] {\n     loop {\n-        buf = slice(buf, 1, buf.len());\n+        buf = buf.slice(1, buf.len());\n         if buf.len() == 0 {\n             break;\n         }\n@@ -226,7 +226,7 @@ fn read_stdin() -> ~[u8] {\n                 fgets(transmute(&mut window[0]), LINE_LEN as c_int, stdin);\n \n                 {\n-                    if vec::slice(window, 0, 6) == header {\n+                    if window.slice(0, 6) == header {\n                         break;\n                     }\n                 }\n@@ -235,9 +235,7 @@ fn read_stdin() -> ~[u8] {\n             while fgets(transmute(&mut window[0]),\n                         LINE_LEN as c_int,\n                         stdin) != null() {\n-                window = vec::mut_slice(window,\n-                                        strlen(transmute(&window[0])) as uint,\n-                                        window.len());\n+                window = window.mut_slice(strlen(transmute(&window[0])) as uint, window.len());\n             }\n         }\n "}, {"sha": "295211e03a14b4439c040dad72071b5a51827a62", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -32,7 +32,6 @@ use std::str;\n use std::task;\n use std::u64;\n use std::uint;\n-use std::vec;\n \n fn fib(n: int) -> int {\n     fn pfib(c: &Chan<int>, n: int) {\n@@ -62,7 +61,7 @@ struct Config {\n fn parse_opts(argv: ~[~str]) -> Config {\n     let opts = ~[getopts::optflag(~\"stress\")];\n \n-    let opt_args = vec::slice(argv, 1, argv.len());\n+    let opt_args = argv.slice(1, argv.len());\n \n     match getopts::getopts(opt_args, opts) {\n       Ok(ref m) => {"}, {"sha": "c9f6733fa2587afdf6f0adb686d6cc44d4fc7d2b", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -8,12 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-// This doesn't work, and should.\n-//    v.slice(1, 5)\n-    vec::slice(v, 1, 5)\n+    v.slice(1, 5)\n }\n \n pub fn main() {}"}, {"sha": "e3012b0862145b30499f17f78f41a0232c117149", "filename": "src/test/run-pass/vec-slice.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0512b1055eac15db86d83c994fb546cbfa62676/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice.rs?ref=d0512b1055eac15db86d83c994fb546cbfa62676", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n pub fn main() {\n     let  v = ~[1,2,3,4,5];\n-    let v2 = vec::slice(v, 1, 3);\n+    let v2 = v.slice(1, 3);\n     assert_eq!(v2[0], 2);\n     assert_eq!(v2[1], 3);\n }"}]}