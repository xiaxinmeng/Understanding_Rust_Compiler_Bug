{"sha": "407d179f4e0b625e6911ebaf72c87cd35935fb06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwN2QxNzlmNGUwYjYyNWU2OTExZWJhZjcyYzg3Y2QzNTkzNWZiMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T02:31:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T02:31:13Z"}, "message": "auto merge of #9285 : sfackler/rust/future, r=alexcrichton\n\nThe `Drop` implementation was used to prevent `Future` from being implicitly copyable. Since `~fn`s are no longer copyable, this is no longer needed. I added a cfail test to make sure that this is actually the case.\r\n\r\nI method-ized all of the `Future` creation methods and added a new one, `spawn_with`, which is similar to `task::spawn_with`.\r\n\r\nI also got rid of some unused imports in tests.", "tree": {"sha": "03a0d29757c7b5ba7b3f1eb579b3184174c40fb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03a0d29757c7b5ba7b3f1eb579b3184174c40fb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/407d179f4e0b625e6911ebaf72c87cd35935fb06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/407d179f4e0b625e6911ebaf72c87cd35935fb06", "html_url": "https://github.com/rust-lang/rust/commit/407d179f4e0b625e6911ebaf72c87cd35935fb06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/407d179f4e0b625e6911ebaf72c87cd35935fb06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "570431fcacb115eb0bc3bd9f81977b57173a95ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/570431fcacb115eb0bc3bd9f81977b57173a95ef", "html_url": "https://github.com/rust-lang/rust/commit/570431fcacb115eb0bc3bd9f81977b57173a95ef"}, {"sha": "963707f45d935e938adde9e37b56355a915660bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/963707f45d935e938adde9e37b56355a915660bd", "html_url": "https://github.com/rust-lang/rust/commit/963707f45d935e938adde9e37b56355a915660bd"}], "stats": {"total": 210, "additions": 115, "deletions": 95}, "files": [{"sha": "e1f70a19e52e5ad5f7b3480e3f56b000a7e046ac", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -280,7 +280,7 @@ fn fib(n: uint) -> uint {\n     12586269025\n }\n \n-let mut delayed_fib = extra::future::spawn (|| fib(50) );\n+let mut delayed_fib = extra::future::Future::spawn (|| fib(50) );\n make_a_sandwich();\n println(fmt!(\"fib(50) = %?\", delayed_fib.get()))\n ~~~\n@@ -304,7 +304,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\n+    let mut futures = vec::from_fn(1000, |ind| do extra::future::Future::spawn { partial_sum(ind) });\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {"}, {"sha": "3ce58b58db6da382293c6e6a717f7a6295376366", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -420,7 +420,6 @@ mod test {\n     use std::rt::io;\n     use std::rt::io::Writer;\n     use std::rt::io::file;\n-    use std::uint;\n     use std::vec;\n \n     fn make_file(path : &Path, contents: &[~str]) {"}, {"sha": "4e8bc37891dcb7597bf1047be7423a54270cf585", "filename": "src/libextra/future.rs", "status": "modified", "additions": 84, "deletions": 80, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -25,27 +25,16 @@\n \n #[allow(missing_doc)];\n \n-\n-use std::cast;\n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::task;\n use std::util::replace;\n \n-#[doc = \"The future type\"]\n+/// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n     priv state: FutureState<A>,\n }\n \n-// n.b. It should be possible to get rid of this.\n-// Add a test, though -- tjc\n-// FIXME(#2829) -- futures should not be copyable, because they close\n-// over ~fn's that have pipes and so forth within!\n-#[unsafe_destructor]\n-impl<A> Drop for Future<A> {\n-    fn drop(&mut self) {}\n-}\n-\n enum FutureState<A> {\n     Pending(~fn() -> A),\n     Evaluating,\n@@ -71,156 +60,171 @@ impl<A> Future<A> {\n             _ => fail!( \"Logic error.\" ),\n         }\n     }\n-}\n \n-impl<A> Future<A> {\n     pub fn get_ref<'a>(&'a mut self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as\n         * the future.\n         */\n-        unsafe {\n-            {\n-                match self.state {\n-                    Forced(ref mut v) => { return cast::transmute(v); }\n-                    Evaluating => fail!(\"Recursive forcing of future!\"),\n-                    Pending(_) => {}\n-                }\n-            }\n-            {\n-                let state = replace(&mut self.state, Evaluating);\n-                match state {\n+        match self.state {\n+            Forced(ref v) => return v,\n+            Evaluating => fail!(\"Recursive forcing of future!\"),\n+            Pending(_) => {\n+                match replace(&mut self.state, Evaluating) {\n                     Forced(_) | Evaluating => fail!(\"Logic error.\"),\n                     Pending(f) => {\n                         self.state = Forced(f());\n-                        cast::transmute(self.get_ref())\n+                        self.get_ref()\n                     }\n                 }\n             }\n         }\n     }\n-}\n-\n-pub fn from_value<A>(val: A) -> Future<A> {\n-    /*!\n-     * Create a future from a value.\n-     *\n-     * The value is immediately available and calling `get` later will\n-     * not block.\n-     */\n \n-    Future {state: Forced(val)}\n-}\n+    pub fn from_value(val: A) -> Future<A> {\n+        /*!\n+         * Create a future from a value.\n+         *\n+         * The value is immediately available and calling `get` later will\n+         * not block.\n+         */\n \n-pub fn from_port<A:Send>(port: PortOne<A>) -> Future<A> {\n-    /*!\n-     * Create a future from a port\n-     *\n-     * The first time that the value is requested the task will block\n-     * waiting for the result to be received on the port.\n-     */\n+        Future {state: Forced(val)}\n+    }\n \n-    let port = Cell::new(port);\n-    do from_fn {\n-        port.take().recv()\n+    pub fn from_fn(f: ~fn() -> A) -> Future<A> {\n+        /*!\n+         * Create a future from a function.\n+         *\n+         * The first time that the value is requested it will be retrieved by\n+         * calling the function.  Note that this function is a local\n+         * function. It is not spawned into another task.\n+         */\n+\n+        Future {state: Pending(f)}\n     }\n }\n \n-pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n-    /*!\n-     * Create a future from a function.\n-     *\n-     * The first time that the value is requested it will be retrieved by\n-     * calling the function.  Note that this function is a local\n-     * function. It is not spawned into another task.\n-     */\n+impl<A:Send> Future<A> {\n+    pub fn from_port(port: PortOne<A>) -> Future<A> {\n+        /*!\n+         * Create a future from a port\n+         *\n+         * The first time that the value is requested the task will block\n+         * waiting for the result to be received on the port.\n+         */\n+\n+        let port = Cell::new(port);\n+        do Future::from_fn {\n+            port.take().recv()\n+        }\n+    }\n \n-    Future {state: Pending(f)}\n-}\n+    pub fn spawn(blk: ~fn() -> A) -> Future<A> {\n+        /*!\n+         * Create a future from a unique closure.\n+         *\n+         * The closure will be run in a new task and its result used as the\n+         * value of the future.\n+         */\n \n-pub fn spawn<A:Send>(blk: ~fn() -> A) -> Future<A> {\n-    /*!\n-     * Create a future from a unique closure.\n-     *\n-     * The closure will be run in a new task and its result used as the\n-     * value of the future.\n-     */\n+        let (port, chan) = oneshot();\n \n-    let (port, chan) = oneshot();\n+        do task::spawn_with(chan) |chan| {\n+            chan.send(blk());\n+        }\n \n-    let chan = Cell::new(chan);\n-    do task::spawn {\n-        let chan = chan.take();\n-        chan.send(blk());\n+        Future::from_port(port)\n     }\n \n-    return from_port(port);\n+    pub fn spawn_with<B: Send>(v: B, blk: ~fn(B) -> A) -> Future<A> {\n+        /*!\n+         * Create a future from a unique closure taking one argument.\n+         *\n+         * The closure and its argument will be moved into a new task. The\n+         * closure will be run and its result used as the value of the future.\n+         */\n+\n+         let (port, chan) = oneshot();\n+\n+         do task::spawn_with((v, chan)) |(v, chan)| {\n+            chan.send(blk(v));\n+         }\n+\n+         Future::from_port(port)\n+    }\n }\n \n #[cfg(test)]\n mod test {\n-    use future::*;\n+    use future::Future;\n \n     use std::cell::Cell;\n     use std::comm::oneshot;\n     use std::task;\n \n     #[test]\n     fn test_from_value() {\n-        let mut f = from_value(~\"snail\");\n+        let mut f = Future::from_value(~\"snail\");\n         assert_eq!(f.get(), ~\"snail\");\n     }\n \n     #[test]\n     fn test_from_port() {\n         let (po, ch) = oneshot();\n         ch.send(~\"whale\");\n-        let mut f = from_port(po);\n+        let mut f = Future::from_port(po);\n         assert_eq!(f.get(), ~\"whale\");\n     }\n \n     #[test]\n     fn test_from_fn() {\n-        let mut f = from_fn(|| ~\"brail\");\n+        let mut f = Future::from_fn(|| ~\"brail\");\n         assert_eq!(f.get(), ~\"brail\");\n     }\n \n     #[test]\n     fn test_interface_get() {\n-        let mut f = from_value(~\"fail\");\n+        let mut f = Future::from_value(~\"fail\");\n         assert_eq!(f.get(), ~\"fail\");\n     }\n \n     #[test]\n     fn test_interface_unwrap() {\n-        let f = from_value(~\"fail\");\n+        let f = Future::from_value(~\"fail\");\n         assert_eq!(f.unwrap(), ~\"fail\");\n     }\n \n     #[test]\n     fn test_get_ref_method() {\n-        let mut f = from_value(22);\n+        let mut f = Future::from_value(22);\n         assert_eq!(*f.get_ref(), 22);\n     }\n \n     #[test]\n     fn test_spawn() {\n-        let mut f = spawn(|| ~\"bale\");\n+        let mut f = Future::spawn(|| ~\"bale\");\n         assert_eq!(f.get(), ~\"bale\");\n     }\n \n+    #[test]\n+    fn test_spawn_with() {\n+        let mut f = Future::spawn_with(~\"gale\", |s| { s });\n+        assert_eq!(f.get(), ~\"gale\");\n+    }\n+\n     #[test]\n     #[should_fail]\n     fn test_futurefail() {\n-        let mut f = spawn(|| fail!());\n+        let mut f = Future::spawn(|| fail!());\n         let _x: ~str = f.get();\n     }\n \n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n-        let f = Cell::new(do spawn { expected });\n+        let f = Cell::new(do Future::spawn { expected });\n         do task::spawn {\n             let mut f = f.take();\n             let actual = f.get();"}, {"sha": "934943f6fbb47c9bb80a8f0f1c4a383408758099", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -512,10 +512,8 @@ impl MatchOptions {\n \n #[cfg(test)]\n mod test {\n-    use std::{io, os, unstable};\n-    use std::unstable::finally::Finally;\n+    use std::os;\n     use super::*;\n-    use tempfile;\n \n     #[test]\n     fn test_absolute_pattern() {"}, {"sha": "b5514315226966b71614fd53b078474595e8e9aa", "filename": "src/libextra/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -14,7 +14,7 @@ use std::num;\n use std::ptr;\n use std::sys;\n use std::vec;\n-use future_spawn = future::spawn;\n+use future::Future;\n \n /**\n  * The maximum number of tasks this module will spawn for a single\n@@ -55,7 +55,7 @@ fn map_slices<A:Clone + Send,B:Clone + Send>(\n             do xs.as_imm_buf |p, _len| {\n                 let f = f();\n                 let base = base;\n-                let f = do future_spawn() || {\n+                let f = do Future::spawn() || {\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base as int),"}, {"sha": "fb58e5c2bf02dfa76396fee61f31659a80e4e178", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -20,7 +20,7 @@ use std::result;\n use std::run;\n use std::str;\n use std::task;\n-use extra::future;\n+use extra::future::Future;\n \n #[deriving(Clone)]\n pub enum WriteInstr {\n@@ -207,10 +207,10 @@ pub fn future_writer_factory(\n     (writer_factory, markdown_po)\n }\n \n-fn future_writer() -> (Writer, future::Future<~str>) {\n+fn future_writer() -> (Writer, Future<~str>) {\n     let (port, chan) = comm::stream();\n     let writer: ~fn(instr: WriteInstr) = |instr| chan.send(instr.clone());\n-    let future = do future::from_fn || {\n+    let future = do Future::from_fn || {\n         let mut res = ~\"\";\n         loop {\n             match port.recv() {"}, {"sha": "b52ba154f435a97e831901337ebc7de56e1340f6", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -18,7 +18,7 @@\n extern mod extra;\n \n use extra::arc;\n-use extra::future;\n+use extra::future::Future;\n use extra::time;\n use std::cell::Cell;\n use std::os;\n@@ -94,7 +94,7 @@ fn main() {\n         let (new_chan, num_port) = init();\n         let num_chan2 = Cell::new(num_chan.take());\n         let num_port = Cell::new(num_port);\n-        let new_future = do future::spawn() {\n+        let new_future = do Future::spawn() {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)"}, {"sha": "e3d0b4912f9748c20ea87f71f052a309d89d827a", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -18,7 +18,7 @@\n extern mod extra;\n \n use extra::arc;\n-use extra::future;\n+use extra::future::Future;\n use extra::time;\n use std::cell::Cell;\n use std::os;\n@@ -90,7 +90,7 @@ fn main() {\n         let (new_chan, num_port) = init();\n         let num_chan2 = Cell::new(num_chan.take());\n         let num_port = Cell::new(num_port);\n-        let new_future = do future::spawn {\n+        let new_future = do Future::spawn {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)"}, {"sha": "aef5d0f9b04a6412b75223f6a7880b33120a708a", "filename": "src/test/compile-fail/future_not_copyable.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/407d179f4e0b625e6911ebaf72c87cd35935fb06/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs?ref=407d179f4e0b625e6911ebaf72c87cd35935fb06", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use extra::future::Future;\n+\n+fn main() {\n+    let f = Future::from_value(());\n+    let g = f;\n+    f.unwrap(); //~ ERROR use of moved value\n+}"}]}