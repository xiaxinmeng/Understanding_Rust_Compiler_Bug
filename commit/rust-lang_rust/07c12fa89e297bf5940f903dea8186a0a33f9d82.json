{"sha": "07c12fa89e297bf5940f903dea8186a0a33f9d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YzEyZmE4OWUyOTdiZjU5NDBmOTAzZGVhODE4NmEwYTMzZjlkODI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-12-11T22:55:43Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-12-12T09:36:00Z"}, "message": "Merge `TokenStreamKind` into `TokenStream`.\n\nBecause the distinction provides little value, and removing it cleans up\nthe code quite a bit.", "tree": {"sha": "471ecbb9b34aa0dc162b4acb28415d5c0463bf5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/471ecbb9b34aa0dc162b4acb28415d5c0463bf5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07c12fa89e297bf5940f903dea8186a0a33f9d82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07c12fa89e297bf5940f903dea8186a0a33f9d82", "html_url": "https://github.com/rust-lang/rust/commit/07c12fa89e297bf5940f903dea8186a0a33f9d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07c12fa89e297bf5940f903dea8186a0a33f9d82/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43c6eced848034cf10018b109245263e2428bb1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/43c6eced848034cf10018b109245263e2428bb1f", "html_url": "https://github.com/rust-lang/rust/commit/43c6eced848034cf10018b109245263e2428bb1f"}], "stats": {"total": 137, "additions": 65, "deletions": 72}, "files": [{"sha": "e31bde4082dad0897fcc46c4a159ca617d7dc4b2", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 65, "deletions": 72, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/07c12fa89e297bf5940f903dea8186a0a33f9d82/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c12fa89e297bf5940f903dea8186a0a33f9d82/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=07c12fa89e297bf5940f903dea8186a0a33f9d82", "patch": "@@ -123,7 +123,7 @@ impl TokenTree {\n     }\n \n     pub fn joint(self) -> TokenStream {\n-        TokenStream { kind: TokenStreamKind::JointTree(self) }\n+        TokenStream::JointTree(self)\n     }\n \n     /// Returns the opening delimiter as a token tree.\n@@ -154,8 +154,11 @@ impl TokenTree {\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `Token::Interpolated` for back-compat.\n #[derive(Clone, Debug)]\n-pub struct TokenStream {\n-    kind: TokenStreamKind,\n+pub enum TokenStream {\n+    Empty,\n+    Tree(TokenTree),\n+    JointTree(TokenTree),\n+    Stream(Lrc<Vec<TokenStream>>),\n }\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -167,24 +170,22 @@ impl TokenStream {\n     /// separating the two arguments with a comma for diagnostic suggestions.\n     pub(crate) fn add_comma(&self) -> Option<(TokenStream, Span)> {\n         // Used to suggest if a user writes `foo!(a b);`\n-        if let TokenStreamKind::Stream(ref stream) = self.kind {\n+        if let TokenStream::Stream(ref stream) = self {\n             let mut suggestion = None;\n             let mut iter = stream.iter().enumerate().peekable();\n             while let Some((pos, ts)) = iter.next() {\n                 if let Some((_, next)) = iter.peek() {\n-                    let sp = match (&ts.kind, &next.kind) {\n-                        (TokenStreamKind::Tree(TokenTree::Token(_, token::Token::Comma)), _) |\n-                        (_, TokenStreamKind::Tree(TokenTree::Token(_, token::Token::Comma))) => {\n+                    let sp = match (&ts, &next) {\n+                        (TokenStream::Tree(TokenTree::Token(_, token::Token::Comma)), _) |\n+                        (_, TokenStream::Tree(TokenTree::Token(_, token::Token::Comma))) => {\n                             continue;\n                         }\n-                        (TokenStreamKind::Tree(TokenTree::Token(sp, _)), _) => *sp,\n-                        (TokenStreamKind::Tree(TokenTree::Delimited(sp, ..)), _) => sp.entire(),\n+                        (TokenStream::Tree(TokenTree::Token(sp, _)), _) => *sp,\n+                        (TokenStream::Tree(TokenTree::Delimited(sp, ..)), _) => sp.entire(),\n                         _ => continue,\n                     };\n                     let sp = sp.shrink_to_hi();\n-                    let comma = TokenStream {\n-                        kind: TokenStreamKind::Tree(TokenTree::Token(sp, token::Comma)),\n-                    };\n+                    let comma = TokenStream::Tree(TokenTree::Token(sp, token::Comma));\n                     suggestion = Some((pos, comma, sp));\n                 }\n             }\n@@ -201,17 +202,9 @@ impl TokenStream {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-enum TokenStreamKind {\n-    Empty,\n-    Tree(TokenTree),\n-    JointTree(TokenTree),\n-    Stream(Lrc<Vec<TokenStream>>),\n-}\n-\n impl From<TokenTree> for TokenStream {\n     fn from(tt: TokenTree) -> TokenStream {\n-        TokenStream { kind: TokenStreamKind::Tree(tt) }\n+        TokenStream::Tree(tt)\n     }\n }\n \n@@ -230,22 +223,22 @@ impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n impl Extend<TokenStream> for TokenStream {\n     fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, iter: I) {\n         let iter = iter.into_iter();\n-        let kind = mem::replace(&mut self.kind, TokenStreamKind::Empty);\n+        let this = mem::replace(self, TokenStream::Empty);\n \n         // Vector of token streams originally in self.\n-        let tts: Vec<TokenStream> = match kind {\n-            TokenStreamKind::Empty => {\n+        let tts: Vec<TokenStream> = match this {\n+            TokenStream::Empty => {\n                 let mut vec = Vec::new();\n                 vec.reserve(iter.size_hint().0);\n                 vec\n             }\n-            TokenStreamKind::Tree(_) | TokenStreamKind::JointTree(_) => {\n+            TokenStream::Tree(_) | TokenStream::JointTree(_) => {\n                 let mut vec = Vec::new();\n                 vec.reserve(1 + iter.size_hint().0);\n-                vec.push(TokenStream { kind });\n+                vec.push(this);\n                 vec\n             }\n-            TokenStreamKind::Stream(rc_vec) => match Lrc::try_unwrap(rc_vec) {\n+            TokenStream::Stream(rc_vec) => match Lrc::try_unwrap(rc_vec) {\n                 Ok(mut vec) => {\n                     // Extend in place using the existing capacity if possible.\n                     // This is the fast path for libraries like `quote` that\n@@ -286,20 +279,20 @@ impl PartialEq<TokenStream> for TokenStream {\n \n impl TokenStream {\n     pub fn len(&self) -> usize {\n-        if let TokenStreamKind::Stream(ref slice) = self.kind {\n+        if let TokenStream::Stream(ref slice) = self {\n             slice.len()\n         } else {\n             0\n         }\n     }\n \n     pub fn empty() -> TokenStream {\n-        TokenStream { kind: TokenStreamKind::Empty }\n+        TokenStream::Empty\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        match self.kind {\n-            TokenStreamKind::Empty => true,\n+        match self {\n+            TokenStream::Empty => true,\n             _ => false,\n         }\n     }\n@@ -313,7 +306,7 @@ impl TokenStream {\n     }\n \n     fn concat_rc_vec(streams: Lrc<Vec<TokenStream>>) -> TokenStream {\n-        TokenStream { kind: TokenStreamKind::Stream(streams) }\n+        TokenStream::Stream(streams)\n     }\n \n     pub fn trees(&self) -> Cursor {\n@@ -377,9 +370,9 @@ impl TokenStream {\n     /// Precondition: `self` consists of a single token tree.\n     /// Returns true if the token tree is a joint operation w.r.t. `proc_macro::TokenNode`.\n     pub fn as_tree(self) -> (TokenTree, bool /* joint? */) {\n-        match self.kind {\n-            TokenStreamKind::Tree(tree) => (tree, false),\n-            TokenStreamKind::JointTree(tree) => (tree, true),\n+        match self {\n+            TokenStream::Tree(tree) => (tree, false),\n+            TokenStream::JointTree(tree) => (tree, true),\n             _ => unreachable!(),\n         }\n     }\n@@ -389,9 +382,9 @@ impl TokenStream {\n         let mut result = Vec::new();\n         let mut i = 0;\n         while let Some(stream) = trees.next_as_stream() {\n-            result.push(match stream.kind {\n-                TokenStreamKind::Tree(tree) => f(i, tree).into(),\n-                TokenStreamKind::JointTree(tree) => f(i, tree).joint(),\n+            result.push(match stream {\n+                TokenStream::Tree(tree) => f(i, tree).into(),\n+                TokenStream::JointTree(tree) => f(i, tree).joint(),\n                 _ => unreachable!()\n             });\n             i += 1;\n@@ -403,29 +396,29 @@ impl TokenStream {\n         let mut trees = self.into_trees();\n         let mut result = Vec::new();\n         while let Some(stream) = trees.next_as_stream() {\n-            result.push(match stream.kind {\n-                TokenStreamKind::Tree(tree) => f(tree).into(),\n-                TokenStreamKind::JointTree(tree) => f(tree).joint(),\n+            result.push(match stream {\n+                TokenStream::Tree(tree) => f(tree).into(),\n+                TokenStream::JointTree(tree) => f(tree).joint(),\n                 _ => unreachable!()\n             });\n         }\n         TokenStream::concat(result)\n     }\n \n     fn first_tree_and_joint(&self) -> Option<(TokenTree, bool)> {\n-        match self.kind {\n-            TokenStreamKind::Empty => None,\n-            TokenStreamKind::Tree(ref tree) => Some((tree.clone(), false)),\n-            TokenStreamKind::JointTree(ref tree) => Some((tree.clone(), true)),\n-            TokenStreamKind::Stream(ref stream) => stream.first().unwrap().first_tree_and_joint(),\n+        match self {\n+            TokenStream::Empty => None,\n+            TokenStream::Tree(ref tree) => Some((tree.clone(), false)),\n+            TokenStream::JointTree(ref tree) => Some((tree.clone(), true)),\n+            TokenStream::Stream(ref stream) => stream.first().unwrap().first_tree_and_joint(),\n         }\n     }\n \n     fn last_tree_if_joint(&self) -> Option<TokenTree> {\n-        match self.kind {\n-            TokenStreamKind::Empty | TokenStreamKind::Tree(..) => None,\n-            TokenStreamKind::JointTree(ref tree) => Some(tree.clone()),\n-            TokenStreamKind::Stream(ref stream) => stream.last().unwrap().last_tree_if_joint(),\n+        match self {\n+            TokenStream::Empty | TokenStream::Tree(..) => None,\n+            TokenStream::JointTree(ref tree) => Some(tree.clone()),\n+            TokenStream::Stream(ref stream) => stream.last().unwrap().last_tree_if_joint(),\n         }\n     }\n }\n@@ -472,7 +465,7 @@ impl TokenStreamBuilder {\n     }\n \n     fn push_all_but_last_tree(&mut self, stream: &TokenStream) {\n-        if let TokenStreamKind::Stream(ref streams) = stream.kind {\n+        if let TokenStream::Stream(ref streams) = stream {\n             let len = streams.len();\n             match len {\n                 1 => {}\n@@ -484,7 +477,7 @@ impl TokenStreamBuilder {\n     }\n \n     fn push_all_but_first_tree(&mut self, stream: &TokenStream) {\n-        if let TokenStreamKind::Stream(ref streams) = stream.kind {\n+        if let TokenStream::Stream(ref streams) = stream {\n             let len = streams.len();\n             match len {\n                 1 => {}\n@@ -524,10 +517,10 @@ impl StreamCursor {\n             if self.index < self.stream.len() {\n                 self.index += 1;\n                 let next = self.stream[self.index - 1].clone();\n-                match next.kind {\n-                    TokenStreamKind::Tree(..) | TokenStreamKind::JointTree(..) => return Some(next),\n-                    TokenStreamKind::Stream(stream) => self.insert(stream),\n-                    TokenStreamKind::Empty => {}\n+                match next {\n+                    TokenStream::Tree(..) | TokenStream::JointTree(..) => return Some(next),\n+                    TokenStream::Stream(stream) => self.insert(stream),\n+                    TokenStream::Empty => {}\n                 }\n             } else if let Some((stream, index)) = self.stack.pop() {\n                 self.stream = stream;\n@@ -548,20 +541,20 @@ impl Iterator for Cursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n-        self.next_as_stream().map(|stream| match stream.kind {\n-            TokenStreamKind::Tree(tree) | TokenStreamKind::JointTree(tree) => tree,\n+        self.next_as_stream().map(|stream| match stream {\n+            TokenStream::Tree(tree) | TokenStream::JointTree(tree) => tree,\n             _ => unreachable!()\n         })\n     }\n }\n \n impl Cursor {\n     fn new(stream: TokenStream) -> Self {\n-        Cursor(match stream.kind {\n-            TokenStreamKind::Empty => CursorKind::Empty,\n-            TokenStreamKind::Tree(tree) => CursorKind::Tree(tree, false),\n-            TokenStreamKind::JointTree(tree) => CursorKind::JointTree(tree, false),\n-            TokenStreamKind::Stream(stream) => CursorKind::Stream(StreamCursor::new(stream)),\n+        Cursor(match stream {\n+            TokenStream::Empty => CursorKind::Empty,\n+            TokenStream::Tree(tree) => CursorKind::Tree(tree, false),\n+            TokenStream::JointTree(tree) => CursorKind::JointTree(tree, false),\n+            TokenStream::Stream(stream) => CursorKind::Stream(StreamCursor::new(stream)),\n         })\n     }\n \n@@ -610,11 +603,11 @@ impl Cursor {\n     pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n         fn look_ahead(streams: &[TokenStream], mut n: usize) -> Result<TokenTree, usize> {\n             for stream in streams {\n-                n = match stream.kind {\n-                    TokenStreamKind::Tree(ref tree) | TokenStreamKind::JointTree(ref tree)\n+                n = match stream {\n+                    TokenStream::Tree(ref tree) | TokenStream::JointTree(ref tree)\n                         if n == 0 => return Ok(tree.clone()),\n-                    TokenStreamKind::Tree(..) | TokenStreamKind::JointTree(..) => n - 1,\n-                    TokenStreamKind::Stream(ref stream) => match look_ahead(stream, n) {\n+                    TokenStream::Tree(..) | TokenStream::JointTree(..) => n - 1,\n+                    TokenStream::Stream(ref stream) => match look_ahead(stream, n) {\n                         Ok(tree) => return Ok(tree),\n                         Err(n) => n,\n                     },\n@@ -660,11 +653,11 @@ impl ThinTokenStream {\n \n impl From<TokenStream> for ThinTokenStream {\n     fn from(stream: TokenStream) -> ThinTokenStream {\n-        ThinTokenStream(match stream.kind {\n-            TokenStreamKind::Empty => None,\n-            TokenStreamKind::Tree(tree) => Some(Lrc::new(vec![tree.into()])),\n-            TokenStreamKind::JointTree(tree) => Some(Lrc::new(vec![tree.joint()])),\n-            TokenStreamKind::Stream(stream) => Some(stream),\n+        ThinTokenStream(match stream {\n+            TokenStream::Empty => None,\n+            TokenStream::Tree(tree) => Some(Lrc::new(vec![tree.into()])),\n+            TokenStream::JointTree(tree) => Some(Lrc::new(vec![tree.joint()])),\n+            TokenStream::Stream(stream) => Some(stream),\n         })\n     }\n }"}]}