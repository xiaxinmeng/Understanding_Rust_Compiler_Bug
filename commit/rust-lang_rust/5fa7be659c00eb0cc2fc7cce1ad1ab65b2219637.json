{"sha": "5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYTdiZTY1OWMwMGViMGNjMmZjN2NjZTFhZDFhYjY1YjIyMTk2Mzc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-20T16:09:11Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:55Z"}, "message": "rustc: slightly optimize make_mono_id to not clone lots of vectors.", "tree": {"sha": "1e588219c0fb5f1b8f6d0ad0d54fa67c9d75f956", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e588219c0fb5f1b8f6d0ad0d54fa67c9d75f956"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637", "html_url": "https://github.com/rust-lang/rust/commit/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c709c1efc6c399b404bc73ef9a8de10c81a67e35", "url": "https://api.github.com/repos/rust-lang/rust/commits/c709c1efc6c399b404bc73ef9a8de10c81a67e35", "html_url": "https://github.com/rust-lang/rust/commit/c709c1efc6c399b404bc73ef9a8de10c81a67e35"}], "stats": {"total": 126, "additions": 61, "deletions": 65}, "files": [{"sha": "78fe41352595bef486177245aacd9cf474cc5fb6", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637", "patch": "@@ -690,6 +690,7 @@ pub fn is_null(val: ValueRef) -> bool {\n #[deriving(Eq, TotalEq, Hash)]\n pub struct MonoParamId {\n     pub subst: ty::t,\n+    // Do we really need the vtables to be hashed? Isn't the type enough?\n     pub vtables: Vec<mono_id>\n }\n "}, {"sha": "0155af02eb5d94966612f21152302fa83da68366", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637", "patch": "@@ -427,29 +427,6 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     };\n }\n \n-pub fn vtable_id(ccx: &CrateContext,\n-                 origin: &typeck::vtable_origin)\n-              -> mono_id {\n-    match origin {\n-        &typeck::vtable_static(impl_id, ref substs, ref sub_vtables) => {\n-            let psubsts = param_substs {\n-                tys: (*substs).clone(),\n-                vtables: Some(sub_vtables.clone()),\n-                self_ty: None,\n-                self_vtables: None\n-            };\n-\n-            monomorphize::make_mono_id(\n-                ccx,\n-                impl_id,\n-                &psubsts)\n-        }\n-\n-        // can't this be checked at the callee?\n-        _ => fail!(\"vtable_id\")\n-    }\n-}\n-\n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n fn get_vtable(bcx: &Block,\n@@ -460,7 +437,7 @@ fn get_vtable(bcx: &Block,\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n     // Check the cache.\n-    let hash_id = (self_ty, vtable_id(ccx, origins.get(0)));\n+    let hash_id = (self_ty, monomorphize::make_vtable_id(ccx, origins.get(0)));\n     match ccx.vtables.borrow().find(&hash_id) {\n         Some(&val) => { return val }\n         None => { }"}, {"sha": "16fef63482f217aac5aff54232840bd6128dc143", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=5fa7be659c00eb0cc2fc7cce1ad1ab65b2219637", "patch": "@@ -47,21 +47,51 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n            self_vtables.repr(ccx.tcx()),\n            ref_id);\n \n-    assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n+    assert!(real_substs.tps.iter().all(|t| {\n+        !ty::type_needs_infer(*t) && !ty::type_has_params(*t)\n+    }));\n+\n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n+    let substs_iter = real_substs.self_ty.iter().chain(real_substs.tps.iter());\n+    let param_ids: Vec<MonoParamId> = match vtables {\n+        Some(ref vts) => {\n+            debug!(\"make_mono_id vtables={} psubsts={}\",\n+                   vts.repr(ccx.tcx()), real_substs.tps.repr(ccx.tcx()));\n+            let vts_iter = self_vtables.iter().chain(vts.iter());\n+            vts_iter.zip(substs_iter).map(|(vtable, subst)| MonoParamId {\n+                subst: *subst,\n+                // Do we really need the vtables to be hashed? Isn't the type enough?\n+                vtables: vtable.iter().map(|vt| make_vtable_id(ccx, vt)).collect()\n+            }).collect()\n+        }\n+        None => substs_iter.map(|subst| MonoParamId {\n+            subst: *subst,\n+            vtables: Vec::new()\n+        }).collect()\n+    };\n+\n+    let hash_id = @mono_id_ {\n+        def: fn_id,\n+        params: param_ids\n+    };\n+\n+    match ccx.monomorphized.borrow().find(&hash_id) {\n+        Some(&val) => {\n+            debug!(\"leaving monomorphic fn {}\",\n+            ty::item_path_str(ccx.tcx(), fn_id));\n+            return (val, false);\n+        }\n+        None => ()\n+    }\n+\n     let psubsts = @param_substs {\n         tys: real_substs.tps.clone(),\n         vtables: vtables,\n         self_ty: real_substs.self_ty.clone(),\n         self_vtables: self_vtables\n     };\n \n-    for s in real_substs.tps.iter() { assert!(!ty::type_has_params(*s)); }\n-    for s in psubsts.tys.iter() { assert!(!ty::type_has_params(*s)); }\n-\n-    let hash_id = make_mono_id(ccx, fn_id, &*psubsts);\n-\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             psubsts={}, \\\n@@ -70,15 +100,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n            psubsts.repr(ccx.tcx()),\n            hash_id);\n \n-    match ccx.monomorphized.borrow().find(&hash_id) {\n-        Some(&val) => {\n-            debug!(\"leaving monomorphic fn {}\",\n-            ty::item_path_str(ccx.tcx(), fn_id));\n-            return (val, false);\n-        }\n-        None => ()\n-    }\n-\n     let tpt = ty::lookup_item_type(ccx.tcx(), fn_id);\n     let llitem_ty = tpt.ty;\n \n@@ -117,8 +138,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst_tps(ccx.tcx(), psubsts.tys.as_slice(),\n-                              psubsts.self_ty, llitem_ty),\n+        None => ty::subst_tps(ccx.tcx(), real_substs.tps.as_slice(),\n+                              real_substs.self_ty, llitem_ty),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n             // that the \"internal\" and \"external\" type of them differ.\n@@ -134,9 +155,9 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             // stick a substitution for the self type in.\n             // This is a bit unfortunate.\n \n-            let idx = psubsts.tys.len() - num_method_ty_params;\n-            let substs = psubsts.tys.slice(0, idx) +\n-                &[psubsts.self_ty.unwrap()] + psubsts.tys.tailn(idx);\n+            let idx = real_substs.tps.len() - num_method_ty_params;\n+            let substs = real_substs.tps.slice(0, idx) +\n+            &[real_substs.self_ty.unwrap()] + real_substs.tps.tailn(idx);\n             debug!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx()));\n \n@@ -284,28 +305,25 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     (lldecl, false)\n }\n \n-pub fn make_mono_id(ccx: &CrateContext,\n-                    item: ast::DefId,\n-                    substs: &param_substs) -> mono_id {\n-    let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n-    let param_ids: Vec<MonoParamId> = match substs.vtables {\n-        Some(ref vts) => {\n-            debug!(\"make_mono_id vtables={} substs={}\",\n-                   vts.repr(ccx.tcx()), substs.tys.repr(ccx.tcx()));\n-            let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n-            vts_iter.zip(substs_iter).map(|(vtable, subst)| MonoParamId {\n-                subst: *subst,\n-                vtables: vtable.iter().map(|vt| meth::vtable_id(ccx, vt)).collect()\n-            }).collect()\n+pub fn make_vtable_id(ccx: &CrateContext,\n+                      origin: &typeck::vtable_origin)\n+                      -> mono_id {\n+    match origin {\n+        &typeck::vtable_static(impl_id, ref substs, ref sub_vtables) => {\n+            let param_ids = sub_vtables.iter().zip(substs.iter()).map(|(vtable, subst)| {\n+                MonoParamId {\n+                    subst: *subst,\n+                    vtables: vtable.iter().map(|vt| make_vtable_id(ccx, vt)).collect()\n+                }\n+            }).collect();\n+\n+            @mono_id_ {\n+                def: impl_id,\n+                params: param_ids\n+            }\n         }\n-        None => substs_iter.map(|subst| MonoParamId {\n-            subst: *subst,\n-            vtables: Vec::new()\n-        }).collect()\n-    };\n \n-    @mono_id_ {\n-        def: item,\n-        params: param_ids\n+        // can't this be checked at the callee?\n+        _ => fail!(\"make_vtable_id needs vtable_static\")\n     }\n }"}]}