{"sha": "63d83fa38584fa0537f896bee5d90709c1352030", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZDgzZmEzODU4NGZhMDUzN2Y4OTZiZWU1ZDkwNzA5YzEzNTIwMzA=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-02T00:05:09Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-04T15:44:27Z"}, "message": "Add associated data into fst", "tree": {"sha": "d9e0ca57f278cedd819a53577cc703f245c6cda9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9e0ca57f278cedd819a53577cc703f245c6cda9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63d83fa38584fa0537f896bee5d90709c1352030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63d83fa38584fa0537f896bee5d90709c1352030", "html_url": "https://github.com/rust-lang/rust/commit/63d83fa38584fa0537f896bee5d90709c1352030", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63d83fa38584fa0537f896bee5d90709c1352030/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bfc3a50c0febbfa9b56de01997d081814d98e39", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bfc3a50c0febbfa9b56de01997d081814d98e39", "html_url": "https://github.com/rust-lang/rust/commit/1bfc3a50c0febbfa9b56de01997d081814d98e39"}], "stats": {"total": 94, "additions": 45, "deletions": 49}, "files": [{"sha": "6283c1f1a3f8b6be2bf24628b150177737cf93af", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/63d83fa38584fa0537f896bee5d90709c1352030/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d83fa38584fa0537f896bee5d90709c1352030/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=63d83fa38584fa0537f896bee5d90709c1352030", "patch": "@@ -7,9 +7,7 @@ use fst::{self, Streamer};\n use hir_expand::name::Name;\n use indexmap::{map::Entry, IndexMap};\n use itertools::Itertools;\n-use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n-use smallvec::SmallVec;\n-use syntax::SmolStr;\n+use rustc_hash::{FxHashSet, FxHasher};\n \n use crate::{\n     db::DefDatabase, item_scope::ItemInNs, visibility::Visibility, AssocItemId, ModuleDefId,\n@@ -25,6 +23,8 @@ pub struct ImportInfo {\n     pub path: ImportPath,\n     /// The module containing this item.\n     pub container: ModuleId,\n+    /// Whether the import is a trait associated item or not.\n+    pub is_assoc_item: bool,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -64,10 +64,6 @@ pub struct ImportMap {\n     /// the index of the first one.\n     importables: Vec<ItemInNs>,\n     fst: fst::Map<Vec<u8>>,\n-\n-    /// Maps names of associated items to the item's ID. Only includes items whose defining trait is\n-    /// exported.\n-    assoc_map: FxHashMap<SmolStr, SmallVec<[AssocItemId; 1]>>,\n }\n \n impl ImportMap {\n@@ -108,14 +104,22 @@ impl ImportMap {\n \n                 for item in per_ns.iter_items() {\n                     let path = mk_path();\n+                    let path_len = path.len();\n+                    let import_info = ImportInfo { path, container: module, is_assoc_item: false };\n+\n+                    // If we've added a path to a trait, add the trait's associated items to the assoc map.\n+                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n+                        import_map.collect_trait_assoc_items(db, tr, &import_info);\n+                    }\n+\n                     match import_map.map.entry(item) {\n                         Entry::Vacant(entry) => {\n-                            entry.insert(ImportInfo { path, container: module });\n+                            entry.insert(import_info);\n                         }\n                         Entry::Occupied(mut entry) => {\n                             // If the new path is shorter, prefer that one.\n-                            if path.len() < entry.get().path.len() {\n-                                *entry.get_mut() = ImportInfo { path, container: module };\n+                            if path_len < entry.get().path.len() {\n+                                *entry.get_mut() = import_info;\n                             } else {\n                                 continue;\n                             }\n@@ -128,11 +132,6 @@ impl ImportMap {\n                     if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n                         worklist.push((mod_id, mk_path()));\n                     }\n-\n-                    // If we've added a path to a trait, add the trait's methods to the method map.\n-                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n-                        import_map.collect_trait_methods(db, tr);\n-                    }\n                 }\n             }\n         }\n@@ -153,12 +152,10 @@ impl ImportMap {\n                 }\n             }\n \n-            let start = last_batch_start;\n-            last_batch_start = idx + 1;\n+            let key = fst_path(&importables[last_batch_start].1.path);\n+            builder.insert(key, last_batch_start as u64).unwrap();\n \n-            let key = fst_path(&importables[start].1.path);\n-\n-            builder.insert(key, start as u64).unwrap();\n+            last_batch_start = idx + 1;\n         }\n \n         import_map.fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n@@ -176,10 +173,22 @@ impl ImportMap {\n         self.map.get(&item)\n     }\n \n-    fn collect_trait_methods(&mut self, db: &dyn DefDatabase, tr: TraitId) {\n-        let data = db.trait_data(tr);\n-        for (name, item) in data.items.iter() {\n-            self.assoc_map.entry(name.to_string().into()).or_default().push(*item);\n+    fn collect_trait_assoc_items(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        tr: TraitId,\n+        import_info: &ImportInfo,\n+    ) {\n+        for (assoc_item_name, item) in db.trait_data(tr).items.iter() {\n+            let assoc_item = ItemInNs::Types(match item.clone() {\n+                AssocItemId::FunctionId(f) => f.into(),\n+                AssocItemId::ConstId(c) => c.into(),\n+                AssocItemId::TypeAliasId(t) => t.into(),\n+            });\n+            let mut assoc_item_info = import_info.to_owned();\n+            assoc_item_info.path.segments.push(assoc_item_name.to_owned());\n+            assoc_item_info.is_assoc_item = true;\n+            self.map.insert(assoc_item, assoc_item_info);\n         }\n     }\n }\n@@ -304,11 +313,11 @@ impl Query {\n     }\n }\n \n-fn contains_query(query: &Query, input_path: &ImportPath, enforce_lowercase: bool) -> bool {\n-    let mut input = if query.name_only {\n-        input_path.segments.last().unwrap().to_string()\n+fn import_matches_query(import: &ImportInfo, query: &Query, enforce_lowercase: bool) -> bool {\n+    let mut input = if import.is_assoc_item || query.name_only {\n+        import.path.segments.last().unwrap().to_string()\n     } else {\n-        input_path.to_string()\n+        import.path.to_string()\n     };\n     if enforce_lowercase || !query.case_sensitive {\n         input.make_ascii_lowercase();\n@@ -366,13 +375,13 @@ pub fn search_dependencies<'a>(\n             let import_map = &import_maps[indexed_value.index];\n             let importables = &import_map.importables[indexed_value.value as usize..];\n \n-            // Path shared by the importable items in this group.\n-            let common_importables_path = &import_map.map[&importables[0]].path;\n-            if !contains_query(&query, common_importables_path, true) {\n+            let common_importable_data = &import_map.map[&importables[0]];\n+            if !import_matches_query(common_importable_data, &query, true) {\n                 continue;\n             }\n \n-            let common_importables_path_fst = fst_path(common_importables_path);\n+            // Path shared by the importable items in this group.\n+            let common_importables_path_fst = fst_path(&common_importable_data.path);\n             // Add the items from this `ModPath` group. Those are all subsequent items in\n             // `importables` whose paths match `path`.\n             let iter = importables\n@@ -387,7 +396,7 @@ pub fn search_dependencies<'a>(\n                 })\n                 .filter(|item| {\n                     !query.case_sensitive // we've already checked the common importables path case-insensitively\n-                        || contains_query(&query, &import_map.map[item].path, false)\n+                        || import_matches_query(&import_map.map[item], &query, false)\n                 });\n             res.extend(iter);\n \n@@ -398,19 +407,6 @@ pub fn search_dependencies<'a>(\n         }\n     }\n \n-    // Add all exported associated items whose names match the query (exactly).\n-    for map in &import_maps {\n-        if let Some(v) = map.assoc_map.get(&*query.query) {\n-            res.extend(v.iter().map(|&assoc| {\n-                ItemInNs::Types(match assoc {\n-                    AssocItemId::FunctionId(it) => it.into(),\n-                    AssocItemId::ConstId(it) => it.into(),\n-                    AssocItemId::TypeAliasId(it) => it.into(),\n-                })\n-            }));\n-        }\n-    }\n-\n     res\n }\n \n@@ -755,7 +751,7 @@ mod tests {\n         //- /dep.rs crate:dep\n         pub mod fmt {\n             pub trait Display {\n-                fn fmttt();\n+                fn format();\n             }\n         }\n     \"#;\n@@ -767,7 +763,7 @@ mod tests {\n             expect![[r#\"\n                 dep::fmt (t)\n                 dep::fmt::Display (t)\n-                dep::fmt::Display::fmttt (f)\n+                dep::fmt::Display::format (f)\n             \"#]],\n         );\n     }\n@@ -808,8 +804,8 @@ mod tests {\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n                 dep::fmt::Display (t)\n-                dep::format (f)\n                 dep::fmt::Display::fmt (f)\n+                dep::format (f)\n             \"#]],\n         );\n "}]}