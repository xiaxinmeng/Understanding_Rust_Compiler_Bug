{"sha": "a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNmY2YmIyN2RmMWE5YTlmY2I1MDYwODFiYjMwY2NiZjk2NmU1YzI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T18:43:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "cleanup", "tree": {"sha": "7ec1a33ec57806979951fa5cefc3cc9a05b28987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ec1a33ec57806979951fa5cefc3cc9a05b28987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "html_url": "https://github.com/rust-lang/rust/commit/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d1f0b105d7995088fdf7a90e5e594b5555699c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1f0b105d7995088fdf7a90e5e594b5555699c6", "html_url": "https://github.com/rust-lang/rust/commit/2d1f0b105d7995088fdf7a90e5e594b5555699c6"}], "stats": {"total": 82, "additions": 42, "deletions": 40}, "files": [{"sha": "19c75404d1d51b169a61236a824af6604309018a", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "patch": "@@ -1,13 +1,13 @@\n use rustc_hash::FxHashMap;\n use ra_syntax::SmolStr;\n \n-use crate::{self as mbe, tt_cursor::TtCursor};\n+use crate::tt_cursor::TtCursor;\n \n-pub fn exapnd(rules: &mbe::MacroRules, input: &tt::Subtree) -> Option<tt::Subtree> {\n+pub fn exapnd(rules: &crate::MacroRules, input: &tt::Subtree) -> Option<tt::Subtree> {\n     rules.rules.iter().find_map(|it| expand_rule(it, input))\n }\n \n-fn expand_rule(rule: &mbe::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n+fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n     let mut input = TtCursor::new(input);\n     let bindings = match_lhs(&rule.lhs, &mut input)?;\n     expand_subtree(&rule.rhs, &bindings, &mut Vec::new())\n@@ -52,12 +52,12 @@ impl Bindings {\n     }\n }\n \n-fn match_lhs(pattern: &mbe::Subtree, input: &mut TtCursor) -> Option<Bindings> {\n+fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings> {\n     let mut res = Bindings::default();\n     for pat in pattern.token_trees.iter() {\n         match pat {\n-            mbe::TokenTree::Leaf(leaf) => match leaf {\n-                mbe::Leaf::Var(mbe::Var { text, kind }) => {\n+            crate::TokenTree::Leaf(leaf) => match leaf {\n+                crate::Leaf::Var(crate::Var { text, kind }) => {\n                     let kind = kind.clone()?;\n                     match kind.as_str() {\n                         \"ident\" => {\n@@ -70,14 +70,14 @@ fn match_lhs(pattern: &mbe::Subtree, input: &mut TtCursor) -> Option<Bindings> {\n                         _ => return None,\n                     }\n                 }\n-                mbe::Leaf::Punct(punct) => {\n+                crate::Leaf::Punct(punct) => {\n                     if input.eat_punct()? != punct {\n                         return None;\n                     }\n                 }\n                 _ => return None,\n             },\n-            mbe::TokenTree::Repeat(mbe::Repeat {\n+            crate::TokenTree::Repeat(crate::Repeat {\n                 subtree,\n                 kind: _,\n                 separator,\n@@ -114,7 +114,7 @@ impl_froms! (Foo: Bar, Baz)\n */\n \n fn expand_subtree(\n-    template: &mbe::Subtree,\n+    template: &crate::Subtree,\n     bindings: &Bindings,\n     nesting: &mut Vec<usize>,\n ) -> Option<tt::Subtree> {\n@@ -131,13 +131,13 @@ fn expand_subtree(\n }\n \n fn expand_tt(\n-    template: &mbe::TokenTree,\n+    template: &crate::TokenTree,\n     bindings: &Bindings,\n     nesting: &mut Vec<usize>,\n ) -> Option<tt::TokenTree> {\n     let res: tt::TokenTree = match template {\n-        mbe::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n-        mbe::TokenTree::Repeat(repeat) => {\n+        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n+        crate::TokenTree::Repeat(repeat) => {\n             let mut token_trees = Vec::new();\n             nesting.push(0);\n             while let Some(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n@@ -152,14 +152,14 @@ fn expand_tt(\n             }\n             .into()\n         }\n-        mbe::TokenTree::Leaf(leaf) => match leaf {\n-            mbe::Leaf::Ident(ident) => tt::Leaf::from(tt::Ident {\n+        crate::TokenTree::Leaf(leaf) => match leaf {\n+            crate::Leaf::Ident(ident) => tt::Leaf::from(tt::Ident {\n                 text: ident.text.clone(),\n             })\n             .into(),\n-            mbe::Leaf::Punct(punct) => tt::Leaf::from(punct.clone()).into(),\n-            mbe::Leaf::Var(v) => bindings.get(&v.text, nesting)?.clone(),\n-            mbe::Leaf::Literal(l) => tt::Leaf::from(tt::Literal {\n+            crate::Leaf::Punct(punct) => tt::Leaf::from(punct.clone()).into(),\n+            crate::Leaf::Var(v) => bindings.get(&v.text, nesting)?.clone(),\n+            crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal {\n                 text: l.text.clone(),\n             })\n             .into(),"}, {"sha": "a76ea84dbe4d77d4258de06f2d17e88d29b91e12", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "patch": "@@ -1,58 +1,59 @@\n-use crate::{self as mbe, tt_cursor::TtCursor};\n+use crate::tt_cursor::TtCursor;\n \n /// This module parses a raw `tt::TokenStream` into macro-by-example token\n /// stream. This is a *mostly* identify function, expect for handling of\n /// `$var:tt_kind` and `$(repeat),*` constructs.\n \n-pub fn parse(tt: &tt::Subtree) -> Option<mbe::MacroRules> {\n+pub fn parse(tt: &tt::Subtree) -> Option<crate::MacroRules> {\n     let mut parser = TtCursor::new(tt);\n     let mut rules = Vec::new();\n     while !parser.is_eof() {\n         rules.push(parse_rule(&mut parser)?)\n     }\n-    Some(mbe::MacroRules { rules })\n+    Some(crate::MacroRules { rules })\n }\n \n-fn parse_rule(p: &mut TtCursor) -> Option<mbe::Rule> {\n+fn parse_rule(p: &mut TtCursor) -> Option<crate::Rule> {\n     let lhs = parse_subtree(p.eat_subtree()?)?;\n     p.expect_char('=')?;\n     p.expect_char('>')?;\n-    let rhs = parse_subtree(p.eat_subtree()?)?;\n-    Some(mbe::Rule { lhs, rhs })\n+    let mut rhs = parse_subtree(p.eat_subtree()?)?;\n+    rhs.delimiter = crate::Delimiter::None;\n+    Some(crate::Rule { lhs, rhs })\n }\n \n-fn parse_subtree(tt: &tt::Subtree) -> Option<mbe::Subtree> {\n+fn parse_subtree(tt: &tt::Subtree) -> Option<crate::Subtree> {\n     let mut token_trees = Vec::new();\n     let mut p = TtCursor::new(tt);\n     while let Some(tt) = p.eat() {\n-        let child: mbe::TokenTree = match tt {\n+        let child: crate::TokenTree = match tt {\n             tt::TokenTree::Leaf(leaf) => match leaf {\n                 tt::Leaf::Punct(tt::Punct { char: '$', .. }) => {\n                     if p.at_ident().is_some() {\n-                        mbe::Leaf::from(parse_var(&mut p)?).into()\n+                        crate::Leaf::from(parse_var(&mut p)?).into()\n                     } else {\n                         parse_repeat(&mut p)?.into()\n                     }\n                 }\n-                tt::Leaf::Punct(punct) => mbe::Leaf::from(*punct).into(),\n+                tt::Leaf::Punct(punct) => crate::Leaf::from(*punct).into(),\n                 tt::Leaf::Ident(tt::Ident { text }) => {\n-                    mbe::Leaf::from(mbe::Ident { text: text.clone() }).into()\n+                    crate::Leaf::from(crate::Ident { text: text.clone() }).into()\n                 }\n                 tt::Leaf::Literal(tt::Literal { text }) => {\n-                    mbe::Leaf::from(mbe::Literal { text: text.clone() }).into()\n+                    crate::Leaf::from(crate::Literal { text: text.clone() }).into()\n                 }\n             },\n             tt::TokenTree::Subtree(subtree) => parse_subtree(&subtree)?.into(),\n         };\n         token_trees.push(child);\n     }\n-    Some(mbe::Subtree {\n+    Some(crate::Subtree {\n         token_trees,\n         delimiter: tt.delimiter,\n     })\n }\n \n-fn parse_var(p: &mut TtCursor) -> Option<mbe::Var> {\n+fn parse_var(p: &mut TtCursor) -> Option<crate::Var> {\n     let ident = p.eat_ident().unwrap();\n     let text = ident.text.clone();\n     let kind = if p.at_char(':') {\n@@ -66,26 +67,27 @@ fn parse_var(p: &mut TtCursor) -> Option<mbe::Var> {\n     } else {\n         None\n     };\n-    Some(mbe::Var { text, kind })\n+    Some(crate::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut TtCursor) -> Option<mbe::Repeat> {\n+fn parse_repeat(p: &mut TtCursor) -> Option<crate::Repeat> {\n     let subtree = p.eat_subtree().unwrap();\n-    let subtree = parse_subtree(subtree)?;\n+    let mut subtree = parse_subtree(subtree)?;\n+    subtree.delimiter = crate::Delimiter::None;\n     let sep = p.eat_punct()?;\n     let (separator, rep) = match sep.char {\n         '*' | '+' | '?' => (None, sep.char),\n         char => (Some(char), p.eat_punct()?.char),\n     };\n \n     let kind = match rep {\n-        '*' => mbe::RepeatKind::ZeroOrMore,\n-        '+' => mbe::RepeatKind::OneOrMore,\n-        '?' => mbe::RepeatKind::ZeroOrOne,\n+        '*' => crate::RepeatKind::ZeroOrMore,\n+        '+' => crate::RepeatKind::OneOrMore,\n+        '?' => crate::RepeatKind::ZeroOrOne,\n         _ => return None,\n     };\n     p.bump();\n-    Some(mbe::Repeat {\n+    Some(crate::Repeat {\n         subtree,\n         kind,\n         separator,"}, {"sha": "3223f6ea5f565c42d0cbf8925b886f2db14343a2", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "patch": "@@ -107,7 +107,7 @@ impl_froms!(TokenTree: Leaf, Subtree);\n     let expansion = crate::exapnd(&mbe, &invocation_tt).unwrap();\n     assert_eq!(\n         expansion.to_string(),\n-        \"{(impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}}) \\\n-          (impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}})}\"\n+        \"impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}} \\\n+         impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}}\"\n     )\n }"}]}