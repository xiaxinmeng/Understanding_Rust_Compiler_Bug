{"sha": "7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZTAyZDlmNGQ5NGY2YTgyNmQxMDUyOTQxOWI2NGE0Y2NkMmE0MDU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-20T04:24:14Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-02T22:49:47Z"}, "message": "Use the compiler API to run pretty printing.\n\nThis commit still does a lot of building in pretty because we always run after parsing.", "tree": {"sha": "b301dc71180f1b0fba846a064b268ef238f20d00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b301dc71180f1b0fba846a064b268ef238f20d00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "html_url": "https://github.com/rust-lang/rust/commit/7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4000cbbf8be9f21884077bee1361b5221e1f78f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4000cbbf8be9f21884077bee1361b5221e1f78f", "html_url": "https://github.com/rust-lang/rust/commit/a4000cbbf8be9f21884077bee1361b5221e1f78f"}], "stats": {"total": 160, "additions": 80, "deletions": 80}, "files": [{"sha": "bf1457c576ebae2d994991c2e21f8cff299d5ff3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "patch": "@@ -70,7 +70,7 @@ pub fn compile_input(sess: &Session,\n                      control: &CompileController) -> CompileResult {\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n-            let state = $make_state;\n+            let state = &mut $make_state;\n             let phase_result: &CompileResult = &$phase_result;\n             if phase_result.is_ok() || control.$point.run_callback_on_error {\n                 (control.$point.callback)(state);\n@@ -95,10 +95,17 @@ pub fn compile_input(sess: &Session,\n                 }\n             };\n \n+            let mut compile_state = CompileState::state_after_parse(input,\n+                                                                    sess,\n+                                                                    outdir,\n+                                                                    output,\n+                                                                    krate,\n+                                                                    &cstore);\n             controller_entry_point!(after_parse,\n                                     sess,\n-                                    CompileState::state_after_parse(input, sess, outdir, &krate),\n+                                    compile_state,\n                                     Ok(()));\n+            let krate = compile_state.krate.unwrap();\n \n             let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n             let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n@@ -194,16 +201,16 @@ pub fn compile_input(sess: &Session,\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n \n-                let state = CompileState::state_after_analysis(input,\n-                                                               &tcx.sess,\n-                                                               outdir,\n-                                                               opt_crate,\n-                                                               tcx.map.krate(),\n-                                                               &analysis,\n-                                                               mir_map.as_ref(),\n-                                                               tcx,\n-                                                               &id);\n-                (control.after_analysis.callback)(state);\n+                let mut state = CompileState::state_after_analysis(input,\n+                                                                   &tcx.sess,\n+                                                                   outdir,\n+                                                                   opt_crate,\n+                                                                   tcx.map.krate(),\n+                                                                   &analysis,\n+                                                                   mir_map.as_ref(),\n+                                                                   tcx,\n+                                                                   &id);\n+                (control.after_analysis.callback)(&mut state);\n \n                 if control.after_analysis.stop == Compilation::Stop {\n                     return result.and_then(|_| Err(0usize));\n@@ -311,7 +318,7 @@ pub struct PhaseController<'a> {\n     // If true then the compiler will try to run the callback even if the phase\n     // ends with an error. Note that this is not always possible.\n     pub run_callback_on_error: bool,\n-    pub callback: Box<Fn(CompileState) -> () + 'a>,\n+    pub callback: Box<Fn(&mut CompileState) + 'a>,\n }\n \n impl<'a> PhaseController<'a> {\n@@ -330,11 +337,12 @@ impl<'a> PhaseController<'a> {\n pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n     pub input: &'a Input,\n     pub session: &'a Session,\n-    pub cfg: Option<&'a ast::CrateConfig>,\n-    pub krate: Option<&'a ast::Crate>,\n+    pub krate: Option<ast::Crate>,\n+    pub cstore: Option<&'a CStore>,\n     pub crate_name: Option<&'a str>,\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n+    pub out_file: Option<&'a Path>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n@@ -353,8 +361,9 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             input: input,\n             session: session,\n             out_dir: out_dir.as_ref().map(|s| &**s),\n-            cfg: None,\n+            out_file: None,\n             krate: None,\n+            cstore: None,\n             crate_name: None,\n             output_filenames: None,\n             expanded_crate: None,\n@@ -370,9 +379,16 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n     fn state_after_parse(input: &'a Input,\n                          session: &'a Session,\n                          out_dir: &'a Option<PathBuf>,\n-                         krate: &'a ast::Crate)\n+                         out_file: &'a Option<PathBuf>,\n+                         krate: ast::Crate,\n+                         cstore: &'a CStore)\n                          -> CompileState<'a, 'ast, 'tcx> {\n-        CompileState { krate: Some(krate), ..CompileState::empty(input, session, out_dir) }\n+        CompileState {\n+            krate: Some(krate),\n+            cstore: Some(cstore),\n+            out_file: out_file.as_ref().map(|s| &**s),\n+            ..CompileState::empty(input, session, out_dir)\n+        }\n     }\n \n     fn state_after_expand(input: &'a Input,\n@@ -399,7 +415,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n             ast_map: Some(hir_map),\n-            krate: Some(krate),\n+            expanded_crate: Some(krate),\n             hir_crate: Some(hir_crate),\n             ..CompileState::empty(input, session, out_dir)\n         }\n@@ -419,7 +435,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             analysis: Some(analysis),\n             mir_map: mir_map,\n             tcx: Some(tcx),\n-            krate: krate,\n+            expanded_crate: krate,\n             hir_crate: Some(hir_crate),\n             crate_name: Some(crate_name),\n             ..CompileState::empty(input, session, out_dir)"}, {"sha": "8ffdf6843e75acc4ee13e8da1896e3f34829c081", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "patch": "@@ -31,6 +31,7 @@\n #![feature(set_stdio)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n+#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate flate;\n@@ -208,15 +209,8 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n \n     do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile), Some(sess));\n \n-    // It is somewhat unfortunate that this is hardwired in.\n-    let pretty = callbacks.parse_pretty(&sess, &matches);\n-    if let Some((ppm, opt_uii)) = pretty {\n-        pretty::pretty_print_input(&sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n-        return (Ok(()), None);\n-    }\n-\n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n-    let control = callbacks.build_controller(&sess);\n+    let control = callbacks.build_controller(&sess, &matches);\n     (driver::compile_input(&sess, &cstore, cfg, &input, &odir, &ofile,\n                            Some(plugins), &control),\n      Some(sess))\n@@ -247,6 +241,27 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n     }\n }\n \n+fn parse_pretty(sess: &Session,\n+                matches: &getopts::Matches)\n+                -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+    let pretty = if sess.opts.debugging_opts.unstable_options {\n+        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+            // stable pretty-print variants only\n+            pretty::parse_pretty(sess, &a, false)\n+        })\n+    } else {\n+        None\n+    };\n+    if pretty.is_none() && sess.unstable_options() {\n+        matches.opt_str(\"unpretty\").map(|a| {\n+            // extended with unstable pretty-print variants\n+            pretty::parse_pretty(sess, &a, true)\n+        })\n+    } else {\n+        pretty\n+    }\n+}\n+\n // Whether to stop or continue compilation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Compilation {\n@@ -316,29 +331,9 @@ pub trait CompilerCalls<'a> {\n         None\n     }\n \n-    // Parse pretty printing information from the arguments. The implementer can\n-    // choose to ignore this (the default will return None) which will skip pretty\n-    // printing. If you do want to pretty print, it is recommended to use the\n-    // implementation of this method from RustcDefaultCalls.\n-    // FIXME, this is a terrible bit of API. Parsing of pretty printing stuff\n-    // should be done as part of the framework and the implementor should customise\n-    // handling of it. However, that is not possible atm because pretty printing\n-    // essentially goes off and takes another path through the compiler which\n-    // means the session is either moved or not depending on what parse_pretty\n-    // returns (we could fix this by cloning, but it's another hack). The proper\n-    // solution is to handle pretty printing as if it were a compiler extension,\n-    // extending CompileController to make this work (see for example the treatment\n-    // of save-analysis in RustcDefaultCalls::build_controller).\n-    fn parse_pretty(&mut self,\n-                    _sess: &Session,\n-                    _matches: &getopts::Matches)\n-                    -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n-        None\n-    }\n-\n     // Create a CompilController struct for controlling the behaviour of\n     // compilation.\n-    fn build_controller(&mut self, &Session) -> CompileController<'a>;\n+    fn build_controller(&mut self, &Session, &getopts::Matches) -> CompileController<'a>;\n }\n \n // CompilerCalls instance for a regular rustc build.\n@@ -441,28 +436,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         None\n     }\n \n-    fn parse_pretty(&mut self,\n-                    sess: &Session,\n-                    matches: &getopts::Matches)\n-                    -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n-        let pretty = if sess.opts.debugging_opts.unstable_options {\n-            matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-                // stable pretty-print variants only\n-                pretty::parse_pretty(sess, &a, false)\n-            })\n-        } else {\n-            None\n-        };\n-        if pretty.is_none() && sess.unstable_options() {\n-            matches.opt_str(\"unpretty\").map(|a| {\n-                // extended with unstable pretty-print variants\n-                pretty::parse_pretty(sess, &a, true)\n-            })\n-        } else {\n-            pretty\n-        }\n-    }\n-\n     fn late_callback(&mut self,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n@@ -474,9 +447,22 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             .and_then(|| RustcDefaultCalls::list_metadata(sess, matches, input))\n     }\n \n-    fn build_controller(&mut self, sess: &Session) -> CompileController<'a> {\n+    fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n         let mut control = CompileController::basic();\n \n+        if let Some((ppm, opt_uii)) = parse_pretty(&sess, &matches) {\n+            control.after_parse.stop = Compilation::Stop;\n+            control.after_parse.callback = box move |state| {\n+                pretty::pretty_print_input(state.session,\n+                                           state.cstore.unwrap(),\n+                                           state.input,\n+                                           state.krate.take().unwrap(),\n+                                           ppm,\n+                                           opt_uii.clone(),\n+                                           state.out_file);\n+            };\n+        }\n+\n         if sess.opts.parse_only || sess.opts.debugging_opts.show_span.is_some() ||\n            sess.opts.debugging_opts.ast_json_noexpand {\n             control.after_parse.stop = Compilation::Stop;\n@@ -498,7 +484,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             control.after_analysis.callback = box |state| {\n                 time(state.session.time_passes(), \"save analysis\", || {\n                     save::process_crate(state.tcx.unwrap(),\n-                                        state.krate.unwrap(),\n+                                        state.expanded_crate.unwrap(),\n                                         state.analysis.unwrap(),\n                                         state.crate_name.unwrap(),\n                                         state.out_dir,"}, {"sha": "80d8a40b4e91485a6961f296cb04833bb5f1dc38", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "patch": "@@ -49,7 +49,7 @@ use std::fs::File;\n use std::io::{self, Write};\n use std::iter;\n use std::option;\n-use std::path::PathBuf;\n+use std::path::Path;\n use std::str::FromStr;\n \n use rustc::hir::map as hir_map;\n@@ -702,13 +702,11 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n pub fn pretty_print_input(sess: &Session,\n                           cstore: &CStore,\n-                          cfg: ast::CrateConfig,\n                           input: &Input,\n+                          krate: ast::Crate,\n                           ppm: PpMode,\n                           opt_uii: Option<UserIdentifiedItem>,\n-                          ofile: Option<PathBuf>) {\n-    let krate = panictry!(driver::phase_1_parse_input(sess, cfg, input));\n-\n+                          ofile: Option<&Path>) {\n     let krate = if let PpmSource(PpmEveryBodyLoops) = ppm {\n         let mut fold = ReplaceBodyWithLoop::new();\n         fold.fold_crate(krate)\n@@ -922,7 +920,7 @@ pub fn pretty_print_input(sess: &Session,\n     match ofile {\n         None => print!(\"{}\", String::from_utf8(out).unwrap()),\n         Some(p) => {\n-            match File::create(&p) {\n+            match File::create(p) {\n                 Ok(mut w) => w.write_all(&out).unwrap(),\n                 Err(e) => panic!(\"print-print failed to open {} due to {}\", p.display(), e),\n             }"}, {"sha": "837215c3cac4e49cd2a99fbc3c978626da356a23", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee02d9f4d94f6a826d10529419b64a4ccd2a405/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "patch": "@@ -69,7 +69,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n         panic!(\"This shouldn't happen\");\n     }\n \n-    fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n+    fn build_controller(&mut self, _: &Session, _: &getopts::Matches) -> driver::CompileController<'a> {\n         panic!(\"This shouldn't be called\");\n     }\n }"}]}