{"sha": "be055d96c4c223a5ad49a0181f0b43bc46781708", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMDU1ZDk2YzRjMjIzYTVhZDQ5YTAxODFmMGI0M2JjNDY3ODE3MDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-13T22:43:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-13T22:43:06Z"}, "message": "Auto merge of #67502 - Mark-Simulacrum:opt-catch, r=Mark-Simulacrum\n\nOptimize catch_unwind to match C++ try/catch\n\nThis refactors the implementation of catching unwinds to allow LLVM to inline the \"try\" closure directly into the happy path, avoiding indirection. This means that the catch_unwind implementation is (after this PR) zero-cost unless a panic is thrown.\n\nhttps://rust.godbolt.org/z/cZcUSB is an example of the current codegen in a simple case. Notably, the codegen is *exactly the same* if `-Cpanic=abort` is passed, which is clearly not great.\n\nThis PR, on the other hand, generates the following assembly:\n\n```asm\n# -Cpanic=unwind:\n\tpush   rbx\n\tmov    ebx,0x2a\n\tcall   QWORD PTR [rip+0x1c53c]        # <happy>\n\tmov    eax,ebx\n\tpop    rbx\n\tret\n\tmov    rdi,rax\n\tcall   QWORD PTR [rip+0x1c537]        # cleanup function call\n\tcall   QWORD PTR [rip+0x1c539]        # <unfortunate>\n\tmov    ebx,0xd\n\tmov    eax,ebx\n\tpop    rbx\n\tret\n\n# -Cpanic=abort:\n\tpush   rax\n\tcall   QWORD PTR [rip+0x20a1]        # <happy>\n\tmov    eax,0x2a\n\tpop    rcx\n\tret\n```\n\nFixes #64224, and resolves #64222.", "tree": {"sha": "72cda37978123f3dff36d9c24f599837097df9db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72cda37978123f3dff36d9c24f599837097df9db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be055d96c4c223a5ad49a0181f0b43bc46781708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be055d96c4c223a5ad49a0181f0b43bc46781708", "html_url": "https://github.com/rust-lang/rust/commit/be055d96c4c223a5ad49a0181f0b43bc46781708", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be055d96c4c223a5ad49a0181f0b43bc46781708/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1572c433eed495d0ade41511ae106b180e02851d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1572c433eed495d0ade41511ae106b180e02851d", "html_url": "https://github.com/rust-lang/rust/commit/1572c433eed495d0ade41511ae106b180e02851d"}, {"sha": "9f3679fe4485aa4be4a0de9abc8aca938c60db36", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3679fe4485aa4be4a0de9abc8aca938c60db36", "html_url": "https://github.com/rust-lang/rust/commit/9f3679fe4485aa4be4a0de9abc8aca938c60db36"}], "stats": {"total": 738, "additions": 368, "deletions": 370}, "files": [{"sha": "250824321920d97d75abee30eb88e9375e5da4fd", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -52,7 +52,6 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n \n #[lang = \"eh_personality\"] extern fn rust_eh_personality() {}\n #[lang = \"panic_impl\"] extern fn rust_begin_panic(info: &PanicInfo) -> ! { unsafe { intrinsics::abort() } }\n-#[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n #[no_mangle] pub extern fn rust_eh_register_frames () {}\n #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n ```\n@@ -67,7 +66,7 @@ Other features provided by lang items include:\n   marked with lang items; those specific four are `eq`, `ord`,\n   `deref`, and `add` respectively.\n - stack unwinding and general failure; the `eh_personality`,\n-  `eh_unwind_resume`, `fail` and `fail_bounds_checks` lang items.\n+  `panic` and `panic_bounds_checks` lang items.\n - the traits in `std::marker` used to indicate types of\n   various kinds; lang items `send`, `sync` and `copy`.\n - the marker types and variance indicators found in\n@@ -130,12 +129,6 @@ fn start(_argc: isize, _argv: *const *const u8) -> isize {\n pub extern fn rust_eh_personality() {\n }\n \n-// This function may be needed based on the compilation target.\n-#[lang = \"eh_unwind_resume\"]\n-#[no_mangle]\n-pub extern fn rust_eh_unwind_resume() {\n-}\n-\n #[lang = \"panic_impl\"]\n #[no_mangle]\n pub extern fn rust_begin_panic(info: &PanicInfo) -> ! {\n@@ -173,12 +166,6 @@ pub extern fn main(_argc: i32, _argv: *const *const u8) -> i32 {\n pub extern fn rust_eh_personality() {\n }\n \n-// This function may be needed based on the compilation target.\n-#[lang = \"eh_unwind_resume\"]\n-#[no_mangle]\n-pub extern fn rust_eh_unwind_resume() {\n-}\n-\n #[lang = \"panic_impl\"]\n #[no_mangle]\n pub extern fn rust_begin_panic(info: &PanicInfo) -> ! {\n@@ -211,10 +198,8 @@ compiler. When a panic happens, this controls the message that's displayed on\n the screen. While the language item's name is `panic_impl`, the symbol name is\n `rust_begin_panic`.\n \n-A third function, `rust_eh_unwind_resume`, is also needed if the `custom_unwind_resume`\n-flag is set in the options of the compilation target. It allows customizing the\n-process of resuming unwind at the end of the landing pads. The language item's name\n-is `eh_unwind_resume`.\n+Finally, a `eh_catch_typeinfo` static is needed for certain targets which\n+implement Rust panics on top of C++ exceptions.\n \n ## List of all language items\n \n@@ -247,8 +232,6 @@ the source code.\n   - `eh_personality`: `libpanic_unwind/emcc.rs` (EMCC)\n   - `eh_personality`: `libpanic_unwind/gcc.rs` (GNU)\n   - `eh_personality`: `libpanic_unwind/seh.rs` (SEH)\n-  - `eh_unwind_resume`: `libpanic_unwind/gcc.rs` (GCC)\n-  - `eh_catch_typeinfo`: `libpanic_unwind/seh.rs` (SEH)\n   - `eh_catch_typeinfo`: `libpanic_unwind/emcc.rs` (EMCC)\n   - `panic`: `libcore/panicking.rs`\n   - `panic_bounds_check`: `libcore/panicking.rs`"}, {"sha": "c2f13047e5495c6c2aacd66b8b4f8ba48bfeb779", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -1871,14 +1871,16 @@ extern \"rust-intrinsic\" {\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> u64;\n \n-    /// Rust's \"try catch\" construct which invokes the function pointer `f` with\n-    /// the data pointer `data`.\n+    /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n+    /// with the data pointer `data`.\n     ///\n-    /// The third pointer is a target-specific data pointer which is filled in\n-    /// with the specifics of the exception that occurred. For examples on Unix\n-    /// platforms this is a `*mut *mut T` which is filled in by the compiler and\n-    /// on MSVC it's `*mut [usize; 2]`. For more information see the compiler's\n+    /// The third argument is a function called if a panic occurs. This function\n+    /// takes the data pointer and a pointer to the target-specific exception\n+    /// object that was caught. For more information see the compiler's\n     /// source as well as std's catch implementation.\n+    #[cfg(not(bootstrap))]\n+    pub fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32;\n+    #[cfg(bootstrap)]\n     pub fn r#try(f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32;\n \n     /// Emits a `!nontemporal` store according to LLVM (see their docs)."}, {"sha": "f44a875c9d0d5450b022631b138f59470d05fd12", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -18,17 +18,11 @@\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n \n-// Rust's \"try\" function, but if we're aborting on panics we just call the\n-// function as there's nothing else we need to do here.\n+use core::any::Any;\n+\n #[rustc_std_internal_symbol]\n-pub unsafe extern \"C\" fn __rust_maybe_catch_panic(\n-    f: fn(*mut u8),\n-    data: *mut u8,\n-    _data_ptr: *mut usize,\n-    _vtable_ptr: *mut usize,\n-) -> u32 {\n-    f(data);\n-    0\n+pub unsafe extern \"C\" fn __rust_panic_cleanup(_: *mut u8) -> *mut (dyn Any + Send + 'static) {\n+    unreachable!()\n }\n \n // \"Leak\" the payload and shim to the relevant abort on the platform in\n@@ -92,7 +86,7 @@ pub unsafe extern \"C\" fn __rust_start_panic(_payload: usize) -> u32 {\n // binaries, but it should never be called as we don't link in an unwinding\n // runtime at all.\n pub mod personalities {\n-    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n     #[cfg(not(any(\n         all(target_arch = \"wasm32\", not(target_os = \"emscripten\"),),\n         all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86_64\",),\n@@ -101,7 +95,7 @@ pub mod personalities {\n \n     // On x86_64-pc-windows-gnu we use our own personality function that needs\n     // to return `ExceptionContinueSearch` as we're passing on all our frames.\n-    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n     #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86_64\"))]\n     pub extern \"C\" fn rust_eh_personality(\n         _record: usize,\n@@ -117,16 +111,16 @@ pub mod personalities {\n     //\n     // Note that we don't execute landing pads, so this is never called, so it's\n     // body is empty.\n-    #[no_mangle]\n-    #[cfg(all(target_os = \"windows\", target_env = \"gnu\"))]\n+    #[rustc_std_internal_symbol]\n+    #[cfg(all(bootstrap, target_os = \"windows\", target_env = \"gnu\"))]\n     pub extern \"C\" fn rust_eh_unwind_resume() {}\n \n     // These two are called by our startup objects on i686-pc-windows-gnu, but\n     // they don't need to do anything so the bodies are nops.\n-    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n     #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n     pub extern \"C\" fn rust_eh_register_frames() {}\n-    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n     #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n     pub extern \"C\" fn rust_eh_unregister_frames() {}\n }"}, {"sha": "4667ede2baad5131ef5587f06c2c3b153f8f9bb8", "filename": "src/libpanic_unwind/dummy.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdummy.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -6,10 +6,6 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::intrinsics;\n \n-pub fn payload() -> *mut u8 {\n-    core::ptr::null_mut()\n-}\n-\n pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n     intrinsics::abort()\n }"}, {"sha": "c7144fe16cddabc70c00b4cc3e54d00dac8e6431", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -48,15 +48,11 @@ static EXCEPTION_TYPE_INFO: TypeInfo = TypeInfo {\n     name: b\"rust_panic\\0\".as_ptr(),\n };\n \n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n-\n struct Exception {\n     // This needs to be an Option because the object's lifetime follows C++\n     // semantics: when catch_unwind moves the Box out of the exception it must\n     // still leave the exception object in a valid state because its destructor\n-    // is still going to be called by __cxa_end_catch..\n+    // is still going to be called by __cxa_end_catch.\n     data: Option<Box<dyn Any + Send>>,\n }\n \n@@ -98,7 +94,6 @@ extern \"C\" fn exception_cleanup(ptr: *mut libc::c_void) -> DestructorRet {\n }\n \n #[lang = \"eh_personality\"]\n-#[no_mangle]\n unsafe extern \"C\" fn rust_eh_personality(\n     version: c_int,\n     actions: uw::_Unwind_Action,"}, {"sha": "9c032b30341e9da44c75bd3cb2eb1e2f956d8f06", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -35,20 +35,11 @@\n //!\n //! Once stack has been unwound down to the handler frame level, unwinding stops\n //! and the last personality routine transfers control to the catch block.\n-//!\n-//! ## `eh_personality` and `eh_unwind_resume`\n-//!\n-//! These language items are used by the compiler when generating unwind info.\n-//! The first one is the personality routine described above. The second one\n-//! allows compilation target to customize the process of resuming unwind at the\n-//! end of the landing pads. `eh_unwind_resume` is used only if\n-//! `custom_unwind_resume` flag in the target options is set.\n \n #![allow(private_no_mangle_fns)]\n \n use alloc::boxed::Box;\n use core::any::Any;\n-use core::ptr;\n \n use crate::dwarf::eh::{self, EHAction, EHContext};\n use libc::{c_int, uintptr_t};\n@@ -83,10 +74,6 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     }\n }\n \n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n-\n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let exception = Box::from_raw(ptr as *mut Exception);\n     exception.cause\n@@ -143,7 +130,6 @@ cfg_if::cfg_if! {\n         //\n         // iOS uses the default routine instead since it uses SjLj unwinding.\n         #[lang = \"eh_personality\"]\n-        #[no_mangle]\n         unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n                                                  exception_object: *mut uw::_Unwind_Exception,\n                                                  context: *mut uw::_Unwind_Context)\n@@ -277,7 +263,6 @@ cfg_if::cfg_if! {\n                 // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n                 // handler data (aka LSDA) uses GCC-compatible encoding.\n                 #[lang = \"eh_personality\"]\n-                #[no_mangle]\n                 #[allow(nonstandard_style)]\n                 unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut uw::EXCEPTION_RECORD,\n                         establisherFrame: uw::LPVOID,\n@@ -293,7 +278,6 @@ cfg_if::cfg_if! {\n             } else {\n                 // The personality routine for most of our targets.\n                 #[lang = \"eh_personality\"]\n-                #[no_mangle]\n                 unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n                         actions: uw::_Unwind_Action,\n                         exception_class: uw::_Unwind_Exception_Class,\n@@ -329,8 +313,8 @@ unsafe fn find_eh_action(\n     eh::find_eh_action(lsda, &eh_context, foreign_exception)\n }\n \n-// See docs in the `unwind` module.\n #[cfg(all(\n+    bootstrap,\n     target_os = \"windows\",\n     any(target_arch = \"x86\", target_arch = \"x86_64\"),\n     target_env = \"gnu\"\n@@ -364,12 +348,12 @@ pub mod eh_frame_registry {\n         fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n     }\n \n-    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn rust_eh_register_frames(eh_frame_begin: *const u8, object: *mut u8) {\n         __register_frame_info(eh_frame_begin, object);\n     }\n \n-    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn rust_eh_unregister_frames(eh_frame_begin: *const u8, object: *mut u8) {\n         __deregister_frame_info(eh_frame_begin, object);\n     }"}, {"sha": "6bded4dd499bd7b0a6774f9df07eb31787390004", "filename": "src/libpanic_unwind/hermit.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fhermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fhermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fhermit.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -6,10 +6,6 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::ptr;\n \n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n-\n pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n     extern \"C\" {\n         pub fn __rust_abort() -> !;"}, {"sha": "d6c3366693818583466adac05bed0588e2e6c12a", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -22,19 +22,18 @@\n #![feature(libc)]\n #![feature(nll)]\n #![feature(panic_unwind)]\n-#![feature(raw)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(unwind_attributes)]\n #![feature(abi_thiscall)]\n+#![feature(rustc_attrs)]\n+#![feature(raw)]\n #![panic_runtime]\n #![feature(panic_runtime)]\n \n use alloc::boxed::Box;\n-use core::intrinsics;\n-use core::mem;\n+use core::any::Any;\n use core::panic::BoxMeUp;\n-use core::raw;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n@@ -69,33 +68,14 @@ extern \"C\" {\n \n mod dwarf;\n \n-// Entry point for catching an exception, implemented using the `try` intrinsic\n-// in the compiler.\n-//\n-// The interaction between the `payload` function and the compiler is pretty\n-// hairy and tightly coupled, for more information see the compiler's\n-// implementation of this.\n-#[no_mangle]\n-pub unsafe extern \"C\" fn __rust_maybe_catch_panic(\n-    f: fn(*mut u8),\n-    data: *mut u8,\n-    data_ptr: *mut usize,\n-    vtable_ptr: *mut usize,\n-) -> u32 {\n-    let mut payload = imp::payload();\n-    if intrinsics::r#try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n-        0\n-    } else {\n-        let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));\n-        *data_ptr = obj.data as usize;\n-        *vtable_ptr = obj.vtable as usize;\n-        1\n-    }\n+#[rustc_std_internal_symbol]\n+pub unsafe extern \"C\" fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static) {\n+    Box::into_raw(imp::cleanup(payload))\n }\n \n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n-#[no_mangle]\n+#[rustc_std_internal_symbol]\n #[unwind(allowed)]\n pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n     let payload = payload as *mut &mut dyn BoxMeUp;"}, {"sha": "c294fe26327d7ac3d2f73c61b26eff28c398a755", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -49,10 +49,17 @@\n \n use alloc::boxed::Box;\n use core::any::Any;\n-use core::mem;\n-use core::raw;\n+use core::mem::{self, ManuallyDrop};\n use libc::{c_int, c_uint, c_void};\n \n+struct Exception {\n+    // This needs to be an Option because we catch the exception by reference\n+    // and its destructor is executed by the C++ runtime. When we take the Box\n+    // out of the exception, we need to leave the exception in a valid state\n+    // for its destructor to run without double-dropping the Box.\n+    data: Option<Box<dyn Any + Send>>,\n+}\n+\n // First up, a whole bunch of type definitions. There's a few platform-specific\n // oddities here, and a lot that's just blatantly copied from LLVM. The purpose\n // of all this is to implement the `panic` function below through a call to\n@@ -167,6 +174,9 @@ pub struct _TypeDescriptor {\n \n // Note that we intentionally ignore name mangling rules here: we don't want C++\n // to be able to catch Rust panics by simply declaring a `struct rust_panic`.\n+//\n+// When modifying, make sure that the type name string exactly matches\n+// the one used in src/librustc_codegen_llvm/intrinsic.rs.\n const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n \n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n@@ -183,7 +193,7 @@ static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n     properties: 0,\n     pType: ptr!(0),\n     thisDisplacement: _PMD { mdisp: 0, pdisp: -1, vdisp: 0 },\n-    sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n+    sizeOrOffset: mem::size_of::<Exception>() as c_int,\n     copyFunction: ptr!(0),\n };\n \n@@ -199,12 +209,12 @@ extern \"C\" {\n     static TYPE_INFO_VTABLE: *const u8;\n }\n \n-// We use #[lang = \"eh_catch_typeinfo\"] here as this is the type descriptor which\n-// we'll use in LLVM's `catchpad` instruction which ends up also being passed as\n-// an argument to the C++ personality function.\n+// This type descriptor is only used when throwing an exception. The catch part\n+// is handled by the try intrinsic, which generates its own TypeDescriptor.\n //\n-// Again, I'm not entirely sure what this is describing, it just seems to work.\n-#[cfg_attr(not(test), lang = \"eh_catch_typeinfo\")]\n+// This is fine since the MSVC runtime uses string comparison on the type name\n+// to match TypeDescriptors rather than pointer equality.\n+#[cfg_attr(bootstrap, lang = \"eh_catch_typeinfo\")]\n static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n     pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n     spare: core::ptr::null_mut(),\n@@ -226,16 +236,16 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n // because Box<dyn Any> isn't clonable.\n macro_rules! define_cleanup {\n     ($abi:tt) => {\n-        unsafe extern $abi fn exception_cleanup(e: *mut [u64; 2]) {\n-            if (*e)[0] != 0 {\n-                cleanup(*e);\n+        unsafe extern $abi fn exception_cleanup(e: *mut Exception) {\n+            if let Exception { data: Some(b) } = e.read() {\n+                drop(b);\n                 super::__rust_drop_panic();\n             }\n         }\n         #[unwind(allowed)]\n-        unsafe extern $abi fn exception_copy(_dest: *mut [u64; 2],\n-                                             _src: *mut [u64; 2])\n-                                             -> *mut [u64; 2] {\n+        unsafe extern $abi fn exception_copy(_dest: *mut Exception,\n+                                             _src: *mut Exception)\n+                                             -> *mut Exception {\n             panic!(\"Rust panics cannot be copied\");\n         }\n     }\n@@ -255,12 +265,11 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // need to otherwise transfer `data` to the heap. We just pass a stack\n     // pointer to this function.\n     //\n-    // The first argument is the payload being thrown (our two pointers), and\n-    // the second argument is the type information object describing the\n-    // exception (constructed above).\n-    let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n-    let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n-    let throw_ptr = ptrs.as_mut_ptr() as *mut _;\n+    // The ManuallyDrop is needed here since we don't want Exception to be\n+    // dropped when unwinding. Instead it will be dropped by exception_cleanup\n+    // which is invoked by the C++ runtime.\n+    let mut exception = ManuallyDrop::new(Exception { data: Some(data) });\n+    let throw_ptr = &mut exception as *mut _ as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,\n@@ -308,12 +317,9 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     _CxxThrowException(throw_ptr, &mut THROW_INFO as *mut _ as *mut _);\n }\n \n-pub fn payload() -> [u64; 2] {\n-    [0; 2]\n-}\n-\n-pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n-    mem::transmute(raw::TraitObject { data: payload[0] as *mut _, vtable: payload[1] as *mut _ })\n+pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n+    let exception = &mut *(payload as *mut Exception);\n+    exception.data.take().unwrap()\n }\n \n // This is required by the compiler to exist (e.g., it's a lang item), but"}, {"sha": "36560371587a53c8b5d6c4937650604f60e356e1", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -57,8 +57,7 @@ pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: LangItem) -> bool {\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n     if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        return lang_item == LangItem::EhPersonalityLangItem\n-            || lang_item == LangItem::EhUnwindResumeLangItem;\n+        return lang_item == LangItem::EhPersonalityLangItem;\n     }\n \n     false"}, {"sha": "d9c88951440f491a2f35a94c1c4b7f77e35862ee", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -1,4 +1,3 @@\n-use crate::abi::FnAbi;\n use crate::attributes;\n use crate::debuginfo;\n use crate::llvm;\n@@ -15,23 +14,20 @@ use rustc::mir::mono::CodegenUnit;\n use rustc::session::config::{self, CFGuard, DebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{\n-    FnAbiExt, HasParamEnv, LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx,\n+    HasParamEnv, LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx,\n };\n use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_data_structures::base_n;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_hir::Unsafety;\n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use crate::abi::Abi;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::Symbol;\n use std::cell::{Cell, RefCell};\n use std::ffi::CStr;\n-use std::iter;\n use std::str;\n use std::sync::Arc;\n \n@@ -87,7 +83,6 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n \n     eh_personality: Cell<Option<&'ll Value>>,\n-    eh_unwind_resume: Cell<Option<&'ll Value>>,\n     pub rust_try_fn: Cell<Option<&'ll Value>>,\n \n     intrinsics: RefCell<FxHashMap<&'static str, &'ll Value>>,\n@@ -327,7 +322,6 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             isize_ty,\n             dbg_cx,\n             eh_personality: Cell::new(None),\n-            eh_unwind_resume: Cell::new(None),\n             rust_try_fn: Cell::new(None),\n             intrinsics: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n@@ -405,45 +399,6 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         llfn\n     }\n \n-    // Returns a Value of the \"eh_unwind_resume\" lang item if one is defined,\n-    // otherwise declares it as an external function.\n-    fn eh_unwind_resume(&self) -> &'ll Value {\n-        let unwresume = &self.eh_unwind_resume;\n-        if let Some(llfn) = unwresume.get() {\n-            return llfn;\n-        }\n-\n-        let tcx = self.tcx;\n-        assert!(self.sess().target.target.options.custom_unwind_resume);\n-        if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n-            let llfn = self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    tcx.intern_substs(&[]),\n-                )\n-                .unwrap(),\n-            );\n-            unwresume.set(Some(llfn));\n-            return llfn;\n-        }\n-\n-        let sig = ty::Binder::bind(tcx.mk_fn_sig(\n-            iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n-            tcx.types.never,\n-            false,\n-            Unsafety::Unsafe,\n-            Abi::C,\n-        ));\n-\n-        let fn_abi = FnAbi::of_fn_ptr(self, sig, &[]);\n-        let llfn = self.declare_fn(\"rust_eh_unwind_resume\", &fn_abi);\n-        attributes::apply_target_cpu_attr(self, llfn);\n-        unwresume.set(Some(llfn));\n-        llfn\n-    }\n-\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }"}, {"sha": "5ce18a9007a629e7efc77b97a43344fad9f61bdf", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 77, "deletions": 61, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -851,19 +851,21 @@ fn memset_intrinsic(\n \n fn try_intrinsic(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    func: &'ll Value,\n+    try_func: &'ll Value,\n     data: &'ll Value,\n-    local_ptr: &'ll Value,\n+    catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n     if bx.sess().no_landing_pads() {\n-        bx.call(func, &[data], None);\n-        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        bx.store(bx.const_null(bx.type_i8p()), dest, ptr_align);\n+        bx.call(try_func, &[data], None);\n+        // Return 0 unconditionally from the intrinsic call;\n+        // we can never unwind.\n+        let ret_align = bx.tcx().data_layout.i32_align.abi;\n+        bx.store(bx.const_i32(0), dest, ret_align);\n     } else if wants_msvc_seh(bx.sess()) {\n-        codegen_msvc_try(bx, func, data, local_ptr, dest);\n+        codegen_msvc_try(bx, try_func, data, catch_func, dest);\n     } else {\n-        codegen_gnu_try(bx, func, data, local_ptr, dest);\n+        codegen_gnu_try(bx, try_func, data, catch_func, dest);\n     }\n }\n \n@@ -876,9 +878,9 @@ fn try_intrinsic(\n // as the old ones are still more optimized.\n fn codegen_msvc_try(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    func: &'ll Value,\n+    try_func: &'ll Value,\n     data: &'ll Value,\n-    local_ptr: &'ll Value,\n+    catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n@@ -890,15 +892,15 @@ fn codegen_msvc_try(\n         let mut catchpad = bx.build_sibling_block(\"catchpad\");\n         let mut caught = bx.build_sibling_block(\"caught\");\n \n-        let func = llvm::get_param(bx.llfn(), 0);\n+        let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n-        let local_ptr = llvm::get_param(bx.llfn(), 2);\n+        let catch_func = llvm::get_param(bx.llfn(), 2);\n \n         // We're generating an IR snippet that looks like:\n         //\n-        //   declare i32 @rust_try(%func, %data, %ptr) {\n-        //      %slot = alloca [2 x i64]\n-        //      invoke %func(%data) to label %normal unwind label %catchswitch\n+        //   declare i32 @rust_try(%try_func, %data, %catch_func) {\n+        //      %slot = alloca u8*\n+        //      invoke %try_func(%data) to label %normal unwind label %catchswitch\n         //\n         //   normal:\n         //      ret i32 0\n@@ -908,8 +910,8 @@ fn codegen_msvc_try(\n         //\n         //   catchpad:\n         //      %tok = catchpad within %cs [%type_descriptor, 0, %slot]\n-        //      %ptr[0] = %slot[0]\n-        //      %ptr[1] = %slot[1]\n+        //      %ptr = load %slot\n+        //      call %catch_func(%data, %ptr)\n         //      catchret from %tok to label %caught\n         //\n         //   caught:\n@@ -926,56 +928,67 @@ fn codegen_msvc_try(\n         //          ~rust_panic();\n         //\n         //          uint64_t x[2];\n-        //      }\n+        //      };\n         //\n-        //      int bar(void (*foo)(void), uint64_t *ret) {\n+        //      int __rust_try(\n+        //          void (*try_func)(void*),\n+        //          void *data,\n+        //          void (*catch_func)(void*, void*) noexcept\n+        //      ) {\n         //          try {\n-        //              foo();\n+        //              try_func(data);\n         //              return 0;\n         //          } catch(rust_panic& a) {\n-        //              ret[0] = a.x[0];\n-        //              ret[1] = a.x[1];\n-        //              a.x[0] = 0;\n+        //              catch_func(data, &a);\n         //              return 1;\n         //          }\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64_2 = bx.type_array(bx.type_i64(), 2);\n-        let i64_2_ptr = bx.type_ptr_to(i64_2);\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64_2_ptr, ptr_align);\n-        bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n+        let slot = bx.alloca(bx.type_i8p(), ptr_align);\n+        bx.invoke(try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n+        // We can't use the TypeDescriptor defined in libpanic_unwind because it\n+        // might be in another DLL and the SEH encoding only supports specifying\n+        // a TypeDescriptor from the current module.\n+        //\n+        // However this isn't an issue since the MSVC runtime uses string\n+        // comparison on the type name to match TypeDescriptors rather than\n+        // pointer equality.\n+        //\n+        // So instead we generate a new TypeDescriptor in each module that uses\n+        // `try` and let the linker merge duplicate definitions in the same\n+        // module.\n+        //\n+        // When modifying, make sure that the type_name string exactly matches\n+        // the one used in src/libpanic_unwind/seh.rs.\n+        let type_info_vtable = bx.declare_global(\"??_7type_info@@6B@\", bx.type_i8p());\n+        let type_name = bx.const_bytes(b\"rust_panic\\0\");\n+        let type_info =\n+            bx.const_struct(&[type_info_vtable, bx.const_null(bx.type_i8p()), type_name], false);\n+        let tydesc = bx.declare_global(\"__rust_panic_type_info\", bx.val_ty(type_info));\n+        unsafe {\n+            llvm::LLVMRustSetLinkage(tydesc, llvm::Linkage::LinkOnceODRLinkage);\n+            llvm::SetUniqueComdat(bx.llmod, tydesc);\n+            llvm::LLVMSetInitializer(tydesc, type_info);\n+        }\n+\n         // The flag value of 8 indicates that we are catching the exception by\n         // reference instead of by value. We can't use catch by value because\n         // that requires copying the exception object, which we don't support\n         // since our exception object effectively contains a Box.\n         //\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n         let flags = bx.const_i32(8);\n-        let tydesc = match bx.tcx().lang_items().eh_catch_typeinfo() {\n-            Some(did) => bx.get_static(did),\n-            None => bug!(\"eh_catch_typeinfo not defined, but needed for SEH unwinding\"),\n-        };\n         let funclet = catchpad.catch_pad(cs, &[tydesc, flags, slot]);\n-\n-        let i64_align = bx.tcx().data_layout.i64_align.abi;\n-        let payload_ptr = catchpad.load(slot, ptr_align);\n-        let payload = catchpad.load(payload_ptr, i64_align);\n-        let local_ptr = catchpad.bitcast(local_ptr, bx.type_ptr_to(i64_2));\n-        catchpad.store(payload, local_ptr, i64_align);\n-\n-        // Clear the first word of the exception so avoid double-dropping it.\n-        // This will be read by the destructor which is implicitly called at the\n-        // end of the catch block by the runtime.\n-        let payload_0_ptr = catchpad.inbounds_gep(payload_ptr, &[bx.const_i32(0), bx.const_i32(0)]);\n-        catchpad.store(bx.const_u64(0), payload_0_ptr, i64_align);\n+        let ptr = catchpad.load(slot, ptr_align);\n+        catchpad.call(catch_func, &[data, ptr], Some(&funclet));\n \n         catchpad.catch_ret(&funclet, caught.llbb());\n \n@@ -984,7 +997,7 @@ fn codegen_msvc_try(\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[func, data, local_ptr], None);\n+    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1002,38 +1015,34 @@ fn codegen_msvc_try(\n // the right personality function.\n fn codegen_gnu_try(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    func: &'ll Value,\n+    try_func: &'ll Value,\n     data: &'ll Value,\n-    local_ptr: &'ll Value,\n+    catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         // Codegens the shims described above:\n         //\n         //   bx:\n-        //      invoke %func(%args...) normal %normal unwind %catch\n+        //      invoke %try_func(%data) normal %normal unwind %catch\n         //\n         //   normal:\n         //      ret 0\n         //\n         //   catch:\n-        //      (ptr, _) = landingpad\n-        //      store ptr, %local_ptr\n+        //      (%ptr, _) = landingpad\n+        //      call %catch_func(%data, %ptr)\n         //      ret 1\n-        //\n-        // Note that the `local_ptr` data passed into the `try` intrinsic is\n-        // expected to be `*mut *mut u8` for this to actually work, but that's\n-        // managed by the standard library.\n \n         bx.sideeffect();\n \n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n \n-        let func = llvm::get_param(bx.llfn(), 0);\n+        let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n-        let local_ptr = llvm::get_param(bx.llfn(), 2);\n-        bx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n+        let catch_func = llvm::get_param(bx.llfn(), 2);\n+        bx.invoke(try_func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n@@ -1053,15 +1062,13 @@ fn codegen_gnu_try(\n         };\n         catch.add_clause(vals, tydesc);\n         let ptr = catch.extract_value(vals, 0);\n-        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let bitcast = catch.bitcast(local_ptr, bx.type_ptr_to(bx.type_i8p()));\n-        catch.store(ptr, bitcast, ptr_align);\n+        catch.call(catch_func, &[data, ptr], None);\n         catch.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[func, data, local_ptr], None);\n+    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1084,6 +1091,8 @@ fn gen_fn<'ll, 'tcx>(\n     ));\n     let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n     let llfn = cx.declare_fn(name, &fn_abi);\n+    cx.set_frame_pointer_elimination(llfn);\n+    cx.apply_target_cpu_attr(llfn);\n     // FIXME(eddyb) find a nicer way to do this.\n     unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n     let bx = Builder::new_block(cx, llfn, \"entry-block\");\n@@ -1106,15 +1115,22 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n         iter::once(i8p),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+        [i8p, i8p].iter().cloned(),\n+        tcx.mk_unit(),\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(cx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, codegen);\n+    let rust_try = gen_fn(cx, \"__rust_try\", vec![try_fn_ty, i8p, catch_fn_ty], output, codegen);\n     cx.rust_try_fn.set(Some(rust_try));\n     rust_try\n }"}, {"sha": "a4eef2374c2413105be033eee2605b50f7cb2d96", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -490,6 +490,11 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let (linker, flavor) = linker_and_flavor(sess);\n \n+    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n+        || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n+            *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+        });\n+\n     // The invocations of cc share some flags across platforms\n     let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n \n@@ -555,6 +560,15 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n+    if any_dynamic_crate {\n+        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n+            cmd.args(args);\n+        }\n+    } else {\n+        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n+            cmd.args(args);\n+        }\n+    }\n     for obj in &sess.target.target.options.post_link_objects {\n         cmd.arg(get_file_path(sess, obj));\n     }"}, {"sha": "8433f793020774962e1fbb0318997007ca13b7a4", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -178,15 +178,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let lp1 = bx.load_operand(lp1).immediate();\n             slot.storage_dead(&mut bx);\n \n-            if !bx.sess().target.target.options.custom_unwind_resume {\n-                let mut lp = bx.const_undef(self.landing_pad_type());\n-                lp = bx.insert_value(lp, lp0, 0);\n-                lp = bx.insert_value(lp, lp1, 1);\n-                bx.resume(lp);\n-            } else {\n-                bx.call(bx.eh_unwind_resume(), &[lp0], helper.funclet(self));\n-                bx.unreachable();\n-            }\n+            let mut lp = bx.const_undef(self.landing_pad_type());\n+            lp = bx.insert_value(lp, lp0, 0);\n+            lp = bx.insert_value(lp, lp1, 1);\n+            bx.resume(lp);\n         }\n     }\n "}, {"sha": "d7587163ba00168dc4ccb828f3f91cf8432d172c", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -14,7 +14,6 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn get_fn(&self, instance: Instance<'tcx>) -> Self::Function;\n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> Self::Value;\n     fn eh_personality(&self) -> Self::Value;\n-    fn eh_unwind_resume(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>>;\n     fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;"}, {"sha": "89457009a8bfa4d32dbe533e91b99e44947a1a7d", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -240,7 +240,6 @@ language_item_table! {\n     StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n \n     EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n-    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n     EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n \n     OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;"}, {"sha": "c0560eb8d455a9deee694c607e0404b9d843688d", "filename": "src/librustc_hir/weak_lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_hir%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_hir%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fweak_lang_items.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -43,6 +43,5 @@ impl LanguageItems {\n weak_lang_items! {\n     panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n     eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n-    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n     oom,                OomLangItem,                rust_oom;\n }"}, {"sha": "7bf49d56531897e086c6f1213c6aab3e0a1c83f4", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -28,9 +28,6 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n     if items.eh_personality().is_none() {\n         items.missing.push(lang_items::EhPersonalityLangItem);\n     }\n-    if tcx.sess.target.target.options.custom_unwind_resume & items.eh_unwind_resume().is_none() {\n-        items.missing.push(lang_items::EhUnwindResumeLangItem);\n-    }\n \n     {\n         let mut cx = Context { tcx, items };"}, {"sha": "bca4bfee85ad80ed69cbe44522da45281fc48a6f", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -289,7 +289,6 @@ symbols! {\n         dylib,\n         dyn_trait,\n         eh_personality,\n-        eh_unwind_resume,\n         enable,\n         Encodable,\n         env,\n@@ -665,7 +664,6 @@ symbols! {\n         rustc_variance,\n         rustfmt,\n         rust_eh_personality,\n-        rust_eh_unwind_resume,\n         rust_oom,\n         rvalue_static_promotion,\n         sanitize,"}, {"sha": "6e5111bd7018a460db2aaf627e5801b56f3be49c", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -581,6 +581,12 @@ pub struct TargetOptions {\n     /// user-defined but before post_link_objects. Standard platform\n     /// libraries that should be always be linked to, usually go here.\n     pub late_link_args: LinkArgs,\n+    /// Linker arguments used in addition to `late_link_args` if at least one\n+    /// Rust dependency is dynamically linked.\n+    pub late_link_args_dynamic: LinkArgs,\n+    /// Linker arguments used in addition to `late_link_args` if aall Rust\n+    /// dependencies are statically linked.\n+    pub late_link_args_static: LinkArgs,\n     /// Objects to link after all others, always found within the\n     /// sysroot folder.\n     pub post_link_objects: Vec<String>, // ... unconditionally\n@@ -694,11 +700,6 @@ pub struct TargetOptions {\n     pub archive_format: String,\n     /// Is asm!() allowed? Defaults to true.\n     pub allow_asm: bool,\n-    /// Whether the target uses a custom unwind resumption routine.\n-    /// By default LLVM lowers `resume` instructions into calls to `_Unwind_Resume`\n-    /// defined in libgcc. If this option is enabled, the target must provide\n-    /// `eh_unwind_resume` lang item.\n-    pub custom_unwind_resume: bool,\n     /// Whether the runtime startup code requires the `main` function be passed\n     /// `argc` and `argv` values.\n     pub main_needs_argc_argv: bool,\n@@ -865,10 +866,11 @@ impl Default for TargetOptions {\n             post_link_objects: Vec::new(),\n             post_link_objects_crt: Vec::new(),\n             late_link_args: LinkArgs::new(),\n+            late_link_args_dynamic: LinkArgs::new(),\n+            late_link_args_static: LinkArgs::new(),\n             link_env: Vec::new(),\n             link_env_remove: Vec::new(),\n             archive_format: \"gnu\".to_string(),\n-            custom_unwind_resume: false,\n             main_needs_argc_argv: true,\n             allow_asm: true,\n             has_elf_tls: false,\n@@ -1144,6 +1146,8 @@ impl Target {\n         key!(pre_link_objects_exe_crt, list);\n         key!(pre_link_objects_dll, list);\n         key!(late_link_args, link_args);\n+        key!(late_link_args_dynamic, link_args);\n+        key!(late_link_args_static, link_args);\n         key!(post_link_objects, list);\n         key!(post_link_objects_crt, list);\n         key!(post_link_args, link_args);\n@@ -1184,7 +1188,6 @@ impl Target {\n         key!(relro_level, RelroLevel)?;\n         key!(archive_format);\n         key!(allow_asm, bool);\n-        key!(custom_unwind_resume, bool);\n         key!(main_needs_argc_argv, bool);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n@@ -1372,6 +1375,8 @@ impl ToJson for Target {\n         target_option_val!(pre_link_objects_exe_crt);\n         target_option_val!(pre_link_objects_dll);\n         target_option_val!(link_args - late_link_args);\n+        target_option_val!(link_args - late_link_args_dynamic);\n+        target_option_val!(link_args - late_link_args_static);\n         target_option_val!(post_link_objects);\n         target_option_val!(post_link_objects_crt);\n         target_option_val!(link_args - post_link_args);\n@@ -1412,7 +1417,6 @@ impl ToJson for Target {\n         target_option_val!(relro_level);\n         target_option_val!(archive_format);\n         target_option_val!(allow_asm);\n-        target_option_val!(custom_unwind_resume);\n         target_option_val!(main_needs_argc_argv);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);"}, {"sha": "188548b41fe75fda00784adf71f26e4f4ff2e0e8", "filename": "src/librustc_target/spec/windows_base.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -17,12 +17,13 @@ pub fn opts() -> TargetOptions {\n     );\n \n     let mut late_link_args = LinkArgs::new();\n+    let mut late_link_args_dynamic = LinkArgs::new();\n+    let mut late_link_args_static = LinkArgs::new();\n     late_link_args.insert(\n         LinkerFlavor::Gcc,\n         vec![\n             \"-lmingwex\".to_string(),\n             \"-lmingw32\".to_string(),\n-            \"-lgcc\".to_string(), // alas, mingw* libraries above depend on libgcc\n             \"-lmsvcrt\".to_string(),\n             // mingw's msvcrt is a weird hybrid import library and static library.\n             // And it seems that the linker fails to use import symbols from msvcrt\n@@ -37,6 +38,31 @@ pub fn opts() -> TargetOptions {\n             \"-lkernel32\".to_string(),\n         ],\n     );\n+    late_link_args_dynamic.insert(\n+        LinkerFlavor::Gcc,\n+        vec![\n+            // If any of our crates are dynamically linked then we need to use\n+            // the shared libgcc_s-dw2-1.dll. This is required to support\n+            // unwinding across DLL boundaries.\n+            \"-lgcc_s\".to_string(),\n+            \"-lgcc\".to_string(),\n+            \"-lkernel32\".to_string(),\n+        ],\n+    );\n+    late_link_args_static.insert(\n+        LinkerFlavor::Gcc,\n+        vec![\n+            // If all of our crates are statically linked then we can get away\n+            // with statically linking the libgcc unwinding code. This allows\n+            // binaries to be redistributed without the libgcc_s-dw2-1.dll\n+            // dependency, but unfortunately break unwinding across DLL\n+            // boundaries when unwinding across FFI boundaries.\n+            \"-lgcc\".to_string(),\n+            \"-lgcc_eh\".to_string(),\n+            \"-lpthread\".to_string(),\n+            \"-lkernel32\".to_string(),\n+        ],\n+    );\n \n     TargetOptions {\n         // FIXME(#13846) this should be enabled for windows\n@@ -63,8 +89,9 @@ pub fn opts() -> TargetOptions {\n             \"rsbegin.o\".to_string(),\n         ],\n         late_link_args,\n+        late_link_args_dynamic,\n+        late_link_args_static,\n         post_link_objects: vec![\"rsend.o\".to_string()],\n-        custom_unwind_resume: true,\n         abi_return_struct_as_int: true,\n         emit_debug_gdb_scripts: false,\n         requires_uwtable: true,"}, {"sha": "3f7eb442bbc73049d6a6bf58c212c9eaaa1b26ce", "filename": "src/librustc_target/spec/windows_uwp_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_base.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -54,7 +54,6 @@ pub fn opts() -> TargetOptions {\n         pre_link_objects_dll: vec![\"rsbegin.o\".to_string()],\n         late_link_args,\n         post_link_objects: vec![\"rsend.o\".to_string()],\n-        custom_unwind_resume: true,\n         abi_return_struct_as_int: true,\n         emit_debug_gdb_scripts: false,\n         requires_uwtable: true,"}, {"sha": "07f392fa23b3777e441da4cf68bf5ff334f05451", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -299,14 +299,25 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let try_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n                     tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust,\n                 ));\n-                (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n+                let catch_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                    [mut_u8, mut_u8].iter().cloned(),\n+                    tcx.mk_unit(),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust,\n+                ));\n+                (\n+                    0,\n+                    vec![tcx.mk_fn_ptr(try_fn_ty), mut_u8, tcx.mk_fn_ptr(catch_fn_ty)],\n+                    tcx.types.i32,\n+                )\n             }\n \n             \"va_start\" | \"va_end\" => match mk_va_list_ty(hir::Mutability::Mut) {"}, {"sha": "0be71b52d9edd559d2efadfeec6553c3b332f54c", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 66, "deletions": 26, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -14,7 +14,6 @@ use crate::fmt;\n use crate::intrinsics;\n use crate::mem::{self, ManuallyDrop};\n use crate::process;\n-use crate::raw;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::stdio::panic_output;\n use crate::sys_common::backtrace::{self, RustBacktrace};\n@@ -41,12 +40,7 @@ use realstd::io::set_panic;\n // hook up these functions, but it is not this day!\n #[allow(improper_ctypes)]\n extern \"C\" {\n-    fn __rust_maybe_catch_panic(\n-        f: fn(*mut u8),\n-        data: *mut u8,\n-        data_ptr: *mut usize,\n-        vtable_ptr: *mut usize,\n-    ) -> u32;\n+    fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static);\n \n     /// `payload` is actually a `*mut &mut dyn BoxMeUp` but that would cause FFI warnings.\n     /// It cannot be `Box<dyn BoxMeUp>` because the other end of this call does not depend\n@@ -247,12 +241,13 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     union Data<F, R> {\n         f: ManuallyDrop<F>,\n         r: ManuallyDrop<R>,\n+        p: ManuallyDrop<Box<dyn Any + Send>>,\n     }\n \n     // We do some sketchy operations with ownership here for the sake of\n-    // performance. We can only  pass pointers down to\n-    // `__rust_maybe_catch_panic` (can't pass objects by value), so we do all\n-    // the ownership tracking here manually using a union.\n+    // performance. We can only pass pointers down to `do_call` (can't pass\n+    // objects by value), so we do all the ownership tracking here manually\n+    // using a union.\n     //\n     // We go through a transition where:\n     //\n@@ -263,7 +258,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     // * If the closure successfully returns, we write the return value into the\n     //   data's return slot. Note that `ptr::write` is used as it's overwriting\n     //   uninitialized data.\n-    // * Finally, when we come back out of the `__rust_maybe_catch_panic` we're\n+    // * Finally, when we come back out of the `try` intrinsic we're\n     //   in one of two states:\n     //\n     //      1. The closure didn't panic, in which case the return value was\n@@ -274,27 +269,59 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     //\n     // Once we stack all that together we should have the \"most efficient'\n     // method of calling a catch panic whilst juggling ownership.\n-    let mut any_data = 0;\n-    let mut any_vtable = 0;\n     let mut data = Data { f: ManuallyDrop::new(f) };\n \n-    let r = __rust_maybe_catch_panic(\n-        do_call::<F, R>,\n-        &mut data as *mut _ as *mut u8,\n-        &mut any_data,\n-        &mut any_vtable,\n-    );\n-\n-    return if r == 0 {\n+    let data_ptr = &mut data as *mut _ as *mut u8;\n+    return if do_try(do_call::<F, R>, data_ptr, do_catch::<F, R>) == 0 {\n         Ok(ManuallyDrop::into_inner(data.r))\n     } else {\n-        update_panic_count(-1);\n-        Err(mem::transmute(raw::TraitObject {\n-            data: any_data as *mut _,\n-            vtable: any_vtable as *mut _,\n-        }))\n+        Err(ManuallyDrop::into_inner(data.p))\n     };\n \n+    // Compatibility wrapper around the try intrinsic for bootstrap\n+    #[inline]\n+    unsafe fn do_try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32 {\n+        #[cfg(not(bootstrap))]\n+        {\n+            intrinsics::r#try(try_fn, data, catch_fn)\n+        }\n+        #[cfg(bootstrap)]\n+        {\n+            use crate::mem::MaybeUninit;\n+            #[cfg(target_env = \"msvc\")]\n+            type TryPayload = [u64; 2];\n+            #[cfg(not(target_env = \"msvc\"))]\n+            type TryPayload = *mut u8;\n+\n+            let mut payload: MaybeUninit<TryPayload> = MaybeUninit::uninit();\n+            let payload_ptr = payload.as_mut_ptr() as *mut u8;\n+            let r = intrinsics::r#try(try_fn, data, payload_ptr);\n+            if r != 0 {\n+                #[cfg(target_env = \"msvc\")]\n+                {\n+                    catch_fn(data, payload_ptr)\n+                }\n+                #[cfg(not(target_env = \"msvc\"))]\n+                {\n+                    catch_fn(data, payload.assume_init())\n+                }\n+            }\n+            r\n+        }\n+    }\n+\n+    // We consider unwinding to be rare, so mark this function as cold. However,\n+    // do not mark it no-inline -- that decision is best to leave to the\n+    // optimizer (in most cases this function is not inlined even as a normal,\n+    // non-cold function, though, as of the writing of this comment).\n+    #[cold]\n+    unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send + 'static> {\n+        let obj = Box::from_raw(__rust_panic_cleanup(payload));\n+        update_panic_count(-1);\n+        obj\n+    }\n+\n+    #[inline]\n     fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n         unsafe {\n             let data = data as *mut Data<F, R>;\n@@ -303,6 +330,19 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n             data.r = ManuallyDrop::new(f());\n         }\n     }\n+\n+    // We *do* want this part of the catch to be inlined: this allows the\n+    // compiler to properly track accesses to the Data union and optimize it\n+    // away most of the time.\n+    #[inline]\n+    fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n+        unsafe {\n+            let data = data as *mut Data<F, R>;\n+            let data = &mut (*data);\n+            let obj = cleanup(payload);\n+            data.p = ManuallyDrop::new(obj);\n+        }\n+    }\n }\n \n /// Determines whether the current thread is unwinding because of panic."}, {"sha": "0628e5d2fc03af7737ec617321a14cb65d571e0c", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -33,8 +33,13 @@ fn main() {\n     } else if target.contains(\"dragonfly\") {\n         println!(\"cargo:rustc-link-lib=gcc_pic\");\n     } else if target.contains(\"pc-windows-gnu\") {\n-        println!(\"cargo:rustc-link-lib=static-nobundle=gcc_eh\");\n-        println!(\"cargo:rustc-link-lib=static-nobundle=pthread\");\n+        // This is handled in the target spec with late_link_args_[static|dynamic]\n+\n+        // cfg!(bootstrap) doesn't work in build scripts\n+        if env::var(\"RUSTC_STAGE\").ok() == Some(\"0\".to_string()) {\n+            println!(\"cargo:rustc-link-lib=static-nobundle=gcc_eh\");\n+            println!(\"cargo:rustc-link-lib=static-nobundle=pthread\");\n+        }\n     } else if target.contains(\"uwp-windows-gnu\") {\n         println!(\"cargo:rustc-link-lib=unwind\");\n     } else if target.contains(\"fuchsia\") {"}, {"sha": "bd1946133e8afe40708865f1fff3852d5dcfb3a0", "filename": "src/rtstartup/rsbegin.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsbegin.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -60,37 +60,36 @@ pub mod eh_frames {\n     }\n \n     // Unwind info registration/deregistration routines.\n-    // See the docs of `unwind` module in libstd.\n+    // See the docs of libpanic_unwind.\n     extern \"C\" {\n         fn rust_eh_register_frames(eh_frame_begin: *const u8, object: *mut u8);\n         fn rust_eh_unregister_frames(eh_frame_begin: *const u8, object: *mut u8);\n     }\n \n-    unsafe fn init() {\n+    unsafe extern \"C\" fn init() {\n         // register unwind info on module startup\n         rust_eh_register_frames(&__EH_FRAME_BEGIN__ as *const u8, &mut OBJ as *mut _ as *mut u8);\n     }\n \n-    unsafe fn uninit() {\n+    unsafe extern \"C\" fn uninit() {\n         // unregister on shutdown\n         rust_eh_unregister_frames(&__EH_FRAME_BEGIN__ as *const u8, &mut OBJ as *mut _ as *mut u8);\n     }\n \n-    // MSVC-specific init/uninit routine registration\n-    pub mod ms_init {\n-        // .CRT$X?? sections are roughly analogous to ELF's .init_array and .fini_array,\n-        // except that they exploit the fact that linker will sort them alphabitically,\n-        // so e.g., sections with names between .CRT$XIA and .CRT$XIZ are guaranteed to be\n-        // placed between those two, without requiring any ordering of objects on the linker\n-        // command line.\n-        // Note that ordering of same-named sections from different objects is not guaranteed.\n-        // Since .CRT$XIA contains init array's header symbol, which must always come first,\n-        // we place our initialization callback into .CRT$XIB.\n+    // MinGW-specific init/uninit routine registration\n+    pub mod mingw_init {\n+        // MinGW's startup objects (crt0.o / dllcrt0.o) will invoke global constructors in the\n+        // .ctors and .dtors sections on startup and exit. In the case of DLLs, this is done when\n+        // the DLL is loaded and unloaded.\n+        //\n+        // The linker will sort the sections, which ensures that our callbacks are located at the\n+        // end of the list. Since constructors are run in reverse order, this ensures that our\n+        // callbacks are the first and last ones executed.\n \n-        #[link_section = \".CRT$XIB\"] // .CRT$XI? : C initialization callbacks\n-        pub static P_INIT: unsafe fn() = super::init;\n+        #[link_section = \".ctors.65535\"] // .ctors.* : C initialization callbacks\n+        pub static P_INIT: unsafe extern \"C\" fn() = super::init;\n \n-        #[link_section = \".CRT$XTY\"] // .CRT$XT? : C termination callbacks\n-        pub static P_UNINIT: unsafe fn() = super::uninit;\n+        #[link_section = \".dtors.65535\"] // .dtors.* : C termination callbacks\n+        pub static P_UNINIT: unsafe extern \"C\" fn() = super::uninit;\n     }\n }"}, {"sha": "3c9bc35d1c8bd4dd4de9a4e87525a070ace88920", "filename": "src/test/codegen/catch-unwind.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+extern \"C\" {\n+    fn bar();\n+}\n+\n+// CHECK-LABEL: @foo\n+#[no_mangle]\n+pub unsafe fn foo() -> i32 {\n+    // CHECK: call void @bar\n+    // CHECK: ret i32 0\n+    std::panic::catch_unwind(|| {\n+        bar();\n+        0\n+    })\n+    .unwrap()\n+}"}, {"sha": "166d2bb99426d44ce0940c89c43051ffddeb1d87", "filename": "src/test/codegen/try-panic-abort.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -C panic=abort -O\n+\n+#![crate_type = \"lib\"]\n+#![feature(unwind_attributes, core_intrinsics)]\n+\n+extern \"C\" {\n+    #[unwind(allow)]\n+    fn bar(data: *mut u8);\n+}\n+extern \"Rust\" {\n+    fn catch(data: *mut u8, exception: *mut u8);\n+}\n+\n+// CHECK-LABEL: @foo\n+#[no_mangle]\n+pub unsafe fn foo() -> i32 {\n+    // CHECK: call void @bar\n+    // CHECK: ret i32 0\n+    std::intrinsics::r#try(|x| bar(x), 0 as *mut u8, |x, y| catch(x, y))\n+}"}, {"sha": "3e5cdad7ab936b865fc98b782a5b5d6ff9b22e30", "filename": "src/test/compile-fail/auxiliary/panic-runtime-lang-items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpanic-runtime-lang-items.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -11,5 +11,3 @@ use core::panic::PanicInfo;\n fn panic_impl(info: &PanicInfo) -> ! { loop {} }\n #[lang = \"eh_personality\"]\n fn eh_personality() {}\n-#[lang = \"eh_unwind_resume\"]\n-fn eh_unwind_resume() {}"}, {"sha": "6b86feb5921a1d04a64972ad763f07654d8c53aa", "filename": "src/test/ui/consts/const-eval/const_panic_libcore_main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -17,8 +17,6 @@ const X: () = unimplemented!();\n \n #[lang = \"eh_personality\"]\n fn eh() {}\n-#[lang = \"eh_unwind_resume\"]\n-fn eh_unwind_resume() {}\n \n #[panic_handler]\n fn panic(_info: &PanicInfo) -> ! {"}, {"sha": "83a88ab3bd97c4b0dbf6763e7f9130d38abf2d3e", "filename": "src/test/ui/macros/macro-comma-behavior.core.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.core.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.core.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.core.stderr?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -1,41 +1,41 @@\n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:21:23\n+  --> $DIR/macro-comma-behavior.rs:20:23\n    |\n LL |     assert_eq!(1, 1, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:24:23\n+  --> $DIR/macro-comma-behavior.rs:23:23\n    |\n LL |     assert_ne!(1, 2, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:30:29\n+  --> $DIR/macro-comma-behavior.rs:29:29\n    |\n LL |     debug_assert_eq!(1, 1, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:33:29\n+  --> $DIR/macro-comma-behavior.rs:32:29\n    |\n LL |     debug_assert_ne!(1, 2, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:54:19\n+  --> $DIR/macro-comma-behavior.rs:53:19\n    |\n LL |     format_args!(\"{}\",);\n    |                   ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:72:21\n+  --> $DIR/macro-comma-behavior.rs:71:21\n    |\n LL |     unimplemented!(\"{}\",);\n    |                     ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:81:24\n+  --> $DIR/macro-comma-behavior.rs:80:24\n    |\n LL |             write!(f, \"{}\",)?;\n    |                        ^^"}, {"sha": "04714c65b5cb71daf78e86397487ce16a11767cd", "filename": "src/test/ui/macros/macro-comma-behavior.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -9,7 +9,6 @@\n #[cfg(std)] use std::fmt;\n #[cfg(core)] use core::fmt;\n #[cfg(core)] #[lang = \"eh_personality\"] fn eh_personality() {}\n-#[cfg(core)] #[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n #[cfg(core)] #[lang = \"panic_impl\"] fn panic_impl(panic: &core::panic::PanicInfo) -> ! { loop {} }\n \n // (see documentation of the similarly-named test in run-pass)"}, {"sha": "26445f2c5c542c318f756ad4cf4e02c92d4cf02e", "filename": "src/test/ui/macros/macro-comma-behavior.std.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.std.stderr?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -1,59 +1,59 @@\n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:21:23\n+  --> $DIR/macro-comma-behavior.rs:20:23\n    |\n LL |     assert_eq!(1, 1, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:24:23\n+  --> $DIR/macro-comma-behavior.rs:23:23\n    |\n LL |     assert_ne!(1, 2, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:30:29\n+  --> $DIR/macro-comma-behavior.rs:29:29\n    |\n LL |     debug_assert_eq!(1, 1, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:33:29\n+  --> $DIR/macro-comma-behavior.rs:32:29\n    |\n LL |     debug_assert_ne!(1, 2, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:38:18\n+  --> $DIR/macro-comma-behavior.rs:37:18\n    |\n LL |         eprint!(\"{}\",);\n    |                  ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:50:18\n+  --> $DIR/macro-comma-behavior.rs:49:18\n    |\n LL |         format!(\"{}\",);\n    |                  ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:54:19\n+  --> $DIR/macro-comma-behavior.rs:53:19\n    |\n LL |     format_args!(\"{}\",);\n    |                   ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:61:17\n+  --> $DIR/macro-comma-behavior.rs:60:17\n    |\n LL |         print!(\"{}\",);\n    |                 ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:72:21\n+  --> $DIR/macro-comma-behavior.rs:71:21\n    |\n LL |     unimplemented!(\"{}\",);\n    |                     ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:81:24\n+  --> $DIR/macro-comma-behavior.rs:80:24\n    |\n LL |             write!(f, \"{}\",)?;\n    |                        ^^"}, {"sha": "d9d532106125a2ac71cbe9253e300600e377117b", "filename": "src/test/ui/no-landing-pads.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1572c433eed495d0ade41511ae106b180e02851d/src%2Ftest%2Fui%2Fno-landing-pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572c433eed495d0ade41511ae106b180e02851d/src%2Ftest%2Fui%2Fno-landing-pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-landing-pads.rs?ref=1572c433eed495d0ade41511ae106b180e02851d", "patch": "@@ -1,23 +0,0 @@\n-// run-pass\n-// compile-flags: -Z no-landing-pads -C codegen-units=1\n-// ignore-emscripten no threads support\n-\n-use std::thread;\n-\n-static mut HIT: bool = false;\n-\n-struct A;\n-\n-impl Drop for A {\n-    fn drop(&mut self) {\n-        unsafe { HIT = true; }\n-    }\n-}\n-\n-fn main() {\n-    thread::spawn(move|| -> () {\n-        let _a = A;\n-        panic!();\n-    }).join().unwrap_err();\n-    assert!(unsafe { !HIT });\n-}"}, {"sha": "58e45ff73a5e645e389443a9f490df2f979f9f80", "filename": "src/test/ui/no_owned_box_lang_item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fno_owned_box_lang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fno_owned_box_lang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno_owned_box_lang_item.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -12,5 +12,4 @@ fn main() {\n }\n \n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n #[lang = \"panic_impl\"] fn panic_impl(panic: &PanicInfo) -> ! { loop {} }"}, {"sha": "3e5cdad7ab936b865fc98b782a5b5d6ff9b22e30", "filename": "src/test/ui/panic-runtime/auxiliary/panic-runtime-lang-items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -11,5 +11,3 @@ use core::panic::PanicInfo;\n fn panic_impl(info: &PanicInfo) -> ! { loop {} }\n #[lang = \"eh_personality\"]\n fn eh_personality() {}\n-#[lang = \"eh_unwind_resume\"]\n-fn eh_unwind_resume() {}"}, {"sha": "c6a3cc346fc808cd4d2c75e89c27a6586d0f733e", "filename": "src/test/ui/range/issue-54505-no-std.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -15,10 +15,6 @@ use core::ops::RangeBounds;\n #[lang = \"eh_personality\"]\n extern fn eh_personality() {}\n \n-#[cfg(target_os = \"windows\")]\n-#[lang = \"eh_unwind_resume\"]\n-extern fn eh_unwind_resume() {}\n-\n \n // take a reference to any built-in range\n fn take_range(_r: &impl RangeBounds<i8>) {}"}, {"sha": "909340611328a47e1364c8560790998dc5d1d762", "filename": "src/test/ui/range/issue-54505-no-std.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.stderr?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -1,7 +1,7 @@\n error: `#[panic_handler]` function required, but not found\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:28:16\n+  --> $DIR/issue-54505-no-std.rs:24:16\n    |\n LL |     take_range(0..1);\n    |                ^^^^\n@@ -13,7 +13,7 @@ LL |     take_range(0..1);\n                  found struct `core::ops::Range<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:33:16\n+  --> $DIR/issue-54505-no-std.rs:29:16\n    |\n LL |     take_range(1..);\n    |                ^^^\n@@ -25,7 +25,7 @@ LL |     take_range(1..);\n                  found struct `core::ops::RangeFrom<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:38:16\n+  --> $DIR/issue-54505-no-std.rs:34:16\n    |\n LL |     take_range(..);\n    |                ^^\n@@ -37,7 +37,7 @@ LL |     take_range(..);\n                  found struct `core::ops::RangeFull`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:43:16\n+  --> $DIR/issue-54505-no-std.rs:39:16\n    |\n LL |     take_range(0..=1);\n    |                ^^^^^\n@@ -49,7 +49,7 @@ LL |     take_range(0..=1);\n                  found struct `core::ops::RangeInclusive<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:48:16\n+  --> $DIR/issue-54505-no-std.rs:44:16\n    |\n LL |     take_range(..5);\n    |                ^^^\n@@ -61,7 +61,7 @@ LL |     take_range(..5);\n                  found struct `core::ops::RangeTo<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:53:16\n+  --> $DIR/issue-54505-no-std.rs:49:16\n    |\n LL |     take_range(..=42);\n    |                ^^^^^"}, {"sha": "247e85603cfc2e2305db675ca0f45670231e6d73", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be055d96c4c223a5ad49a0181f0b43bc46781708/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=be055d96c4c223a5ad49a0181f0b43bc46781708", "patch": "@@ -59,6 +59,8 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libstd/sys_common/mod.rs\",\n     \"src/libstd/sys_common/net.rs\",\n     \"src/libstd/sys_common/backtrace.rs\",\n+    // panic_unwind shims\n+    \"src/libstd/panicking.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test crate needs it.\n     \"src/libtest\", // Probably should defer to unstable `std::sys` APIs.\n     \"src/libstd/sync/mpsc\", // some tests are only run on non-emscripten"}]}