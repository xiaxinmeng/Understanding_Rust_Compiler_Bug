{"sha": "49de80d7ea77bce8796d12d7fc600cb16281b1e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZGU4MGQ3ZWE3N2JjZTg3OTZkMTJkN2ZjNjAwY2IxNjI4MWIxZTA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-05T09:56:05Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-07T00:31:42Z"}, "message": "Refactor away the prelude injection pass", "tree": {"sha": "5fd3848f0bbb61ce48daae9ad301af62aef0ff96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fd3848f0bbb61ce48daae9ad301af62aef0ff96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49de80d7ea77bce8796d12d7fc600cb16281b1e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49de80d7ea77bce8796d12d7fc600cb16281b1e0", "html_url": "https://github.com/rust-lang/rust/commit/49de80d7ea77bce8796d12d7fc600cb16281b1e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49de80d7ea77bce8796d12d7fc600cb16281b1e0/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f37edb758e22021ea1a9e5b0c744bb05a57b202", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f37edb758e22021ea1a9e5b0c744bb05a57b202", "html_url": "https://github.com/rust-lang/rust/commit/0f37edb758e22021ea1a9e5b0c744bb05a57b202"}], "stats": {"total": 224, "additions": 79, "deletions": 145}, "files": [{"sha": "41afa43fe28d810a402182464aad3f4dbaed47a8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=49de80d7ea77bce8796d12d7fc600cb16281b1e0", "patch": "@@ -601,7 +601,8 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n     })?;\n \n     krate = time(time_passes, \"crate injection\", || {\n-        syntax::std_inject::maybe_inject_crates_ref(krate, sess.opts.alt_std_name.clone())\n+        let alt_std_name = sess.opts.alt_std_name.clone();\n+        syntax::std_inject::maybe_inject_crates_ref(&sess.parse_sess, krate, alt_std_name)\n     });\n \n     let macros = time(time_passes,\n@@ -720,10 +721,6 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n                                          sess.diagnostic())\n     });\n \n-    krate = time(time_passes,\n-                 \"prelude injection\",\n-                 || syntax::std_inject::maybe_inject_prelude(&sess.parse_sess, krate));\n-\n     time(time_passes,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));"}, {"sha": "775c24b6d4a676753bb52b2ce8cf884bee510a0e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=49de80d7ea77bce8796d12d7fc600cb16281b1e0", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::{self, VariantKind};\n \n use syntax::ast::Name;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -57,6 +57,9 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for the entire crate.\n     pub fn build_reduced_graph(&mut self, krate: &Crate) {\n+        let no_implicit_prelude = attr::contains_name(&krate.attrs, \"no_implicit_prelude\");\n+        self.graph_root.no_implicit_prelude.set(no_implicit_prelude);\n+\n         let mut visitor = BuildReducedGraphVisitor {\n             parent: self.graph_root,\n             resolver: self,\n@@ -128,7 +131,7 @@ impl<'b> Resolver<'b> {\n                 };\n \n                 // Build up the import directives.\n-                let is_prelude = item.attrs.iter().any(|attr| attr.name() == \"prelude_import\");\n+                let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n@@ -221,6 +224,10 @@ impl<'b> Resolver<'b> {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false);\n+                module.no_implicit_prelude.set({\n+                    parent.no_implicit_prelude.get() ||\n+                        attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n+                });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n                 *parent_ref = module;"}, {"sha": "0fab12c230c0fdaee81ae7a7ebc68f8ad010d0a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=49de80d7ea77bce8796d12d7fc600cb16281b1e0", "patch": "@@ -788,7 +788,7 @@ pub struct ModuleS<'a> {\n     resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n-    prelude: RefCell<Option<Module<'a>>>,\n+    no_implicit_prelude: Cell<bool>,\n \n     glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective<'a>)>>,\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n@@ -817,7 +817,7 @@ impl<'a> ModuleS<'a> {\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n-            prelude: RefCell::new(None),\n+            no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n@@ -981,6 +981,8 @@ pub struct Resolver<'a> {\n \n     graph_root: Module<'a>,\n \n+    prelude: Option<Module<'a>>,\n+\n     trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n@@ -1170,6 +1172,7 @@ impl<'a> Resolver<'a> {\n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n             graph_root: graph_root,\n+            prelude: None,\n \n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n@@ -1453,10 +1456,13 @@ impl<'a> Resolver<'a> {\n \n                 // We can only see through anonymous modules\n                 if module.def.is_some() {\n-                    return module.prelude.borrow().and_then(|module| {\n-                        module.resolve_name(name, ns, false)\n-                              .success().map(LexicalScopeBinding::Item)\n-                    });\n+                    return match self.prelude {\n+                        Some(prelude) if !module.no_implicit_prelude.get() => {\n+                            prelude.resolve_name(name, ns, false).success()\n+                                   .map(LexicalScopeBinding::Item)\n+                        }\n+                        _ => None,\n+                    };\n                 }\n             }\n         }\n@@ -3261,7 +3267,7 @@ impl<'a> Resolver<'a> {\n         let mut search_module = self.current_module;\n         loop {\n             // Look for trait children.\n-            let mut search_in_module = |module: Module<'a>| {\n+            let mut search_in_module = |this: &mut Self, module: Module<'a>| {\n                 let mut traits = module.traits.borrow_mut();\n                 if traits.is_none() {\n                     let mut collected_traits = Vec::new();\n@@ -3276,23 +3282,25 @@ impl<'a> Resolver<'a> {\n \n                 for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n                     let trait_def_id = binding.def().unwrap().def_id();\n-                    if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+                    if this.trait_item_map.contains_key(&(name, trait_def_id)) {\n                         let mut import_id = None;\n                         if let NameBindingKind::Import { directive, .. } = binding.kind {\n                             let id = directive.id;\n-                            self.maybe_unused_trait_imports.insert(id);\n+                            this.maybe_unused_trait_imports.insert(id);\n                             import_id = Some(id);\n                         }\n                         add_trait_info(&mut found_traits, trait_def_id, import_id, name);\n-                        self.record_use(trait_name, binding);\n+                        this.record_use(trait_name, binding);\n                     }\n                 }\n             };\n-            search_in_module(search_module);\n+            search_in_module(self, search_module);\n \n             match search_module.parent_link {\n                 NoParentLink | ModuleParentLink(..) => {\n-                    search_module.prelude.borrow().map(search_in_module);\n+                    if !search_module.no_implicit_prelude.get() {\n+                        self.prelude.map(|prelude| search_in_module(self, prelude));\n+                    }\n                     break;\n                 }\n                 BlockParentLink(parent_module, _) => {"}, {"sha": "629b687d8f72a365ac30aac96f85501cb297337a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=49de80d7ea77bce8796d12d7fc600cb16281b1e0", "patch": "@@ -624,7 +624,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.resolver.populate_module_if_necessary(target_module);\n \n         if let GlobImport { is_prelude: true } = directive.subclass {\n-            *module_.prelude.borrow_mut() = Some(target_module);\n+            self.resolver.prelude = Some(target_module);\n             return Success(());\n         }\n "}, {"sha": "8834c026067c8180a7b5624f26626ee7b0c5a063", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 47, "deletions": 125, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de80d7ea77bce8796d12d7fc600cb16281b1e0/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=49de80d7ea77bce8796d12d7fc600cb16281b1e0", "patch": "@@ -12,12 +12,9 @@ use ast;\n use attr;\n use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n-use fold::Folder;\n-use fold;\n use parse::token::{intern, InternedString, keywords};\n use parse::{token, ParseSess};\n use ptr::P;\n-use util::small_vector::SmallVector;\n \n /// Craft a span that will be ignored by the stability lint's\n /// call to codemap's is_internal check.\n@@ -37,33 +34,6 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     return sp;\n }\n \n-pub fn maybe_inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>)\n-                               -> ast::Crate {\n-    if no_core(&krate) {\n-        krate\n-    } else {\n-        let name = if no_std(&krate) {\"core\"} else {\"std\"};\n-        let mut fold = CrateInjector {\n-            item_name: token::str_to_ident(name),\n-            crate_name: token::intern(&alt_std_name.unwrap_or(name.to_string())),\n-        };\n-        fold.fold_crate(krate)\n-    }\n-}\n-\n-pub fn maybe_inject_prelude(sess: &ParseSess, krate: ast::Crate) -> ast::Crate {\n-    if no_core(&krate) {\n-        krate\n-    } else {\n-        let name = if no_std(&krate) {\"core\"} else {\"std\"};\n-        let mut fold = PreludeInjector {\n-            span: ignored_span(sess, DUMMY_SP),\n-            crate_identifier: token::str_to_ident(name),\n-        };\n-        fold.fold_crate(krate)\n-    }\n-}\n-\n pub fn no_core(krate: &ast::Crate) -> bool {\n     attr::contains_name(&krate.attrs, \"no_core\")\n }\n@@ -72,102 +42,54 @@ pub fn no_std(krate: &ast::Crate) -> bool {\n     attr::contains_name(&krate.attrs, \"no_std\") || no_core(krate)\n }\n \n-fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n-    attr::contains_name(attrs, \"no_implicit_prelude\")\n-}\n-\n-struct CrateInjector {\n-    item_name: ast::Ident,\n-    crate_name: ast::Name,\n-}\n-\n-impl fold::Folder for CrateInjector {\n-    fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        krate.module.items.insert(0, P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: self.item_name,\n-            attrs: vec!(\n-                attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n-                        InternedString::new(\"macro_use\")))),\n-            node: ast::ItemKind::ExternCrate(Some(self.crate_name)),\n-            vis: ast::Visibility::Inherited,\n-            span: DUMMY_SP\n-        }));\n-\n-        krate\n-    }\n-}\n-\n-struct PreludeInjector {\n-    span: Span,\n-    crate_identifier: ast::Ident,\n-}\n-\n-impl fold::Folder for PreludeInjector {\n-    fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        // only add `use std::prelude::*;` if there wasn't a\n-        // `#![no_implicit_prelude]` at the crate level.\n-        // fold_mod() will insert glob path.\n-        if !no_prelude(&krate.attrs) {\n-            krate.module = self.fold_mod(krate.module);\n-        }\n-        krate\n-    }\n-\n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if !no_prelude(&item.attrs) {\n-            // only recur if there wasn't `#![no_implicit_prelude]`\n-            // on this item, i.e. this means that the prelude is not\n-            // implicitly imported though the whole subtree\n-            fold::noop_fold_item(item, self)\n-        } else {\n-            SmallVector::one(item)\n-        }\n+pub fn maybe_inject_crates_ref(sess: &ParseSess,\n+                               mut krate: ast::Crate,\n+                               alt_std_name: Option<String>)\n+                               -> ast::Crate {\n+    if no_core(&krate) {\n+        return krate;\n     }\n \n-    fn fold_mod(&mut self, mut mod_: ast::Mod) -> ast::Mod {\n-        let prelude_path = ast::Path {\n-            span: self.span,\n+    let name = if no_std(&krate) { \"core\" } else { \"std\" };\n+    let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n+\n+    krate.module.items.insert(0, P(ast::Item {\n+        attrs: vec![attr::mk_attr_outer(attr::mk_attr_id(),\n+                                        attr::mk_word_item(InternedString::new(\"macro_use\")))],\n+        vis: ast::Visibility::Inherited,\n+        node: ast::ItemKind::ExternCrate(Some(crate_name)),\n+        ident: token::str_to_ident(name),\n+        id: ast::DUMMY_NODE_ID,\n+        span: DUMMY_SP,\n+    }));\n+\n+    let span = ignored_span(sess, DUMMY_SP);\n+    krate.module.items.insert(0, P(ast::Item {\n+        attrs: vec![ast::Attribute {\n+            node: ast::Attribute_ {\n+                style: ast::AttrStyle::Outer,\n+                value: P(ast::MetaItem {\n+                    node: ast::MetaItemKind::Word(token::intern_and_get_ident(\"prelude_import\")),\n+                    span: span,\n+                }),\n+                id: attr::mk_attr_id(),\n+                is_sugared_doc: false,\n+            },\n+            span: span,\n+        }],\n+        vis: ast::Visibility::Inherited,\n+        node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n-            segments: vec![\n-                ast::PathSegment {\n-                    identifier: self.crate_identifier,\n-                    parameters: ast::PathParameters::none(),\n-                },\n-                ast::PathSegment {\n-                    identifier: token::str_to_ident(\"prelude\"),\n-                    parameters: ast::PathParameters::none(),\n-                },\n-                ast::PathSegment {\n-                    identifier: token::str_to_ident(\"v1\"),\n-                    parameters: ast::PathParameters::none(),\n-                },\n-            ],\n-        };\n-\n-        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path)));\n-        mod_.items.insert(0, P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: keywords::Invalid.ident(),\n-            node: ast::ItemKind::Use(vp),\n-            attrs: vec![ast::Attribute {\n-                span: self.span,\n-                node: ast::Attribute_ {\n-                    id: attr::mk_attr_id(),\n-                    style: ast::AttrStyle::Outer,\n-                    value: P(ast::MetaItem {\n-                        span: self.span,\n-                        node: ast::MetaItemKind::Word(\n-                            token::intern_and_get_ident(\"prelude_import\")\n-                        ),\n-                    }),\n-                    is_sugared_doc: false,\n-                },\n-            }],\n-            vis: ast::Visibility::Inherited,\n-            span: self.span,\n-        }));\n-\n-        fold::noop_fold_mod(mod_, self)\n-    }\n+            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n+                identifier: token::str_to_ident(name),\n+                parameters: ast::PathParameters::none(),\n+            }).collect(),\n+            span: span,\n+        })))),\n+        id: ast::DUMMY_NODE_ID,\n+        ident: keywords::Invalid.ident(),\n+        span: span,\n+    }));\n+\n+    krate\n }"}]}