{"sha": "d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZmMyYjU5OTVmZGVmNjlmZTFkYmRiYmEzNzAzMzk4YzBhYTU0N2I=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-30T23:19:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-02T02:19:32Z"}, "message": "Convert to new closure syntax", "tree": {"sha": "b6d14fd0e920512a29c64a671cc2a5bb90132abb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6d14fd0e920512a29c64a671cc2a5bb90132abb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "html_url": "https://github.com/rust-lang/rust/commit/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13a8f545388929a07af110a950441e6a1b88473a", "url": "https://api.github.com/repos/rust-lang/rust/commits/13a8f545388929a07af110a950441e6a1b88473a", "html_url": "https://github.com/rust-lang/rust/commit/13a8f545388929a07af110a950441e6a1b88473a"}], "stats": {"total": 6531, "additions": 3253, "deletions": 3278}, "files": [{"sha": "28c053b8d508e3a15b351d21cf80818afbd32d3d", "filename": "doc/rust.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -1007,11 +1007,11 @@ the function name.\n \n ~~~~\n fn iter<T>(seq: ~[T], f: fn(T)) {\n-    for seq.each {|elt| f(elt); }\n+    for seq.each |elt| { f(elt); }\n }\n fn map<T, U>(seq: ~[T], f: fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    for seq.each {|elt| vec::push(acc, f(elt)); }\n+    for seq.each |elt| { vec::push(acc, f(elt)); }\n     acc\n }\n ~~~~\n@@ -1638,7 +1638,7 @@ task in a _failing state_.\n ~~~~\n # let buildr = task::builder();\n # task::unsupervise(buildr);\n-# do task::run(buildr) {||\n+# do task::run(buildr) || {\n \n (~[1, 2, 3, 4])[0];\n (~[mut 'x', 'y'])[1] = 'z';\n@@ -2069,7 +2069,7 @@ An example a for loop:\n \n let v: ~[foo] = ~[a, b, c];\n \n-for v.each {|e|\n+for v.each |e| {\n     bar(e);\n }\n ~~~~\n@@ -2276,7 +2276,7 @@ fn read_file_lines(path: str) -> ~[str] {\n     note path;\n     let r: [str];\n     let f: file = open_read(path);\n-    lines(f) {|s|\n+    lines(f) |s| {\n         r += ~[s];\n     }\n     ret r;\n@@ -3365,7 +3365,7 @@ An example of a `spawn` call:\n let po = comm::port();\n let ch = comm::chan(po);\n \n-do task::spawn {||\n+do task::spawn || {\n     // let task run, do other things\n     // ...\n     comm::send(ch, true);"}, {"sha": "fe08fa95d126e25acfd93e37373b7dbdfcb02ed6", "filename": "doc/tutorial.md", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -851,9 +851,7 @@ full access to its environment.\n fn call_closure_with_ten(b: fn(int)) { b(10); }\n \n let x = 20;    \n-call_closure_with_ten({|arg|\n-    #info(\"x=%d, arg=%d\", x, arg);\n-});\n+call_closure_with_ten(|arg| #info(\"x=%d, arg=%d\", x, arg) );\n ~~~~\n \n This defines a function that accepts a closure, and then calls it with\n@@ -910,7 +908,7 @@ that callers have the flexibility to pass whatever they want.\n \n ~~~~\n fn call_twice(f: fn()) { f(); f(); }\n-call_twice({|| \"I am a stack closure\"; });\n+call_twice(|| { \"I am a stack closure\"; } );\n call_twice(fn@() { \"I am a boxed closure\"; });\n fn bare_function() { \"I am a plain function\"; }\n call_twice(bare_function);\n@@ -926,7 +924,7 @@ them. Unique closures mostly exist for spawning new [tasks](#tasks).\n \n ### Do syntax\n \n-The compact syntax used for stack closures (`{|arg1, arg2| body}`) can\n+The compact syntax used for stack closures (`|arg1, arg2| body`) can\n also be used to express boxed and unique closures in situations where\n the closure style can be unambiguously derived from the context. Most\n notably, when calling a higher-order function you do not have to use\n@@ -953,7 +951,7 @@ To run such an iteration, you could do this:\n \n ~~~~\n # fn for_rev(v: ~[int], act: fn(int)) {}\n-for_rev(~[1, 2, 3], {|n| log(error, n); });\n+for_rev(~[1, 2, 3], |n| log(error, n) );\n ~~~~\n \n Because this is such a common pattern Rust has a special form\n@@ -962,7 +960,7 @@ structure:\n \n ~~~~\n # fn for_rev(v: [int], act: fn(int)) {}\n-do for_rev(~[1, 2, 3]) {|n|\n+do for_rev(~[1, 2, 3]) |n| {\n     log(error, n);\n }\n ~~~~\n@@ -980,7 +978,7 @@ To allow breaking out of loops, many iteration functions, such as\n `false` to break off iteration.\n \n ~~~~\n-vec::each(~[2, 4, 8, 5, 16], {|n|\n+vec::each(~[2, 4, 8, 5, 16], |n| {\n     if n % 2 != 0 {\n         io::println(\"found odd number!\");\n         false\n@@ -994,7 +992,7 @@ return `true`, and `break` and `cont` can be used, much like in a\n `while` loop, to explicitly return `false` or `true`.\n \n ~~~~\n-for vec::each(~[2, 4, 8, 5, 16]) {|n|\n+for vec::each(~[2, 4, 8, 5, 16]) |n| {\n     if n % 2 != 0 {\n         io::println(\"found odd number!\");\n         break;\n@@ -1009,7 +1007,7 @@ function, not just the loop body.\n \n ~~~~\n fn contains(v: ~[int], elt: int) -> bool {\n-    for vec::each(v) {|x|\n+    for vec::each(v) |x| {\n         if (x == elt) { ret true; }\n     }\n     false\n@@ -1478,7 +1476,7 @@ fn for_rev<T>(v: ~[T], act: fn(T)) {\n \n fn map<T, U>(v: ~[T], f: fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    for v.each {|elt| vec::push(acc, f(elt)); }\n+    for v.each |elt| { vec::push(acc, f(elt)); }\n     ret acc;\n }\n ~~~~\n@@ -1956,7 +1954,7 @@ parameters.\n # iface to_str { fn to_str() -> str; }\n fn comma_sep<T: to_str>(elts: ~[T]) -> str {\n     let mut result = \"\", first = true;\n-    for elts.each {|elt|\n+    for elts.each |elt| {\n         if first { first = false; }\n         else { result += \", \"; }\n         result += elt.to_str();\n@@ -1986,7 +1984,7 @@ iface seq<T> {\n impl <T> of seq<T> for ~[T] {\n     fn len() -> uint { vec::len(self) }\n     fn iter(b: fn(T)) {\n-        for self.each {|elt| b(elt); }\n+        for self.each |elt| { b(elt); }\n     }\n }\n ~~~~\n@@ -2006,7 +2004,7 @@ However, consider this function:\n ~~~~\n # iface drawable { fn draw(); }\n fn draw_all<T: drawable>(shapes: ~[T]) {\n-    for shapes.each {|shape| shape.draw(); }\n+    for shapes.each |shape| { shape.draw(); }\n }\n ~~~~\n \n@@ -2020,7 +2018,7 @@ the function to be written simply like this:\n ~~~~\n # iface drawable { fn draw(); }\n fn draw_all(shapes: ~[drawable]) {\n-    for shapes.each {|shape| shape.draw(); }\n+    for shapes.each |shape| { shape.draw(); }\n }\n ~~~~\n \n@@ -2105,7 +2103,7 @@ extern mod crypto {\n \n fn as_hex(data: ~[u8]) -> str {\n     let mut acc = \"\";\n-    for data.each {|byte| acc += #fmt(\"%02x\", byte as uint); }\n+    for data.each |byte| { acc += #fmt(\"%02x\", byte as uint); }\n     ret acc;\n }\n \n@@ -2338,7 +2336,7 @@ module `task`.  Let's begin with the simplest one, `task::spawn()`:\n \n ~~~~\n let some_value = 22;\n-do task::spawn {||\n+do task::spawn || {\n     io::println(\"This executes in the child task.\");\n     io::println(#fmt(\"%d\", some_value));\n }\n@@ -2364,7 +2362,7 @@ in parallel.  We might write something like:\n # fn some_other_expensive_computation() {}\n let port = comm::port::<int>();\n let chan = comm::chan::<int>(port);\n-do task::spawn {||\n+do task::spawn || {\n     let result = some_expensive_computation();\n     comm::send(chan, result);\n }\n@@ -2395,7 +2393,7 @@ The next statement actually spawns the child:\n # fn some_expensive_computation() -> int { 42 }\n # let port = comm::port::<int>();\n # let chan = comm::chan::<int>(port);\n-do task::spawn {||\n+do task::spawn || {\n     let result = some_expensive_computation();\n     comm::send(chan, result);\n }\n@@ -2458,7 +2456,7 @@ Here is the code for the parent task:\n fn main() {\n     let from_child = comm::port();\n     let to_parent = comm::chan(from_child);\n-    let to_child = do task::spawn_listener {|from_parent|\n+    let to_child = do task::spawn_listener |from_parent| {\n         stringifier(from_parent, to_parent);\n     };\n     comm::send(to_child, 22u);"}, {"sha": "8cb2b0cc21b713929f39579def13bf3f5545276f", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -117,7 +117,7 @@ fn is_uuid(id: str) -> bool {\n     let parts = str::split_str(id, \"-\");\n     if vec::len(parts) == 5u {\n         let mut correct = 0u;\n-        for vec::eachi(parts) { |i, part|\n+        for vec::eachi(parts) |i, part| {\n             fn is_hex_digit(ch: char) -> bool {\n                 ('0' <= ch && ch <= '9') ||\n                 ('a' <= ch && ch <= 'f') ||\n@@ -222,7 +222,7 @@ fn load_link(mis: ~[@ast::meta_item]) -> (option<str>,\n     let mut name = none;\n     let mut vers = none;\n     let mut uuid = none;\n-    for mis.each {|a|\n+    for mis.each |a| {\n         alt a.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n                 alt *v {\n@@ -249,7 +249,7 @@ fn load_crate(filename: str) -> option<crate> {\n     let mut sigs = none;\n     let mut crate_type = none;\n \n-    for c.node.attrs.each {|a|\n+    for c.node.attrs.each |a| {\n         alt a.node.value.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n                 alt *v {\n@@ -291,7 +291,7 @@ fn load_crate(filename: str) -> option<crate> {\n                 let mut attr_vers = \"\";\n                 let mut attr_from = \"\";\n \n-                for m.each { |item|\n+              for m.each |item| {\n                     alt attr::get_meta_item_value_str(item) {\n                         some(value) {\n                             let name = attr::get_meta_item_name(item);\n@@ -329,8 +329,8 @@ fn load_crate(filename: str) -> option<crate> {\n         mut deps: ~[]\n     };\n     let v = visit::mk_simple_visitor(@{\n-        visit_view_item: {|a|goto_view_item(e, a)},\n-        visit_item: {|a|goto_item(e, a)},\n+        visit_view_item: |a| goto_view_item(e, a),\n+        visit_item: |a| goto_item(e, a),\n         with *visit::default_simple_visitor()\n     });\n \n@@ -435,7 +435,7 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n     let c = io::read_whole_file_str(filename);\n     alt json::from_str(result::get(c)) {\n         ok(json::dict(j)) {\n-            for j.each { |k, v|\n+          for j.each |k, v| {\n                 sources.insert(k, parse_source(k, v));\n                 #debug(\"source: %s\", k);\n             }\n@@ -501,7 +501,7 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     let mut tags = ~[];\n     alt p.find(\"tags\") {\n         some(json::list(js)) {\n-            for (*js).each {|j|\n+          for (*js).each |j| {\n                 alt j {\n                     json::string(j) { vec::grow(tags, 1u, *j); }\n                     _ { }\n@@ -531,7 +531,7 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n         versions: ~[]\n     };\n \n-    alt src.packages.position({ |pkg| pkg.uuid == uuid }) {\n+    alt src.packages.position(|pkg| pkg.uuid == uuid ) {\n       some(idx) {\n         src.packages[idx] = newpkg;\n         log(debug, \"  updated package: \" + src.name + \"/\" + name);\n@@ -573,7 +573,7 @@ fn load_source_packages(c: cargo, src: source) {\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) {\n-            for (*js).each {|j|\n+          for (*js).each |j| {\n                 alt j {\n                     json::dict(p) {\n                         load_one_source_package(src, p);\n@@ -667,7 +667,7 @@ fn configure(opts: options) -> cargo {\n     need_dir(c.libdir);\n     need_dir(c.bindir);\n \n-    for sources.each_key { |k|\n+    for sources.each_key |k| {\n         let mut s = sources.get(k);\n         load_source_packages(c, s);\n         sources.insert(k, s);\n@@ -685,11 +685,11 @@ fn configure(opts: options) -> cargo {\n }\n \n fn for_each_package(c: cargo, b: fn(source, package)) {\n-    for c.sources.each_value {|v|\n+    for c.sources.each_value |v| {\n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n         let pks = copy v.packages;\n-        for vec::each(pks) {|p|\n+        for vec::each(pks) |p| {\n             b(v, p);\n         }\n     }\n@@ -698,7 +698,7 @@ fn for_each_package(c: cargo, b: fn(source, package)) {\n // Runs all programs in directory <buildpath>\n fn run_programs(buildpath: str) {\n     let newv = os::list_dir_path(buildpath);\n-    for newv.each {|ct|\n+    for newv.each |ct| {\n         run::run_program(ct, ~[]);\n     }\n }\n@@ -736,7 +736,7 @@ fn install_one_crate(c: cargo, path: str, cf: str) {\n     };\n     let newv = os::list_dir_path(buildpath);\n     let exec_suffix = os::exe_suffix();\n-    for newv.each {|ct|\n+    for newv.each |ct| {\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n             (exec_suffix == \"\" && !str::starts_with(path::basename(ct),\n                                                     \"lib\")) {\n@@ -773,7 +773,7 @@ fn install_source(c: cargo, path: str) {\n     os::change_dir(path);\n \n     let mut cratefiles = ~[];\n-    for os::walk_dir(\".\") {|p|\n+    for os::walk_dir(\".\") |p| {\n         if str::ends_with(p, \".rc\") {\n             vec::push(cratefiles, p);\n         }\n@@ -783,11 +783,11 @@ fn install_source(c: cargo, path: str) {\n         fail \"this doesn't look like a rust package (no .rc files)\";\n     }\n \n-    for cratefiles.each {|cf|\n+    for cratefiles.each |cf| {\n         alt load_crate(cf) {\n             none { cont; }\n             some(crate) {\n-                for crate.deps.each { |query|\n+              for crate.deps.each |query| {\n                     // TODO: handle cyclic dependencies\n \n                     let wd_base = c.workdir + path::path_sep();\n@@ -869,7 +869,7 @@ fn cargo_suggestion(c: cargo, fallback: fn())\n \n fn install_uuid(c: cargo, wd: str, uuid: str) {\n     let mut ps = ~[];\n-    for_each_package(c, { |s, p|\n+    for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n             vec::grow(ps, 1u, (s.name, copy p));\n         }\n@@ -879,21 +879,21 @@ fn install_uuid(c: cargo, wd: str, uuid: str) {\n         install_package(c, sname, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, { ||\n+        cargo_suggestion(c, || {\n             error(\"can't find package: \" + uuid);\n         });\n         ret;\n     }\n     error(\"found multiple packages:\");\n-    for ps.each {|elt|\n+    for ps.each |elt| {\n         let (sname,p) = copy elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n \n fn install_named(c: cargo, wd: str, name: str) {\n     let mut ps = ~[];\n-    for_each_package(c, { |s, p|\n+    for_each_package(c, |s, p| {\n         if p.name == name {\n             vec::grow(ps, 1u, (s.name, copy p));\n         }\n@@ -903,13 +903,13 @@ fn install_named(c: cargo, wd: str, name: str) {\n         install_package(c, sname, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, { ||\n+        cargo_suggestion(c, || {\n             error(\"can't find package: \" + name);\n         });\n         ret;\n     }\n     error(\"found multiple packages:\");\n-    for ps.each {|elt|\n+    for ps.each |elt| {\n         let (sname,p) = copy elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n@@ -919,7 +919,7 @@ fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n     alt c.sources.find(src) {\n       some(s) {\n         let packages = copy s.packages;\n-        if vec::any(packages, { |p|\n+        if vec::any(packages, |p| {\n             if p.uuid == uuid {\n                 install_package(c, src, wd, p);\n                 true\n@@ -935,7 +935,7 @@ fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n     alt c.sources.find(src) {\n         some(s) {\n           let packages = copy s.packages;\n-          if vec::any(packages, { |p|\n+          if vec::any(packages, |p| {\n                 if p.name == name {\n                     install_package(c, src, wd, p);\n                     true\n@@ -962,7 +962,7 @@ fn cmd_uninstall(c: cargo) {\n     // cache instead of looking for it (binaries can be uninstalled by\n     // name only)\n     if is_uuid(target) {\n-        for os::list_dir(lib).each { |file|\n+        for os::list_dir(lib).each |file| {\n             alt str::find_str(file, \"-\" + target + \"-\") {\n                 some(idx) {\n                     let full = path::normalize(path::connect(lib, file));\n@@ -979,7 +979,7 @@ fn cmd_uninstall(c: cargo) {\n \n         error(\"can't find package with uuid: \" + target);\n     } else {\n-        for os::list_dir(lib).each { |file|\n+        for os::list_dir(lib).each |file| {\n             alt str::find_str(file, \"lib\" + target + \"-\") {\n                 some(idx) {\n                     let full = path::normalize(path::connect(lib,\n@@ -994,7 +994,7 @@ fn cmd_uninstall(c: cargo) {\n                 none { cont; }\n             }\n         }\n-        for os::list_dir(bin).each { |file|\n+        for os::list_dir(bin).each |file| {\n             alt str::find_str(file, target) {\n                 some(idx) {\n                     let full = path::normalize(path::connect(bin, file));\n@@ -1065,7 +1065,7 @@ fn install_query(c: cargo, wd: str, target: str) {\n     // a bit of a hack. It should be cleaned up in the future.\n \n     if target == c.current_install {\n-        for c.dep_cache.each { |k, _v|\n+        for c.dep_cache.each |k, _v| {\n             c.dep_cache.remove(k);\n         }\n \n@@ -1101,7 +1101,7 @@ fn cmd_install(c: cargo) unsafe {\n }\n \n fn sync(c: cargo) {\n-    for c.sources.each_key { |k|\n+    for c.sources.each_key |k| {\n         let mut s = c.sources.get(k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n@@ -1464,15 +1464,13 @@ fn print_pkg(s: source, p: package) {\n fn print_source(s: source) {\n     info(s.name + \" (\" + s.url + \")\");\n \n-    let pks = sort::merge_sort({ |a, b|\n-        a < b\n-    }, copy s.packages);\n+    let pks = sort::merge_sort(|a, b| a < b, copy s.packages);\n     let l = vec::len(pks);\n \n-    print(io::with_str_writer({ |writer|\n+    print(io::with_str_writer(|writer| {\n         let mut list = \"   >> \";\n \n-        do vec::iteri(pks) { |i, pk|\n+        do vec::iteri(pks) |i, pk| {\n             if str::len(list) > 78u {\n                 writer.write_line(list);\n                 list = \"   >> \";\n@@ -1488,7 +1486,7 @@ fn cmd_list(c: cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n-        do vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n+        do vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) |name| {\n             if !valid_pkg_name(name) {\n                 error(#fmt(\"'%s' is an invalid source name\", name));\n             } else {\n@@ -1503,7 +1501,7 @@ fn cmd_list(c: cargo) {\n             }\n         }\n     } else {\n-        for c.sources.each_value { |v|\n+        for c.sources.each_value |v| {\n             print_source(v);\n         }\n     }\n@@ -1520,9 +1518,9 @@ fn cmd_search(c: cargo) {\n     let mut n = 0;\n     let name = c.opts.free[2];\n     let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n-    for_each_package(c, { |s, p|\n+    for_each_package(c, |s, p| {\n         if (str::contains(p.name, name) || name == \"*\") &&\n-            vec::all(tags, { |t| vec::contains(p.tags, t) }) {\n+            vec::all(tags, |t| vec::contains(p.tags, t) ) {\n             print_pkg(s, p);\n             n += 1;\n         }\n@@ -1569,7 +1567,7 @@ fn dump_sources(c: cargo) {\n             let hash = map::str_hash();\n             let root = json::dict(hash);\n \n-            for c.sources.each { |k, v|\n+          for c.sources.each |k, v| {\n                 let chash = map::str_hash();\n                 let child = json::dict(chash);\n \n@@ -1608,7 +1606,7 @@ fn copy_warn(srcfile: str, destfile: str) {\n \n fn cmd_sources(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n-        for c.sources.each_value { |v|\n+        for c.sources.each_value |v| {\n             info(#fmt(\"%s (%s) via %s\",\n                       copy v.name, copy v.url, copy v.method));\n         }\n@@ -1619,7 +1617,7 @@ fn cmd_sources(c: cargo) {\n \n     alt action {\n         \"clear\" {\n-            for c.sources.each_key { |k|\n+          for c.sources.each_key |k| {\n                 c.sources.remove(k);\n             }\n "}, {"sha": "9078e943cf2f3bc16e6dea7c52e0c96140ee3047", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -90,7 +90,7 @@ fn verify(root: str, data: str, sig: str, keyfp: str) -> bool {\n     let p = gpg(~[\"--homedir\", path, \"--with-fingerprint\", \"--verify\", sig,\n                  data]);\n     let res = \"Primary key fingerprint: \" + keyfp;\n-    for str::split_char(p.err, '\\n').each {|line|\n+    for str::split_char(p.err, '\\n').each |line| {\n         if line == res { ret true; }\n     }\n     ret false;"}, {"sha": "359ca0c5bccf2f9d21fc625383da69eeee85c07f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -136,7 +136,7 @@ fn test_opts(config: config) -> test::test_opts {\n fn make_tests(config: config) -> ~[test::test_desc] {\n     #debug(\"making tests from %s\", config.src_base);\n     let mut tests = ~[];\n-    for os::list_dir_path(config.src_base).each {|file|\n+    for os::list_dir_path(config.src_base).each |file| {\n         let file = file;\n         #debug(\"inspecting file %s\", file);\n         if is_test(config, file) {\n@@ -155,11 +155,11 @@ fn is_test(config: config, testfile: str) -> bool {\n \n     let mut valid = false;\n \n-    for valid_extensions.each {|ext|\n+    for valid_extensions.each |ext| {\n         if str::ends_with(name, ext) { valid = true; }\n     }\n \n-    for invalid_prefixes.each {|pre|\n+    for invalid_prefixes.each |pre| {\n         if str::starts_with(name, pre) { valid = false; }\n     }\n \n@@ -181,9 +181,7 @@ fn make_test_name(config: config, testfile: str) -> str {\n }\n \n fn make_test_closure(config: config, testfile: str) -> test::test_fn {\n-    ret {||\n-        runtest::run(config, copy testfile);\n-    };\n+    fn~() { runtest::run(config, copy testfile) }\n }\n \n // Local Variables:"}, {"sha": "53f3876d9f69acfe9b2cc4e9aaee2fc5a08d0cc6", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -29,7 +29,7 @@ fn load_props(testfile: str) -> test_props {\n     let mut exec_env = ~[];\n     let mut compile_flags = option::none;\n     let mut pp_exact = option::none;\n-    for iter_header(testfile) {|ln|\n+    for iter_header(testfile) |ln| {\n         alt parse_error_pattern(ln) {\n           option::some(ep) { vec::push(error_patterns, ep) }\n           option::none { }\n@@ -43,11 +43,11 @@ fn load_props(testfile: str) -> test_props {\n             pp_exact = parse_pp_exact(ln, testfile);\n         }\n \n-        do option::iter(parse_aux_build(ln)) {|ab|\n+        do option::iter(parse_aux_build(ln)) |ab| {\n             vec::push(aux_builds, ab);\n         }\n \n-        do option::iter(parse_exec_env(ln)) {|ee|\n+        do option::iter(parse_exec_env(ln)) |ee| {\n             vec::push(exec_env, ee);\n         }\n     };\n@@ -62,7 +62,7 @@ fn load_props(testfile: str) -> test_props {\n \n fn is_test_ignored(config: config, testfile: str) -> bool {\n     let mut found = false;\n-    for iter_header(testfile) {|ln|\n+    for iter_header(testfile) |ln| {\n         if parse_name_directive(ln, \"xfail-test\") { ret true; }\n         if parse_name_directive(ln, xfail_target()) { ret true; }\n         if config.mode == common::mode_pretty &&\n@@ -104,7 +104,7 @@ fn parse_compile_flags(line: str) -> option<str> {\n }\n \n fn parse_exec_env(line: str) -> option<(str, str)> {\n-    do parse_name_value_directive(line, \"exec-env\").map {|nv|\n+    do parse_name_value_directive(line, \"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n         let strs = str::splitn_char(nv, '=', 1u);\n         alt strs.len() {"}, {"sha": "d2e8b019bfd334143b664720a95d691e36dc22a1", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -13,7 +13,7 @@ fn target_env(lib_path: str, prog: str) -> ~[(str,str)] {\n     assert prog.ends_with(\".exe\");\n     let aux_path = prog.slice(0u, prog.len() - 4u) + \".libaux\";\n \n-    env = do vec::map(env) {|pair|\n+    env = do vec::map(env) |pair| {\n         let (k,v) = pair;\n         if k == \"PATH\" { (\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }\n@@ -60,11 +60,11 @@ fn run(lib_path: str,\n     writeclose(pipe_in.out, input);\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    do task::spawn_sched(task::single_threaded) {||\n+    do task::spawn_sched(task::single_threaded) || {\n         let errput = readclose(pipe_err.in);\n         comm::send(ch, (2, errput));\n     }\n-    do task::spawn_sched(task::single_threaded) {||\n+    do task::spawn_sched(task::single_threaded) || {\n         let output = readclose(pipe_out.in);\n         comm::send(ch, (1, output));\n     }"}, {"sha": "9c131f185643619c2d93d6c36336b6ba9eb6c26c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -199,7 +199,7 @@ fn check_error_patterns(props: test_props,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::split_char(procres.stderr, '\\n').each {|line|\n+    for str::split_char(procres.stderr, '\\n').each |line| {\n         if str::contains(line, next_err_pat) {\n             #debug(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -220,7 +220,7 @@ fn check_error_patterns(props: test_props,\n         fatal_procres(#fmt[\"error pattern '%s' not found!\",\n                            missing_patterns[0]], procres);\n     } else {\n-        for missing_patterns.each {|pattern|\n+        for missing_patterns.each |pattern| {\n             error(#fmt[\"error pattern '%s' not found!\", pattern]);\n         }\n         fatal_procres(\"multiple error patterns not found\", procres);\n@@ -239,7 +239,7 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         fatal(\"process did not return an error status\");\n     }\n \n-    let prefixes = vec::map(expected_errors, {|ee|\n+    let prefixes = vec::map(expected_errors, |ee| {\n         #fmt(\"%s:%u:\", testfile, ee.line)\n     });\n \n@@ -249,9 +249,9 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::split_char(procres.stderr, '\\n').each {|line|\n+    for str::split_char(procres.stderr, '\\n').each |line| {\n         let mut was_expected = false;\n-        for vec::eachi(expected_errors) {|i, ee|\n+        for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n                 #debug[\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line];\n@@ -277,7 +277,7 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         }\n     }\n \n-    for uint::range(0u, vec::len(found_flags)) {|i|\n+    for uint::range(0u, vec::len(found_flags)) |i| {\n         if !found_flags[i] {\n             let ee = expected_errors[i];\n             fatal_procres(#fmt[\"expected %s on line %u not found: %s\",\n@@ -321,11 +321,11 @@ fn compose_and_run_compiler(\n \n     let extra_link_args = ~[\"-L\", aux_output_dir_name(config, testfile)];\n \n-    do vec::iter(props.aux_builds) {|rel_ab|\n+    do vec::iter(props.aux_builds) |rel_ab| {\n         let abs_ab = path::connect(config.aux_base, rel_ab);\n         let aux_args =\n             make_compile_args(config, props, ~[\"--lib\"] + extra_link_args,\n-                              {|a,b|make_lib_name(a, b, testfile)}, abs_ab);\n+                              |a,b| make_lib_name(a, b, testfile), abs_ab);\n         let auxres = compose_and_run(config, abs_ab, aux_args, ~[],\n                                      config.compile_lib_path, option::none);\n         if auxres.status != 0 {"}, {"sha": "d052e0739ded319583e947b88d1ebfcfa0761d86", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -25,7 +25,7 @@ fn find_rust_files(&files: ~[str], path: str) {\n     } else if os::path_is_dir(path)\n         && !contains(path, \"compile-fail\")\n         && !contains(path, \"build\") {\n-        for os::list_dir_path(path).each {|p|\n+        for os::list_dir_path(path).each |p| {\n             find_rust_files(files, p);\n         }\n     }\n@@ -139,8 +139,8 @@ fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n     let exprs = @mut ~[];\n     let tys = @mut ~[];\n     let v = visit::mk_simple_visitor(@{\n-        visit_expr: {|a|stash_expr_if(safe_to_steal_expr, exprs, a, tm)},\n-        visit_ty: {|a|stash_ty_if(safe_to_steal_ty, tys, a, tm)}\n+        visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n+        visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm)\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(crate, (), v);\n@@ -187,10 +187,12 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n             fold::noop_fold_expr(original, fld)\n         }\n     }\n-    let afp =\n-        @{fold_expr: fold::wrap({|a,b|\n-        fold_expr_rep(j, i, newexpr.node, a, b, tm)})\n-          with *fold::default_ast_fold()};\n+    let afp = @{\n+        fold_expr: fold::wrap(|a,b| {\n+            fold_expr_rep(j, i, newexpr.node, a, b, tm)\n+        })\n+        with *fold::default_ast_fold()\n+    };\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2\n@@ -210,9 +212,10 @@ fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty,\n             newty_\n         } else { fold::noop_fold_ty(original, fld) }\n     }\n-    let afp =\n-        @{fold_ty: fold::wrap({|a,b|fold_ty_rep(j, i, newty.node, a, b, tm)})\n-         with *fold::default_ast_fold()};\n+    let afp = @{\n+        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) )\n+        with *fold::default_ast_fold()\n+    };\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2\n@@ -235,7 +238,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n                          filename: str, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n-                                  {|a|safe_to_use_expr(a, cx.mode)});\n+                                  |a| safe_to_use_expr(a, cx.mode) );\n     check_variants_T(crate, codemap, filename, \"expr\",\n                      extra_exprs + stolen.exprs, pprust::expr_to_str,\n                      replace_expr_in_crate, cx);\n@@ -259,23 +262,23 @@ fn check_variants_T<T: copy>(\n     let L = vec::len(things);\n \n     if L < 100u {\n-        do under(uint::min(L, 20u)) {|i|\n+        do under(uint::min(L, 20u)) |i| {\n             log(error, \"Replacing... #\" + uint::str(i));\n-            do under(uint::min(L, 30u)) {|j|\n+            do under(uint::min(L, 30u)) |j| {\n                 log(error, \"With... \" + stringifier(@things[j]));\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but\n                 // testing the string for stability is easier and ok for now.\n                 let handler = diagnostic::mk_handler(none);\n                 let str3 =\n-                    @as_str({|a|pprust::print_crate(\n+                    @as_str(|a|pprust::print_crate(\n                         codemap,\n                         diagnostic::mk_span_handler(handler, codemap),\n                         crate2,\n                         filename,\n                         io::str_reader(\"\"), a,\n                         pprust::no_ann(),\n-                        false)});\n+                        false));\n                 alt cx.mode {\n                   tm_converge {\n                     check_roundtrip_convergence(str3, 1u);\n@@ -421,14 +424,14 @@ fn parse_and_print(code: @str) -> str {\n     write_file(filename, *code);\n     let crate = parse::parse_crate_from_source_str(\n         filename, code, ~[], sess);\n-    io::with_str_reader(*code, { |rdr|\n-        as_str({|a|pprust::print_crate(sess.cm,\n+    io::with_str_reader(*code, |rdr| {\n+        as_str(|a| pprust::print_crate(sess.cm,\n                                        sess.span_diagnostic,\n                                        crate,\n                                        filename,\n                                        rdr, a,\n                                        pprust::no_ann(),\n-                                       false)})\n+                                       false) )\n     })\n }\n \n@@ -441,7 +444,7 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n         }\n     }\n     let v =\n-        visit::mk_simple_visitor(@{visit_ty: {|a|visit_ty(has_rp, a)}\n+        visit::mk_simple_visitor(@{visit_ty: |a| visit_ty(has_rp, a)\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(c, (), v);\n     ret *has_rp;\n@@ -455,15 +458,15 @@ fn content_is_dangerous_to_run(code: str) -> bool {\n          \"unsafe\",\n          \"log\"];    // python --> rust pipe deadlock?\n \n-    for dangerous_patterns.each {|p| if contains(code, p) { ret true; } }\n+    for dangerous_patterns.each |p| { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n fn content_is_dangerous_to_compile(code: str) -> bool {\n     let dangerous_patterns =\n         ~[\"xfail-test\"];\n \n-    for dangerous_patterns.each {|p| if contains(code, p) { ret true; } }\n+    for dangerous_patterns.each |p| { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n@@ -479,7 +482,7 @@ fn content_might_not_converge(code: str) -> bool {\n          \"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n         ];\n \n-    for confusing_patterns.each {|p| if contains(code, p) { ret true; } }\n+    for confusing_patterns.each |p| { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n@@ -493,7 +496,7 @@ fn file_might_not_converge(filename: str) -> bool {\n     ];\n \n \n-    for confusing_files.each {|f| if contains(filename, f) { ret true; } }\n+    for confusing_files.each |f| { if contains(filename, f) { ret true; } }\n \n     ret false;\n }\n@@ -527,7 +530,7 @@ fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n \n fn check_convergence(files: ~[str]) {\n     #error(\"pp convergence tests: %u files\", vec::len(files));\n-    for files.each {|file|\n+    for files.each |file| {\n         if !file_might_not_converge(file) {\n             let s = @result::get(io::read_whole_file_str(file));\n             if !content_might_not_converge(*s) {\n@@ -541,7 +544,7 @@ fn check_convergence(files: ~[str]) {\n }\n \n fn check_variants(files: ~[str], cx: context) {\n-    for files.each {|file|\n+    for files.each |file| {\n         if cx.mode == tm_converge && file_might_not_converge(file) {\n             #error(\"Skipping convergence test based on\\\n                     file_might_not_converge\");\n@@ -565,15 +568,15 @@ fn check_variants(files: ~[str], cx: context) {\n             parse::parse_crate_from_source_str(\n                 file,\n                 s, ~[], sess);\n-        io::with_str_reader(*s, { |rdr|\n+        io::with_str_reader(*s, |rdr| {\n             #error(\"%s\",\n-                   as_str({|a|pprust::print_crate(sess.cm,\n+                   as_str(|a| pprust::print_crate(sess.cm,\n                                                   sess.span_diagnostic,\n                                                   crate,\n                                                   file,\n                                                   rdr, a,\n                                                   pprust::no_ann(),\n-                                                  false)}))\n+                                                  false) ))\n         });\n         check_variants_of_ast(*crate, sess.cm, file, cx);\n     }"}, {"sha": "84f8ca8700e21373aaeb2d5632ebc4ca05e9da9a", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -109,9 +109,7 @@ impl methods<T: send> for exclusive<T> {\n             unsafe::reinterpret_cast(self.data);\n         let r = {\n             let rec: &ex_data<T> = &(*ptr).data;\n-            rec.lock.lock_cond({|c|\n-                f(c, &rec.data)\n-            })\n+            rec.lock.lock_cond(|c| f(c, &rec.data))\n         };\n         unsafe::forget(ptr);\n         r\n@@ -135,7 +133,7 @@ fn shared_arc<T: send const>(-data: T) -> shared_arc<T> {\n     let a = arc::arc(data);\n     let p = port();\n     let c = chan(p);\n-    do task::spawn() {|move a|\n+    do task::spawn() |move a| {\n         let mut live = true;\n         let terminate = port();\n         let get = port();\n@@ -174,7 +172,7 @@ mod tests {\n         let p = port();\n         let c = chan(p);\n \n-        do task::spawn() {||\n+        do task::spawn() || {\n             let p = port();\n             c.send(chan(p));\n \n@@ -200,7 +198,7 @@ mod tests {\n         let p = port();\n         let c = chan(p);\n \n-        do task::spawn() {||\n+        do task::spawn() || {\n             let arc_v = get_arc(arc_c);\n             let v = *get(&arc_v);\n             assert v[2] == 3;\n@@ -221,20 +219,20 @@ mod tests {\n \n         let total = exclusive(~mut 0u);\n \n-        for uint::range(0u, num_tasks) {|_i|\n+        for uint::range(0u, num_tasks) |_i| {\n             let total = total.clone();\n-            futures += ~[future::spawn({||\n-                for uint::range(0u, count) {|_i|\n-                    do total.with {|_cond, count|\n+            futures += ~[future::spawn(|| {\n+                for uint::range(0u, count) |_i| {\n+                    do total.with |_cond, count| {\n                         **count += 1u;\n                     }\n                 }\n             })];\n         };\n \n-        for futures.each {|f| f.get() };\n+        for futures.each |f| { f.get() }\n \n-        do total.with {|_cond, total|\n+        do total.with |_cond, total| {\n             assert **total == num_tasks * count\n         };\n     }"}, {"sha": "cf7689c57ac30b5ef1d26f2d1707e955a9acc178", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -65,7 +65,7 @@ pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[test]\n fn test_bool_from_str() {\n-    do all_values { |v|\n+    do all_values |v| {\n         assert some(v) == from_str(bool::to_str(v))\n     }\n }\n@@ -78,7 +78,7 @@ fn test_bool_to_str() {\n \n #[test]\n fn test_bool_to_bit() {\n-    do all_values { |v|\n+    do all_values |v| {\n         assert to_bit(v) == if is_true(v) { 1u8 } else { 0u8 };\n     }\n }"}, {"sha": "8e204d89f3f4ade8840611e82da015788f2bae12", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -140,7 +140,7 @@ fn escape_unicode(c: char) -> str {\n     assert str::len(s) <= pad;\n     let mut out = \"\\\\\";\n     out += str::from_char(c);\n-    for uint::range(str::len(s), pad) {|_i| out += \"0\"; }\n+    for uint::range(str::len(s), pad) |_i| { out += \"0\"; }\n     out += s;\n     ret out;\n }"}, {"sha": "2d1c4dd978cabd8e0be1fc6653f9e8fdd3a9eefc", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -98,7 +98,7 @@ class port_ptr<T:send> {\n   let po: *rust_port;\n   new(po: *rust_port) { self.po = po; }\n   drop unsafe {\n-    do task::unkillable {||\n+      do task::unkillable || {\n         // Once the port is detached it's guaranteed not to receive further\n         // messages\n         let yield = 0u;\n@@ -184,11 +184,11 @@ fn peek<T: send>(p: port<T>) -> bool { peek_((**p).po) }\n \n #[doc(hidden)]\n fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n-    as_raw_port(ch, {|x|recv_(x)})\n+    as_raw_port(ch, |x|recv_(x))\n }\n \n fn peek_chan<T: send>(ch: comm::chan<T>) -> bool {\n-    as_raw_port(ch, {|x|peek_(x)})\n+    as_raw_port(ch, |x|peek_(x))\n }\n \n #[doc = \"Receive on a raw port pointer\"]\n@@ -223,7 +223,7 @@ fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n \n     let mut resport: *rust_port;\n     resport = rusti::init::<*rust_port>();\n-    do vec::as_buf(ports) {|ports|\n+    do vec::as_buf(ports) |ports| {\n         rustrt::rust_port_select(ptr::addr_of(resport), ports, n_ports,\n                                  yieldp);\n     }\n@@ -364,16 +364,16 @@ fn test_select2_rendezvous() {\n     let ch_a = chan(po_a);\n     let ch_b = chan(po_b);\n \n-    do iter::repeat(10u) {||\n-        do task::spawn {||\n-            iter::repeat(10u, {|| task::yield() });\n+    do iter::repeat(10u) || {\n+        do task::spawn || {\n+            iter::repeat(10u, || task::yield());\n             send(ch_a, \"a\");\n         };\n \n         assert select2(po_a, po_b) == either::left(\"a\");\n \n-        do task::spawn {||\n-            iter::repeat(10u, {|| task::yield() });\n+        do task::spawn || {\n+            iter::repeat(10u, || task::yield());\n             send(ch_b, \"b\");\n         };\n \n@@ -391,22 +391,22 @@ fn test_select2_stress() {\n     let msgs = 100u;\n     let times = 4u;\n \n-    do iter::repeat(times) {||\n-        do task::spawn {||\n-            do iter::repeat(msgs) {||\n+    do iter::repeat(times) || {\n+        do task::spawn || {\n+            do iter::repeat(msgs) || {\n                 send(ch_a, \"a\")\n             }\n         };\n-        do task::spawn {||\n-            do iter::repeat(msgs) {||\n+        do task::spawn || {\n+            do iter::repeat(msgs) || {\n                 send(ch_b, \"b\")\n             }\n         };\n     }\n \n     let mut as = 0;\n     let mut bs = 0;\n-    do iter::repeat(msgs * times * 2u) {||\n+    do iter::repeat(msgs * times * 2u) || {\n         alt check select2(po_a, po_b) {\n           either::left(\"a\") { as += 1 }\n           either::right(\"b\") { bs += 1 }\n@@ -440,9 +440,9 @@ fn test_recv_chan_wrong_task() {\n     let po = port();\n     let ch = chan(po);\n     send(ch, \"flower\");\n-    assert result::is_err(task::try({||\n+    assert result::is_err(task::try(||\n         recv_chan(ch)\n-    }))\n+    ))\n }\n \n #[test]\n@@ -462,8 +462,8 @@ fn test_chan_peek() {\n \n #[test]\n fn test_listen() {\n-    do listen {|parent|\n-        do task::spawn {||\n+    do listen |parent| {\n+        do task::spawn || {\n             parent.send(\"oatmeal-salad\");\n         }\n         assert parent.recv() == \"oatmeal-salad\";\n@@ -473,18 +473,18 @@ fn test_listen() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_port_detach_fail() {\n-    do iter::repeat(100u) {||\n+    do iter::repeat(100u) || {\n         let builder = task::builder();\n         task::unsupervise(builder);\n-        do task::run(builder) {||\n+        do task::run(builder) || {\n             let po = port();\n             let ch = po.chan();\n \n-            do task::spawn {||\n+            do task::spawn || {\n                 fail;\n             }\n \n-            do task::spawn {||\n+            do task::spawn || {\n                 ch.send(());\n             }\n         }"}, {"sha": "ea67947073ecbe939670c48a11f2111f97e8601a", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -114,12 +114,12 @@ impl extensions<A> for dvec<A> {\n     \"]\n     #[inline(always)]\n     fn swap(f: fn(-~[mut A]) -> ~[mut A]) {\n-        self.borrow({ |v| self.return(f(v)) })\n+        self.borrow(|v| self.return(f(v)))\n     }\n \n     #[doc = \"Returns the number of elements currently in the dvec\"]\n     fn len() -> uint {\n-        do self.borrow { |v|\n+        do self.borrow |v| {\n             let l = v.len();\n             self.return(v);\n             l\n@@ -134,7 +134,7 @@ impl extensions<A> for dvec<A> {\n \n     #[doc = \"Remove and return the last element\"]\n     fn pop() -> A {\n-        do self.borrow { |v|\n+        do self.borrow |v| {\n             let mut v <- v;\n             let result = vec::pop(v);\n             self.return(v);\n@@ -164,7 +164,7 @@ impl extensions<A> for dvec<A> {\n \n     #[doc = \"Remove and return the first element\"]\n     fn shift() -> A {\n-        do self.borrow { |v|\n+        do self.borrow |v| {\n             let mut v = vec::from_mut(v);\n             let result = vec::shift(v);\n             self.return(vec::to_mut(v));\n@@ -187,7 +187,7 @@ impl extensions<A:copy> for dvec<A> {\n         Appends elements from `from_idx` to `to_idx` (exclusive)\n     \"]\n     fn push_slice(ts: &[const A], from_idx: uint, to_idx: uint) {\n-        do self.swap { |v|\n+        do self.swap |v| {\n             let mut v <- v;\n             let new_len = vec::len(v) + to_idx - from_idx;\n             vec::reserve(v, new_len);\n@@ -207,7 +207,7 @@ impl extensions<A:copy> for dvec<A> {\n         attempts to access this vector.\n     \"]\n     fn append_iter<A, I:iter::base_iter<A>>(ts: I) {\n-       do self.swap { |v|\n+        do self.swap |v| {\n            let mut v = alt ts.size_hint() {\n              none { v }\n              some(h) {\n@@ -218,7 +218,7 @@ impl extensions<A:copy> for dvec<A> {\n             }\n            };\n \n-           for ts.each { |t| vec::push(v, t) };\n+        for ts.each |t| { vec::push(v, t) };\n            v\n         }\n     }\n@@ -229,7 +229,7 @@ impl extensions<A:copy> for dvec<A> {\n         See `unwrap()` if you do not wish to copy the contents.\n     \"]\n     fn get() -> ~[A] {\n-        do self.borrow { |v|\n+        do self.borrow |v| {\n             let w = vec::from_mut(copy v);\n             self.return(v);\n             w\n@@ -259,7 +259,7 @@ impl extensions<A:copy> for dvec<A> {\n     growing the vector if necessary.  New elements will be initialized\n     with `initval`\"]\n     fn grow_set_elt(idx: uint, initval: A, val: A) {\n-        do self.swap { |v|\n+        do self.swap |v| {\n             let mut v <- v;\n             vec::grow_set(v, idx, initval, val);\n             v"}, {"sha": "9dadd848415e6d695a289815e83025335110f193", "filename": "src/libcore/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -25,7 +25,7 @@ fn lefts<T: copy, U>(eithers: ~[either<T, U>]) -> ~[T] {\n     #[doc = \"Extracts from a vector of either all the left values\"];\n \n     let mut result: ~[T] = ~[];\n-    for vec::each(eithers) {|elt|\n+    for vec::each(eithers) |elt| {\n         alt elt { left(l) { vec::push(result, l); } _ {/* fallthrough */ } }\n     }\n     ret result;\n@@ -35,7 +35,7 @@ fn rights<T, U: copy>(eithers: ~[either<T, U>]) -> ~[U] {\n     #[doc = \"Extracts from a vector of either all the right values\"];\n \n     let mut result: ~[U] = ~[];\n-    for vec::each(eithers) {|elt|\n+    for vec::each(eithers) |elt| {\n         alt elt { right(r) { vec::push(result, r); } _ {/* fallthrough */ } }\n     }\n     ret result;\n@@ -52,7 +52,7 @@ fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n \n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n-    for vec::each(eithers) {|elt|\n+    for vec::each(eithers) |elt| {\n         alt elt {\n           left(l) { vec::push(lefts, l); }\n           right(r) { vec::push(rights, r); }"}, {"sha": "e156e5954900d5198971a62d3fc46289573abfdc", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -174,7 +174,7 @@ mod ct {\n             let curr: ~[flag] = ~[f];\n             ret {flags: vec::append(curr, rest), next: j};\n         }\n-        let more = {|x|more_(x, s, i, lim)};\n+        let more = |x| more_(x, s, i, lim);\n         let f = s[i];\n         ret if f == '-' as u8 {\n                 more(flag_left_justify)"}, {"sha": "51aeb3a354c825b430ca4fdc485ba8e4c0140a73", "filename": "src/libcore/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -64,7 +64,7 @@ fn from_port<A:send>(-port: comm::port<A>) -> future<A> {\n     waiting for the result to be received on the port.\n     \"];\n \n-    do from_fn {||\n+    do from_fn || {\n         comm::recv(port)\n     }\n }\n@@ -93,7 +93,7 @@ fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n \n     let mut po = comm::port();\n     let ch = comm::chan(po);\n-    do task::spawn {||\n+    do task::spawn || {\n         comm::send(ch, blk())\n     };\n     from_port(po)\n@@ -102,7 +102,7 @@ fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n fn get<A:copy>(future: future<A>) -> A {\n     #[doc = \"Get the value of the future\"];\n \n-    do with(future) {|v| v }\n+    do with(future) |v| { v }\n }\n \n fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n@@ -150,25 +150,25 @@ fn test_iface_get() {\n #[test]\n fn test_with() {\n     let f = from_value(\"nail\");\n-    assert with(f, {|v| v}) == \"nail\";\n+    assert with(f, |v| v) == \"nail\";\n }\n \n #[test]\n fn test_iface_with() {\n     let f = from_value(\"kale\");\n-    assert f.with({|v| v}) == \"kale\";\n+    assert f.with(|v| v) == \"kale\";\n }\n \n #[test]\n fn test_spawn() {\n-    let f = spawn({|| \"bale\" });\n+    let f = spawn(|| \"bale\");\n     assert get(f) == \"bale\";\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(target_os = \"win32\"))]\n fn test_futurefail() {\n-    let f = spawn({|| fail });\n+    let f = spawn(|| fail);\n     let _x: str = get(f);\n }"}, {"sha": "ac11f2f1102c64f3f20dbdb01a3148a988b4bcc4", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -93,8 +93,8 @@ fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n #[doc = \"Convert to a string in a given base\"]\n fn to_str(n: T, radix: uint) -> str {\n-    do to_str_bytes(n, radix) {|slice|\n-        do vec::unpack_slice(slice) {|p, len|\n+    do to_str_bytes(n, radix) |slice| {\n+        do vec::unpack_slice(slice) |p, len| {\n             unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }"}, {"sha": "8527f58ca6caa5950686842db88ee9e045587283", "filename": "src/libcore/io.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -195,7 +195,7 @@ impl of reader for *libc::FILE {\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut buf : ~[mut u8] = ~[mut];\n         vec::reserve(buf, len);\n-        do vec::as_mut_buf(buf) {|b|\n+        do vec::as_mut_buf(buf) |b| {\n             let read = libc::fread(b as *mut c_void, 1u as size_t,\n                                    len as size_t, self);\n             unsafe { vec::unsafe::set_len(buf, read as uint) };\n@@ -245,10 +245,10 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> reader {\n fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n \n fn file_reader(path: str) -> result<reader, str> {\n-    let f = os::as_c_charp(path, {|pathbuf|\n-        os::as_c_charp(\"r\", {|modebuf|\n+    let f = os::as_c_charp(path, |pathbuf| {\n+        os::as_c_charp(\"r\", |modebuf|\n             libc::fopen(pathbuf, modebuf)\n-        })\n+        )\n     });\n     ret if f as uint == 0u { result::err(\"error opening \" + path) }\n     else {\n@@ -308,7 +308,7 @@ fn str_reader(s: str) -> reader {\n }\n \n fn with_str_reader<T>(s: str, f: fn(reader) -> T) -> T {\n-    do str::as_bytes(s) { |bytes|\n+    do str::as_bytes(s) |bytes| {\n         with_bytes_reader_between(bytes, 0u, str::len(s), f)\n     }\n }\n@@ -334,7 +334,7 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n \n impl of writer for *libc::FILE {\n     fn write(v: &[const u8]) {\n-        do vec::unpack_const_slice(v) {|vbuf, len|\n+        do vec::unpack_const_slice(v) |vbuf, len| {\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n                                     1u as size_t, self);\n             if nout < 1 as size_t {\n@@ -363,7 +363,7 @@ fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n impl of writer for fd_t {\n     fn write(v: &[const u8]) {\n         let mut count = 0u;\n-        do vec::unpack_const_slice(v) {|vbuf, len|\n+        do vec::unpack_const_slice(v) |vbuf, len| {\n             while count < len {\n                 let vb = ptr::const_offset(vbuf, count) as *c_void;\n                 let nout = libc::write(self, vb, len as size_t);\n@@ -412,15 +412,15 @@ fn mk_file_writer(path: str, flags: ~[fileflag])\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-    for vec::each(flags) {|f|\n+    for vec::each(flags) |f| {\n         alt f {\n           append { fflags |= O_APPEND as c_int; }\n           create { fflags |= O_CREAT as c_int; }\n           truncate { fflags |= O_TRUNC as c_int; }\n           no_flag { }\n         }\n     }\n-    let fd = do os::as_c_charp(path) {|pathbuf|\n+    let fd = do os::as_c_charp(path) |pathbuf| {\n         libc::open(pathbuf, fflags,\n                    (S_IRUSR | S_IWUSR) as c_int)\n     };\n@@ -514,78 +514,78 @@ impl writer_util for writer {\n             self.write_str(str::from_char(ch));\n         }\n     }\n-    fn write_str(s: str/&) { str::byte_slice(s, {|v| self.write(v); }) }\n+    fn write_str(s: str/&) { str::byte_slice(s, |v| self.write(v)) }\n     fn write_line(s: str/&) {\n         self.write_str(s);\n         self.write_str(\"\\n\"/&);\n     }\n     fn write_int(n: int) {\n-        int::to_str_bytes(n, 10u, {|buf| self.write(buf) })\n+        int::to_str_bytes(n, 10u, |buf| self.write(buf))\n     }\n     fn write_uint(n: uint) {\n-        uint::to_str_bytes(false, n, 10u, {|buf| self.write(buf) })\n+        uint::to_str_bytes(false, n, 10u, |buf| self.write(buf))\n     }\n     fn write_le_uint(n: uint, size: uint) {\n-        u64_to_le_bytes(n as u64, size, {|v| self.write(v) })\n+        u64_to_le_bytes(n as u64, size, |v| self.write(v))\n     }\n     fn write_le_int(n: int, size: uint) {\n-        u64_to_le_bytes(n as u64, size, {|v| self.write(v) })\n+        u64_to_le_bytes(n as u64, size, |v| self.write(v))\n     }\n     fn write_be_uint(n: uint, size: uint) {\n-        u64_to_be_bytes(n as u64, size, {|v| self.write(v) })\n+        u64_to_be_bytes(n as u64, size, |v| self.write(v))\n     }\n     fn write_be_int(n: int, size: uint) {\n-        u64_to_be_bytes(n as u64, size, {|v| self.write(v) })\n+        u64_to_be_bytes(n as u64, size, |v| self.write(v))\n     }\n     fn write_be_u64(n: u64) {\n-        u64_to_be_bytes(n, 8u, {|v| self.write(v) })\n+        u64_to_be_bytes(n, 8u, |v| self.write(v))\n     }\n     fn write_be_u32(n: u32) {\n-        u64_to_be_bytes(n as u64, 4u, {|v| self.write(v) })\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n     fn write_be_u16(n: u16) {\n-        u64_to_be_bytes(n as u64, 2u, {|v| self.write(v) })\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n     fn write_be_i64(n: i64) {\n-        u64_to_be_bytes(n as u64, 8u, {|v| self.write(v) })\n+        u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n     fn write_be_i32(n: i32) {\n-        u64_to_be_bytes(n as u64, 4u, {|v| self.write(v) })\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n     fn write_be_i16(n: i16) {\n-        u64_to_be_bytes(n as u64, 2u, {|v| self.write(v) })\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n     fn write_le_u64(n: u64) {\n-        u64_to_le_bytes(n, 8u, {|v| self.write(v) })\n+        u64_to_le_bytes(n, 8u, |v| self.write(v))\n     }\n     fn write_le_u32(n: u32) {\n-        u64_to_le_bytes(n as u64, 4u, {|v| self.write(v) })\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n     fn write_le_u16(n: u16) {\n-        u64_to_le_bytes(n as u64, 2u, {|v| self.write(v) })\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n     fn write_le_i64(n: i64) {\n-        u64_to_le_bytes(n as u64, 8u, {|v| self.write(v) })\n+        u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n     }\n     fn write_le_i32(n: i32) {\n-        u64_to_le_bytes(n as u64, 4u, {|v| self.write(v) })\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n     fn write_le_i16(n: i16) {\n-        u64_to_le_bytes(n as u64, 2u, {|v| self.write(v) })\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     fn write_u8(n: u8) { self.write(&[n]) }\n }\n \n fn file_writer(path: str, flags: ~[fileflag]) -> result<writer, str> {\n-    result::chain(mk_file_writer(path, flags), { |w| result::ok(w)})\n+    result::chain(mk_file_writer(path, flags), |w| result::ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n fn buffered_file_writer(path: str) -> result<writer, str> {\n-    let f = do os::as_c_charp(path) {|pathbuf|\n-        do os::as_c_charp(\"w\") {|modebuf|\n+    let f = do os::as_c_charp(path) |pathbuf| {\n+        do os::as_c_charp(\"w\") |modebuf| {\n             libc::fopen(pathbuf, modebuf)\n         }\n     };\n@@ -672,15 +672,15 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n }\n \n fn read_whole_file_str(file: str) -> result<str, str> {\n-    result::chain(read_whole_file(file), { |bytes|\n+    result::chain(read_whole_file(file), |bytes| {\n         result::ok(str::from_bytes(bytes))\n     })\n }\n \n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n fn read_whole_file(file: str) -> result<~[u8], str> {\n-    result::chain(file_reader(file), { |rdr|\n+    result::chain(file_reader(file), |rdr| {\n         result::ok(rdr.read_whole_stream())\n     })\n }\n@@ -804,7 +804,7 @@ mod tests {\n                 assert(vec::len(res) == len);\n             }\n             assert(vec::slice(ivals, 0u, vec::len(res)) ==\n-                   vec::map(res, {|x| x as int}));\n+                   vec::map(res, |x| x as int));\n         }\n         let mut i = 0u;\n         while i < 8u {"}, {"sha": "3f1f4db6a4dd68135197b0aa66b9cb480128f6b8", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -7,7 +7,7 @@ Attempts to access this dvec during iteration will fail.\n \"]\n fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     import dvec::extensions;\n-    self.swap({ |v| vec::each(v, f); v })\n+    self.swap(|v| { vec::each(v, f); v })\n }\n \n fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {"}, {"sha": "c5f395d376c3d55b7a9e65a8199e307f37dcd612", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -5,21 +5,21 @@ iface base_iter<A> {\n \n fn eachi<A,IA:base_iter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n     let mut i = 0u;\n-    for self.each {|a|\n+    for self.each |a| {\n         if !blk(i, a) { break; }\n         i += 1u;\n     }\n }\n \n fn all<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n-    for self.each {|a|\n+    for self.each |a| {\n         if !blk(a) { ret false; }\n     }\n     ret true;\n }\n \n fn any<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n-    for self.each {|a|\n+    for self.each |a| {\n         if blk(a) { ret true; }\n     }\n     ret false;\n@@ -28,17 +28,17 @@ fn any<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n                                          prd: fn(A) -> bool) -> ~[A] {\n     let mut result = ~[];\n-    self.size_hint().iter({|hint| vec::reserve(result, hint); });\n-    for self.each {|a|\n+    self.size_hint().iter(|hint| vec::reserve(result, hint));\n+    for self.each |a| {\n         if prd(a) { vec::push(result, a); }\n     }\n     ret result;\n }\n \n fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n     let mut result = ~[];\n-    self.size_hint().iter({|hint| vec::reserve(result, hint); });\n-    for self.each {|a|\n+    self.size_hint().iter(|hint| vec::reserve(result, hint));\n+    for self.each |a| {\n         vec::push(result, op(a));\n     }\n     ret result;\n@@ -48,8 +48,8 @@ fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n     self: IA, op: fn(A) -> IB) -> ~[B] {\n \n     let mut result = ~[];\n-    for self.each {|a|\n-        for op(a).each {|b|\n+    for self.each |a| {\n+        for op(a).each |b| {\n             vec::push(result, b);\n         }\n     }\n@@ -58,25 +58,25 @@ fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n \n fn foldl<A,B,IA:base_iter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     let mut b <- b0;\n-    for self.each {|a|\n+    for self.each |a| {\n         b = blk(b, a);\n     }\n     ret b;\n }\n \n fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> ~[A] {\n-    foldl::<A,~[A],IA>(self, ~[], {|r, a| vec::append(r, ~[a]) })\n+    foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(r, ~[a]))\n }\n \n fn contains<A,IA:base_iter<A>>(self: IA, x: A) -> bool {\n-    for self.each {|a|\n+    for self.each |a| {\n         if a == x { ret true; }\n     }\n     ret false;\n }\n \n fn count<A,IA:base_iter<A>>(self: IA, x: A) -> uint {\n-    do foldl(self, 0u) {|count, value|\n+    do foldl(self, 0u) |count, value| {\n         if value == x {\n             count + 1u\n         } else {\n@@ -88,7 +88,7 @@ fn count<A,IA:base_iter<A>>(self: IA, x: A) -> uint {\n fn position<A,IA:base_iter<A>>(self: IA, f: fn(A) -> bool)\n         -> option<uint> {\n     let mut i = 0;\n-    for self.each {|a|\n+    for self.each |a| {\n         if f(a) { ret some(i); }\n         i += 1;\n     }\n@@ -108,7 +108,7 @@ fn repeat(times: uint, blk: fn()) {\n }\n \n fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n-    alt do foldl::<A,option<A>,IA>(self, none) {|a, b|\n+    alt do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         alt a {\n           some(a_) if a_ < b {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n@@ -124,7 +124,7 @@ fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n }\n \n fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n-    alt do foldl::<A,option<A>,IA>(self, none) {|a, b|\n+    alt do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         alt a {\n           some(a_) if a_ > b {\n             // FIXME (#2005): Not sure if this is successfully optimized to"}, {"sha": "c97420646c989c311d787c6c8faa55a0f382ab92", "filename": "src/libcore/newcomm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fnewcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fnewcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnewcomm.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -31,7 +31,7 @@ fn chan<T: send>(p: port<T>) -> chan<T> {\n \n fn send<T: send>(c: chan<T>, -x: T) {\n     let mut x <- some(x);\n-    do (*c).with {|cond, data|\n+    do (*c).with |cond, data| {\n         let mut xx = none;\n         xx <-> x;\n         (*data).push(option::unwrap(xx));\n@@ -40,7 +40,7 @@ fn send<T: send>(c: chan<T>, -x: T) {\n }\n \n fn recv<T: send>(p: port<T>) -> T {\n-    do (*p).with {|cond, data|\n+    do (*p).with |cond, data| {\n         if (*data).len() == 0u {\n             cond.wait();\n         }"}, {"sha": "3d47c51a73ff5c9d2ddd4ade09ef93c57e8cf29b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -133,10 +133,10 @@ fn test_unwrap_ptr() {\n #[test]\n fn test_unwrap_str() {\n     let x = \"test\";\n-    let addr_x = str::as_buf(x, {|buf| ptr::addr_of(buf) });\n+    let addr_x = str::as_buf(x, |buf| ptr::addr_of(buf));\n     let opt = some(x);\n     let y = unwrap(opt);\n-    let addr_y = str::as_buf(y, {|buf| ptr::addr_of(buf) });\n+    let addr_y = str::as_buf(y, |buf| ptr::addr_of(buf));\n     assert addr_x == addr_y;\n }\n "}, {"sha": "b945a998084053409e70f457a58f425921011283", "filename": "src/libcore/os.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -53,7 +53,7 @@ native mod rustrt {\n \n fn env() -> ~[(str,str)] {\n     let mut pairs = ~[];\n-    for vec::each(rustrt::rust_env_pairs()) {|p|\n+    for vec::each(rustrt::rust_env_pairs()) |p| {\n         let vs = str::splitn_char(p, '=', 1u);\n         assert vec::len(vs) == 2u;\n         vec::push(pairs, (vs[0], vs[1]));\n@@ -64,13 +64,13 @@ fn env() -> ~[(str,str)] {\n const tmpbuf_sz : uint = 1000u;\n \n fn as_c_charp<T>(s: str, f: fn(*c_char) -> T) -> T {\n-    str::as_c_str(s, {|b| f(b as *c_char) })\n+    str::as_c_str(s, |b| f(b as *c_char))\n }\n \n fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> option<str> {\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n-    do vec::as_mut_buf(buf) { |b|\n+    do vec::as_mut_buf(buf) |b| {\n         if f(b, tmpbuf_sz as size_t) unsafe {\n             some(str::unsafe::from_buf(b as *u8))\n         } else {\n@@ -95,7 +95,7 @@ mod win32 {\n         let mut done = false;\n         while !done {\n             let buf = vec::to_mut(vec::from_elem(n as uint, 0u16));\n-            do vec::as_mut_buf(buf) {|b|\n+            do vec::as_mut_buf(buf) |b| {\n                 let k : dword = f(b, tmpbuf_sz as dword);\n                 if k == (0 as dword) {\n                     done = true;\n@@ -160,7 +160,7 @@ mod global_env {\n \n     fn get_global_env_chan() -> comm::chan<msg> {\n         let global_ptr = rustrt::rust_global_env_chan_ptr();\n-        let builder_fn = {||\n+        let builder_fn = || {\n             let builder = task::builder();\n             task::unsupervise(builder);\n             task::set_opts(builder, {\n@@ -182,7 +182,7 @@ mod global_env {\n \n     fn global_env_task(msg_po: comm::port<msg>) {\n         unsafe {\n-            do priv::weaken_task {|weak_po|\n+            do priv::weaken_task |weak_po| {\n                 loop {\n                     alt comm::select2(msg_po, weak_po) {\n                       either::left(msg_getenv(n, resp_ch)) {\n@@ -220,8 +220,8 @@ mod global_env {\n             import libc::types::os::arch::extra::*;\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n-            do as_utf16_p(n) {|u|\n-                do fill_utf16_buf_and_decode() {|buf, sz|\n+            do as_utf16_p(n) |u| {\n+                do fill_utf16_buf_and_decode() |buf, sz| {\n                     GetEnvironmentVariableW(u, buf, sz)\n                 }\n             }\n@@ -233,8 +233,8 @@ mod global_env {\n \n             // FIXME: remove this when export globs work properly. #1238\n             import libc::funcs::posix01::unistd::setenv;\n-            do str::as_c_str(n) {|nbuf|\n-                do str::as_c_str(v) {|vbuf|\n+            do str::as_c_str(n) |nbuf| {\n+                do str::as_c_str(v) |vbuf| {\n                     setenv(nbuf, vbuf, 1i32);\n                 }\n             }\n@@ -246,8 +246,8 @@ mod global_env {\n             // FIXME: remove imports when export globs work properly. #1238\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n-            do as_utf16_p(n) {|nbuf|\n-                do as_utf16_p(v) {|vbuf|\n+            do as_utf16_p(n) |nbuf| {\n+                do as_utf16_p(v) |vbuf| {\n                     SetEnvironmentVariableW(nbuf, vbuf);\n                 }\n             }\n@@ -257,7 +257,7 @@ mod global_env {\n }\n \n fn fdopen(fd: c_int) -> *FILE {\n-    ret do as_c_charp(\"r\") {|modebuf|\n+    ret do as_c_charp(\"r\") |modebuf| {\n         libc::fdopen(fd, modebuf)\n     };\n }\n@@ -370,7 +370,7 @@ fn self_exe_path() -> option<path> {\n         unsafe {\n             import libc::funcs::bsd44::*;\n             import libc::consts::os::extra::*;\n-            do fill_charp_buf() {|buf, sz|\n+            do fill_charp_buf() |buf, sz| {\n                 let mib = ~[CTL_KERN as c_int,\n                            KERN_PROC as c_int,\n                            KERN_PROC_PATHNAME as c_int, -1 as c_int];\n@@ -384,8 +384,8 @@ fn self_exe_path() -> option<path> {\n     #[cfg(target_os = \"linux\")]\n     fn load_self() -> option<path> {\n         import libc::funcs::posix01::unistd::readlink;\n-        do fill_charp_buf() {|buf, sz|\n-            do as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n+        do fill_charp_buf() |buf, sz| {\n+            do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n                 readlink(proc_self_buf, buf, sz) != (-1 as ssize_t)\n             }\n         }\n@@ -395,7 +395,7 @@ fn self_exe_path() -> option<path> {\n     fn load_self() -> option<path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n-        do fill_charp_buf() {|buf, sz|\n+        do fill_charp_buf() |buf, sz| {\n             _NSGetExecutablePath(buf, ptr::mut_addr_of(sz as u32))\n                 == (0 as c_int)\n         }\n@@ -407,12 +407,12 @@ fn self_exe_path() -> option<path> {\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n-        do fill_utf16_buf_and_decode() {|buf, sz|\n+        do fill_utf16_buf_and_decode() |buf, sz| {\n             GetModuleFileNameW(0u as dword, buf, sz)\n         }\n     }\n \n-    do option::map(load_self()) {|pth|\n+    do option::map(load_self()) |pth| {\n         path::dirname(pth) + path::path_sep()\n     }\n }\n@@ -452,7 +452,7 @@ fn homedir() -> option<path> {\n \n     #[cfg(windows)]\n     fn secondary() -> option<path> {\n-        do option::chain(getenv(\"USERPROFILE\")) {|p|\n+        do option::chain(getenv(\"USERPROFILE\")) |p| {\n             if !str::is_empty(p) {\n                 some(p)\n             } else {\n@@ -469,7 +469,7 @@ fn walk_dir(p: path, f: fn(path) -> bool) {\n \n     fn walk_dir_(p: path, f: fn(path) -> bool) -> bool {\n         let mut keepgoing = true;\n-        do list_dir(p).each {|q|\n+        do list_dir(p).each |q| {\n             let path = path::connect(p, q);\n             if !f(path) {\n                 keepgoing = false;\n@@ -493,14 +493,14 @@ fn walk_dir(p: path, f: fn(path) -> bool) {\n \n #[doc = \"Indicates whether a path represents a directory\"]\n fn path_is_dir(p: path) -> bool {\n-    do str::as_c_str(p) {|buf|\n+    do str::as_c_str(p) |buf| {\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n #[doc = \"Indicates whether a path exists\"]\n fn path_exists(p: path) -> bool {\n-    do str::as_c_str(p) {|buf|\n+    do str::as_c_str(p) |buf| {\n         rustrt::rust_path_exists(buf) != 0 as c_int\n     }\n }\n@@ -537,15 +537,15 @@ fn make_dir(p: path, mode: c_int) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n         // FIXME: turn mode into something useful? #2623\n-        do as_utf16_p(p) {|buf|\n+        do as_utf16_p(p) |buf| {\n             CreateDirectoryW(buf, unsafe { unsafe::reinterpret_cast(0) })\n                 != (0 as BOOL)\n         }\n     }\n \n     #[cfg(unix)]\n     fn mkdir(p: path, mode: c_int) -> bool {\n-        do as_c_charp(p) {|c|\n+        do as_c_charp(p) |c| {\n             libc::mkdir(c, mode as mode_t) == (0 as c_int)\n         }\n     }\n@@ -568,7 +568,7 @@ fn list_dir(p: path) -> ~[str] {\n         }\n     }\n \n-    do rustrt::rust_list_files(star(p)).filter {|filename|\n+    do rustrt::rust_list_files(star(p)).filter |filename| {\n         !str::eq(filename, \".\") && !str::eq(filename, \"..\")\n     }\n }\n@@ -585,7 +585,7 @@ fn list_dir_path(p: path) -> ~[str] {\n                     && p[pl - 1u] as char != path::consts::alt_path_sep) {\n         p += path::path_sep();\n     }\n-    os::list_dir(p).map({|f| p + f})\n+    os::list_dir(p).map(|f| p + f)\n }\n \n #[doc = \"Removes a directory at the specified path\"]\n@@ -598,14 +598,14 @@ fn remove_dir(p: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(p) {|buf|\n+        ret do as_utf16_p(p) |buf| {\n             RemoveDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn rmdir(p: path) -> bool {\n-        ret do as_c_charp(p) {|buf|\n+        ret do as_c_charp(p) |buf| {\n             libc::rmdir(buf) == (0 as c_int)\n         };\n     }\n@@ -620,14 +620,14 @@ fn change_dir(p: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(p) {|buf|\n+        ret do as_utf16_p(p) |buf| {\n             SetCurrentDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn chdir(p: path) -> bool {\n-        ret do as_c_charp(p) {|buf|\n+        ret do as_c_charp(p) |buf| {\n             libc::chdir(buf) == (0 as c_int)\n         };\n     }\n@@ -643,25 +643,25 @@ fn copy_file(from: path, to: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(from) {|fromp|\n-            do as_utf16_p(to) {|top|\n+        ret do as_utf16_p(from) |fromp| {\n+            do as_utf16_p(to) |top| {\n                 CopyFileW(fromp, top, (0 as BOOL)) != (0 as BOOL)\n             }\n         }\n     }\n \n     #[cfg(unix)]\n     fn do_copy_file(from: path, to: path) -> bool {\n-        let istream = do as_c_charp(from) {|fromp|\n-            do as_c_charp(\"rb\") {|modebuf|\n+        let istream = do as_c_charp(from) |fromp| {\n+            do as_c_charp(\"rb\") |modebuf| {\n                 libc::fopen(fromp, modebuf)\n             }\n         };\n         if istream as uint == 0u {\n             ret false;\n         }\n-        let ostream = do as_c_charp(to) {|top|\n-            do as_c_charp(\"w+b\") {|modebuf|\n+        let ostream = do as_c_charp(to) |top| {\n+            do as_c_charp(\"w+b\") |modebuf| {\n                 libc::fopen(top, modebuf)\n             }\n         };\n@@ -675,7 +675,7 @@ fn copy_file(from: path, to: path) -> bool {\n         let mut done = false;\n         let mut ok = true;\n         while !done {\n-          do vec::as_mut_buf(buf) {|b|\n+            do vec::as_mut_buf(buf) |b| {\n               let nread = libc::fread(b as *mut c_void, 1u as size_t,\n                                       bufsize as size_t,\n                                       istream);\n@@ -707,14 +707,14 @@ fn remove_file(p: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(p) {|buf|\n+        ret do as_utf16_p(p) |buf| {\n             DeleteFileW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn unlink(p: path) -> bool {\n-        ret do as_c_charp(p) {|buf|\n+        ret do as_c_charp(p) |buf| {\n             libc::unlink(buf) == (0 as c_int)\n         };\n     }\n@@ -850,7 +850,7 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert vec::len(e) > 0u;\n-        for vec::each(e) {|p|\n+        for vec::each(e) |p| {\n             let (n, v) = p;\n             log(debug, n);\n             let v2 = getenv(n);\n@@ -894,7 +894,7 @@ mod tests {\n         setenv(\"HOME\", \"\");\n         assert os::homedir() == none;\n \n-        option::iter(oldhome, {|s| setenv(\"HOME\", s)});\n+        option::iter(oldhome, |s| setenv(\"HOME\", s));\n     }\n \n     #[test]\n@@ -924,9 +924,9 @@ mod tests {\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n         assert os::homedir() == some(\"/home/MountainView\");\n \n-        option::iter(oldhome, {|s| setenv(\"HOME\", s)});\n+        option::iter(oldhome, |s| setenv(\"HOME\", s));\n         option::iter(olduserprofile,\n-                               {|s| setenv(\"USERPROFILE\", s)});\n+                               |s| setenv(\"USERPROFILE\", s));\n     }\n \n     // Issue #712\n@@ -939,7 +939,7 @@ mod tests {\n         // Just assuming that we've got some contents in the current directory\n         assert (vec::len(dirs) > 0u);\n \n-        for vec::each(dirs) {|dir| log(debug, dir); }\n+        for vec::each(dirs) |dir| { log(debug, dir); }\n     }\n \n     #[test]\n@@ -970,15 +970,15 @@ mod tests {\n       let out = tempdir + path::path_sep() + \"out.txt\";\n \n       /* Write the temp input file */\n-      let ostream = do as_c_charp(in) {|fromp|\n-            do as_c_charp(\"w+b\") {|modebuf|\n+        let ostream = do as_c_charp(in) |fromp| {\n+            do as_c_charp(\"w+b\") |modebuf| {\n                 libc::fopen(fromp, modebuf)\n             }\n       };\n       assert (ostream as uint != 0u);\n       let s = \"hello\";\n       let mut buf = vec::to_mut(str::bytes(s) + ~[0 as u8]);\n-      do vec::as_mut_buf(buf) {|b|\n+      do vec::as_mut_buf(buf) |b| {\n           assert (libc::fwrite(b as *c_void, 1u as size_t,\n                                (str::len(s) + 1u) as size_t, ostream)\n                   == buf.len() as size_t)};"}, {"sha": "1b514b00759f686590e0efe1fdc4800152ace171", "filename": "src/libcore/path.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -61,9 +61,9 @@ fn path_is_absolute(p: str) -> bool {\n fn path_sep() -> str { ret str::from_char(consts::path_sep); }\n \n fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n-    alt str::rfind(pp, {|ch|\n+    alt str::rfind(pp, |ch|\n         ch == consts::path_sep || ch == consts::alt_path_sep\n-    }) {\n+    ) {\n       some(i) {\n         {dirname: str::slice(pp, 0u, i),\n          basename: str::slice(pp, i + 1u, str::len(pp))}\n@@ -145,7 +145,7 @@ the first element of the returned vector will be the drive letter\n followed by a colon.\n \"]\n fn split(p: path) -> ~[path] {\n-    str::split_nonempty(p, {|c|\n+    str::split_nonempty(p, |c| {\n         c == consts::path_sep || c == consts::alt_path_sep\n     })\n }\n@@ -235,13 +235,12 @@ fn normalize(p: path) -> path {\n     ret s;\n \n     fn strip_dots(s: ~[path]) -> ~[path] {\n-        vec::filter_map(s, { |elem|\n+        vec::filter_map(s, |elem|\n             if elem == \".\" {\n                 option::none\n             } else {\n                 option::some(elem)\n-            }\n-        })\n+            })\n     }\n \n     fn rollup_doubledots(s: ~[path]) -> ~[path] {"}, {"sha": "8d8ce9a9d72f27715e85a274671573370e816b5f", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -41,7 +41,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n \n         let setup_po = comm::port();\n         let setup_ch = comm::chan(setup_po);\n-        let setup_ch = do task::run_listener(builder()) {|setup_po|\n+        let setup_ch = do task::run_listener(builder()) |setup_po| {\n             let po = comm::port::<T>();\n             let ch = comm::chan(po);\n             comm::send(setup_ch, ch);\n@@ -92,7 +92,7 @@ fn test_from_global_chan1() {\n \n     // Create the global channel, attached to a new task\n     let ch = unsafe {\n-        do chan_from_global_ptr(globchanp, task::builder) {|po|\n+        do chan_from_global_ptr(globchanp, task::builder) |po| {\n             let ch = comm::recv(po);\n             comm::send(ch, true);\n             let ch = comm::recv(po);\n@@ -106,7 +106,7 @@ fn test_from_global_chan1() {\n \n     // This one just reuses the previous channel\n     let ch = unsafe {\n-        do chan_from_global_ptr(globchanp, task::builder) {|po|\n+        do chan_from_global_ptr(globchanp, task::builder) |po| {\n             let ch = comm::recv(po);\n             comm::send(ch, false);\n         }\n@@ -121,7 +121,7 @@ fn test_from_global_chan1() {\n #[test]\n fn test_from_global_chan2() {\n \n-    do iter::repeat(100u) {||\n+    do iter::repeat(100u) || {\n         // The global channel\n         let globchan = 0u;\n         let globchanp = ptr::addr_of(globchan);\n@@ -131,13 +131,13 @@ fn test_from_global_chan2() {\n \n         // Spawn a bunch of tasks that all want to compete to\n         // create the global channel\n-        for uint::range(0u, 10u) {|i|\n-            do task::spawn {||\n+        for uint::range(0u, 10u) |i| {\n+            do task::spawn || {\n                 let ch = unsafe {\n                     do chan_from_global_ptr(\n-                        globchanp, task::builder) {|po|\n+                        globchanp, task::builder) |po| {\n \n-                        for uint::range(0u, 10u) {|_j|\n+                        for uint::range(0u, 10u) |_j| {\n                             let ch = comm::recv(po);\n                             comm::send(ch, {i});\n                         }\n@@ -153,7 +153,7 @@ fn test_from_global_chan2() {\n         }\n         // There should be only one winner\n         let mut winners = 0u;\n-        for uint::range(0u, 10u) {|_i|\n+        for uint::range(0u, 10u) |_i| {\n             let res = comm::recv(resultpo);\n             if res { winners += 1u };\n         }\n@@ -200,9 +200,9 @@ unsafe fn weaken_task(f: fn(comm::port<()>)) {\n \n #[test]\n fn test_weaken_task_then_unweaken() {\n-    do task::try {||\n+    do task::try || {\n         unsafe {\n-            do weaken_task {|_po|\n+            do weaken_task |_po| {\n             }\n         }\n     };\n@@ -212,9 +212,9 @@ fn test_weaken_task_then_unweaken() {\n fn test_weaken_task_wait() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    do task::run(builder) {||\n+    do task::run(builder) || {\n         unsafe {\n-            do weaken_task {|po|\n+            do weaken_task |po| {\n                 comm::recv(po);\n             }\n         }\n@@ -224,18 +224,18 @@ fn test_weaken_task_wait() {\n #[test]\n fn test_weaken_task_stress() {\n     // Create a bunch of weak tasks\n-    do iter::repeat(100u) {||\n-        do task::spawn {||\n+    do iter::repeat(100u) || {\n+        do task::spawn || {\n             unsafe {\n-                do weaken_task {|_po|\n+                do weaken_task |_po| {\n                 }\n             }\n         }\n         let builder = task::builder();\n         task::unsupervise(builder);\n-        do task::run(builder) {||\n+        do task::run(builder) || {\n             unsafe {\n-                do weaken_task {|po|\n+                do weaken_task |po| {\n                     // Wait for it to tell us to die\n                     comm::recv(po);\n                 }\n@@ -247,9 +247,9 @@ fn test_weaken_task_stress() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_weaken_task_fail() {\n-    let res = do task::try {||\n+    let res = do task::try || {\n         unsafe {\n-            do weaken_task {|_po|\n+            do weaken_task |_po| {\n                 fail;\n             }\n         }"}, {"sha": "b3eaa3bd16dca259f06942e28631b763a64b439b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -70,7 +70,7 @@ fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n #[doc = \"Return the offset of the first null pointer in `buf`.\"]\n #[inline(always)]\n unsafe fn buf_len<T>(buf: **T) -> uint {\n-    do position(buf) {|i| i == null() }\n+    position(buf, |i| i == null())\n }\n \n #[doc = \"Return the first offset `i` such that `f(buf[i]) == true`.\"]\n@@ -171,9 +171,9 @@ fn test_position() {\n \n     let s = \"hello\";\n     unsafe {\n-        assert 2u == as_c_str(s, {|p| position(p, {|c| c == 'l' as c_char})});\n-        assert 4u == as_c_str(s, {|p| position(p, {|c| c == 'o' as c_char})});\n-        assert 5u == as_c_str(s, {|p| position(p, {|c| c == 0 as c_char })});\n+        assert 2u == as_c_str(s, |p| position(p, |c| c == 'l' as c_char));\n+        assert 4u == as_c_str(s, |p| position(p, |c| c == 'o' as c_char));\n+        assert 5u == as_c_str(s, |p| position(p, |c| c == 0 as c_char));\n     }\n }\n \n@@ -182,11 +182,11 @@ fn test_buf_len() {\n     let s0 = \"hello\";\n     let s1 = \"there\";\n     let s2 = \"thing\";\n-    do str::as_c_str(s0) {|p0|\n-        do str::as_c_str(s1) {|p1|\n-            do str::as_c_str(s2) {|p2|\n+    do str::as_c_str(s0) |p0| {\n+        do str::as_c_str(s1) |p1| {\n+            do str::as_c_str(s2) |p2| {\n                 let v = ~[p0, p1, p2, null()];\n-                do vec::as_buf(v) {|vp|\n+                do vec::as_buf(v) |vp| {\n                     assert unsafe { buf_len(vp) } == 3u;\n                 }\n             }"}, {"sha": "4724c00941c480b51316f142aede7c9c35ec6d90", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -152,7 +152,7 @@ impl extensions for rng {\n \n     #[doc = \"Return a random byte string of the specified length\"]\n     fn gen_bytes(len: uint) -> ~[u8] {\n-        do vec::from_fn(len) {|_i|\n+        do vec::from_fn(len) |_i| {\n             self.gen_u8()\n         }\n     }\n@@ -181,15 +181,15 @@ impl extensions for rng {\n              none if the sum of the weights is 0\"]\n     fn choose_weighted_option<T:copy>(v: ~[weighted<T>]) -> option<T> {\n         let mut total = 0u;\n-        for v.each {|item|\n+        for v.each |item| {\n             total += item.weight;\n         }\n         if total == 0u {\n             ret none;\n         }\n         let chosen = self.gen_uint_range(0u, total);\n         let mut so_far = 0u;\n-        for v.each {|item|\n+        for v.each |item| {\n             so_far += item.weight;\n             if so_far > chosen {\n                 ret some(item.item);\n@@ -202,8 +202,8 @@ impl extensions for rng {\n              the weight of the item determines how many copies there are\"]\n     fn weighted_vec<T:copy>(v: ~[weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n-        for v.each {|item|\n-            for uint::range(0u, item.weight) {|_i|\n+        for v.each |item| {\n+            for uint::range(0u, item.weight) |_i| {\n                 vec::push(r, item.item);\n             }\n         }"}, {"sha": "64d5ff9c73c76177c227a7d32ee5b5a893b33d59", "filename": "src/libcore/result.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -254,7 +254,7 @@ fn map_vec<T,U:copy,V:copy>(\n \n     let mut vs: ~[V] = ~[];\n     vec::reserve(vs, vec::len(ts));\n-    for vec::each(ts) {|t|\n+    for vec::each(ts) |t| {\n         alt op(t) {\n           ok(v) { vec::push(vs, v); }\n           err(u) { ret err(u); }\n@@ -362,33 +362,33 @@ mod tests {\n     #[test]\n     fn test_impl_iter() {\n         let mut valid = false;\n-        ok::<str, str>(\"a\").iter({ |_x| valid = true; });\n+        ok::<str, str>(\"a\").iter(|_x| valid = true);\n         assert valid;\n \n-        err::<str, str>(\"b\").iter({ |_x| valid = false; });\n+        err::<str, str>(\"b\").iter(|_x| valid = false);\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_iter_err() {\n         let mut valid = true;\n-        ok::<str, str>(\"a\").iter_err({ |_x| valid = false; });\n+        ok::<str, str>(\"a\").iter_err(|_x| valid = false);\n         assert valid;\n \n         valid = false;\n-        err::<str, str>(\"b\").iter_err({ |_x| valid = true; });\n+        err::<str, str>(\"b\").iter_err(|_x| valid = true);\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_map() {\n-        assert ok::<str, str>(\"a\").map({ |_x| \"b\" }) == ok(\"b\");\n-        assert err::<str, str>(\"a\").map({ |_x| \"b\" }) == err(\"a\");\n+        assert ok::<str, str>(\"a\").map(|_x| \"b\") == ok(\"b\");\n+        assert err::<str, str>(\"a\").map(|_x| \"b\") == err(\"a\");\n     }\n \n     #[test]\n     fn test_impl_map_err() {\n-        assert ok::<str, str>(\"a\").map_err({ |_x| \"b\" }) == ok(\"a\");\n-        assert err::<str, str>(\"a\").map_err({ |_x| \"b\" }) == err(\"b\");\n+        assert ok::<str, str>(\"a\").map_err(|_x| \"b\") == ok(\"a\");\n+        assert err::<str, str>(\"a\").map_err(|_x| \"b\") == err(\"b\");\n     }\n }"}, {"sha": "7bb3b56fa1b7961ad2d7d3417cb8896574087de3", "filename": "src/libcore/run.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -67,9 +67,9 @@ fn spawn_process(prog: str, args: ~[str],\n                  dir: option<str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n    -> pid_t {\n-    do with_argv(prog, args) {|argv|\n-        do with_envp(env) { |envp|\n-            do with_dirp(dir) { |dirp|\n+    do with_argv(prog, args) |argv| {\n+        do with_envp(env) |envp| {\n+            do with_dirp(dir) |dirp| {\n                 rustrt::rust_run_program(argv, envp, dirp,\n                                          in_fd, out_fd, err_fd)\n             }\n@@ -79,12 +79,12 @@ fn spawn_process(prog: str, args: ~[str],\n \n fn with_argv<T>(prog: str, args: ~[str],\n                 cb: fn(**libc::c_char) -> T) -> T {\n-    let mut argptrs = str::as_c_str(prog, {|b| ~[b] });\n+    let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n     let mut tmps = ~[];\n-    for vec::each(args) {|arg|\n+    for vec::each(args) |arg| {\n         let t = @arg;\n         vec::push(tmps, t);\n-        vec::push_all(argptrs, str::as_c_str(*t, {|b| ~[b] }));\n+        vec::push_all(argptrs, str::as_c_str(*t, |b| ~[b]));\n     }\n     vec::push(argptrs, ptr::null());\n     vec::as_buf(argptrs, cb)\n@@ -100,16 +100,16 @@ fn with_envp<T>(env: option<~[(str,str)]>,\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        for vec::each(es) {|e|\n+        for vec::each(es) |e| {\n             let (k,v) = e;\n             let t = @(#fmt(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n-            vec::push_all(ptrs, str::as_c_str(*t, {|b| ~[b]}));\n+            vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n         }\n         vec::push(ptrs, ptr::null());\n-        vec::as_buf(ptrs, { |p|\n+        vec::as_buf(ptrs, |p|\n             unsafe { cb(::unsafe::reinterpret_cast(p)) }\n-        })\n+        )\n       }\n       _ {\n         cb(ptr::null())\n@@ -127,15 +127,15 @@ fn with_envp<T>(env: option<~[(str,str)]>,\n         alt env {\n           some(es) if !vec::is_empty(es) {\n             let mut blk : ~[u8] = ~[];\n-            for vec::each(es) {|e|\n+            for vec::each(es) |e| {\n                 let (k,v) = e;\n                 let t = #fmt(\"%s=%s\", k, v);\n                 let mut v : ~[u8] = ::unsafe::reinterpret_cast(t);\n                 blk += v;\n                 ::unsafe::forget(v);\n             }\n             blk += ~[0_u8];\n-            vec::as_buf(blk, {|p| cb(::unsafe::reinterpret_cast(p)) })\n+            vec::as_buf(blk, |p| cb(::unsafe::reinterpret_cast(p)))\n           }\n           _ {\n             cb(ptr::null())\n@@ -298,11 +298,11 @@ fn program_output(prog: str, args: ~[str]) ->\n     // clever way to do this.\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    do task::spawn_sched(task::single_threaded) {||\n+    do task::spawn_sched(task::single_threaded) || {\n         let errput = readclose(pipe_err.in);\n         comm::send(ch, (2, errput));\n     };\n-    do task::spawn_sched(task::single_threaded) {||\n+    do task::spawn_sched(task::single_threaded) || {\n         let output = readclose(pipe_out.in);\n         comm::send(ch, (1, output));\n     };"}, {"sha": "4af007b14dd1a38867165daba8867f2b775d89b8", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -18,7 +18,7 @@ fn walk_stack(visit: fn(frame) -> bool) {\n \n     #debug(\"beginning stack walk\");\n \n-    do frame_address { |frame_pointer|\n+    do frame_address |frame_pointer| {\n         let mut frame_address: *word = unsafe {\n             reinterpret_cast(frame_pointer)\n         };\n@@ -44,7 +44,7 @@ fn walk_stack(visit: fn(frame) -> bool) {\n \n #[test]\n fn test_simple() {\n-    for walk_stack { |_frame|\n+    for walk_stack |_frame| {\n     }\n }\n \n@@ -53,7 +53,7 @@ fn test_simple_deep() {\n     fn run(i: int) {\n         if i == 0 { ret }\n \n-        for walk_stack { |_frame|\n+        for walk_stack |_frame| {\n             unsafe {\n                 breakpoint();\n             }"}, {"sha": "e0c257f9c0aa1de90db6d6072d60b329b58d488e", "filename": "src/libcore/str.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -154,7 +154,7 @@ fn push_char(&s: str, ch: char) {\n         let new_len = len + nb;\n         reserve_at_least(s, new_len);\n         let off = len;\n-        do as_buf(s) {|buf|\n+        do as_buf(s) |buf| {\n             let buf: *mut u8 = ::unsafe::reinterpret_cast(buf);\n             if nb == 1u {\n                 *ptr::mut_offset(buf, off) =\n@@ -208,7 +208,7 @@ fn push_char(&s: str, ch: char) {\n             *ptr::mut_offset(buf, off + nb) = 0u8;\n         }\n \n-        do as_bytes(s) {|bytes|\n+        do as_bytes(s) |bytes| {\n             let mut mut_bytes: ~[u8] = ::unsafe::reinterpret_cast(bytes);\n             vec::unsafe::set_len(mut_bytes, new_len + 1u);\n             ::unsafe::forget(mut_bytes);\n@@ -228,15 +228,15 @@ pure fn from_chars(chs: &[const char]) -> str {\n     let mut buf = \"\";\n     unchecked {\n         reserve(buf, chs.len());\n-        for vec::each(chs) {|ch| push_char(buf, ch); }\n+        for vec::each(chs) |ch| { push_char(buf, ch); }\n     }\n     ret buf;\n }\n \n #[doc = \"Concatenate a vector of strings\"]\n pure fn concat(v: &[const str]) -> str {\n     let mut s: str = \"\";\n-    for vec::each(v) {|ss| s += ss; }\n+    for vec::each(v) |ss| { s += ss; }\n     ret s;\n }\n \n@@ -245,7 +245,7 @@ Concatenate a vector of strings, placing a given separator between each\n \"]\n pure fn connect(v: &[const str], sep: str) -> str {\n     let mut s = \"\", first = true;\n-    for vec::each(v) {|ss|\n+    for vec::each(v) |ss| {\n         if first { first = false; } else { s += sep; }\n         s += ss;\n     }\n@@ -289,7 +289,7 @@ fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n #[doc = \"Returns a string with leading whitespace removed\"]\n pure fn trim_left(+s: str) -> str {\n-    alt find(s, {|c| !char::is_whitespace(c)}) {\n+    alt find(s, |c| !char::is_whitespace(c)) {\n       none { \"\" }\n       some(first) {\n         if first == 0u { s }\n@@ -300,7 +300,7 @@ pure fn trim_left(+s: str) -> str {\n \n #[doc = \"Returns a string with trailing whitespace removed\"]\n pure fn trim_right(+s: str) -> str {\n-    alt rfind(s, {|c| !char::is_whitespace(c)}) {\n+    alt rfind(s, |c| !char::is_whitespace(c)) {\n       none { \"\" }\n       some(last) {\n         let {next, _} = char_range_at(s, last);\n@@ -336,7 +336,7 @@ Work with the string as a byte slice, not including trailing null.\n \"]\n #[inline(always)]\n pure fn byte_slice<T>(s: str/&, f: fn(v: &[u8]) -> T) -> T {\n-    do unpack_slice(s) {|p,n|\n+    do unpack_slice(s) |p,n| {\n         unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n     }\n }\n@@ -421,7 +421,7 @@ pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n         }\n         result\n     } else {\n-        splitn(s, {|cur| cur == sep}, count)\n+        splitn(s, |cur| cur == sep, count)\n     }\n }\n \n@@ -495,7 +495,7 @@ pure fn iter_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n \n pure fn iter_between_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     let mut last_end = 0u;\n-    do iter_matches(s, sep) {|from, to|\n+    do iter_matches(s, sep) |from, to| {\n         f(last_end, from);\n         last_end = to;\n     }\n@@ -513,15 +513,15 @@ assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n \"]\n pure fn split_str(s: str/&a, sep: str/&b) -> ~[str] {\n     let mut result = ~[];\n-    do iter_between_matches(s, sep) {|from, to|\n+    do iter_between_matches(s, sep) |from, to| {\n         unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n     }\n     result\n }\n \n pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> ~[str] {\n     let mut result = ~[];\n-    do iter_between_matches(s, sep) {|from, to|\n+    do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n             unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n         }\n@@ -539,7 +539,7 @@ Splits a string into a vector of the substrings separated by LF ('\\\\n')\n and/or CR LF ('\\\\r\\\\n')\n \"]\n pure fn lines_any(s: str/&) -> ~[str] {\n-    vec::map(lines(s), {|s|\n+    vec::map(lines(s), |s| {\n         let l = len(s);\n         let mut cp = s;\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n@@ -553,21 +553,21 @@ pure fn lines_any(s: str/&) -> ~[str] {\n Splits a string into a vector of the substrings separated by whitespace\n \"]\n pure fn words(s: str/&) -> ~[str] {\n-    split_nonempty(s, {|c| char::is_whitespace(c)})\n+    split_nonempty(s, |c| char::is_whitespace(c))\n }\n \n #[doc = \"Convert a string to lowercase. ASCII only\"]\n pure fn to_lower(s: str/&) -> str {\n-    map(s, {|c|\n-        unchecked{(libc::tolower(c as libc::c_char)) as char}\n-    })\n+    map(s,\n+        |c| unchecked{(libc::tolower(c as libc::c_char)) as char}\n+    )\n }\n \n #[doc = \"Convert a string to uppercase. ASCII only\"]\n pure fn to_upper(s: str/&) -> str {\n-    map(s, {|c|\n-        unchecked{(libc::toupper(c as libc::c_char)) as char}\n-    })\n+    map(s,\n+        |c| unchecked{(libc::toupper(c as libc::c_char)) as char}\n+    )\n }\n \n #[doc = \"\n@@ -585,7 +585,7 @@ The original string with all occurances of `from` replaced with `to`\n \"]\n pure fn replace(s: str, from: str, to: str) -> str {\n     let mut result = \"\", first = true;\n-    do iter_between_matches(s, from) {|start, end|\n+    do iter_between_matches(s, from) |start, end| {\n         if first { first = false; } else { result += to; }\n         unsafe { result += unsafe::slice_bytes(s, start, end); }\n     }\n@@ -622,7 +622,7 @@ pure fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur. (see #859 and #1616)\n     let mut u: uint = 5381u;\n-    for each(s) {|c| u *= 33u; u += c as uint; }\n+    for each(s) |c| { u *= 33u; u += c as uint; }\n     ret u;\n }\n \n@@ -643,15 +643,15 @@ Return true if a predicate matches any character (and false if it\n matches none or there are no characters)\n \"]\n pure fn any(ss: str/&, pred: fn(char) -> bool) -> bool {\n-    !all(ss, {|cc| !pred(cc)})\n+    !all(ss, |cc| !pred(cc))\n }\n \n #[doc = \"Apply a function to each character\"]\n pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n     unchecked {\n         reserve(result, len(ss));\n-        do chars_iter(ss) {|cc|\n+        do chars_iter(ss) |cc| {\n             str::push_char(result, ff(cc));\n         }\n     }\n@@ -807,7 +807,7 @@ pure fn find_char_between(s: str/&, c: char, start: uint, end: uint)\n         }\n         ret none;\n     } else {\n-        find_between(s, start, end, {|x| x == c})\n+        find_between(s, start, end, |x| x == c)\n     }\n }\n \n@@ -886,7 +886,7 @@ pure fn rfind_char_between(s: str/&, c: char, start: uint, end: uint)\n         }\n         ret none;\n     } else {\n-        rfind_between(s, start, end, {|x| x == c})\n+        rfind_between(s, start, end, |x| x == c)\n     }\n }\n \n@@ -1051,7 +1051,7 @@ pure fn rfind_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n // Utility used by various searching functions\n pure fn match_at(haystack: str/&a, needle: str/&b, at: uint) -> bool {\n     let mut i = at;\n-    for each(needle) {|c| if haystack[i] != c { ret false; } i += 1u; }\n+    for each(needle) |c| { if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n }\n \n@@ -1215,7 +1215,7 @@ fn is_alphanumeric(s: str/&) -> bool {\n Returns the string length/size in bytes not counting the null terminator\n \"]\n pure fn len(s: str/&) -> uint {\n-    do unpack_slice(s) { |_p, n| n - 1u }\n+    do unpack_slice(s) |_p, n| { n - 1u }\n }\n \n #[doc = \"Returns the number of characters that a string holds\"]\n@@ -1267,7 +1267,7 @@ pure fn is_utf16(v: &[const u16]) -> bool {\n #[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n pure fn to_utf16(s: str/&) -> ~[u16] {\n     let mut u = ~[];\n-    do chars_iter(s) {|cch|\n+    do chars_iter(s) |cch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n@@ -1316,7 +1316,7 @@ pure fn from_utf16(v: &[const u16]) -> str {\n     let mut buf = \"\";\n     unchecked {\n         reserve(buf, vec::len(v));\n-        do utf16_chars(v) {|ch| push_char(buf, ch); }\n+        utf16_chars(v, |ch| push_char(buf, ch));\n     }\n     ret buf;\n }\n@@ -1539,7 +1539,7 @@ Loop through a substring, char by char\n \"]\n pure fn any_between(s: str/&, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n-    !all_between(s, start, end, {|c| !it(c)})\n+    !all_between(s, start, end, |c| !it(c))\n }\n \n // UTF-8 tags and ranges\n@@ -1583,7 +1583,7 @@ Allows for unsafe manipulation of strings, which is useful for native\n interop.\n \"]\n pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T {\n-    as_bytes(s, { |v| unsafe { vec::as_buf(v, f) } })\n+    as_bytes(s, |v| unsafe { vec::as_buf(v, f) })\n }\n \n #[doc = \"\n@@ -1599,7 +1599,7 @@ let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n ~~~\n \"]\n pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T {\n-    as_buf(s, {|buf| f(buf as *libc::c_char) })\n+    as_buf(s, |buf| f(buf as *libc::c_char))\n }\n \n \n@@ -1671,7 +1671,7 @@ Returns the number of single-byte characters the string can hold without\n reallocating\n \"]\n pure fn capacity(&&s: str) -> uint {\n-    do as_bytes(s) {|buf|\n+    do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n         vcap - 1u\n@@ -1683,7 +1683,7 @@ pure fn escape_default(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n-        do chars_iter(s) {|c| out += char::escape_default(c); }\n+        chars_iter(s, |c| out += char::escape_default(c));\n     }\n     ret out;\n }\n@@ -1693,7 +1693,7 @@ pure fn escape_unicode(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n-        do chars_iter(s) {|c| out += char::escape_unicode(c); }\n+        chars_iter(s, |c| out += char::escape_unicode(c));\n     }\n     ret out;\n }\n@@ -1726,7 +1726,7 @@ mod unsafe {\n     unsafe fn from_buf_len(buf: *u8, len: uint) -> str {\n         let mut v: ~[u8] = ~[];\n         vec::reserve(v, len + 1u);\n-        do vec::as_buf(v) {|b| ptr::memcpy(b, buf, len); }\n+        vec::as_buf(v, |b| ptr::memcpy(b, buf, len));\n         vec::unsafe::set_len(v, len);\n         vec::push(v, 0u8);\n \n@@ -1777,14 +1777,14 @@ mod unsafe {\n    If end is greater than the length of the string.\n    \"]\n    unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str {\n-       do unpack_slice(s) { |sbuf, n|\n+       do unpack_slice(s) |sbuf, n| {\n            assert (begin <= end);\n            assert (end <= n);\n \n            let mut v = ~[];\n            vec::reserve(v, end - begin + 1u);\n            unsafe {\n-               do vec::as_buf(v) { |vbuf|\n+               do vec::as_buf(v) |vbuf| {\n                    let src = ptr::offset(sbuf, begin);\n                    ptr::memcpy(vbuf, src, end - begin);\n                }\n@@ -1802,7 +1802,7 @@ mod unsafe {\n \n    #[doc = \"Appends a vector of bytes to a string. (Not UTF-8 safe).\"]\n    unsafe fn push_bytes(&s: str, bytes: ~[u8]) {\n-       for vec::each(bytes) {|byte| rustrt::rust_str_push(s, byte); }\n+       for vec::each(bytes) |byte| { rustrt::rust_str_push(s, byte); }\n    }\n \n    #[doc = \"\n@@ -2037,7 +2037,7 @@ mod tests {\n             log(debug, \"split_byte: \" + s);\n             let v = split_char(s, c);\n             #debug(\"split_byte to: %?\", v);\n-            assert vec::all2(v, u, { |a,b| a == b });\n+            assert vec::all2(v, u, |a,b| a == b);\n         }\n         t(\"abc.hello.there\", '.', ~[\"abc\", \"hello\", \"there\"]);\n         t(\".hello.there\", '.', ~[\"\", \"hello\", \"there\"]);\n@@ -2067,7 +2067,7 @@ mod tests {\n             let v = splitn_char(s, c, n);\n             #debug(\"split_byte to: %?\", v);\n             #debug(\"comparing vs. %?\", u);\n-            assert vec::all2(v, u, { |a,b| a == b });\n+            assert vec::all2(v, u, |a,b| a == b);\n         }\n         t(\"abc.hello.there\", '.', 0u, ~[\"abc.hello.there\"]);\n         t(\"abc.hello.there\", '.', 1u, ~[\"abc\", \"hello.there\"]);\n@@ -2149,17 +2149,17 @@ mod tests {\n     fn test_split() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         assert ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n-            == split (data, {|cc| cc == '\u534e'});\n+            == split (data, |cc| cc == '\u534e');\n \n         assert ~[\"\", \"\", \"XXX\", \"YYY\", \"\"]\n             == split(\"zzXXXzYYYz\", char::is_lowercase);\n \n         assert ~[\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]\n             == split(\"zzXXXzYYYz\", char::is_uppercase);\n \n-        assert ~[\"\",\"\"] == split(\"z\", {|cc| cc == 'z'});\n-        assert ~[\"\"] == split(\"\", {|cc| cc == 'z'});\n-        assert ~[\"ok\"] == split(\"ok\", {|cc| cc == 'z'});\n+        assert ~[\"\",\"\"] == split(\"z\", |cc| cc == 'z');\n+        assert ~[\"\"] == split(\"\", |cc| cc == 'z');\n+        assert ~[\"ok\"] == split(\"ok\", |cc| cc == 'z');\n     }\n \n     #[test]\n@@ -2284,9 +2284,9 @@ mod tests {\n \n     #[test]\n     fn test_to_lower() {\n-        assert \"\" == map(\"\", {|c| libc::tolower(c as c_char) as char});\n+        assert \"\" == map(\"\", |c| libc::tolower(c as c_char) as char);\n         assert \"ymca\" == map(\"YMCA\",\n-                             {|c| libc::tolower(c as c_char) as char});\n+                             |c| libc::tolower(c as c_char) as char);\n     }\n \n     #[test]\n@@ -2574,13 +2574,13 @@ mod tests {\n     #[should_fail]\n     fn test_as_bytes_fail() {\n         // Don't double free\n-        do as_bytes(\"\") {|_bytes| fail }\n+        as_bytes::<()>(\"\", |_bytes| fail );\n     }\n \n     #[test]\n     fn test_as_buf() {\n         let a = \"Abcdefg\";\n-        let b = as_buf(a, {|buf|\n+        let b = as_buf(a, |buf| {\n             assert unsafe { *buf } == 65u8;\n             100\n         });\n@@ -2590,7 +2590,7 @@ mod tests {\n     #[test]\n     fn test_as_buf_small() {\n         let a = \"A\";\n-        let b = as_buf(a, {|buf|\n+        let b = as_buf(a, |buf| {\n             assert unsafe { *buf } == 65u8;\n             100\n         });\n@@ -2601,7 +2601,7 @@ mod tests {\n     fn test_as_buf2() {\n         unsafe {\n             let s = \"hello\";\n-            let sb = as_buf(s, {|b| b });\n+            let sb = as_buf(s, |b| b);\n             let s_cstr = unsafe::from_buf(sb);\n             assert (eq(s_cstr, s));\n         }\n@@ -2647,7 +2647,7 @@ mod tests {\n     #[test]\n     fn test_chars_iter() {\n         let mut i = 0;\n-        do chars_iter(\"x\\u03c0y\") {|ch|\n+        do chars_iter(\"x\\u03c0y\") |ch| {\n             alt check i {\n               0 { assert ch == 'x'; }\n               1 { assert ch == '\\u03c0'; }\n@@ -2656,14 +2656,14 @@ mod tests {\n             i += 1;\n         }\n \n-        do chars_iter(\"\") {|_ch| fail; } // should not fail\n+        chars_iter(\"\", |_ch| fail ); // should not fail\n     }\n \n     #[test]\n     fn test_bytes_iter() {\n         let mut i = 0;\n \n-        do bytes_iter(\"xyz\") {|bb|\n+        do bytes_iter(\"xyz\") |bb| {\n             alt check i {\n               0 { assert bb == 'x' as u8; }\n               1 { assert bb == 'y' as u8; }\n@@ -2672,7 +2672,7 @@ mod tests {\n             i += 1;\n         }\n \n-        do bytes_iter(\"\") {|bb| assert bb == 0u8; }\n+        bytes_iter(\"\", |bb| assert bb == 0u8);\n     }\n \n     #[test]\n@@ -2681,7 +2681,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        do split_char_iter(data, ' ') {|xx|\n+        do split_char_iter(data, ' ') |xx| {\n             alt ii {\n               0 { assert \"\\nMary\" == xx; }\n               1 { assert \"had\"    == xx; }\n@@ -2699,7 +2699,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        do splitn_char_iter(data, ' ', 2u) {|xx|\n+        do splitn_char_iter(data, ' ', 2u) |xx| {\n             alt ii {\n               0 { assert \"\\nMary\" == xx; }\n               1 { assert \"had\"    == xx; }\n@@ -2716,7 +2716,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        do words_iter(data) {|ww|\n+        do words_iter(data) |ww| {\n             alt ii {\n               0 { assert \"Mary\"   == ww; }\n               1 { assert \"had\"    == ww; }\n@@ -2727,7 +2727,7 @@ mod tests {\n             ii += 1;\n         }\n \n-        do words_iter(\"\") {|_x| fail; } // should not fail\n+        words_iter(\"\", |_x| fail); // should not fail\n     }\n \n     #[test]\n@@ -2736,7 +2736,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        do lines_iter(lf) {|x|\n+        do lines_iter(lf) |x| {\n             alt ii {\n                 0 { assert \"\" == x; }\n                 1 { assert \"Mary had a little lamb\" == x; }\n@@ -2750,9 +2750,8 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        assert \"\" == map(\"\", {|c| libc::toupper(c as c_char) as char});\n-        assert \"YMCA\" == map(\"ymca\", {|c| libc::toupper(c as c_char)\n-              as char});\n+        assert \"\" == map(\"\", |c| libc::toupper(c as c_char) as char);\n+        assert \"YMCA\" == map(\"ymca\", |c| libc::toupper(c as c_char) as char);\n     }\n \n     #[test]\n@@ -2819,7 +2818,7 @@ mod tests {\n                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                0x000a_u16 ]) ];\n \n-        for vec::each(pairs) {|p|\n+        for vec::each(pairs) |p| {\n             let (s, u) = p;\n             assert to_utf16(s) == u;\n             assert from_utf16(u) == s;\n@@ -2832,7 +2831,7 @@ mod tests {\n     fn test_each_char() {\n         let s = \"abc\";\n         let mut found_b = false;\n-        for each_char(s) {|ch|\n+        for each_char(s) |ch| {\n             if ch == 'b' {\n                 found_b = true;\n                 break;\n@@ -2844,7 +2843,7 @@ mod tests {\n     #[test]\n     fn test_unpack_slice() {\n         let a = \"hello\";\n-        do unpack_slice(a) {|buf, len|\n+        do unpack_slice(a) |buf, len| {\n             unsafe {\n                 assert a[0] == 'h' as u8;\n                 assert *buf == 'h' as u8;"}, {"sha": "28ef48240ee07de61a9f966139e6082d5a2ad6af", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -183,16 +183,16 @@ mod tests {\n         let lock = arc::arc(create_lock());\n         let lock2 = arc::clone(&lock);\n \n-        do task::spawn {|move lock2|\n+        do task::spawn |move lock2| {\n             let lock = arc::get(&lock2);\n-            do (*lock).lock_cond {|c|\n+            do (*lock).lock_cond |c| {\n                 c.wait();\n             }\n         }\n \n         let mut signaled = false;\n         while !signaled {\n-            do (*arc::get(&lock)).lock_cond {|c|\n+            do (*arc::get(&lock)).lock_cond |c| {\n                 signaled = c.signal()\n             }\n         }"}, {"sha": "2d4c2b44226dc903b1dc6ae03b06861472e72698", "filename": "src/libcore/task.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -295,7 +295,7 @@ fn future_result(builder: builder) -> future::future<task_result> {\n         with get_opts(builder)\n     });\n \n-    do future::from_fn {||\n+    do future::from_fn || {\n         alt comm::recv(po) {\n           exit(_, result) { result }\n         }\n@@ -307,7 +307,7 @@ fn future_task(builder: builder) -> future::future<task> {\n \n     let mut po = comm::port();\n     let ch = comm::chan(po);\n-    do add_wrapper(builder) {|body|\n+    do add_wrapper(builder) |body| {\n         fn~() {\n             comm::send(ch, get_task());\n             body();\n@@ -342,7 +342,7 @@ fn run_listener<A:send>(-builder: builder,\n     let setup_po = comm::port();\n     let setup_ch = comm::chan(setup_po);\n \n-    do run(builder) {||\n+    do run(builder) || {\n         let po = comm::port();\n         let mut ch = comm::chan(po);\n         comm::send(setup_ch, ch);\n@@ -439,7 +439,7 @@ fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n     let mut builder = builder();\n     unsupervise(builder);\n     let result = future_result(builder);\n-    do run(builder) {||\n+    do run(builder) || {\n         comm::send(ch, f());\n     }\n     alt future::get(result) {\n@@ -540,7 +540,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n         };\n         assert !new_task.is_null();\n \n-        do option::iter(opts.notify_chan) {|c|\n+        do option::iter(opts.notify_chan) |c| {\n             // FIXME (#1087): Would like to do notification in Rust\n             rustrt::rust_task_config_notify(new_task, c);\n         }\n@@ -615,7 +615,7 @@ crust fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n     let map: task_local_map = unsafe::reinterpret_cast(map_ptr);\n-    for (*map).each {|entry|\n+    for (*map).each |entry| {\n         alt entry {\n             // Finaliser drops data. We drop the finaliser implicitly here.\n             some((_key, data, finalise_fn)) { finalise_fn(data); }\n@@ -657,10 +657,10 @@ unsafe fn key_to_key_value<T>(key: local_data_key<T>) -> *libc::c_void {\n unsafe fn local_data_lookup<T>(map: task_local_map, key: local_data_key<T>)\n         -> option<(uint, *libc::c_void, fn@(+*libc::c_void))> {\n     let key_value = key_to_key_value(key);\n-    let map_pos = (*map).position({|entry|\n+    let map_pos = (*map).position(|entry|\n         alt entry { some((k,_,_)) { k == key_value } none { false } }\n-    });\n-    do map_pos.map {|index|\n+    );\n+    do map_pos.map |index| {\n         // .get() is guaranteed because of \"none { false }\" above.\n         let (_, data_ptr, finaliser) = (*map)[index].get();\n         (index, data_ptr, finaliser)\n@@ -671,7 +671,7 @@ unsafe fn local_get_helper<T>(task: *rust_task, key: local_data_key<T>,\n                               do_pop: bool) -> option<@T> {\n     let map = get_task_local_map(task);\n     // Interpret our findings from the map\n-    do local_data_lookup(map, key).map {|result|\n+    do local_data_lookup(map, key).map |result| {\n         // A reference count magically appears on 'data' out of thin air.\n         // 'data' has the reference we originally stored it with. We either\n         // need to erase it from the map or artificially bump the count.\n@@ -718,7 +718,7 @@ unsafe fn local_set<T>(task: *rust_task, key: local_data_key<T>, -data: @T) {\n         }\n         none {\n             // Find an empty slot. If not, grow the vector.\n-            alt (*map).position({|x| x == none}) {\n+            alt (*map).position(|x| x == none) {\n                 some(empty_index) {\n                     (*map).set_elt(empty_index, new_entry);\n                 }\n@@ -799,7 +799,7 @@ native mod rustrt {\n fn test_spawn_raw_simple() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    do spawn_raw(default_task_opts()) {||\n+    do spawn_raw(default_task_opts()) || {\n         comm::send(ch, ());\n     }\n     comm::recv(po);\n@@ -812,7 +812,7 @@ fn test_spawn_raw_unsupervise() {\n         supervise: false\n         with default_task_opts()\n     };\n-    do spawn_raw(opts) {||\n+    do spawn_raw(opts) || {\n         fail;\n     }\n }\n@@ -829,7 +829,7 @@ fn test_spawn_raw_notify() {\n         notify_chan: some(notify_ch)\n         with default_task_opts()\n     };\n-    do spawn_raw(opts) {||\n+    do spawn_raw(opts) || {\n         comm::send(task_ch, get_task());\n     }\n     let task_ = comm::recv(task_po);\n@@ -840,7 +840,7 @@ fn test_spawn_raw_notify() {\n         notify_chan: some(notify_ch)\n         with default_task_opts()\n     };\n-    do spawn_raw(opts) {||\n+    do spawn_raw(opts) || {\n         comm::send(task_ch, get_task());\n         fail;\n     }\n@@ -853,7 +853,7 @@ fn test_run_basic() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n     let buildr = builder();\n-    do run(buildr) {||\n+    do run(buildr) || {\n         comm::send(ch, ());\n     }\n     comm::recv(po);\n@@ -864,13 +864,13 @@ fn test_add_wrapper() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n     let buildr = builder();\n-    do add_wrapper(buildr) {|body|\n+    do add_wrapper(buildr) |body| {\n         fn~() {\n             body();\n             comm::send(ch, ());\n         }\n     }\n-    do run(buildr) {||}\n+    do run(buildr) || { }\n     comm::recv(po);\n }\n \n@@ -879,13 +879,13 @@ fn test_add_wrapper() {\n fn test_future_result() {\n     let buildr = builder();\n     let result = future_result(buildr);\n-    do run(buildr) {||}\n+    do run(buildr) || { }\n     assert future::get(result) == success;\n \n     let buildr = builder();\n     let result = future_result(buildr);\n     unsupervise(buildr);\n-    do run(buildr) {|| fail }\n+    do run(buildr) || { fail }\n     assert future::get(result) == failure;\n }\n \n@@ -895,15 +895,15 @@ fn test_future_task() {\n     let ch = comm::chan(po);\n     let buildr = builder();\n     let task1 = future_task(buildr);\n-    do run(buildr) {|| comm::send(ch, get_task()) }\n+    do run(buildr) || { comm::send(ch, get_task()) }\n     assert future::get(task1) == comm::recv(po);\n }\n \n #[test]\n fn test_spawn_listiner_bidi() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    let ch = do spawn_listener {|po|\n+    let ch = do spawn_listener |po| {\n         // Now the child has a port called 'po' to read from and\n         // an environment-captured channel called 'ch'.\n         let res = comm::recv(po);\n@@ -918,7 +918,7 @@ fn test_spawn_listiner_bidi() {\n \n #[test]\n fn test_try_success() {\n-    alt do try {||\n+    alt do try || {\n         \"Success!\"\n     } {\n         result::ok(\"Success!\") { }\n@@ -929,7 +929,7 @@ fn test_try_success() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_try_fail() {\n-    alt do try {||\n+    alt do try || {\n         fail\n     } {\n         result::err(()) { }\n@@ -941,7 +941,7 @@ fn test_try_fail() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_spawn_sched_no_threads() {\n-    do spawn_sched(manual_threads(0u)) {|| };\n+    do spawn_sched(manual_threads(0u)) || { }\n }\n \n #[test]\n@@ -952,7 +952,7 @@ fn test_spawn_sched() {\n     fn f(i: int, ch: comm::chan<()>) {\n         let parent_sched_id = rustrt::rust_get_sched_id();\n \n-        do spawn_sched(single_threaded) {||\n+        do spawn_sched(single_threaded) || {\n             let child_sched_id = rustrt::rust_get_sched_id();\n             assert parent_sched_id != child_sched_id;\n \n@@ -973,9 +973,9 @@ fn test_spawn_sched_childs_on_same_sched() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n \n-    do spawn_sched(single_threaded) {||\n+    do spawn_sched(single_threaded) || {\n         let parent_sched_id = rustrt::rust_get_sched_id();\n-        do spawn {||\n+        do spawn || {\n             let child_sched_id = rustrt::rust_get_sched_id();\n             // This should be on the same scheduler\n             assert parent_sched_id == child_sched_id;\n@@ -1002,7 +1002,7 @@ fn test_spawn_sched_blocking() {\n \n     // Testing that a task in one scheduler can block in foreign code\n     // without affecting other schedulers\n-    do iter::repeat(20u) {||\n+    do iter::repeat(20u) || {\n \n         let start_po = comm::port();\n         let start_ch = comm::chan(start_po);\n@@ -1011,7 +1011,7 @@ fn test_spawn_sched_blocking() {\n \n         let lock = testrt::rust_dbg_lock_create();\n \n-        do spawn_sched(single_threaded) {||\n+        do spawn_sched(single_threaded) || {\n             testrt::rust_dbg_lock_lock(lock);\n \n             comm::send(start_ch, ());\n@@ -1038,7 +1038,7 @@ fn test_spawn_sched_blocking() {\n         let setup_ch = comm::chan(setup_po);\n         let parent_po = comm::port();\n         let parent_ch = comm::chan(parent_po);\n-        do spawn {||\n+        do spawn || {\n             let child_po = comm::port();\n             comm::send(setup_ch, comm::chan(child_po));\n             pingpong(child_po, parent_ch);\n@@ -1063,7 +1063,7 @@ fn avoid_copying_the_body(spawnfn: fn(+fn~())) {\n     let x = ~1;\n     let x_in_parent = ptr::addr_of(*x) as uint;\n \n-    do spawnfn {||\n+    do spawnfn || {\n         let x_in_child = ptr::addr_of(*x) as uint;\n         comm::send(ch, x_in_child);\n     }\n@@ -1079,7 +1079,7 @@ fn test_avoid_copying_the_body_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n-    do avoid_copying_the_body {|f|\n+    do avoid_copying_the_body |f| {\n         spawn_listener(fn~(move f, _po: comm::port<int>) {\n             f();\n         });\n@@ -1088,17 +1088,17 @@ fn test_avoid_copying_the_body_spawn_listener() {\n \n #[test]\n fn test_avoid_copying_the_body_run() {\n-    do avoid_copying_the_body {|f|\n+    do avoid_copying_the_body |f| {\n         let buildr = builder();\n-        do run(buildr) {||\n+        do run(buildr) || {\n             f();\n         }\n     }\n }\n \n #[test]\n fn test_avoid_copying_the_body_run_listener() {\n-    do avoid_copying_the_body {|f|\n+    do avoid_copying_the_body |f| {\n         let buildr = builder();\n         run_listener(buildr, fn~(move f, _po: comm::port<int>) {\n             f();\n@@ -1108,30 +1108,30 @@ fn test_avoid_copying_the_body_run_listener() {\n \n #[test]\n fn test_avoid_copying_the_body_try() {\n-    do avoid_copying_the_body {|f|\n-        do try {||\n+    do avoid_copying_the_body |f| {\n+        do try || {\n             f()\n         };\n     }\n }\n \n #[test]\n fn test_avoid_copying_the_body_future_task() {\n-    do avoid_copying_the_body {|f|\n+    do avoid_copying_the_body |f| {\n         let buildr = builder();\n         future_task(buildr);\n-        do run(buildr) {||\n+        do run(buildr) || {\n             f();\n         }\n     }\n }\n \n #[test]\n fn test_avoid_copying_the_body_unsupervise() {\n-    do avoid_copying_the_body {|f|\n+    do avoid_copying_the_body |f| {\n         let buildr = builder();\n         unsupervise(buildr);\n-        do run(buildr) {||\n+        do run(buildr) || {\n             f();\n         }\n     }\n@@ -1151,7 +1151,7 @@ fn test_osmain() {\n \n     let po = comm::port();\n     let ch = comm::chan(po);\n-    do run(buildr) {||\n+    do run(buildr) || {\n         comm::send(ch, ());\n     }\n     comm::recv(po);\n@@ -1166,20 +1166,20 @@ fn test_unkillable() {\n     let ch = po.chan();\n \n     // We want to do this after failing\n-    do spawn {||\n+    do spawn || {\n         iter::repeat(10u, yield);\n         ch.send(());\n     }\n \n-    do spawn {||\n+    do spawn || {\n         yield();\n         // We want to fail after the unkillable task\n         // blocks on recv\n         fail;\n     }\n \n     unsafe {\n-        do unkillable {||\n+        do unkillable || {\n             let p = ~0;\n             let pp: *uint = unsafe::transmute(p);\n \n@@ -1198,7 +1198,7 @@ fn test_unkillable() {\n fn test_tls_multitask() unsafe {\n     fn my_key(+_x: @str) { }\n     local_data_set(my_key, @\"parent data\");\n-    do task::spawn {||\n+    do task::spawn || {\n         assert local_data_get(my_key) == none; // TLS shouldn't carry over.\n         local_data_set(my_key, @\"child data\");\n         assert *(local_data_get(my_key).get()) == \"child data\";\n@@ -1230,13 +1230,13 @@ fn test_tls_pop() unsafe {\n #[test]\n fn test_tls_modify() unsafe {\n     fn my_key(+_x: @str) { }\n-    local_data_modify(my_key, {|data|\n+    local_data_modify(my_key, |data| {\n         alt data {\n             some(@val) { fail \"unwelcome value: \" + val }\n             none       { some(@\"first data\") }\n         }\n     });\n-    local_data_modify(my_key, {|data|\n+    local_data_modify(my_key, |data| {\n         alt data {\n             some(@\"first data\") { some(@\"next data\") }\n             some(@val)          { fail \"wrong value: \" + val }\n@@ -1254,7 +1254,7 @@ fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // something within a rust stack segment. Then a subsequent upcall (esp.\n     // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n     fn my_key(+_x: @str) { }\n-    do task::spawn {||\n+    do task::spawn || {\n         unsafe { local_data_set(my_key, @\"hax\"); }\n     }\n }\n@@ -1264,7 +1264,7 @@ fn test_tls_multiple_types() unsafe {\n     fn str_key(+_x: @str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n-    do task::spawn{||\n+    do task::spawn || {\n         local_data_set(str_key, @\"string data\");\n         local_data_set(box_key, @@());\n         local_data_set(int_key, @42);\n@@ -1276,7 +1276,7 @@ fn test_tls_overwrite_multiple_types() unsafe {\n     fn str_key(+_x: @str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n-    do task::spawn{||\n+    do task::spawn || {\n         local_data_set(str_key, @\"string data\");\n         local_data_set(int_key, @42);\n         // This could cause a segfault if overwriting-destruction is done with\n@@ -1294,7 +1294,7 @@ fn test_tls_cleanup_on_failure() unsafe {\n     fn int_key(+_x: @int) { }\n     local_data_set(str_key, @\"parent data\");\n     local_data_set(box_key, @@());\n-    do task::spawn{|| // spawn_linked\n+    do task::spawn || { // spawn_linked\n         local_data_set(str_key, @\"string data\");\n         local_data_set(box_key, @@());\n         local_data_set(int_key, @42);"}, {"sha": "359f5ea4a9cd864cc49b877bd93b513223e878e2", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -59,7 +59,7 @@ impl <A: to_str copy, B: to_str copy, C: to_str copy> of to_str for (A, B, C){\n impl <A: to_str> of to_str for ~[A] {\n     fn to_str() -> str {\n         let mut acc = \"[\", first = true;\n-        for vec::each(self) {|elt|\n+        for vec::each(self) |elt| {\n             if first { first = false; }\n             else { acc += \", \"; }\n             acc += elt.to_str();"}, {"sha": "7f4ffe97c014fa667e5a9e70fc125b7c02fdb6b0", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -131,8 +131,8 @@ Convert to a string in a given base\n Fails if `radix` < 2 or `radix` > 16\n \"]\n fn to_str(num: T, radix: uint) -> str {\n-    do to_str_bytes(false, num, radix) {|slice|\n-        do vec::unpack_slice(slice) {|p, len|\n+    do to_str_bytes(false, num, radix) |slice| {\n+        do vec::unpack_slice(slice) |p, len| {\n             unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }\n@@ -177,7 +177,7 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     // in-bounds, no extra cost.\n \n     unsafe {\n-        do vec::unpack_slice(buf) {|p, len|\n+        do vec::unpack_slice(buf) |p, len| {\n             let mp = p as *mut u8;\n             let mut i = len;\n             let mut n = num;"}, {"sha": "e95598a08c83fbff68d3dbed545da377d79193a0", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -103,12 +103,12 @@ type init_op<T> = fn(uint) -> T;\n \n #[doc = \"Returns true if a vector contains no elements\"]\n pure fn is_empty<T>(v: &[const T]) -> bool {\n-    unpack_const_slice(v, {|_p, len| len == 0u})\n+    unpack_const_slice(v, |_p, len| len == 0u)\n }\n \n #[doc = \"Returns true if a vector contains some elements\"]\n pure fn is_not_empty<T>(v: &[const T]) -> bool {\n-    unpack_const_slice(v, {|_p, len| len > 0u})\n+    unpack_const_slice(v, |_p, len| len > 0u)\n }\n \n #[doc = \"Returns true if two vectors have the same length\"]\n@@ -169,7 +169,7 @@ pure fn capacity<T>(&&v: ~[const T]) -> uint {\n #[doc = \"Returns the length of a vector\"]\n #[inline(always)]\n pure fn len<T>(&&v: &[const T]) -> uint {\n-    unpack_const_slice(v, { |_p, len| len})\n+    unpack_const_slice(v, |_p, len| len)\n }\n \n #[doc = \"\n@@ -266,7 +266,7 @@ pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n pure fn view<T: copy>(v: &[const T], start: uint, end: uint) -> &a.[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    do unpack_slice(v) {|p, _len|\n+    do unpack_slice(v) |p, _len| {\n         unsafe {\n             ::unsafe::reinterpret_cast(\n                 (ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n@@ -387,7 +387,7 @@ fn shift<T>(&v: ~[T]) -> T {\n             let vv = unsafe::to_ptr(vv);\n             rr <- *vv;\n \n-            for uint::range(1u, ln) {|i|\n+            for uint::range(1u, ln) |i| {\n                 let r <- *ptr::offset(vv, i);\n                 push(v, r);\n             }\n@@ -455,16 +455,14 @@ fn push_slow<T>(&v: ~[const T], +initval: T) {\n // Unchecked vector indexing\n #[inline(always)]\n unsafe fn ref<T: copy>(v: &[const T], i: uint) -> T {\n-    unpack_slice(v, {|p, _len|\n-        *ptr::offset(p, i)\n-    })\n+    unpack_slice(v, |p, _len| *ptr::offset(p, i))\n }\n \n #[inline(always)]\n fn push_all<T: copy>(&v: ~[const T], rhs: &[const T]) {\n     reserve(v, v.len() + rhs.len());\n \n-    for uint::range(0u, rhs.len()) {|i|\n+    for uint::range(0u, rhs.len()) |i| {\n         push(v, unsafe { ref(rhs, i) })\n     }\n }\n@@ -473,8 +471,8 @@ fn push_all<T: copy>(&v: ~[const T], rhs: &[const T]) {\n fn push_all_move<T>(&v: ~[const T], -rhs: ~[const T]) {\n     reserve(v, v.len() + rhs.len());\n     unsafe {\n-        do unpack_slice(rhs) {|p, len|\n-            for uint::range(0, len) {|i|\n+        do unpack_slice(rhs) |p, len| {\n+            for uint::range(0, len) |i| {\n                 let x <- *ptr::offset(p, i);\n                 push(v, x);\n             }\n@@ -578,7 +576,7 @@ Apply a function to each element of a vector and return the results\n pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n-    for each(v) {|elem| unsafe { push(result, f(elem)); } }\n+    for each(v) |elem| { unsafe { push(result, f(elem)); } }\n     ret result;\n }\n \n@@ -588,7 +586,7 @@ Apply a function to each element of a vector and return the results\n pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n-    for eachi(v) {|i, elem| unsafe { push(result, f(i, elem)); } }\n+    for eachi(v) |i, elem| { unsafe { push(result, f(i, elem)); } }\n     ret result;\n }\n \n@@ -598,7 +596,7 @@ of each result vector\n \"]\n pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) {|elem| unchecked{ push_all_move(result, f(elem)); } }\n+    for each(v) |elem| { unchecked{ push_all_move(result, f(elem)); } }\n     ret result;\n }\n \n@@ -627,7 +625,7 @@ the resulting vector.\n pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n-    for each(v) {|elem|\n+    for each(v) |elem| {\n         alt f(elem) {\n           none {/* no-op */ }\n           some(result_elem) { unsafe { push(result, result_elem); } }\n@@ -645,7 +643,7 @@ only those elements for which `f` returned true.\n \"]\n pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     let mut result = ~[];\n-    for each(v) {|elem|\n+    for each(v) |elem| {\n         if f(elem) { unsafe { push(result, elem); } }\n     }\n     ret result;\n@@ -658,7 +656,7 @@ Flattens a vector of vectors of T into a single vector of T.\n \"]\n pure fn concat<T: copy>(v: &[[T]/~]) -> ~[T] {\n     let mut r = ~[];\n-    for each(v) {|inner| unsafe { push_all(r, inner); } }\n+    for each(v) |inner| { unsafe { push_all(r, inner); } }\n     ret r;\n }\n \n@@ -668,7 +666,7 @@ Concatenate a vector of vectors, placing a given separator between each\n pure fn connect<T: copy>(v: &[[T]/~], sep: T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n-    for each(v) {|inner|\n+    for each(v) |inner| {\n         if first { first = false; } else { unsafe { push(r, sep); } }\n         unchecked { push_all(r, inner) };\n     }\n@@ -678,7 +676,7 @@ pure fn connect<T: copy>(v: &[[T]/~], sep: T) -> ~[T] {\n #[doc = \"Reduce a vector from left to right\"]\n pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n-    do iter(v) { |elt|\n+    do iter(v) |elt| {\n         accum = p(accum, elt);\n     }\n     ret accum;\n@@ -687,7 +685,7 @@ pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n #[doc = \"Reduce a vector from right to left\"]\n pure fn foldr<T, U: copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n-    do riter(v) { |elt|\n+    do riter(v) |elt| {\n         accum = p(elt, accum);\n     }\n     ret accum;\n@@ -699,7 +697,7 @@ Return true if a predicate matches any elements\n If the vector contains no elements then false is returned.\n \"]\n pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) {|elem| if f(elem) { ret true; } }\n+    for each(v) |elem| { if f(elem) { ret true; } }\n     ret false;\n }\n \n@@ -726,7 +724,7 @@ Return true if a predicate matches all elements\n If the vector contains no elements then true is returned.\n \"]\n pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) {|elem| if !f(elem) { ret false; } }\n+    for each(v) |elem| { if !f(elem) { ret false; } }\n     ret true;\n }\n \n@@ -736,7 +734,7 @@ Return true if a predicate matches all elements\n If the vector contains no elements then true is returned.\n \"]\n pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n-    for eachi(v) {|i, elem| if !f(i, elem) { ret false; } }\n+    for eachi(v) |i, elem| { if !f(i, elem) { ret false; } }\n     ret true;\n }\n \n@@ -756,14 +754,14 @@ pure fn all2<T, U>(v0: &[T], v1: &[U],\n \n #[doc = \"Return true if a vector contains an element with the given value\"]\n pure fn contains<T>(v: &[T], x: T) -> bool {\n-    for each(v) {|elt| if x == elt { ret true; } }\n+    for each(v) |elt| { if x == elt { ret true; } }\n     ret false;\n }\n \n #[doc = \"Returns the number of elements that are equal to a given value\"]\n pure fn count<T>(v: &[T], x: T) -> uint {\n     let mut cnt = 0u;\n-    for each(v) {|elt| if x == elt { cnt += 1u; } }\n+    for each(v) |elt| { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n@@ -787,7 +785,7 @@ is returned. If `f` matches no elements then none is returned.\n \"]\n pure fn find_between<T: copy>(v: &[T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> option<T> {\n-    option::map(position_between(v, start, end, f), { |i| v[i] })\n+    option::map(position_between(v, start, end, f), |i| v[i])\n }\n \n #[doc = \"\n@@ -810,12 +808,12 @@ the element is returned. If `f` matches no elements then none is returned.\n \"]\n pure fn rfind_between<T: copy>(v: &[T], start: uint, end: uint,\n                                f: fn(T) -> bool) -> option<T> {\n-    option::map(rposition_between(v, start, end, f), { |i| v[i] })\n+    option::map(rposition_between(v, start, end, f), |i| v[i])\n }\n \n #[doc = \"Find the first index containing a matching value\"]\n pure fn position_elem<T>(v: &[T], x: T) -> option<uint> {\n-    position(v, { |y| x == y })\n+    position(v, |y| x == y)\n }\n \n #[doc = \"\n@@ -847,7 +845,7 @@ pure fn position_between<T>(v: &[T], start: uint, end: uint,\n \n #[doc = \"Find the last index containing a matching value\"]\n pure fn rposition_elem<T>(v: &[T], x: T) -> option<uint> {\n-    rposition(v, { |y| x == y })\n+    rposition(v, |y| x == y)\n }\n \n #[doc = \"\n@@ -894,7 +892,7 @@ of the i-th tuple of the input vector.\n \"]\n pure fn unzip<T: copy, U: copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut as = ~[], bs = ~[];\n-    for each(v) {|p|\n+    for each(v) |p| {\n         let (a, b) = p;\n         unchecked {\n             vec::push(as, a);\n@@ -974,7 +972,7 @@ element's value.\n */\n #[inline(always)]\n pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n-    do unpack_slice(v) { |base_ptr, len|\n+    do unpack_slice(v) |base_ptr, len| {\n         assert start <= end;\n         assert end <= len;\n         unsafe {\n@@ -996,7 +994,7 @@ Return true to continue, false to break.\n \"]\n #[inline(always)]\n pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n-    do vec::unpack_slice(v) {|p, n|\n+    do vec::unpack_slice(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n         while n > 0u {\n@@ -1016,7 +1014,7 @@ Return true to continue, false to break.\n \"]\n #[inline(always)]\n pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n-    do vec::unpack_slice(v) {|p, n|\n+    do vec::unpack_slice(v) |p, n| {\n         let mut i = 0u;\n         let mut p = p;\n         while i < n {\n@@ -1039,7 +1037,7 @@ Both vectors must have the same length\n #[inline]\n fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n     assert len(v1) == len(v2);\n-    for uint::range(0u, len(v1)) {|i|\n+    for uint::range(0u, len(v1)) |i| {\n         f(v1[i], v2[i])\n     }\n }\n@@ -1064,7 +1062,7 @@ Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n \"]\n pure fn riter<T>(v: &[T], f: fn(T)) {\n-    riteri(v, { |_i, v| f(v) })\n+    riteri(v, |_i, v| f(v))\n }\n \n #[doc =\"\n@@ -1102,7 +1100,7 @@ pure fn permute<T: copy>(v: &[T], put: fn(~[T])) {\n             let mut rest = slice(v, 0u, i);\n             unchecked {\n                 push_all(rest, view(v, i+1u, ln));\n-                permute(rest, {|permutation|\n+                permute(rest, |permutation| {\n                     put(append(~[elt], permutation))\n                 })\n             }\n@@ -1114,7 +1112,7 @@ pure fn permute<T: copy>(v: &[T], put: fn(~[T])) {\n pure fn windowed<TT: copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     assert 1u <= nn;\n-    vec::iteri (xx, {|ii, _x|\n+    vec::iteri (xx, |ii, _x| {\n         let len = vec::len(xx);\n         if ii+nn <= len unchecked {\n             vec::push(ww, vec::slice(xx, ii, ii+nn));\n@@ -1130,11 +1128,11 @@ Allows for unsafe manipulation of vector contents, which is useful for native\n interop.\n \"]\n fn as_buf<E,T>(v: &[E], f: fn(*E) -> T) -> T {\n-    unpack_slice(v, { |buf, _len| f(buf) })\n+    unpack_slice(v, |buf, _len| f(buf))\n }\n \n fn as_mut_buf<E,T>(v: &[mut E], f: fn(*mut E) -> T) -> T {\n-    unpack_mut_slice(v, { |buf, _len| f(buf) })\n+    unpack_mut_slice(v, |buf, _len| f(buf))\n }\n \n #[doc = \"\n@@ -1474,7 +1472,7 @@ mod u8 {\n            it out. -- tjc */\n \n         let mut u: uint = 5381u;\n-        vec::iter(s, { |c| u *= 33u; u += c as uint; });\n+        vec::iter(s, |c| {u *= 33u; u += c as uint;});\n         ret u;\n     }\n }\n@@ -1841,21 +1839,21 @@ mod tests {\n     #[test]\n     fn test_iter_empty() {\n         let mut i = 0;\n-        iter::<int>(~[], { |_v| i += 1 });\n+        iter::<int>(~[], |_v| i += 1);\n         assert i == 0;\n     }\n \n     #[test]\n     fn test_iter_nonempty() {\n         let mut i = 0;\n-        iter(~[1, 2, 3], { |v| i += v });\n+        iter(~[1, 2, 3], |v| i += v);\n         assert i == 6;\n     }\n \n     #[test]\n     fn test_iteri() {\n         let mut i = 0;\n-        iteri(~[1, 2, 3], { |j, v|\n+        iteri(~[1, 2, 3], |j, v| {\n             if i == 0 { assert v == 1; }\n             assert j + 1u == v as uint;\n             i += v;\n@@ -1866,14 +1864,14 @@ mod tests {\n     #[test]\n     fn test_riter_empty() {\n         let mut i = 0;\n-        riter::<int>(~[], { |_v| i += 1 });\n+        riter::<int>(~[], |_v| i += 1);\n         assert i == 0;\n     }\n \n     #[test]\n     fn test_riter_nonempty() {\n         let mut i = 0;\n-        riter(~[1, 2, 3], { |v|\n+        riter(~[1, 2, 3], |v| {\n             if i == 0 { assert v == 3; }\n             i += v\n         });\n@@ -1883,7 +1881,7 @@ mod tests {\n     #[test]\n     fn test_riteri() {\n         let mut i = 0;\n-        riteri(~[0, 1, 2], { |j, v|\n+        riteri(~[0, 1, 2], |j, v| {\n             if i == 0 { assert v == 2; }\n             assert j == v as uint;\n             i += v;\n@@ -1896,19 +1894,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        permute(~[], {|v| vec::push(results, v); });\n+        permute(~[], |v| vec::push(results, v));\n         assert results == ~[~[]];\n \n         results = ~[];\n-        permute(~[7], {|v| results += ~[v]; });\n+        permute(~[7], |v| results += ~[v]);\n         assert results == ~[~[7]];\n \n         results = ~[];\n-        permute(~[1,1], {|v| results += ~[v]; });\n+        permute(~[1,1], |v| results += ~[v]);\n         assert results == ~[~[1,1],~[1,1]];\n \n         results = ~[];\n-        permute(~[5,2,0], {|v| results += ~[v]; });\n+        permute(~[5,2,0], |v| results += ~[v]);\n         assert results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]];\n     }"}, {"sha": "adc3a7969d62a6987dc953609cda362bf9c51cd1", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -45,7 +45,7 @@ fn process(v0: bitv, v1: bitv, op: fn(uint, uint) -> uint) -> bool {\n     assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n     let mut changed = false;\n-    for uint::range(0u, len) {|i|\n+    for uint::range(0u, len) |i| {\n         let w0 = v0.storage[i];\n         let w1 = v1.storage[i];\n         let w = op(w0, w1);\n@@ -89,7 +89,7 @@ fn assign(v0: bitv, v1: bitv) -> bool {\n fn clone(v: bitv) -> bitv {\n     let storage = vec::to_mut(vec::from_elem(v.nbits / uint_bits + 1u, 0u));\n     let len = vec::len(v.storage);\n-    for uint::range(0u, len) {|i| storage[i] = v.storage[i]; };\n+    for uint::range(0u, len) |i| { storage[i] = v.storage[i]; };\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n@@ -113,22 +113,22 @@ contain identical elements.\n fn equal(v0: bitv, v1: bitv) -> bool {\n     if v0.nbits != v1.nbits { ret false; }\n     let len = vec::len(v1.storage);\n-    for uint::iterate(0u, len) {|i|\n+    for uint::iterate(0u, len) |i| {\n         if v0.storage[i] != v1.storage[i] { ret false; }\n     }\n }\n \n #[doc = \"Set all bits to 0\"]\n #[inline(always)]\n-fn clear(v: bitv) { for each_storage(v) {|w| w = 0u } }\n+fn clear(v: bitv) { for each_storage(v) |w| { w = 0u } }\n \n #[doc = \"Set all bits to 1\"]\n #[inline(always)]\n-fn set_all(v: bitv) { for each_storage(v) {|w| w = !0u } }\n+fn set_all(v: bitv) { for each_storage(v) |w| { w = !0u } }\n \n #[doc = \"Invert all bits\"]\n #[inline(always)]\n-fn invert(v: bitv) { for each_storage(v) {|w| w = !w } }\n+fn invert(v: bitv) { for each_storage(v) |w| { w = !w } }\n \n #[doc = \"\n Calculate the difference between two bitvectors\n@@ -163,14 +163,14 @@ fn set(v: bitv, i: uint, x: bool) {\n \n #[doc = \"Returns true if all bits are 1\"]\n fn is_true(v: bitv) -> bool {\n-    for each(v) {|i| if !i { ret false; } }\n+    for each(v) |i| { if !i { ret false; } }\n     ret true;\n }\n \n \n #[doc = \"Returns true if all bits are 0\"]\n fn is_false(v: bitv) -> bool {\n-    for each(v) {|i| if i { ret false; } }\n+    for each(v) |i| { if i { ret false; } }\n     ret true;\n }\n \n@@ -184,7 +184,7 @@ Converts the bitvector to a vector of uint with the same length.\n Each uint in the resulting vector has either value 0u or 1u.\n \"]\n fn to_vec(v: bitv) -> ~[uint] {\n-    let sub = {|x|init_to_vec(v, x)};\n+    let sub = |x| init_to_vec(v, x);\n     ret vec::from_fn::<uint>(v.nbits, sub);\n }\n \n@@ -199,7 +199,7 @@ fn each(v: bitv, f: fn(bool) -> bool) {\n \n #[inline(always)]\n fn each_storage(v: bitv, op: fn(&uint) -> bool) {\n-    for uint::range(0u, vec::len(v.storage)) {|i|\n+    for uint::range(0u, vec::len(v.storage)) |i| {\n         let mut w = v.storage[i];\n         let b = !op(w);\n         v.storage[i] = w;\n@@ -215,7 +215,7 @@ is either '0' or '1'.\n \"]\n fn to_str(v: bitv) -> str {\n     let mut rs = \"\";\n-    for each(v) {|i| if i { rs += \"1\"; } else { rs += \"0\"; } }\n+    for each(v) |i| { if i { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n "}, {"sha": "02ed63981b960c3bf393d8165de673b382f573a1", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -140,7 +140,7 @@ mod tests {\n         assert mem as int != 0;\n \n         ret unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n-                                     {||free(mem)}) };\n+                                     ||free(mem)) };\n     }\n \n     #[test]"}, {"sha": "501a9dabc5ac5f1e9ca6c74d1fa35544b595208e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -57,7 +57,7 @@ fn create<T: copy>() -> t<T> {\n                 self.lo = self.elts.len() - 1u;\n             } else { self.lo -= 1u; }\n             if self.lo == self.hi {\n-                self.elts.swap({ |v| grow(self.nelts, oldlo, v) });\n+                self.elts.swap(|v| grow(self.nelts, oldlo, v));\n                 self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n@@ -66,7 +66,7 @@ fn create<T: copy>() -> t<T> {\n         }\n         fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap({ |v| grow(self.nelts, self.lo, v) });\n+                self.elts.swap(|v| grow(self.nelts, self.lo, v));\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }\n@@ -292,7 +292,7 @@ mod tests {\n                                     two(17, 42));\n \n         #debug(\"*** test parameterized: taggypar<int>\");\n-        let eq4: eqfn<taggypar<int>> = {|x,y|taggypareq::<int>(x, y)};\n+        let eq4: eqfn<taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n         test_parameterized::<taggypar<int>>(eq4, onepar::<int>(1),\n                                             twopar::<int>(1, 2),\n                                             threepar::<int>(1, 2, 3),"}, {"sha": "70d974f255f740fc29484ecc83ae6c312486c176", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -222,19 +222,19 @@ impl writer for writer {\n     }\n \n     fn wr_tagged_u64(tag_id: uint, v: u64) {\n-        do io::u64_to_be_bytes(v, 8u) {|v|\n+        do io::u64_to_be_bytes(v, 8u) |v| {\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_u32(tag_id: uint, v: u32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_u16(tag_id: uint, v: u16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n@@ -244,19 +244,19 @@ impl writer for writer {\n     }\n \n     fn wr_tagged_i64(tag_id: uint, v: i64) {\n-        do io::u64_to_be_bytes(v as u64, 8u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 8u) |v| {\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_i32(tag_id: uint, v: i32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_i16(tag_id: uint, v: i16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n@@ -355,7 +355,7 @@ impl serializer of serialization::serializer for ebml::writer {\n     fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n \n     fn emit_vec(len: uint, f: fn()) {\n-        do self.wr_tag(es_vec as uint) {||\n+        do self.wr_tag(es_vec as uint) || {\n             self._emit_tagged_uint(es_vec_len, len);\n             f()\n         }\n@@ -482,7 +482,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n         #debug[\"read_enum_variant()\"];\n         let idx = self._next_uint(es_enum_vid);\n         #debug[\"  idx=%u\", idx];\n-        do self.push_doc(self.next_doc(es_enum_body)) {||\n+        do self.push_doc(self.next_doc(es_enum_body)) || {\n             f(idx)\n         }\n     }\n@@ -494,7 +494,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n \n     fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n         #debug[\"read_vec()\"];\n-        do self.push_doc(self.next_doc(es_vec)) {||\n+        do self.push_doc(self.next_doc(es_vec)) || {\n             let len = self._next_uint(es_vec_len);\n             #debug[\"  len=%u\", len];\n             f(len)\n@@ -549,14 +549,14 @@ fn test_option_int() {\n     }\n \n     fn serialize_0<S: serialization::serializer>(s: S, v: option<int>) {\n-        do s.emit_enum(\"core::option::t\") {||\n+        do s.emit_enum(\"core::option::t\") || {\n             alt v {\n               none {\n-                s.emit_enum_variant(\"core::option::none\", 0u, 0u, {||});\n+                s.emit_enum_variant(\"core::option::none\", 0u, 0u, || { } );\n               }\n               some(v0) {\n-                do s.emit_enum_variant(\"core::option::some\", 1u, 1u) {||\n-                    s.emit_enum_variant_arg(0u, {|| serialize_1(s, v0) });\n+                do s.emit_enum_variant(\"core::option::some\", 1u, 1u) || {\n+                    s.emit_enum_variant_arg(0u, || serialize_1(s, v0));\n                 }\n               }\n             }\n@@ -568,12 +568,12 @@ fn test_option_int() {\n     }\n \n     fn deserialize_0<S: serialization::deserializer>(s: S) -> option<int> {\n-        do s.read_enum(\"core::option::t\") {||\n-            do s.read_enum_variant {|i|\n+        do s.read_enum(\"core::option::t\") || {\n+            do s.read_enum_variant |i| {\n                 alt check i {\n                   0u { none }\n                   1u {\n-                    let v0 = do s.read_enum_variant_arg(0u) {||\n+                    let v0 = do s.read_enum_variant_arg(0u) || {\n                         deserialize_1(s)\n                     };\n                     some(v0)"}, {"sha": "a82d131f516edc393242101babcc1c556e27d54d", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -145,7 +145,7 @@ fn name_str(nm: name) -> str {\n }\n \n fn find_opt(opts: ~[opt], nm: name) -> option<uint> {\n-    vec::position(opts, { |opt| opt.name == nm })\n+    vec::position(opts, |opt| opt.name == nm)\n }\n \n #[doc = \"\n@@ -228,7 +228,7 @@ fn getopts(args: ~[str], opts: ~[opt]) -> result unsafe {\n                 }\n             }\n             let mut name_pos = 0u;\n-            for vec::each(names) {|nm|\n+            for vec::each(names) |nm| {\n                 name_pos += 1u;\n                 let optid = alt find_opt(opts, nm) {\n                   some(id) { id }\n@@ -297,7 +297,7 @@ fn opt_present(m: match, nm: str) -> bool {\n \n #[doc = \"Returns true if any of several options were matched\"]\n fn opts_present(m: match, names: ~[str]) -> bool {\n-    for vec::each(names) {|nm|\n+    for vec::each(names) |nm| {\n         alt find_opt(m.opts, mkname(nm)) {\n           some(_) { ret true; }\n           _ { }\n@@ -323,7 +323,7 @@ Fails if the no option was provided from the given list, or if the no such\n option took an argument\n \"]\n fn opts_str(m: match, names: ~[str]) -> str {\n-    for vec::each(names) {|nm|\n+    for vec::each(names) |nm| {\n         alt opt_val(m, nm) {\n           val(s) { ret s }\n           _ {  }\n@@ -340,7 +340,7 @@ Used when an option accepts multiple values.\n \"]\n fn opt_strs(m: match, nm: str) -> ~[str] {\n     let mut acc: ~[str] = ~[];\n-    for vec::each(opt_vals(m, nm)) {|v|\n+    for vec::each(opt_vals(m, nm)) |v| {\n         alt v { val(s) { vec::push(acc, s); } _ { } }\n     }\n     ret acc;"}, {"sha": "859349d4170b7f277e69f9f55adce99f507f723b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -54,7 +54,7 @@ fn to_writer(wr: io::writer, j: json) {\n       list(v) {\n         wr.write_char('[');\n         let mut first = true;\n-        for (*v).each { |item|\n+        for (*v).each |item| {\n             if !first {\n                 wr.write_str(\", \");\n             }\n@@ -71,7 +71,7 @@ fn to_writer(wr: io::writer, j: json) {\n \n         wr.write_str(\"{ \");\n         let mut first = true;\n-        for d.each { |key, value|\n+        for d.each |key, value| {\n             if !first {\n                 wr.write_str(\", \");\n             }\n@@ -90,7 +90,7 @@ fn to_writer(wr: io::writer, j: json) {\n \n fn escape_str(s: str) -> str {\n     let mut escaped = \"\\\"\";\n-    do str::chars_iter(s) { |c|\n+    do str::chars_iter(s) |c| {\n         alt c {\n           '\"' { escaped += \"\\\\\\\"\"; }\n           '\\\\' { escaped += \"\\\\\\\\\"; }\n@@ -110,7 +110,7 @@ fn escape_str(s: str) -> str {\n \n #[doc = \"Serializes a json value into a string\"]\n fn to_str(j: json) -> str {\n-    io::with_str_writer({ |wr| to_writer(wr, j) })\n+    io::with_str_writer(|wr| to_writer(wr, j))\n }\n \n type parser = {\n@@ -186,7 +186,7 @@ impl parser for parser {\n     }\n \n     fn parse_ident(ident: str, value: json) -> result<json, error> {\n-        if str::all(ident, { |c| c == self.next_char() }) {\n+        if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             ok(value)\n         } else {\n@@ -487,7 +487,7 @@ fn eq(value0: json, value1: json) -> bool {\n       (dict(d0), dict(d1)) {\n           if d0.size() == d1.size() {\n               let mut equal = true;\n-              for d0.each { |k, v0|\n+              for d0.each |k, v0| {\n                   alt d1.find(k) {\n                     some(v1) {\n                         if !eq(v0, v1) { equal = false; } }\n@@ -598,13 +598,13 @@ impl <A: to_json copy, B: to_json copy, C: to_json copy>\n }\n \n impl <A: to_json> of to_json for ~[A] {\n-    fn to_json() -> json { list(@self.map({ |elt| elt.to_json() })) }\n+    fn to_json() -> json { list(@self.map(|elt| elt.to_json())) }\n }\n \n impl <A: to_json copy> of to_json for hashmap<str, A> {\n     fn to_json() -> json {\n         let d = map::str_hash();\n-        for self.each() { |key, value|\n+        for self.each() |key, value| {\n             d.insert(copy key, value.to_json());\n         }\n         dict(d)\n@@ -635,7 +635,7 @@ mod tests {\n     fn mk_dict(items: ~[(str, json)]) -> json {\n         let d = map::str_hash();\n \n-        do vec::iter(items) { |item|\n+        do vec::iter(items) |item| {\n             let (key, value) = copy item;\n             d.insert(key, value);\n         };"}, {"sha": "30df6432d0512da7b65047932d2e7e4740b149b0", "filename": "src/libstd/list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -11,7 +11,7 @@ enum list<T> {\n \n #[doc = \"Create a list from a vector\"]\n fn from_vec<T: copy>(v: ~[T]) -> @list<T> {\n-    vec::foldr(v, @nil::<T>, { |h, t| @cons(h, t) })\n+    vec::foldr(v, @nil::<T>, |h, t| @cons(h, t))\n }\n \n #[doc = \"\n@@ -29,7 +29,7 @@ accumulated result.\n \"]\n fn foldl<T: copy, U>(z: T, ls: @list<U>, f: fn(T, U) -> T) -> T {\n     let mut accum: T = z;\n-    do iter(ls) {|elt| accum = f(accum, elt);}\n+    do iter(ls) |elt| { accum = f(accum, elt);}\n     accum\n }\n \n@@ -55,7 +55,7 @@ fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n \n #[doc = \"Returns true if a list contains an element with the given value\"]\n fn has<T: copy>(ls: @list<T>, elt: T) -> bool {\n-    for each(ls) { |e|\n+    for each(ls) |e| {\n         if e == elt { ret true; }\n     }\n     ret false;\n@@ -77,7 +77,7 @@ pure fn is_not_empty<T: copy>(ls: @list<T>) -> bool {\n #[doc = \"Returns the length of a list\"]\n fn len<T>(ls: @list<T>) -> uint {\n     let mut count = 0u;\n-    iter(ls, {|_e| count += 1u;});\n+    iter(ls, |_e| count += 1u);\n     count\n }\n "}, {"sha": "6163f6154a1f5522b4ffe71ca7efbc2b6d33e210", "filename": "src/libstd/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -151,7 +151,7 @@ mod chained {\n             let n_old_chains = vec::len(self.chains);\n             let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n             let new_chains = chains(n_new_chains);\n-            for self.each_entry {|entry|\n+            for self.each_entry |entry| {\n                 let idx = entry.hash % n_new_chains;\n                 entry.next = new_chains[idx];\n                 new_chains[idx] = present(entry);\n@@ -256,14 +256,14 @@ mod chained {\n         }\n \n         fn each(blk: fn(K,V) -> bool) {\n-            for self.each_entry { |entry|\n+            for self.each_entry |entry| {\n                 if !blk(entry.key, copy entry.value) { break; }\n             }\n         }\n \n-        fn each_key(blk: fn(K) -> bool) { self.each({ |k, _v| blk(k)}) }\n+        fn each_key(blk: fn(K) -> bool) { self.each(|k, _v| blk(k)) }\n \n-        fn each_value(blk: fn(V) -> bool) { self.each({ |_k, v| blk(v)}) }\n+        fn each_value(blk: fn(V) -> bool) { self.each(|_k, v| blk(v)) }\n     }\n \n     fn chains<K,V>(nchains: uint) -> ~[mut chain<K,V>] {\n@@ -302,7 +302,7 @@ fn str_hash<V: copy>() -> hashmap<str, V> {\n \n #[doc = \"Construct a hashmap for boxed string keys\"]\n fn box_str_hash<V: copy>() -> hashmap<@str, V> {\n-    ret hashmap({|x: @str|str::hash(*x)}, {|x,y|str::eq(*x,*y)});\n+    ret hashmap(|x: @str| str::hash(*x), |x,y| str::eq(*x,*y));\n }\n \n #[doc = \"Construct a hashmap for byte string keys\"]\n@@ -332,7 +332,7 @@ Convert a set into a vector.\n \"]\n fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n     let mut v = ~[];\n-    do s.each_key() {|k|\n+    do s.each_key() |k| {\n         vec::push(v, k);\n         true\n     };\n@@ -343,7 +343,7 @@ fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n                                          items: ~[(K, V)]) -> hashmap<K, V> {\n     let map = hashmap(hasher, eqer);\n-    do vec::iter(items) { |item|\n+    do vec::iter(items) |item| {\n         let (key, value) = item;\n         map.insert(key, value);\n     }"}, {"sha": "d7bd7ed811a7b8c5f775fcf448fc18ff9fe08b4c", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -88,7 +88,7 @@ fn md4_str(msg: ~[u8]) -> str {\n         f(a); f(b); f(c); f(d);\n     }\n     let mut result = \"\";\n-    do app(a, b, c, d) {|u|\n+    do app(a, b, c, d) |u| {\n         let mut i = 0u32;\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;"}, {"sha": "f1e15dec6de411b29db7b2bbd5c51e0120aabe0d", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -66,7 +66,7 @@ j    Fails if the string is not a valid IPv4 address\n         }\n     }\n     fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n-        let parts = vec::map(str::split_char(ip, '.'), {|s|\n+        let parts = vec::map(str::split_char(ip, '.'), |s| {\n             alt uint::from_str(s) {\n               some(n) if n <= 255u { n }\n               _ { 256u }"}, {"sha": "c995e021f5fb6f8389ecf5340915818de5fa5266", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -48,7 +48,7 @@ class tcp_socket {\n        };\n        let close_data_ptr = ptr::addr_of(close_data);\n        let stream_handle_ptr = (*(self.socket_data)).stream_handle_ptr;\n-       do iotask::interact((*(self.socket_data)).iotask) {|loop_ptr|\n+        do iotask::interact((*(self.socket_data)).iotask) |loop_ptr| {\n           log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n             stream_handle_ptr, loop_ptr));\n            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -72,7 +72,7 @@ class tcp_conn_port {\n     let server_stream_ptr = ptr::addr_of((*conn_data_ptr).server_stream);\n     let stream_closed_po = (*(self.conn_data)).stream_closed_po;\n     let iotask = (*conn_data_ptr).iotask;\n-    do iotask::interact(iotask) {|loop_ptr|\n+      do iotask::interact(iotask) |loop_ptr| {\n         log(debug, #fmt(\"dtor for tcp_conn_port loop: %?\",\n                        loop_ptr));\n         uv::ll::close(server_stream_ptr, tcp_nl_close_cb);\n@@ -131,7 +131,7 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n     // we can send into the interact cb to be handled in libuv..\n     log(debug, #fmt(\"stream_handle_ptr outside interact %?\",\n         stream_handle_ptr));\n-    do iotask::interact(iotask) {|loop_ptr|\n+    do iotask::interact(iotask) |loop_ptr| {\n         log(debug, \"in interact cb for tcp client connect..\");\n         log(debug, #fmt(\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr));\n@@ -251,7 +251,7 @@ value as the `err` variant\n fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n     -> future<result::result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n-    do future_spawn {||\n+    do future_spawn || {\n         write_common_impl(socket_data_ptr, raw_write_data)\n     }\n }\n@@ -340,7 +340,7 @@ read attempt. Pass `0u` to wait indefinitely\n fn read_future(sock: tcp_socket, timeout_msecs: uint)\n     -> future<result::result<~[u8],tcp_err_data>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n-    do future_spawn {||\n+    do future_spawn || {\n         read_common_impl(socket_data, timeout_msecs)\n     }\n }\n@@ -387,7 +387,7 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n \n     let setup_po = comm::port::<option<tcp_err_data>>();\n     let setup_ch = comm::chan(setup_po);\n-    do iotask::interact(iotask) {|loop_ptr|\n+    do iotask::interact(iotask) |loop_ptr| {\n         let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n                                                    port);\n         alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n@@ -488,7 +488,7 @@ fn conn_recv_spawn(server_port: tcp_conn_port,\n     let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n     let iotask = (*(server_port.conn_data)).iotask;\n     let new_conn_result = comm::recv(new_conn_po);\n-    do task::spawn {||\n+    do task::spawn || {\n         let sock_create_result = alt new_conn_result {\n           ok(client_stream_ptr) {\n             conn_port_new_tcp_socket(client_stream_ptr, iotask)\n@@ -709,7 +709,7 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n \n     let setup_po = comm::port::<option<tcp_err_data>>();\n     let setup_ch = comm::chan(setup_po);\n-    do iotask::interact(iotask) {|loop_ptr|\n+    do iotask::interact(iotask) |loop_ptr| {\n         let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n                                                    port);\n         alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n@@ -755,7 +755,7 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n       none {\n         on_establish_cb(kill_ch);\n         let kill_result = comm::recv(kill_po);\n-        do iotask::interact(iotask) {|loop_ptr|\n+        do iotask::interact(iotask) |loop_ptr| {\n             log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n                             loop_ptr));\n             (*server_data_ptr).active = false;\n@@ -861,7 +861,7 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let stop_po = comm::port::<option<tcp_err_data>>();\n     let stop_ch = comm::chan(stop_po);\n-    do iotask::interact((*socket_data).iotask) {|loop_ptr|\n+    do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, \"in interact cb for tcp::read_stop\");\n         alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 {\n@@ -893,7 +893,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n     log(debug, \"in tcp::read_start before interact loop\");\n-    do iotask::interact((*socket_data).iotask) {|loop_ptr|\n+    do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n@@ -935,7 +935,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n         result_ch: comm::chan(result_po)\n     };\n     let write_data_ptr = ptr::addr_of(write_data);\n-    do iotask::interact((*socket_data_ptr).iotask) {|loop_ptr|\n+    do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| {\n         log(debug, #fmt(\"in interact cb for tcp::write %?\", loop_ptr));\n         alt uv::ll::write(write_req_ptr,\n                           stream_handle_ptr,\n@@ -979,8 +979,8 @@ fn conn_port_new_tcp_socket(\n         iotask : iotask\n     };\n     let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n-    do comm::listen {|cont_ch|\n-        do iotask::interact(iotask) {|loop_ptr|\n+    do comm::listen |cont_ch| {\n+        do iotask::interact(iotask) |loop_ptr| {\n             log(debug, #fmt(\"in interact cb 4 conn_port_new_tcp.. loop %?\",\n                 loop_ptr));\n             uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -1332,8 +1332,8 @@ mod test {\n         let cont_po = comm::port::<()>();\n         let cont_ch = comm::chan(cont_po);\n         // server\n-        do task::spawn_sched(task::manual_threads(1u)) {||\n-            let actual_req = do comm::listen {|server_ch|\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n+            let actual_req = do comm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n                     server_port,\n@@ -1347,7 +1347,7 @@ mod test {\n         comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = do comm::listen {|client_ch|\n+        let actual_resp = do comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1376,8 +1376,8 @@ mod test {\n         let cont_po = comm::port::<()>();\n         let cont_ch = comm::chan(cont_po);\n         // server\n-        do task::spawn_sched(task::manual_threads(1u)) {||\n-            let actual_req = do comm::listen {|server_ch|\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n+            let actual_req = do comm::listen |server_ch| {\n                 run_tcp_test_server_listener(\n                     server_ip,\n                     server_port,\n@@ -1391,7 +1391,7 @@ mod test {\n         comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = do comm::listen {|client_ch|\n+        let actual_resp = do comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1413,23 +1413,21 @@ mod test {\n                           cont_ch: comm::chan<()>,\n                           iotask: iotask) -> str {\n \n-        do task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let listen_result =\n                 listen_for_conn(server_ip_addr, server_port, 128u,\n-                iotask,\n-                // on_establish_cb -- called when listener is set up\n-                {|kill_ch|\n+                iotask, |kill_ch| {\n+                    // on_establish_cb -- called when listener is set up\n                     log(debug, #fmt(\"establish_cb %?\",\n                         kill_ch));\n                     comm::send(cont_ch, ());\n-                },\n+                }, |new_conn, kill_ch| {\n                 // risky to run this on the loop, but some users\n                 // will want the POWER\n-                {|new_conn, kill_ch|\n                 log(debug, \"SERVER: new connection!\");\n-                do comm::listen {|cont_ch|\n-                    do task::spawn_sched(task::manual_threads(1u)) {||\n+                    do comm::listen |cont_ch| {\n+                        do task::spawn_sched(task::manual_threads(1u)) || {\n                         log(debug, \"SERVER: starting worker for new req\");\n \n                         let accept_result = accept(new_conn);\n@@ -1492,7 +1490,7 @@ mod test {\n                                     cont_ch: comm::chan<()>,\n                                     iotask: iotask) -> str {\n \n-        do task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let new_listener_result =\n                 new_listener(server_ip_addr, server_port, 128u, iotask);"}, {"sha": "3447d55827affabbeddb8f2ee476a564d46378cd", "filename": "src/libstd/par.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -41,9 +41,9 @@ fn map_slices<A: copy send, B: copy send>(\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n             // FIXME: why is the ::<A, ()> annotation required here? (#2617)\n-            do vec::unpack_slice::<A, ()>(xs) {|p, _len|\n+            do vec::unpack_slice::<A, ()>(xs) |p, _len| {\n                 let f = f();\n-                let f = do future_spawn() {|copy base|\n+                let f = do future_spawn() |copy base| {\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n@@ -66,7 +66,7 @@ fn map_slices<A: copy send, B: copy send>(\n         log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n         assert(num_tasks == futures.len());\n \n-        let r = do futures.map() {|ys|\n+        let r = do futures.map() |ys| {\n             ys.get()\n         };\n         assert(r.len() == futures.len());\n@@ -76,7 +76,7 @@ fn map_slices<A: copy send, B: copy send>(\n \n #[doc=\"A parallel version of map.\"]\n fn map<A: copy send, B: copy send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n-    vec::concat(map_slices(xs, {||\n+    vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::map(slice, f)\n         }\n@@ -86,9 +86,9 @@ fn map<A: copy send, B: copy send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n #[doc=\"A parallel version of mapi.\"]\n fn mapi<A: copy send, B: copy send>(xs: ~[A],\n                                     f: fn~(uint, A) -> B) -> ~[B] {\n-    let slices = map_slices(xs, {||\n+    let slices = map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n-            vec::mapi(slice, {|i, x|\n+            vec::mapi(slice, |i, x| {\n                 f(i + base, x)\n             })\n         }\n@@ -105,10 +105,10 @@ In this case, f is a function that creates functions to run over the\n inner elements. This is to skirt the need for copy constructors.\"]\n fn mapi_factory<A: copy send, B: copy send>(\n     xs: ~[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n-    let slices = map_slices(xs, {||\n+    let slices = map_slices(xs, || {\n         let f = f();\n         fn~(base: uint, slice : &[A], move f) -> ~[B] {\n-            vec::mapi(slice, {|i, x|\n+            vec::mapi(slice, |i, x| {\n                 f(i + base, x)\n             })\n         }\n@@ -121,20 +121,20 @@ fn mapi_factory<A: copy send, B: copy send>(\n \n #[doc=\"Returns true if the function holds for all elements in the vector.\"]\n fn alli<A: copy send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n-    do vec::all(map_slices(xs, {||\n+    do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n-            vec::alli(slice, {|i, x|\n+            vec::alli(slice, |i, x| {\n                 f(i + base, x)\n             })\n         }\n-    })) {|x| x }\n+    })) |x| { x }\n }\n \n #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n fn any<A: copy send>(xs: ~[A], f: fn~(A) -> bool) -> bool {\n-    do vec::any(map_slices(xs, {||\n+    do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, f)\n         }\n-    })) {|x| x }\n+    })) |x| { x }\n }"}, {"sha": "a7d54daba9a3deef0d23047e3330761a10e45523", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -158,13 +158,13 @@ fn concat(v: ~[rope]) -> rope {\n     let mut len = vec::len(v);\n     if len == 0u { ret node::empty; }\n     let ropes = vec::to_mut(vec::from_elem(len, v[0]));\n-    for uint::range(1u, len) {|i|\n+    for uint::range(1u, len) |i| {\n        ropes[i] = v[i];\n     }\n \n     //Merge progresively\n     while len > 1u {\n-        for uint::range(0u, len/2u) {|i|\n+        for uint::range(0u, len/2u) |i| {\n             ropes[i] = append_rope(ropes[2u*i], ropes[2u*i+1u]);\n         }\n         if len%2u != 0u {\n@@ -397,7 +397,7 @@ Loop through a rope, char by char, until the end.\n * it - A block to execute with each consecutive character of the rope.\n \"]\n fn iter_chars(rope: rope, it: fn(char)) {\n-    do loop_chars(rope) {|x|\n+    do loop_chars(rope) |x| {\n         it(x);\n         true\n     };\n@@ -1038,11 +1038,11 @@ mod node {\n     }\n \n     fn loop_chars(node: @node, it: fn(char) -> bool) -> bool {\n-        ret loop_leaves(node, {|leaf|\n+        ret loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,\n                              leaf.byte_len, it)\n-        })\n+        });\n     }\n \n     #[doc =\"\n@@ -1350,19 +1350,19 @@ mod tests {\n     fn char_at1() {\n         //Generate a large rope\n         let mut r = of_str(@ \"123456789\");\n-        for uint::range(0u, 10u){|_i|\n+        for uint::range(0u, 10u) |_i| {\n             r = append_rope(r, r);\n         }\n \n         //Copy it in the slowest possible way\n         let mut r2 = empty();\n-        for uint::range(0u, char_len(r)){|i|\n+        for uint::range(0u, char_len(r)) |i| {\n             r2 = append_char(r2, char_at(r, i));\n         }\n         assert eq(r, r2);\n \n         let mut r3 = empty();\n-        for uint::range(0u, char_len(r)){|i|\n+        for uint::range(0u, char_len(r)) |i| {\n             r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n         }\n         assert eq(r, r3);\n@@ -1383,7 +1383,7 @@ mod tests {\n         //Generate a reasonable rope\n         let chunk = of_str(@ \"123456789\");\n         let mut r = empty();\n-        for uint::range(0u, 10u){|_i|\n+        for uint::range(0u, 10u) |_i| {\n             r = append_rope(r, chunk);\n         }\n "}, {"sha": "a5d56bda0efe79e08daf622d98ba7410cccae4ab", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -84,19 +84,19 @@ iface deserializer {\n // In some cases, these should eventually be coded as traits.\n \n fn emit_from_vec<S: serializer, T>(s: S, v: ~[T], f: fn(T)) {\n-    do s.emit_vec(vec::len(v)) {||\n-        do vec::iteri(v) {|i,e|\n-            do s.emit_vec_elt(i) {||\n+    do s.emit_vec(vec::len(v)) || {\n+        do vec::iteri(v) |i,e| {\n+            do s.emit_vec_elt(i) || {\n                 f(e)\n             }\n         }\n     }\n }\n \n fn read_to_vec<D: deserializer, T: copy>(d: D, f: fn() -> T) -> ~[T] {\n-    do d.read_vec {|len|\n-        do vec::from_fn(len) {|i|\n-            do d.read_vec_elt(i) {|| f() }\n+    do d.read_vec |len| {\n+        do vec::from_fn(len) |i| {\n+            d.read_vec_elt(i, || f())\n         }\n     }\n }\n@@ -234,16 +234,16 @@ fn deserialize_bool<D: deserializer>(d: D) -> bool {\n }\n \n fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n-    do s.emit_enum(\"option\") {||\n+    do s.emit_enum(\"option\") || {\n         alt v {\n           none {\n-            do s.emit_enum_variant(\"none\", 0u, 0u) {||\n+            do s.emit_enum_variant(\"none\", 0u, 0u) || {\n             }\n           }\n \n           some(v) {\n-            do s.emit_enum_variant(\"some\", 1u, 1u) {||\n-                do s.emit_enum_variant_arg(0u) {||\n+            do s.emit_enum_variant(\"some\", 1u, 1u) || {\n+                do s.emit_enum_variant_arg(0u) || {\n                     st(v)\n                 }\n             }\n@@ -254,14 +254,14 @@ fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n \n fn deserialize_option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n     -> option<T> {\n-    do d.read_enum(\"option\") {||\n-        do d.read_enum_variant {|i|\n+    do d.read_enum(\"option\") || {\n+        do d.read_enum_variant |i| {\n             alt check i {\n               0u { // none\n                 none\n               }\n               1u { // some(v)\n-                some(d.read_enum_variant_arg(0u, {||\n+                some(d.read_enum_variant_arg(0u, || {\n                     st()\n                 }))\n               }"}, {"sha": "6aed645283db163adf330d1b5759274c631fc02a", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -63,7 +63,7 @@ fn sha1() -> sha1 {\n     fn add_input(st: sha1state, msg: ~[u8]) {\n         /* FIXME: Should be typestate precondition (#2345) */\n         assert (!st.computed);\n-        for vec::each(msg) {|element|\n+        for vec::each(msg) |element| {\n             st.msg_block[st.msg_block_idx] = element;\n             st.msg_block_idx += 1u;\n             st.len_low += 8u32;\n@@ -160,7 +160,7 @@ fn sha1() -> sha1 {\n     fn mk_result(st: sha1state) -> ~[u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n         let mut rs: ~[u8] = ~[];\n-        for vec::each(st.h) {|hpart|\n+        for vec::each(st.h) |hpart| {\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n             let c = (hpart >> 8u32 & 0xFFu32) as u8;\n@@ -237,7 +237,7 @@ fn sha1() -> sha1 {\n         fn result_str() -> str {\n             let r = mk_result(self);\n             let mut s = \"\";\n-            for vec::each(r) {|b| s += uint::to_str(b as uint, 16u); }\n+            for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n             ret s;\n         }\n     }\n@@ -326,7 +326,7 @@ mod tests {\n         // Test that it works when accepting the message all at once\n \n         let sh = sha1::sha1();\n-        for vec::each(tests) {|t|\n+        for vec::each(tests) |t| {\n             sh.input_str(t.input);\n             let out = sh.result();\n             check_vec_eq(t.output, out);\n@@ -335,7 +335,7 @@ mod tests {\n \n \n         // Test that it works when accepting the message in pieces\n-        for vec::each(tests) {|t|\n+        for vec::each(tests) |t| {\n             let len = str::len(t.input);\n             let mut left = len;\n             while left > 0u {"}, {"sha": "6583d97908d3eefd454c09fad6655d175d8b682a", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -58,7 +58,7 @@ fn contains_key<T: copy>(self: smallintmap<T>, key: uint) -> bool {\n impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn size() -> uint {\n         let mut sz = 0u;\n-        for self.v.each {|item|\n+        for self.v.each |item| {\n             alt item { some(_) { sz += 1u; } _ {} }\n         }\n         sz\n@@ -102,7 +102,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         }\n     }\n     fn each_value(it: fn(V) -> bool) {\n-        self.each({|_i, v| it(v)});\n+        self.each(|_i, v| it(v));\n     }\n }\n "}, {"sha": "7de8f0cfab830c27a78995f8b563b9d1399fe03c", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -155,7 +155,7 @@ This is an unstable sort.\n \"]\n fn quick_sort3<T: copy ord eq>(arr: ~[mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n-    qsort3::<T>({ |x, y| x.lt(y) }, { |x, y| x.eq(y) }, arr, 0,\n+    qsort3::<T>(|x, y| x.lt(y), |x, y| x.eq(y), arr, 0,\n                 (len::<T>(arr) as int) - 1);\n }\n \n@@ -251,7 +251,7 @@ mod test_qsort {\n         let immut_names = vec::from_mut(names);\n \n         let pairs = vec::zip(expected, immut_names);\n-        for vec::each(pairs) {|p|\n+        for vec::each(pairs) |p| {\n             let (a, b) = p;\n             #debug(\"%d %d\", a, b);\n             assert (a == b);"}, {"sha": "43e1765f50b3deafb1e794c318743634fab29a98", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -37,7 +37,7 @@ fn color_supported() -> bool {\n                            \"screen-bce\", \"xterm-256color\"];\n     ret alt os::getenv(\"TERM\") {\n           option::some(env) {\n-            for vec::each(supported_terms) {|term|\n+            for vec::each(supported_terms) |term| {\n                 if str::eq(term, env) { ret true; }\n             }\n             false"}, {"sha": "42ff9f6366a0cf50f41313d4c6c2335f2fd823bb", "filename": "src/libstd/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -162,7 +162,7 @@ fn run_tests_console(opts: test_opts,\n           mut ignored: 0u,\n           mut failures: ~[]};\n \n-    run_tests(opts, tests, {|x|callback(x, st)});\n+    run_tests(opts, tests, |x| callback(x, st));\n \n     assert (st.passed + st.failed + st.ignored == st.total);\n     let success = st.failed == 0u;\n@@ -216,9 +216,9 @@ fn run_tests_console(opts: test_opts,\n fn print_failures(st: console_test_state) {\n     st.out.write_line(\"\\nfailures:\");\n     let failures = copy st.failures;\n-    let failures = vec::map(failures, {|test| test.name});\n+    let failures = vec::map(failures, |test| test.name);\n     let failures = sort::merge_sort(str::le, failures);\n-    for vec::each(failures) {|name|\n+    for vec::each(failures) |name| {\n         st.out.write_line(#fmt[\"    %s\", name]);\n     }\n }\n@@ -349,7 +349,7 @@ fn filter_tests(opts: test_opts,\n             } else { ret option::none; }\n         }\n \n-        let filter = {|x|filter_fn(x, filter_str)};\n+        let filter = |x| filter_fn(x, filter_str);\n \n         vec::filter_map(filtered, filter)\n     };\n@@ -367,7 +367,7 @@ fn filter_tests(opts: test_opts,\n             } else { ret option::none; }\n         };\n \n-        vec::filter_map(filtered, {|x|filter(x)})\n+        vec::filter_map(filtered, |x| filter(x))\n     };\n \n     // Sort the tests alphabetically\n@@ -376,7 +376,7 @@ fn filter_tests(opts: test_opts,\n             fn lteq(t1: test_desc, t2: test_desc) -> bool {\n                 str::le(t1.name, t2.name)\n             }\n-        sort::merge_sort({|x,y|lteq(x, y)}, filtered)\n+        sort::merge_sort(|x,y| lteq(x, y), filtered)\n         };\n \n     ret filtered;\n@@ -390,7 +390,7 @@ fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n         ret;\n     }\n \n-    do task::spawn {||\n+    do task::spawn || {\n         let testfn = copy test.fn;\n         let mut builder = task::builder();\n         let result_future = task::future_result(builder);\n@@ -529,7 +529,7 @@ mod tests {\n         {\n         let testfn = fn~() { };\n         let mut tests = ~[];\n-        for vec::each(names) {|name|\n+            for vec::each(names) |name| {\n             let test = {name: name, fn: copy testfn, ignore: false,\n                         should_fail: false};\n             tests += ~[test];\n@@ -547,7 +547,7 @@ mod tests {\n \n     let pairs = vec::zip(expected, filtered);\n \n-    for vec::each(pairs) {|p| let (a, b) = copy p; assert (a == b.name); }\n+    for vec::each(pairs) |p| { let (a, b) = copy p; assert (a == b.name); }\n }\n }\n "}, {"sha": "fa1597925bd25e52a7996d444bb974d12a7e8207", "filename": "src/libstd/time.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -142,7 +142,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n \n     fn match_str(s: str, pos: uint, needle: str) -> bool {\n         let mut i = pos;\n-        for str::each(needle) {|ch|\n+        for str::each(needle) |ch| {\n             if s[i] != ch {\n                 ret false;\n             }\n@@ -283,21 +283,21 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'c' {\n             parse_type(s, pos, 'a', tm)\n-                .chain({ |pos| parse_char(s, pos, ' ') })\n-                .chain({ |pos| parse_type(s, pos, 'b', tm) })\n-                .chain({ |pos| parse_char(s, pos, ' ') })\n-                .chain({ |pos| parse_type(s, pos, 'e', tm) })\n-                .chain({ |pos| parse_char(s, pos, ' ') })\n-                .chain({ |pos| parse_type(s, pos, 'T', tm) })\n-                .chain({ |pos| parse_char(s, pos, ' ') })\n-                .chain({ |pos| parse_type(s, pos, 'Y', tm) })\n+                .chain(|pos| parse_char(s, pos, ' '))\n+                .chain(|pos| parse_type(s, pos, 'b', tm))\n+                .chain(|pos| parse_char(s, pos, ' '))\n+                .chain(|pos| parse_type(s, pos, 'e', tm))\n+                .chain(|pos| parse_char(s, pos, ' '))\n+                .chain(|pos| parse_type(s, pos, 'T', tm))\n+                .chain(|pos| parse_char(s, pos, ' '))\n+                .chain(|pos| parse_type(s, pos, 'Y', tm))\n           }\n           'D' | 'x' {\n             parse_type(s, pos, 'm', tm)\n-                .chain({ |pos| parse_char(s, pos, '/') })\n-                .chain({ |pos| parse_type(s, pos, 'd', tm) })\n-                .chain({ |pos| parse_char(s, pos, '/') })\n-                .chain({ |pos| parse_type(s, pos, 'y', tm) })\n+                .chain(|pos| parse_char(s, pos, '/'))\n+                .chain(|pos| parse_type(s, pos, 'd', tm))\n+                .chain(|pos| parse_char(s, pos, '/'))\n+                .chain(|pos| parse_type(s, pos, 'y', tm))\n           }\n           'd' {\n             alt match_digits(s, pos, 2u, false) {\n@@ -313,10 +313,10 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'F' {\n             parse_type(s, pos, 'Y', tm)\n-                .chain({ |pos| parse_char(s, pos, '-') })\n-                .chain({ |pos| parse_type(s, pos, 'm', tm) })\n-                .chain({ |pos| parse_char(s, pos, '-') })\n-                .chain({ |pos| parse_type(s, pos, 'd', tm) })\n+                .chain(|pos| parse_char(s, pos, '-'))\n+                .chain(|pos| parse_type(s, pos, 'm', tm))\n+                .chain(|pos| parse_char(s, pos, '-'))\n+                .chain(|pos| parse_type(s, pos, 'd', tm))\n           }\n           'H' {\n             // FIXME (#2350): range check.\n@@ -398,17 +398,17 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'R' {\n             parse_type(s, pos, 'H', tm)\n-                .chain({ |pos| parse_char(s, pos, ':') })\n-                .chain({ |pos| parse_type(s, pos, 'M', tm) })\n+                .chain(|pos| parse_char(s, pos, ':'))\n+                .chain(|pos| parse_type(s, pos, 'M', tm))\n           }\n           'r' {\n             parse_type(s, pos, 'I', tm)\n-                .chain({ |pos| parse_char(s, pos, ':') })\n-                .chain({ |pos| parse_type(s, pos, 'M', tm) })\n-                .chain({ |pos| parse_char(s, pos, ':') })\n-                .chain({ |pos| parse_type(s, pos, 'S', tm) })\n-                .chain({ |pos| parse_char(s, pos, ' ') })\n-                .chain({ |pos| parse_type(s, pos, 'p', tm) })\n+                .chain(|pos| parse_char(s, pos, ':'))\n+                .chain(|pos| parse_type(s, pos, 'M', tm))\n+                .chain(|pos| parse_char(s, pos, ':'))\n+                .chain(|pos| parse_type(s, pos, 'S', tm))\n+                .chain(|pos| parse_char(s, pos, ' '))\n+                .chain(|pos| parse_type(s, pos, 'p', tm))\n           }\n           'S' {\n             // FIXME (#2350): range check.\n@@ -424,10 +424,10 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           //'s' {}\n           'T' | 'X' {\n             parse_type(s, pos, 'H', tm)\n-                .chain({ |pos| parse_char(s, pos, ':') })\n-                .chain({ |pos| parse_type(s, pos, 'M', tm) })\n-                .chain({ |pos| parse_char(s, pos, ':') })\n-                .chain({ |pos| parse_type(s, pos, 'S', tm) })\n+                .chain(|pos| parse_char(s, pos, ':'))\n+                .chain(|pos| parse_type(s, pos, 'M', tm))\n+                .chain(|pos| parse_char(s, pos, ':'))\n+                .chain(|pos| parse_type(s, pos, 'S', tm))\n           }\n           't' { parse_char(s, pos, '\\t') }\n           'u' {\n@@ -443,10 +443,10 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'v' {\n             parse_type(s, pos, 'e', tm)\n-                .chain({ |pos| parse_char(s, pos, '-') })\n-                .chain({ |pos| parse_type(s, pos, 'b', tm) })\n-                .chain({ |pos| parse_char(s, pos, '-') })\n-                .chain({ |pos| parse_type(s, pos, 'Y', tm) })\n+                .chain(|pos| parse_char(s, pos, '-'))\n+                .chain(|pos| parse_type(s, pos, 'b', tm))\n+                .chain(|pos| parse_char(s, pos, '-'))\n+                .chain(|pos| parse_type(s, pos, 'Y', tm))\n           }\n           //'W' {}\n           'w' {\n@@ -526,7 +526,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n         }\n     }\n \n-    do io::with_str_reader(format) { |rdr|\n+    do io::with_str_reader(format) |rdr| {\n         let tm = {\n             mut tm_sec: 0_i32,\n             mut tm_min: 0_i32,\n@@ -738,7 +738,7 @@ fn strftime(format: str, tm: tm) -> str {\n \n     let mut buf = \"\";\n \n-    do io::with_str_reader(format) { |rdr|\n+    do io::with_str_reader(format) |rdr| {\n         while !rdr.eof() {\n             alt rdr.read_char() {\n                 '%' { buf += parse_type(rdr.read_char(), tm); }\n@@ -1002,27 +1002,27 @@ mod tests {\n             }\n         }\n \n-        do [\n+        [\n             \"Sunday\",\n             \"Monday\",\n             \"Tuesday\",\n             \"Wednesday\",\n             \"Thursday\",\n             \"Friday\",\n             \"Saturday\"\n-        ]/_.iter { |day| assert test(day, \"%A\"); }\n+        ]/_.iter(|day| assert test(day, \"%A\"));\n \n-        do [\n+        [\n             \"Sun\",\n             \"Mon\",\n             \"Tue\",\n             \"Wed\",\n             \"Thu\",\n             \"Fri\",\n             \"Sat\"\n-        ]/_.iter { |day| assert test(day, \"%a\"); }\n+        ]/_.iter(|day| assert test(day, \"%a\"));\n \n-        do [\n+        [\n             \"January\",\n             \"February\",\n             \"March\",\n@@ -1035,9 +1035,9 @@ mod tests {\n             \"October\",\n             \"November\",\n             \"December\"\n-        ]/_.iter { |day| assert test(day, \"%B\"); }\n+        ]/_.iter(|day| assert test(day, \"%B\"));\n \n-        do [\n+        [\n             \"Jan\",\n             \"Feb\",\n             \"Mar\",\n@@ -1050,7 +1050,7 @@ mod tests {\n             \"Oct\",\n             \"Nov\",\n             \"Dec\"\n-        ]/_.iter { |day| assert test(day, \"%b\"); }\n+        ]/_.iter(|day| assert test(day, \"%b\"));\n \n         assert test(\"19\", \"%C\");\n         assert test(\"Fri Feb 13 23:31:30 2009\", \"%c\");"}, {"sha": "6365c9bd95381f2a37eeae7bc0e45f4bf24391a6", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -31,7 +31,7 @@ fn delayed_send<T: copy send>(iotask: iotask,\n             let timer_done_ch_ptr = ptr::addr_of(timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(timer);\n-            do iotask::interact(iotask) {|loop_ptr|\n+            do iotask::interact(iotask) |loop_ptr| {\n                 let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n                 if (init_result == 0i32) {\n                     let start_result = uv::ll::timer_start(\n@@ -105,11 +105,11 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n     delayed_send(iotask, msecs, timeout_ch, ());\n     // FIXME: This could be written clearer (#2618)\n     either::either(\n-        {|left_val|\n+        |left_val| {\n             log(debug, #fmt(\"recv_time .. left_val %?\",\n                            left_val));\n             none\n-        }, {|right_val|\n+        }, |right_val| {\n             some(right_val)\n         }, comm::select2(timeout_po, wait_po)\n     )\n@@ -151,7 +151,7 @@ mod test {\n     #[test]\n     fn test_gl_timer_sleep_stress1() {\n         let hl_loop = uv::global_loop::get();\n-        do iter::repeat(200u) {||\n+        do iter::repeat(200u) || {\n             sleep(hl_loop, 1u);\n         }\n     }\n@@ -171,22 +171,22 @@ mod test {\n \n         };\n \n-        do iter::repeat(repeat) {||\n+        do iter::repeat(repeat) || {\n \n-            for spec.each {|spec|\n+            for spec.each |spec| {\n                 let (times, maxms) = spec;\n-                do task::spawn {||\n+                do task::spawn || {\n                     import rand::*;\n                     let rng = rng();\n-                    do iter::repeat(times) {||\n+                    do iter::repeat(times) || {\n                         sleep(hl_loop, rng.next() as uint % maxms);\n                     }\n                     comm::send(ch, ());\n                 }\n             }\n         }\n \n-        do iter::repeat(repeat * spec.len()) {||\n+        do iter::repeat(repeat * spec.len()) || {\n             comm::recv(po)\n         }\n     }\n@@ -204,14 +204,14 @@ mod test {\n         let mut failures = 0;\n         let hl_loop = uv::global_loop::get();\n \n-        do iter::repeat(times as uint) {||\n+        do iter::repeat(times as uint) || {\n             task::yield();\n \n             let expected = rand::rng().gen_str(16u);\n             let test_po = comm::port::<str>();\n             let test_ch = comm::chan(test_po);\n \n-            do task::spawn() {||\n+            do task::spawn() || {\n                 delayed_send(hl_loop, 1u, test_ch, expected);\n             };\n \n@@ -231,12 +231,12 @@ mod test {\n         let mut failures = 0;\n         let hl_loop = uv::global_loop::get();\n \n-        do iter::repeat(times as uint) {||\n+        do iter::repeat(times as uint) || {\n             let expected = rand::rng().gen_str(16u);\n             let test_po = comm::port::<str>();\n             let test_ch = comm::chan(test_po);\n \n-            do task::spawn() {||\n+            do task::spawn() || {\n                 delayed_send(hl_loop, 1000u, test_ch, expected);\n             };\n "}, {"sha": "066d2a6501f7e08608f0d4d5c86e7012c905bd4c", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -125,7 +125,7 @@ mod tests {\n         fn t(n: @mut int, &&k: int, &&_v: ()) {\n             assert (*n == k); *n += 1;\n         }\n-        traverse(m, {|x,y|t(n, x, y)});\n+        traverse(m, |x,y| t(n, x, y));\n     }\n \n     #[test]"}, {"sha": "aab8040c0a49796d00d34383bfefc1d15f3a5b77", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -40,7 +40,7 @@ fn get_monitor_task_gl() -> iotask unsafe {\n     #debug(\"ENTERING global_loop::get() loop chan: %?\",\n            monitor_loop_chan_ptr);\n \n-    let builder_fn = {||\n+    let builder_fn = || {\n         let builder = task::builder();\n         task::set_opts(builder, {\n             supervise: false,\n@@ -57,11 +57,11 @@ fn get_monitor_task_gl() -> iotask unsafe {\n     type monchan = chan<iotask>;\n \n     let monitor_ch = do chan_from_global_ptr::<monchan>(monitor_loop_chan_ptr,\n-                                                     builder_fn) {|msg_po|\n+                                                        builder_fn) |msg_po| {\n         #debug(\"global monitor task starting\");\n \n         // As a weak task the runtime will notify us when to exit\n-        do weaken_task() {|weak_exit_po|\n+        do weaken_task() |weak_exit_po| {\n             #debug(\"global monitor task is now weak\");\n             let hl_loop = spawn_loop();\n             loop {\n@@ -87,19 +87,19 @@ fn get_monitor_task_gl() -> iotask unsafe {\n \n     // once we have a chan to the monitor loop, we ask it for\n     // the libuv loop's async handle\n-    do listen { |fetch_ch|\n+    do listen |fetch_ch| {\n         monitor_ch.send(fetch_ch);\n         fetch_ch.recv()\n     }\n }\n \n fn spawn_loop() -> iotask unsafe {\n     let builder = task::builder();\n-    do task::add_wrapper(builder) {|task_body|\n+    do task::add_wrapper(builder) |task_body| {\n         fn~(move task_body) {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n-            do weaken_task {|weak_exit_po|\n+            do weaken_task |weak_exit_po| {\n                 #debug(\"global libuv task is now weak %?\", weak_exit_po);\n                 task_body();\n \n@@ -129,7 +129,7 @@ mod test {\n         log(debug, \"in simple timer cb\");\n         ll::timer_stop(timer_ptr);\n         let hl_loop = get_gl();\n-        do iotask::interact(hl_loop) {|_loop_ptr|\n+        do iotask::interact(hl_loop) |_loop_ptr| {\n             log(debug, \"closing timer\");\n             ll::close(timer_ptr, simple_timer_close_cb);\n             log(debug, \"about to deref exit_ch_ptr\");\n@@ -146,7 +146,7 @@ mod test {\n                        exit_ch_ptr));\n         let timer_handle = ll::timer_t();\n         let timer_ptr = ptr::addr_of(timer_handle);\n-        do iotask::interact(iotask) {|loop_ptr|\n+        do iotask::interact(iotask) |loop_ptr| {\n             log(debug, \"user code inside interact loop!!!\");\n             let init_status = ll::timer_init(loop_ptr, timer_ptr);\n             if(init_status == 0i32) {\n@@ -174,7 +174,7 @@ mod test {\n         let hl_loop = get_gl();\n         let exit_po = comm::port::<()>();\n         let exit_ch = comm::chan(exit_po);\n-        task::spawn_sched(task::manual_threads(1u), {||\n+        task::spawn_sched(task::manual_threads(1u), || {\n             impl_uv_hl_simple_timer(hl_loop);\n             comm::send(exit_ch, ());\n         });\n@@ -191,13 +191,13 @@ mod test {\n         let exit_po = comm::port::<()>();\n         let exit_ch = comm::chan(exit_po);\n         let cycles = 5000u;\n-        do iter::repeat(cycles) {||\n-            task::spawn_sched(task::manual_threads(1u), {||\n+        do iter::repeat(cycles) || {\n+            task::spawn_sched(task::manual_threads(1u), || {\n                 impl_uv_hl_simple_timer(hl_loop);\n                 comm::send(exit_ch, ());\n             });\n         };\n-        do iter::repeat(cycles) {||\n+        do iter::repeat(cycles) || {\n             comm::recv(exit_po);\n         };\n         log(debug, \"test_stress_gl_uv_global_loop_high_level_global_timer\"+"}, {"sha": "c24a3bf81700d0ed6859f9cf3bfb434f04ae5ddd", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -39,9 +39,9 @@ fn spawn_iotask(-builder: task::builder) -> iotask {\n         with get_opts(builder)\n     });\n \n-    do listen {|iotask_ch|\n+    do listen |iotask_ch| {\n \n-        do run(copy(builder)) {||\n+        do run(copy(builder)) || {\n             #debug(\"entering libuv task\");\n             run_loop(iotask_ch);\n             #debug(\"libuv task exiting\");\n@@ -211,7 +211,7 @@ mod test {\n             exit_ch: exit_ch\n         };\n         let ah_data_ptr = ptr::addr_of(ah_data);\n-        do interact(iotask) {|loop_ptr|\n+        do interact(iotask) |loop_ptr| {\n             ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n             ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n             ll::async_send(ah_ptr);\n@@ -224,7 +224,7 @@ mod test {\n     unsafe fn spawn_test_loop(exit_ch: comm::chan<()>) -> iotask {\n         let iotask_port = comm::port::<iotask>();\n         let iotask_ch = comm::chan(iotask_port);\n-        do task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n             run_loop(iotask_ch);\n             exit_ch.send(());\n         };\n@@ -255,13 +255,13 @@ mod test {\n         // called, at least.\n         let work_exit_po = comm::port::<()>();\n         let work_exit_ch = comm::chan(work_exit_po);\n-        do iter::repeat(7u) {||\n-            do task::spawn_sched(task::manual_threads(1u)) {||\n+        do iter::repeat(7u) || {\n+            do task::spawn_sched(task::manual_threads(1u)) || {\n                 impl_uv_iotask_async(iotask);\n                 comm::send(work_exit_ch, ());\n             };\n         };\n-        do iter::repeat(7u) {||\n+        do iter::repeat(7u) || {\n             comm::recv(work_exit_po);\n         };\n         log(debug, \"sending teardown_loop msg..\");"}, {"sha": "6004b0cf62e2a416b563983a8a35fd7fbceeace3", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -1262,7 +1262,7 @@ mod test {\n         let continue_chan = comm::chan::<bool>(continue_port);\n         let continue_chan_ptr = ptr::addr_of(continue_chan);\n \n-        do task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n             impl_uv_tcp_server(bind_ip, port,\n                                kill_server_msg,\n                                server_resp_msg,\n@@ -1275,7 +1275,7 @@ mod test {\n         comm::recv(continue_port);\n         log(debug, \"received on continue port, set up tcp client\");\n \n-        do task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n             impl_uv_tcp_request(request_ip, port,\n                                kill_server_msg,\n                                ptr::addr_of(client_chan));"}, {"sha": "3b4fe5f91ee545daab6499928826bb44ee0c1476", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -11,7 +11,7 @@ type path = ~[path_elt];\n \n /* FIXMEs that say \"bad\" are as per #2543 */\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n-    let strs = do vec::map(p) {|e|\n+    let strs = do vec::map(p) |e| {\n         alt e {\n           path_mod(s) { /* FIXME (#2543) */ copy *s }\n           path_name(s) { /* FIXME (#2543) */ copy *s }\n@@ -119,7 +119,7 @@ fn map_decoded_item(diag: span_handler,\n \n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n-    for decl.inputs.each {|a|\n+    for decl.inputs.each |a| {\n         cx.map.insert(a.id,\n                       node_arg(/* FIXME (#2543) */\n                           copy a, cx.local_id));\n@@ -156,7 +156,7 @@ fn map_block(b: blk, cx: ctx, v: vt) {\n }\n \n fn number_pat(cx: ctx, pat: @pat) {\n-    do ast_util::walk_pat(pat) {|p|\n+    do ast_util::walk_pat(pat) |p| {\n         alt p.node {\n           pat_ident(_, _) {\n             cx.map.insert(p.id, node_local(cx.local_id));\n@@ -190,13 +190,13 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     alt i.node {\n       item_impl(_, _, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n-        for ms.each {|m|\n+        for ms.each |m| {\n             map_method(impl_did, extend(cx, i.ident), m,\n                        cx);\n         }\n       }\n       item_enum(vs, _, _) {\n-        for vs.each {|v|\n+        for vs.each |v| {\n             cx.map.insert(v.node.id, node_variant(\n                 /* FIXME (#2543) */ copy v, i,\n                 extend(cx, i.ident)));\n@@ -207,7 +207,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           either::left(msg) { cx.diag.span_fatal(i.span, msg); }\n           either::right(abi) { abi }\n         };\n-        for nm.items.each {|nitem|\n+        for nm.items.each |nitem| {\n             cx.map.insert(nitem.id,\n                           node_foreign_item(nitem, abi,\n                                            /* FIXME (#2543) */\n@@ -218,12 +218,12 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           let (_, ms) = ast_util::split_class_items(items);\n           // Map iface refs to their parent classes. This is\n           // so we can find the self_ty\n-          do vec::iter(ifces) {|p| cx.map.insert(p.id,\n+          do vec::iter(ifces) |p| { cx.map.insert(p.id,\n                                   node_item(i, item_path)); };\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);\n            // only need to handle methods\n-          do vec::iter(ms) {|m| map_method(d_id, p, m, cx); }\n+          do vec::iter(ms) |m| { map_method(d_id, p, m, cx); }\n       }\n       _ { }\n     }\n@@ -240,7 +240,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     alt vi.node {\n       view_item_export(vps) {\n-        for vps.each {|vp|\n+        for vps.each |vp| {\n             let (id, name) = alt vp.node {\n               view_path_simple(nm, _, id) {\n                 (id, /* FIXME (#2543) */ copy nm)"}, {"sha": "0115ffb0331b3f618575825952438e167f1066eb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -25,7 +25,7 @@ pure fn path_name(p: @path) -> str { path_name_i(p.idents) }\n \n pure fn path_name_i(idents: ~[ident]) -> str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map({|i|*i}), \"::\")\n+    str::connect(idents.map(|i|*i), \"::\")\n }\n \n pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n@@ -152,11 +152,11 @@ pure fn float_ty_to_str(t: float_ty) -> str {\n fn is_exported(i: ident, m: _mod) -> bool {\n     let mut local = false;\n     let mut parent_enum : option<ident> = none;\n-    for m.items.each {|it|\n+    for m.items.each |it| {\n         if it.ident == i { local = true; }\n         alt it.node {\n           item_enum(variants, _, _) {\n-            for variants.each {|v|\n+            for variants.each |v| {\n                 if v.node.name == i {\n                    local = true;\n                    parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n@@ -168,11 +168,11 @@ fn is_exported(i: ident, m: _mod) -> bool {\n         if local { break; }\n     }\n     let mut has_explicit_exports = false;\n-    for m.view_items.each {|vi|\n+    for m.view_items.each |vi| {\n         alt vi.node {\n           view_item_export(vps) {\n             has_explicit_exports = true;\n-            for vps.each {|vp|\n+            for vps.each |vp| {\n                 alt vp.node {\n                   ast::view_path_simple(id, _, _) {\n                     if id == i { ret true; }\n@@ -187,7 +187,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                   ast::view_path_list(path, ids, _) {\n                     if vec::len(path.idents) == 1u {\n                         if i == path.idents[0] { ret true; }\n-                        for ids.each {|id|\n+                        for ids.each |id| {\n                             if id.node.name == i { ret true; }\n                         }\n                     } else {\n@@ -288,14 +288,16 @@ type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n              id: node_id, vis: visibility};\n \n fn public_methods(ms: ~[@method]) -> ~[@method] {\n-    vec::filter(ms, {|m| alt m.vis {\n+    vec::filter(ms,\n+                |m| alt m.vis {\n                     public { true }\n-                    _   { false }}})\n+                    _   { false }\n+                })\n }\n \n fn split_class_items(cs: ~[@class_member]) -> (~[ivar], ~[@method]) {\n     let mut vs = ~[], ms = ~[];\n-    for cs.each {|c|\n+    for cs.each |c| {\n       alt c.node {\n         instance_var(i, t, cm, id, vis) {\n           vec::push(vs, {ident: /* FIXME (#2543) */ copy i,\n@@ -408,7 +410,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             alt vi.node {\n               view_item_use(_, _, id) { vfn(id) }\n               view_item_import(vps) | view_item_export(vps) {\n-                do vec::iter(vps) {|vp|\n+                do vec::iter(vps) |vp| {\n                     alt vp.node {\n                       view_path_simple(_, _, id) { vfn(id) }\n                       view_path_glob(_, id) { vfn(id) }\n@@ -426,7 +428,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_item: fn@(i: @item) {\n             vfn(i.id);\n             alt i.node {\n-              item_enum(vs, _, _) { for vs.each {|v| vfn(v.node.id); } }\n+              item_enum(vs, _, _) { for vs.each |v| { vfn(v.node.id); } }\n               _ {}\n             }\n         },\n@@ -473,7 +475,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         },\n \n         visit_ty_params: fn@(ps: ~[ty_param]) {\n-            vec::iter(ps, {|p| vfn(p.id) })\n+            vec::iter(ps, |p| vfn(p.id))\n         },\n \n         visit_constr: fn@(_p: @path, _sp: span, id: node_id) {\n@@ -486,33 +488,33 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n \n             alt fk {\n               visit::fk_ctor(nm, tps, self_id, parent_id) {\n-                vec::iter(tps, {|tp| vfn(tp.id)});\n+                vec::iter(tps, |tp| vfn(tp.id));\n                 vfn(id);\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n               visit::fk_dtor(tps, self_id, parent_id) {\n-                vec::iter(tps, {|tp| vfn(tp.id)});\n+                vec::iter(tps, |tp| vfn(tp.id));\n                 vfn(id);\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n               visit::fk_item_fn(_, tps) {\n-                vec::iter(tps, {|tp| vfn(tp.id)});\n+                vec::iter(tps, |tp| vfn(tp.id));\n               }\n               visit::fk_method(_, tps, m) {\n                 vfn(m.self_id);\n-                vec::iter(tps, {|tp| vfn(tp.id)});\n+                vec::iter(tps, |tp| vfn(tp.id));\n               }\n               visit::fk_anon(_, capture_clause)\n               | visit::fk_fn_block(capture_clause) {\n-                for vec::each(*capture_clause) {|clause|\n+                for vec::each(*capture_clause) |clause| {\n                     vfn(clause.id);\n                 }\n               }\n             }\n \n-            do vec::iter(d.inputs) {|arg|\n+            do vec::iter(d.inputs) |arg| {\n                 vfn(arg.id)\n             }\n         },\n@@ -536,15 +538,15 @@ fn visit_ids_for_inlined_item(item: inlined_item, vfn: fn@(node_id)) {\n fn compute_id_range(visit_ids_fn: fn(fn@(node_id))) -> id_range {\n     let min = @mut int::max_value;\n     let max = @mut int::min_value;\n-    do visit_ids_fn { |id|\n+    do visit_ids_fn |id| {\n         *min = int::min(*min, id);\n         *max = int::max(*max, id + 1);\n     }\n     ret {min:*min, max:*max};\n }\n \n fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n-    compute_id_range({ |f| visit_ids_for_inlined_item(item, f) })\n+    compute_id_range(|f| visit_ids_for_inlined_item(item, f))\n }\n \n pure fn is_item_impl(item: @ast::item) -> bool {\n@@ -558,8 +560,12 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     alt pat.node {\n       pat_ident(pth, some(p)) { walk_pat(p, it); }\n-      pat_rec(fields, _) { for fields.each {|f| walk_pat(f.pat, it); } }\n-      pat_enum(_, some(s)) | pat_tup(s) { for s.each {|p| walk_pat(p, it); } }\n+      pat_rec(fields, _) {\n+        for fields.each |f| { walk_pat(f.pat, it); }\n+      }\n+      pat_enum(_, some(s)) | pat_tup(s) {\n+        for s.each |p| { walk_pat(p, it); }\n+      }\n       pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n       pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _)\n         | pat_enum(_, _) {}"}, {"sha": "13aa281ffb0d3426a74efac26285b525a4d4ccd5", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -77,7 +77,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     let mut mitems = ~[];\n-    for attrs.each {|a| vec::push(mitems, attr_meta(a)); }\n+    for attrs.each |a| { vec::push(mitems, attr_meta(a)); }\n     ret mitems;\n }\n \n@@ -179,7 +179,7 @@ comparison is performed structurally.\n fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     #debug(\"looking for %s\",\n            print::pprust::meta_item_to_str(*needle));\n-    for haystack.each {|item|\n+    for haystack.each |item| {\n         #debug(\"looking in %s\",\n                print::pprust::meta_item_to_str(*item));\n         if eq(item, needle) { #debug(\"found it!\"); ret true; }\n@@ -289,8 +289,7 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ast::ident) ->\n    ~[@ast::meta_item] {\n \n-    ret vec::filter_map(items, {\n-        |item|\n+    ret vec::filter_map(items, |item| {\n         if get_meta_item_name(item) != name {\n             option::some(/* FIXME (#2543) */ copy item)\n         } else {\n@@ -301,7 +300,7 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ast::ident) ->\n \n fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n     let mut found = ~[];\n-    for find_attrs_by_name(attrs, \"link\").each {|attr|\n+    for find_attrs_by_name(attrs, \"link\").each |attr| {\n         alt attr.node.value.node {\n           ast::meta_list(_, _) { vec::push(found, attr) }\n           _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n@@ -315,7 +314,7 @@ From a list of crate attributes get only the meta_items that impact crate\n linkage\n \"]\n fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n-    do find_linkage_attrs(attrs).flat_map {|attr|\n+    do find_linkage_attrs(attrs).flat_map |attr| {\n         alt check attr.node.value.node {\n           ast::meta_list(_, items) { /* FIXME (#2543) */ copy items }\n         }\n@@ -351,7 +350,7 @@ enum inline_attr {\n #[doc = \"True if something like #[inline] is found in the list of attrs.\"]\n fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // TODO---validate the usage of #[inline] and #[inline(always)]\n-    do vec::foldl(ia_none, attrs) {|ia,attr|\n+    do vec::foldl(ia_none, attrs) |ia,attr| {\n         alt attr.node.value.node {\n           ast::meta_word(@\"inline\") { ia_hint }\n           ast::meta_list(@\"inline\", items) {\n@@ -370,7 +369,7 @@ fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n fn require_unique_names(diagnostic: span_handler,\n                         metas: ~[@ast::meta_item]) {\n     let map = map::str_hash();\n-    for metas.each {|meta|\n+    for metas.each |meta| {\n         let name = get_meta_item_name(meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)"}, {"sha": "4c30016fdc855ef12979e336337a556e79ba18af", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -185,7 +185,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     let mut lines = ~[];\n-    for uint::range(lo.line - 1u, hi.line as uint) {|i|\n+    for uint::range(lo.line - 1u, hi.line as uint) |i| {\n         vec::push(lines, i);\n     };\n     ret @{file: lo.file, lines: lines};\n@@ -224,7 +224,7 @@ fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> str\n }\n \n fn get_filemap(cm: codemap, filename: str) -> filemap {\n-    for cm.files.each {|fm| if fm.name == filename { ret fm; } }\n+    for cm.files.each |fm| { if fm.name == filename { ret fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)\n     fail; // (\"asking for \" + filename + \" which we don't know about\");"}, {"sha": "4e1d8f824e15ae2c66435b096c2db5eb08d9bebd", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -207,7 +207,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n         elided = true;\n     }\n     // Print the offending lines\n-    for display_lines.each {|line|\n+    for display_lines.each |line| {\n         io::stderr().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n         let s = codemap::get_line(fm, line as int) + \"\\n\";\n         io::stderr().write_str(s);\n@@ -249,11 +249,9 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n }\n \n fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n-    do option::iter (sp.expn_info) {|ei|\n-        let ss = option::map_default(ei.callie.span, @\"\", {\n-            |span|\n-            @codemap::span_to_str(span, cm)\n-        });\n+    do option::iter (sp.expn_info) |ei| {\n+        let ss = option::map_default(ei.callie.span, @\"\",\n+                                     |span| @codemap::span_to_str(span, cm));\n         print_diagnostic(*ss, note,\n                          #fmt(\"in expansion of #%s\", ei.callie.name));\n         let ss = codemap::span_to_str(ei.call_site, cm);"}, {"sha": "d2d685f8f7da776eface1ed1f9a36f16930024b5", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -100,7 +100,7 @@ fn expand(cx: ext_ctxt,\n           with *item}\n     }\n \n-    do vec::flat_map(in_items) {|in_item|\n+    do vec::flat_map(in_items) |in_item| {\n         alt in_item.node {\n           ast::item_ty(ty, tps, _) {\n             vec::append(~[filter_attrs(in_item)],\n@@ -151,7 +151,7 @@ impl helpers for ext_ctxt {\n     fn ty_fn(span: span,\n              -input_tys: ~[@ast::ty],\n              -output: @ast::ty) -> @ast::ty {\n-        let args = do vec::map(input_tys) {|ty|\n+        let args = do vec::map(input_tys) |ty| {\n             {mode: ast::expl(ast::by_ref),\n              ty: ty,\n              ident: @\"\",\n@@ -237,12 +237,12 @@ impl helpers for ext_ctxt {\n     fn lambda(blk: ast::blk) -> @ast::expr {\n         let ext_cx = self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk));\n-        #ast{ {|| $(blk_e) } }\n+        #ast{ || $(blk_e) }\n     }\n \n     fn clone_folder() -> fold::ast_fold {\n         fold::make_fold(@{\n-            new_id: {|_id| self.next_id()}\n+            new_id: |_id| self.next_id()\n             with *fold::default_ast_fold()\n         })\n     }\n@@ -272,7 +272,7 @@ impl helpers for ext_ctxt {\n         }\n \n         let fld = fold::make_fold(@{\n-            new_span: {|a|repl_sp(a, ast_util::dummy_sp(), span)}\n+            new_span: |a| repl_sp(a, ast_util::dummy_sp(), span)\n             with *fold::default_ast_fold()\n         });\n \n@@ -294,11 +294,11 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n             ast::expr_path(\n                 cx.helper_path(path, \"serialize\")));\n \n-    let ty_args = do vec::map(path.types) {|ty|\n+    let ty_args = do vec::map(path.types) |ty| {\n         let sv_stmts = ser_ty(cx, tps, ty, cx.clone(s), #ast{ __v });\n         let sv = cx.expr(path.span,\n                          ast::expr_block(cx.blk(path.span, sv_stmts)));\n-        cx.at(ty.span, #ast{ {|__v| $(sv)} })\n+        cx.at(ty.span, #ast{ |__v| $(sv) })\n     };\n \n     ~[cx.stmt(\n@@ -316,14 +316,14 @@ fn ser_variant(cx: ext_ctxt,\n                bodyfn: fn(-@ast::expr, ast::blk) -> @ast::expr,\n                argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n-    let vnames = do vec::from_fn(vec::len(tys)) {|i|\n+    let vnames = do vec::from_fn(vec::len(tys)) |i| {\n         @#fmt[\"__v%u\", i]\n     };\n-    let pats = do vec::from_fn(vec::len(tys)) {|i|\n+    let pats = do vec::from_fn(vec::len(tys)) |i| {\n         cx.binder_pat(tys[i].span, vnames[i])\n     };\n     let pat: @ast::pat = @{id: cx.next_id(), node: pfn(pats), span: span};\n-    let stmts = do vec::from_fn(vec::len(tys)) {|i|\n+    let stmts = do vec::from_fn(vec::len(tys)) |i| {\n         let v = cx.var_ref(span, vnames[i]);\n         let arg_blk =\n             cx.blk(\n@@ -376,7 +376,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_rec(flds) {\n-        let fld_stmts = do vec::from_fn(vec::len(flds)) {|fidx|\n+        let fld_stmts = do vec::from_fn(vec::len(flds)) |fidx| {\n             let fld = flds[fidx];\n             let vf = cx.expr(fld.span,\n                              ast::expr_field(cx.clone(v),\n@@ -412,17 +412,17 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n                 cx, tps, tys, ty.span, s,\n \n                 // Generate pattern (v1, v2, v3)\n-                {|pats| ast::pat_tup(pats)},\n+                |pats| ast::pat_tup(pats),\n \n                 // Generate body s.emit_tup(3, {|| blk })\n-                {|-s, blk|\n+                |-s, blk| {\n                     let sz = cx.lit_uint(ty.span, vec::len(tys));\n                     let body = cx.lambda(blk);\n                     #ast{ $(s).emit_tup($(sz), $(body)) }\n                 },\n \n                 // Generate s.emit_tup_elt(i, {|| blk })\n-                {|-s, i, blk|\n+                |-s, i, blk| {\n                     let idx = cx.lit_uint(ty.span, i);\n                     let body = cx.lambda(blk);\n                     #ast{ $(s).emit_tup_elt($(idx), $(body)) }\n@@ -473,7 +473,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n                             cx.at(ty.span, #ast{ __e })))));\n \n         ~[#ast(stmt){\n-            std::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n+            std::serialization::emit_from_vec($(s), $(v), |__e| $(ser_e))\n         }]\n       }\n \n@@ -491,17 +491,17 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n     -> @ast::item {\n     let ext_cx = cx; // required for #ast\n \n-    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, ~[tp.ident], ~[])});\n+    let tp_types = vec::map(tps, |tp| cx.ty_path(span, ~[tp.ident], ~[]));\n     let v_ty = cx.ty_path(span, ~[name], tp_types);\n \n     let tp_inputs =\n-        vec::map(tps, {|tp|\n+        vec::map(tps, |tp|\n             {mode: ast::expl(ast::by_ref),\n              ty: cx.ty_fn(span,\n                           ~[cx.ty_path(span, ~[tp.ident], ~[])],\n                           cx.ty_nil(span)),\n              ident: @(\"__s\" + *tp.ident),\n-             id: cx.next_id()}});\n+             id: cx.next_id()});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n@@ -518,7 +518,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n                     tp_inputs);\n \n     let tps_map = map::str_hash();\n-    do vec::iter2(tps, tp_inputs) {|tp, arg|\n+    do vec::iter2(tps, tp_inputs) |tp, arg| {\n         let arg_ident = arg.ident;\n         tps_map.insert(\n             *tp.ident,\n@@ -539,7 +539,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n         vec::append(~[{ident: @\"__S\",\n                       id: cx.next_id(),\n                       bounds: ser_bnds}],\n-                    vec::map(tps, {|tp| cx.clone_ty_param(tp) }));\n+                    vec::map(tps, |tp| cx.clone_ty_param(tp)));\n \n     let ser_output: @ast::ty = @{id: cx.next_id(),\n                                  node: ast::ty_nil,\n@@ -575,7 +575,7 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n             ast::expr_path(\n                 cx.helper_path(path, \"deserialize\")));\n \n-    let ty_args = do vec::map(path.types) {|ty|\n+    let ty_args = do vec::map(path.types) |ty| {\n         let dv_expr = deser_ty(cx, tps, ty, cx.clone(d));\n         cx.lambda(cx.expr_blk(dv_expr))\n     };\n@@ -618,7 +618,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n       }\n \n       ast::ty_rec(flds) {\n-        let fields = do vec::from_fn(vec::len(flds)) {|fidx|\n+        let fields = do vec::from_fn(vec::len(flds)) |fidx| {\n             let fld = flds[fidx];\n             let d = cx.clone(d);\n             let f = cx.lit_str(fld.span, fld.node.ident);\n@@ -647,7 +647,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         //    d.read_tup_elt(2u, {||...}))\n         // }\n \n-        let arg_exprs = do vec::from_fn(vec::len(tys)) {|i|\n+        let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n             let idx = cx.lit_uint(ty.span, i);\n             let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n             #ast{ $(d).read_tup_elt($(idx), $(body)) }\n@@ -703,17 +703,17 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n     -> @ast::item {\n     let ext_cx = cx; // required for #ast\n \n-    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, ~[tp.ident], ~[])});\n+    let tp_types = vec::map(tps, |tp| cx.ty_path(span, ~[tp.ident], ~[]));\n     let v_ty = cx.ty_path(span, ~[name], tp_types);\n \n     let tp_inputs =\n-        vec::map(tps, {|tp|\n+        vec::map(tps, |tp|\n             {mode: ast::expl(ast::by_ref),\n              ty: cx.ty_fn(span,\n                           ~[],\n                           cx.ty_path(span, ~[tp.ident], ~[])),\n              ident: @(\"__d\" + *tp.ident),\n-             id: cx.next_id()}});\n+             id: cx.next_id()});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n@@ -725,7 +725,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n                     tp_inputs);\n \n     let tps_map = map::str_hash();\n-    do vec::iter2(tps, tp_inputs) {|tp, arg|\n+    do vec::iter2(tps, tp_inputs) |tp, arg| {\n         let arg_ident = arg.ident;\n         tps_map.insert(\n             *tp.ident,\n@@ -745,7 +745,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n         vec::append(~[{ident: @\"__D\",\n                       id: cx.next_id(),\n                       bounds: deser_bnds}],\n-                    vec::map(tps, {|tp|\n+                    vec::map(tps, |tp| {\n                         let cloned = cx.clone_ty_param(tp);\n                         {bounds: @(vec::append(*cloned.bounds,\n                                                ~[ast::bound_copy]))\n@@ -774,26 +774,26 @@ fn ty_fns(cx: ext_ctxt, name: ast::ident,\n \n     let span = ty.span;\n     ~[\n-        mk_ser_fn(cx, span, name, tps, {|a,b,c,d|ser_ty(a, b, ty, c, d)}),\n-        mk_deser_fn(cx, span, name, tps, {|a,b,c|deser_ty(a, b, ty, c)})\n+        mk_ser_fn(cx, span, name, tps, |a,b,c,d| ser_ty(a, b, ty, c, d)),\n+        mk_deser_fn(cx, span, name, tps, |a,b,c| deser_ty(a, b, ty, c))\n     ]\n }\n \n fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n             e_span: span, variants: ~[ast::variant],\n             -s: @ast::expr, -v: @ast::expr) -> ~[@ast::stmt] {\n     let ext_cx = cx;\n-    let arms = do vec::from_fn(vec::len(variants)) {|vidx|\n+    let arms = do vec::from_fn(vec::len(variants)) |vidx| {\n         let variant = variants[vidx];\n         let v_span = variant.span;\n         let v_name = variant.node.name;\n-        let variant_tys = vec::map(variant.node.args, {|a| a.ty });\n+        let variant_tys = vec::map(variant.node.args, |a| a.ty);\n \n         ser_variant(\n             cx, tps, variant_tys, v_span, cx.clone(s),\n \n             // Generate pattern var(v1, v2, v3)\n-            {|pats|\n+            |pats| {\n                 if vec::is_empty(pats) {\n                     ast::pat_ident(cx.path(v_span, ~[v_name]), none)\n                 } else {\n@@ -803,7 +803,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n \n             // Generate body s.emit_enum_variant(\"foo\", 0u,\n             //                                   3u, {|| blk })\n-            {|-s, blk|\n+            |-s, blk| {\n                 let v_name = cx.lit_str(v_span, v_name);\n                 let v_id = cx.lit_uint(v_span, vidx);\n                 let sz = cx.lit_uint(v_span, vec::len(variant_tys));\n@@ -815,7 +815,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n             },\n \n             // Generate s.emit_enum_variant_arg(i, {|| blk })\n-            {|-s, i, blk|\n+            |-s, i, blk| {\n                 let idx = cx.lit_uint(v_span, i);\n                 let body = cx.lambda(blk);\n                 #ast[expr]{\n@@ -832,13 +832,13 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n               e_span: span, variants: ~[ast::variant],\n               -d: @ast::expr) -> @ast::expr {\n     let ext_cx = cx;\n-    let arms: ~[ast::arm] = do vec::from_fn(vec::len(variants)) {|vidx|\n+    let arms: ~[ast::arm] = do vec::from_fn(vec::len(variants)) |vidx| {\n         let variant = variants[vidx];\n         let v_span = variant.span;\n         let v_name = variant.node.name;\n-        let tys = vec::map(variant.node.args, {|a| a.ty });\n+        let tys = vec::map(variant.node.args, |a| a.ty);\n \n-        let arg_exprs = do vec::from_fn(vec::len(tys)) {|i|\n+        let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n             let idx = cx.lit_uint(v_span, i);\n             let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n             #ast{ $(d).read_enum_variant_arg($(idx), $(body)) }\n@@ -866,7 +866,7 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n     let e_name = cx.lit_str(e_span, e_name);\n     let alt_expr = cx.expr(e_span,\n                            ast::expr_alt(#ast{__i}, arms, ast::alt_check));\n-    let var_lambda = #ast{ {|__i| $(alt_expr)} };\n+    let var_lambda = #ast{ |__i| $(alt_expr) };\n     let read_var = #ast{ $(cx.clone(d)).read_enum_variant($(var_lambda)) };\n     let read_lambda = cx.lambda(cx.expr_blk(read_var));\n     #ast{ $(d).read_enum($(e_name), $(read_lambda)) }\n@@ -877,8 +877,8 @@ fn enum_fns(cx: ext_ctxt, e_name: ast::ident, e_span: span,\n     -> ~[@ast::item] {\n     ~[\n         mk_ser_fn(cx, e_span, e_name, tps,\n-                  {|a,b,c,d|ser_enum(a, b, e_name, e_span, variants, c, d)}),\n+                  |a,b,c,d| ser_enum(a, b, e_name, e_span, variants, c, d)),\n         mk_deser_fn(cx, e_span, e_name, tps,\n-                    {|a,b,c|deser_enum(a, b, e_name, e_span, variants, c)})\n+                    |a,b,c| deser_enum(a, b, e_name, e_span, variants, c))\n     ]\n }"}, {"sha": "872d1f5eff6976d7e473f850d943a515a0be49f5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -81,7 +81,7 @@ fn mk_rec_e(cx: ext_ctxt, sp: span,\n             fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n     @ast::expr {\n     let mut astfields: ~[ast::field] = ~[];\n-    for fields.each {|field|\n+    for fields.each |field| {\n         let ident = field.ident;\n         let val = field.ex;\n         let astfield ="}, {"sha": "a678304725de2556b7dc20d7d378ffe94239da7b", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -4,7 +4,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args_no_max(cx,sp,arg,1u,\"concat_idents\");\n     let mut res = \"\";\n-    for args.each {|e|\n+    for args.each |e| {\n         res += *expr_to_ident(cx, e, \"expected an ident\");\n     }\n "}, {"sha": "a6e47e0941c699f717a1fe23b3107c8fdf195a9a", "filename": "src/libsyntax/ext/earley_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fearley_parser.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -47,7 +47,7 @@ fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n }\n \n fn count_names(ms: &[matcher]) -> uint {\n-    vec::foldl(0u, ms, {|ct, m|\n+    vec::foldl(0u, ms, |ct, m| {\n         ct + alt m.node {\n           mtc_tok(_) { 0u }\n           mtc_rep(more_ms, _, _) { count_names(more_ms) }\n@@ -57,7 +57,7 @@ fn count_names(ms: &[matcher]) -> uint {\n \n fn new_matcher_pos(ms: ~[matcher], sep: option<token>) -> matcher_pos {\n     ~{elts: ms, sep: sep, mut idx: 0u, mut up: matcher_pos_up(none),\n-      matches: copy vec::from_fn(count_names(ms), {|_i| dvec::dvec()}) }\n+      matches: copy vec::from_fn(count_names(ms), |_i| dvec::dvec()) }\n }\n \n /* logically, an arb_depth should contain only one kind of nonterminal */\n@@ -106,7 +106,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                         // I bet this is a perf problem: we're preemptively\n                         // doing a lot of array work that will get thrown away\n                         // most of the time.\n-                        for ei.matches.eachi() { |idx, elt|\n+                        for ei.matches.eachi() |idx, elt| {\n                             new_pos.matches[idx].push(@seq(elt.get()));\n                         }\n \n@@ -145,7 +145,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                     }\n \n                     let matches = vec::map(ei.matches, // fresh, same size:\n-                                           {|_m| dvec::<@arb_depth>()});\n+                                           |_m| dvec::<@arb_depth>());\n                     let ei_t <- ei;\n                     vec::push(cur_eis, ~{\n                         elts: matchers, sep: sep, mut idx: 0u,\n@@ -165,7 +165,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n         /* error messages here could be improved with links to orig. rules */\n         if tok == EOF {\n             if eof_eis.len() == 1u {\n-                let ret_val = vec::map(eof_eis[0u].matches, {|dv| dv.pop()});\n+                let ret_val = vec::map(eof_eis[0u].matches, |dv| dv.pop());\n                 ret ret_val; /* success */\n             } else if eof_eis.len() > 1u {\n                 rdr.fatal(\"Ambiguity: multiple successful parses\");\n@@ -175,7 +175,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n-                let nts = str::connect(vec::map(bb_eis, {|ei|\n+                let nts = str::connect(vec::map(bb_eis, |ei| {\n                     alt ei.elts[ei.idx].node\n                         { mtc_bb(_,name,_) { *name } _ { fail; } }\n                 }), \" or \");"}, {"sha": "a037d87166ae96902800f056f7a717913b56a01a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -100,8 +100,8 @@ fn expand_mod_items(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n     // For each item, look through the attributes.  If any of them are\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n-    let new_items = do vec::flat_map(module.items) {|item|\n-        do vec::foldr(item.attrs, ~[item]) {|attr, items|\n+    let new_items = do vec::flat_map(module.items) |item| {\n+        do vec::foldr(item.attrs, ~[item]) |attr, items| {\n             let mname = alt attr.node.value.node {\n               ast::meta_word(n) { n }\n               ast::meta_name_value(n, _) { n }\n@@ -164,10 +164,10 @@ fn expand_crate(parse_sess: parse::parse_sess,\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n     let f_pre =\n-        @{fold_expr: {|a,b,c|expand_expr(exts, cx, a, b, c, afp.fold_expr)},\n-          fold_mod: {|a,b|expand_mod_items(exts, cx, a, b, afp.fold_mod)},\n-          fold_item: {|a,b|expand_item(cx, a, b, afp.fold_item)},\n-          new_span: {|a|new_span(cx, a)}\n+        @{fold_expr: |a,b,c| expand_expr(exts, cx, a, b, c, afp.fold_expr),\n+          fold_mod: |a,b| expand_mod_items(exts, cx, a, b, afp.fold_mod),\n+          fold_item: |a,b| expand_item(cx, a, b, afp.fold_item),\n+          new_span: |a|new_span(cx, a)\n           with *afp};\n     let f = make_fold(f_pre);\n     let cm = parse_expr_from_source_str(\"<core-macros>\","}, {"sha": "acf055ccabda38f6eb64f163c1eb14ebe90ebbe2", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -51,7 +51,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n         fn make_flags(cx: ext_ctxt, sp: span, flags: ~[flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @\"flag_none\");\n-            for flags.each {|f|\n+            for flags.each |f| {\n                 let fstr = alt f {\n                   flag_left_justify { \"flag_left_justify\" }\n                   flag_left_zero_pad { \"flag_left_zero_pad\" }\n@@ -136,7 +136,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n           option::none { }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n-        for cnv.flags.each {|f|\n+        for cnv.flags.each |f| {\n             alt f {\n               flag_left_justify { }\n               flag_sign_always {\n@@ -191,7 +191,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n           some(p) { log(debug, \"param: \" + int::to_str(p, 10u)); }\n           _ { #debug(\"param: none\"); }\n         }\n-        for c.flags.each {|f|\n+        for c.flags.each |f| {\n             alt f {\n               flag_left_justify { #debug(\"flag: left justify\"); }\n               flag_left_zero_pad { #debug(\"flag: left zero pad\"); }\n@@ -246,7 +246,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     let mut n = 0u;\n     let mut piece_exprs = ~[];\n     let nargs = args.len();\n-    for pieces.each {|pc|\n+    for pieces.each |pc| {\n         alt pc {\n           piece_string(s) {\n             vec::push(piece_exprs, mk_str(cx, fmt_sp, s));"}, {"sha": "d237cd3383916641f6e8820c68b269550fb5233a", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -7,7 +7,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     cx.print_backtrace();\n     io::stdout().write_line(\n         str::connect(vec::map(args,\n-                              {|&&ex| print::pprust::expr_to_str(ex)}), \", \")\n+                              |&&ex| print::pprust::expr_to_str(ex)), \", \")\n     );\n \n     //trivial expression"}, {"sha": "2bb8c27828c23a570f8279baa0d2cac78158c0ac", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -97,17 +97,15 @@ impl of qq_helper for @ast::pat {\n \n fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n {\n-    let v = @{visit_expr: {|node, &&cx, v|\n-                  visit_aq(node, \"from_expr\", cx, v)},\n-              visit_ty: {|node, &&cx, v|\n-                  visit_aq(node, \"from_ty\", cx, v)}\n+    let v = @{visit_expr: |node, &&cx, v| visit_aq(node, \"from_expr\", cx, v),\n+              visit_ty: |node, &&cx, v| visit_aq(node, \"from_ty\", cx, v)\n               with *default_visitor()};\n     let cx = @{lo:lo, gather: dvec()};\n     node.visit(cx, mk_vt(v));\n     // FIXME (#2250): Maybe this is an overkill (merge_sort), it might\n     // be better to just keep the gather array in sorted order.\n-    do cx.gather.swap { |v|\n-        vec::to_mut(std::sort::merge_sort({|a,b| a.lo < b.lo}, v))\n+    do cx.gather.swap |v| {\n+        vec::to_mut(std::sort::merge_sort(|a,b| a.lo < b.lo, v))\n     };\n     ret cx;\n }\n@@ -132,7 +130,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     -> @ast::expr\n {\n     let mut what = \"expr\";\n-    do option::iter(arg) {|arg|\n+    do option::iter(arg) |arg| {\n         let args: ~[@ast::expr] =\n             alt arg.node {\n               ast::expr_vec(elts, _) { elts }\n@@ -193,7 +191,7 @@ fn finish<T: qq_helper>\n     let qcx = gather_anti_quotes(sp.lo, node);\n     let cx = qcx;\n \n-    for uint::range(1u, cx.gather.len()) {|i|\n+    for uint::range(1u, cx.gather.len()) |i| {\n         assert cx.gather[i-1u].lo < cx.gather[i].lo;\n         // ^^ check that the vector is sorted\n         assert cx.gather[i-1u].hi <= cx.gather[i].lo;\n@@ -205,7 +203,7 @@ fn finish<T: qq_helper>\n     let mut state = active;\n     let mut i = 0u, j = 0u;\n     let g_len = cx.gather.len();\n-    do str::chars_iter(*str) {|ch|\n+    do str::chars_iter(*str) |ch| {\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n             let repl = #fmt(\"$%u \", j);\n@@ -229,14 +227,11 @@ fn finish<T: qq_helper>\n \n     let cx = ecx;\n \n-    let cfg_call = {||\n-        mk_call_(cx, sp, mk_access(cx, sp, ~[@\"ext_cx\"], @\"cfg\"), ~[])\n-    };\n+    let cfg_call = || mk_call_(\n+        cx, sp, mk_access(cx, sp, ~[@\"ext_cx\"], @\"cfg\"), ~[]);\n \n-    let parse_sess_call = {||\n-        mk_call_(cx, sp,\n-                 mk_access(cx, sp, ~[@\"ext_cx\"], @\"parse_sess\"), ~[])\n-    };\n+    let parse_sess_call = || mk_call_(\n+        cx, sp, mk_access(cx, sp, ~[@\"ext_cx\"], @\"parse_sess\"), ~[]);\n \n     let pcall = mk_call(cx,sp,\n                        ~[@\"syntax\", @\"parse\", @\"parser\",\n@@ -259,7 +254,7 @@ fn finish<T: qq_helper>\n         rcall = mk_call(cx,sp,\n                         ~[@\"syntax\", @\"ext\", @\"qquote\", @\"replace\"],\n                         ~[pcall,\n-                         mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec({|g|\n+                          mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec(|g| {\n                              mk_call(cx,sp,\n                                      ~[@\"syntax\", @\"ext\",\n                                       @\"qquote\", @g.constr],\n@@ -275,10 +270,10 @@ fn replace<T>(node: T, repls: ~[fragment], ff: fn (ast_fold, T) -> T)\n     -> T\n {\n     let aft = default_ast_fold();\n-    let f_pre = @{fold_expr: {|a,b,c|replace_expr(repls, a, b, c,\n-                                                  aft.fold_expr)},\n-                  fold_ty: {|a,b,c|replace_ty(repls, a, b, c,\n-                                              aft.fold_ty)}\n+    let f_pre = @{fold_expr: |a,b,c|replace_expr(repls, a, b, c,\n+                                                  aft.fold_expr),\n+                  fold_ty: |a,b,c|replace_ty(repls, a, b, c,\n+                                              aft.fold_ty)\n                   with *aft};\n     ret ff(make_fold(f_pre), node);\n }"}, {"sha": "2f811891711d6421ba1a81e47d0b5776854d8163", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -74,7 +74,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n    {pre: ~[@expr], rep: option<@expr>, post: ~[@expr]} {\n     let mut idx: uint = 0u;\n     let mut res = none;\n-    for elts.each {|elt|\n+    for elts.each |elt| {\n         alt elt.node {\n           expr_mac(m) {\n             alt m.node {\n@@ -103,7 +103,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: ~[T]) ->\n    option<~[U]> {\n     let mut res = ~[];\n-    for v.each {|elem|\n+    for v.each |elem| {\n         alt f(elem) { none { ret none; } some(fv) { vec::push(res, fv); } }\n     }\n     ret some(res);\n@@ -113,7 +113,7 @@ fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n     alt ad {\n       leaf(x) { ret f(x); }\n       seq(ads, span) {\n-        alt option_flatten_map({|x| a_d_map(x, f)}, *ads) {\n+        alt option_flatten_map(|x| a_d_map(x, f), *ads) {\n           none { ret none; }\n           some(ts) { ret some(seq(@ts, span)); }\n         }\n@@ -128,7 +128,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n               some(matches) { a_d_map(matches, s2) }\n             }\n     }\n-    ret {|x|scomp(s1, s2, x)};\n+    ret { |x| scomp(s1, s2, x) };\n }\n \n \n@@ -164,11 +164,11 @@ selectors. */\n fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n     let res = box_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n-    for b.literal_ast_matchers.each {|sel|\n+    for b.literal_ast_matchers.each |sel| {\n         alt sel(match_expr(e)) { none { ret none; } _ { } }\n     }\n     let mut never_mind: bool = false;\n-    for b.real_binders.each {|key, val|\n+    for b.real_binders.each |key, val| {\n         alt val(match_expr(e)) {\n           none { never_mind = true; }\n           some(mtc) { res.insert(key, mtc); }\n@@ -190,22 +190,22 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     }\n     let afp = default_ast_fold();\n     let f_pre =\n-        @{fold_ident: {|x,y|transcribe_ident(cx, b, idx_path, x, y)},\n-          fold_path: {|x,y|transcribe_path(cx, b, idx_path, x, y)},\n-          fold_expr: {|x,y,z|\n+        @{fold_ident: |x,y|transcribe_ident(cx, b, idx_path, x, y),\n+          fold_path: |x,y|transcribe_path(cx, b, idx_path, x, y),\n+          fold_expr: |x,y,z|\n               transcribe_expr(cx, b, idx_path, x, y, z, afp.fold_expr)\n-          },\n-          fold_ty: {|x,y,z|\n+          ,\n+          fold_ty: |x,y,z|\n               transcribe_type(cx, b, idx_path,\n                               x, y, z, afp.fold_ty)\n-          },\n-          fold_block: {|x,y,z|\n+          ,\n+          fold_block: |x,y,z|\n               transcribe_block(cx, b, idx_path, x, y, z, afp.fold_block)\n-          },\n-          map_exprs: {|x,y|\n+          ,\n+          map_exprs: |x,y|\n               transcribe_exprs(cx, b, idx_path, x, y)\n-          },\n-          new_id: {|x|new_id(x, cx)}\n+          ,\n+          new_id: |x|new_id(x, cx)\n           with *afp};\n     let f = make_fold(f_pre);\n     let result = f.fold_expr(body);\n@@ -217,7 +217,7 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n fn follow(m: arb_depth<matchable>, idx_path: @mut ~[uint]) ->\n    arb_depth<matchable> {\n     let mut res: arb_depth<matchable> = m;\n-    for vec::each(*idx_path) {|idx|\n+    for vec::each(*idx_path) |idx| {\n         res = alt res {\n           leaf(_) { ret res;/* end of the line */ }\n           seq(new_ms, _) { new_ms[idx] }\n@@ -255,11 +255,11 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n     // using fold is a hack: we want visit, but it doesn't hit idents ) :\n     // solve this with macros\n     let f_pre =\n-        @{fold_ident: {|x,y|mark_ident(x, y, b, idents)}\n+        @{fold_ident: |x,y|mark_ident(x, y, b, idents)\n           with *default_ast_fold()};\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n-    for idents.each_key {|x| it(x); };\n+    for idents.each_key |x| { it(x); };\n }\n \n \n@@ -276,7 +276,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n             let mut repeat: option<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n-            do free_vars(b, repeat_me) {|fv|\n+            do free_vars(b, repeat_me) |fv| {\n                 let cur_pos = follow(b.get(fv), idx_path);\n                 alt cur_pos {\n                   leaf(_) { }\n@@ -481,7 +481,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                       _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                     }\n             }\n-            b.literal_ast_matchers.push({|x|select(cx, x, e)});\n+            b.literal_ast_matchers.push(|x| select(cx, x, e));\n           }\n         }\n       }\n@@ -523,7 +523,7 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n         if b.real_binders.contains_key(p_id) {\n             cx.span_fatal(p.span, \"duplicate binding identifier\");\n         }\n-        b.real_binders.insert(p_id, compose_sels(s, {|x|select(cx, x)}));\n+        b.real_binders.insert(p_id, compose_sels(s, |x| select(cx, x)));\n       }\n       none { }\n     }\n@@ -568,7 +568,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n                           _ { none }\n                         }\n                 }\n-                let final_step = {|x|select_pt_1(cx, x, select_pt_2)};\n+                let final_step = |x| select_pt_1(cx, x, select_pt_2);\n                 b.real_binders.insert(id, compose_sels(s, final_step));\n               }\n               none { no_des(cx, pth.span, \"under `#<>`\"); }\n@@ -588,7 +588,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n                       _ { none }\n                     }\n             }\n-            let final_step = {|x|select_pt_1(cx, x, select_pt_2)};\n+            let final_step = |x| select_pt_1(cx, x, select_pt_2);\n             b.real_binders.insert(id, compose_sels(s, final_step));\n           }\n           none { no_des(cx, blk.span, \"under `#{}`\"); }\n@@ -625,7 +625,7 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n             }\n     }\n     p_t_s_rec(cx, match_expr(repeat_me),\n-              compose_sels(s, {|x|select(cx, repeat_me, offset, x)}), b);\n+              compose_sels(s, |x| select(cx, repeat_me, offset, x)), b);\n }\n \n \n@@ -649,7 +649,7 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n             }\n     }\n     b.literal_ast_matchers.push(\n-        compose_sels(s, {|x|len_select(cx, x, at_least, len)}));\n+        compose_sels(s, |x| len_select(cx, x, at_least, len)));\n }\n \n fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n@@ -670,7 +670,7 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n                 }\n         }\n         p_t_s_rec(cx, match_expr(elts[idx]),\n-                  compose_sels(s, {|x, copy idx|select(cx, x, idx)}), b);\n+                  compose_sels(s, |x, copy idx| select(cx, x, idx)), b);\n         idx += 1u;\n     }\n }\n@@ -681,7 +681,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n     let mut macro_name: option<@str> = none;\n     let mut clauses: ~[@clause] = ~[];\n-    for args.each {|arg|\n+    for args.each |arg| {\n         alt arg.node {\n           expr_vec(elts, mutbl) {\n             if vec::len(elts) != 2u {\n@@ -745,9 +745,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         }\n     }\n \n-    let ext = {|a,b,c,d, move clauses|\n-        generic_extension(a,b,c,d,clauses)\n-    };\n+    let ext = |a,b,c,d, move clauses| generic_extension(a,b,c,d,clauses);\n \n     ret {ident:\n              alt macro_name {\n@@ -766,7 +764,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n           some(arg) { arg }\n           none { cx.span_fatal(sp, \"macro must have arguments\")}\n         };\n-        for clauses.each {|c|\n+        for clauses.each |c| {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) { ret transcribe(cx, bindings, c.body); }\n               none { cont; }"}, {"sha": "ee5e96cc0e44c824d88e402f40d90cd1ff334c0f", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -50,7 +50,7 @@ fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n     -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), \"file\");\n     ret mk_lit(cx, sp, ast::lit_str(\n-        @str::connect(cx.mod_path().map({|x|*x}), \"::\")));\n+        @str::connect(cx.mod_path().map(|x|*x), \"::\")));\n }\n \n fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n@@ -88,7 +88,7 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     alt io::read_whole_file(res_rel_file(cx, sp, file)) {\n       result::ok(src) {\n-        let u8_exprs = vec::map(src, { |char: u8|\n+        let u8_exprs = vec::map(src, |char: u8| {\n             mk_lit(cx, sp, ast::lit_uint(char as u64, ast::ty_u8))\n         });\n         ret mk_uniq_vec_e(cx, sp, u8_exprs);"}, {"sha": "cbe8edb2b51907c8d95ae06fc6acef5042ad64ef", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -87,7 +87,7 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n               alt mi.node {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n-                  let fold_meta_item = {|x|fold_meta_item_(x, fld)};\n+                  let fold_meta_item = |x|fold_meta_item_(x, fld);\n                   meta_list(/* FIXME: (#2543) */ copy id,\n                             vec::map(mis, fold_meta_item))\n                 }\n@@ -131,7 +131,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n-    ret {inputs: vec::map(decl.inputs, {|x| fold_arg_(x, fld)}),\n+    ret {inputs: vec::map(decl.inputs, |x| fold_arg_(x, fld) ),\n          output: fld.fold_ty(decl.output),\n          purity: decl.purity,\n          cf: decl.cf,\n@@ -148,16 +148,16 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n     {ident: /* FIXME (#2543) */ copy tp.ident,\n      id: fld.new_id(tp.id),\n-     bounds: @vec::map(*tp.bounds, {|x|fold_ty_param_bound(x, fld)})}\n+     bounds: @vec::map(*tp.bounds, |x| fold_ty_param_bound(x, fld) )}\n }\n \n fn fold_ty_params(tps: ~[ty_param], fld: ast_fold) -> ~[ty_param] {\n-    vec::map(tps, {|x|fold_ty_param(x, fld)})\n+    vec::map(tps, |x| fold_ty_param(x, fld) )\n }\n \n fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n-    let fold_meta_item = {|x|fold_meta_item_(x, fld)};\n-    let fold_attribute = {|x|fold_attribute_(x, fld)};\n+    let fold_meta_item = |x| fold_meta_item_(x, fld);\n+    let fold_attribute = |x| fold_attribute_(x, fld);\n \n     ret {directives: vec::map(c.directives, fld.fold_crate_directive),\n          module: fld.fold_mod(c.module),\n@@ -188,8 +188,8 @@ fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n \n fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n     -> @foreign_item {\n-    let fold_arg = {|x|fold_arg_(x, fld)};\n-    let fold_attribute = {|x|fold_attribute_(x, fld)};\n+    let fold_arg = |x| fold_arg_(x, fld);\n+    let fold_attribute = |x| fold_attribute_(x, fld);\n \n     ret @{ident: fld.fold_ident(ni.ident),\n           attrs: vec::map(ni.attrs, fold_attribute),\n@@ -211,7 +211,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n }\n \n fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n-    let fold_attribute = {|x|fold_attribute_(x, fld)};\n+    let fold_attribute = |x| fold_attribute_(x, fld);\n \n     ret @{ident: fld.fold_ident(i.ident),\n           attrs: vec::map(i.attrs, fold_attribute),\n@@ -255,15 +255,15 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n               let ctor_body = fld.fold_block(ctor.node.body);\n               let ctor_decl = fold_fn_decl(ctor.node.dec, fld);\n               let ctor_id   = fld.new_id(ctor.node.id);\n-              let dtor = do option::map(m_dtor) {|dtor|\n+            let dtor = do option::map(m_dtor) |dtor| {\n                 let dtor_body = fld.fold_block(dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n                 {node: {body: dtor_body,\n                         id: dtor_id with dtor.node}\n                     with dtor}};\n               item_class(\n                   /* FIXME (#2543) */ copy typms,\n-                  vec::map(ifaces, {|p| fold_iface_ref(p, fld) }),\n+                  vec::map(ifaces, |p| fold_iface_ref(p, fld)),\n                   vec::map(items, fld.fold_class_item),\n                   {node: {body: ctor_body,\n                           dec: ctor_decl,\n@@ -273,7 +273,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_impl(tps, rp, ifce, ty, methods) {\n               item_impl(fold_ty_params(tps, fld),\n                         rp,\n-                        ifce.map({ |p| fold_iface_ref(p, fld) }),\n+                        ifce.map(|p| fold_iface_ref(p, fld)),\n                         fld.fold_ty(ty),\n                         vec::map(methods, fld.fold_method))\n           }\n@@ -333,11 +333,11 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_lit(e) { pat_lit(fld.fold_expr(e)) }\n           pat_enum(pth, pats) {\n               pat_enum(fld.fold_path(pth), option::map(pats,\n-                       {|pats| vec::map(pats, fld.fold_pat)}))\n+                       |pats| vec::map(pats, fld.fold_pat)))\n           }\n           pat_rec(fields, etc) {\n             let mut fs = ~[];\n-            for fields.each {|f|\n+            for fields.each |f| {\n                 vec::push(fs,\n                           {ident: /* FIXME (#2543) */ copy f.ident,\n                            pat: fld.fold_pat(f.pat)});\n@@ -376,9 +376,9 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                   expr: fld.fold_expr(field.node.expr)},\n              span: fld.new_span(field.span)};\n     }\n-    let fold_field = {|x|fold_field_(x, fld)};\n+    let fold_field = |x| fold_field_(x, fld);\n \n-    let fold_mac = {|x|fold_mac_(x, fld)};\n+    let fold_mac = |x| fold_mac_(x, fld);\n \n     ret alt e {\n           expr_new(p, i, v) {\n@@ -426,13 +426,13 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_fn(proto, decl, body, captures) {\n             expr_fn(proto, fold_fn_decl(decl, fld),\n                     fld.fold_block(body),\n-                    @((*captures).map({|cap_item|\n+                    @((*captures).map(|cap_item| {\n                         @({id: fld.new_id((*cap_item).id)\n                            with *cap_item})})))\n           }\n           expr_fn_block(decl, body, captures) {\n             expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body),\n-                          @((*captures).map({|cap_item|\n+                          @((*captures).map(|cap_item| {\n                               @({id: fld.new_id((*cap_item).id)\n                                  with *cap_item})})))\n           }\n@@ -474,7 +474,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n }\n \n fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n-    let fold_mac = {|x|fold_mac_(x, fld)};\n+    let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n         {ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl}\n     }\n@@ -490,9 +490,9 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_vec(mt) {ty_vec(fold_mt(mt, fld))}\n       ty_ptr(mt) {ty_ptr(fold_mt(mt, fld))}\n       ty_rptr(region, mt) {ty_rptr(region, fold_mt(mt, fld))}\n-      ty_rec(fields) {ty_rec(vec::map(fields, {|f| fold_field(f, fld)}))}\n+      ty_rec(fields) {ty_rec(vec::map(fields, |f| fold_field(f, fld)))}\n       ty_fn(proto, decl) {ty_fn(proto, fold_fn_decl(decl, fld))}\n-      ty_tup(tys) {ty_tup(vec::map(tys, {|ty| fld.fold_ty(ty)}))}\n+      ty_tup(tys) {ty_tup(vec::map(tys, |ty| fld.fold_ty(ty)))}\n       ty_path(path, id) {ty_path(fld.fold_path(path), fld.new_id(id))}\n       ty_constr(ty, constrs) {ty_constr(fld.fold_ty(ty),\n                                 vec::map(constrs, fld.fold_ty_constr))}\n@@ -527,10 +527,10 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n         ret {ty: fld.fold_ty(va.ty), id: fld.new_id(va.id)};\n     }\n-    let fold_variant_arg = {|x|fold_variant_arg_(x, fld)};\n+    let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n     let args = vec::map(v.args, fold_variant_arg);\n \n-    let fold_attribute = {|x|fold_attribute_(x, fld)};\n+    let fold_attribute = |x| fold_attribute_(x, fld);\n     let attrs = vec::map(v.attrs, fold_attribute);\n \n     let de = alt v.disr_expr {\n@@ -624,8 +624,8 @@ impl of ast_fold for ast_fold_precursor {\n     fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n         ret @{node: self.fold_view_item(x.node, self as ast_fold),\n-              attrs: vec::map(x.attrs, {|a|\n-                  fold_attribute_(a, self as ast_fold)}),\n+              attrs: vec::map(x.attrs, |a|\n+                  fold_attribute_(a, self as ast_fold)),\n               vis: x.vis,\n               span: self.new_span(x.span)};\n     }"}, {"sha": "bf9a7dd2acecd59ff1d665eea417b52667722b61", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -37,8 +37,8 @@ fn new_parse_sess(demitter: option<emitter>) -> parse_sess {\n     ret @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-          interner: @interner::mk::<@str>({|x|str::hash(*x)},\n-                                          {|x,y|str::eq(*x, *y)}),\n+          interner: @interner::mk::<@str>(|x| str::hash(*x),\n+                                          |x,y| str::eq(*x, *y)),\n           mut chpos: 0u, mut byte_pos: 0u};\n }\n \n@@ -47,8 +47,8 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::codemap)\n     ret @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: sh,\n-          interner: @interner::mk::<@str>({|x|str::hash(*x)},\n-                                          {|x,y|str::eq(*x, *y)}),\n+          interner: @interner::mk::<@str>(|x| str::hash(*x),\n+                                          |x,y| str::eq(*x, *y)),\n           mut chpos: 0u, mut byte_pos: 0u};\n }\n "}, {"sha": "13c72d1e31527c47bb4fdcc04e22555b5a7b1562", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -114,7 +114,7 @@ impl parser_attr for parser {\n     fn parse_meta_seq() -> ~[@ast::meta_item] {\n         ret self.parse_seq(token::LPAREN, token::RPAREN,\n                            seq_sep_trailing_disallowed(token::COMMA),\n-                           {|p| p.parse_meta_item()}).node;\n+                           |p| p.parse_meta_item()).node;\n     }\n \n     fn parse_optional_meta() -> ~[@ast::meta_item] {"}, {"sha": "3fbb16b5574b1e736a4c4009681eeb2293f6194e", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -173,8 +173,8 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = @interner::mk::<@str>(\n-        {|x|str::hash(*x)},\n-        {|x,y|str::eq(*x, *y)}\n+        |x| str::hash(*x),\n+        |x,y| str::eq(*x, *y)\n     );\n     let rdr = lexer::new_low_level_string_reader\n         (span_diagnostic, codemap::new_filemap(path, src, 0u, 0u), itr);"}, {"sha": "883aedb75a63d5fc6b97db340fff3b59dce142ba", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -12,7 +12,7 @@ fn eval_crate_directives(cx: ctx,\n                          prefix: str,\n                          &view_items: ~[@ast::view_item],\n                          &items: ~[@ast::item]) {\n-    for cdirs.each {|sub_cdir|\n+    for cdirs.each |sub_cdir| {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }"}, {"sha": "e42ba7fe18713eeb96067eef2738be9c18c9ebee", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -162,7 +162,7 @@ class parser {\n     fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n         let inputs = do self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n-            seq_sep_trailing_disallowed(token::COMMA)) { |p|\n+            seq_sep_trailing_disallowed(token::COMMA)) |p| {\n             let mode = p.parse_arg_mode();\n             let name = if is_plain_ident(p.token)\n                 && p.look_ahead(1u) == token::COLON {\n@@ -188,7 +188,7 @@ class parser {\n \n     fn parse_ty_methods() -> ~[ty_method] {\n         do self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n-                                 seq_sep_none()) { |p|\n+                                    seq_sep_none()) |p| {\n             let attrs = p.parse_outer_attributes();\n             let flo = p.span.lo;\n             let pur = p.parse_fn_purity();\n@@ -220,7 +220,7 @@ class parser {\n     // otherwise, fail\n     fn ident_index(args: ~[arg], i: ident) -> uint {\n         let mut j = 0u;\n-        for args.each {|a| if a.ident == i { ret j; } j += 1u; }\n+        for args.each |a| { if a.ident == i { ret j; } j += 1u; }\n         self.fatal(\"unbound variable `\" + *i + \"` in constraint arg\");\n     }\n \n@@ -256,7 +256,7 @@ class parser {\n         let args = self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA),\n-            {|p| p.parse_constr_arg(fn_args)});\n+            |p| p.parse_constr_arg(fn_args));\n         ret @spanned(lo, self.span.hi,\n                      {path: path, args: args, id: self.get_id()});\n     }\n@@ -267,7 +267,7 @@ class parser {\n         let args: ~[@ty_constr_arg] = self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA),\n-            {|p| p.parse_type_constr_arg()});\n+            |p| p.parse_type_constr_arg());\n         let hi = self.span.lo;\n         let tc: ty_constr_ = {path: path, args: args, id: self.get_id()};\n         ret @spanned(lo, hi, tc);\n@@ -286,7 +286,7 @@ class parser {\n     }\n \n     fn parse_type_constraints() -> ~[@ty_constr] {\n-        ret self.parse_constrs({|p| p.parse_constr_in_type()});\n+        ret self.parse_constrs(|p| p.parse_constr_in_type());\n     }\n \n     fn parse_ret_ty() -> (ret_style, @ty) {\n@@ -397,7 +397,7 @@ class parser {\n             let elems = self.parse_unspanned_seq(\n                 token::LBRACE, token::RBRACE,\n                 seq_sep_trailing_allowed(token::COMMA),\n-                {|p| p.parse_ty_field()});\n+                |p| p.parse_ty_field());\n             if vec::len(elems) == 0u {\n                 self.unexpected_last(token::RBRACE);\n             }\n@@ -495,11 +495,11 @@ class parser {\n     }\n \n     fn parse_arg_or_capture_item() -> arg_or_capture_item {\n-        self.parse_capture_item_or({|p| p.parse_arg() })\n+        self.parse_capture_item_or(|p| p.parse_arg())\n     }\n \n     fn parse_fn_block_arg() -> arg_or_capture_item {\n-        do self.parse_capture_item_or {|p|\n+        do self.parse_capture_item_or |p| {\n             let m = p.parse_arg_mode();\n             let i = p.parse_value_ident();\n             let t = if p.eat(token::COLON) {\n@@ -594,8 +594,8 @@ class parser {\n     }\n \n     fn parse_path_without_tps() -> @path {\n-        self.parse_path_without_tps_({|p| p.parse_ident()},\n-                                     {|p| p.parse_ident()})\n+        self.parse_path_without_tps_(|p| p.parse_ident(),\n+                                     |p| p.parse_ident())\n     }\n \n     fn parse_path_without_tps_(\n@@ -623,8 +623,8 @@ class parser {\n     }\n \n     fn parse_value_path() -> @path {\n-        self.parse_path_without_tps_({|p| p.parse_ident()},\n-                                     {|p| p.parse_value_ident()})\n+        self.parse_path_without_tps_(|p| p.parse_ident(),\n+                                     |p| p.parse_value_ident())\n     }\n \n     fn parse_path_with_tps(colons: bool) -> @path {\n@@ -658,7 +658,7 @@ class parser {\n         let tps = {\n             if self.token == token::LT {\n                 self.parse_seq_lt_gt(some(token::COMMA),\n-                                     {|p| p.parse_ty(false)})\n+                                     |p| p.parse_ty(false))\n             } else {\n                 {node: ~[], span: path.span}\n             }\n@@ -820,7 +820,7 @@ class parser {\n             let mutbl = self.parse_mutability();\n             let es = self.parse_seq_to_end(\n                 token::RBRACKET, seq_sep_trailing_allowed(token::COMMA),\n-                {|p| p.parse_expr()});\n+                |p| p.parse_expr());\n             hi = self.span.hi;\n             ex = expr_vec(es, mutbl);\n         } else if self.token == token::POUND\n@@ -968,10 +968,10 @@ class parser {\n             let es =\n                 if self.token == token::LPAREN {\n                     self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                             sep, {|p| p.parse_expr()})\n+                                             sep, |p| p.parse_expr())\n                 } else {\n                     self.parse_unspanned_seq(token::LBRACKET, token::RBRACKET,\n-                                             sep, {|p| p.parse_expr()})\n+                                             sep, |p| p.parse_expr())\n                 };\n             let hi = self.span.hi;\n             e = some(self.mk_expr(lo, hi, expr_vec(es, m_imm)));\n@@ -1019,7 +1019,7 @@ class parser {\n                     let tys = if self.eat(token::MOD_SEP) {\n                         self.expect(token::LT);\n                         self.parse_seq_to_gt(some(token::COMMA),\n-                                             {|p| p.parse_ty(false)})\n+                                             |p| p.parse_ty(false))\n                     } else { ~[] };\n                     e = self.mk_pexpr(lo, hi, expr_field(self.to_expr(e),\n                                                          self.get_str(i),\n@@ -1036,7 +1036,7 @@ class parser {\n                 let es = self.parse_unspanned_seq(\n                     token::LPAREN, token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    {|p| p.parse_expr()});\n+                    |p| p.parse_expr());\n                 hi = self.span.hi;\n \n                 let nd = expr_call(self.to_expr(e), es, false);\n@@ -1095,7 +1095,7 @@ class parser {\n                 vec::append(\n                     self.parse_seq_to_before_end(\n                         ket, seq_sep_none(),\n-                        {|p| p.parse_token_tree()}),\n+                        |p| p.parse_token_tree()),\n                     ~[parse_tt_flat(self, true)])))\n           }\n           _ { parse_tt_flat(self, false) }\n@@ -1106,7 +1106,7 @@ class parser {\n     fn parse_tt_mac_demo() -> @expr {\n         let ms = self.parse_seq(token::LBRACE, token::RBRACE,\n                                 common::seq_sep_none(),\n-                                {|p| p.parse_matcher(@mut 0u)}).node;\n+                                |p| p.parse_matcher(@mut 0u)).node;\n         let tt = self.parse_token_tree();\n         alt tt {\n           tt_delim(tts) {\n@@ -1131,7 +1131,7 @@ class parser {\n             self.bump();\n             let ms = (self.parse_seq(token::LPAREN, token::RPAREN,\n                                      common::seq_sep_none(),\n-                                     {|p| p.parse_matcher(name_idx)}).node);\n+                                     |p| p.parse_matcher(name_idx)).node);\n             if ms.len() == 0u {\n                 self.fatal(\"repetition body must be nonempty\");\n             }\n@@ -1350,7 +1350,7 @@ class parser {\n         // the future, just have to change parse_arg to parse_fn_block_arg.\n         let (decl, capture_clause) =\n             self.parse_fn_decl(impure_fn,\n-                               {|p| p.parse_arg_or_capture_item()});\n+                               |p| p.parse_arg_or_capture_item());\n \n         let body = self.parse_block();\n         ret self.mk_expr(lo, body.span.hi,\n@@ -1367,15 +1367,15 @@ class parser {\n \n     // `|args| { ... }` like in `do` expressions\n     fn parse_lambda_block_expr() -> @expr {\n-        self.parse_lambda_expr_({||\n+        self.parse_lambda_expr_(|| {\n             let blk = self.parse_block();\n             self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk))\n         })\n     }\n \n     // `|args| expr`\n     fn parse_lambda_expr() -> @expr {\n-        self.parse_lambda_expr_({|| self.parse_expr()})\n+        self.parse_lambda_expr_(|| self.parse_expr())\n     }\n \n     fn parse_lambda_expr_(parse_body: fn&() -> @expr) -> @expr {\n@@ -1645,7 +1645,7 @@ class parser {\n                         args = self.parse_unspanned_seq(\n                             token::LPAREN, token::RPAREN,\n                             seq_sep_trailing_disallowed(token::COMMA),\n-                            {|p| p.parse_pat()});\n+                            |p| p.parse_pat());\n                         hi = self.span.hi;\n                       }\n                     }\n@@ -1891,7 +1891,7 @@ class parser {\n \n     fn parse_ty_params() -> ~[ty_param] {\n         if self.eat(token::LT) {\n-            self.parse_seq_to_gt(some(token::COMMA), {|p| p.parse_ty_param()})\n+            self.parse_seq_to_gt(some(token::COMMA), |p| p.parse_ty_param())\n         } else { ~[] }\n     }\n \n@@ -1913,7 +1913,7 @@ class parser {\n         let mut constrs = ~[];\n         if self.token == token::COLON {\n             self.bump();\n-            constrs = self.parse_constrs({|p| p.parse_ty_constr(inputs) });\n+            constrs = self.parse_constrs(|p| p.parse_ty_constr(inputs));\n         }\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ret ({inputs: inputs,\n@@ -1931,7 +1931,7 @@ class parser {\n                 self.parse_unspanned_seq(\n                     token::BINOP(token::OR), token::BINOP(token::OR),\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    {|p| p.parse_fn_block_arg()})\n+                    |p| p.parse_fn_block_arg())\n             }\n         };\n         let output = if self.eat(token::RARROW) {\n@@ -1966,7 +1966,7 @@ class parser {\n \n     fn parse_item_fn(purity: purity) -> item_info {\n         let t = self.parse_fn_header();\n-        let (decl, _) = self.parse_fn_decl(purity, {|p| p.parse_arg()});\n+        let (decl, _) = self.parse_fn_decl(purity, |p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         (t.ident, item_fn(decl, t.tps, body), some(inner_attrs))\n     }\n@@ -1991,7 +1991,7 @@ class parser {\n         let lo = self.span.lo, pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n         let tps = self.parse_ty_params();\n-        let (decl, _) = self.parse_fn_decl(pur, {|p| p.parse_arg()});\n+        let (decl, _) = self.parse_fn_decl(pur, |p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         let attrs = vec::append(attrs, inner_attrs);\n         @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n@@ -2066,7 +2066,7 @@ class parser {\n \n         @{span: s, global: false, idents: ~[i],\n           rp: a_r,\n-          types: vec::map(typarams, {|tp|\n+          types: vec::map(typarams, |tp| {\n               @{id: self.get_id(),\n                 node: ty_path(ident_to_path(s, tp.ident), self.get_id()),\n                 span: s}})\n@@ -2081,7 +2081,7 @@ class parser {\n     fn parse_iface_ref_list() -> ~[@iface_ref] {\n         self.parse_seq_to_before_end(\n             token::LBRACE, seq_sep_trailing_disallowed(token::COMMA),\n-            {|p| p.parse_iface_ref()})\n+            |p| p.parse_iface_ref())\n     }\n \n     fn parse_item_class() -> item_info {\n@@ -2108,7 +2108,7 @@ class parser {\n               members(mms) { ms = vec::append(ms, mms); }\n             }\n         }\n-        let actual_dtor = do option::map(the_dtor) {|dtor|\n+        let actual_dtor = do option::map(the_dtor) |dtor| {\n             let (d_body, d_s) = dtor;\n             {node: {id: self.get_id(),\n                     self_id: self.get_id(),\n@@ -2151,7 +2151,7 @@ class parser {\n     fn parse_ctor(result_ty: ast::ty_) -> class_contents {\n         // FIXME (#2660): Can ctors/dtors have attrs?\n         let lo = self.last_span.lo;\n-        let (decl_, _) = self.parse_fn_decl(impure_fn, {|p| p.parse_arg()});\n+        let (decl_, _) = self.parse_fn_decl(impure_fn, |p| p.parse_arg());\n         let decl = {output: @{id: self.get_id(),\n                               node: result_ty, span: decl_.output.span}\n                     with decl_};\n@@ -2253,7 +2253,7 @@ class parser {\n                              purity: purity) -> @foreign_item {\n         let lo = self.last_span.lo;\n         let t = self.parse_fn_header();\n-        let (decl, _) = self.parse_fn_decl(purity, {|p| p.parse_arg()});\n+        let (decl, _) = self.parse_fn_decl(purity, |p| p.parse_arg());\n         let mut hi = self.span.hi;\n         self.expect(token::SEMI);\n         ret @{ident: t.ident,\n@@ -2368,8 +2368,8 @@ class parser {\n                 let arg_tys = self.parse_unspanned_seq(\n                     token::LPAREN, token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    {|p| p.parse_ty(false)});\n-                for arg_tys.each {|ty|\n+                    |p| p.parse_ty(false));\n+                for arg_tys.each |ty| {\n                     vec::push(args, {ty: ty, id: self.get_id()});\n                 }\n             } else if self.eat(token::EQ) {\n@@ -2515,7 +2515,7 @@ class parser {\n                     let idents = self.parse_unspanned_seq(\n                         token::LBRACE, token::RBRACE,\n                         seq_sep_trailing_allowed(token::COMMA),\n-                        {|p| p.parse_path_list_ident()});\n+                        |p| p.parse_path_list_ident());\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n                                  rp: none, types: ~[]};"}, {"sha": "a5d119d898607c2a0a8c8b0525a847815db5e7a7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -238,10 +238,10 @@ in positions that might otherwise contain _value identifiers_.\n \"]\n fn keyword_table() -> hashmap<str, ()> {\n     let keywords = str_hash();\n-    for contextual_keyword_table().each_key {|word|\n+    for contextual_keyword_table().each_key |word| {\n         keywords.insert(word, ());\n     }\n-    for restricted_keyword_table().each_key {|word|\n+    for restricted_keyword_table().each_key |word| {\n         keywords.insert(word, ());\n     }\n     keywords\n@@ -263,7 +263,7 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n         /* temp */\n         \"sep\", \"many\", \"at_least_one\", \"parse\"\n     ];\n-    for keys.each {|word|\n+    for keys.each |word| {\n         words.insert(word, ());\n     }\n     words\n@@ -301,7 +301,7 @@ fn restricted_keyword_table() -> hashmap<str, ()> {\n         \"unchecked\", \"unsafe\",\n         \"while\"\n     ];\n-    for keys.each {|word|\n+    for keys.each |word| {\n         words.insert(word, ());\n     }\n     words"}, {"sha": "05e959c332120849042306c22b6434e5e33ea575", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -105,7 +105,7 @@ fn typarams_to_str(tps: ~[ast::ty_param]) -> str {\n }\n \n fn path_to_str(&&p: @ast::path) -> str {\n-    ret to_str(p, {|a,b|print_path(a, b, false)});\n+    ret to_str(p, |a,b| print_path(a, b, false));\n }\n \n fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n@@ -260,7 +260,7 @@ fn synth_comment(s: ps, text: str) {\n fn commasep<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n-    for elts.each {|elt|\n+    for elts.each |elt| {\n         if first { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n     }\n@@ -273,7 +273,7 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n     let mut i = 0u;\n-    for elts.each {|elt|\n+    for elts.each |elt| {\n         maybe_print_comment(s, get_span(elt).hi);\n         op(s, elt);\n         i += 1u;\n@@ -294,19 +294,19 @@ fn commasep_exprs(s: ps, b: breaks, exprs: ~[@ast::expr]) {\n \n fn print_mod(s: ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for _mod.view_items.each {|vitem|\n+    for _mod.view_items.each |vitem| {\n         print_view_item(s, vitem);\n     }\n-    for _mod.items.each {|item| print_item(s, item); }\n+    for _mod.items.each |item| { print_item(s, item); }\n }\n \n fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n                      attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for nmod.view_items.each {|vitem|\n+    for nmod.view_items.each |vitem| {\n         print_view_item(s, vitem);\n     }\n-    for nmod.items.each {|item| print_foreign_item(s, item); }\n+    for nmod.items.each |item| { print_foreign_item(s, item); }\n }\n \n fn print_region(s: ps, region: @ast::region) {\n@@ -481,7 +481,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n             end(s);\n         } else {\n             bopen(s);\n-            for variants.each {|v|\n+            for variants.each |v| {\n                 space_if_not_bol(s);\n                 maybe_print_comment(s, v.span.lo);\n                 print_outer_attributes(s, v.node.attrs);\n@@ -501,8 +501,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_type_params(s, tps);\n           if vec::len(ifaces) != 0u {\n               word_space(s, \":\");\n-              commasep(s, inconsistent, ifaces, {|s, p|\n-                  print_path(s, p.path, false)});\n+              commasep(s, inconsistent, ifaces, |s, p|\n+                  print_path(s, p.path, false));\n           }\n           bopen(s);\n           hardbreak_if_not_bol(s);\n@@ -511,13 +511,13 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_fn_args_and_ret(s, ctor.node.dec, ~[]);\n           space(s.s);\n           print_block(s, ctor.node.body);\n-          do option::iter(m_dtor) {|dtor|\n+          do option::iter(m_dtor) |dtor| {\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, dtor.span.lo);\n             head(s, \"drop\");\n             print_block(s, dtor.node.body);\n           }\n-          for items.each {|ci|\n+          for items.each |ci| {\n                   /*\n                      FIXME (#1893): collect all private items and print\n                      them in a single \"priv\" section\n@@ -565,7 +565,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_region_param(s, rp);\n         print_type_params(s, tps);\n         space(s.s);\n-        option::iter(ifce, {|p|\n+        option::iter(ifce, |p| {\n             word_nbsp(s, \"of\");\n             print_path(s, p.path, false);\n             space(s.s);\n@@ -574,7 +574,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_type(s, ty);\n         space(s.s);\n         bopen(s);\n-        for methods.each {|meth|\n+        for methods.each |meth| {\n            print_method(s, meth);\n         }\n         bclose(s, item.span);\n@@ -586,7 +586,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_type_params(s, tps);\n         word(s.s, \" \");\n         bopen(s);\n-        for methods.each {|meth| print_ty_method(s, meth); }\n+        for methods.each |meth| { print_ty_method(s, meth); }\n         bclose(s, item.span);\n       }\n     }\n@@ -632,7 +632,7 @@ fn print_method(s: ps, meth: @ast::method) {\n \n fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n-    for attrs.each {|attr|\n+    for attrs.each |attr| {\n         alt attr.node.style {\n           ast::attr_outer { print_attribute(s, attr); count += 1; }\n           _ {/* fallthrough */ }\n@@ -643,7 +643,7 @@ fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n \n fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n-    for attrs.each {|attr|\n+    for attrs.each |attr| {\n         alt attr.node.style {\n           ast::attr_inner {\n             print_attribute(s, attr);\n@@ -719,8 +719,8 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n \n     print_inner_attributes(s, attrs);\n \n-    for blk.node.view_items.each {|vi| print_view_item(s, vi); }\n-    for blk.node.stmts.each {|st|\n+    for blk.node.view_items.each |vi| { print_view_item(s, vi); }\n+    for blk.node.stmts.each |st| {\n         print_stmt(s, *st);\n     }\n     alt blk.node.expr {\n@@ -796,7 +796,7 @@ fn print_mac(s: ps, m: ast::mac) {\n           some(@{node: ast::expr_vec(_, _), _}) { }\n           _ { word(s.s, \" \"); }\n         }\n-        option::iter(arg, {|a|print_expr(s, a)});\n+        option::iter(arg, |a| print_expr(s, a));\n         // FIXME: extension 'body' (#2339)\n       }\n       ast::mac_embed_type(ty) {\n@@ -943,12 +943,12 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_maybe_parens_discrim(s, expr);\n         space(s.s);\n         bopen(s);\n-        for arms.each {|arm|\n+        for arms.each |arm| {\n             space(s.s);\n             cbox(s, alt_indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n-            for arm.pats.each {|p|\n+            for arm.pats.each |p| {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n@@ -1135,8 +1135,8 @@ fn print_decl(s: ps, decl: @ast::decl) {\n         word_nbsp(s, \"let\");\n \n         // if any are mut, all are mut\n-        if vec::any(locs, {|l| l.node.is_mutbl }) {\n-            assert vec::all(locs, {|l| l.node.is_mutbl });\n+        if vec::any(locs, |l| l.node.is_mutbl) {\n+            assert vec::all(locs, |l| l.node.is_mutbl);\n             word_nbsp(s, \"mut\");\n         }\n \n@@ -1176,7 +1176,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n-    for path.idents.each {|id|\n+    for path.idents.each |id| {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, *id);\n     }\n@@ -1278,7 +1278,7 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     if cap_items.is_not_empty() {\n         let mut first = decl.inputs.is_empty();\n-        for cap_items.each { |cap_item|\n+        for cap_items.each |cap_item| {\n             if first { first = false; } else { word_space(s, \",\"); }\n             if cap_item.is_move { word_nbsp(s, \"move\") }\n             else { word_nbsp(s, \"copy\") }\n@@ -1292,7 +1292,7 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n     popen(s);\n     print_fn_args(s, decl, cap_items);\n     pclose(s);\n-    word(s.s, constrs_str(decl.constraints, {|c|\n+    word(s.s, constrs_str(decl.constraints, |c| {\n         ast_fn_constr_to_str(decl, c)\n     }));\n \n@@ -1336,7 +1336,7 @@ fn print_arg_mode(s: ps, m: ast::mode) {\n fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n     if vec::len(*bounds) > 0u {\n         word(s.s, \":\");\n-        for vec::each(*bounds) {|bound|\n+        for vec::each(*bounds) |bound| {\n             nbsp(s);\n             alt bound {\n               ast::bound_copy { word(s.s, \"copy\"); }\n@@ -1404,7 +1404,7 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n       ast::view_path_list(path, idents, _) {\n         print_path(s, path, false);\n         word(s.s, \"::{\");\n-        do commasep(s, inconsistent, idents) {|s, w|\n+        do commasep(s, inconsistent, idents) |s, w| {\n             word(s.s, *w.node.name)\n         }\n         word(s.s, \"}\");\n@@ -1627,7 +1627,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n       }\n       comments::isolated {\n         pprust::hardbreak_if_not_bol(s);\n-        for cmnt.lines.each {|line|\n+        for cmnt.lines.each |line| {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n             if str::is_not_empty(line) { word(s.s, line); }\n@@ -1641,7 +1641,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            for cmnt.lines.each {|line|\n+            for cmnt.lines.each |line| {\n                 if str::is_not_empty(line) { word(s.s, line); }\n                 hardbreak(s.s);\n             }\n@@ -1691,7 +1691,7 @@ fn constr_args_to_str<T>(f: fn@(T) -> str,\n    str {\n     let mut comma = false;\n     let mut s = \"(\";\n-    for args.each {|a|\n+    for args.each |a| {\n         if comma { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str::<T>(f, a.node);\n     }\n@@ -1719,7 +1719,7 @@ fn ast_ty_fn_constr_to_str(&&c: @ast::constr) -> str {\n }\n \n fn ast_fn_constr_to_str(decl: ast::fn_decl, &&c: @ast::constr) -> str {\n-    let arg_to_str = {|a|fn_arg_idx_to_str(decl, a)};\n+    let arg_to_str = |a| fn_arg_idx_to_str(decl, a);\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(arg_to_str, c.node.args);\n }\n@@ -1734,7 +1734,7 @@ fn ty_constr_to_str(&&c: @ast::ty_constr) -> str {\n \n fn constrs_str<T>(constrs: ~[T], elt: fn(T) -> str) -> str {\n     let mut s = \"\", colon = true;\n-    for constrs.each {|c|\n+    for constrs.each |c| {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += elt(c);\n     }"}, {"sha": "48f2e57de1ca01362d5ab8653e7618fb46c93a70", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 76, "deletions": 81, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -64,22 +64,22 @@ type visitor<E> =\n       visit_class_item: fn@(@class_member, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n-    ret @{visit_mod: {|a,b,c,d,e|visit_mod::<E>(a, b, c, d, e)},\n-          visit_view_item: {|a,b,c|visit_view_item::<E>(a, b, c)},\n-          visit_foreign_item: {|a,b,c|visit_foreign_item::<E>(a, b, c)},\n-          visit_item: {|a,b,c|visit_item::<E>(a, b, c)},\n-          visit_local: {|a,b,c|visit_local::<E>(a, b, c)},\n-          visit_block: {|a,b,c|visit_block::<E>(a, b, c)},\n-          visit_stmt: {|a,b,c|visit_stmt::<E>(a, b, c)},\n-          visit_arm: {|a,b,c|visit_arm::<E>(a, b, c)},\n-          visit_pat: {|a,b,c|visit_pat::<E>(a, b, c)},\n-          visit_decl: {|a,b,c|visit_decl::<E>(a, b, c)},\n-          visit_expr: {|a,b,c|visit_expr::<E>(a, b, c)},\n-          visit_ty: {|a,b,c|skip_ty::<E>(a, b, c)},\n-          visit_ty_params: {|a,b,c|visit_ty_params::<E>(a, b, c)},\n-          visit_constr: {|a,b,c,d,e|visit_constr::<E>(a, b, c, d, e)},\n-          visit_fn: {|a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g)},\n-          visit_class_item: {|a,b,c|visit_class_item::<E>(a, b, c)}};\n+    ret @{visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n+          visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n+          visit_foreign_item: |a,b,c|visit_foreign_item::<E>(a, b, c),\n+          visit_item: |a,b,c|visit_item::<E>(a, b, c),\n+          visit_local: |a,b,c|visit_local::<E>(a, b, c),\n+          visit_block: |a,b,c|visit_block::<E>(a, b, c),\n+          visit_stmt: |a,b,c|visit_stmt::<E>(a, b, c),\n+          visit_arm: |a,b,c|visit_arm::<E>(a, b, c),\n+          visit_pat: |a,b,c|visit_pat::<E>(a, b, c),\n+          visit_decl: |a,b,c|visit_decl::<E>(a, b, c),\n+          visit_expr: |a,b,c|visit_expr::<E>(a, b, c),\n+          visit_ty: |a,b,c|skip_ty::<E>(a, b, c),\n+          visit_ty_params: |a,b,c|visit_ty_params::<E>(a, b, c),\n+          visit_constr: |a,b,c,d,e|visit_constr::<E>(a, b, c, d, e),\n+          visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n+          visit_class_item: |a,b,c|visit_class_item::<E>(a, b, c)};\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -90,7 +90,7 @@ fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n     alt cd.node {\n       cdir_src_mod(_, _) { }\n       cdir_dir_mod(_, cdirs, _) {\n-        for cdirs.each {|cdir|\n+        for cdirs.each |cdir| {\n             visit_crate_directive(cdir, e, v);\n         }\n       }\n@@ -100,8 +100,8 @@ fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n }\n \n fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n-    for m.view_items.each {|vi| v.visit_view_item(vi, e, v); }\n-    for m.items.each {|i| v.visit_item(i, e, v); }\n+    for m.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n+    for m.items.each |i| { v.visit_item(i, e, v); }\n }\n \n fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n@@ -122,43 +122,43 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n       item_foreign_mod(nm) {\n-        for nm.view_items.each {|vi| v.visit_view_item(vi, e, v); }\n-        for nm.items.each {|ni| v.visit_foreign_item(ni, e, v); }\n+        for nm.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n+        for nm.items.each |ni| { v.visit_foreign_item(ni, e, v); }\n       }\n       item_ty(t, tps, rp) {\n         v.visit_ty(t, e, v);\n         v.visit_ty_params(tps, e, v);\n       }\n       item_enum(variants, tps, _) {\n         v.visit_ty_params(tps, e, v);\n-        for variants.each {|vr|\n-            for vr.node.args.each {|va| v.visit_ty(va.ty, e, v); }\n+        for variants.each |vr| {\n+            for vr.node.args.each |va| { v.visit_ty(va.ty, e, v); }\n         }\n       }\n       item_impl(tps, _rp, ifce, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n-        option::iter(ifce, {|p| visit_path(p.path, e, v)});\n+        option::iter(ifce, |p| visit_path(p.path, e, v));\n         v.visit_ty(ty, e, v);\n-        for methods.each {|m|\n+        for methods.each |m| {\n             visit_method_helper(m, e, v)\n         }\n       }\n       item_class(tps, ifaces, members, ctor, m_dtor, _) {\n           v.visit_ty_params(tps, e, v);\n-          for members.each {|m|\n+          for members.each |m| {\n              v.visit_class_item(m, e, v);\n           }\n-          for ifaces.each {|p| visit_path(p.path, e, v); }\n+          for ifaces.each |p| { visit_path(p.path, e, v); }\n           visit_class_ctor_helper(ctor, i.ident, tps,\n                                   ast_util::local_def(i.id), e, v);\n-          do option::iter(m_dtor) {|dtor|\n+          do option::iter(m_dtor) |dtor| {\n                   visit_class_dtor_helper(dtor, tps,\n                      ast_util::local_def(i.id), e, v)};\n       }\n       item_iface(tps, _rp, methods) {\n         v.visit_ty_params(tps, e, v);\n-        for methods.each {|m|\n-            for m.decl.inputs.each {|a| v.visit_ty(a.ty, e, v); }\n+        for methods.each |m| {\n+            for m.decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n             v.visit_ty_params(m.tps, e, v);\n             v.visit_ty(m.decl.output, e, v);\n         }\n@@ -186,12 +186,12 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         v.visit_ty(mt.ty, e, v);\n       }\n       ty_rec(flds) {\n-        for flds.each {|f| v.visit_ty(f.node.mt.ty, e, v); }\n+        for flds.each |f| { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n-      ty_tup(ts) { for ts.each {|tt| v.visit_ty(tt, e, v); } }\n+      ty_tup(ts) { for ts.each |tt| { v.visit_ty(tt, e, v); } }\n       ty_fn(_, decl) {\n-        for decl.inputs.each {|a| v.visit_ty(a.ty, e, v); }\n-        for decl.constraints.each {|c|\n+        for decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n+        for decl.constraints.each |c| {\n             v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n         }\n         v.visit_ty(decl.output, e, v);\n@@ -202,7 +202,7 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n       }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n-        for cs.each {|tc|\n+        for cs.each |tc| {\n             v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n         }\n       }\n@@ -220,26 +220,26 @@ fn visit_constr<E>(_operator: @path, _sp: span, _id: node_id, _e: E,\n }\n \n fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n-    for p.types.each {|tp| v.visit_ty(tp, e, v); }\n+    for p.types.each |tp| { v.visit_ty(tp, e, v); }\n }\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n       pat_enum(path, children) {\n         visit_path(path, e, v);\n-        do option::iter(children) {|children|\n-                for children.each {|child| v.visit_pat(child, e, v); }}\n+        do option::iter(children) |children| {\n+            for children.each |child| { v.visit_pat(child, e, v); }}\n       }\n       pat_rec(fields, _) {\n-        for fields.each {|f| v.visit_pat(f.pat, e, v); }\n+          for fields.each |f| { v.visit_pat(f.pat, e, v); }\n       }\n-      pat_tup(elts) { for elts.each {|elt| v.visit_pat(elt, e, v); } }\n+      pat_tup(elts) { for elts.each |elt| { v.visit_pat(elt, e, v); } }\n       pat_box(inner) | pat_uniq(inner) {\n         v.visit_pat(inner, e, v);\n       }\n       pat_ident(path, inner) {\n           visit_path(path, e, v);\n-          do option::iter(inner) {|subpat| v.visit_pat(subpat, e, v)};\n+          do option::iter(inner) |subpat| { v.visit_pat(subpat, e, v)};\n       }\n       pat_lit(ex) { v.visit_expr(ex, e, v); }\n       pat_range(e1, e2) { v.visit_expr(e1, e, v); v.visit_expr(e2, e, v); }\n@@ -257,8 +257,8 @@ fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n }\n \n fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n-    for tps.each {|tp|\n-        for vec::each(*tp.bounds) {|bound|\n+    for tps.each |tp| {\n+        for vec::each(*tp.bounds) |bound| {\n             alt bound {\n               bound_iface(t) { v.visit_ty(t, e, v); }\n               bound_copy | bound_send | bound_const { }\n@@ -268,8 +268,8 @@ fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n }\n \n fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n-    for fd.inputs.each {|a| v.visit_ty(a.ty, e, v); }\n-    for fd.constraints.each {|c|\n+    for fd.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n+    for fd.constraints.each |c| {\n         v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n     }\n     v.visit_ty(fd.output, e, v);\n@@ -311,8 +311,8 @@ fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n }\n \n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n-    for b.node.view_items.each {|vi| v.visit_view_item(vi, e, v); }\n-    for b.node.stmts.each {|s| v.visit_stmt(s, e, v); }\n+    for b.node.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n+    for b.node.stmts.each |s| { v.visit_stmt(s, e, v); }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n@@ -327,7 +327,7 @@ fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     alt d.node {\n       decl_local(locs) {\n-        for locs.each {|loc| v.visit_local(loc, e, v); }\n+        for locs.each |loc| { v.visit_local(loc, e, v); }\n       }\n       decl_item(it) { v.visit_item(it, e, v); }\n     }\n@@ -338,13 +338,13 @@ fn visit_expr_opt<E>(eo: option<@expr>, e: E, v: vt<E>) {\n }\n \n fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n-    for exprs.each {|ex| v.visit_expr(ex, e, v); }\n+    for exprs.each |ex| { v.visit_expr(ex, e, v); }\n }\n \n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     alt m.node {\n       ast::mac_invoc(pth, arg, body) {\n-        option::map(arg, {|arg| v.visit_expr(arg, e, v)}); }\n+        option::map(arg, |arg| v.visit_expr(arg, e, v)); }\n       ast::mac_invoc_tt(pth, tt) { /* no user-serviceable parts inside */ }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n       ast::mac_embed_block(blk) { v.visit_block(blk, e, v); }\n@@ -363,10 +363,10 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_vstore(x, _) { v.visit_expr(x, e, v); }\n       expr_vec(es, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n-        for flds.each {|f| v.visit_expr(f.node.expr, e, v); }\n+        for flds.each |f| { v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n-      expr_tup(elts) { for elts.each {|el| v.visit_expr(el, e, v); } }\n+      expr_tup(elts) { for elts.each |el| { v.visit_expr(el, e, v); } }\n       expr_call(callee, args, _) {\n         visit_exprs(args, e, v);\n         v.visit_expr(callee, e, v);\n@@ -393,7 +393,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_loop(b) { v.visit_block(b, e, v); }\n       expr_alt(x, arms, _) {\n         v.visit_expr(x, e, v);\n-        for arms.each {|a| v.visit_arm(a, e, v); }\n+        for arms.each |a| { v.visit_arm(a, e, v); }\n       }\n       expr_fn(proto, decl, body, cap_clause) {\n         v.visit_fn(fk_anon(proto, cap_clause), decl, body,\n@@ -414,7 +414,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_field(x, _, tys) {\n         v.visit_expr(x, e, v);\n-        for tys.each {|tp| v.visit_ty(tp, e, v); }\n+        for tys.each |tp| { v.visit_ty(tp, e, v); }\n       }\n       expr_index(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_path(p) { visit_path(p, e, v); }\n@@ -431,7 +431,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n }\n \n fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n-    for a.pats.each {|p| v.visit_pat(p, e, v); }\n+    for a.pats.each |p| { v.visit_pat(p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     v.visit_block(a.body, e, v);\n }\n@@ -551,43 +551,38 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_fn(fk, decl, body, sp, id, e, v);\n     }\n     let visit_ty = if v.visit_ty == simple_ignore_ty {\n-        {|a,b,c| skip_ty(a, b, c)}\n+        |a,b,c| skip_ty(a, b, c)\n     } else {\n-        {|a,b,c| v_ty(v.visit_ty, a, b, c)}\n+        |a,b,c| v_ty(v.visit_ty, a, b, c)\n     };\n     fn v_class_item(f: fn@(@class_member),\n                     cm: @class_member, &&e: (),\n                     v: vt<()>) {\n         f(cm);\n         visit_class_item(cm, e, v);\n     }\n-    ret mk_vt(@{visit_mod: {|a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e)},\n-                visit_view_item: {|a,b,c|\n-                    v_view_item(v.visit_view_item, a, b, c)\n-                },\n+    ret mk_vt(@{visit_mod: |a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e),\n+                visit_view_item: |a,b,c|\n+                    v_view_item(v.visit_view_item, a, b, c),\n                 visit_foreign_item:\n-                    {|a,b,c|v_foreign_item(v.visit_foreign_item, a, b, c)},\n-                visit_item: {|a,b,c|v_item(v.visit_item, a, b, c)},\n-                visit_local: {|a,b,c|v_local(v.visit_local, a, b, c)},\n-                visit_block: {|a,b,c|v_block(v.visit_block, a, b, c)},\n-                visit_stmt: {|a,b,c|v_stmt(v.visit_stmt, a, b, c)},\n-                visit_arm: {|a,b,c|v_arm(v.visit_arm, a, b, c)},\n-                visit_pat: {|a,b,c|v_pat(v.visit_pat, a, b, c)},\n-                visit_decl: {|a,b,c|v_decl(v.visit_decl, a, b, c)},\n-                visit_expr: {|a,b,c|v_expr(v.visit_expr, a, b, c)},\n+                    |a,b,c|v_foreign_item(v.visit_foreign_item, a, b, c),\n+                visit_item: |a,b,c|v_item(v.visit_item, a, b, c),\n+                visit_local: |a,b,c|v_local(v.visit_local, a, b, c),\n+                visit_block: |a,b,c|v_block(v.visit_block, a, b, c),\n+                visit_stmt: |a,b,c|v_stmt(v.visit_stmt, a, b, c),\n+                visit_arm: |a,b,c|v_arm(v.visit_arm, a, b, c),\n+                visit_pat: |a,b,c|v_pat(v.visit_pat, a, b, c),\n+                visit_decl: |a,b,c|v_decl(v.visit_decl, a, b, c),\n+                visit_expr: |a,b,c|v_expr(v.visit_expr, a, b, c),\n                 visit_ty: visit_ty,\n-                visit_ty_params: {|a,b,c|\n-                    v_ty_params(v.visit_ty_params, a, b, c)\n-                },\n-                visit_constr: {|a,b,c,d,e|\n-                    v_constr(v.visit_constr, a, b, c, d, e)\n-                },\n-                visit_fn: {|a,b,c,d,e,f,g|\n-                    v_fn(v.visit_fn, a, b, c, d, e, f, g)\n-                },\n-                visit_class_item: {|a,b,c|\n+                visit_ty_params: |a,b,c|\n+                    v_ty_params(v.visit_ty_params, a, b, c),\n+                visit_constr: |a,b,c,d,e|\n+                    v_constr(v.visit_constr, a, b, c, d, e),\n+                visit_fn: |a,b,c,d,e,f,g|\n+                    v_fn(v.visit_fn, a, b, c, d, e, f, g),\n+                visit_class_item: |a,b,c|\n                     v_class_item(v.visit_class_item, a, b, c)\n-                }\n                });\n }\n "}, {"sha": "5603300e0405b7878144c6738a162c38763a09a8", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -69,18 +69,16 @@ mod write {\n               output_type_bitcode {\n                 if opts.optimize != 0u {\n                     let filename = mk_intermediate_name(output, \"no-opt.bc\");\n-                    str::as_c_str(filename,\n-                                {|buf|\n-                                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                                });\n+                    str::as_c_str(filename, |buf| {\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                    });\n                 }\n               }\n               _ {\n                 let filename = mk_intermediate_name(output, \"bc\");\n-                str::as_c_str(filename,\n-                            {|buf|\n-                                llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                            });\n+                str::as_c_str(filename, |buf| {\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                });\n               }\n             }\n         }\n@@ -151,64 +149,67 @@ mod write {\n \n                 let filename = mk_intermediate_name(output, \"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                str::as_c_str(filename,\n-                            {|buf|\n-                                llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                            });\n+                str::as_c_str(filename, |buf| {\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                });\n                 pm = mk_pass_manager();\n                 // Save the assembly file if -S is used\n \n                 if opts.output_type == output_type_assembly {\n                     let _: () = str::as_c_str(\n                         sess.targ_cfg.target_strs.target_triple,\n-                        {|buf_t|\n-                            str::as_c_str(output, {|buf_o|\n+                        |buf_t| {\n+                            str::as_c_str(output, |buf_o| {\n                                 llvm::LLVMRustWriteOutputFile(\n                                     pm.llpm,\n                                     llmod,\n                                     buf_t,\n                                     buf_o,\n                                     lib::llvm::AssemblyFile as c_uint,\n                                     CodeGenOptLevel,\n-                                    true)})});\n+                                    true)\n+                            })\n+                        });\n                 }\n \n \n                 // Save the object file for -c or --save-temps alone\n                 // This .o is needed when an exe is built\n                 if opts.output_type == output_type_object ||\n                        opts.output_type == output_type_exe {\n-                    let _: () =\n-                        str::as_c_str(\n-                            sess.targ_cfg.target_strs.target_triple,\n-                            {|buf_t|\n-                                str::as_c_str(output, {|buf_o|\n-                                    llvm::LLVMRustWriteOutputFile(\n-                                        pm.llpm,\n-                                        llmod,\n-                                        buf_t,\n-                                        buf_o,\n-                                        lib::llvm::ObjectFile as c_uint,\n-                                        CodeGenOptLevel,\n-                                        true)})});\n-                }\n-            } else {\n-                // If we aren't saving temps then just output the file\n-                // type corresponding to the '-c' or '-S' flag used\n-\n-                let _: () =\n-                    str::as_c_str(\n+                    let _: () = str::as_c_str(\n                         sess.targ_cfg.target_strs.target_triple,\n-                        {|buf_t|\n-                            str::as_c_str(output, {|buf_o|\n+                        |buf_t| {\n+                            str::as_c_str(output, |buf_o| {\n                                 llvm::LLVMRustWriteOutputFile(\n                                     pm.llpm,\n                                     llmod,\n                                     buf_t,\n                                     buf_o,\n-                                    FileType as c_uint,\n+                                    lib::llvm::ObjectFile as c_uint,\n                                     CodeGenOptLevel,\n-                                    true)})});\n+                                    true)\n+                            })\n+                        });\n+                }\n+            } else {\n+                // If we aren't saving temps then just output the file\n+                // type corresponding to the '-c' or '-S' flag used\n+\n+                let _: () = str::as_c_str(\n+                    sess.targ_cfg.target_strs.target_triple,\n+                    |buf_t| {\n+                        str::as_c_str(output, |buf_o| {\n+                            llvm::LLVMRustWriteOutputFile(\n+                                pm.llpm,\n+                                llmod,\n+                                buf_t,\n+                                buf_o,\n+                                FileType as c_uint,\n+                                CodeGenOptLevel,\n+                                true)\n+                        })\n+                    });\n             }\n             // Clean up and return\n \n@@ -219,14 +220,14 @@ mod write {\n \n         if opts.output_type == output_type_llvm_assembly {\n             // Given options \"-S --emit-llvm\": output LLVM assembly\n-            str::as_c_str(output, {|buf_o|\n+            str::as_c_str(output, |buf_o| {\n                 llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o)});\n         } else {\n             // If only a bitcode file is asked for by using the '--emit-llvm'\n             // flag, then output it here\n             llvm::LLVMRunPassManager(pm.llpm, llmod);\n             str::as_c_str(output,\n-                        {|buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) });\n+                        |buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) );\n         }\n \n         llvm::LLVMDisposeModule(llmod);\n@@ -301,7 +302,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n         let mut cmh_items: ~[@ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n-        for linkage_metas.each {|meta|\n+        for linkage_metas.each |meta| {\n             if *attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n@@ -332,7 +333,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n         let cmh_items = attr::sort_meta_items(metas.cmh_items);\n \n         sha.reset();\n-        for cmh_items.each {|m_|\n+        for cmh_items.each |m_| {\n             let m = m_;\n             alt m.node {\n               ast::meta_name_value(key, value) {\n@@ -347,7 +348,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n             }\n         }\n \n-        for dep_hashes.each {|dh|\n+        for dep_hashes.each |dh| {\n             sha.input_str(len_and_str(*dh));\n         }\n \n@@ -443,7 +444,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n // gas doesn't!\n fn sanitize(s: str) -> str {\n     let mut result = \"\";\n-    do str::chars_iter(s) {|c|\n+    do str::chars_iter(s) |c| {\n         alt c {\n           '@' { result += \"_sbox_\"; }\n           '~' { result += \"_ubox_\"; }\n@@ -479,7 +480,7 @@ fn mangle(ss: path) -> str {\n \n     let mut n = \"_ZN\"; // Begin name-sequence.\n \n-    for ss.each {|s|\n+    for ss.each |s| {\n         alt s { path_name(s) | path_mod(s) {\n           let sani = sanitize(*s);\n           n += #fmt[\"%u%s\", str::len(sani), sani];\n@@ -593,7 +594,7 @@ fn link_binary(sess: session,\n     // # Crate linking\n \n     let cstore = sess.cstore;\n-    for cstore::get_used_crate_files(cstore).each {|cratepath|\n+    for cstore::get_used_crate_files(cstore).each |cratepath| {\n         if str::ends_with(cratepath, \".rlib\") {\n             vec::push(cc_args, cratepath);\n             cont;\n@@ -606,7 +607,7 @@ fn link_binary(sess: session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each {|arg| vec::push(cc_args, arg); }\n+    for ula.each |arg| { vec::push(cc_args, arg); }\n \n     // # Native library linking\n \n@@ -617,11 +618,11 @@ fn link_binary(sess: session,\n     // forces to make sure that library can be found at runtime.\n \n     let addl_paths = sess.opts.addl_lib_search_paths;\n-    for addl_paths.each {|path| vec::push(cc_args, \"-L\" + path); }\n+    for addl_paths.each |path| { vec::push(cc_args, \"-L\" + path); }\n \n     // The names of the native libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each {|l| vec::push(cc_args, \"-l\" + l); }\n+    for used_libs.each |l| { vec::push(cc_args, \"-l\" + l); }\n \n     if sess.building_library {\n         vec::push(cc_args, lib_cmd);"}, {"sha": "55e4ba8d0823c094c9d94c8552d021d9c0413488", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -45,7 +45,7 @@ fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::path {\n }\n \n fn rpaths_to_flags(rpaths: ~[str]) -> ~[str] {\n-    vec::map(rpaths, { |rpath| #fmt(\"-Wl,-rpath,%s\",rpath)})\n+    vec::map(rpaths, |rpath| #fmt(\"-Wl,-rpath,%s\",rpath) )\n }\n \n fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n@@ -55,7 +55,7 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n     #debug(\"sysroot: %s\", sysroot);\n     #debug(\"output: %s\", output);\n     #debug(\"libs:\");\n-    for libs.each {|libpath|\n+    for libs.each |libpath| {\n         #debug(\"    %s\", libpath);\n     }\n     #debug(\"target_triple: %s\", target_triple);\n@@ -74,7 +74,7 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n \n     fn log_rpaths(desc: str, rpaths: ~[str]) {\n         #debug(\"%s rpaths:\", desc);\n-        for rpaths.each {|rpath|\n+        for rpaths.each |rpath| {\n             #debug(\"    %s\", rpath);\n         }\n     }\n@@ -96,7 +96,7 @@ fn get_rpaths_relative_to_output(os: session::os,\n                                  cwd: path::path,\n                                  output: path::path,\n                                  libs: ~[path::path]) -> ~[str] {\n-    vec::map(libs, {|a|\n+    vec::map(libs, |a| {\n         check not_win32(os);\n         get_rpath_relative_to_output(os, cwd, output, a)\n     })\n@@ -142,7 +142,7 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n     }\n \n     let mut path = ~[];\n-    for uint::range(start_idx, len1 - 1u) {|_i| vec::push(path, \"..\"); };\n+    for uint::range(start_idx, len1 - 1u) |_i| { vec::push(path, \"..\"); };\n \n     vec::push_all(path, vec::view(split2, start_idx, len2 - 1u));\n \n@@ -154,7 +154,7 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n }\n \n fn get_absolute_rpaths(cwd: path::path, libs: ~[path::path]) -> ~[str] {\n-    vec::map(libs, {|a|get_absolute_rpath(cwd, a)})\n+    vec::map(libs, |a| get_absolute_rpath(cwd, a) )\n }\n \n fn get_absolute_rpath(cwd: path::path, &&lib: path::path) -> str {\n@@ -185,7 +185,7 @@ fn get_install_prefix_rpath(cwd: path::path, target_triple: str) -> str {\n fn minimize_rpaths(rpaths: ~[str]) -> ~[str] {\n     let set = map::str_hash::<()>();\n     let mut minimized = ~[];\n-    for rpaths.each {|rpath|\n+    for rpaths.each |rpath| {\n         if !set.contains_key(rpath) {\n             vec::push(minimized, rpath);\n             set.insert(rpath, ());"}, {"sha": "b7ee7008d2f5b124f9fd44d0eb65cc6fd45d840b", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -36,15 +36,15 @@ fn declare_upcalls(targ_cfg: @session::config,\n             tys: ~[TypeRef], rv: TypeRef) ->\n        ValueRef {\n         let mut arg_tys: ~[TypeRef] = ~[];\n-        for tys.each {|t| vec::push(arg_tys, t); }\n+        for tys.each |t| { vec::push(arg_tys, t); }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }\n     fn nothrow(f: ValueRef) -> ValueRef {\n         base::set_no_unwind(f); f\n     }\n-    let d = {|a,b,c|decl(llmod, \"upcall_\", a, b, c)};\n-    let dv = {|a,b|decl(llmod, \"upcall_\", a, b, T_void())};\n+    let d = |a,b,c| decl(llmod, \"upcall_\", a, b, c);\n+    let dv = |a,b| decl(llmod, \"upcall_\", a, b, T_void());\n \n     let int_t = T_int(targ_cfg);\n     let size_t = T_size_t(targ_cfg);"}, {"sha": "a90d960717c8b6cefd8f184626acdb439b49b6a7", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 94, "deletions": 75, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -82,7 +82,7 @@ fn parse_cfgspecs(cfgspecs: ~[str]) -> ast::crate_cfg {\n     // varieties of meta_item here. At the moment we just support the\n     // meta_word variant.\n     let mut words = ~[];\n-    for cfgspecs.each {|s| vec::push(words, attr::mk_word_item(@s)); }\n+    for cfgspecs.each |s| { vec::push(words, attr::mk_word_item(@s)); }\n     ret words;\n }\n \n@@ -131,95 +131,111 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     -> {crate: @ast::crate, tcx: option<ty::ctxt>} {\n     let time_passes = sess.time_passes();\n     let mut crate = time(time_passes, \"parsing\",\n-                         {||parse_input(sess, cfg, input)});\n+                         ||parse_input(sess, cfg, input) );\n     if upto == cu_parse { ret {crate: crate, tcx: none}; }\n \n     sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n \n-    crate =\n-        time(time_passes, \"configuration\",\n-             {|copy crate|front::config::strip_unconfigured_items(crate)});\n-    crate =\n-        time(time_passes, \"maybe building test harness\",\n-             {|copy crate|front::test::modify_for_testing(sess, crate)});\n-    crate =\n-        time(time_passes, \"expansion\",\n-             {|copy crate|syntax::ext::expand::expand_crate(\n-                 sess.parse_sess, sess.opts.cfg, crate)});\n+    crate = time(time_passes, \"configuration\", |copy crate| {\n+        front::config::strip_unconfigured_items(crate)\n+    });\n+\n+    crate = time(time_passes, \"maybe building test harness\", |copy crate| {\n+        front::test::modify_for_testing(sess, crate)\n+    });\n+\n+    crate = time(time_passes, \"expansion\", |copy crate| {\n+        syntax::ext::expand::expand_crate(\n+            sess.parse_sess, sess.opts.cfg, crate)\n+    });\n \n     if upto == cu_expand { ret {crate: crate, tcx: none}; }\n \n-    crate =\n-        time(time_passes, \"intrinsic injection\", {|copy crate|\n-            front::intrinsic_inject::inject_intrinsic(sess, crate)\n-        });\n+    crate = time(time_passes, \"intrinsic injection\", |copy crate| {\n+        front::intrinsic_inject::inject_intrinsic(sess, crate)\n+    });\n \n-    crate =\n-        time(time_passes, \"core injection\", {|copy crate|\n-            front::core_inject::maybe_inject_libcore_ref(sess, crate)\n-        });\n+    crate = time(time_passes, \"core injection\", |copy crate| {\n+        front::core_inject::maybe_inject_libcore_ref(sess, crate)\n+    });\n \n-    time(time_passes, \"building warning settings table\", {|copy crate|\n+    time(time_passes, \"building warning settings table\", |copy crate| {\n         lint::build_settings_crate(sess, crate)\n     });\n \n-    let ast_map =\n-        time(time_passes, \"ast indexing\", {|copy crate|\n+    let ast_map = time(time_passes, \"ast indexing\", |copy crate| {\n             syntax::ast_map::map_crate(sess.diagnostic(), *crate)\n         });\n-    time(time_passes, \"external crate/lib resolution\", {|copy crate|\n+\n+    time(time_passes, \"external crate/lib resolution\", |copy crate| {\n         creader::read_crates(\n             sess.diagnostic(), *crate, sess.cstore,\n             sess.filesearch,\n             session::sess_os_to_meta_os(sess.targ_cfg.os),\n             sess.opts.static)\n     });\n-    let {def_map, exp_map, impl_map} =\n-        time(time_passes, \"resolution\", {|copy crate|\n-            resolve::resolve_crate(sess, ast_map, crate)\n-        });\n-    let freevars =\n-        time(time_passes, \"freevar finding\", {|copy crate|\n-            freevars::annotate_freevars(def_map, crate)\n-        });\n-    let region_map =\n-        time(time_passes, \"region resolution\", {|copy crate|\n-            middle::region::resolve_crate(sess, def_map, crate)\n-        });\n+\n+    let { def_map, exp_map, impl_map\n+        } = time(time_passes, \"resolution\", |copy crate| {\n+        resolve::resolve_crate(sess, ast_map, crate)\n+    });\n+\n+    let freevars = time(time_passes, \"freevar finding\", |copy crate| {\n+        freevars::annotate_freevars(def_map, crate)\n+    });\n+\n+    let region_map = time(time_passes, \"region resolution\", |copy crate| {\n+        middle::region::resolve_crate(sess, def_map, crate)\n+    });\n+\n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars, region_map);\n-    let (method_map, vtable_map) =\n-        time(time_passes, \"typechecking\", {|copy crate|\n-            typeck::check_crate(ty_cx, impl_map, crate)\n-        });\n-    time(time_passes, \"const checking\", {|copy crate|\n+\n+    let ( method_map, vtable_map\n+        ) = time(time_passes, \"typechecking\", |copy crate| {\n+        typeck::check_crate(ty_cx, impl_map, crate)\n+    });\n+\n+    time(time_passes, \"const checking\", |copy crate| {\n         middle::check_const::check_crate(\n             sess, crate, ast_map, def_map, method_map, ty_cx)\n     });\n \n     if upto == cu_typeck { ret {crate: crate, tcx: some(ty_cx)}; }\n \n-    time(time_passes, \"block-use checking\",\n-         {|copy crate|middle::block_use::check_crate(ty_cx, crate)});\n-    time(time_passes, \"loop checking\",\n-         {|copy crate|middle::check_loop::check_crate(ty_cx, crate)});\n-    time(time_passes, \"alt checking\",\n-         {|copy crate|middle::check_alt::check_crate(ty_cx, crate)});\n-    let last_use_map =\n-        time(time_passes, \"liveness checking\", {|copy crate|\n-            middle::liveness::check_crate(ty_cx, method_map, crate)\n-        });\n-    time(time_passes, \"typestate checking\",\n-         {|copy crate|middle::tstate::ck::check_crate(ty_cx, crate)});\n-    let (root_map, mutbl_map) = time(\n-        time_passes, \"borrow checking\",\n-        {|copy crate|middle::borrowck::check_crate(ty_cx, method_map,\n-                                         last_use_map, crate)});\n-    time(time_passes, \"kind checking\", {|copy crate|\n+    time(time_passes, \"block-use checking\", |copy crate| {\n+        middle::block_use::check_crate(ty_cx, crate)\n+    });\n+\n+    time(time_passes, \"loop checking\", |copy crate| {\n+        middle::check_loop::check_crate(ty_cx, crate)\n+    });\n+\n+    time(time_passes, \"alt checking\", |copy crate| {\n+        middle::check_alt::check_crate(ty_cx, crate)\n+    });\n+\n+    let last_use_map = time(time_passes, \"liveness checking\", |copy crate| {\n+        middle::liveness::check_crate(ty_cx, method_map, crate)\n+    });\n+\n+    time(time_passes, \"typestate checking\", |copy crate| {\n+        middle::tstate::ck::check_crate(ty_cx, crate)\n+    });\n+\n+    let ( root_map, mutbl_map\n+        ) = time(time_passes, \"borrow checking\", |copy crate| {\n+        middle::borrowck::check_crate(ty_cx, method_map,\n+                                      last_use_map, crate)\n+    });\n+\n+    time(time_passes, \"kind checking\", |copy crate| {\n         kind::check_crate(ty_cx, method_map, last_use_map, crate)\n     });\n-    time(time_passes, \"lint checking\",\n-         {|copy crate|lint::check_crate(ty_cx, crate)});\n+\n+    time(time_passes, \"lint checking\", |copy crate| {\n+        lint::check_crate(ty_cx, crate)\n+    });\n \n     if upto == cu_no_trans { ret {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n@@ -229,23 +245,26 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 impl_map: impl_map, method_map: method_map,\n                 vtable_map: vtable_map};\n \n-    let (llmod, link_meta) =\n-        time(time_passes, \"translation\",\n-             {|copy crate|trans::base::trans_crate(\n-                 sess, crate, ty_cx, outputs.obj_filename,\n-                 exp_map, maps)});\n-    time(time_passes, \"LLVM passes\",\n-         {||link::write::run_passes(sess, llmod, outputs.obj_filename)});\n+    let (llmod, link_meta) = time(time_passes, \"translation\", |copy crate| {\n+        trans::base::trans_crate(sess, crate, ty_cx, outputs.obj_filename,\n+                                 exp_map, maps)\n+    });\n+\n+    time(time_passes, \"LLVM passes\", || {\n+        link::write::run_passes(sess, llmod, outputs.obj_filename)\n+    });\n \n     let stop_after_codegen =\n         sess.opts.output_type != link::output_type_exe ||\n             sess.opts.static && sess.building_library;\n \n     if stop_after_codegen { ret {crate: crate, tcx: some(ty_cx)}; }\n \n-    time(time_passes, \"linking\",\n-         {||link::link_binary(sess, outputs.obj_filename,\n-                              outputs.out_filename, link_meta)});\n+    time(time_passes, \"linking\", || {\n+        link::link_binary(sess, outputs.obj_filename,\n+                          outputs.out_filename, link_meta)\n+    });\n+\n     ret {crate: crate, tcx: some(ty_cx)};\n }\n \n@@ -313,7 +332,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     let ann = alt ppm {\n       ppm_typed {\n         {pre: ann_paren_for_expr,\n-         post: {|a|ann_typed_post(option::get(tcx), a)}}\n+         post: |a| ann_typed_post(option::get(tcx), a) }\n       }\n       ppm_identified | ppm_expanded_identified {\n         {pre: ann_paren_for_expr, post: ann_identified_post}\n@@ -322,7 +341,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     };\n     let is_expanded = upto != cu_parse;\n     let src = codemap::get_filemap(sess.codemap, source_name(input)).src;\n-    do io::with_str_reader(*src) { |rdr|\n+    do io::with_str_reader(*src) |rdr| {\n         pprust::print_crate(sess.codemap, sess.span_diagnostic, crate,\n                             source_name(input),\n                             rdr, io::stdout(), ann, is_expanded);\n@@ -417,7 +436,7 @@ fn build_session_options(match: getopts::match,\n     let lint_flags = vec::append(getopts::opt_strs(match, \"W\"),\n                                  getopts::opt_strs(match, \"warn\"));\n     let lint_dict = lint::get_lint_dict();\n-    let lint_opts = do vec::map(lint_flags) {|flag|\n+    let lint_opts = do vec::map(lint_flags) |flag| {\n         alt lint::lookup_lint(lint_dict, flag) {\n           (flag, none) {\n             early_error(demitter, #fmt(\"unknown warning: %s\", flag))\n@@ -429,9 +448,9 @@ fn build_session_options(match: getopts::match,\n     let mut debugging_opts = 0u;\n     let debug_flags = getopts::opt_strs(match, \"Z\");\n     let debug_map = session::debugging_opts_map();\n-    for debug_flags.each { |debug_flag|\n+    for debug_flags.each |debug_flag| {\n         let mut this_bit = 0u;\n-        for debug_map.each { |pair|\n+        for debug_map.each |pair| {\n             let (name, _, bit) = pair;\n             if name == debug_flag { this_bit = bit; break; }\n         }"}, {"sha": "e7661f40b2646c20fa9f0ecfb12f11321857b29c", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -80,7 +80,7 @@ Options:\n fn describe_warnings() {\n     let lint_dict = lint::get_lint_dict();\n     let mut max_key = 0u;\n-    for lint_dict.each_key {|k| max_key = uint::max(k.len(), max_key); }\n+    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n     fn padded(max: uint, s: str) -> str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n@@ -89,7 +89,7 @@ fn describe_warnings() {\n                      padded(max_key, \"name\"), \"default\", \"meaning\"));\n     io::println(#fmt(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, \"----\"), \"-------\", \"-------\"));\n-    for lint_dict.each {|k, v|\n+    for lint_dict.each |k, v| {\n         let k = str::replace(k, \"_\", \"-\");\n         io::println(#fmt(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n@@ -103,7 +103,7 @@ fn describe_warnings() {\n \n fn describe_debug_flags() {\n     io::println(#fmt(\"\\nAvailable debug options:\\n\"));\n-    for session::debugging_opts_map().each { |pair|\n+    for session::debugging_opts_map().each |pair| {\n         let (name, desc, _) = pair;\n         io::println(#fmt(\"    -Z%-20s -- %s\", name, desc));\n     }\n@@ -169,7 +169,7 @@ fn run_compiler(args: ~[str], demitter: diagnostic::emitter) {\n     let pretty =\n         option::map(getopts::opt_default(match, \"pretty\",\n                                          \"normal\"),\n-                    {|a|parse_pretty(sess, a)});\n+                    |a| parse_pretty(sess, a) );\n     alt pretty {\n       some::<pp_mode>(ppm) { pretty_print_input(sess, cfg, input, ppm); ret; }\n       none::<pp_mode> {/* continue */ }\n@@ -211,7 +211,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n     let p = comm::port();\n     let ch = comm::chan(p);\n \n-    alt do task::try  {||\n+    alt do task::try  || {\n \n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n@@ -248,7 +248,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n                     \"try running with RUST_LOG=rustc=0,::rt::backtrace \\\n                      to get further details and report the results \\\n                      to github.com/mozilla/rust/issues\"\n-                ]/_.each {|note|\n+                ]/_.each |note| {\n                     diagnostic::emit(none, note, diagnostic::note)\n                 }\n             }\n@@ -259,7 +259,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n }\n \n fn main(args: ~[str]) {\n-    do monitor {|demitter|\n+    do monitor |demitter| {\n         run_compiler(args, demitter);\n     }\n }"}, {"sha": "9db9147ecafa8b60cc4283a75d7e227317c59711", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -13,7 +13,7 @@ type ctxt = @{\n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n-    do strip_items(crate) {|attrs|\n+    do strip_items(crate) |attrs| {\n         in_cfg(crate.node.config, attrs)\n     }\n }\n@@ -24,9 +24,9 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     let ctxt = @{in_cfg: in_cfg};\n \n     let precursor =\n-        @{fold_mod: {|a,b|fold_mod(ctxt, a, b)},\n-          fold_block: fold::wrap({|a,b|fold_block(ctxt, a, b)}),\n-          fold_foreign_mod: {|a,b|fold_foreign_mod(ctxt, a, b)}\n+        @{fold_mod: |a,b| fold_mod(ctxt, a, b),\n+          fold_block: fold::wrap(|a,b| fold_block(ctxt, a, b) ),\n+          fold_foreign_mod: |a,b| fold_foreign_mod(ctxt, a, b)\n           with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n@@ -41,7 +41,7 @@ fn filter_item(cx: ctxt, &&item: @ast::item) ->\n \n fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n-    let filter = {|a|filter_item(cx, a)};\n+    let filter = |a| filter_item(cx, a);\n     let filtered_items = vec::filter_map(m.items, filter);\n     ret {view_items: vec::map(m.view_items, fld.fold_view_item),\n          items: vec::map(filtered_items, fld.fold_item)};\n@@ -56,7 +56,7 @@ fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n \n fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n                    fld: fold::ast_fold) -> ast::foreign_mod {\n-    let filter = {|a|filter_foreign_item(cx, a)};\n+    let filter = |a| filter_foreign_item(cx, a);\n     let filtered_items = vec::filter_map(nm.items, filter);\n     ret {view_items: vec::map(nm.view_items, fld.fold_view_item),\n          items: filtered_items};\n@@ -81,7 +81,7 @@ fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n \n fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n-    let filter = {|a|filter_stmt(cx, a)};\n+    let filter = |a| filter_stmt(cx, a);\n     let filtered_stmts = vec::filter_map(b.stmts, filter);\n     ret {view_items: b.view_items,\n          stmts: vec::map(filtered_stmts, fld.fold_stmt),\n@@ -113,12 +113,12 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n     let cfg_metas = vec::concat(vec::filter_map(cfg_metas,\n-        {|&&i| attr::get_meta_item_list(i)}));\n+        |&&i| attr::get_meta_item_list(i) ));\n \n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n     if !has_cfg_metas { ret true; }\n \n-    for cfg_metas.each {|cfg_mi|\n+    for cfg_metas.each |cfg_mi| {\n         if attr::contains(cfg, cfg_mi) { ret true; }\n     }\n "}, {"sha": "ce101a5ce4e76e37e140ddb2e2f6ba40e08fdc08", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -45,9 +45,9 @@ fn generate_test_harness(sess: session::session,\n           testfns: dvec()};\n \n     let precursor =\n-        @{fold_crate: fold::wrap({|a,b|fold_crate(cx, a, b)}),\n-          fold_item: {|a,b|fold_item(cx, a, b)},\n-          fold_mod: {|a,b|fold_mod(cx, a, b)} with *fold::default_ast_fold()};\n+        @{fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),\n+          fold_item: |a,b| fold_item(cx, a, b),\n+          fold_mod: |a,b| fold_mod(cx, a, b) with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);\n@@ -57,7 +57,7 @@ fn generate_test_harness(sess: session::session,\n fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    do config::strip_items(crate) {|attrs|\n+    do config::strip_items(crate) |attrs| {\n         !attr::contains_name(attr::attr_metas(attrs), \"test\")\n     }\n }\n@@ -147,7 +147,7 @@ fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n-        {|&&i| attr::get_meta_item_list(i)}));\n+        |&&i| attr::get_meta_item_list(i) ));\n     ret if vec::is_not_empty(ignoreitems) {\n         config::metas_in_cfg(cx.crate.node.config, cfg_metas)\n     } else {\n@@ -278,7 +278,7 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     #debug(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    for cx.testfns.each {|test|\n+    for cx.testfns.each |test| {\n         vec::push(descs, mk_test_desc_rec(cx, test));\n     }\n "}, {"sha": "60bb9c57f1cf7721555bc4863dceed9c6df3120d", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -1029,7 +1029,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n                tys: ~[TypeRef]) -> str {\n         let mut s: str = \"\";\n         let mut first: bool = true;\n-        for tys.each {|t|\n+        for tys.each |t| {\n             if first { first = false; } else { s += \", \"; }\n             s += type_to_str_inner(names, outer, t);\n         }\n@@ -1079,7 +1079,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n       }\n       Pointer {\n         let mut i: uint = 0u;\n-        for outer0.each {|tout|\n+        for outer0.each |tout| {\n             i += 1u;\n             if tout as int == ty as int {\n                 let n: uint = vec::len::<TypeRef>(outer0) - i;\n@@ -1133,7 +1133,7 @@ type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n fn mk_target_data(string_rep: str) -> target_data {\n     let lltd =\n-        str::as_c_str(string_rep, {|buf| llvm::LLVMCreateTargetData(buf) });\n+        str::as_c_str(string_rep, |buf| llvm::LLVMCreateTargetData(buf) );\n     ret {lltd: lltd, dtor: @target_data_res(lltd)};\n }\n "}, {"sha": "99df3c79f74b63ac605e952746c6c2b3fdea2a6e", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -128,7 +128,7 @@ fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n \n fn hash_path(&&s: str) -> uint {\n     let mut h = 5381u;\n-    for str::each(s) {|ch| h = (h << 5u) + h ^ (ch as uint); }\n+    for str::each(s) |ch| { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n "}, {"sha": "8f920e6bbbe6525de1f883d86d36011d45837f81", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -31,8 +31,8 @@ fn read_crates(diag: span_handler, crate: ast::crate,\n               mut next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n-                                       {|a|visit_view_item(e, a)},\n-                                   visit_item: {|a|visit_item(e, a)}\n+                                       |a| visit_view_item(e, a),\n+                                   visit_item: |a| visit_item(e, a)\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);\n@@ -48,14 +48,14 @@ type cache_entry = {\n \n fn dump_crates(crate_cache: dvec<cache_entry>) {\n     #debug(\"resolved crates:\");\n-    for crate_cache.each {|entry|\n+    for crate_cache.each |entry| {\n         #debug(\"cnum: %?\", entry.cnum);\n         #debug(\"span: %?\", entry.span);\n         #debug(\"hash: %?\", entry.hash);\n         let attrs = ~[\n             attr::mk_attr(attr::mk_list_item(@\"link\", *entry.metas))\n         ];\n-        for attr::find_linkage_attrs(attrs).each {|attr|\n+        for attr::find_linkage_attrs(attrs).each |attr| {\n             #debug(\"meta: %s\", pprust::attr_to_str(attr));\n         }\n     }\n@@ -68,7 +68,7 @@ fn warn_if_multiple_versions(diag: span_handler,\n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(*crate_cache.last().metas);\n         let {lefts: matches, rights: non_matches} =\n-            partition(crate_cache.map_to_vec({|entry|\n+            partition(crate_cache.map_to_vec(|entry| {\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {\n                     left(entry)\n@@ -82,7 +82,7 @@ fn warn_if_multiple_versions(diag: span_handler,\n         if matches.len() != 1u {\n             diag.handler().warn(\n                 #fmt(\"using multiple versions of crate `%s`\", *name));\n-            for matches.each {|match|\n+            for matches.each |match| {\n                 diag.span_note(match.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(@\"link\", *match.metas))\n@@ -147,7 +147,7 @@ fn visit_item(e: env, i: @ast::item) {\n             e.diag.span_fatal(i.span, \"library '\" + *foreign_name +\n                               \"' already added: can't specify link_args.\");\n         }\n-        for link_args.each {|a|\n+        for link_args.each |a| {\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) {\n                 cstore::add_used_link_args(cstore, *linkarg);\n@@ -178,7 +178,7 @@ fn metas_with_ident(ident: ast::ident,\n fn existing_match(e: env, metas: ~[@ast::meta_item], hash: str) ->\n     option<int> {\n \n-    for e.crate_cache.each {|c|\n+    for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || *c.hash == hash) {\n             ret some(c.cnum);\n@@ -246,7 +246,7 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let cnum_map = int_hash::<ast::crate_num>();\n-    for decoder::get_crate_deps(cdata).each {|dep|\n+    for decoder::get_crate_deps(cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cmetas = metas_with(dep.vers, @\"vers\", ~[]);"}, {"sha": "700913498e90f164eb7bc9e5ed59082d8bafda93", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -42,7 +42,7 @@ fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n                path: ~[ast::ident]) -> ~[ast::def] {\n     let mut result = ~[];\n     #debug(\"lookup_defs: path = %? cnum = %?\", path, cnum);\n-    for resolve_path(cstore, cnum, path).each {|elt|\n+    for resolve_path(cstore, cnum, path).each |elt| {\n         let (c, data, def) = elt;\n         vec::push(result, decoder::lookup_def(c, data, def));\n     }\n@@ -66,7 +66,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     #debug(\"resolve_path %s in crates[%d]:%s\",\n            ast_util::path_name_i(path), cnum, cm.name);\n     let mut result = ~[];\n-    for decoder::resolve_path(path, cm.data).each {|def|\n+    for decoder::resolve_path(path, cm.data).each |def| {\n         if def.crate == ast::local_crate {\n             vec::push(result, (cnum, cm.data, def));\n         } else {\n@@ -120,7 +120,7 @@ fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n                      name: option<ast::ident>)\n     -> @~[@decoder::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    do decoder::get_impls_for_mod(cdata, def.node, name) {|cnum|\n+    do decoder::get_impls_for_mod(cdata, def.node, name) |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n     }\n }\n@@ -151,13 +151,13 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     #debug(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n-                           {|| #fmt(\"get_field_type: class ID %? not found\",\n-                     class_id)});\n+                           || #fmt(\"get_field_type: class ID %? not found\",\n+                                   class_id) );\n     #debug(\"looking up %? : %?\", def, class_doc);\n     let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n-        {|| #fmt(\"get_field_type: in class %?, field ID %? not found\",\n-                 class_id, def)});\n+        || #fmt(\"get_field_type: in class %?, field ID %? not found\",\n+                 class_id, def) );\n     #debug(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ret {bounds: @~[], rp: ast::rp_none, ty: ty};"}, {"sha": "f912dd92a4a3b3a36d0bc2672474b14cada2052a", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -96,7 +96,7 @@ fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> @str {\n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n                   data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n-    do vec::iter(decoder::get_crate_module_paths(data.data)) {|dp|\n+    do vec::iter(decoder::get_crate_module_paths(data.data)) |dp| {\n         let (did, path) = dp;\n         let d = {crate: cnum, node: did.node};\n         p(cstore).mod_path_map.insert(d, @path);\n@@ -108,7 +108,7 @@ fn have_crate_data(cstore: cstore, cnum: ast::crate_num) -> bool {\n }\n \n fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n-    for p(cstore).metas.each {|k,v| i(k, v);};\n+    for p(cstore).metas.each |k,v| { i(k, v);};\n }\n \n fn add_used_crate_file(cstore: cstore, lib: str) {\n@@ -157,7 +157,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[@str] {\n     type crate_hash = {name: @str, hash: @str};\n     let mut result = ~[];\n \n-    for p(cstore).use_crate_map.each_value {|cnum|\n+    for p(cstore).use_crate_map.each_value |cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         #debug(\"Add hash[%s]: %s\", cdata.name, *hash);\n@@ -168,7 +168,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[@str] {\n     }\n     let sorted = std::sort::merge_sort(lteq, result);\n     #debug(\"sorted:\");\n-    for sorted.each {|x|\n+    for sorted.each |x| {\n         #debug(\"  hash[%s]: %s\", *x.name, *x.hash);\n     }\n     fn mapper(ch: crate_hash) -> @str { ret ch.hash; }\n@@ -178,7 +178,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[@str] {\n fn get_path(cstore: cstore, d: ast::def_id) -> ~[ast::ident] {\n     // let f = bind str::split_str(_, \"::\");\n     option::map_default(p(cstore).mod_path_map.find(d), ~[],\n-                        {|ds| str::split_str(*ds, \"::\").map({|x|@x})})\n+                        |ds| str::split_str(*ds, \"::\").map(|x| @x ) )\n }\n // Local Variables:\n // mode: rust"}, {"sha": "d069b4046bcd230e5c4b67bd9cde4b013161eb56", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -64,7 +64,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@(~[u8]) -> bool, hash: uint) ->\n \n     let mut result: ~[ebml::doc] = ~[];\n     let belt = tag_index_buckets_bucket_elt;\n-    do ebml::tagged_docs(bucket, belt) {|elt|\n+    do ebml::tagged_docs(bucket, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n             vec::push(result, ebml::doc_at(d.data, pos).doc);\n@@ -77,7 +77,7 @@ fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n     fn eq_item(bytes: ~[u8], item_id: int) -> bool {\n         ret io::u64_from_be_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n-    let eqer = {|a|eq_item(a, item_id)};\n+    let eqer = |a| eq_item(a, item_id);\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n     if vec::len(found) == 0u {\n         ret option::none::<ebml::doc>;\n@@ -110,7 +110,7 @@ fn item_symbol(item: ebml::doc) -> str {\n \n fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n     let mut found = none;\n-    do ebml::tagged_docs(d, tag_items_data_parent_item) {|did|\n+    do ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n         found = some(parse_def_id(ebml::doc_data(did)));\n     }\n     found\n@@ -123,25 +123,26 @@ fn class_member_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n \n fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n-    option::map_default(ebml::maybe_get_doc(d, tag_class_mut),\n-                  ast::class_immutable,\n-                  {|d|\n-                  alt ebml::doc_as_u8(d) as char {\n-                    'm' { ast::class_mutable }\n-                    _   { ast::class_immutable }\n-                  }\n-                  })\n+    option::map_default(\n+        ebml::maybe_get_doc(d, tag_class_mut),\n+        ast::class_immutable,\n+        |d| {\n+            alt ebml::doc_as_u8(d) as char {\n+              'm' { ast::class_mutable }\n+              _   { ast::class_immutable }\n+            }\n+        })\n }\n \n fn variant_disr_val(d: ebml::doc) -> option<int> {\n-    do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) {|val_doc|\n+    do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n         int::parse_buf(ebml::doc_data(val_doc), 10u)\n     }\n }\n \n fn doc_type(doc: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = ebml::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, {|did|\n+    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, |did| {\n         translate_def_id(cdata, did)\n     })\n }\n@@ -157,7 +158,7 @@ fn item_type(item_id: ast::def_id, item: ebml::doc,\n fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> option<ty::t> {\n     let mut result = none;\n-    do ebml::tagged_docs(item, tag_impl_iface) {|ity|\n+    do ebml::tagged_docs(item, tag_impl_iface) |ity| {\n         result = some(doc_type(ity, tcx, cdata));\n     };\n     result\n@@ -166,8 +167,8 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    do ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n-        let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n+    do ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+        let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n             translate_def_id(cdata, did)\n         });\n         vec::push(bounds, bd);\n@@ -190,14 +191,14 @@ fn item_ty_region_param(item: ebml::doc) -> ast::region_param {\n fn item_ty_param_count(item: ebml::doc) -> uint {\n     let mut n = 0u;\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n-                      {|_p| n += 1u; });\n+                      |_p| n += 1u );\n     n\n }\n \n fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    do ebml::tagged_docs(item, v) {|p|\n+    do ebml::tagged_docs(item, v) |p| {\n         let ext = parse_def_id(ebml::doc_data(p));\n         vec::push(ids, {crate: cdata.cnum, node: ext.node});\n     };\n@@ -213,10 +214,10 @@ fn resolve_path(path: ~[ast::ident], data: @~[u8]) -> ~[ast::def_id] {\n     let s = ast_util::path_name_i(path);\n     let md = ebml::doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n-    let eqer = {|a|eq_item(a, s)};\n+    let eqer = |a| eq_item(a, s);\n     let mut result: ~[ast::def_id] = ~[];\n     #debug(\"resolve_path: looking up %s\", s);\n-    for lookup_hash(paths, eqer, hash_path(s)).each {|doc|\n+    for lookup_hash(paths, eqer, hash_path(s)).each |doc| {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n     }\n@@ -232,7 +233,7 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     let mut result = ~[];\n     vec::reserve(result, len);\n \n-    do ebml::docs(path_doc) {|tag, elt_doc|\n+    do ebml::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n             vec::push(result, ast_map::path_mod(@str));\n@@ -306,7 +307,7 @@ fn get_impl_method(cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n-    do ebml::tagged_docs(find_item(id, items), tag_item_impl_method) {|mid|\n+    do ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = parse_def_id(ebml::doc_data(mid));\n         if item_name(find_item(m_did.node, items)) == name {\n             found = some(translate_def_id(cdata, m_did));\n@@ -323,7 +324,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n             some(it) { it }\n             none { fail (#fmt(\"get_class_method: class id not found \\\n              when looking up method %s\", *name)) }};\n-    do ebml::tagged_docs(cls_items, tag_item_iface_method) {|mid|\n+    do ebml::tagged_docs(cls_items, tag_item_iface_method) |mid| {\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n             found = some(m_did);\n@@ -343,7 +344,7 @@ fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n             none     { fail (#fmt(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id)); }\n     };\n-    do ebml::tagged_docs(cls_items, tag_item_dtor) {|doc|\n+    do ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n          let doc1 = ebml::get_doc(doc, tag_def_id);\n          let did = parse_def_id(ebml::doc_data(doc1));\n          found = some(translate_def_id(cdata, did));\n@@ -399,15 +400,15 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let mut infos: ~[ty::variant_info] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    for variant_ids.each {|did|\n+    for variant_ids.each |did| {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type({crate: cdata.cnum, node: id}, item,\n                                 tcx, cdata);\n         let name = item_name(item);\n         let mut arg_tys: ~[ty::t] = ~[];\n         alt ty::get(ctor_ty).struct {\n           ty::ty_fn(f) {\n-            for f.inputs.each {|a| vec::push(arg_tys, a.ty); }\n+            for f.inputs.each |a| { vec::push(arg_tys, a.ty); }\n           }\n           _ { /* Nullary enum variant. */ }\n         }\n@@ -429,7 +430,7 @@ type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n     -> ~[@method_info] {\n     let mut rslt = ~[];\n-    do ebml::tagged_docs(item, tag_item_impl_method) {|doc|\n+    do ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         vec::push(rslt, @{did: translate_def_id(cdata, m_did),\n@@ -447,7 +448,7 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n-    do ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n+    do ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n         let did = parse_def_id(ebml::doc_data(doc));\n         let local_did = translate_def_id(cdata, did);\n           // The impl may be defined in a different crate. Ask the caller\n@@ -473,7 +474,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do ebml::tagged_docs(item, tag_item_iface_method) {|mth|\n+    do ebml::tagged_docs(item, tag_item_iface_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n@@ -498,7 +499,7 @@ fn get_class_members(cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do ebml::tagged_docs(item, tag_item_field) {|an_item|\n+    do ebml::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(an_item);\n@@ -520,7 +521,7 @@ pure fn family_to_visibility(family: char) -> ast::visibility {\n \n /* 'g' for public field, 'j' for private field */\n fn get_class_fields(cdata: cmd, id: ast::node_id) -> ~[ty::field_ty] {\n-    get_class_members(cdata, id, {|f| f == 'g' || f == 'j'})\n+    get_class_members(cdata, id, |f| f == 'g' || f == 'j')\n }\n \n fn family_has_type_params(fam_ch: char) -> bool {\n@@ -578,12 +579,12 @@ fn item_family_to_str(fam: char) -> str {\n \n fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n-    do ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n+    do ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         vec::push(items, attr::mk_word_item(@n));\n     };\n-    do ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n+    do ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = str::from_bytes(ebml::doc_data(nd));\n@@ -592,7 +593,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n         // but currently the encoder just drops them\n         vec::push(items, attr::mk_name_value_item_str(@n, v));\n     };\n-    do ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n+    do ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n@@ -605,7 +606,7 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n-        do ebml::tagged_docs(attrs_d, tag_attribute) {|attr_doc|\n+        do ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -622,15 +623,15 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n }\n \n fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n-    for get_meta_items(meta_items).each {|mi|\n+    for get_meta_items(meta_items).each |mi| {\n         out.write_str(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]);\n     }\n }\n \n fn list_crate_attributes(md: ebml::doc, hash: @str, out: io::writer) {\n     out.write_str(#fmt(\"=Crate Attributes (%s)=\\n\", *hash));\n \n-    for get_attributes(md).each {|attr|\n+    for get_attributes(md).each |attr| {\n         out.write_str(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]);\n     }\n \n@@ -652,7 +653,7 @@ fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     fn docstr(doc: ebml::doc, tag_: uint) -> str {\n         str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n     }\n-    do ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n+    do ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         vec::push(deps, {cnum: crate_num,\n                   name: @docstr(depdoc, tag_crate_dep_name),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n@@ -665,7 +666,7 @@ fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n fn list_crate_deps(data: @~[u8], out: io::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n-    for get_crate_deps(data).each {|dep|\n+    for get_crate_deps(data).each |dep| {\n         out.write_str(#fmt[\"%d %s-%s-%s\\n\",\n                            dep.cnum, *dep.name, *dep.hash, *dep.vers]);\n     }\n@@ -691,7 +692,7 @@ fn get_crate_vers(data: @~[u8]) -> @str {\n fn list_crate_items(bytes: @~[u8], md: ebml::doc, out: io::writer) {\n     out.write_str(\"=Items=\\n\");\n     let items = ebml::get_doc(md, tag_items);\n-    do iter_crate_items(bytes) {|path, did|\n+    do iter_crate_items(bytes) |path, did| {\n         out.write_str(#fmt[\"%s (%s)\\n\", path, describe_def(items, did)]);\n     }\n     out.write_str(\"\\n\");\n@@ -702,9 +703,9 @@ fn iter_crate_items(bytes: @~[u8], proc: fn(str, ast::def_id)) {\n     let paths = ebml::get_doc(md, tag_paths);\n     let index = ebml::get_doc(paths, tag_index);\n     let bs = ebml::get_doc(index, tag_index_buckets);\n-    do ebml::tagged_docs(bs, tag_index_buckets_bucket) {|bucket|\n+    do ebml::tagged_docs(bs, tag_index_buckets_bucket) |bucket| {\n         let et = tag_index_buckets_bucket_elt;\n-        do ebml::tagged_docs(bucket, et) {|elt|\n+        do ebml::tagged_docs(bucket, et) |elt| {\n             let data = read_path(elt);\n             let {tag:_, doc:def} = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);\n@@ -723,7 +724,7 @@ fn get_crate_module_paths(bytes: @~[u8]) -> ~[(ast::def_id, str)] {\n     // fowarded path due to renamed import or reexport\n     let mut res = ~[];\n     let mods = map::str_hash();\n-    do iter_crate_items(bytes) {|path, did|\n+    do iter_crate_items(bytes) |path, did| {\n         let m = mod_of_path(path);\n         if str::is_not_empty(m) {\n             // if m has a sub-item, it must be a module\n@@ -734,7 +735,7 @@ fn get_crate_module_paths(bytes: @~[u8]) -> ~[(ast::def_id, str)] {\n         // unified later by using the mods map\n         vec::push(res, (did, path));\n     }\n-    ret do vec::filter(res) {|x|\n+    ret do vec::filter(res) |x| {\n         let (_, xp) = x;\n         mods.contains_key(xp)\n     }"}, {"sha": "0c01414847d20564b38d6bb4e1d8f9d0ca96968f", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -87,20 +87,20 @@ fn encode_name_and_def_id(ebml_w: ebml::writer, nm: ident,\n }\n \n fn encode_region_param(ebml_w: ebml::writer, rp: region_param) {\n-    do ebml_w.wr_tag(tag_region_param) {||\n+    do ebml_w.wr_tag(tag_region_param) || {\n         serialize_region_param(ebml_w, rp)\n     }\n }\n \n fn encode_named_def_id(ebml_w: ebml::writer, name: ident, id: def_id) {\n-    do ebml_w.wr_tag(tag_paths_data_item) {||\n+    do ebml_w.wr_tag(tag_paths_data_item) || {\n         encode_name(ebml_w, name);\n         encode_def_id(ebml_w, id);\n     }\n }\n \n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n-    do ebml_w.wr_tag(tag_class_mut) {||\n+    do ebml_w.wr_tag(tag_class_mut) || {\n         ebml_w.writer.write(&[alt mt { class_immutable { 'i' }\n                 class_mutable { 'm' } } as u8]);\n         }\n@@ -110,9 +110,9 @@ type entry<T> = {val: T, pos: uint};\n \n fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: ~[variant],\n                             path: ~[ident], &index: ~[entry<str>]) {\n-    for variants.each {|variant|\n+    for variants.each |variant| {\n         add_to_index(ebml_w, path, index, variant.node.name);\n-        do ebml_w.wr_tag(tag_paths_data_item) {||\n+        do ebml_w.wr_tag(tag_paths_data_item) || {\n             encode_name(ebml_w, variant.node.name);\n             encode_def_id(ebml_w, local_def(variant.node.id));\n         }\n@@ -130,15 +130,15 @@ fn add_to_index(ebml_w: ebml::writer, path: &[ident], &index: ~[entry<str>],\n \n fn encode_foreign_module_item_paths(ebml_w: ebml::writer, nmod: foreign_mod,\n                                     path: ~[ident], &index: ~[entry<str>]) {\n-    for nmod.items.each {|nitem|\n+    for nmod.items.each |nitem| {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         encode_named_def_id(ebml_w, nitem.ident, local_def(nitem.id));\n     }\n }\n \n fn encode_class_item_paths(ebml_w: ebml::writer,\n      items: ~[@class_member], path: ~[ident], &index: ~[entry<str>]) {\n-    for items.each {|it|\n+    for items.each |it| {\n      alt ast_util::class_member_visibility(it) {\n           private { cont; }\n           public {\n@@ -156,7 +156,7 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             module: _mod, path: ~[ident],\n                             &index: ~[entry<str>]) {\n-    for module.items.each {|it|\n+    for module.items.each |it| {\n         if !reachable(ecx, it.id) ||\n            !ast_util::is_exported(it.ident, module) { cont; }\n         if !ast_util::is_item_impl(it) {\n@@ -170,31 +170,31 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n           }\n           item_mod(_mod) {\n-            do ebml_w.wr_tag(tag_paths_data_mod) {||\n+            do ebml_w.wr_tag(tag_paths_data_mod) || {\n                encode_name_and_def_id(ebml_w, it.ident, it.id);\n                encode_module_item_paths(ebml_w, ecx, _mod,\n                                         vec::append_one(path, it.ident),\n                                         index);\n             }\n           }\n           item_foreign_mod(nmod) {\n-            do ebml_w.wr_tag(tag_paths_data_mod) {||\n+            do ebml_w.wr_tag(tag_paths_data_mod) || {\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n               encode_foreign_module_item_paths(\n                   ebml_w, nmod,\n                   vec::append_one(path, it.ident), index);\n             }\n           }\n           item_ty(_, tps, _) {\n-            do ebml_w.wr_tag(tag_paths_data_item) {||\n+            do ebml_w.wr_tag(tag_paths_data_item) || {\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n           }\n           item_class(_, _, items, ctor, m_dtor, _) {\n-            do ebml_w.wr_tag(tag_paths_data_item) {||\n+            do ebml_w.wr_tag(tag_paths_data_item) || {\n                 encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n-            do ebml_w.wr_tag(tag_paths) {||\n+            do ebml_w.wr_tag(tag_paths) || {\n                 // We add the same ident twice: for the\n                 // class and for its ctor\n                 add_to_index(ebml_w, path, index, it.ident);\n@@ -206,13 +206,13 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             }\n           }\n           item_enum(variants, _, _) {\n-              do ebml_w.wr_tag(tag_paths_data_item) {||\n+            do ebml_w.wr_tag(tag_paths_data_item) || {\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n               encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n           item_iface(*) {\n-              do ebml_w.wr_tag(tag_paths_data_item) {||\n+            do ebml_w.wr_tag(tag_paths_data_item) || {\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n           }\n@@ -240,7 +240,7 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n \n fn encode_reexport_paths(ebml_w: ebml::writer,\n                          ecx: @encode_ctxt, &index: ~[entry<str>]) {\n-    for ecx.reexports.each {|reexport|\n+    for ecx.reexports.each |reexport| {\n         let (path, def_id) = reexport;\n         vec::push(index, {val: path, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_paths_data_item);\n@@ -265,9 +265,9 @@ fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n                         tcx: ecx.tcx,\n-                        reachable: {|a|reachable(ecx, a)},\n+                        reachable: |a| reachable(ecx, a),\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    for params.each {|param|\n+    for params.each |param| {\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n         let bs = ecx.tcx.ty_param_bounds.get(param.id);\n         tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, bs);\n@@ -286,7 +286,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n         @{diag: ecx.diag,\n           ds: def_to_str,\n           tcx: ecx.tcx,\n-          reachable: {|a|reachable(ecx, a)},\n+          reachable: |a| reachable(ecx, a),\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n@@ -335,7 +335,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx, {crate: local_crate, node: id});\n-    for variants.each {|variant|\n+    for variants.each |variant| {\n         vec::push(*index, {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n@@ -372,9 +372,9 @@ fn encode_path(ebml_w: ebml::writer,\n         ebml_w.wr_tagged_str(tag, *name);\n     }\n \n-    do ebml_w.wr_tag(tag_path) {||\n+    do ebml_w.wr_tag(tag_path) || {\n         ebml_w.wr_tagged_u32(tag_path_len, (vec::len(path) + 1u) as u32);\n-        do vec::iter(path) {|pe| encode_path_elt(ebml_w, pe); }\n+        do vec::iter(path) |pe| { encode_path_elt(ebml_w, pe); }\n         encode_path_elt(ebml_w, name);\n     }\n }\n@@ -386,7 +386,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     encode_family(ebml_w, 'm');\n     encode_name(ebml_w, name);\n     let impls = ecx.impl_map(id);\n-    for impls.each {|i|\n+    for impls.each |i| {\n         let (ident, did) = i;\n         if ast_util::is_exported(ident, md) {\n             ebml_w.start_tag(tag_mod_impl);\n@@ -432,7 +432,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n        may have fields with the same name */\n     let index = @mut ~[];\n     let tcx = ecx.tcx;\n-    for items.each {|ci|\n+    for items.each |ci| {\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n       alt ci.node {\n@@ -547,7 +547,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                      index: @mut ~[entry<int>]) {\n         vec::push(*index, {val: item.id, pos: ebml_w.writer.tell()});\n     }\n-    let add_to_index = {|copy ebml_w|add_to_index_(item, ebml_w, index)};\n+    let add_to_index = |copy ebml_w| add_to_index_(item, ebml_w, index);\n \n     alt item.node {\n       item_const(_, _) {\n@@ -602,13 +602,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       }\n       item_enum(variants, tps, rp) {\n         add_to_index();\n-        do ebml_w.wr_tag(tag_items_data_item) {||\n+        do ebml_w.wr_tag(tag_items_data_item) || {\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_family(ebml_w, 't');\n             encode_type_param_bounds(ebml_w, ecx, tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n             encode_name(ebml_w, item.ident);\n-            for variants.each {|v|\n+            for variants.each |v| {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n             ecx.encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n@@ -626,7 +626,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         let idx = encode_info_for_class(ecx, ebml_w, item.id, path, tps,\n                                           items, index);\n         /* Encode the dtor */\n-        do option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) |dtor| {\n             vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_fn(ecx, ebml_w, dtor.node.id, @(*item.ident\n                              + \"_dtor\"), path, if tps.len() > 0u {\n@@ -646,13 +646,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ebml_w, rp);\n-        for ifaces.each {|t|\n+        for ifaces.each |t| {\n            encode_iface_ref(ebml_w, ecx, t);\n         }\n         /* Encode the dtor */\n         /* Encode id for dtor */\n-        do option::iter(m_dtor) {|dtor|\n-            do ebml_w.wr_tag(tag_item_dtor) {||\n+        do option::iter(m_dtor) |dtor| {\n+            do ebml_w.wr_tag(tag_item_dtor) || {\n                 encode_def_id(ebml_w, local_def(dtor.node.id));\n             }\n         };\n@@ -661,14 +661,14 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n          for methods, write all the stuff get_iface_method\n         needs to know*/\n         let (fs,ms) = ast_util::split_class_items(items);\n-        for fs.each {|f|\n+        for fs.each |f| {\n            ebml_w.start_tag(tag_item_field);\n            encode_visibility(ebml_w, f.vis);\n            encode_name(ebml_w, f.ident);\n            encode_def_id(ebml_w, local_def(f.id));\n            ebml_w.end_tag();\n         }\n-        for ms.each {|m|\n+        for ms.each |m| {\n            alt m.vis {\n               private { /* do nothing */ }\n               public {\n@@ -703,20 +703,20 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n-        for methods.each {|m|\n+        for methods.each |m| {\n             ebml_w.start_tag(tag_item_impl_method);\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml_w.end_tag();\n         }\n-        do option::iter(ifce) {|t|\n+        do option::iter(ifce) |t| {\n            encode_iface_ref(ebml_w, ecx, t)\n         };\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n         let impl_path = vec::append_one(path,\n                                         ast_map::path_name(item.ident));\n-        for methods.each {|m|\n+        for methods.each |m| {\n             vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                                    should_inline(m.attrs), item.id, m,\n@@ -733,7 +733,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         let mut i = 0u;\n-        for vec::each(*ty::iface_methods(tcx, local_def(item.id))) {|mty|\n+        for vec::each(*ty::iface_methods(tcx, local_def(item.id))) |mty| {\n             ebml_w.start_tag(tag_item_iface_method);\n             encode_name(ebml_w, mty.ident);\n             encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n@@ -782,8 +782,8 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n                         crate_node_id, ~[], @\"\");\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n-        visit_expr: {|_e, _cx, _v|},\n-        visit_item: {|i, cx, v, copy ebml_w|\n+        visit_expr: |_e, _cx, _v| { },\n+        visit_item: |i, cx, v, copy ebml_w| {\n             visit::visit_item(i, cx, v);\n             alt check ecx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) {\n@@ -806,7 +806,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n               }\n             }\n         },\n-        visit_foreign_item: {|ni, cx, v, copy ebml_w|\n+        visit_foreign_item: |ni, cx, v, copy ebml_w| {\n             visit::visit_foreign_item(ni, cx, v);\n             alt check ecx.tcx.items.get(ni.id) {\n               ast_map::node_foreign_item(_, abi, pt) {\n@@ -827,14 +827,14 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n fn create_index<T: copy>(index: ~[entry<T>], hash_fn: fn@(T) -> uint) ->\n    ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n-    for uint::range(0u, 256u) {|_i| vec::push(buckets, @mut ~[]); };\n-    for index.each {|elt|\n+    for uint::range(0u, 256u) |_i| { vec::push(buckets, @mut ~[]); };\n+    for index.each |elt| {\n         let h = hash_fn(elt.val);\n         vec::push(*buckets[h % 256u], elt);\n     }\n \n     let mut buckets_frozen = ~[];\n-    for buckets.each {|bucket|\n+    for buckets.each |bucket| {\n         vec::push(buckets_frozen, @*bucket);\n     }\n     ret buckets_frozen;\n@@ -846,10 +846,10 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: ~[@~[entry<T>]],\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n-    for buckets.each {|bucket|\n+    for buckets.each |bucket| {\n         vec::push(bucket_locs, ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for vec::each(*bucket) {|elt|\n+        for vec::each(*bucket) |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt.pos, 4u);\n             write_fn(writer, elt.val);\n@@ -859,7 +859,7 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: ~[@~[entry<T>]],\n     }\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n-    for bucket_locs.each {|pos| writer.write_be_uint(pos, 4u); }\n+    for bucket_locs.each |pos| { writer.write_be_uint(pos, 4u); }\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -899,7 +899,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(*name));\n         ebml_w.end_tag();\n-        for items.each {|inner_item|\n+        for items.each |inner_item| {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n@@ -909,7 +909,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n \n fn encode_attributes(ebml_w: ebml::writer, attrs: ~[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n-    for attrs.each {|attr|\n+    for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebml_w.end_tag();\n@@ -948,7 +948,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n \n     let mut attrs: ~[attribute] = ~[];\n     let mut found_link_attr = false;\n-    for crate.node.attrs.each {|attr|\n+    for crate.node.attrs.each |attr| {\n         vec::push(\n             attrs,\n             if *attr::get_attr_name(attr) != \"link\" {\n@@ -977,7 +977,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps: ~[mut numdep] = ~[mut];\n-        do cstore::iter_crate_data(cstore) {|key, val|\n+        do cstore::iter_crate_data(cstore) |key, val| {\n             let dep = {cnum: key, name: @val.name,\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n@@ -990,7 +990,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for deps.each {|n|\n+        for deps.each |n| {\n             assert (n.cnum == expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -1004,7 +1004,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n-    for get_ordered_deps(cstore).each {|dep|\n+    for get_ordered_deps(cstore).each |dep| {\n         encode_crate_dep(ebml_w, dep);\n     }\n     ebml_w.end_tag();\n@@ -1081,7 +1081,7 @@ fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> str {\n     let cx = @{diag: tcx.diag,\n                ds: def_to_str,\n                tcx: tcx,\n-               reachable: {|_id| false},\n+               reachable: |_id| false,\n                abbrevs: tyencode::ac_no_abbrevs};\n     let buf = io::mem_buffer();\n     tyencode::enc_ty(io::mem_buffer_writer(buf), cx, t);"}, {"sha": "ab42afb1edddea5b15d76dec76c1c9d9972ba6df", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -70,9 +70,9 @@ fn mk_filesearch(maybe_sysroot: option<path>,\n \n fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     let mut rslt = none;\n-    for filesearch.lib_search_paths().each {|lib_search_path|\n+    for filesearch.lib_search_paths().each |lib_search_path| {\n         #debug(\"searching %s\", lib_search_path);\n-        for os::list_dir_path(lib_search_path).each {|path|\n+        for os::list_dir_path(lib_search_path).each |path| {\n             #debug(\"testing %s\", path);\n             let maybe_picked = pick(path);\n             if option::is_some(maybe_picked) {\n@@ -134,7 +134,7 @@ fn get_cargo_root() -> result<path, str> {\n }\n \n fn get_cargo_root_nearest() -> result<path, str> {\n-    do result::chain(get_cargo_root()) { |p|\n+    do result::chain(get_cargo_root()) |p| {\n         let cwd = os::getcwd();\n         let mut dirname = path::dirname(cwd);\n         let mut dirpath = path::split(dirname);\n@@ -158,13 +158,13 @@ fn get_cargo_root_nearest() -> result<path, str> {\n }\n \n fn get_cargo_lib_path() -> result<path, str> {\n-    do result::chain(get_cargo_root()) { |p|\n+    do result::chain(get_cargo_root()) |p| {\n         result::ok(path::connect(p, libdir()))\n     }\n }\n \n fn get_cargo_lib_path_nearest() -> result<path, str> {\n-    do result::chain(get_cargo_root_nearest()) { |p|\n+    do result::chain(get_cargo_root_nearest()) |p| {\n         result::ok(path::connect(p, libdir()))\n     }\n }"}, {"sha": "9b9571de413dbe9f8e5ec04a3d1b790139a07530", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -73,7 +73,7 @@ fn find_library_crate_aux(cx: ctxt,\n     let suffix: str = nn.suffix;\n \n     let mut matches = ~[];\n-    filesearch::search(filesearch, { |path|\n+    filesearch::search(filesearch, |path| {\n         #debug(\"inspecting file %s\", path);\n         let f: str = path::basename(path);\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n@@ -109,7 +109,7 @@ fn find_library_crate_aux(cx: ctxt,\n         cx.diag.span_err(\n             cx.span, #fmt(\"multiple matching crates for `%s`\", *crate_name));\n         cx.diag.handler().note(\"candidates:\");\n-        for matches.each {|match|\n+        for matches.each |match| {\n             cx.diag.handler().note(#fmt(\"path: %s\", match.ident));\n             let attrs = decoder::get_crate_attributes(match.data);\n             note_linkage_attrs(cx.diag, attrs);\n@@ -135,7 +135,7 @@ fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @str {\n }\n \n fn note_linkage_attrs(diag: span_handler, attrs: ~[ast::attribute]) {\n-    for attr::find_linkage_attrs(attrs).each {|attr|\n+    for attr::find_linkage_attrs(attrs).each |attr| {\n         diag.handler().note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n     }\n }\n@@ -158,11 +158,11 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n            vec::len(local_metas), vec::len(extern_metas));\n \n     #debug(\"crate metadata:\");\n-    for extern_metas.each {|have|\n+    for extern_metas.each |have| {\n         #debug(\"  %s\", pprust::meta_item_to_str(*have));\n     }\n \n-    for local_metas.each {|needed|\n+    for local_metas.each |needed| {\n         #debug(\"looking for %s\", pprust::meta_item_to_str(*needed));\n         if !attr::contains(extern_metas, needed) {\n             #debug(\"missing %s\", pprust::meta_item_to_str(*needed));\n@@ -174,7 +174,7 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n \n fn get_metadata_section(os: os,\n                         filename: str) -> option<@~[u8]> unsafe {\n-    let mb = str::as_c_str(filename, {|buf|\n+    let mb = str::as_c_str(filename, |buf| {\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });\n     if mb as int == 0 { ret option::none::<@~[u8]>; }"}, {"sha": "ed510dad3cea5312d88315fba0e1e809e5c3408f", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -37,7 +37,7 @@ fn next_byte(st: @pstate) -> u8 {\n \n fn parse_ident(st: @pstate, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { ret c == b; }\n-    ret parse_ident_(st, {|a|is_last(last, a)});\n+    ret parse_ident_(st, |a| is_last(last, a) );\n }\n \n fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n@@ -192,9 +192,9 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n }\n \n fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n-    let self_r = parse_opt(st, {|| parse_region(st) });\n+    let self_r = parse_opt(st, || parse_region(st) );\n \n-    let self_ty = parse_opt(st, {|| parse_ty(st, conv) });\n+    let self_ty = parse_opt(st, || parse_ty(st, conv) );\n \n     assert next(st) == '[';\n     let mut params: [ty::t]/~ = []/~;"}, {"sha": "4190b0440af521f02dd434e90331203bc61a4f89", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -115,10 +115,10 @@ fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n }\n \n fn enc_substs(w: io::writer, cx: @ctxt, substs: ty::substs) {\n-    do enc_opt(w, substs.self_r) { |r| enc_region(w, cx, r) }\n-    do enc_opt(w, substs.self_ty) { |t| enc_ty(w, cx, t) }\n+    do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n+    do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n-    for substs.tps.each { |t| enc_ty(w, cx, t); }\n+    for substs.tps.each |t| { enc_ty(w, cx, t); }\n     w.write_char(']');\n }\n \n@@ -231,7 +231,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_tup(ts) {\n         w.write_str(\"T[\"/&);\n-        for ts.each {|t| enc_ty(w, cx, t); }\n+        for ts.each |t| { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) { w.write_char('@'); enc_mt(w, cx, mt); }\n@@ -255,7 +255,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_unboxed_vec(mt) { w.write_char('U'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\"/&);\n-        for fields.each {|field|\n+        for fields.each |field| {\n             w.write_str(*field.ident);\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n@@ -290,7 +290,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_constr(ty, cs) {\n         w.write_str(\"A[\"/&);\n         enc_ty(w, cx, ty);\n-        for cs.each {|tc| enc_ty_constr(w, cx, tc); }\n+        for cs.each |tc| { enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n       }\n       ty::ty_opaque_box { w.write_char('B'); }\n@@ -341,13 +341,13 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     enc_proto(w, ft.proto);\n     enc_purity(w, ft.purity);\n     w.write_char('[');\n-    for ft.inputs.each {|arg|\n+    for ft.inputs.each |arg| {\n         enc_mode(w, cx, arg.mode);\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');\n     let mut colon = true;\n-    for ft.constraints.each {|c|\n+    for ft.constraints.each |c| {\n         if colon {\n             w.write_char(':');\n             colon = false;\n@@ -368,15 +368,15 @@ fn enc_constr_gen<T>(w: io::writer, cx: @ctxt,\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n     let mut semi = false;\n-    for c.node.args.each {|a|\n+    for c.node.args.each |a| {\n         if semi { w.write_char(';'); } else { semi = true; }\n         write_arg(a);\n     }\n     w.write_char(')');\n }\n \n fn enc_constr(w: io::writer, cx: @ctxt, c: @ty::constr) {\n-    enc_constr_gen(w, cx, c, {|a|\n+    enc_constr_gen(w, cx, c, |a| {\n       alt a.node {\n         carg_base     { w.write_char('*'); }\n         carg_ident(i) { w.write_uint(i); }\n@@ -386,7 +386,7 @@ fn enc_constr(w: io::writer, cx: @ctxt, c: @ty::constr) {\n }\n \n fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n-    enc_constr_gen(w, cx, c, {|a|\n+    enc_constr_gen(w, cx, c, |a| {\n       alt a.node {\n         carg_base     { w.write_char('*'); }\n         carg_ident(p) { w.write_str(path_to_str(p)); }\n@@ -396,7 +396,7 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n }\n \n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n-    for vec::each(*bs) {|bound|\n+    for vec::each(*bs) |bound| {\n         alt bound {\n           ty::bound_send { w.write_char('S'); }\n           ty::bound_copy { w.write_char('C'); }"}, {"sha": "3b9b4549817f08b8b70c88a4127304bac929695a", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -87,7 +87,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n            ebml_w.writer.tell()];\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n-    do ebml_w.wr_tag(c::tag_ast as uint) {||\n+    do ebml_w.wr_tag(c::tag_ast as uint) || {\n         ast_util::serialize_id_range(ebml_w, id_range);\n         encode_ast(ebml_w, simplify_ast(ii));\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n@@ -210,7 +210,7 @@ impl deserializer_helpers<D: deserializer> for D {\n // but eventually we should add entries to the local codemap as required.\n \n fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n-    do ebml_w.wr_tag(c::tag_tree as uint) {||\n+    do ebml_w.wr_tag(c::tag_tree as uint) || {\n         ast::serialize_inlined_item(ebml_w, item)\n     }\n }\n@@ -227,7 +227,7 @@ fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n // inlined items.\n fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n-        let stmts_sans_items = do vec::filter(blk.stmts) {|stmt|\n+        let stmts_sans_items = do vec::filter(blk.stmts) |stmt| {\n             alt stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n               ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) { true }\n@@ -278,8 +278,8 @@ fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n     -> ast::inlined_item {\n     let fld = fold::make_fold(@{\n-        new_id: {|a|xcx.tr_id(a)},\n-        new_span: {|a|xcx.tr_span(a)}\n+        new_id: |a| xcx.tr_id(a),\n+        new_span: |a| xcx.tr_span(a)\n         with *fold::default_ast_fold()\n     });\n \n@@ -425,45 +425,45 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written serialization routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) {|vtable_origin|\n+    do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     }\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                       ebml_w: ebml::writer,\n                       vtable_origin: typeck::vtable_origin) {\n-    do ebml_w.emit_enum(\"vtable_origin\") {||\n+    do ebml_w.emit_enum(\"vtable_origin\") || {\n         alt vtable_origin {\n           typeck::vtable_static(def_id, tys, vtable_res) {\n-            do ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) {||\n-                do ebml_w.emit_enum_variant_arg(0u) {||\n+            do ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) || {\n+                do ebml_w.emit_enum_variant_arg(0u) || {\n                     ebml_w.emit_def_id(def_id)\n                 }\n-                do ebml_w.emit_enum_variant_arg(1u) {||\n+                do ebml_w.emit_enum_variant_arg(1u) || {\n                     ebml_w.emit_tys(ecx, tys);\n                 }\n-                do ebml_w.emit_enum_variant_arg(2u) {||\n+                do ebml_w.emit_enum_variant_arg(2u) || {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n                 }\n             }\n           }\n           typeck::vtable_param(pn, bn) {\n-            do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) {||\n-                do ebml_w.emit_enum_variant_arg(0u) {||\n+            do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) || {\n+                do ebml_w.emit_enum_variant_arg(0u) || {\n                     ebml_w.emit_uint(pn);\n                 }\n-                do ebml_w.emit_enum_variant_arg(1u) {||\n+                do ebml_w.emit_enum_variant_arg(1u) || {\n                     ebml_w.emit_uint(bn);\n                 }\n             }\n           }\n           typeck::vtable_iface(def_id, tys) {\n-            do ebml_w.emit_enum_variant(\"vtable_iface\", 1u, 3u) {||\n-                do ebml_w.emit_enum_variant_arg(0u) {||\n+            do ebml_w.emit_enum_variant(\"vtable_iface\", 1u, 3u) || {\n+                do ebml_w.emit_enum_variant_arg(0u) || {\n                     ebml_w.emit_def_id(def_id)\n                 }\n-                do ebml_w.emit_enum_variant_arg(1u) {||\n+                do ebml_w.emit_enum_variant_arg(1u) || {\n                     ebml_w.emit_tys(ecx, tys);\n                 }\n             }\n@@ -475,43 +475,43 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n \n impl helpers for ebml::ebml_deserializer {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n-        @self.read_to_vec({|| self.read_vtable_origin(xcx) })\n+        @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n \n     fn read_vtable_origin(xcx: extended_decode_ctxt)\n         -> typeck::vtable_origin {\n-        do self.read_enum(\"vtable_origin\") {||\n-            do self.read_enum_variant {|i|\n+        do self.read_enum(\"vtable_origin\") || {\n+            do self.read_enum_variant |i| {\n                 alt check i {\n                   0u {\n                     typeck::vtable_static(\n-                        do self.read_enum_variant_arg(0u) {||\n+                        do self.read_enum_variant_arg(0u) || {\n                             self.read_def_id(xcx)\n                         },\n-                        do self.read_enum_variant_arg(1u) {||\n+                        do self.read_enum_variant_arg(1u) || {\n                             self.read_tys(xcx)\n                         },\n-                        do self.read_enum_variant_arg(2u) {||\n+                        do self.read_enum_variant_arg(2u) || {\n                             self.read_vtable_res(xcx)\n                         }\n                     )\n                   }\n                   1u {\n                     typeck::vtable_param(\n-                        do self.read_enum_variant_arg(0u) {||\n+                        do self.read_enum_variant_arg(0u) || {\n                             self.read_uint()\n                         },\n-                        do self.read_enum_variant_arg(1u) {||\n+                        do self.read_enum_variant_arg(1u) || {\n                             self.read_uint()\n                         }\n                     )\n                   }\n                   2u {\n                     typeck::vtable_iface(\n-                        do self.read_enum_variant_arg(0u) {||\n+                        do self.read_enum_variant_arg(0u) || {\n                             self.read_def_id(xcx)\n                         },\n-                        do self.read_enum_variant_arg(1u) {||\n+                        do self.read_enum_variant_arg(1u) || {\n                             self.read_tys(xcx)\n                         }\n                     )\n@@ -530,7 +530,7 @@ impl helpers for @e::encode_ctxt {\n         @{diag: self.tcx.sess.diagnostic(),\n           ds: e::def_to_str,\n           tcx: self.tcx,\n-          reachable: {|a|encoder::reachable(self, a)},\n+          reachable: |a| encoder::reachable(self, a),\n           abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n     }\n }\n@@ -541,7 +541,7 @@ impl helpers for ebml::writer {\n     }\n \n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]) {\n-        do self.emit_from_vec(tys) {|ty|\n+        do self.emit_from_vec(tys) |ty| {\n             e::write_type(ecx, self, ty)\n         }\n     }\n@@ -551,16 +551,16 @@ impl helpers for ebml::writer {\n     }\n \n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_rec {||\n-            do self.emit_rec_field(\"bounds\", 0u) {||\n-                do self.emit_from_vec(*tpbt.bounds) {|bs|\n+        do self.emit_rec || {\n+            do self.emit_rec_field(\"bounds\", 0u) || {\n+                do self.emit_from_vec(*tpbt.bounds) |bs| {\n                     self.emit_bounds(ecx, bs)\n                 }\n             }\n-            do self.emit_rec_field(\"rp\", 1u) {||\n+            do self.emit_rec_field(\"rp\", 1u) || {\n                 ast::serialize_region_param(self, tpbt.rp)\n             }\n-            do self.emit_rec_field(\"ty\", 2u) {||\n+            do self.emit_rec_field(\"ty\", 2u) || {\n                 self.emit_ty(ecx, tpbt.ty);\n             }\n         }\n@@ -569,7 +569,7 @@ impl helpers for ebml::writer {\n \n impl writer for ebml::writer {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n-        do self.wr_tag(tag_id as uint) {|| f() }\n+        do self.wr_tag(tag_id as uint) || { f() }\n     }\n \n     fn id(id: ast::node_id) {\n@@ -581,7 +581,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n                              ebml_w: ebml::writer,\n                              ii: ast::inlined_item) {\n-    do ebml_w.wr_tag(c::tag_table as uint) {||\n+    do ebml_w.wr_tag(c::tag_table as uint) || {\n         ast_util::visit_ids_for_inlined_item(\n             ii,\n             fn@(id: ast::node_id, copy ebml_w) {\n@@ -601,57 +601,57 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n     #debug[\"Encoding side tables for id %d\", id];\n \n-    do option::iter(tcx.def_map.find(id)) {|def|\n-        do ebml_w.tag(c::tag_table_def) {||\n+    do option::iter(tcx.def_map.find(id)) |def| {\n+        do ebml_w.tag(c::tag_table_def) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 ast::serialize_def(ebml_w, def)\n             }\n         }\n     }\n-    do option::iter((*tcx.node_types).find(id as uint)) {|ty|\n-        do ebml_w.tag(c::tag_table_node_type) {||\n+    do option::iter((*tcx.node_types).find(id as uint)) |ty| {\n+        do ebml_w.tag(c::tag_table_node_type) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 e::write_type(ecx, ebml_w, ty)\n             }\n         }\n     }\n \n-    do option::iter(tcx.node_type_substs.find(id)) {|tys|\n-        do ebml_w.tag(c::tag_table_node_type_subst) {||\n+    do option::iter(tcx.node_type_substs.find(id)) |tys| {\n+        do ebml_w.tag(c::tag_table_node_type_subst) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 ebml_w.emit_tys(ecx, tys)\n             }\n         }\n     }\n \n-    do option::iter(tcx.freevars.find(id)) {|fv|\n-        do ebml_w.tag(c::tag_table_freevars) {||\n+    do option::iter(tcx.freevars.find(id)) |fv| {\n+        do ebml_w.tag(c::tag_table_freevars) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n-                do ebml_w.emit_from_vec(*fv) {|fv_entry|\n+            do ebml_w.tag(c::tag_table_val) || {\n+                do ebml_w.emit_from_vec(*fv) |fv_entry| {\n                     encode_freevar_entry(ebml_w, *fv_entry)\n                 }\n             }\n         }\n     }\n \n     let lid = {crate: ast::local_crate, node: id};\n-    do option::iter(tcx.tcache.find(lid)) {|tpbt|\n-        do ebml_w.tag(c::tag_table_tcache) {||\n+    do option::iter(tcx.tcache.find(lid)) |tpbt| {\n+        do ebml_w.tag(c::tag_table_tcache) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 ebml_w.emit_tpbt(ecx, tpbt);\n             }\n         }\n     }\n \n-    do option::iter(tcx.ty_param_bounds.find(id)) {|pbs|\n-        do ebml_w.tag(c::tag_table_param_bounds) {||\n+    do option::iter(tcx.ty_param_bounds.find(id)) |pbs| {\n+        do ebml_w.tag(c::tag_table_param_bounds) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 ebml_w.emit_bounds(ecx, pbs)\n             }\n         }\n@@ -671,17 +671,17 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     //    }\n     //}\n \n-    do option::iter(maps.mutbl_map.find(id)) {|_m|\n-        do ebml_w.tag(c::tag_table_mutbl) {||\n+    do option::iter(maps.mutbl_map.find(id)) |_m| {\n+        do ebml_w.tag(c::tag_table_mutbl) || {\n             ebml_w.id(id);\n         }\n     }\n \n-    do option::iter(maps.last_use_map.find(id)) {|m|\n-        do ebml_w.tag(c::tag_table_last_use) {||\n+    do option::iter(maps.last_use_map.find(id)) |m| {\n+        do ebml_w.tag(c::tag_table_last_use) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n-                do ebml_w.emit_from_vec((*m).get()) {|id|\n+            do ebml_w.tag(c::tag_table_val) || {\n+                do ebml_w.emit_from_vec((*m).get()) |id| {\n                     ebml_w.emit_int(id);\n                 }\n             }\n@@ -691,28 +691,28 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     // impl_map is not used except when emitting metadata,\n     // don't need to keep it.\n \n-    do option::iter(maps.method_map.find(id)) {|mme|\n-        do ebml_w.tag(c::tag_table_method_map) {||\n+    do option::iter(maps.method_map.find(id)) |mme| {\n+        do ebml_w.tag(c::tag_table_method_map) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 serialize_method_map_entry(ebml_w, mme)\n             }\n         }\n     }\n \n-    do option::iter(maps.vtable_map.find(id)) {|dr|\n-        do ebml_w.tag(c::tag_table_vtable_map) {||\n+    do option::iter(maps.vtable_map.find(id)) |dr| {\n+        do ebml_w.tag(c::tag_table_vtable_map) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 encode_vtable_res(ecx, ebml_w, dr);\n             }\n         }\n     }\n \n-    do option::iter(tcx.borrowings.find(id)) {|borrow|\n-        do ebml_w.tag(c::tag_table_borrowings) {||\n+    do option::iter(tcx.borrowings.find(id)) |borrow| {\n+        do ebml_w.tag(c::tag_table_borrowings) || {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) || {\n                 ty::serialize_borrow(ebml_w, borrow)\n             }\n         }\n@@ -738,30 +738,30 @@ impl decoder for ebml::ebml_deserializer {\n \n         tydecode::parse_ty_data(\n             self.parent.data, xcx.dcx.cdata.cnum, self.pos, xcx.dcx.tcx,\n-            {|a|xcx.tr_def_id(a)})\n+            |a| xcx.tr_def_id(a) )\n     }\n \n     fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t] {\n-        self.read_to_vec({|| self.read_ty(xcx) })\n+        self.read_to_vec(|| self.read_ty(xcx) )\n     }\n \n     fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound] {\n         tydecode::parse_bounds_data(\n             self.parent.data, self.pos, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n-            {|a|xcx.tr_def_id(a)})\n+            |a| xcx.tr_def_id(a) )\n     }\n \n     fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n         -> ty::ty_param_bounds_and_ty {\n-        do self.read_rec {||\n+        do self.read_rec || {\n             {\n-                bounds: self.read_rec_field(\"bounds\", 0u, {||\n-                    @self.read_to_vec({|| self.read_bounds(xcx) })\n+                bounds: self.read_rec_field(\"bounds\", 0u, || {\n+                    @self.read_to_vec(|| self.read_bounds(xcx) )\n                 }),\n-                rp: self.read_rec_field(\"rp\", 1u, {||\n+                rp: self.read_rec_field(\"rp\", 1u, || {\n                     ast::deserialize_region_param(self)\n                 }),\n-                ty: self.read_rec_field(\"ty\", 2u, {||\n+                ty: self.read_rec_field(\"ty\", 2u, || {\n                     self.read_ty(xcx)\n                 })\n             }\n@@ -773,7 +773,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                       ast_doc: ebml::doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table];\n-    do ebml::docs(tbl_doc) {|tag, entry_doc|\n+    do ebml::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc[c::tag_table_id].as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -796,7 +796,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let tys = val_dsr.read_tys(xcx);\n                 dcx.tcx.node_type_substs.insert(id, tys);\n             } else if tag == (c::tag_table_freevars as uint) {\n-                let fv_info = @val_dsr.read_to_vec({||\n+                let fv_info = @val_dsr.read_to_vec(|| {\n                     @val_dsr.read_freevar_entry(xcx)\n                 });\n                 dcx.tcx.freevars.insert(id, fv_info);\n@@ -808,7 +808,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let bounds = val_dsr.read_bounds(xcx);\n                 dcx.tcx.ty_param_bounds.insert(id, bounds);\n             } else if tag == (c::tag_table_last_use as uint) {\n-                let ids = val_dsr.read_to_vec({||\n+                let ids = val_dsr.read_to_vec(|| {\n                     xcx.tr_id(val_dsr.read_int())\n                 });\n                 let dvec = @dvec::from_vec(vec::to_mut(ids));\n@@ -838,7 +838,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n \n #[cfg(test)]\n fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n-    do ebml_w.wr_tag(c::tag_tree as uint) {||\n+    do ebml_w.wr_tag(c::tag_tree as uint) || {\n         ast::serialize_item(ebml_w, *item);\n     }\n }\n@@ -881,9 +881,9 @@ fn roundtrip(in_item: @ast::item) {\n     #debug[\"out_item = %s\", pprust::item_to_str(out_item)];\n \n     let exp_str =\n-        io::with_str_writer({|w| ast::serialize_item(w, *in_item) });\n+        io::with_str_writer(|w| ast::serialize_item(w, *in_item) );\n     let out_str =\n-        io::with_str_writer({|w| ast::serialize_item(w, *out_item) });\n+        io::with_str_writer(|w| ast::serialize_item(w, *out_item) );\n \n     #debug[\"expected string: %s\", exp_str];\n     #debug[\"actual string  : %s\", out_str];"}, {"sha": "e6bafb4c48a7f5fcbc351332d5cf794a2f0460d4", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -28,7 +28,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         cx.allow_block = true;\n         v.visit_expr(f, cx, v);\n         let mut i = 0u;\n-        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each {|arg_t|\n+        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n             cx.allow_block = (ty::arg_mode(cx.tcx, arg_t) == by_ref);\n             v.visit_expr(args[i], cx, v);\n             i += 1u;"}, {"sha": "69b38cc1b2cf51e70bd83c0bec682dbea7a31717", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -450,7 +450,7 @@ impl to_str_methods for borrowck_ctxt {\n              self.cat_to_repr(cmt.cat),\n              cmt.id,\n              self.mut_to_str(cmt.mutbl),\n-             cmt.lp.map_default(\"none\", { |p| self.lp_to_str(p) }),\n+             cmt.lp.map_default(\"none\", |p| self.lp_to_str(p) ),\n              ty_to_str(self.tcx, cmt.ty)]\n     }\n "}, {"sha": "7df58bf43d03ac363ddeeb17430bbd8e0e442d6b", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -280,7 +280,7 @@ impl public_methods for borrowck_ctxt {\n                                 cmt: cmt) -> cmt {\n         @{id: arg.id(), span: arg.span(),\n           cat: cat_comp(cmt, comp_variant(enum_did)),\n-          lp: cmt.lp.map({ |l| @lp_comp(l, comp_variant(enum_did)) }),\n+          lp: cmt.lp.map(|l| @lp_comp(l, comp_variant(enum_did)) ),\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(arg)}\n     }\n@@ -311,20 +311,18 @@ impl public_methods for borrowck_ctxt {\n           m_mutbl | m_const { f_mutbl }\n         };\n         let f_comp = comp_field(f_name, f_mutbl);\n-        let lp = base_cmt.lp.map({ |lp|\n-            @lp_comp(lp, f_comp)\n-        });\n+        let lp = base_cmt.lp.map(|lp| @lp_comp(lp, f_comp) );\n         @{id: node.id(), span: node.span(),\n           cat: cat_comp(base_cmt, f_comp), lp:lp,\n           mutbl: m, ty: self.tcx.ty(node)}\n     }\n \n     fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n                              expl: bool) -> option<cmt> {\n-        do ty::deref(self.tcx, base_cmt.ty, expl).map { |mt|\n+        do ty::deref(self.tcx, base_cmt.ty, expl).map |mt| {\n             alt deref_kind(self.tcx, base_cmt.ty) {\n               deref_ptr(ptr) {\n-                let lp = do base_cmt.lp.chain { |l|\n+                let lp = do base_cmt.lp.chain |l| {\n                     // Given that the ptr itself is loanable, we can\n                     // loan out deref'd uniq ptrs as the data they are\n                     // the only way to reach the data they point at.\n@@ -341,7 +339,7 @@ impl public_methods for borrowck_ctxt {\n               }\n \n               deref_comp(comp) {\n-                let lp = base_cmt.lp.map({ |l| @lp_comp(l, comp) });\n+                let lp = base_cmt.lp.map(|l| @lp_comp(l, comp) );\n                 @{id:node.id(), span:node.span(),\n                   cat:cat_comp(base_cmt, comp), lp:lp,\n                   mutbl:mt.mutbl, ty:mt.ty}\n@@ -367,7 +365,7 @@ impl public_methods for borrowck_ctxt {\n           deref_ptr(ptr) {\n             // make deref of vectors explicit, as explained in the comment at\n             // the head of this section\n-            let deref_lp = base_cmt.lp.map({ |lp| @lp_deref(lp, ptr) });\n+            let deref_lp = base_cmt.lp.map(|lp| @lp_deref(lp, ptr) );\n             let deref_cmt = @{id:expr.id, span:expr.span,\n                               cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n                               mutbl:m_imm, ty:mt.ty};\n@@ -383,7 +381,7 @@ impl public_methods for borrowck_ctxt {\n         fn comp(expr: @ast::expr, of_cmt: cmt,\n                 vect: ty::t, mt: ty::mt) -> cmt {\n             let comp = comp_index(vect, mt.mutbl);\n-            let index_lp = of_cmt.lp.map({ |lp| @lp_comp(lp, comp) });\n+            let index_lp = of_cmt.lp.map(|lp| @lp_comp(lp, comp) );\n             @{id:expr.id, span:expr.span,\n               cat:cat_comp(of_cmt, comp), lp:index_lp,\n               mutbl:mt.mutbl, ty:mt.ty}\n@@ -393,7 +391,7 @@ impl public_methods for borrowck_ctxt {\n     fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n         @{id: elt.id(), span: elt.span(),\n           cat: cat_comp(cmt, comp_tuple),\n-          lp: cmt.lp.map({ |l| @lp_comp(l, comp_tuple) }),\n+          lp: cmt.lp.map(|l| @lp_comp(l, comp_tuple) ),\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(elt)}\n     }\n@@ -432,14 +430,14 @@ fn field_mutbl(tcx: ty::ctxt,\n     // Need to refactor so that records/class fields can be treated uniformly.\n     alt ty::get(base_ty).struct {\n       ty::ty_rec(fields) {\n-        for fields.each { |f|\n+        for fields.each |f| {\n             if f.ident == f_name {\n                 ret some(f.mt.mutbl);\n             }\n         }\n       }\n       ty::ty_class(did, substs) {\n-        for ty::lookup_class_fields(tcx, did).each { |fld|\n+        for ty::lookup_class_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {\n                 let m = alt fld.mutability {\n                   ast::class_mutable { ast::m_mutbl }"}, {"sha": "617c1f8df8a757197ddb2160040e30659b4814de", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -120,9 +120,9 @@ impl methods for check_loan_ctxt {\n         let req_loan_map = self.req_maps.req_loan_map;\n \n         loop {\n-            for req_loan_map.find(scope_id).each { |loanss|\n-                for (*loanss).each { |loans|\n-                    for (*loans).each { |loan|\n+            for req_loan_map.find(scope_id).each |loanss| {\n+                for (*loanss).each |loans| {\n+                    for (*loans).each |loan| {\n                         if !f(loan) { ret; }\n                     }\n                 }\n@@ -138,7 +138,7 @@ impl methods for check_loan_ctxt {\n     fn walk_loans_of(scope_id: ast::node_id,\n                      lp: @loan_path,\n                      f: fn(loan) -> bool) {\n-        for self.walk_loans(scope_id) { |loan|\n+        for self.walk_loans(scope_id) |loan| {\n             if loan.lp == lp {\n                 if !f(loan) { ret; }\n             }\n@@ -160,7 +160,7 @@ impl methods for check_loan_ctxt {\n         #debug[\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n                 callee_id=%d, ty=%s)\",\n                pc,\n-               opt_expr.map({|e| pprust::expr_to_str(e)}),\n+               opt_expr.map(|e| pprust::expr_to_str(e) ),\n                callee_id,\n                ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id))];\n \n@@ -244,9 +244,9 @@ impl methods for check_loan_ctxt {\n         };\n \n         let par_scope_id = self.tcx().region_map.get(scope_id);\n-        for self.walk_loans(par_scope_id) { |old_loan|\n-            for (*new_loanss).each { |new_loans|\n-                for (*new_loans).each { |new_loan|\n+        for self.walk_loans(par_scope_id) |old_loan| {\n+            for (*new_loanss).each |new_loans| {\n+                for (*new_loans).each |new_loan| {\n                     if old_loan.lp != new_loan.lp { cont; }\n                     alt (old_loan.mutbl, new_loan.mutbl) {\n                       (m_const, _) | (_, m_const) |\n@@ -333,7 +333,7 @@ impl methods for check_loan_ctxt {\n         // which will be checked for compat separately in\n         // check_for_conflicting_loans()\n         if at != at_mutbl_ref {\n-            for cmt.lp.each { |lp|\n+            for cmt.lp.each |lp| {\n                 self.check_for_loan_conflicting_with_assignment(\n                     at, ex, cmt, lp);\n             }\n@@ -348,7 +348,7 @@ impl methods for check_loan_ctxt {\n         cmt: cmt,\n         lp: @loan_path) {\n \n-        for self.walk_loans_of(ex.id, lp) { |loan|\n+        for self.walk_loans_of(ex.id, lp) |loan| {\n             alt loan.mutbl {\n               m_mutbl | m_const { /*ok*/ }\n               m_imm {\n@@ -439,7 +439,7 @@ impl methods for check_loan_ctxt {\n           none { ret; }\n           some(lp) { lp }\n         };\n-        for self.walk_loans_of(cmt.id, lp) { |loan|\n+        for self.walk_loans_of(cmt.id, lp) |loan| {\n             self.bccx.span_err(\n                 cmt.span,\n                 #fmt[\"moving out of %s prohibited due to outstanding loan\",\n@@ -461,7 +461,7 @@ impl methods for check_loan_ctxt {\n           none { ret; }\n           some(lp) { lp }\n         };\n-        for self.walk_loans_of(cmt.id, lp) { |_loan|\n+        for self.walk_loans_of(cmt.id, lp) |_loan| {\n             #debug[\"Removing last use entry %? due to outstanding loan\",\n                    expr.id];\n             self.bccx.last_use_map.remove(expr.id);\n@@ -479,7 +479,7 @@ impl methods for check_loan_ctxt {\n           some(pc) {\n             self.check_pure_callee_or_arg(\n                 pc, callee, callee_id, callee_span);\n-            for args.each { |arg|\n+            for args.each |arg| {\n                 self.check_pure_callee_or_arg(\n                     pc, some(arg), arg.id, arg.span);\n             }\n@@ -488,7 +488,7 @@ impl methods for check_loan_ctxt {\n         let arg_tys =\n             ty::ty_fn_args(\n                 ty::node_id_to_type(self.tcx(), callee_id));\n-        do vec::iter2(args, arg_tys) { |arg, arg_ty|\n+        do vec::iter2(args, arg_tys) |arg, arg_ty| {\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_move {\n                 self.check_move_out(arg);\n@@ -508,9 +508,9 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n     #debug[\"purity on entry=%?\", copy self.declared_purity];\n-    do save_and_restore(self.in_ctor) {||\n-        do save_and_restore(self.declared_purity) {||\n-            do save_and_restore(self.fn_args) {||\n+    do save_and_restore(self.in_ctor) || {\n+        do save_and_restore(self.declared_purity) || {\n+            do save_and_restore(self.fn_args) || {\n                 let is_stack_closure = self.is_stack_closure(id);\n \n                 // In principle, we could consider fk_anon(*) or\n@@ -523,7 +523,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                   visit::fk_ctor(*) {\n                     self.in_ctor = true;\n                     self.declared_purity = decl.purity;\n-                    self.fn_args = @decl.inputs.map({|i| i.id});\n+                    self.fn_args = @decl.inputs.map(|i| i.id );\n                   }\n                   visit::fk_anon(*) |\n                   visit::fk_fn_block(*) if is_stack_closure {\n@@ -535,7 +535,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                   visit::fk_dtor(*) {\n                     self.in_ctor = false;\n                     self.declared_purity = decl.purity;\n-                    self.fn_args = @decl.inputs.map({|i| i.id});\n+                    self.fn_args = @decl.inputs.map(|i| i.id );\n                   }\n                 }\n \n@@ -582,7 +582,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n       ast::expr_fn_block(_, _, cap_clause) {\n-        for (*cap_clause).each { |cap_item|\n+        for (*cap_clause).each |cap_item| {\n             if cap_item.is_move {\n                 let def = self.tcx().def_map.get(cap_item.id);\n \n@@ -637,7 +637,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n fn check_loans_in_block(blk: ast::blk,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n-    do save_and_restore(self.declared_purity) {||\n+    do save_and_restore(self.declared_purity) || {\n         self.check_for_conflicting_loans(blk.node.id);\n \n         alt blk.node.rules {"}, {"sha": "443f135f46d99577be8db708d6c55eb55ea5cc7e", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -33,7 +33,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n     #debug[\"req_loans_in_expr(ex=%s)\", pprust::expr_to_str(ex)];\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    for tcx.borrowings.find(ex.id).each { |borrow|\n+    for tcx.borrowings.find(ex.id).each |borrow| {\n         let cmt = self.bccx.cat_borrow_of_expr(ex);\n         let scope_r = ty::re_scope(borrow.scope_id);\n         self.guarantee_valid(cmt, borrow.mutbl, scope_r);\n@@ -56,7 +56,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       ast::expr_call(f, args, _) {\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n         let scope_r = ty::re_scope(ex.id);\n-        do vec::iter2(args, arg_tys) { |arg, arg_ty|\n+        do vec::iter2(args, arg_tys) |arg, arg_ty| {\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_mutbl_ref {\n                 let arg_cmt = self.bccx.cat_expr(arg);\n@@ -114,8 +114,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n       ast::expr_alt(ex_v, arms, _) {\n         let cmt = self.bccx.cat_expr(ex_v);\n-        for arms.each { |arm|\n-            for arm.pats.each { |pat|\n+        for arms.each |arm| {\n+            for arm.pats.each |pat| {\n                 self.gather_pat(cmt, pat, arm.body.node.id, ex.id);\n             }\n         }\n@@ -215,7 +215,7 @@ impl methods for gather_loan_ctxt {\n             };\n \n             let result = {\n-                do self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n+                do self.check_mutbl(req_mutbl, cmt).chain |_ok| {\n                     self.bccx.preserve(cmt, opt_scope_id)\n                 }\n             };\n@@ -345,7 +345,7 @@ impl methods for gather_loan_ctxt {\n                                          not variant\", e])}\n             };\n \n-            for subpats.each { |subpat|\n+            for subpats.each |subpat| {\n                 let subcmt = self.bccx.cat_variant(subpat, enum_did, cmt);\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }\n@@ -375,22 +375,22 @@ impl methods for gather_loan_ctxt {\n \n             self.guarantee_valid(cmt1, m_const, arm_scope);\n \n-            for o_pat.each { |p|\n+            for o_pat.each |p| {\n                 self.gather_pat(cmt, p, arm_id, alt_id);\n             }\n           }\n \n           ast::pat_rec(field_pats, _) {\n             // {f1: p1, ..., fN: pN}\n-            for field_pats.each { |fp|\n+            for field_pats.each |fp| {\n                 let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n                 self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n             }\n           }\n \n           ast::pat_tup(subpats) {\n             // (p1, ..., pN)\n-            for subpats.each { |subpat|\n+            for subpats.each |subpat| {\n                 let subcmt = self.bccx.cat_tuple_elt(subpat, cmt);\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }"}, {"sha": "bdb4adacf7e34053d69c206d4e7077501ef01c57", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -38,9 +38,9 @@ fn check_capture_clause(tcx: ty::ctxt,\n     let freevars = freevars::get_freevars(tcx, fn_expr_id);\n     let seen_defs = map::int_hash();\n \n-    for (*cap_clause).each { |cap_item|\n+    for (*cap_clause).each |cap_item| {\n         let cap_def = tcx.def_map.get(cap_item.id);\n-        if !vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+        if !vec::any(*freevars, |fv| fv.def == cap_def ) {\n             tcx.sess.span_warn(\n                 cap_item.span,\n                 #fmt(\"captured variable '%s' not used in closure\",\n@@ -66,7 +66,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n \n     // first add entries for anything explicitly named in the cap clause\n \n-    for (*cap_clause).each { |cap_item|\n+    for (*cap_clause).each |cap_item| {\n         #debug(\"Doing capture var: %s (%?)\",\n                *cap_item.name, cap_item.id);\n \n@@ -75,7 +75,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n         if cap_item.is_move {\n             // if we are moving the value in, but it's not actually used,\n             // must drop it.\n-            if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+            if vec::any(*freevars, |fv| fv.def == cap_def ) {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n                                             cap_item: some(cap_item),\n@@ -89,7 +89,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n         } else {\n             // if we are copying the value in, but it's not actually used,\n             // just ignore it.\n-            if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+            if vec::any(*freevars, |fv| fv.def == cap_def ) {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n                                             cap_item: some(cap_item),\n@@ -106,7 +106,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n       ast::proto_bare | ast::proto_box | ast::proto_uniq { cap_copy }\n     };\n \n-    do vec::iter(*freevars) { |fvar|\n+    do vec::iter(*freevars) |fvar| {\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n         alt cap_map.find(fvar_def_id) {\n           option::some(_) { /* was explicitly named, do nothing */ }\n@@ -120,6 +120,6 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     }\n \n     let mut result = ~[];\n-    for cap_map.each_value { |cap_var| vec::push(result, cap_var); }\n+    for cap_map.each_value |cap_var| { vec::push(result, cap_var); }\n     ret result;\n }"}, {"sha": "1d72e3e95d5f56713f52654e6c9de6c9f4f81347", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -13,8 +13,8 @@ import std::map::hashmap;\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n-        visit_expr: {|a,b,c|check_expr(tcx, a, b, c)},\n-        visit_local: {|a,b,c|check_local(tcx, a, b, c)}\n+        visit_expr: |a,b,c| check_expr(tcx, a, b, c),\n+        visit_local: |a,b,c| check_local(tcx, a, b, c)\n         with *visit::default_visitor::<()>()\n     }));\n     tcx.sess.abort_if_errors();\n@@ -38,8 +38,8 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n // Check for unreachable patterns\n fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n     let mut seen = ~[];\n-    for arms.each {|arm|\n-        for arm.pats.each {|pat|\n+    for arms.each |arm| {\n+        for arm.pats.each |pat| {\n             let v = ~[pat];\n             alt is_useful(tcx, seen, v) {\n               not_useful {\n@@ -60,7 +60,7 @@ fn raw_pat(p: @pat) -> @pat {\n }\n \n fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n-    let ext = alt is_useful(tcx, vec::map(pats, {|p| ~[p]}), ~[wild()]) {\n+    let ext = alt is_useful(tcx, vec::map(pats, |p| ~[p]), ~[wild()]) {\n       not_useful { ret; } // This is good, wildcard pattern isn't reachable\n       useful_ { none }\n       useful(ty, ctor) {\n@@ -74,7 +74,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n           ty::ty_enum(id, _) {\n             let vid = alt check ctor { variant(id) { id } };\n             alt check vec::find(*ty::enum_variants(tcx, id),\n-                                {|v| v.id == vid}) {\n+                                |v| v.id == vid) {\n               some(v) { some(v.name) }\n             }\n           }\n@@ -114,7 +114,7 @@ enum ctor {\n fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n     if m.len() == 0u { ret useful_; }\n     if m[0].len() == 0u { ret not_useful; }\n-    let real_pat = alt vec::find(m, {|r| r[0].id != 0}) {\n+    let real_pat = alt vec::find(m, |r| r[0].id != 0) {\n       some(r) { r[0] } none { v[0] }\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil(tcx) }\n@@ -136,7 +136,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n                 }\n               }\n               ty::ty_enum(eid, _) {\n-                for (*ty::enum_variants(tcx, eid)).each {|va|\n+                for (*ty::enum_variants(tcx, eid)).each |va| {\n                     alt is_useful_specialized(tcx, m, v, variant(va.id),\n                                               va.args.len(), left_ty) {\n                       not_useful {}\n@@ -152,7 +152,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n             }\n           }\n           some(ctor) {\n-            alt is_useful(tcx, vec::filter_map(m, {|r| default(tcx, r)}),\n+            alt is_useful(tcx, vec::filter_map(m, |r| default(tcx, r) ),\n                           vec::tail(v)) {\n               useful_ { useful(left_ty, ctor) }\n               u { u }\n@@ -169,7 +169,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n \n fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n                           arity: uint, lty: ty::t) -> useful {\n-    let ms = vec::filter_map(m, {|r| specialize(tcx, r, ctor, arity, lty)});\n+    let ms = vec::filter_map(m, |r| specialize(tcx, r, ctor, arity, lty) );\n     alt is_useful(tcx, ms, option::get(specialize(tcx, v, ctor, arity, lty))){\n       useful_ { useful(lty, ctor) }\n       u { u }\n@@ -211,21 +211,21 @@ fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n     alt ty::get(left_ty).struct {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_tup(_) | ty::ty_rec(_) {\n-        for m.each {|r|\n+        for m.each |r| {\n             if !is_wild(tcx, r[0]) { ret none; }\n         }\n         ret some(single);\n       }\n       ty::ty_enum(eid, _) {\n         let mut found = ~[];\n-        for m.each {|r|\n-            do option::iter(pat_ctor_id(tcx, r[0])) {|id|\n+        for m.each |r| {\n+            do option::iter(pat_ctor_id(tcx, r[0])) |id| {\n                 if !vec::contains(found, id) { vec::push(found, id); }\n             }\n         }\n         let variants = ty::enum_variants(tcx, eid);\n         if found.len() != (*variants).len() {\n-            for vec::each(*variants) {|v|\n+            for vec::each(*variants) |v| {\n                 if !found.contains(variant(v.id)) {\n                     ret some(variant(v.id));\n                 }\n@@ -236,7 +236,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n       ty::ty_nil { none }\n       ty::ty_bool {\n         let mut true_found = false, false_found = false;\n-        for m.each {|r|\n+        for m.each |r| {\n             alt check pat_ctor_id(tcx, r[0]) {\n               none {}\n               some(val(const_int(1i64))) { true_found = true; }\n@@ -258,7 +258,7 @@ fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n       ty::ty_box(_) | ty::ty_uniq(_) { 1u }\n       ty::ty_enum(eid, _) {\n         let id = alt check ctor { variant(id) { id } };\n-        alt check vec::find(*ty::enum_variants(tcx, eid), {|v| v.id == id}) {\n+        alt check vec::find(*ty::enum_variants(tcx, eid), |v| v.id == id ) {\n           some(v) { v.args.len() }\n         }\n       }\n@@ -301,8 +301,8 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         let ty_flds = alt check ty::get(left_ty).struct {\n           ty::ty_rec(flds) { flds }\n         };\n-        let args = vec::map(ty_flds, {|ty_f|\n-            alt vec::find(flds, {|f| f.ident == ty_f.ident}) {\n+        let args = vec::map(ty_flds, |ty_f| {\n+            alt vec::find(flds, |f| f.ident == ty_f.ident ) {\n               some(f) { f.pat } _ { wild() }\n             }\n         });\n@@ -363,17 +363,17 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       pat_wild | pat_ident(_, none) { false }\n       pat_lit(_) | pat_range(_, _) { true }\n       pat_rec(fields, _) {\n-        for fields.each {|it|\n+        for fields.each |it| {\n             if is_refutable(tcx, it.pat) { ret true; }\n         }\n         false\n       }\n       pat_tup(elts) {\n-        for elts.each {|elt| if is_refutable(tcx, elt) { ret true; } }\n+        for elts.each |elt| { if is_refutable(tcx, elt) { ret true; } }\n         false\n       }\n       pat_enum(_, some(args)) {\n-        for args.each {|p| if is_refutable(tcx, p) { ret true; } };\n+        for args.each |p| { if is_refutable(tcx, p) { ret true; } };\n         false\n       }\n       pat_enum(_,_) { false }"}, {"sha": "16c714ac05740764c0e2e1128e9270cbd44a65e1", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -8,11 +8,10 @@ fn check_crate(sess: session, crate: @crate, ast_map: ast_map::map,\n                def_map: resolve::def_map,\n                 method_map: typeck::method_map, tcx: ty::ctxt) {\n     visit::visit_crate(*crate, false, visit::mk_vt(@{\n-        visit_item: {|a,b,c|check_item(sess, ast_map, def_map, a, b, c)},\n+        visit_item: |a,b,c| check_item(sess, ast_map, def_map, a, b, c),\n         visit_pat: check_pat,\n-        visit_expr: {|a,b,c|\n+        visit_expr: |a,b,c|\n             check_expr(sess, def_map, method_map, tcx, a, b, c)\n-        }\n         with *visit::default_visitor()\n     }));\n     sess.abort_if_errors();\n@@ -26,8 +25,8 @@ fn check_item(sess: session, ast_map: ast_map::map, def_map: resolve::def_map,\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(vs, _, _) {\n-        for vs.each {|var|\n-            do option::iter(var.node.disr_expr) {|ex|\n+        for vs.each |var| {\n+            do option::iter(var.node.disr_expr) |ex| {\n                 v.visit_expr(ex, true, v);\n             }\n         }"}, {"sha": "44fbdaef7ce40f82bf4756aae89c1124a69df1dc", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -6,10 +6,10 @@ type ctx = {in_loop: bool, can_ret: bool};\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(*crate, {in_loop: false,can_ret: true}, visit::mk_vt(@{\n-        visit_item: {|i, _cx, v|\n+        visit_item: |i, _cx, v| {\n             visit::visit_item(i, {in_loop: false, can_ret: true}, v);\n         },\n-        visit_expr: {|e: @expr, cx: ctx, v: visit::vt<ctx>|\n+        visit_expr: |e: @expr, cx: ctx, v: visit::vt<ctx>| {\n             alt e.node {\n               expr_while(e, b) {\n                 v.visit_expr(e, cx, v);"}, {"sha": "1f73a8fc999f2db4ebfa6c18536e61d47e37890c", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -101,7 +101,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         if !is_move { check_copy(cx, id, var_t, sp, is_implicit); }\n \n         // check that only immutable variables are implicitly copied in\n-        for fv.each { |fv|\n+        for fv.each |fv| {\n             check_imm_free_var(cx, fv.def, fv.span);\n         }\n     }\n@@ -113,7 +113,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         if !is_move { check_copy(cx, id, var_t, sp, is_implicit); }\n \n         // check that only immutable variables are implicitly copied in\n-        for fv.each { |fv|\n+        for fv.each |fv| {\n             check_imm_free_var(cx, fv.def, fv.span);\n         }\n     }\n@@ -150,7 +150,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n \n     // Find the check function that enforces the appropriate bounds for this\n     // kind of function:\n-    do with_appropriate_checker(cx, fn_id) { |chk|\n+    do with_appropriate_checker(cx, fn_id) |chk| {\n \n         // Begin by checking the variables in the capture clause, if any.\n         // Here we slightly abuse the map function to both check and report\n@@ -162,7 +162,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n           visit::fk_item_fn(*) | visit::fk_method(*) |\n           visit::fk_ctor(*) | visit::fk_dtor(*) { @~[] }\n         };\n-        let captured_vars = do (*cap_clause).map { |cap_item|\n+        let captured_vars = do (*cap_clause).map |cap_item| {\n             let cap_def = cx.tcx.def_map.get(cap_item.id);\n             let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n             let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n@@ -172,7 +172,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n \n         // Iterate over any free variables that may not have appeared in the\n         // capture list.  Ensure that they too are of the appropriate kind.\n-        for vec::each(*freevars::get_freevars(cx.tcx, fn_id)) {|fv|\n+        for vec::each(*freevars::get_freevars(cx.tcx, fn_id)) |fv| {\n             let id = ast_util::def_id_of_def(fv.def).node;\n \n             // skip over free variables that appear in the cap clause\n@@ -217,7 +217,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         check_copy_ex(cx, rs, false);\n       }\n       expr_rec(fields, def) {\n-        for fields.each {|field| maybe_copy(cx, field.node.expr); }\n+        for fields.each |field| { maybe_copy(cx, field.node.expr); }\n         alt def {\n           some(ex) {\n             // All noncopyable fields must be overridden\n@@ -226,8 +226,8 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n               ty::ty_rec(f) { f }\n               _ { cx.tcx.sess.span_bug(ex.span, \"bad expr type in record\"); }\n             };\n-            for ty_fields.each {|tf|\n-                if !vec::any(fields, {|f| f.node.ident == tf.ident}) &&\n+            for ty_fields.each |tf| {\n+                if !vec::any(fields, |f| f.node.ident == tf.ident ) &&\n                     !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n                     cx.tcx.sess.span_err(ex.span,\n                                          \"copying a noncopyable value\");\n@@ -238,11 +238,11 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_tup(exprs) | expr_vec(exprs, _) {\n-        for exprs.each {|expr| maybe_copy(cx, expr); }\n+        for exprs.each |expr| { maybe_copy(cx, expr); }\n       }\n       expr_call(f, args, _) {\n         let mut i = 0u;\n-        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each {|arg_t|\n+        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n             alt ty::arg_mode(cx.tcx, arg_t) {\n               by_copy { maybe_copy(cx, args[i]); }\n               by_ref | by_val | by_mutbl_ref | by_move { }\n@@ -251,7 +251,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_path(_) | expr_field(_, _, _) {\n-        do option::iter(cx.tcx.node_type_substs.find(e.id)) {|ts|\n+        do option::iter(cx.tcx.node_type_substs.find(e.id)) |ts| {\n             let bounds = alt check e.node {\n               expr_path(_) {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n@@ -286,7 +286,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                   %s (%u tys), declared = %? (%u tys)\",\n                   tys_to_str(cx.tcx, ts), ts.len(), *bounds, (*bounds).len());\n             }\n-            do vec::iter2(ts, *bounds) {|ty, bound|\n+            do vec::iter2(ts, *bounds) |ty, bound| {\n                 check_bounds(cx, e.id, e.span, ty, bound)\n             }\n         }\n@@ -299,7 +299,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     alt stmt.node {\n       stmt_decl(@{node: decl_local(locals), _}, _) {\n-        for locals.each {|local|\n+        for locals.each |local| {\n             alt local.node.init {\n               some({op: init_assign, expr}) { maybe_copy(cx, expr); }\n               _ {}\n@@ -314,10 +314,10 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n fn check_ty(aty: @ty, cx: ctx, v: visit::vt<ctx>) {\n     alt aty.node {\n       ty_path(_, id) {\n-        do option::iter(cx.tcx.node_type_substs.find(id)) {|ts|\n+        do option::iter(cx.tcx.node_type_substs.find(id)) |ts| {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n-            do vec::iter2(ts, *bounds) {|ty, bound|\n+            do vec::iter2(ts, *bounds) |ty, bound| {\n                 check_bounds(cx, aty.id, aty.span, ty, bound)\n             }\n         }"}, {"sha": "ec35f7046aa38fb6a1e3f873463cd27f4dcc6483", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -211,10 +211,10 @@ impl methods for ctxt {\n         let mut new_ctxt = self;\n \n         let metas = attr::attr_metas(attr::find_attrs_by_name(attrs, \"warn\"));\n-        for metas.each {|meta|\n+        for metas.each |meta| {\n             alt meta.node {\n               ast::meta_list(_, metas) {\n-                for metas.each {|meta|\n+                for metas.each |meta| {\n                     alt meta.node {\n                       ast::meta_word(lintname) {\n                         alt lookup_lint(self.dict, *lintname) {\n@@ -273,7 +273,7 @@ fn lookup_lint(dict: lint_dict, s: str)\n }\n \n fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n-    do cx.with_warn_attrs(i.attrs) {|cx|\n+    do cx.with_warn_attrs(i.attrs) |cx| {\n         if !cx.is_default {\n             cx.sess.warning_settings.settings_map.insert(i.id, cx.curr);\n         }\n@@ -289,17 +289,17 @@ fn build_settings_crate(sess: session::session, crate: @ast::crate) {\n               sess: sess};\n \n     // Install defaults.\n-    for cx.dict.each {|_k, spec| cx.set_level(spec.lint, spec.default); }\n+    for cx.dict.each |_k, spec| { cx.set_level(spec.lint, spec.default); }\n \n     // Install command-line options, overriding defaults.\n-    for sess.opts.lint_opts.each {|pair|\n+    for sess.opts.lint_opts.each |pair| {\n         let (lint,level) = pair;\n         cx.set_level(lint, level);\n     }\n \n-    do cx.with_warn_attrs(crate.node.attrs) {|cx|\n+    do cx.with_warn_attrs(crate.node.attrs) |cx| {\n         // Copy out the default settings\n-        for cx.curr.each {|k, v|\n+        for cx.curr.each |k, v| {\n             sess.warning_settings.default_settings.insert(k, v);\n         }\n \n@@ -327,7 +327,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n // not traverse into subitems, since that is handled by the outer\n // lint visitor.\n fn item_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n-    visit::mk_vt(@{visit_item: {|_i, _e, _v| } with **v})\n+    visit::mk_vt(@{visit_item: |_i, _e, _v| { } with **v})\n }\n \n fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n@@ -357,8 +357,8 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                        decl: ast::fn_decl) {\n-        let tys = vec::map(decl.inputs, {|a| a.ty });\n-        for vec::each(vec::append_one(tys, decl.output)) {|ty|\n+        let tys = vec::map(decl.inputs, |a| a.ty );\n+        for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             alt ty.node {\n               ast::ty_path(_, id) {\n                 alt cx.def_map.get(id) {\n@@ -387,7 +387,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_foreign_mod(nmod) if attr::foreign_abi(it.attrs) !=\n       either::right(ast::foreign_abi_rust_intrinsic) {\n-        for nmod.items.each {|ni|\n+        for nmod.items.each |ni| {\n             alt ni.node {\n               ast::foreign_item_fn(decl, tps) {\n                 check_foreign_fn(cx, it.id, decl);"}, {"sha": "fe05e817a203646f725c88c700559b091816436f", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -351,7 +351,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n     #debug[\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint];\n \n-    for decl.inputs.each { |arg|\n+    for decl.inputs.each |arg| {\n         #debug[\"adding argument %d\", arg.id];\n         let mode = ty::resolved_mode(self.tcx, arg.mode);\n         (*fn_maps).add_variable(vk_arg(arg.id, arg.ident, mode));\n@@ -397,7 +397,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n }\n \n fn add_class_fields(self: @ir_maps, did: def_id) {\n-    for ty::lookup_class_fields(self.tcx, did).each { |field_ty|\n+    for ty::lookup_class_fields(self.tcx, did).each |field_ty| {\n         assert field_ty.id.crate == local_crate;\n         let var = (*self).add_variable(vk_field(field_ty.ident));\n         self.field_map.insert(field_ty.ident, var);\n@@ -406,7 +406,7 @@ fn add_class_fields(self: @ir_maps, did: def_id) {\n \n fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n     let def_map = self.tcx.def_map;\n-    do pat_util::pat_bindings(def_map, local.node.pat) { |p_id, sp, path|\n+    do pat_util::pat_bindings(def_map, local.node.pat) |p_id, sp, path| {\n         #debug[\"adding local variable %d\", p_id];\n         let name = ast_util::path_to_ident(path);\n         (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n@@ -436,7 +436,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n         let cvs = capture::compute_capture_vars(self.tcx, expr.id,\n                                                 proto, cap_clause);\n         let mut call_caps = ~[];\n-        for cvs.each { |cv|\n+        for cvs.each |cv| {\n             alt relevant_def(cv.def) {\n               some(rv) {\n                 let cv_ln = (*self).add_live_node(lnk_freevar(cv.span));\n@@ -560,9 +560,9 @@ class liveness {\n         alt expr.node {\n           expr_path(_) {\n             let def = self.tcx.def_map.get(expr.id);\n-            relevant_def(def).map({ |rdef|\n-                self.variable_from_rdef(rdef, expr.span)\n-            })\n+            relevant_def(def).map(\n+                |rdef| self.variable_from_rdef(rdef, expr.span)\n+            )\n           }\n           _ {none}\n         }\n@@ -576,9 +576,9 @@ class liveness {\n                              span: span) -> option<variable> {\n         alt self.tcx.def_map.find(node_id) {\n           some(def) {\n-            relevant_def(def).map({ |rdef|\n-              self.variable_from_rdef(rdef, span)\n-            })\n+            relevant_def(def).map(\n+                |rdef| self.variable_from_rdef(rdef, span)\n+            )\n           }\n           none {\n             self.tcx.sess.span_bug(\n@@ -589,7 +589,7 @@ class liveness {\n \n     fn pat_bindings(pat: @pat, f: fn(live_node, variable, span)) {\n         let def_map = self.tcx.def_map;\n-        do pat_util::pat_bindings(def_map, pat) {|p_id, sp, _n|\n+        do pat_util::pat_bindings(def_map, pat) |p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(ln, var, sp);\n@@ -635,7 +635,7 @@ class liveness {\n \n     fn indices(ln: live_node, op: fn(uint)) {\n         let node_base_idx = self.idx(ln, variable(0u));\n-        for uint::range(0u, self.ir.num_vars) { |var_idx|\n+        for uint::range(0u, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx)\n         }\n     }\n@@ -644,7 +644,7 @@ class liveness {\n                 op: fn(uint, uint)) {\n         let node_base_idx = self.idx(ln, variable(0u));\n         let succ_base_idx = self.idx(succ_ln, variable(0u));\n-        for uint::range(0u, self.ir.num_vars) { |var_idx|\n+        for uint::range(0u, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n@@ -653,7 +653,7 @@ class liveness {\n                   ln: live_node,\n                   test: fn(uint) -> live_node) {\n         let node_base_idx = self.idx(ln, variable(0u));\n-        for uint::range(0u, self.ir.num_vars) { |var_idx|\n+        for uint::range(0u, self.ir.num_vars) |var_idx| {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 wr.write_str(\" \");\n@@ -663,15 +663,15 @@ class liveness {\n     }\n \n     fn ln_str(ln: live_node) -> str {\n-        do io::with_str_writer { |wr|\n+        do io::with_str_writer |wr| {\n             wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(\") of kind \");\n             wr.write_str(#fmt[\"%?\", copy self.ir.lnks[*ln]]);\n             wr.write_str(\" reads\");\n-            self.write_vars(wr, ln, {|idx| self.users[idx].reader});\n+            self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             wr.write_str(\"  writes\");\n-            self.write_vars(wr, ln, {|idx| self.users[idx].writer});\n+            self.write_vars(wr, ln, |idx| self.users[idx].writer );\n             wr.write_str(\" \");\n             wr.write_str(\" precedes \");\n             wr.write_str((copy self.successors[*ln]).to_str());\n@@ -695,8 +695,8 @@ class liveness {\n     fn init_from_succ(ln: live_node, succ_ln: live_node) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[*ln] = succ_ln;\n-        self.indices2(ln, succ_ln, { |idx, succ_idx|\n-            self.users[idx] = self.users[succ_idx];\n+        self.indices2(ln, succ_ln, |idx, succ_idx| {\n+            self.users[idx] = self.users[succ_idx]\n         });\n         #debug[\"init_from_succ(ln=%s, succ=%s)\",\n                self.ln_str(ln), self.ln_str(succ_ln)];\n@@ -707,7 +707,7 @@ class liveness {\n         if ln == succ_ln { ret false; }\n \n         let mut changed = false;\n-        do self.indices2(ln, succ_ln) { |idx, succ_idx|\n+        do self.indices2(ln, succ_ln) |idx, succ_idx| {\n             changed |= copy_if_invalid(copy self.users[succ_idx].reader,\n                                        self.users[idx].reader);\n             changed |= copy_if_invalid(copy self.users[succ_idx].writer,\n@@ -776,14 +776,14 @@ class liveness {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n         let entry_ln: live_node =\n-            self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln, {||\n+            self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln, || {\n                 self.propagate_through_fn_block(decl, body)\n             });\n \n         // hack to skip the loop unless #debug is enabled:\n         #debug[\"^^ liveness computation results for body %d (entry=%s)\",\n                {\n-                   for uint::range(0u, self.ir.num_live_nodes) { |ln_idx|\n+                   for uint::range(0u, self.ir.num_live_nodes) |ln_idx| {\n                        #debug[\"%s\", self.ln_str(live_node(ln_idx))];\n                    }\n                    body.node.id\n@@ -795,7 +795,7 @@ class liveness {\n \n     fn propagate_through_fn_block(decl: fn_decl, blk: blk) -> live_node {\n         // inputs passed by & mode should be considered live on exit:\n-        for decl.inputs.each { |arg|\n+        for decl.inputs.each |arg| {\n             alt ty::resolved_mode(self.tcx, arg.mode) {\n               by_mutbl_ref | by_ref | by_val {\n                 // These are \"non-owned\" modes, so register a read at\n@@ -816,7 +816,7 @@ class liveness {\n         self.acc(self.s.exit_ln, self.s.self_var, ACC_READ);\n \n         // in a ctor, there is an implicit use of self.f for all fields f:\n-        for self.ir.field_map.each_value { |var|\n+        for self.ir.field_map.each_value |var| {\n             self.acc(self.s.exit_ln, var, ACC_READ|ACC_USE);\n         }\n \n@@ -832,7 +832,7 @@ class liveness {\n \n     fn propagate_through_block(blk: blk, succ: live_node) -> live_node {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n-        do blk.node.stmts.foldr(succ) { |stmt, succ|\n+        do blk.node.stmts.foldr(succ) |stmt, succ| {\n             self.propagate_through_stmt(stmt, succ)\n         }\n     }\n@@ -852,7 +852,7 @@ class liveness {\n     fn propagate_through_decl(decl: @decl, succ: live_node) -> live_node {\n         alt decl.node {\n           decl_local(locals) {\n-            do locals.foldr(succ) { |local, succ|\n+            do locals.foldr(succ) |local, succ| {\n                 self.propagate_through_local(local, succ)\n             }\n           }\n@@ -877,9 +877,9 @@ class liveness {\n         // initialization, which is mildly more complex than checking\n         // once at the func header but otherwise equivalent.\n \n-        let opt_init = local.node.init.map({ |i| i.expr });\n+        let opt_init = local.node.init.map(|i| i.expr );\n         let mut succ = self.propagate_through_opt_expr(opt_init, succ);\n-        do self.pat_bindings(local.node.pat) { |ln, var, _sp|\n+        do self.pat_bindings(local.node.pat) |ln, var, _sp| {\n             self.init_from_succ(ln, succ);\n             self.define(ln, var);\n             succ = ln;\n@@ -889,14 +889,14 @@ class liveness {\n \n     fn propagate_through_exprs(exprs: ~[@expr],\n                                succ: live_node) -> live_node {\n-        do exprs.foldr(succ) { |expr, succ|\n+        do exprs.foldr(succ) |expr, succ| {\n             self.propagate_through_expr(expr, succ)\n         }\n     }\n \n     fn propagate_through_opt_expr(opt_expr: option<@expr>,\n                                   succ: live_node) -> live_node {\n-        do opt_expr.foldl(succ) { |succ, expr|\n+        do opt_expr.foldl(succ) |succ, expr| {\n             self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -930,7 +930,7 @@ class liveness {\n             // the construction of a closure itself is not important,\n             // but we have to consider the closed over variables.\n             let caps = (*self.ir).captures(expr);\n-            do (*caps).foldr(succ) { |cap, succ|\n+            do (*caps).foldr(succ) |cap, succ| {\n                 self.init_from_succ(cap.ln, succ);\n                 let var = self.variable_from_rdef(cap.rv, expr.span);\n                 self.acc(cap.ln, var, ACC_READ | ACC_USE);\n@@ -987,7 +987,7 @@ class liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for arms.each { |arm|\n+            for arms.each |arm| {\n                 let arm_succ =\n                     self.propagate_through_opt_expr(\n                         arm.guard,\n@@ -1063,7 +1063,7 @@ class liveness {\n \n           expr_rec(fields, with_expr) {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do fields.foldr(succ) { |field, succ|\n+            do fields.foldr(succ) |field, succ| {\n                 self.propagate_through_expr(field.node.expr, succ)\n             }\n           }\n@@ -1241,7 +1241,7 @@ class liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n                 self.init_from_succ(ln, succ);\n-                for self.ir.field_map.each_value { |var|\n+                for self.ir.field_map.each_value |var| {\n                     self.acc(ln, var, acc);\n                 }\n             }\n@@ -1273,7 +1273,7 @@ class liveness {\n             alt def {\n               def_self(_) {\n                 // Note: the field_map is empty unless we are in a ctor\n-                ret self.ir.field_map.find(fld).map({ |var|\n+                ret self.ir.field_map.find(fld).map(|var| {\n                     let ln = self.live_node(expr.id, expr.span);\n                     (ln, var)\n                 });\n@@ -1320,15 +1320,15 @@ class liveness {\n             first_merge = false;\n         }\n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n-        let body_ln = self.with_loop_nodes(succ, ln, {||\n+        let body_ln = self.with_loop_nodes(succ, ln, || {\n             self.propagate_through_block(body, cond_ln)\n         });\n \n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n             assert cond_ln == self.propagate_through_opt_expr(cond, ln);\n-            assert body_ln == self.with_loop_nodes(succ, ln, {||\n+            assert body_ln == self.with_loop_nodes(succ, ln, || {\n                 self.propagate_through_block(body, cond_ln)\n             });\n         }\n@@ -1373,7 +1373,7 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n         // should not be live at this point.\n \n         #debug[\"check_local() with no initializer\"];\n-        do (*self).pat_bindings(local.node.pat) { |ln, var, sp|\n+        do (*self).pat_bindings(local.node.pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 alt (*self).live_on_exit(ln, var) {\n                   none { /* not live: good */ }\n@@ -1394,7 +1394,7 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n     alt expr.node {\n       expr_path(_) {\n-        for (*self).variable_from_def_map(expr.id, expr.span).each { |var|\n+        for (*self).variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = (*self).live_node(expr.id, expr.span);\n             self.consider_last_use(expr, ln, var);\n         }\n@@ -1404,7 +1404,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n \n       expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n         let caps = (*self.ir).captures(expr);\n-        for (*caps).each { |cap|\n+        for (*caps).each |cap| {\n             let var = (*self).variable_from_rdef(cap.rv, expr.span);\n             self.consider_last_use(expr, cap.ln, var);\n             if cap.is_move {\n@@ -1438,7 +1438,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_call(f, args, _) {\n         let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n         vt.visit_expr(f, self, vt);\n-        do vec::iter2(args, targs) { |arg_expr, arg_ty|\n+        do vec::iter2(args, targs) |arg_expr, arg_ty| {\n             alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n               by_val | by_copy | by_ref | by_mutbl_ref{\n                 vt.visit_expr(arg_expr, self, vt);\n@@ -1480,7 +1480,7 @@ enum read_kind {\n \n impl check_methods for @liveness {\n     fn check_fields(sp: span, entry_ln: live_node) {\n-        for self.ir.field_map.each { |nm, var|\n+        for self.ir.field_map.each |nm, var| {\n             alt (*self).live_on_entry(entry_ln, var) {\n               none { /* ok */ }\n               some(lnk_exit) {\n@@ -1621,7 +1621,7 @@ impl check_methods for @liveness {\n     }\n \n     fn check_for_reassignments_in_pat(pat: @pat) {\n-        do (*self).pat_bindings(pat) { |ln, var, sp|\n+        do (*self).pat_bindings(pat) |ln, var, sp| {\n             self.check_for_reassignment(ln, var, sp);\n         }\n     }\n@@ -1728,7 +1728,7 @@ impl check_methods for @liveness {\n     }\n \n     fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: live_node) {\n-        for decl.inputs.each { |arg|\n+        for decl.inputs.each |arg| {\n             let var = (*self).variable(arg.id, arg.ty.span);\n             alt ty::resolved_mode(self.tcx, arg.mode) {\n               by_mutbl_ref {\n@@ -1752,7 +1752,7 @@ impl check_methods for @liveness {\n     }\n \n     fn warn_about_unused_or_dead_vars_in_pat(pat: @pat) {\n-        do (*self).pat_bindings(pat) { |ln, var, sp|\n+        do (*self).pat_bindings(pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 self.warn_about_dead_assign(sp, ln, var);\n             }\n@@ -1761,7 +1761,7 @@ impl check_methods for @liveness {\n \n     fn warn_about_unused(sp: span, ln: live_node, var: variable) -> bool {\n         if !(*self).used_on_entry(ln, var) {\n-            for self.should_warn(var).each { |name|\n+            for self.should_warn(var).each |name| {\n \n                 // annoying: for parameters in funcs like `fn(x: int)\n                 // {ret}`, there is only one node, so asking about\n@@ -1788,7 +1788,7 @@ impl check_methods for @liveness {\n \n     fn warn_about_dead_assign(sp: span, ln: live_node, var: variable) {\n         if (*self).live_on_exit(ln, var).is_none() {\n-            for self.should_warn(var).each { |name|\n+            for self.should_warn(var).each |name| {\n                 self.tcx.sess.span_warn(\n                     sp,\n                     #fmt[\"value assigned to `%s` is never read\", *name]);"}, {"sha": "16be926d7be1d4ca9de0adefcdb31137d8558d50", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -15,7 +15,7 @@ type pat_id_map = std::map::hashmap<ident, node_id>;\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(dm: resolve::def_map, pat: @pat) -> pat_id_map {\n     let map = std::map::box_str_hash();\n-    do pat_bindings(dm, pat) {|p_id, _s, n|\n+    do pat_bindings(dm, pat) |p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };\n     ret map;\n@@ -39,7 +39,7 @@ fn pat_is_variant(dm: resolve::def_map, pat: @pat) -> bool {\n // Could return a constrained type in order to express that (future work)\n fn pat_bindings(dm: resolve::def_map, pat: @pat,\n                 it: fn(node_id, span, @path)) {\n-    do walk_pat(pat) {|p|\n+    do walk_pat(pat) |p| {\n         alt p.node {\n           pat_ident(pth, _) if !pat_is_variant(dm, p) {\n             it(p.id, p.span, pth);\n@@ -51,6 +51,6 @@ fn pat_bindings(dm: resolve::def_map, pat: @pat,\n \n fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> ~[node_id] {\n     let mut found = ~[];\n-    pat_bindings(dm, pat, {|b_id, _sp, _pt| vec::push(found, b_id); });\n+    pat_bindings(dm, pat, |b_id, _sp, _pt| vec::push(found, b_id) );\n     ret found;\n }"}, {"sha": "15faf3d2b7c36578c325f4cea5725c36b84d94f5", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -332,7 +332,7 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n         // although the capture items are not expressions per se, they\n         // do get \"evaluated\" in some sense as copies or moves of the\n         // relevant variables so we parent them like an expression\n-        for (*cap_clause).each { |cap_item|\n+        for (*cap_clause).each |cap_item| {\n             record_parent(cx, cap_item.id);\n         }\n         visit::visit_expr(expr, cx, visitor);\n@@ -375,7 +375,7 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n             fn_cx.parent: %?\",\n            body.node.id, cx.parent, fn_cx.parent];\n \n-    for decl.inputs.each { |input|\n+    for decl.inputs.each |input| {\n         cx.region_map.insert(input.id, body.node.id);\n     }\n "}, {"sha": "143901a9eadaf633647f69ecc8a5d1f5017f51e1", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 130, "deletions": 130, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -79,7 +79,7 @@ fn new_ext_hash() -> ext_hash {\n         ret ast_util::def_eq(v1.did, v2.did) &&\n             str::eq(*v1.ident, *v2.ident) && v1.ns == v2.ns;\n     }\n-    std::map::hashmap(hash, {|a, b| a == b})\n+    std::map::hashmap(hash, |a, b| a == b)\n }\n \n enum mod_index_entry {\n@@ -158,7 +158,7 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n     check_for_collisions(e, *crate);\n \n     // FIXME: move this to the lint pass when rewriting resolve. (#1634)\n-    for sess.opts.lint_opts.each {|pair|\n+    for sess.opts.lint_opts.each |pair| {\n         let (lint,level) = pair;\n         if lint == lint::unused_imports && level != lint::ignore {\n             check_unused_imports(e, level);\n@@ -192,7 +192,7 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     alt vi.node {\n       ast::view_item_export(vps) {\n-        for vps.each {|vp|\n+        for vps.each |vp| {\n             f(vp);\n         }\n       }\n@@ -203,7 +203,7 @@ fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     alt vi.node {\n       ast::view_item_import(vps) {\n-        for vps.each {|vp| f(vp);}\n+        for vps.each |vp| { f(vp);}\n       }\n       _ {}\n     }\n@@ -212,7 +212,7 @@ fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n fn iter_effective_import_paths(vi: ast::view_item,\n                                f: fn(vp: @ast::view_path)) {\n     iter_import_paths(vi, f);\n-    do iter_export_paths(vi) {|vp|\n+    do iter_export_paths(vi) |vp| {\n         alt vp.node {\n           ast::view_path_simple(_, _, _) { }\n           // FIXME (but also see #1893): support uniform ident-list exports\n@@ -231,7 +231,7 @@ fn iter_effective_import_paths(vi: ast::view_item,\n fn map_crate(e: @env, c: @ast::crate) {\n \n     fn index_vi(e: @env, i: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n-        do iter_effective_import_paths(*i) { |vp|\n+        do iter_effective_import_paths(*i) |vp| {\n             alt vp.node {\n               ast::view_path_simple(name, path, id) {\n                 e.imports.insert(id, todo(name, @path.idents, vp.span,\n@@ -241,7 +241,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                 e.imports.insert(id, is_glob(@path.idents, sc, vp.span));\n               }\n               ast::view_path_list(mod_path, idents, _) {\n-                for idents.each {|ident|\n+                for idents.each |ident| {\n                     let t = todo(ident.node.name,\n                                  @(vec::append_one(mod_path.idents,\n                                                    ident.node.name)),\n@@ -255,7 +255,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n \n     fn path_from_scope(sc: scopes, n: str) -> str {\n         let mut path = n + \"::\";\n-        do list::iter(sc) {|s|\n+        do list::iter(sc) |s| {\n             alt s {\n               scope_item(i) { path = *i.ident + \"::\" + path; }\n               _ {}\n@@ -294,7 +294,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n     // So we wind up reusing the glob-import machinery when looking at\n     // glob exports. They just do re-exporting in a later step.\n     fn link_glob(e: @env, vi: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n-        do iter_effective_import_paths(*vi) { |vp|\n+        do iter_effective_import_paths(*vi) |vp| {\n             alt vp.node {\n               ast::view_path_glob(path, _) {\n                 alt follow_import(*e, sc, path.idents, vp.span) {\n@@ -329,8 +329,8 @@ fn map_crate(e: @env, c: @ast::crate) {\n \n     // First, find all the modules, and index the names that they contain\n     let v_map_mod =\n-        @{visit_view_item: {|a,b,c|index_vi(e, a, b, c)},\n-          visit_item: {|a,b,c|index_i(e, a, b, c)},\n+        @{visit_view_item: |a,b,c| index_vi(e, a, b, c),\n+          visit_item: |a,b,c| index_i(e, a, b, c),\n           visit_block: visit_block_with_scope\n           with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, top_scope(), visit::mk_vt(v_map_mod));\n@@ -346,17 +346,17 @@ fn map_crate(e: @env, c: @ast::crate) {\n \n     // Next, assemble the links for globbed imports and exports.\n     let v_link_glob =\n-        @{visit_view_item: {|a,b,c|link_glob(e, a, b, c)},\n+        @{visit_view_item: |a,b,c| link_glob(e, a, b, c),\n           visit_block: visit_block_with_scope,\n-          visit_item: {|a,b,c|visit_item_with_scope(e, a, b, c)}\n+          visit_item: |a,b,c| visit_item_with_scope(e, a, b, c)\n           with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, top_scope(), visit::mk_vt(v_link_glob));\n \n }\n \n fn resolve_imports(e: env) {\n     e.used_imports.track = true;\n-    for e.imports.each {|id, v|\n+    for e.imports.each |id, v| {\n         alt check v {\n           todo(name, path, span, scopes) {\n             resolve_import(e, id, name, *path, span, scopes);\n@@ -372,7 +372,7 @@ fn resolve_imports(e: env) {\n // using lint-specific control flags presently but resolve-specific data\n // structures. Should use the general lint framework (with scopes, attrs).\n fn check_unused_imports(e: @env, level: lint::level) {\n-    for e.imports.each {|k, v|\n+    for e.imports.each |k, v| {\n         alt v {\n             resolved(_, _, _, _, name, sp) {\n               if !vec::contains(e.used_imports.data, k) {\n@@ -415,17 +415,17 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     e.used_imports.track = true;\n     let v =\n         @{visit_foreign_item: visit_foreign_item_with_scope,\n-          visit_item: {|a,b,c|walk_item(e, a, b, c)},\n+          visit_item: |a,b,c| walk_item(e, a, b, c),\n           visit_block: visit_block_with_scope,\n           visit_decl: visit_decl_with_scope,\n           visit_arm: visit_arm_with_scope,\n-          visit_local: {|a,b,c|visit_local_with_scope(e, a, b, c)},\n-          visit_pat: {|a,b,c|walk_pat(e, a, b, c)},\n-          visit_expr: {|a,b,c|walk_expr(e, a, b ,c)},\n-          visit_ty: {|a,b,c|walk_ty(e, a, b, c)},\n-          visit_ty_params: {|a,b,c|walk_tps(e, a, b, c)},\n-          visit_constr: {|a,b,c,d,f|walk_constr(e, a, b, c, d, f)},\n-          visit_fn: {|a,b,c,d,f,g,h|\n+          visit_local: |a,b,c| visit_local_with_scope(e, a, b, c),\n+          visit_pat: |a,b,c| walk_pat(e, a, b, c),\n+          visit_expr: |a,b,c| walk_expr(e, a, b ,c),\n+          visit_ty: |a,b,c| walk_ty(e, a, b, c),\n+          visit_ty_params: |a,b,c| walk_tps(e, a, b, c),\n+          visit_constr: |a,b,c,d,f| walk_constr(e, a, b, c, d, f),\n+          visit_fn: |a,b,c,d,f,g,h| {\n               visit_fn_with_scope(e, a, b, c, d, f, g, h)\n           }\n           with *visit::default_visitor()};\n@@ -440,10 +440,10 @@ fn resolve_names(e: @env, c: @ast::crate) {\n              refer to, so it's possible to resolve them.\n            */\n           ast::item_impl(_, _, ifce, _, _) {\n-            ifce.iter({|p| resolve_iface_ref(p, sc, e);})\n+            ifce.iter(|p| resolve_iface_ref(p, sc, e))\n           }\n           ast::item_class(_, ifaces, _, _, _, _) {\n-            for ifaces.each {|p|\n+            for ifaces.each |p| {\n                resolve_iface_ref(p, sc, e);\n             }\n           }\n@@ -460,7 +460,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           }\n           ast::expr_fn(_, _, _, cap_clause) |\n           ast::expr_fn_block(_, _, cap_clause) {\n-            for (*cap_clause).each { |ci|\n+            for (*cap_clause).each |ci| {\n                 resolve_capture_item(e, sc, ci);\n             }\n           }\n@@ -481,9 +481,9 @@ fn resolve_names(e: @env, c: @ast::crate) {\n                 &&sc: scopes, v: vt<scopes>) {\n         let outer_current_tp = e.current_tp;\n         let mut current = 0u;\n-        for tps.each {|tp|\n+        for tps.each |tp| {\n             e.current_tp = some(current);\n-            for vec::each(*tp.bounds) {|bound|\n+            for vec::each(*tp.bounds) |bound| {\n                 alt bound {\n                   bound_iface(t) { v.visit_ty(t, sc, v); }\n                   _ {}\n@@ -554,9 +554,9 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n     alt i.node {\n       ast::item_impl(tps, _, ifce, sty, methods) {\n         v.visit_ty_params(tps, sc, v);\n-        option::iter(ifce, {|p| visit::visit_path(p.path, sc, v)});\n+        option::iter(ifce, |p| visit::visit_path(p.path, sc, v));\n         v.visit_ty(sty, sc, v);\n-        for methods.each {|m|\n+        for methods.each |m| {\n             v.visit_ty_params(m.tps, sc, v);\n             let msc = @cons(scope_method(m.self_id, vec::append(tps, m.tps)),\n                             sc);\n@@ -567,10 +567,10 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n       ast::item_iface(tps, _, methods) {\n         v.visit_ty_params(tps, sc, v);\n         let isc = @cons(scope_method(i.id, tps), sc);\n-        for methods.each {|m|\n+        for methods.each |m| {\n             v.visit_ty_params(m.tps, isc, v);\n             let msc = @cons(scope_method(i.id, vec::append(tps, m.tps)), sc);\n-            for m.decl.inputs.each {|a| v.visit_ty(a.ty, msc, v); }\n+            for m.decl.inputs.each |a| { v.visit_ty(a.ty, msc, v); }\n             v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n@@ -581,14 +581,14 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n         let ctor_scope = @cons(scope_method(ctor.node.self_id, tps),\n                                class_scope);\n         /* visit the iface refs in the class scope */\n-        for ifaces.each {|p|\n+        for ifaces.each |p| {\n             visit::visit_path(p.path, class_scope, v);\n         }\n         visit_fn_with_scope(e, visit::fk_ctor(i.ident, tps, ctor.node.self_id,\n                                              local_def(i.id)), ctor.node.dec,\n                             ctor.node.body, ctor.span, ctor.node.id,\n                             ctor_scope, v);\n-        do option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) |dtor| {\n           let dtor_scope = @cons(scope_method(dtor.node.self_id, tps),\n                                  class_scope);\n \n@@ -599,7 +599,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n                             dtor_scope, v);\n         };\n         /* visit the items */\n-        for members.each {|cm|\n+        for members.each |cm| {\n             alt cm.node {\n               class_method(m) {\n                   let msc = @cons(scope_method(m.self_id,\n@@ -641,7 +641,7 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n \n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n-    for decl.constraints.each {|c| resolve_constr(e, c, sc, v); }\n+    for decl.constraints.each |c| { resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n       visit::fk_item_fn(_, tps) | visit::fk_method(_, tps, _)\n       | visit::fk_ctor(_, tps, _, _) | visit::fk_dtor(tps, _, _) {\n@@ -658,8 +658,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n fn visit_block_with_scope(b: ast::blk, &&sc: scopes, v: vt<scopes>) {\n     let pos = @mut 0u, loc = @mut 0u;\n     let block_sc = @cons(scope_block(b, pos, loc), sc);\n-    for b.node.view_items.each {|vi| v.visit_view_item(vi, block_sc, v); }\n-    for b.node.stmts.each {|stmt|\n+    for b.node.view_items.each |vi| { v.visit_view_item(vi, block_sc, v); }\n+    for b.node.stmts.each |stmt| {\n         v.visit_stmt(stmt, block_sc, v);;\n         *pos += 1u;;\n         *loc = 0u;\n@@ -674,14 +674,14 @@ fn visit_decl_with_scope(d: @decl, &&sc: scopes, v: vt<scopes>) {\n     };\n     alt d.node {\n       decl_local(locs) {\n-        for locs.each {|loc| v.visit_local(loc, sc, v);; *loc_pos += 1u; }\n+        for locs.each |loc| { v.visit_local(loc, sc, v);; *loc_pos += 1u; }\n       }\n       decl_item(it) { v.visit_item(it, sc, v); }\n     }\n }\n \n fn visit_arm_with_scope(a: ast::arm, &&sc: scopes, v: vt<scopes>) {\n-    for a.pats.each {|p| v.visit_pat(p, sc, v); }\n+    for a.pats.each |p| { v.visit_pat(p, sc, v); }\n     let sc_inner = @cons(scope_arm(a), sc);\n     visit::visit_expr_opt(a.guard, sc_inner, v);\n     v.visit_block(a.body, sc_inner, v);\n@@ -694,7 +694,7 @@ fn visit_local_with_scope(e: @env, loc: @local, &&sc: scopes, v:vt<scopes>) {\n     // scope. We disallow this, in order to make alt patterns consisting of a\n     // single identifier unambiguous (does the pattern \"foo\" refer to enum\n     // foo, or is it binding a new name foo?)\n-    do ast_util::walk_pat(loc.node.pat) { |p|\n+    do ast_util::walk_pat(loc.node.pat) |p| {\n         alt p.node {\n           pat_ident(path, _) {\n             alt lookup_in_scope(*e, sc, loc.span, path_to_ident(path),\n@@ -738,7 +738,7 @@ fn follow_import(e: env, &&sc: scopes, path: ~[ident], sp: span) ->\n        alt dcur {\n           some(ast::def_mod(_)) | some(ast::def_foreign_mod(_)) { ret dcur; }\n           _ {\n-            e.sess.span_err(sp, str::connect(path.map({|x|*x}), \"::\") +\n+            e.sess.span_err(sp, str::connect(path.map(|x|*x), \"::\") +\n                             \" does not name a module.\");\n             ret none;\n           }\n@@ -779,16 +779,16 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     fn find_imports_after(e: env, id: node_id, &&sc: scopes) -> ~[node_id] {\n         fn lst(my_id: node_id, vis: ~[@view_item]) -> ~[node_id] {\n             let mut imports = ~[], found = false;\n-            for vis.each {|vi|\n-                do iter_effective_import_paths(*vi) {|vp|\n+            for vis.each |vi| {\n+                do iter_effective_import_paths(*vi) |vp| {\n                     alt vp.node {\n                       view_path_simple(_, _, id)\n                       | view_path_glob(_, id) {\n                         if id == my_id { found = true; }\n                         if found { vec::push(imports, id); }\n                       }\n                       view_path_list(_, ids, _) {\n-                        for ids.each {|id|\n+                        for ids.each |id| {\n                             if id.node.id == my_id { found = true; }\n                             if found { vec::push(imports, id.node.id); }\n                         }\n@@ -826,7 +826,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     let end_id = ids[n_idents - 1u];\n     if n_idents == 1u {\n         register(e, n_id, in_scope(sc), sp, name,\n-                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns, true) }, ~[]);\n+                 |ns| lookup_in_scope(e, sc, sp, end_id, ns, true), ~[]);\n     } else {\n         alt lookup_in_scope(e, sc, sp, ids[0], ns_module, true) {\n           none {\n@@ -838,7 +838,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n                 if i == n_idents - 1u {\n                     let mut impls = ~[];\n                     find_impls_in_mod(e, dcur, impls, some(end_id));\n-                    register(e, n_id, in_mod(dcur), sp, name, {|ns|\n+                    register(e, n_id, in_mod(dcur), sp, name, |ns| {\n                         lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n                     }, impls);\n                     break;\n@@ -884,7 +884,7 @@ enum ctxt { in_mod(def), in_scope(scopes), }\n \n fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option<scope> {\n-        for list::each(sc) {|cur|\n+        for list::each(sc) |cur| {\n             alt cur {\n               scope_crate | scope_bare_fn(_, _, _) | scope_fn_expr(_, _, _) |\n               scope_item(@{node: ast::item_mod(_), _}) {\n@@ -900,7 +900,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n       in_scope(sc) {\n         alt find_fn_or_mod_scope(sc) {\n           some(err_scope) {\n-            for e.reported.each {|rs|\n+            for e.reported.each |rs| {\n                 if str::eq(*rs.ident, *name) && err_scope == rs.sc { ret; }\n             }\n             e.reported.push({ident: name, sc: err_scope});\n@@ -914,7 +914,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n             path = @(e.mod_map.get(did.node).path + *path);\n         } else if did.node != ast::crate_node_id {\n             let paths = e.ext_map.get(did);\n-            path = @str::connect(vec::append_one(paths, path).map({|x|*x}),\n+            path = @str::connect(vec::append_one(paths, path).map(|x|*x),\n                                  \"::\");\n         }\n       }\n@@ -1168,7 +1168,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n fn lookup_in_ty_params(e: env, name: ident, ty_params: ~[ast::ty_param])\n     -> option<def> {\n     let mut n = 0u;\n-    for ty_params.each {|tp|\n+    for ty_params.each |tp| {\n         if str::eq(*tp.ident, *name) && alt e.current_tp {\n             some(cur) { n < cur } none { true }\n         } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n@@ -1180,7 +1180,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: ~[ast::ty_param])\n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<node_id> {\n     let mut found = none;\n \n-    do pat_util::pat_bindings(e.def_map, pat) {|p_id, _sp, n|\n+    do pat_util::pat_bindings(e.def_map, pat) |p_id, _sp, n| {\n         if str::eq(*path_to_ident(n), *name)\n                     { found = some(p_id); }\n     };\n@@ -1192,7 +1192,7 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ns: namespace) -> option<def> {\n     alt ns {\n       ns_val {\n-        for decl.inputs.each {|a|\n+        for decl.inputs.each |a| {\n             if str::eq(*a.ident, *name) {\n                 ret some(ast::def_arg(a.id, a.mode));\n             }\n@@ -1242,7 +1242,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                     } else {\n                         alt ns {\n                            ns_val {\n-                               for variants.each {|v|\n+                             for variants.each |v| {\n                                   if str::eq(*v.node.name, *name) {\n                                      let i = v.node.id;\n                                      ret some(ast::def_variant\n@@ -1269,7 +1269,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n           _ { }\n         }\n     }\n-    for b.view_items.each {|vi|\n+    for b.view_items.each |vi| {\n         let mut is_import = false;\n         alt vi.node {\n           ast::view_item_import(_) { is_import = true; }\n@@ -1279,7 +1279,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n         alt vi.node {\n \n           ast::view_item_import(vps) | ast::view_item_export(vps) {\n-            for vps.each {|vp|\n+            for vps.each |vp| {\n                 alt vp.node {\n                   ast::view_path_simple(ident, _, id) {\n                     if is_import && name == ident {\n@@ -1288,7 +1288,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                   }\n \n                   ast::view_path_list(path, idents, _) {\n-                    for idents.each {|ident|\n+                    for idents.each |ident| {\n                         if name == ident.node.name {\n                             ret lookup_import(e, ident.node.id, ns);\n                         }\n@@ -1487,7 +1487,7 @@ fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n     alt inf.index.find(id) {\n       none { }\n       some(lst) {\n-        let found = list_search(lst, {|x| lookup_in_mie(e, x, ns)});\n+        let found = list_search(lst, |x| lookup_in_mie(e, x, ns));\n         if !is_none(found) {\n             ret found;\n         }\n@@ -1518,14 +1518,14 @@ fn lookup_in_globs(e: env, globs: ~[glob_imp_def], sp: span, id: ident,\n     }\n     let g = copy globs; // FIXME #2405\n     let matches = vec::filter_map(g,\n-                                  {|x| lookup_in_mod_(e, x, sp, id, ns, dr)});\n+                                  |x| lookup_in_mod_(e, x, sp, id, ns, dr));\n     if vec::len(matches) == 0u {\n         ret none;\n         }\n     else if vec::len(matches) == 1u {\n         ret some(matches[0].def);\n     } else {\n-        for matches.each {|match|\n+        for matches.each |match| {\n             let sp = match.path.span;\n             e.sess.span_note(sp, #fmt[\"'%s' is imported here\", *id]);\n         }\n@@ -1604,21 +1604,21 @@ fn add_to_index(index: hashmap<ident, @list<mod_index_entry>>, id: ident,\n \n fn index_view_items(view_items: ~[@ast::view_item],\n                     index: hashmap<ident, @list<mod_index_entry>>) {\n-    for view_items.each {|vi|\n+    for view_items.each |vi| {\n         alt vi.node {\n           ast::view_item_use(ident, _, id) {\n            add_to_index(index, ident, mie_view_item(ident, id, vi.span));\n           }\n           _ {}\n         }\n \n-        do iter_effective_import_paths(*vi) {|vp|\n+        do iter_effective_import_paths(*vi) |vp| {\n             alt vp.node {\n               ast::view_path_simple(ident, _, id) {\n                 add_to_index(index, ident, mie_import_ident(id, vp.span));\n               }\n               ast::view_path_list(_, idents, _) {\n-                for idents.each {|ident|\n+                for idents.each |ident| {\n                     add_to_index(index, ident.node.name,\n                                  mie_import_ident(ident.node.id,\n                                                   ident.span));\n@@ -1637,7 +1637,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n \n     index_view_items(md.view_items, index);\n \n-    for md.items.each {|it|\n+    for md.items.each |it| {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_foreign_mod(_) | ast::item_ty(_, _, _) |\n@@ -1647,7 +1647,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n           ast::item_enum(variants, _, _) {\n             add_to_index(index, it.ident, mie_item(it));\n             let mut variant_idx: uint = 0u;\n-            for variants.each {|v|\n+            for variants.each |v| {\n                 add_to_index(index, v.node.name,\n                              mie_enum_variant(variant_idx, variants,\n                                              it.id, it.span));\n@@ -1669,7 +1669,7 @@ fn index_nmod(md: ast::foreign_mod) -> mod_index {\n \n     index_view_items(md.view_items, index);\n \n-    for md.items.each {|it|\n+    for md.items.each |it| {\n         add_to_index(index, it.ident, mie_foreign_item(it));\n     }\n     ret index;\n@@ -1694,7 +1694,7 @@ fn ns_for_def(d: def) -> namespace {\n fn lookup_external(e: env, cnum: int, ids: ~[ident], ns: namespace) ->\n    option<def> {\n     let mut result = none;\n-    for csearch::lookup_defs(e.sess.cstore, cnum, ids).each {|d|\n+    for csearch::lookup_defs(e.sess.cstore, cnum, ids).each |d| {\n         e.ext_map.insert(def_id_of_def(d), ids);\n         if ns == ns_for_def(d) { result = some(d); }\n     }\n@@ -1706,16 +1706,16 @@ fn lookup_external(e: env, cnum: int, ids: ~[ident], ns: namespace) ->\n fn check_for_collisions(e: @env, c: ast::crate) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n-    for e.mod_map.each_value {|val|\n-        for val.index.each {|k, v| check_mod_name(*e, k, v); };\n+    for e.mod_map.each_value |val| {\n+        for val.index.each |k, v| { check_mod_name(*e, k, v); };\n     };\n     // Other scopes have to be checked the hard way.\n     let v =\n-        @{visit_item: {|a,b,c|check_item(e, a, b, c)},\n-          visit_block: {|a,b,c|check_block(e, a, b, c)},\n-          visit_arm: {|a,b,c|check_arm(e, a, b, c)},\n-          visit_expr: {|a,b,c|check_expr(e, a, b, c)},\n-          visit_ty: {|a,b,c|check_ty(e, a, b, c)}\n+        @{visit_item: |a,b,c| check_item(e, a, b, c),\n+          visit_block: |a,b,c| check_block(e, a, b, c),\n+          visit_arm: |a,b,c| check_arm(e, a, b, c),\n+          visit_expr: |a,b,c| check_expr(e, a, b, c),\n+          visit_ty: |a,b,c| check_ty(e, a, b, c)\n           with *visit::default_visitor()};\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n@@ -1766,34 +1766,34 @@ fn mie_span(mie: mod_index_entry) -> span {\n fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n     fn typaram_names(tps: ~[ast::ty_param]) -> ~[ident] {\n         let mut x: ~[ast::ident] = ~[];\n-        for tps.each {|tp| vec::push(x, tp.ident); }\n+        for tps.each |tp| { vec::push(x, tp.ident); }\n         ret x;\n     }\n     visit::visit_item(i, x, v);\n     alt i.node {\n       ast::item_fn(decl, ty_params, _) {\n         check_fn(*e, i.span, decl);\n-        ensure_unique(*e, i.span, ty_params, {|tp| tp.ident},\n+        ensure_unique(*e, i.span, ty_params, |tp| tp.ident,\n                       \"type parameter\");\n       }\n       ast::item_enum(_, ty_params, _) {\n-        ensure_unique(*e, i.span, ty_params, {|tp| tp.ident},\n+        ensure_unique(*e, i.span, ty_params, |tp| tp.ident,\n                       \"type parameter\");\n       }\n       ast::item_iface(_, _, methods) {\n-        ensure_unique(*e, i.span, methods, {|m| m.ident},\n+        ensure_unique(*e, i.span, methods, |m| m.ident,\n                       \"method\");\n       }\n       ast::item_impl(_, _, _, _, methods) {\n-        ensure_unique(*e, i.span, methods, {|m| m.ident},\n+        ensure_unique(*e, i.span, methods, |m| m.ident,\n                       \"method\");\n       }\n       _ { }\n     }\n }\n \n fn check_pat(e: @env, ch: checker, p: @ast::pat) {\n-    do pat_util::pat_bindings(e.def_map, p) {|_i, p_sp, n|\n+    do pat_util::pat_bindings(e.def_map, p) |_i, p_sp, n| {\n        add_name(ch, p_sp, path_to_ident(n));\n     };\n }\n@@ -1815,8 +1815,8 @@ fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n             e.sess.span_err(a.pats[i].span,\n                             \"inconsistent number of bindings\");\n         } else {\n-            for ch.seen.each {|name|\n-                if is_none(vec::find(seen0, {|x|str::eq(*name, *x)})) {\n+            for ch.seen.each |name| {\n+                if is_none(vec::find(seen0, |x| str::eq(*name, *x))) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats[i].span,\n@@ -1833,15 +1833,15 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n     let values = checker(*e, \"value\");\n     let types = checker(*e, \"type\");\n     let mods = checker(*e, \"module\");\n-    for b.node.stmts.each {|st|\n+    for b.node.stmts.each |st| {\n         alt st.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locs) {\n                 let local_values = checker(*e, \"value\");\n-                for locs.each {|loc|\n+                for locs.each |loc| {\n                      do pat_util::pat_bindings(e.def_map, loc.node.pat)\n-                         {|_i, p_sp, n|\n+                         |_i, p_sp, n| {\n                          let ident = path_to_ident(n);\n                          add_name(local_values, p_sp, ident);\n                          check_name(values, p_sp, ident);\n@@ -1852,7 +1852,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                 alt it.node {\n                   ast::item_enum(variants, _, _) {\n                     add_name(types, it.span, it.ident);\n-                    for variants.each {|v|\n+                    for variants.each |v| {\n                         add_name(values, v.span, v.node.name);\n                     }\n                   }\n@@ -1909,7 +1909,7 @@ fn checker(e: env, kind: str) -> checker {\n }\n \n fn check_name(ch: checker, sp: span, name: ident) {\n-    for ch.seen.each {|s|\n+    for ch.seen.each |s| {\n         if str::eq(*s, *name) {\n             ch.sess.span_fatal(\n                 sp, \"duplicate \" + ch.kind + \" name: \" + *name);\n@@ -1924,7 +1924,7 @@ fn add_name(ch: checker, sp: span, name: ident) {\n fn ensure_unique<T>(e: env, sp: span, elts: ~[T], id: fn(T) -> ident,\n                     kind: str) {\n     let ch = checker(e, kind);\n-    for elts.each {|elt| add_name(ch, sp, id(elt)); }\n+    for elts.each |elt| { add_name(ch, sp, id(elt)); }\n }\n \n fn check_exports(e: @env) {\n@@ -1942,15 +1942,15 @@ fn check_exports(e: @env) {\n             assert mid.crate == ast::local_crate;\n             let ixm = e.mod_map.get(mid.node);\n \n-            for ixm.index.each {|ident, mies|\n-                do list::iter(mies) {|mie|\n+            for ixm.index.each |ident, mies| {\n+                do list::iter(mies) |mie| {\n                     alt mie {\n                       mie_item(item) {\n                         let defs =\n                             ~[ found_def_item(item, ns_val),\n                              found_def_item(item, ns_type),\n                              found_def_item(item, ns_module) ];\n-                        for defs.each {|d|\n+                        for defs.each |d| {\n                             alt d {\n                               some(def) {\n                                 f(ident, def);\n@@ -1984,7 +1984,7 @@ fn check_exports(e: @env) {\n \n \n     fn maybe_add_reexport(e: @env, export_id: node_id, def: option<def>) {\n-        do option::iter(def) {|def|\n+        do option::iter(def) |def| {\n             add_export(e, export_id, def_id_of_def(def), true);\n         }\n     }\n@@ -2004,7 +2004,7 @@ fn check_exports(e: @env) {\n         if _mod.index.contains_key(ident) {\n             found_something = true;\n             let xs = _mod.index.get(ident);\n-            do list::iter(xs) {|x|\n+            do list::iter(xs) |x| {\n                 alt x {\n                   mie_import_ident(id, _) {\n                     alt check e.imports.get(id) {\n@@ -2045,7 +2045,7 @@ fn check_exports(e: @env) {\n             e.sess.span_fatal(sp, #fmt(\"undefined id %s in an export\", *id));\n           }\n           some(ms) {\n-            let maybe_id = do list_search(ms) {|m|\n+            let maybe_id = do list_search(ms) |m| {\n                 alt m {\n                   mie_item(@{node: item_enum(_, _, _), id, _}) { some(id) }\n                   _ { none }\n@@ -2065,11 +2065,11 @@ fn check_exports(e: @env) {\n                               ids: ~[ast::path_list_ident]) {\n         let parent_id = check_enum_ok(e, span, id, _mod);\n         add_export(e, export_id, local_def(parent_id), false);\n-        for ids.each {|variant_id|\n+        for ids.each |variant_id| {\n             let mut found = false;\n             alt _mod.index.find(variant_id.node.name) {\n               some(ms) {\n-                do list::iter(ms) {|m|\n+                do list::iter(ms) |m| {\n                     alt m {\n                       mie_enum_variant(_, _, actual_parent_id, _) {\n                         found = true;\n@@ -2093,13 +2093,13 @@ fn check_exports(e: @env) {\n         }\n     }\n \n-    for e.mod_map.each_value {|_mod|\n+    for e.mod_map.each_value |_mod| {\n         alt _mod.m {\n           some(m) {\n             let glob_is_re_exported = int_hash();\n \n-            for m.view_items.each {|vi|\n-                do iter_export_paths(*vi) { |vp|\n+            for m.view_items.each |vi| {\n+                do iter_export_paths(*vi) |vp| {\n                     alt vp.node {\n                       ast::view_path_simple(ident, _, id) {\n                         check_export(e, ident, _mod, id, vi);\n@@ -2121,13 +2121,13 @@ fn check_exports(e: @env) {\n             }\n             // Now follow the export-glob links and fill in the\n             // globbed_exports and exp_map lists.\n-            for _mod.glob_imports.each {|glob|\n+            for _mod.glob_imports.each |glob| {\n                 let id = alt check glob.path.node {\n                   ast::view_path_glob(_, node_id) { node_id }\n                 };\n                 if ! glob_is_re_exported.contains_key(id) { cont; }\n                 do iter_mod(*e, glob.def,\n-                         glob.path.span, outside) {|ident, def|\n+                            glob.path.span, outside) |ident, def| {\n                     vec::push(_mod.globbed_exports, ident);\n                     maybe_add_reexport(e, id, some(def));\n                 }\n@@ -2154,9 +2154,9 @@ type iscopes = @list<@~[@_impl]>;\n \n fn resolve_impls(e: @env, c: @ast::crate) {\n     visit::visit_crate(*c, @nil, visit::mk_vt(@{\n-        visit_block: {|a,b,c|visit_block_with_impl_scope(e, a, b, c)},\n-        visit_mod: {|a,b,c,d,f|visit_mod_with_impl_scope(e, a, b, c, d, f)},\n-        visit_expr: {|a,b,c|resolve_impl_in_expr(e, a, b, c)}\n+        visit_block: |a,b,c| visit_block_with_impl_scope(e, a, b, c),\n+        visit_mod: |a,b,c,d,f| visit_mod_with_impl_scope(e, a, b, c, d, f),\n+        visit_expr: |a,b,c| resolve_impl_in_expr(e, a, b, c)\n         with *visit::default_visitor()\n     }));\n }\n@@ -2177,15 +2177,15 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n         }\n     }\n \n-    do iter_effective_import_paths(*vi) { |vp|\n+    do iter_effective_import_paths(*vi) |vp| {\n         alt vp.node {\n           ast::view_path_simple(name, pt, id) {\n             let mut found = ~[];\n             if vec::len(pt.idents) == 1u {\n-                do option::iter(sc) {|sc|\n-                    do list::iter(sc) {|level|\n+                do option::iter(sc) |sc| {\n+                    do list::iter(sc) |level| {\n                         if vec::len(found) == 0u {\n-                            for vec::each(*level) {|imp|\n+                            for vec::each(*level) |imp| {\n                                 if imp.ident == pt.idents[0] {\n                                     vec::push(found,\n                                               @{ident: name with *imp});\n@@ -2198,17 +2198,17 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                     }\n                 }\n             } else {\n-                do lookup_imported_impls(e, id) {|is|\n-                    for vec::each(*is) {|i|\n+                do lookup_imported_impls(e, id) |is| {\n+                    for vec::each(*is) |i| {\n                         vec::push(impls, @{ident: name with *i});\n                     }\n                 }\n             }\n           }\n \n           ast::view_path_list(base, names, _) {\n-            for names.each {|nm|\n-                lookup_imported_impls(e, nm.node.id, {|is|\n+            for names.each |nm| {\n+                lookup_imported_impls(e, nm.node.id, |is| {\n                     vec::push_all(impls, *is);\n                 })\n             }\n@@ -2246,7 +2246,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: ~[@_impl],\n            } {\n             vec::push(impls, @{did: local_def(i.id),\n                         ident: i.ident,\n-                        methods: vec::map(mthds, {|m|\n+                               methods: vec::map(mthds, |m| {\n                             @{did: local_def(m.id),\n                               n_tps: vec::len(m.tps),\n                               ident: m.ident}\n@@ -2256,15 +2256,15 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: ~[@_impl],\n       ast::item_class(tps, ifces, items, _, _, _) {\n           let (_, mthds) = ast_util::split_class_items(items);\n           let n_tps = tps.len();\n-          do vec::iter(ifces) {|p|\n-              // The def_id, in this case, identifies the combination of\n-              // class and iface\n-              vec::push(impls, @{did: local_def(p.id),\n-                         ident: i.ident,\n-                         methods: vec::map(mthds, {|m|\n-                                      @{did: local_def(m.id),\n-                                          n_tps: n_tps + m.tps.len(),\n-                                          ident: m.ident}})});\n+        do vec::iter(ifces) |p| {\n+            // The def_id, in this case, identifies the combination of\n+            // class and iface\n+            vec::push(impls, @{did: local_def(p.id),\n+                               ident: i.ident,\n+                               methods: vec::map(mthds, |m| {\n+                                   @{did: local_def(m.id),\n+                                     n_tps: n_tps + m.tps.len(),\n+                                     ident: m.ident}})});\n           }\n       }\n       _ {}\n@@ -2283,13 +2283,13 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: ~[@_impl],\n             let mut tmp = ~[];\n             let mi = e.mod_map.get(defid.node);\n             let md = option::get(mi.m);\n-            for md.view_items.each {|vi|\n+            for md.view_items.each |vi| {\n                 find_impls_in_view_item(e, vi, tmp, none);\n             }\n-            for md.items.each {|i|\n+            for md.items.each |i| {\n                 find_impls_in_item(e, i, tmp, none, none);\n             }\n-            @vec::filter(tmp, {|i| is_exported(e, i.ident, mi)})\n+            @vec::filter(tmp, |i| is_exported(e, i.ident, mi))\n         } else {\n             csearch::get_impls_for_mod(e.sess.cstore, defid, none)\n         };\n@@ -2298,7 +2298,7 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: ~[@_impl],\n     }\n     alt name {\n       some(n) {\n-        for vec::each(*cached) {|im|\n+        for vec::each(*cached) |im| {\n             if n == im.ident { vec::push(impls, im); }\n         }\n       }\n@@ -2319,10 +2319,10 @@ fn find_impls_in_mod(e: env, m: def, &impls: ~[@_impl],\n fn visit_block_with_impl_scope(e: @env, b: ast::blk, &&sc: iscopes,\n                                v: vt<iscopes>) {\n     let mut impls = ~[];\n-    for b.node.view_items.each {|vi|\n+    for b.node.view_items.each |vi| {\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n-    for b.node.stmts.each {|st|\n+    for b.node.stmts.each |st| {\n         alt st.node {\n           ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n             find_impls_in_item(*e, i, impls, none, none);\n@@ -2337,10 +2337,10 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, &&sc: iscopes,\n fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n                              &&sc: iscopes, v: vt<iscopes>) {\n     let mut impls = ~[];\n-    for m.view_items.each {|vi|\n+    for m.view_items.each |vi| {\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n-    for m.items.each {|i| find_impls_in_item(*e, i, impls, none, none); }\n+    for m.items.each |i| { find_impls_in_item(*e, i, impls, none, none); }\n     let impls = @impls;\n     visit::visit_mod(m, s, id, if vec::len(*impls) > 0u {\n                                    @cons(impls, sc)"}, {"sha": "f40a94e113b51af411733ec7925e85bd4e1810b3", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -71,15 +71,15 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(tcx.def_map.get(pat_id));\n     let variants = ty::enum_variants(tcx, vdef.enm);\n-    for vec::each(*variants) {|v|\n+    for vec::each(*variants) |v| {\n         if vdef.var == v.id { ret var(v.disr_val, vdef); }\n     }\n     core::unreachable();\n }\n \n type bind_map = ~[{ident: ast::ident, val: ValueRef}];\n fn assoc(key: ast::ident, list: bind_map) -> option<ValueRef> {\n-    for vec::each(list) {|elt|\n+    for vec::each(list) |elt| {\n         if str::eq(*elt.ident, *key) { ret some(elt.val); }\n     }\n     ret none;\n@@ -94,7 +94,7 @@ type match_branch =\n type match = ~[match_branch];\n \n fn has_nested_bindings(m: match, col: uint) -> bool {\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         alt br.pats[col].node {\n           ast::pat_ident(_, some(_)) { ret true; }\n           _ {}\n@@ -105,7 +105,7 @@ fn has_nested_bindings(m: match, col: uint) -> bool {\n \n fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n     let mut result = ~[];\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n       alt br.pats[col].node {\n           ast::pat_ident(name, some(inner)) {\n             let pats = vec::append(\n@@ -130,7 +130,7 @@ type enter_pat = fn(@ast::pat) -> option<~[@ast::pat]>;\n fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n                e: enter_pat) -> match {\n     let mut result = ~[];\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         alt e(br.pats[col]) {\n           some(sub) {\n             let pats = vec::append(\n@@ -153,7 +153,7 @@ fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n }\n \n fn enter_default(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n-    do enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some(~[]) }\n           ast::pat_ident(_, none) if !pat_is_variant(dm, p) {\n@@ -167,7 +167,7 @@ fn enter_default(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n              variant_size: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(tcx.def_map, m, col, val) {|p|\n+    do enter_match(tcx.def_map, m, col, val) |p| {\n         alt p.node {\n           ast::pat_enum(_, subpats) {\n             if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n@@ -193,13 +193,13 @@ fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n fn enter_rec(dm: def_map, m: match, col: uint, fields: ~[ast::ident],\n              val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let mut pats = ~[];\n-            for vec::each(fields) {|fname|\n+            for vec::each(fields) |fname| {\n                 let mut pat = dummy;\n-                for vec::each(fpats) {|fpat|\n+                for vec::each(fpats) |fpat| {\n                     if str::eq(*fpat.ident, *fname) { pat = fpat.pat; break; }\n                 }\n                 vec::push(pats, pat);\n@@ -214,7 +214,7 @@ fn enter_rec(dm: def_map, m: match, col: uint, fields: ~[ast::ident],\n fn enter_tup(dm: def_map, m: match, col: uint, val: ValueRef,\n              n_elts: uint) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_tup(elts) { some(elts) }\n           _ { some(vec::from_elem(n_elts, dummy)) }\n@@ -224,7 +224,7 @@ fn enter_tup(dm: def_map, m: match, col: uint, val: ValueRef,\n \n fn enter_box(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_box(sub) { some(~[sub]) }\n           _ { some(~[dummy]) }\n@@ -234,7 +234,7 @@ fn enter_box(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n \n fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_uniq(sub) { some(~[sub]) }\n           _ { some(~[dummy]) }\n@@ -244,12 +244,12 @@ fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n \n fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> ~[opt] {\n     fn add_to_set(tcx: ty::ctxt, &&set: dvec<opt>, val: opt) {\n-        if set.any({|l| opt_eq(tcx, l, val)}) {ret;}\n+        if set.any(|l| opt_eq(tcx, l, val)) {ret;}\n         set.push(val);\n     }\n \n     let found = dvec();\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         let cur = br.pats[col];\n         if pat_is_variant(ccx.tcx.def_map, cur) {\n             add_to_set(ccx.tcx, found, variant_opt(ccx.tcx, br.pats[col].id));\n@@ -285,7 +285,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     }\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n-    let args = do vec::from_fn(size) { |i|\n+    let args = do vec::from_fn(size) |i| {\n         GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n                  enum_ty_substs, i)\n     };\n@@ -294,11 +294,11 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n \n fn collect_record_fields(m: match, col: uint) -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n-            for vec::each(fs) {|f|\n-                if !vec::any(fields, {|x| str::eq(*f.ident, *x)}) {\n+            for vec::each(fs) |f| {\n+                if !vec::any(fields, |x| str::eq(*f.ident, *x)) {\n                     vec::push(fields, f.ident);\n                 }\n             }\n@@ -310,7 +310,7 @@ fn collect_record_fields(m: match, col: uint) -> ~[ast::ident] {\n }\n \n fn root_pats_as_necessary(bcx: block, m: match, col: uint, val: ValueRef) {\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n \n         alt bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n@@ -330,21 +330,21 @@ fn root_pats_as_necessary(bcx: block, m: match, col: uint, val: ValueRef) {\n }\n \n fn any_box_pat(m: match, col: uint) -> bool {\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         alt br.pats[col].node { ast::pat_box(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n fn any_uniq_pat(m: match, col: uint) -> bool {\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         alt br.pats[col].node { ast::pat_uniq(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n fn any_tup_pat(m: match, col: uint) -> bool {\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         alt br.pats[col].node { ast::pat_tup(_) { ret true; } _ { } }\n     }\n     ret false;\n@@ -362,14 +362,14 @@ fn pick_col(m: match) -> uint {\n         }\n     }\n     let scores = vec::to_mut(vec::from_elem(m[0].pats.len(), 0u));\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         let mut i = 0u;\n-        for vec::each(br.pats) {|p| scores[i] += score(p); i += 1u; }\n+        for vec::each(br.pats) |p| { scores[i] += score(p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n-    for vec::each(scores) {|score|\n+    for vec::each(scores) |score| {\n         // Irrefutable columns always go first, they'd only be duplicated in\n         // the branches.\n         if score == 0u { ret i; }\n@@ -393,16 +393,16 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n           some(e) {\n             // Temporarily set bindings. They'll be rewritten to PHI nodes\n             // for the actual arm block.\n-            for data.id_map.each {|key, val|\n+            for data.id_map.each |key, val| {\n                 let loc = local_mem(option::get(assoc(key, m[0].bound)));\n                 bcx.fcx.lllocals.insert(val, loc);\n             };\n             let {bcx: guard_cx, val} = {\n-                do with_scope_result(bcx, e.info(), \"guard\") {|bcx|\n+                do with_scope_result(bcx, e.info(), \"guard\") |bcx| {\n                     trans_temp_expr(bcx, e)\n                 }\n             };\n-            bcx = do with_cond(guard_cx, Not(guard_cx, val)) {|bcx|\n+            bcx = do with_cond(guard_cx, Not(guard_cx, val)) |bcx| {\n                 compile_submatch(bcx, vec::tail(m), vals, chk, exits);\n                 bcx\n             };\n@@ -427,7 +427,7 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n                                 vec::view(vals, col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n-    for vec::each(m) {|br|\n+    for vec::each(m) |br| {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 { pat_id = br.pats[col].id; }\n@@ -440,7 +440,7 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n     if rec_fields.len() > 0u {\n         let fields = ty::get_fields(node_id_type(bcx, pat_id));\n         let mut rec_vals = ~[];\n-        for vec::each(rec_fields) {|field_name|\n+        for vec::each(rec_fields) |field_name| {\n             let ix = option::get(ty::field_idx(field_name, fields));\n             vec::push(rec_vals, GEPi(bcx, val, ~[0u, ix]));\n         }\n@@ -516,7 +516,7 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n           }\n         }\n     }\n-    for vec::each(opts) {|o|\n+    for vec::each(opts) |o| {\n         alt o {\n           range(_, _) { kind = compare; break; }\n           _ { }\n@@ -535,7 +535,7 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n     let len = opts.len();\n     let mut i = 0u;\n     // Compile subtrees for each option\n-    for vec::each(opts) {|opt|\n+    for vec::each(opts) |opt| {\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n@@ -553,7 +553,7 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n               compare {\n                 let t = node_id_type(bcx, pat_id);\n                 let {bcx: after_cx, val: matches} = {\n-                    do with_scope_result(bcx, none, \"compare_scope\") {|bcx|\n+                    do with_scope_result(bcx, none, \"compare_scope\") |bcx| {\n                         alt trans_opt(bcx, opt) {\n                           single_result({bcx, val}) {\n                             trans_compare(bcx, ast::eq, test_val, t, val, t)\n@@ -604,10 +604,10 @@ fn make_phi_bindings(bcx: block, map: ~[exit_node],\n     let _icx = bcx.insn_ctxt(\"alt::make_phi_bindings\");\n     let our_block = bcx.llbb as uint;\n     let mut success = true, bcx = bcx;\n-    for ids.each {|name, node_id|\n+    for ids.each |name, node_id| {\n         let mut llbbs = ~[];\n         let mut vals = ~[];\n-        for vec::each(map) {|ex|\n+        for vec::each(map) |ex| {\n             if ex.to as uint == our_block {\n                 alt assoc(name, ex.bound) {\n                   some(val) {\n@@ -636,7 +636,7 @@ fn trans_alt(bcx: block,\n              mode: ast::alt_mode,\n              dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n-    do with_scope(bcx, alt_expr.info(), \"alt\") {|bcx|\n+    do with_scope(bcx, alt_expr.info(), \"alt\") |bcx| {\n         trans_alt_inner(bcx, expr, arms, mode, dest)\n     }\n }\n@@ -650,11 +650,11 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n     if bcx.unreachable { ret bcx; }\n \n-    for vec::each(arms) {|a|\n+    for vec::each(arms) |a| {\n         let body = scope_block(bcx, a.body.info(), \"case_body\");\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         vec::push(bodies, body);\n-        for vec::each(a.pats) {|p|\n+        for vec::each(a.pats) |p| {\n             vec::push(match, @{pats: ~[p],\n                         bound: ~[],\n                         data: @{bodycx: body, guard: a.guard,\n@@ -674,7 +674,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n             *done = some(fail_cx.llbb);\n             ret fail_cx.llbb;\n         }\n-        some({||mk_fail(scope_cx, expr.span, fail_cx)})\n+        some(|| mk_fail(scope_cx, expr.span, fail_cx))\n       }\n       ast::alt_exhaustive { none }\n     };\n@@ -684,7 +684,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n     compile_submatch(bcx, match, ~[spilled], mk_fail, exit_map);\n \n     let mut arm_cxs = ~[], arm_dests = ~[], i = 0u;\n-    for vec::each(arms) {|a|\n+    for vec::each(arms) |a| {\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         if make_phi_bindings(body_cx, exit_map, id_map) {\n@@ -728,22 +728,22 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let mut i = 0;\n-        do option::iter(sub) {|sub| for vec::each(args.vals) {|argval|\n+        do option::iter(sub) |sub| { for vec::each(args.vals) |argval| {\n             bcx = bind_irrefutable_pat(bcx, sub[i], argval, make_copy);\n             i += 1;\n         }}\n       }\n       ast::pat_rec(fields, _) {\n         let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n-        for vec::each(fields) {|f|\n+        for vec::each(fields) |f| {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             let fldptr = GEPi(bcx, val, ~[0u, ix]);\n             bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n         }\n       }\n       ast::pat_tup(elems) {\n         let mut i = 0u;\n-        for vec::each(elems) {|elem|\n+        for vec::each(elems) |elem| {\n             let fldptr = GEPi(bcx, val, ~[0u, i]);\n             bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n             i += 1u;"}, {"sha": "8cef9f12f6697796a55d6f360ba0bddaa1873396", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 143, "deletions": 145, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -118,7 +118,7 @@ fn join_returns(parent_cx: block, in_cxs: ~[block],\n                 in_ds: ~[dest], out_dest: dest) -> block {\n     let out = sub_block(parent_cx, \"join\");\n     let mut reachable = false, i = 0u, phi = none;\n-    for vec::each(in_cxs) {|cx|\n+    for vec::each(in_cxs) |cx| {\n         if !cx.unreachable {\n             Br(cx, out.llbb);\n             reachable = true;\n@@ -172,7 +172,7 @@ fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timespec,\n \n fn decl_fn(llmod: ModuleRef, name: str, cc: lib::llvm::CallConv,\n            llty: TypeRef) -> ValueRef {\n-    let llfn: ValueRef = str::as_c_str(name, {|buf|\n+    let llfn: ValueRef = str::as_c_str(name, |buf| {\n         llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n     });\n     lib::llvm::SetFunctionCallConv(llfn, cc);\n@@ -204,7 +204,7 @@ fn get_extern_fn(externs: hashmap<str, ValueRef>, llmod: ModuleRef, name: str,\n fn get_extern_const(externs: hashmap<str, ValueRef>, llmod: ModuleRef,\n                     name: str, ty: TypeRef) -> ValueRef {\n     if externs.contains_key(name) { ret externs.get(name); }\n-    let c = str::as_c_str(name, {|buf| llvm::LLVMAddGlobal(llmod, ty, buf) });\n+    let c = str::as_c_str(name, |buf| llvm::LLVMAddGlobal(llmod, ty, buf));\n     externs.insert(name, c);\n     ret c;\n }\n@@ -229,7 +229,7 @@ fn trans_foreign_call(cx: block, externs: hashmap<str, ValueRef>,\n     let llforeign: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n     let mut call_args: ~[ValueRef] = ~[];\n-    for vec::each(args) {|a|\n+    for vec::each(args) |a| {\n         vec::push(call_args, a);\n     }\n     ret Call(cx, llforeign, call_args);\n@@ -323,7 +323,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n     assert ix < variant.args.len();\n \n-    let arg_lltys = vec::map(variant.args, {|aty|\n+    let arg_lltys = vec::map(variant.args, |aty| {\n         type_of(ccx, ty::subst_tps(ccx.tcx, ty_substs, aty))\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n@@ -499,7 +499,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     } else { mangle_internal_name_by_seq(ccx, @\"tydesc\") };\n     note_unique_llvm_symbol(ccx, name);\n     log(debug, #fmt(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n-    let gvar = str::as_c_str(name, {|buf|\n+    let gvar = str::as_c_str(name, |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n     });\n     let inf =\n@@ -574,7 +574,7 @@ fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n \n fn emit_tydescs(ccx: @crate_ctxt) {\n     let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n-    for ccx.tydescs.each {|key, val|\n+    for ccx.tydescs.each |key, val| {\n         let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n         let ti = val;\n         let take_glue =\n@@ -733,7 +733,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       }\n       ty::ty_class(did,substs) {\n         // Call the dtor if there is one\n-        do option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) {|dt_id|\n+        do option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) |dt_id| {\n           trans_class_drop(bcx, v, dt_id, did, substs)\n         }\n       }\n@@ -746,7 +746,7 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n                     class_did: ast::def_id,\n                     substs: ty::substs) -> block {\n   let drop_flag = GEPi(bcx, v0, ~[0u, 0u]);\n-  do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|cx|\n+    do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n     let mut bcx = cx;\n       // We have to cast v0\n      let classptr = GEPi(bcx, v0, ~[0u, 1u]);\n@@ -765,7 +765,7 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n      // Drop the fields\n      for vec::eachi(ty::class_items_as_mutable_fields(bcx.tcx(), class_did,\n                                                       substs))\n-     {|i, fld|\n+         |i, fld| {\n         let llfld_a = GEPi(bcx, classptr, ~[0u, i]);\n         bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n      }\n@@ -864,19 +864,19 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n \n     let llbox_ty = T_opaque_box_ptr(ccx);\n     let box_ptr = PointerCast(bcx, box_ptr, llbox_ty);\n-    do with_cond(bcx, IsNotNull(bcx, box_ptr)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, box_ptr)) |bcx| {\n         let rc_ptr = GEPi(bcx, box_ptr, ~[0u, abi::box_field_refcnt]);\n         let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n         Store(bcx, rc, rc_ptr);\n         let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n-        with_cond(bcx, zero_test, {|bcx| free_ty(bcx, box_ptr, t)})\n+        with_cond(bcx, zero_test, |bcx| free_ty(bcx, box_ptr, t))\n     }\n }\n \n // Structural comparison: a rather involved form of glue.\n fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n     if cx.sess.opts.save_temps {\n-        let _: () = str::as_c_str(s, {|buf| llvm::LLVMSetValueName(v, buf) });\n+        let _: () = str::as_c_str(s, |buf| llvm::LLVMSetValueName(v, buf));\n     }\n }\n \n@@ -887,7 +887,7 @@ enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n                         t: ty::t, op: ast::binop) -> result {\n-    let f = {|a|compare_scalar_values(cx, lhs, rhs, a, op)};\n+    let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n     alt ty::get(t).struct {\n       ty::ty_nil { ret rslt(cx, f(nil_type)); }\n@@ -998,7 +998,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           ty::ty_fn({inputs: args, _}) {\n             let mut j = 0u;\n             let v_id = variant.id;\n-            for vec::each(args) {|a|\n+            for vec::each(args) |a| {\n                 let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n                 let ty_subst = ty::subst_tps(ccx.tcx, tps, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n@@ -1016,7 +1016,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     let mut cx = cx;\n     alt ty::get(t).struct {\n       ty::ty_rec(fields) {\n-        for vec::eachi(fields) {|i, fld|\n+        for vec::eachi(fields) |i, fld| {\n             let llfld_a = GEPi(cx, av, ~[0u, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n         }\n@@ -1027,7 +1027,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         cx = tvec::iter_vec_raw(cx, base, t, len, f);\n       }\n       ty::ty_tup(args) {\n-        for vec::eachi(args) {|i, arg|\n+        for vec::eachi(args) |i, arg| {\n             let llfld_a = GEPi(cx, av, ~[0u, i]);\n             cx = f(cx, llfld_a, arg);\n         }\n@@ -1056,7 +1056,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         Unreachable(unr_cx);\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n         let next_cx = sub_block(cx, \"enum-iter-next\");\n-        for vec::each(*variants) {|variant|\n+        for vec::each(*variants) |variant| {\n             let variant_cx =\n                 sub_block(cx,\n                                    \"enum-iter-variant-\" +\n@@ -1077,7 +1077,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           else { av };\n         for vec::eachi(ty::class_items_as_mutable_fields(cx.tcx(), did,\n                                                          substs))\n-           {|i, fld|\n+            |i, fld| {\n                let llfld_a = GEPi(cx, classptr, ~[0u, i]);\n                cx = f(cx, llfld_a, fld.mt.ty);\n            }\n@@ -1354,7 +1354,7 @@ fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n         let dstcmp = load_if_immediate(cx, dst, t);\n         let cast = PointerCast(cx, dstcmp, val_ty(src));\n         // Self-copy check\n-        do with_cond(cx, ICmp(cx, lib::llvm::IntNE, cast, src)) {|bcx|\n+        do with_cond(cx, ICmp(cx, lib::llvm::IntNE, cast, src)) |bcx| {\n             copy_val_no_check(bcx, action, dst, src, t)\n         }\n     } else {\n@@ -1505,7 +1505,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n         ret trans_call_inner(\n             bcx, un_expr.info(), fty,\n             expr_ty(bcx, un_expr),\n-            {|bcx| impl::trans_method_callee(bcx, callee_id, e, mentry) },\n+            |bcx| impl::trans_method_callee(bcx, callee_id, e, mentry),\n             arg_exprs(~[]), dest);\n       }\n       _ {}\n@@ -1581,8 +1581,8 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n                        lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n-                   {|a,b|Trunc(cx, a, b)},\n-                   {|a,b|ZExt(cx, a, b)})\n+                   |a,b| Trunc(cx, a, b),\n+                   |a,b| ZExt(cx, a, b))\n }\n \n fn cast_shift_const_rhs(op: ast::binop,\n@@ -1637,7 +1637,7 @@ fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n                           ty_to_str(cx.ccx().tcx, rhs_t));\n       }\n     };\n-    do with_cond(cx, is_zero) {|bcx|\n+    do with_cond(cx, is_zero) |bcx| {\n         trans_fail(bcx, some(span), text)\n     }\n }\n@@ -1742,7 +1742,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n         let bcx = trans_call_inner(\n             bcx, ex.info(), fty,\n             expr_ty(bcx, ex),\n-            {|bcx|\n+            |bcx| {\n                 // FIXME (#2528): provide the already-computed address, not\n                 // the expr.\n                 impl::trans_method_callee(bcx, callee_id, dst, origin)\n@@ -1870,7 +1870,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let {bcx: past_lhs, val: lhs} = {\n-        do with_scope_result(bcx, a.info(), \"lhs\") { |bcx|\n+        do with_scope_result(bcx, a.info(), \"lhs\") |bcx| {\n             trans_temp_expr(bcx, a)\n         }\n     };\n@@ -1882,7 +1882,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n       lazy_or { CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb); }\n     }\n     let {bcx: past_rhs, val: rhs} = {\n-        do with_scope_result(before_rhs, b.info(), \"rhs\") { |bcx|\n+        do with_scope_result(before_rhs, b.info(), \"rhs\") |bcx| {\n             trans_temp_expr(bcx, b)\n         }\n     };\n@@ -1905,7 +1905,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n         ret trans_call_inner(\n             bcx, ex.info(), fty,\n             expr_ty(bcx, ex),\n-            {|bcx|\n+            |bcx| {\n                 impl::trans_method_callee(bcx, callee_id, lhs, origin)\n             },\n             arg_exprs(~[rhs]), dest);\n@@ -2079,9 +2079,9 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n       some(vts) {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n         let mut i = 0u;\n-        vec::map2(*bounds, substs, {|bounds, subst|\n+        vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];\n-            for vec::each(*bounds) {|bound|\n+            for vec::each(*bounds) |bound| {\n                 alt bound {\n                   ty::bound_iface(_) {\n                     vec::push(v, impl::vtable_id(ccx, vts[i]));\n@@ -2094,12 +2094,12 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n         })\n       }\n       none {\n-        vec::map(substs, {|subst| mono_precise(subst, none)})\n+        vec::map(substs, |subst| mono_precise(subst, none))\n       }\n     };\n     let param_ids = alt param_uses {\n       some(uses) {\n-        vec::map2(precise_param_ids, uses, {|id, uses|\n+        vec::map2(precise_param_ids, uses, |id, uses| {\n             alt check id {\n               mono_precise(_, some(_)) { id }\n               mono_precise(subst, none) {\n@@ -2131,28 +2131,28 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     -> {val: ValueRef, must_cast: bool} {\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n-    let substs = vec::map(real_substs, {|t|\n+    let substs = vec::map(real_substs, |t| {\n         alt normalize_for_monomorphization(ccx.tcx, t) {\n           some(t) { must_cast = true; t }\n           none { t }\n         }\n     });\n \n-    for real_substs.each() {|s| assert !ty::type_has_params(s); };\n-    for substs.each() {|s| assert !ty::type_has_params(s); };\n+    for real_substs.each() |s| { assert !ty::type_has_params(s); }\n+    for substs.each() |s| { assert !ty::type_has_params(s); }\n \n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, some(param_uses));\n     if vec::any(hash_id.params,\n-                {|p| alt p { mono_precise(_, _) { false } _ { true } } }) {\n+                |p| alt p { mono_precise(_, _) { false } _ { true } }) {\n         must_cast = true;\n     }\n \n     #debug[\"monomorphic_fn(fn_id=%? (%s), real_substs=%?, substs=%?, \\\n            hash_id = %?\",\n            fn_id, ty::item_path_str(ccx.tcx, fn_id),\n-           real_substs.map({|s| ty_to_str(ccx.tcx, s)}),\n-           substs.map({|s| ty_to_str(ccx.tcx, s)}), hash_id];\n+           real_substs.map(|s| ty_to_str(ccx.tcx, s)),\n+           substs.map(|s| ty_to_str(ccx.tcx, s)), hash_id];\n \n     alt ccx.monomorphized.find(hash_id) {\n       some(val) {\n@@ -2165,9 +2165,9 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     let mut llitem_ty = tpt.ty;\n \n     let map_node = session::expect(ccx.sess, ccx.tcx.items.find(fn_id.node),\n-     {|| #fmt(\"While monomorphizing %?, couldn't find it in the item map \\\n+     || #fmt(\"While monomorphizing %?, couldn't find it in the item map \\\n         (may have attempted to monomorphize an item defined in a different \\\n-        crate?)\", fn_id)});\n+        crate?)\", fn_id));\n     // Get the path so that we can create a symbol\n     let (pt, name, span) = alt map_node {\n       ast_map::node_item(i, pt) { (pt, i.ident, i.span) }\n@@ -2210,7 +2210,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     let pt = vec::append(*pt, ~[path_name(@ccx.names(*name))]);\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n \n-    let mk_lldecl = {||\n+    let mk_lldecl = || {\n         let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n         ccx.monomorphized.insert(hash_id, lldecl);\n         lldecl\n@@ -2235,7 +2235,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n       }\n       ast_map::node_variant(v, enum_item, _) {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n-        let this_tv = option::get(vec::find(*tvs, {|tv|\n+        let this_tv = option::get(vec::find(*tvs, |tv| {\n             tv.id.node == fn_id.node}));\n         let d = mk_lldecl();\n         set_inline_hint(d);\n@@ -2303,7 +2303,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n       none { // Not seen yet\n         alt csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n-            {|a,b,c,d|\n+            |a,b,c,d| {\n                 astencode::decode_inlined_item(a, b, ccx.maps, c, d)\n             }) {\n \n@@ -2331,7 +2331,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n               ast::item_enum(_, _, _) {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n                 let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n-                do vec::iter2(*vs_here, *vs_there) {|here, there|\n+                do vec::iter2(*vs_here, *vs_there) |here, there| {\n                     if there.id == fn_id { my_id = here.id.node; }\n                     ccx.external.insert(there.id, some(here.id.node));\n                 }\n@@ -2370,7 +2370,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"lval_static_fn\");\n-    let vts = option::map(bcx.ccx().maps.vtable_map.find(id), {|vts|\n+    let vts = option::map(bcx.ccx().maps.vtable_map.find(id), |vts| {\n         impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n     });\n     lval_static_fn_inner(bcx, fn_id, id, node_id_type_params(bcx, id), vts)\n@@ -2433,7 +2433,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(ccx.sess.cstore, vid);\n-        let gvar = str::as_c_str(sym, {|buf|\n+        let gvar = str::as_c_str(sym, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n         lib::llvm::SetLinkage(gvar, lib::llvm::ExternalLinkage);\n@@ -2622,7 +2622,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     #debug(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n-    let bcx = do with_cond(bcx, bounds_check) {|bcx|\n+    let bcx = do with_cond(bcx, bounds_check) |bcx| {\n         // fail: bad bounds check.\n         trans_fail(bcx, some(ex.span), \"bounds check\")\n     };\n@@ -3109,7 +3109,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n       arg_exprs(es) {\n         let llarg_tys = type_of_explicit_args(ccx, arg_tys);\n         let last = es.len() - 1u;\n-        do vec::iteri(es) {|i, e|\n+        do vec::iteri(es) |i, e| {\n             let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n                                    e, temp_cleanups, if i == last { ret_flag }\n                                    else { none }, 0u);\n@@ -3125,7 +3125,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n     // now that all arguments have been successfully built, we can revoke any\n     // temporary cleanups, as they are only needed if argument construction\n     // should fail (for example, cleanup of copy mode args).\n-    do vec::iter(temp_cleanups) {|c|\n+    do vec::iter(temp_cleanups) |c| {\n         revoke_clean(bcx, c)\n     }\n \n@@ -3140,14 +3140,14 @@ fn trans_call(in_cx: block, call_ex: @ast::expr, f: @ast::expr,\n     let _icx = in_cx.insn_ctxt(\"trans_call\");\n     trans_call_inner(\n         in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n-        {|cx| trans_callee(cx, f)}, args, dest)\n+        |cx| trans_callee(cx, f), args, dest)\n }\n \n fn body_contains_ret(body: ast::blk) -> bool {\n     let cx = {mut found: false};\n     visit::visit_block(body, cx, visit::mk_vt(@{\n-        visit_item: {|_i, _cx, _v|},\n-        visit_expr: {|e: @ast::expr, cx: {mut found: bool}, v|\n+        visit_item: |_i, _cx, _v| { },\n+        visit_expr: |e: @ast::expr, cx: {mut found: bool}, v| {\n             if !cx.found {\n                 alt e.node {\n                   ast::expr_ret(_) { cx.found = true; }\n@@ -3169,7 +3169,7 @@ fn trans_call_inner(\n     args: call_args,\n     dest: dest) -> block {\n \n-    do with_scope(in_cx, call_info, \"call\") {|cx|\n+    do with_scope(in_cx, call_info, \"call\") |cx| {\n         let ret_in_loop = alt args {\n           arg_exprs(args) { args.len() > 0u && alt vec::last(args).node {\n             ast::expr_loop_body(@{node: ast::expr_fn_block(_, body, _), _}) {\n@@ -3237,8 +3237,8 @@ fn trans_call_inner(\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n-            bcx = do with_cond(bcx, Load(bcx, option::get(ret_flag))) {|bcx|\n-                do option::iter(copy bcx.fcx.loop_ret) {|lret|\n+            bcx = do with_cond(bcx, Load(bcx, option::get(ret_flag))) |bcx| {\n+                do option::iter(copy bcx.fcx.loop_ret) |lret| {\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);\n                 }\n@@ -3276,7 +3276,7 @@ fn need_invoke(bcx: block) -> bool {\n     loop {\n         alt cur.kind {\n           block_scope(inf) {\n-            for vec::each(inf.cleanups) {|cleanup|\n+            for vec::each(inf.cleanups) |cleanup| {\n                 alt cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) {\n                     if cleanup_type == normal_exit_and_unwind {\n@@ -3297,7 +3297,7 @@ fn need_invoke(bcx: block) -> bool {\n \n fn have_cached_lpad(bcx: block) -> bool {\n     let mut res = false;\n-    do in_lpad_scope_cx(bcx) {|inf|\n+    do in_lpad_scope_cx(bcx) |inf| {\n         alt inf.landing_pad {\n           some(_) { res = true; }\n           none { res = false; }\n@@ -3325,7 +3325,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n \n     let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n-    do in_lpad_scope_cx(bcx) {|inf|\n+    do in_lpad_scope_cx(bcx) |inf| {\n         // If there is a valid landing pad still around, use it\n         alt copy inf.landing_pad {\n           some(target) { cached = some(target); }\n@@ -3375,21 +3375,21 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n     let mut bcx = bcx;\n     let addr = alt dest {\n       ignore {\n-        for vec::each(elts) {|ex| bcx = trans_expr(bcx, ex, ignore); }\n+        for vec::each(elts) |ex| { bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n       }\n       save_in(pos) { pos }\n       _ { bcx.tcx().sess.bug(\"trans_tup: weird dest\"); }\n     };\n     let mut temp_cleanups = ~[];\n-    for vec::eachi(elts) {|i, e|\n+    for vec::eachi(elts) |i, e| {\n         let dst = GEPi(bcx, addr, ~[0u, i]);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(bcx, e, dst);\n         add_clean_temp_mem(bcx, dst, e_ty);\n         vec::push(temp_cleanups, dst);\n     }\n-    for vec::each(temp_cleanups) {|cleanup| revoke_clean(bcx, cleanup); }\n+    for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n     ret bcx;\n }\n \n@@ -3401,7 +3401,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     let mut bcx = bcx;\n     let addr = alt check dest {\n       ignore {\n-        for vec::each(fields) {|fld|\n+        for vec::each(fields) |fld| {\n             bcx = trans_expr(bcx, fld.node.expr, ignore);\n         }\n         ret bcx;\n@@ -3412,8 +3412,8 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     let ty_fields = alt check ty::get(t).struct { ty::ty_rec(f) { f } };\n \n     let mut temp_cleanups = ~[];\n-    for fields.each {|fld|\n-        let ix = option::get(vec::position(ty_fields, {|ft|\n+    for fields.each |fld| {\n+        let ix = option::get(vec::position(ty_fields, |ft| {\n             str::eq(*fld.node.ident, *ft.ident)\n         }));\n         let dst = GEPi(bcx, addr, ~[0u, ix]);\n@@ -3426,8 +3426,8 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n         let {bcx: cx, val: base_val} = trans_temp_expr(bcx, bexp);\n         bcx = cx;\n         // Copy over inherited fields\n-        for ty_fields.eachi {|i, tf|\n-            if !vec::any(fields, {|f| str::eq(*f.node.ident, *tf.ident)}) {\n+        for ty_fields.eachi |i, tf| {\n+            if !vec::any(fields, |f| str::eq(*f.node.ident, *tf.ident)) {\n                 let dst = GEPi(bcx, addr, ~[0u, i]);\n                 let base = GEPi(bcx, base_val, ~[0u, i]);\n                 let val = load_if_immediate(bcx, base, tf.mt.ty);\n@@ -3440,7 +3440,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n \n     // Now revoke the cleanups as we pass responsibility for the data\n     // structure on to the caller\n-    for temp_cleanups.each {|cleanup| revoke_clean(bcx, cleanup); }\n+    for temp_cleanups.each |cleanup| { revoke_clean(bcx, cleanup); }\n     ret bcx;\n }\n \n@@ -3585,7 +3585,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             ret alt::trans_alt(bcx, e, expr, arms, mode, dest);\n           }\n           ast::expr_block(blk) {\n-            ret do with_scope(bcx, blk.info(), \"block-expr body\") {|bcx|\n+            ret do with_scope(bcx, blk.info(), \"block-expr body\") |bcx| {\n                 trans_block(bcx, blk, dest)\n             };\n           }\n@@ -3653,9 +3653,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             ret trans_call_inner(\n                 bcx, e.info(), fty,\n                 expr_ty(bcx, e),\n-                { |bcx|\n-                    impl::trans_method_callee(bcx, callee_id, base, origin)\n-                },\n+                |bcx| impl::trans_method_callee(bcx, callee_id, base, origin),\n                 arg_exprs(~[idx]), dest);\n           }\n \n@@ -3697,7 +3695,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             otherwise. */\n             let c = get_extern_const(bcx.ccx().externs, bcx.ccx().llmod,\n                                      \"check_claims\", T_bool());\n-            ret do with_cond(bcx, Load(bcx, c)) {|bcx|\n+            ret do with_cond(bcx, Load(bcx, c)) |bcx| {\n                 trans_check_expr(bcx, e, a, \"Claim\")\n             };\n           }\n@@ -3774,8 +3772,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             let origin = bcx.ccx().maps.method_map.get(alloc_id);\n             let bcx = trans_call_inner(\n                 bcx, e.info(), node_id_type(bcx, alloc_id), void_ty,\n-                {|bcx| impl::trans_method_callee(bcx, alloc_id,\n-                                                 pool, origin) },\n+                |bcx| impl::trans_method_callee(bcx, alloc_id,\n+                                                 pool, origin),\n                 arg_vals(args),\n                 save_in(voidval));\n \n@@ -3874,17 +3872,17 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n \n     let modpath = vec::append(\n         ~[path_mod(ccx.link_meta.name)],\n-        vec::filter(bcx.fcx.path, {|e|\n+        vec::filter(bcx.fcx.path, |e|\n             alt e { path_mod(_) { true } _ { false } }\n-        }));\n+        ));\n     let modname = path_str(modpath);\n \n     let global = if ccx.module_data.contains_key(modname) {\n         ccx.module_data.get(modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, @\"loglevel\");\n-        let global = str::as_c_str(s, {|buf|\n+        let global = str::as_c_str(s, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n         });\n         llvm::LLVMSetGlobalConstant(global, False);\n@@ -3895,14 +3893,14 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n     };\n     let current_level = Load(bcx, global);\n     let {bcx, val: level} = {\n-        do with_scope_result(bcx, lvl.info(), \"level\") {|bcx|\n+        do with_scope_result(bcx, lvl.info(), \"level\") |bcx| {\n             trans_temp_expr(bcx, lvl)\n         }\n     };\n \n-    do with_cond(bcx, ICmp(bcx, lib::llvm::IntUGE, current_level, level)) {\n-        |bcx|\n-        do with_scope(bcx, log_ex.info(), \"log\") {|bcx|\n+    do with_cond(bcx, ICmp(bcx, lib::llvm::IntUGE, current_level, level))\n+        |bcx| {\n+        do with_scope(bcx, log_ex.info(), \"log\") |bcx| {\n             let {bcx, val, _} = trans_temp_expr(bcx, e);\n             let e_ty = expr_ty(bcx, e);\n             let tydesc = get_tydesc_simple(ccx, e_ty);\n@@ -3920,11 +3918,11 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n     let expr_str = s + \" \" + expr_to_str(pred_expr) + \" failed\";\n     let {bcx, val} = {\n-        do with_scope_result(bcx, chk_expr.info(), \"check\") {|bcx|\n+        do with_scope_result(bcx, chk_expr.info(), \"check\") |bcx| {\n             trans_temp_expr(bcx, pred_expr)\n         }\n     };\n-    do with_cond(bcx, Not(bcx, val)) {|bcx|\n+    do with_cond(bcx, Not(bcx, val)) |bcx| {\n         trans_fail(bcx, some(pred_expr.span), expr_str)\n     }\n }\n@@ -4133,7 +4131,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n       ast::stmt_decl(d, _) {\n         alt d.node {\n           ast::decl_local(locals) {\n-            for vec::each(locals) {|local|\n+            for vec::each(locals) |local| {\n                 bcx = init_local(bcx, local);\n                 if cx.sess().opts.extra_debuginfo {\n                     debuginfo::create_local_var(bcx, local);\n@@ -4156,11 +4154,11 @@ fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         cx.ccx.names(name)\n     } else { \"\" };\n-    let llbb: BasicBlockRef = str::as_c_str(s, {|buf|\n+    let llbb: BasicBlockRef = str::as_c_str(s, |buf| {\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     let bcx = mk_block(llbb, parent, kind, opt_node_info, cx);\n-    do option::iter(parent) {|cx|\n+    do option::iter(parent) |cx| {\n         if cx.unreachable { Unreachable(bcx); }\n     };\n     ret bcx;\n@@ -4224,7 +4222,7 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n     alt check cleanup_cx.kind {\n       block_scope({cleanups, _}) {\n         let cleanups = copy cleanups;\n-        do vec::riter(cleanups) {|cu|\n+        do vec::riter(cleanups) |cu| {\n             alt cu {\n               clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) {\n                 // Some types don't need to be cleaned up during\n@@ -4260,7 +4258,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n         alt cur.kind {\n           block_scope(inf) if inf.cleanups.len() > 0u {\n             for vec::find(inf.cleanup_paths,\n-                          {|cp| cp.target == leave}).each {|cp|\n+                          |cp| cp.target == leave).each |cp| {\n                 Br(bcx, cp.dest);\n                 ret;\n             }\n@@ -4328,12 +4326,12 @@ fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n }\n \n fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n-    for vec::each(b.node.stmts) {|s|\n+    for vec::each(b.node.stmts) |s| {\n         alt s.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locals) {\n-                for vec::each(locals) {|local| it(local); }\n+                for vec::each(locals) |local| { it(local); }\n               }\n               _ {/* fall through */ }\n             }\n@@ -4362,8 +4360,8 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     };\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n-        do option::iter(simple_name) {|name|\n-            str::as_c_str(*name, {|buf|\n+        do option::iter(simple_name) |name| {\n+            str::as_c_str(*name, |buf| {\n                 llvm::LLVMSetValueName(val, buf)\n             });\n         }\n@@ -4376,8 +4374,8 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n-    do block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n-    for vec::each(b.node.stmts) {|s|\n+    do block_locals(b) |local| { bcx = alloc_local(bcx, local); };\n+    for vec::each(b.node.stmts) |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n@@ -4395,12 +4393,12 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n // Creates the standard set of basic blocks for a function\n fn mk_standard_basic_blocks(llfn: ValueRef) ->\n    {sa: BasicBlockRef, ca: BasicBlockRef, rt: BasicBlockRef} {\n-    {sa: str::as_c_str(\"static_allocas\", {|buf|\n-        llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-     ca: str::as_c_str(\"load_env\", {|buf|\n-         llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-     rt: str::as_c_str(\"return\", {|buf|\n-         llvm::LLVMAppendBasicBlock(llfn, buf) })}\n+    {sa: str::as_c_str(\"static_allocas\",\n+                       |buf| llvm::LLVMAppendBasicBlock(llfn, buf)),\n+     ca: str::as_c_str(\"load_env\",\n+                       |buf| llvm::LLVMAppendBasicBlock(llfn, buf)),\n+     rt: str::as_c_str(\"return\",\n+                       |buf| llvm::LLVMAppendBasicBlock(llfn, buf))}\n }\n \n \n@@ -4468,7 +4466,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n \n     // Populate the llargs field of the function context with the ValueRefs\n     // that we get from llvm::LLVMGetParam for each argument.\n-    for vec::each(args) {|arg|\n+    for vec::each(args) |arg| {\n         let llarg = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n         assert (llarg as int != 0);\n         // Note that this uses local_mem even for things passed by value.\n@@ -4488,7 +4486,7 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n         tcx.sess.bug(\"someone forgot\\\n                 to document an invariant in copy_args_to_allocas!\");\n     };\n-    for vec::each(arg_tys) {|arg|\n+    for vec::each(arg_tys) |arg| {\n         let id = args[arg_n].id;\n         let argval = alt fcx.llargs.get(id) { local_mem(v) { v }\n                                               _ { epic_fail() } };\n@@ -4599,11 +4597,13 @@ fn trans_fn(ccx: @crate_ctxt,\n                 else { {sec: 0i64, nsec: 0i32} };\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n-                  param_substs, id, {|fcx|\n-        if ccx.sess.opts.extra_debuginfo {\n-            debuginfo::create_function(fcx);\n-        }\n-    }, {|_bcx|});\n+                  param_substs, id,\n+                  |fcx| {\n+                      if ccx.sess.opts.extra_debuginfo {\n+                          debuginfo::create_function(fcx);\n+                      }\n+                  },\n+                  |_bcx| { });\n     if do_time {\n         let end = time::get_time();\n         log_fn_time(ccx, path_str(path), start, end);\n@@ -4616,12 +4616,11 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n-    let fn_args = vec::map(variant.node.args, {|varg|\n+    let fn_args = vec::map(variant.node.args, |varg|\n         {mode: ast::expl(ast::by_copy),\n          ty: varg.ty,\n          ident: @\"arg\",\n-         id: varg.id}\n-    });\n+         id: varg.id});\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id,\n                                param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args);\n@@ -4645,7 +4644,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     };\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n-    for vec::eachi(variant.node.args) {|i, va|\n+    for vec::eachi(variant.node.args) |i, va| {\n         let lldestptr = GEP_enum(bcx, llblobptr, t_id, v_id,\n                                  ty_param_substs, i);\n         // If this argument to this function is a enum, it'll have come in to\n@@ -4844,7 +4843,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   let mut bcx = bcx_top;\n   // Initialize fields to zero so init assignments can validly\n   // drop their LHS\n-  for fields.each {|field|\n+    for fields.each |field| {\n      let ix = field_idx_strict(bcx.tcx(), sp, field.ident, fields);\n      bcx = zero_mem(bcx, GEPi(bcx, valptr, ~[0u, ix]), field.mt.ty);\n   }\n@@ -4872,7 +4871,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   /* Look up the parent class's def_id */\n   let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n   /* Substitute in the class type if necessary */\n-  do option::iter(psubsts) {|ss|\n+    do option::iter(psubsts) |ss| {\n     class_ty = ty::subst_tps(tcx, ss.tys, class_ty);\n   }\n \n@@ -4890,7 +4889,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n \n   /* If we're monomorphizing, register the monomorphized decl\n      for the dtor */\n-  do option::iter(hash_id) {|h_id|\n+    do option::iter(hash_id) |h_id| {\n     ccx.monomorphized.insert(h_id, lldecl);\n   }\n   /* Translate the dtor body */\n@@ -4919,7 +4918,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n                      vec::append(*path, ~[path_name(item.ident)]),\n                      decl, body, llfndecl, no_self, none, item.id);\n         } else {\n-            for vec::each(body.node.stmts) {|stmt|\n+            for vec::each(body.node.stmts) |stmt| {\n                 alt stmt.node {\n                   ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n                     trans_item(ccx, *i);\n@@ -4940,7 +4939,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let degen = variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            for vec::each(variants) {|variant|\n+            for vec::each(variants) |variant| {\n                 if variant.node.args.len() > 0u {\n                     let llfn = get_item_val(ccx, variant.node.id);\n                     trans_enum_variant(ccx, item.id, variant,\n@@ -4967,7 +4966,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n           trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n                            get_item_val(ccx, ctor.node.id), psubsts,\n                            ctor.node.id, local_def(item.id), ctor.span);\n-          do option::iter(m_dtor) {|dtor|\n+            do option::iter(m_dtor) |dtor| {\n              trans_class_dtor(ccx, *path, dtor.node.body,\n                dtor.node.id, none, none, local_def(item.id));\n           };\n@@ -4989,7 +4988,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n // and control visibility.\n fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n-    for vec::each(m.items) {|item| trans_item(ccx, *item); }\n+    for vec::each(m.items) |item| { trans_item(ccx, *item); }\n }\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n@@ -5082,7 +5081,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         fn main_name() -> str { ret \"main\"; }\n         let llfty = T_fn(~[ccx.int_type, ccx.int_type], ccx.int_type);\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name(), llfty);\n-        let llbb = str::as_c_str(\"top\", {|buf|\n+        let llbb = str::as_c_str(\"top\", |buf| {\n             llvm::LLVMAppendBasicBlock(llfn, buf)\n         });\n         let bld = ccx.builder.B;\n@@ -5179,7 +5178,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n               ast::item_const(_, _) {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n-                let g = str::as_c_str(s, {|buf|\n+                let g = str::as_c_str(s, |buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n                 });\n                 ccx.item_symbols.insert(i.id, s);\n@@ -5268,13 +5267,13 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n                                              node: it.id});\n         let mut i = 0;\n         let path = item_path(ccx, it);\n-        for vec::each(variants) {|variant|\n+        for vec::each(variants) |variant| {\n             let p = vec::append(path, ~[path_name(variant.node.name),\n                                        path_name(@\"discrim\")]);\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n-            let discrim_gvar = str::as_c_str(s, {|buf|\n+            let discrim_gvar = str::as_c_str(s, |buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n             });\n             llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n@@ -5291,7 +5290,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n \n fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: {|a|trans_constant(ccx, a)}\n+        visit_item: |a| trans_constant(ccx, a)\n         with *visit::default_simple_visitor()\n     }));\n }\n@@ -5377,16 +5376,16 @@ fn trap(bcx: block) {\n fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let elttype = T_struct(~[ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n-    let map = str::as_c_str(\"_rust_mod_map\", {|buf|\n+    let map = str::as_c_str(\"_rust_mod_map\", |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n-    for ccx.module_data.each {|key, val|\n+    for ccx.module_data.each |key, val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, key)),\n                             p2i(ccx, val)]);\n         vec::push(elts, elt);\n-    };\n+    }\n     let term = C_struct(~[C_int(ccx, 0), C_int(ccx, 0)]);\n     vec::push(elts, term);\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n@@ -5407,7 +5406,7 @@ fn decl_crate_map(sess: session::session, mapmeta: link_meta,\n     let sym_name = \"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n     let maptype = T_struct(~[int_type, arrtype]);\n-    let map = str::as_c_str(sym_name, {|buf|\n+    let map = str::as_c_str(sym_name, |buf| {\n         llvm::LLVMAddGlobal(llmod, maptype, buf)\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n@@ -5423,7 +5422,7 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n         let nm = \"_rust_crate_map_\" + cdata.name +\n             \"_\" + *cstore::get_crate_vers(cstore, i) +\n             \"_\" + *cstore::get_crate_hash(cstore, i);\n-        let cr = str::as_c_str(nm, {|buf|\n+        let cr = str::as_c_str(nm, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n         vec::push(subcrates, p2i(ccx, cr));\n@@ -5439,14 +5438,14 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n     -> encoder::encode_parms {\n \n     let encode_inlined_item =\n-        {|a,b,c,d|astencode::encode_inlined_item(a, b, c, d, cx.maps)};\n+        |a,b,c,d| astencode::encode_inlined_item(a, b, c, d, cx.maps);\n \n     ret {\n         diag: cx.sess.diagnostic(),\n         tcx: cx.tcx,\n         reachable: cx.reachable,\n         reexports: reexports(cx),\n-        impl_map: {|a|impl_map(cx, a)},\n+        impl_map: |a| impl_map(cx, a),\n         item_symbols: cx.item_symbols,\n         discrim_symbols: cx.discrim_symbols,\n         link_meta: cx.link_meta,\n@@ -5456,8 +5455,8 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n \n     fn reexports(cx: @crate_ctxt) -> ~[(str, ast::def_id)] {\n         let mut reexports = ~[];\n-        for cx.exp_map.each {|exp_id, defs|\n-            for defs.each {|def|\n+        for cx.exp_map.each |exp_id, defs| {\n+            for defs.each |def| {\n                 if !def.reexp { cont; }\n                 let path = alt check cx.tcx.items.get(exp_id) {\n                   ast_map::node_export(_, path) {\n@@ -5473,9 +5472,8 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n     fn impl_map(cx: @crate_ctxt,\n                 id: ast::node_id) -> ~[(ast::ident, ast::def_id)] {\n         let mut result = ~[];\n-        for list::each(cx.maps.impl_map.get(id)) {\n-            |impls|\n-            vec::push_all(result, (*impls).map({|i| (i.ident, i.did) }));\n+        for list::each(cx.maps.impl_map.get(id)) |impls| {\n+            vec::push_all(result, (*impls).map(|i| (i.ident, i.did)));\n         }\n         ret result;\n     }\n@@ -5486,18 +5484,18 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct(~[llmeta]);\n-    let mut llglobal = str::as_c_str(\"rust_metadata\", {|buf|\n+    let mut llglobal = str::as_c_str(\"rust_metadata\", |buf| {\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llconst);\n-    str::as_c_str(cx.sess.targ_cfg.target_strs.meta_sect_name, {|buf|\n+    str::as_c_str(cx.sess.targ_cfg.target_strs.meta_sect_name, |buf| {\n         llvm::LLVMSetSection(llglobal, buf)\n     });\n     lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n     let t_ptr_i8 = T_ptr(T_i8());\n     llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-    let llvm_used = str::as_c_str(\"llvm.used\", {|buf|\n+    let llvm_used = str::as_c_str(\"llvm.used\", |buf| {\n         llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n     });\n     lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n@@ -5529,18 +5527,18 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = *link_meta.name + \".rc\";\n \n-    let llmod = str::as_c_str(llmod_id, {|buf|\n+    let llmod = str::as_c_str(llmod_id, |buf| {\n         llvm::LLVMModuleCreateWithNameInContext\n             (buf, llvm::LLVMGetGlobalContext())\n     });\n     let data_layout = sess.targ_cfg.target_strs.data_layout;\n     let targ_triple = sess.targ_cfg.target_strs.target_triple;\n     let _: () =\n         str::as_c_str(data_layout,\n-                    {|buf| llvm::LLVMSetDataLayout(llmod, buf) });\n+                    |buf| llvm::LLVMSetDataLayout(llmod, buf));\n     let _: () =\n         str::as_c_str(targ_triple,\n-                    {|buf| llvm::LLVMSetTarget(llmod, buf) });\n+                    |buf| llvm::LLVMSetTarget(llmod, buf));\n     let targ_cfg = sess.targ_cfg;\n     let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n     let tn = mk_type_names();\n@@ -5580,10 +5578,10 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           discrim_symbols: int_hash::<str>(),\n           tydescs: ty::new_ty_hash(),\n           external: ast_util::new_def_hash(),\n-          monomorphized: map::hashmap(hash_mono_id, {|a, b| a == b}),\n+          monomorphized: map::hashmap(hash_mono_id, |a, b| a == b),\n           monomorphizing: ast_util::new_def_hash(),\n           type_use_cache: ast_util::new_def_hash(),\n-          vtables: map::hashmap(hash_mono_id, {|a, b| a == b}),\n+          vtables: map::hashmap(hash_mono_id, |a, b| a == b),\n           const_cstr_cache: map::str_hash(),\n           module_data: str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n@@ -5647,14 +5645,14 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n         let times = copy *ccx.stats.fn_times;\n-        for vec::each(times) {|timing|\n+        for vec::each(times) |timing| {\n             io::println(#fmt(\"time: %s took %d ms\", timing.ident,\n                              timing.time));\n         }\n     }\n \n     if ccx.sess.count_llvm_insns() {\n-        for ccx.stats.llvm_insns.each { |k, v|\n+        for ccx.stats.llvm_insns.each |k, v| {\n             io::println(#fmt(\"%-7u %s\", v, k));\n         }\n     }"}, {"sha": "8c261a402b4ec1743a11943d99fc5d471ba2b3a9", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -141,7 +141,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     cx.terminated = true;\n     #debug[\"Invoke(%s with arguments (%s))\",\n            val_str(cx.ccx().tn, Fn),\n-           str::connect(vec::map(Args, {|a|val_str(cx.ccx().tn, a)}),\n+           str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, a)),\n                         \", \")];\n     unsafe {\n         count_insn(cx, \"invoke\");\n@@ -430,7 +430,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n // in C_i32()\n fn GEPi(cx: block, base: ValueRef, ixs: ~[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n-    for vec::each(ixs) {|i| vec::push(v, C_i32(i as i32)); }\n+    for vec::each(ixs) |i| { vec::push(v, C_i32(i as i32)); }\n     count_insn(cx, \"gepi\");\n     ret InBoundsGEP(cx, base, v);\n }\n@@ -654,8 +654,8 @@ fn add_comment(bcx: block, text: str) {\n     if !ccx.sess.no_asm_comments() {\n         let sanitized = str::replace(text, \"$\", \"\");\n         let comment_text = \"# \" + sanitized;\n-        let asm = str::as_c_str(comment_text, {|c|\n-            str::as_c_str(\"\", {|e|\n+        let asm = str::as_c_str(comment_text, |c| {\n+            str::as_c_str(\"\", |e| {\n                 count_insn(bcx, \"inlineasm\");\n                 llvm::LLVMConstInlineAsm(T_fn(~[], T_void()), c, e,\n                                          False, False)\n@@ -672,7 +672,7 @@ fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n \n         #debug[\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n-               Args.map({ |arg| val_str(cx.ccx().tn, arg) })];\n+               Args.map(|arg| val_str(cx.ccx().tn, arg))];\n \n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                 Args.len() as c_uint, noname());\n@@ -775,7 +775,7 @@ fn Trap(cx: block) {\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-    let T: ValueRef = str::as_c_str(\"llvm.trap\", {|buf|\n+    let T: ValueRef = str::as_c_str(\"llvm.trap\", |buf| {\n         llvm::LLVMGetNamedFunction(M, buf)\n     });\n     assert (T as int != 0);"}, {"sha": "8bd2a61836cd344dabf819a9b452354c8d213a02", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -127,7 +127,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     let mut bound_tys = ~[];\n \n     // Compute the closed over data\n-    for vec::each(bound_values) {|bv|\n+    for vec::each(bound_values) |bv| {\n         vec::push(bound_tys, alt bv {\n             env_copy(_, t, _) { t }\n             env_move(_, t, _) { t }\n@@ -233,7 +233,7 @@ fn store_environment(bcx: block,\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    do vec::iteri(bound_values) { |i, bv|\n+    do vec::iteri(bound_values) |i, bv| {\n         #debug[\"Copy %s into closure\", ev_to_str(ccx, bv)];\n \n         if !ccx.sess.no_asm_comments() {\n@@ -275,7 +275,7 @@ fn store_environment(bcx: block,\n           }\n         }\n     }\n-    for vec::each(temp_cleanups) {|cleanup| revoke_clean(bcx, cleanup); }\n+    for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n \n     ret {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n }\n@@ -294,7 +294,7 @@ fn build_closure(bcx0: block,\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // Package up the captured upvars\n-    do vec::iter(cap_vars) { |cap_var|\n+    do vec::iter(cap_vars) |cap_var| {\n         #debug[\"Building closure: captured variable %?\", cap_var];\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n@@ -323,7 +323,7 @@ fn build_closure(bcx0: block,\n           }\n         }\n     }\n-    do option::iter(include_ret_handle) {|flagptr|\n+    do option::iter(include_ret_handle) |flagptr| {\n         let our_ret = alt bcx.fcx.loop_ret {\n           some({retptr, _}) { retptr }\n           none { bcx.fcx.llretptr }\n@@ -354,7 +354,7 @@ fn load_environment(fcx: fn_ctxt,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    do vec::iter(cap_vars) { |cap_var|\n+    do vec::iter(cap_vars) |cap_var| {\n         alt cap_var.mode {\n           capture::cap_drop { /* ignore */ }\n           _ {\n@@ -404,10 +404,10 @@ fn trans_expr_fn(bcx: block,\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id,\n                                                    ret_handle);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n-                      bcx.fcx.param_substs, id, {|fcx|\n+                      bcx.fcx.param_substs, id, |fcx| {\n             load_environment(fcx, cdata_ty, cap_vars,\n                              option::is_some(ret_handle), ck);\n-        }, {|bcx|\n+                      }, |bcx| {\n             if option::is_some(is_loop_body) {\n                 Store(bcx, C_bool(true), bcx.fcx.llretptr);\n             }\n@@ -421,7 +421,7 @@ fn trans_expr_fn(bcx: block,\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self, none,\n-                      id, {|_fcx|}, {|_bcx|});\n+                      id, |_fcx| { }, |_bcx| { });\n         C_null(T_opaque_box_ptr(ccx))\n       }\n     };\n@@ -436,12 +436,12 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n     let _icx = cx.insn_ctxt(\"closure::trans_bind1\");\n     let ccx = cx.ccx();\n     let mut bound: ~[@ast::expr] = ~[];\n-    for vec::each(args) {|argopt|\n+    for vec::each(args) |argopt| {\n         alt argopt { none { } some(e) { vec::push(bound, e); } }\n     }\n     let mut bcx = f_res.bcx;\n     if dest == ignore {\n-        for vec::each(bound) {|ex| bcx = trans_expr(bcx, ex, ignore); }\n+        for vec::each(bound) |ex| { bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n     }\n \n@@ -478,7 +478,9 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n     // Actually construct the closure\n     let {llbox, cdata_ty, bcx} = store_environment(\n         bcx, vec::append(env_vals,\n-                         vec::map(bound, {|x| env_expr(x, expr_ty(bcx, x))})),\n+                         vec::map(bound, |x| {\n+                             env_expr(x, expr_ty(bcx, x))\n+                         })),\n         ty::ck_box);\n \n     // Make thunk\n@@ -504,7 +506,7 @@ fn make_fn_glue(\n     let fn_env = fn@(ck: ty::closure_kind) -> block {\n         let box_cell_v = GEPi(cx, v, ~[0u, abi::fn_field_box]);\n         let box_ptr_v = Load(cx, box_cell_v);\n-        do with_cond(cx, IsNotNull(cx, box_ptr_v)) {|bcx|\n+        do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n             let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n             glue_fn(bcx, box_cell_v, closure_ty)\n         }\n@@ -537,7 +539,7 @@ fn make_opaque_cbox_take_glue(\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let llopaquecboxty = T_opaque_box_ptr(ccx);\n     let cbox_in = Load(bcx, cboxptr);\n-    do with_cond(bcx, IsNotNull(bcx, cbox_in)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, cbox_in)) |bcx| {\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n         let tydescptr = GEPi(bcx, cbox_in, ~[0u, abi::box_field_tydesc]);\n@@ -599,7 +601,7 @@ fn make_opaque_cbox_free_glue(\n     }\n \n     let ccx = bcx.ccx();\n-    do with_cond(bcx, IsNotNull(bcx, cbox)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, cbox)) |bcx| {\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n         let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));\n@@ -740,7 +742,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let mut a: uint = first_real_arg; // retptr, env come first\n     let mut b: uint = starting_idx;\n     let mut outgoing_arg_index: uint = 0u;\n-    for vec::each(args) {|arg|\n+    for vec::each(args) |arg| {\n         let out_arg = outgoing_args[outgoing_arg_index];\n         alt arg {\n           // Arg provided at binding time; thunk copies it from"}, {"sha": "3125f3d84b835f2e7af16fe35893bcaa5a3bfcce", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -251,8 +251,8 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx) {|info|\n-        vec::push(info.cleanups, clean({|a|base::drop_ty(a, val, ty)},\n+    do in_scope_cx(cx) |info| {\n+        vec::push(info.cleanups, clean(|a| base::drop_ty(a, val, ty),\n                                 cleanup_type));\n         scope_clean_changed(info);\n     }\n@@ -271,8 +271,8 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n             ret base::drop_ty(bcx, val, ty);\n         }\n     }\n-    do in_scope_cx(cx) {|info|\n-        vec::push(info.cleanups, clean_temp(val, {|a|do_drop(a, val, ty)},\n+    do in_scope_cx(cx) |info| {\n+        vec::push(info.cleanups, clean_temp(val, |a| do_drop(a, val, ty),\n                                      cleanup_type));\n         scope_clean_changed(info);\n     }\n@@ -283,19 +283,19 @@ fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx) {|info|\n+    do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups,\n-                  clean_temp(val, {|a|base::drop_ty(a, val, ty)},\n+                  clean_temp(val, |a| base::drop_ty(a, val, ty),\n                              cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n     let free_fn = alt heap {\n-      heap_shared { {|a|base::trans_free(a, ptr)} }\n-      heap_exchange { {|a|base::trans_unique_free(a, ptr)} }\n+      heap_shared { |a| base::trans_free(a, ptr) }\n+      heap_exchange { |a| base::trans_unique_free(a, ptr) }\n     };\n-    do in_scope_cx(cx) {|info|\n+    do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups, clean_temp(ptr, free_fn,\n                                      normal_exit_and_unwind));\n         scope_clean_changed(info);\n@@ -307,10 +307,10 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n fn revoke_clean(cx: block, val: ValueRef) {\n-    do in_scope_cx(cx) {|info|\n-        do option::iter(vec::position(info.cleanups, {|cu|\n+    do in_scope_cx(cx) |info| {\n+        do option::iter(vec::position(info.cleanups, |cu| {\n             alt cu { clean_temp(v, _, _) if v == val { true } _ { false } }\n-        })) {|i|\n+        })) |i| {\n             info.cleanups =\n                 vec::append(vec::slice(info.cleanups, 0u, i),\n                             vec::view(info.cleanups,\n@@ -361,7 +361,7 @@ impl node_info for ast::blk {\n \n impl node_info for option<@ast::expr> {\n     fn info() -> option<node_info> {\n-        self.chain({ |s| s.info() })\n+        self.chain(|s| s.info())\n     }\n }\n \n@@ -592,7 +592,7 @@ fn T_struct(elts: ~[TypeRef]) -> TypeRef unsafe {\n \n fn T_named_struct(name: str) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n-    ret str::as_c_str(name, {|buf| llvm::LLVMStructCreateNamed(c, buf) });\n+    ret str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n }\n \n fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) unsafe {\n@@ -800,7 +800,7 @@ fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n }\n \n fn C_floating(s: str, t: TypeRef) -> ValueRef {\n-    ret str::as_c_str(s, {|buf| llvm::LLVMConstRealOfString(t, buf) });\n+    ret str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n }\n \n fn C_nil() -> ValueRef {\n@@ -840,12 +840,12 @@ fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n       none { }\n     }\n \n-    let sc = do str::as_c_str(s) {|buf|\n+    let sc = do str::as_c_str(s) |buf| {\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n     let g =\n         str::as_c_str(cx.names(\"str\"),\n-                    {|buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf) });\n+                    |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n     lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -862,7 +862,7 @@ fn C_estr_slice(cx: @crate_ctxt, s: str) -> ValueRef {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: str) -> ValueRef {\n-    ret do str::as_c_str(s) {|buf|\n+    ret do str::as_c_str(s) |buf| {\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n }\n@@ -898,7 +898,7 @@ fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n \n fn C_shape(ccx: @crate_ctxt, bytes: ~[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = str::as_c_str(ccx.names(\"shape\"), {|buf|\n+    let llglobal = str::as_c_str(ccx.names(\"shape\"), |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llshape);\n@@ -920,12 +920,12 @@ enum mono_param_id {\n type mono_id = @{def: ast::def_id, params: ~[mono_param_id]};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let mut h = syntax::ast_util::hash_def(mi.def);\n-    for vec::each(mi.params) {|param|\n+    for vec::each(mi.params) |param| {\n         h = h * alt param {\n           mono_precise(ty, vts) {\n             let mut h = ty::type_id(ty);\n-            do option::iter(vts) {|vts|\n-                for vec::each(vts) {|vt| h += hash_mono_id(vt); }\n+            do option::iter(vts) |vts| {\n+                for vec::each(vts) |vt| { h += hash_mono_id(vt); }\n             }\n             h\n           }\n@@ -954,7 +954,7 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n \n fn path_str(p: path) -> str {\n     let mut r = \"\", first = true;\n-    for vec::each(p) {|e|\n+    for vec::each(p) |e| {\n         alt e { ast_map::path_name(s) | ast_map::path_mod(s) {\n           if first { first = false; }\n           else { r += \"::\"; }\n@@ -980,7 +980,7 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let params = ty::node_id_to_type_params(tcx, id);\n     alt bcx.fcx.param_substs {\n       some(substs) {\n-        vec::map(params, {|t| ty::subst_tps(tcx, substs.tys, t) })\n+        vec::map(params, |t| ty::subst_tps(tcx, substs.tys, t))\n       }\n       _ { params }\n     }"}, {"sha": "bbef68aaad672212d0e6fb886de23cbfc4b68d9f", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -48,7 +48,7 @@ const DW_ATE_unsigned: int = 0x07;\n const DW_ATE_unsigned_char: int = 0x08;\n \n fn llstr(s: str) -> ValueRef {\n-    str::as_c_str(s, {|sbuf|\n+    str::as_c_str(s, |sbuf| {\n         llvm::LLVMMDString(sbuf, str::len(s) as libc::c_uint)\n     })\n }\n@@ -76,7 +76,7 @@ fn llnull() -> ValueRef unsafe {\n }\n \n fn add_named_metadata(cx: @crate_ctxt, name: str, val: ValueRef) {\n-    str::as_c_str(name, {|sbuf|\n+    str::as_c_str(name, |sbuf| {\n         llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n     })\n }\n@@ -150,7 +150,7 @@ fn cached_metadata<T: copy>(cache: metadata_cache, mdtag: int,\n                            eq: fn(md: T) -> bool) -> option<T> unsafe {\n     if cache.contains_key(mdtag) {\n         let items = cache.get(mdtag);\n-        for items.each {|item|\n+        for items.each |item| {\n             let md: T = md_from_metadata::<T>(item);\n             if eq(md) {\n                 ret option::some(md);\n@@ -166,7 +166,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n     let crate_name = option::get(cx.dbg_cx).crate_file;\n     let tg = CompileUnitTag;\n     alt cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n-                        {|md| md.data.name == crate_name}) {\n+                        |md| md.data.name == crate_name) {\n       option::some(md) { ret md; }\n       option::none {}\n     }\n@@ -209,7 +209,7 @@ fn create_file(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n     alt cached_metadata::<@metadata<file_md>>(\n-        cache, tg, {|md| md.data.path == full_path}) {\n+        cache, tg, |md| md.data.path == full_path) {\n         option::some(md) { ret md; }\n         option::none {}\n     }\n@@ -286,7 +286,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n-        cache, tg, {|md| ty::type_id(t) == md.data.hash}) {\n+        cache, tg, |md| ty::type_id(t) == md.data.hash) {\n       option::some(md) { ret md; }\n       option::none {}\n     }\n@@ -417,7 +417,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n                                option::get(cx.dbg_cx).names(\"rec\"),\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n-    for fields.each {|field|\n+    for fields.each |field| {\n         let field_t = ty::get_field(t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = size_and_align_of(cx, field_t);\n@@ -640,7 +640,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let cache = get_cache(cx);\n     let tg = AutoVariableTag;\n     alt cached_metadata::<@metadata<local_var_md>>(\n-        cache, tg, {|md| md.data.id == local.node.id}) {\n+        cache, tg, |md| md.data.id == local.node.id) {\n       option::some(md) { ret md; }\n       option::none {}\n     }\n@@ -690,7 +690,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let cache = get_cache(cx);\n     let tg = ArgVariableTag;\n     alt cached_metadata::<@metadata<argument_md>>(\n-        cache, ArgVariableTag, {|md| md.data.id == arg.id}) {\n+        cache, ArgVariableTag, |md| md.data.id == arg.id) {\n       option::some(md) { ret md; }\n       option::none {}\n     }\n@@ -778,7 +778,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n \n     let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<subprogram_md>>(\n-        cache, SubprogramTag, {|md| md.data.id == id}) {\n+        cache, SubprogramTag, |md| md.data.id == id) {\n       option::some(md) { ret md; }\n       option::none {}\n     }"}, {"sha": "58c7fd1349e2783da85486064c0255bcbdae0d31", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -67,7 +67,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n         let n = llvm::LLVMCountStructElementTypes(ty);\n         let elts = vec::from_elem(n as uint, ptr::null());\n-        do vec::as_buf(elts) {|buf|\n+        do vec::as_buf(elts) |buf| {\n             llvm::LLVMGetStructElementTypes(ty, buf);\n         }\n         ret elts;\n@@ -82,7 +82,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             2 /* float */ { 4u }\n             3 /* double */ { 8u }\n             10 /* struct */ {\n-                do vec::foldl(0u, struct_tys(ty)) {|a, t|\n+              do vec::foldl(0u, struct_tys(ty)) |a, t| {\n                     uint::max(a, ty_align(t))\n                 }\n             }\n@@ -105,7 +105,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             2 /* float */ { 4u }\n             3 /* double */ { 8u }\n             10 /* struct */ {\n-                do vec::foldl(0u, struct_tys(ty)) {|s, t|\n+              do vec::foldl(0u, struct_tys(ty)) |s, t| {\n                     s + ty_size(t)\n                 }\n             }\n@@ -122,7 +122,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn all_mem(cls: ~[mut x86_64_reg_class]) {\n-        for uint::range(0u, cls.len()) { |i|\n+        for uint::range(0u, cls.len()) |i| {\n             cls[i] = memory_class;\n         }\n     }\n@@ -159,7 +159,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             classify(T_i64(), cls, i, off);\n         } else {\n             let mut field_off = off;\n-            for vec::each(tys) {|ty|\n+            for vec::each(tys) |ty| {\n                 field_off = align(field_off, ty);\n                 classify(ty, cls, i, field_off);\n                 field_off += ty_size(ty);\n@@ -279,7 +279,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n     fn llvec_len(cls: ~[x86_64_reg_class]) -> uint {\n         let mut len = 1u;\n-        for vec::each(cls) {|c|\n+        for vec::each(cls) |c| {\n             if c != sseup_class {\n                 break;\n             }\n@@ -375,7 +375,7 @@ fn x86_64_tys(atys: ~[TypeRef],\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n-    for vec::each(atys) {|t|\n+    for vec::each(atys) |t| {\n         let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n         vec::push(arg_tys, ty);\n         vec::push(attrs, attr);\n@@ -404,12 +404,12 @@ fn x86_64_tys(atys: ~[TypeRef],\n \n fn decl_x86_64_fn(tys: x86_64_tys,\n                   decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n-    let atys = vec::map(tys.arg_tys, {|t| t.ty });\n+    let atys = vec::map(tys.arg_tys, |t| t.ty);\n     let rty = tys.ret_ty.ty;\n     let fnty = T_fn(atys, rty);\n     let llfn = decl(fnty);\n \n-    do vec::iteri(tys.attrs) {|i, a|\n+    do vec::iteri(tys.attrs) |i, a| {\n         alt a {\n             option::some(attr) {\n                 let llarg = get_param(llfn, i);\n@@ -640,7 +640,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n             alt tys.x86_64_tys {\n                 some(x86_64) {\n-                    do vec::iteri(x86_64.attrs) {|i, a|\n+                  do vec::iteri(x86_64.attrs) |i, a| {\n                         alt a {\n                             some(attr) {\n                                 llvm::LLVMAddInstrAttribute(\n@@ -691,7 +691,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n         // Declare the \"prototype\" for the base function F:\n         alt tys.x86_64_tys {\n           some(x86_64) {\n-            do decl_x86_64_fn(x86_64) {|fnty|\n+            do decl_x86_64_fn(x86_64) |fnty| {\n                 decl_fn(ccx.llmod, lname, cc, fnty)\n             }\n           }\n@@ -712,7 +712,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n         let llbasefn = base_fn(ccx, link_name(item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n-        let args = vec::from_fn(ty::ty_fn_args(ty).len(), {|i|\n+        let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n             get_param(decl, i + first_real_arg)\n         });\n         let retval = Call(bcx, llbasefn, args);\n@@ -762,7 +762,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n       ast::foreign_abi_stdcall { lib::llvm::X86StdcallCallConv }\n     };\n \n-    for vec::each(foreign_mod.items) {|foreign_item|\n+    for vec::each(foreign_mod.items) |foreign_item| {\n       alt foreign_item.node {\n         ast::foreign_item_fn(fn_decl, typarams) {\n           let id = foreign_item.id;\n@@ -974,12 +974,10 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n             constraints: ~[]\n         });\n         bcx = trans_call_inner(bcx, none, fty, ty::mk_nil(bcx.tcx()),\n-                               { |bcx|\n-                                   lval_no_env(\n-                                       bcx,\n-                                       get_param(decl, first_real_arg),\n-                                       temporary)\n-                               },\n+                               |bcx| lval_no_env(\n+                                   bcx,\n+                                   get_param(decl, first_real_arg),\n+                                   temporary),\n                                arg_vals(~[frameaddress_val]), ignore);\n       }\n     }\n@@ -1091,7 +1089,7 @@ fn trans_extern_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                 _ {\n                     let llretptr = alloca(bcx, tys.ret_ty);\n                     let n = vec::len(tys.arg_tys);\n-                    for uint::range(0u, n) {|i|\n+                  for uint::range(0u, n) |i| {\n                         let llargval = get_param(llwrapfn, i);\n                         store_inbounds(bcx, llargval, llargbundle,\n                                                       ~[0u, i]);\n@@ -1153,7 +1151,7 @@ fn register_extern_fn(ccx: @crate_ctxt, sp: span,\n     ret if ccx.sess.targ_cfg.arch == arch_x86_64 {\n         let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n         let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n-        do decl_x86_64_fn(x86_64) {|fnty|\n+        do decl_x86_64_fn(x86_64) |fnty| {\n             register_fn_fuller(ccx, sp, path, node_id,\n                                t, lib::llvm::CCallConv, fnty)\n         }"}, {"sha": "d9ea8316054fbc70a5cae6d6069fae3922fb9019", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -20,7 +20,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { ret; }\n     let sub_path = vec::append_one(path, path_name(name));\n-    for vec::each(methods) {|m|\n+    for vec::each(methods) |m| {\n         if m.tps.len() == 0u {\n             let llfn = get_item_val(ccx, m.id);\n             trans_fn(ccx,\n@@ -77,7 +77,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n \n fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n     -> ast::def_id {\n-  local_def(option::get(vec::find(ms, {|m| m.ident == name})).id)\n+  local_def(option::get(vec::find(ms, |m| m.ident == name)).id)\n }\n \n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n@@ -170,9 +170,9 @@ fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     let mut vtable_off = n_bound, i = 0u;\n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    for vec::each(*ps.bounds) {|bounds|\n+    for vec::each(*ps.bounds) |bounds| {\n         if i >= n_param { break; }\n-        for vec::each(*bounds) {|bound|\n+        for vec::each(*bounds) |bound| {\n             alt bound { ty::bound_iface(_) { vtable_off += 1u; } _ {} }\n         }\n         i += 1u;\n@@ -182,7 +182,7 @@ fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n \n fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    @vec::map(*vts, {|d| resolve_vtable_in_fn_ctxt(fcx, d)})\n+    @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, d))\n }\n \n fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n@@ -191,9 +191,7 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n       typeck::vtable_static(iid, tys, sub) {\n         let tys = alt fcx.param_substs {\n           some(substs) {\n-            vec::map(tys, {|t|\n-                ty::subst_tps(fcx.ccx.tcx, substs.tys, t)\n-            })\n+            vec::map(tys, |t| ty::subst_tps(fcx.ccx.tcx, substs.tys, t))\n           }\n           _ { tys }\n         };\n@@ -219,7 +217,7 @@ fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n       }\n       typeck::vtable_iface(iface_id, substs) {\n         @{def: iface_id,\n-          params: vec::map(substs, {|t| mono_precise(t, none)})}\n+          params: vec::map(substs, |t| mono_precise(t, none))}\n       }\n     }\n }\n@@ -242,7 +240,7 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n     let tbl = C_struct(ptrs);\n-    let vt_gvar = str::as_c_str(ccx.names(\"vtable\"), {|buf|\n+    let vt_gvar = str::as_c_str(ccx.names(\"vtable\"), |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n     });\n     llvm::LLVMSetInitializer(vt_gvar, tbl);\n@@ -258,9 +256,9 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n     let ifce_id = expect(ccx.sess,\n                          ty::ty_to_def_id(option::get(ty::impl_iface(tcx,\n                                                              impl_id))),\n-                         {|| \"make_impl_vtable: non-iface-type implemented\"});\n+                         || \"make_impl_vtable: non-iface-type implemented\");\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n-    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), {|im|\n+    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), |im| {\n         let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             C_null(T_ptr(T_nil()))"}, {"sha": "5c60585ca7c374cf815c6fd7646a6e12a7993516", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -33,11 +33,11 @@ fn find_reachable(crate_mod: _mod, exp_map: resolve::exp_map,\n \n fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n     let mut found_export = false;\n-    for vec::each(vis) {|vi|\n+    for vec::each(vis) |vi| {\n         alt vi.node {\n           view_item_export(vps) {\n             found_export = true;\n-            for vec::each(vps) {|vp|\n+            for vec::each(vps) |vp| {\n                 alt vp.node {\n                   view_path_simple(_, _, id) | view_path_glob(_, id) |\n                   view_path_list(_, _, id) {\n@@ -53,8 +53,8 @@ fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n }\n \n fn traverse_export(cx: ctx, exp_id: node_id) {\n-    do option::iter(cx.exp_map.find(exp_id)) {|defs|\n-        for vec::each(defs) {|def| traverse_def_id(cx, def.id); }\n+    do option::iter(cx.exp_map.find(exp_id)) |defs| {\n+        for vec::each(defs) |def| { traverse_def_id(cx, def.id); }\n     }\n }\n \n@@ -80,7 +80,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n fn traverse_public_mod(cx: ctx, m: _mod) {\n     if !traverse_exports(cx, m.view_items) {\n         // No exports, so every local item is exported\n-        for vec::each(m.items) {|item| traverse_public_item(cx, item); }\n+        for vec::each(m.items) |item| { traverse_public_item(cx, item); }\n     }\n }\n \n@@ -91,7 +91,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       item_mod(m) { traverse_public_mod(cx, m); }\n       item_foreign_mod(nm) {\n           if !traverse_exports(cx, nm.view_items) {\n-              for vec::each(nm.items) {|item| cx.rmap.insert(item.id, ()); }\n+              for vec::each(nm.items) |item| { cx.rmap.insert(item.id, ()); }\n           }\n       }\n       item_fn(_, tps, blk) {\n@@ -101,7 +101,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_impl(tps, _, _, _, ms) {\n-        for vec::each(ms) {|m|\n+        for vec::each(ms) |m| {\n             if tps.len() > 0u || m.tps.len() > 0u ||\n                attr::find_inline_attr(m.attrs) != attr::ia_none {\n                 cx.rmap.insert(m.id, ());\n@@ -111,14 +111,14 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       }\n       item_class(tps, _ifaces, items, ctor, m_dtor, _) {\n         cx.rmap.insert(ctor.node.id, ());\n-        do option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n             // dtors don't have attrs\n             if tps.len() > 0u {\n                 traverse_inline_body(cx, dtor.node.body);\n             }\n         }\n-        for vec::each(items) {|item|\n+        for vec::each(items) |item| {\n             alt item.node {\n               class_method(m) {\n                 cx.rmap.insert(m.id, ());\n@@ -156,7 +156,7 @@ fn traverse_ty(ty: @ty, cx: ctx, v: visit::vt<ctx>) {\n           some(d) { traverse_def_id(cx, def_id_of_def(d)); }\n           none    { /* do nothing -- but should we fail here? */ }\n         }\n-        for p.types.each {|t| v.visit_ty(t, cx, v); };\n+        for p.types.each |t| { v.visit_ty(t, cx, v); };\n       }\n       _ { visit::visit_ty(ty, cx, v); }\n     }\n@@ -201,8 +201,8 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n \n fn traverse_all_resources(cx: ctx, crate_mod: _mod) {\n     visit::visit_mod(crate_mod, ast_util::dummy_sp(), 0, cx, visit::mk_vt(@{\n-        visit_expr: {|_e, _cx, _v|},\n-        visit_item: {|i, cx, v|\n+        visit_expr: |_e, _cx, _v| { },\n+        visit_item: |i, cx, v| {\n             visit::visit_item(i, cx, v);\n             alt i.node {\n               item_class(_, _, _, _, some(_), _) {"}, {"sha": "730686b9df7c0e833277a6ca41f92441cdcf3eef", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -45,7 +45,7 @@ impl methods for reflector {\n                                                  *self.visitor_methods));\n         let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n-        let get_lval = {|bcx|\n+        let get_lval = |bcx| {\n             let callee =\n                 impl::trans_iface_callee(bcx, v, mth_ty, mth_idx);\n             #debug(\"calling mth ty %s, lltype %s\",\n@@ -55,7 +55,7 @@ impl methods for reflector {\n         };\n         #debug(\"passing %u args:\", vec::len(args));\n         let bcx = self.bcx;\n-        for args.eachi {|i, a|\n+        for args.eachi |i, a| {\n             #debug(\"arg %u: %s\", i, val_str(bcx.ccx().tn, a));\n         }\n         self.bcx =\n@@ -129,12 +129,12 @@ impl methods for reflector {\n \n           ty::ty_vec(mt) { self.bracketed_mt(\"vec\", mt, ~[]) }\n           ty::ty_estr(vst) {\n-            do self.vstore_name_and_extra(t, vst) {|name, extra|\n+            do self.vstore_name_and_extra(t, vst) |name, extra| {\n                 self.visit(\"estr_\" + name, extra)\n             }\n           }\n           ty::ty_evec(mt, vst) {\n-            do self.vstore_name_and_extra(t, vst) {|name, extra|\n+            do self.vstore_name_and_extra(t, vst) |name, extra| {\n                 self.bracketed_mt(\"evec_\" + name, mt, extra)\n             }\n           }\n@@ -147,7 +147,7 @@ impl methods for reflector {\n             let extra = (vec::append(~[self.c_uint(vec::len(fields))],\n                                      self.c_size_and_align(t)));\n             self.visit(\"enter_rec\", extra);\n-            for fields.eachi {|i, field|\n+            for fields.eachi |i, field| {\n                 self.bracketed_mt(\"rec_field\", field.mt,\n                                   ~[self.c_uint(i),\n                                    self.c_slice(*field.ident)]);\n@@ -159,7 +159,7 @@ impl methods for reflector {\n             let extra = (vec::append(~[self.c_uint(vec::len(tys))],\n                                      self.c_size_and_align(t)));\n             self.visit(\"enter_tup\", extra);\n-            for tys.eachi {|i, t|\n+            for tys.eachi |i, t| {\n                 self.bracketed_t(\"tup_field\", t, ~[self.c_uint(i)]);\n             }\n             self.visit(\"leave_tup\", extra);\n@@ -190,7 +190,7 @@ impl methods for reflector {\n                          self.c_uint(vec::len(fty.inputs)),\n                          self.c_uint(retval)];\n             self.visit(\"enter_fn\", extra);\n-            for fty.inputs.eachi {|i, arg|\n+            for fty.inputs.eachi |i, arg| {\n                 let modeval = alt arg.mode {\n                   ast::infer(_) { 0u }\n                   ast::expl(e) {\n@@ -220,7 +220,7 @@ impl methods for reflector {\n                                     self.c_size_and_align(t));\n \n             self.visit(\"enter_class\", extra);\n-            for fields.eachi {|i, field|\n+            for fields.eachi |i, field| {\n                 self.bracketed_mt(\"class_field\", field.mt,\n                                   ~[self.c_uint(i),\n                                    self.c_slice(*field.ident)]);\n@@ -240,13 +240,13 @@ impl methods for reflector {\n                                     self.c_size_and_align(t));\n \n             self.visit(\"enter_enum\", extra);\n-            for variants.eachi {|i, v|\n+            for variants.eachi |i, v| {\n                 let extra = ~[self.c_uint(i),\n                              self.c_int(v.disr_val),\n                              self.c_uint(vec::len(v.args)),\n                              self.c_slice(*v.name)];\n                 self.visit(\"enter_enum_variant\", extra);\n-                for v.args.eachi {|j, a|\n+                for v.args.eachi |j, a| {\n                     self.bracketed_t(\"enum_variant_field\", a,\n                                      ~[self.c_uint(j)]);\n                 }"}, {"sha": "2e2403090f5e1554305437dffc66d2ccab1a1b0b", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -28,7 +28,7 @@ type nominal_id = @{did: ast::def_id, parent_id: option<ast::def_id>,\n fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n                  parent_id: option<ast::def_id>,\n                  tps: ~[ty::t]) -> nominal_id {\n-    let tps_norm = tps.map({ |t| ty::normalize_ty(tcx, t) });\n+    let tps_norm = tps.map(|t| ty::normalize_ty(tcx, t));\n     @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n \n@@ -38,7 +38,7 @@ fn hash_nominal_id(&&ri: nominal_id) -> uint {\n     h += ri.did.crate as uint;\n     h *= 33u;\n     h += ri.did.node as uint;\n-    for vec::each(ri.tps) {|t|\n+    for vec::each(ri.tps) |t| {\n         h *= 33u;\n         h += ty::type_id(t);\n     }\n@@ -49,7 +49,7 @@ fn eq_nominal_id(&&mi: nominal_id, &&ni: nominal_id) -> bool {\n     if mi.did != ni.did {\n         false\n     } else {\n-        do vec::all2(mi.tps, ni.tps) { |m_tp, n_tp|\n+        do vec::all2(mi.tps, ni.tps) |m_tp, n_tp| {\n             ty::type_id(m_tp) == ty::type_id(n_tp)\n         }\n     }\n@@ -101,7 +101,7 @@ fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n     let llglobal =\n         str::as_c_str(name,\n-                    {|buf|\n+                      |buf| {\n                         lib::llvm::llvm::LLVMAddGlobal(ccx.llmod,\n                                                        val_ty(llval), buf)\n                     });\n@@ -137,7 +137,7 @@ enum enum_kind {\n \n fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n     let variants = ty::enum_variants(ccx.tcx, did);\n-    if vec::any(*variants, {|v| vec::len(v.args) > 0u}) {\n+    if vec::any(*variants, |v| vec::len(v.args) > 0u) {\n         if vec::len(*variants) == 1u { tk_newtype }\n         else { tk_complex }\n     } else {\n@@ -185,7 +185,7 @@ fn s_send_tydesc(_tcx: ty_ctxt) -> u8 {\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     let llshapetablesty = trans::common::T_named_struct(\"shapes\");\n-    let llshapetables = str::as_c_str(\"shapes\", {|buf|\n+    let llshapetables = str::as_c_str(\"shapes\", |buf| {\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n     });\n \n@@ -315,15 +315,15 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n \n       ty::ty_rec(fields) {\n         let mut s = ~[shape_struct], sub = ~[];\n-        for vec::each(fields) {|f|\n+        for vec::each(fields) |f| {\n             sub += shape_of(ccx, f.mt.ty);\n         }\n         add_substr(s, sub);\n         s\n       }\n       ty::ty_tup(elts) {\n         let mut s = ~[shape_struct], sub = ~[];\n-        for vec::each(elts) {|elt|\n+        for vec::each(elts) |elt| {\n             sub += shape_of(ccx, elt);\n         }\n         add_substr(s, sub);\n@@ -338,7 +338,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n             ~[shape_res]\n           }\n         else { ~[shape_struct] }, sub = ~[];\n-        do option::iter(m_dtor_did) {|dtor_did|\n+        do option::iter(m_dtor_did) |dtor_did| {\n           let ri = @{did: dtor_did, parent_id: some(did), tps: tps};\n           let id = interner::intern(ccx.shape_cx.resources, ri);\n           add_u16(s, id as u16);\n@@ -347,7 +347,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n           // hasn't changed since we started monomorphizing.\n           add_u16(s, 0_u16);\n         };\n-        for ty::class_items_as_mutable_fields(ccx.tcx, did, substs).each {|f|\n+        for ty::class_items_as_mutable_fields(ccx.tcx, did, substs).each |f| {\n            sub += shape_of(ccx, f.mt.ty);\n         }\n         add_substr(s, sub);\n@@ -376,7 +376,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n \n fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> ~[u8] {\n     let mut s = ~[];\n-    for vec::each(v.args) {|t| s += shape_of(ccx, t); }\n+    for vec::each(v.args) |t| { s += shape_of(ccx, t); }\n     ret s;\n }\n \n@@ -391,7 +391,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     while i < ccx.shape_cx.tag_order.len() {\n         let {did, substs} = ccx.shape_cx.tag_order[i];\n         let variants = @ty::substd_enum_variants(ccx.tcx, did, substs);\n-        do vec::iter(*variants) {|v|\n+        do vec::iter(*variants) |v| {\n             offsets += ~[vec::len(data) as u16];\n \n             let variant_shape = shape_of_variant(ccx, v);\n@@ -414,7 +414,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let data_sz = vec::len(data) as u16;\n \n     let mut inf_sz = 0u16;\n-    for enum_variants.each { |variants|\n+    for enum_variants.each |variants| {\n         let num_variants = vec::len(*variants) as u16;\n         add_u16(header, header_sz + inf_sz);\n         inf_sz += 2u16 * (num_variants + 2u16) + 3u16;\n@@ -426,7 +426,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n     let mut lv_table = ~[];\n     let mut i = 0u;\n-    for enum_variants.each { |variants|\n+    for enum_variants.each |variants| {\n         add_u16(inf, vec::len(*variants) as u16);\n \n         // Construct the largest-variants table.\n@@ -435,11 +435,11 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n         let lv = largest_variants(ccx, variants);\n         add_u16(lv_table, vec::len(lv) as u16);\n-        for vec::each(lv) {|v| add_u16(lv_table, v as u16); }\n+        for vec::each(lv) |v| { add_u16(lv_table, v as u16); }\n \n         // Determine whether the enum has dynamic size.\n-        assert !vec::any(*variants, {|v|\n-            vec::any(v.args, {|t| ty::type_has_params(t)})\n+        assert !vec::any(*variants, |v| {\n+            vec::any(v.args, |t| ty::type_has_params(t))\n         });\n \n         // If we can, write in the static size and alignment of the enum.\n@@ -451,7 +451,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         inf += ~[size_align.align];\n \n         // Now write in the offset of each variant.\n-        for vec::each(*variants) {|_v|\n+        for vec::each(*variants) |_v| {\n             add_u16(inf, header_sz + inf_sz + offsets[i]);\n             i += 1u;\n         }\n@@ -478,10 +478,10 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         // variant that contains (T,T) must be as least as large as\n         // any variant that contains just T.\n         let mut ranges = ~[];\n-        for vec::each(*variants) {|variant|\n+        for vec::each(*variants) |variant| {\n             let mut bounded = true;\n             let mut min_size = 0u, min_align = 0u;\n-            for vec::each(variant.args) {|elem_t|\n+            for vec::each(variant.args) |elem_t| {\n                 if ty::type_has_params(elem_t) {\n                     // NB: We could do better here; this causes us to\n                     // conservatively assume that (int, T) has minimum size 0,\n@@ -501,7 +501,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n         // Initialize the candidate set to contain all variants.\n         let mut candidates = ~[mut];\n-        for vec::each(*variants) {|_v| candidates += ~[mut true]; }\n+        for vec::each(*variants) |_v| { candidates += ~[mut true]; }\n \n         // Do a pairwise comparison among all variants still in the\n         // candidate set.  Throw out any variant that we know has size\n@@ -548,10 +548,10 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         -> size_align {\n         let mut max_size = 0u16;\n         let mut max_align = 1u8;\n-        for vec::each(largest_variants) {|vid|\n+        for vec::each(largest_variants) |vid| {\n             // We increment a \"virtual data pointer\" to compute the size.\n             let mut lltys = ~[];\n-            for vec::each(variants[vid].args) {|typ|\n+            for vec::each(variants[vid].args) |typ| {\n                 lltys += ~[type_of::type_of(ccx, typ)];\n             }\n \n@@ -580,10 +580,10 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let mut dtors = ~[];\n     let len = interner::len(ccx.shape_cx.resources);\n-    for uint::range(0u, len) {|i|\n+    for uint::range(0u, len) |i| {\n         let ri = interner::get(ccx.shape_cx.resources, i);\n-        for ri.tps.each() {|s| assert !ty::type_has_params(s); }\n-        do option::iter(ri.parent_id) {|id|\n+        for ri.tps.each() |s| { assert !ty::type_has_params(s); }\n+        do option::iter(ri.parent_id) |id| {\n             dtors += ~[trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n         }\n     }\n@@ -694,7 +694,7 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n         // Compute max(variant sizes).\n         let mut max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n-        for vec::each(*variants) {|variant|\n+        for vec::each(*variants) |variant| {\n             let tup_ty = simplify_type(cx.tcx,\n                                        ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n@@ -742,7 +742,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n                                         ty::mk_u8(tcx),\n                                         mutbl: ast::m_mutbl}}] }\n                 else { ~[] }) +\n-              do ty::lookup_class_fields(tcx, did).map {|f|\n+                do ty::lookup_class_fields(tcx, did).map |f| {\n                  let t = ty::lookup_field_type(tcx, did, f.id, substs);\n                  {ident: f.ident,\n                   mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n@@ -752,5 +752,5 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           _ { typ }\n         }\n     }\n-    ty::fold_ty(tcx, typ, {|t| simplifier(tcx, t) })\n+    ty::fold_ty(tcx, typ, |t| simplifier(tcx, t))\n }"}, {"sha": "a15bb2938139b286f8bf79e6f46438a42e5c329e", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -124,7 +124,7 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if dest == base::ignore {\n-        for vec::each(args) {|arg|\n+        for vec::each(args) |arg| {\n             bcx = base::trans_expr(bcx, arg, base::ignore);\n         }\n         ret bcx;\n@@ -192,15 +192,15 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n     #debug(\"trans_evec: v: %s, dataptr: %s\",\n            val_str(ccx.tn, val),\n            val_str(ccx.tn, dataptr));\n-    for vec::each(args) {|e|\n+    for vec::each(args) |e| {\n         let lleltptr = InBoundsGEP(bcx, dataptr, ~[C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         vec::push(temp_cleanups, lleltptr);\n         i += 1u;\n     }\n \n-    for vec::each(temp_cleanups) {|cln| revoke_clean(bcx, cln); }\n+    for vec::each(temp_cleanups) |cln| { revoke_clean(bcx, cln); }\n \n     alt vst {\n       ast::vstore_fixed(_) {\n@@ -335,7 +335,7 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n-    iter_vec_uniq(bcx, rhs, vec_ty, rfill, {|bcx, addr, _ty|\n+    iter_vec_uniq(bcx, rhs, vec_ty, rfill, |bcx, addr, _ty| {\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n@@ -353,14 +353,14 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n     let elt_llty = type_of::type_of(ccx, elt_ty);\n     let elt_sz = shape::llsize_of(ccx, elt_llty);\n     let scratch = base::alloca(bcx, elt_llty);\n-    for vec::each(vals) {|val|\n+    for vec::each(vals) |val| {\n         bcx = base::trans_expr_save_in(bcx, val, scratch);\n         let vptr = get_bodyptr(bcx, Load(bcx, vptrptr));\n         let old_fill = get_fill(bcx, vptr);\n         let new_fill = Add(bcx, old_fill, elt_sz);\n         let do_grow = ICmp(bcx, lib::llvm::IntUGT, new_fill,\n                            get_alloc(bcx, vptr));\n-        bcx = do base::with_cond(bcx, do_grow) {|bcx|\n+        bcx = do base::with_cond(bcx, do_grow) |bcx| {\n             let pt = PointerCast(bcx, vptrptr,\n                                  T_ptr(T_ptr(T_i8())));\n             Call(bcx, ccx.upcalls.vec_grow, ~[pt, new_fill]);"}, {"sha": "3a34e67f010f26b83ef7ffc6702d9cacb7212fab", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -16,7 +16,7 @@ export type_of_non_gc_box;\n \n fn type_of_explicit_args(cx: @crate_ctxt,\n                          inputs: ~[ty::arg]) -> ~[TypeRef] {\n-    do vec::map(inputs) {|arg|\n+    do vec::map(inputs) |arg| {\n         let arg_ty = arg.ty;\n         let llty = type_of(cx, arg_ty);\n         alt ty::resolved_mode(cx.tcx, arg.mode) {\n@@ -135,7 +135,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n \n           ty::ty_rec(fields) {\n             let mut tys: ~[TypeRef] = ~[];\n-            for vec::each(fields) {|f|\n+            for vec::each(fields) |f| {\n                 let mt_ty = f.mt.ty;\n                 vec::push(tys, type_of(cx, mt_ty));\n             }\n@@ -146,7 +146,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           ty::ty_type { T_ptr(cx.tydesc_type) }\n           ty::ty_tup(elts) {\n             let mut tys = ~[];\n-            for vec::each(elts) {|elt|\n+            for vec::each(elts) |elt| {\n                 vec::push(tys, type_of(cx, elt));\n             }\n             T_struct(tys)\n@@ -175,7 +175,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           ty::ty_class(did, ts) {\n             // Only instance vars are record fields at runtime.\n             let fields = lookup_class_fields(cx.tcx, did);\n-            let mut tys = do vec::map(fields) {|f|\n+            let mut tys = do vec::map(fields) |f| {\n                 let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n                 type_of(cx, t)\n             };"}, {"sha": "15d69df36b1b0e162c3ad0bf235af040e261470e", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -47,7 +47,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n     alt ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).struct {\n       ty::ty_fn({inputs, _}) {\n-        for vec::each(inputs) {|arg|\n+        for vec::each(inputs) |arg| {\n             if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n         }\n       }\n@@ -70,7 +70,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         handle_body(cx, body);\n       }\n       ast_map::node_variant(_, _, _) {\n-        for uint::range(0u, n_tps) {|n| cx.uses[n] |= use_repr;}\n+        for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_repr;}\n       }\n       ast_map::node_foreign_item(i@@{node: foreign_item_fn(_, _), _},\n                                  abi, _) {\n@@ -89,7 +89,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n               }\n               \"forget\" | \"addr_of\" { 0u }\n             };\n-            for uint::range(0u, n_tps) {|n| cx.uses[n] |= flags;}\n+            for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n       }\n       ast_map::node_ctor(_, _, ctor, _, _){\n@@ -108,13 +108,13 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n fn type_needs(cx: ctx, use: uint, ty: ty::t) {\n     let mut done = true;\n     // Optimization -- don't descend type if all params already have this use\n-    for vec::each(cx.uses) {|u| if u & use != use { done = false } }\n+    for vec::each(cx.uses) |u| { if u & use != use { done = false } }\n     if !done { type_needs_inner(cx, use, ty, @nil); }\n }\n \n fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n                     enums_seen: @list<def_id>) {\n-    do ty::maybe_walk_ty(ty) {|ty|\n+    do ty::maybe_walk_ty(ty) |ty| {\n         if ty::type_has_params(ty) {\n             alt ty::get(ty).struct {\n                 /*\n@@ -126,10 +126,10 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n                | ty::ty_iface(_, _) { false }\n               ty::ty_enum(did, substs) {\n-                if option::is_none(list::find(enums_seen, {|id| id == did})) {\n+                if option::is_none(list::find(enums_seen, |id| id == did)) {\n                     let seen = @cons(did, enums_seen);\n-                    for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) {|v|\n-                        for vec::each(v.args) {|aty|\n+                    for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n+                        for vec::each(v.args) |aty| {\n                             let t = ty::subst(cx.ccx.tcx, substs, aty);\n                             type_needs_inner(cx, use, t, seen);\n                         }\n@@ -181,18 +181,19 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_path(_) {\n-        do cx.ccx.tcx.node_type_substs.find(e.id).iter {|ts|\n+        do cx.ccx.tcx.node_type_substs.find(e.id).iter |ts| {\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(e.id));\n-            vec::iter2(type_uses_for(cx.ccx, id, ts.len()), ts, {|uses, subst|\n-                type_needs(cx, uses, subst)\n-            })\n+            vec::iter2(type_uses_for(cx.ccx, id, ts.len()), ts,\n+                       |uses, subst| {\n+                           type_needs(cx, uses, subst)\n+                       })\n         }\n       }\n       expr_fn(*) | expr_fn_block(*) {\n         alt ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n           proto_bare | proto_any | proto_uniq {}\n           proto_box | proto_block {\n-            for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) {|fv|\n+            for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) |fv| {\n                 let node_id = ast_util::def_id_of_def(fv.def).node;\n                 node_type_needs(cx, use_repr, node_id);\n             }\n@@ -209,12 +210,12 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n-        do option::iter(cx.ccx.maps.method_map.find(e.id)) {|mth|\n+        do option::iter(cx.ccx.maps.method_map.find(e.id)) |mth| {\n             alt mth.origin {\n               typeck::method_static(did) {\n-                do option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) {|ts|\n+                do option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) |ts| {\n                     do vec::iter2(type_uses_for(cx.ccx, did, ts.len()), ts)\n-                        {|uses, subst| type_needs(cx, uses, subst)}\n+                        |uses, subst| { type_needs(cx, uses, subst)}\n                 }\n               }\n               typeck::method_param({param_num: param, _}) {\n@@ -231,7 +232,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         node_type_needs(cx, use_repr, v.id);\n       }\n       expr_call(f, _, _) {\n-        vec::iter(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)), {|a|\n+        vec::iter(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)), |a| {\n             alt a.mode {\n               expl(by_move) | expl(by_copy) | expl(by_val) {\n                 type_needs(cx, use_repr, a.ty);\n@@ -251,25 +252,25 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n \n fn handle_body(cx: ctx, body: blk) {\n     let v = visit::mk_vt(@{\n-        visit_expr: {|e, cx, v|\n+        visit_expr: |e, cx, v| {\n             visit::visit_expr(e, cx, v);\n             mark_for_expr(cx, e);\n         },\n-        visit_local: {|l, cx, v|\n+        visit_local: |l, cx, v| {\n             visit::visit_local(l, cx, v);\n             node_type_needs(cx, use_repr, l.node.id);\n         },\n-        visit_pat: {|p, cx, v|\n+        visit_pat: |p, cx, v| {\n             visit::visit_pat(p, cx, v);\n             node_type_needs(cx, use_repr, p.id);\n         },\n-        visit_block: {|b, cx, v|\n+        visit_block: |b, cx, v| {\n             visit::visit_block(b, cx, v);\n-            do option::iter(b.node.expr) {|e|\n+            do option::iter(b.node.expr) |e| {\n                 node_type_needs(cx, use_repr, e.id);\n             }\n         },\n-        visit_item: {|_i, _cx, _v|}\n+        visit_item: |_i, _cx, _v| { }\n         with *visit::default_visitor()\n     });\n     v.visit_block(body, cx, v);"}, {"sha": "992ed26ee733190e74ff39a8f38ca9ee011f9651", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -10,7 +10,7 @@ export make_free_glue, autoderef, duplicate;\n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n-    do with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, vptr)) |bcx| {\n         let content_ty = content_ty(t);\n         let body_ptr = opaque_box_body(bcx, content_ty, vptr);\n         let bcx = drop_ty(bcx, body_ptr, content_ty);"}, {"sha": "e6beae9e014423ad1b7d29d5e847419fbdfe1bd3", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -29,17 +29,17 @@ fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mut ~[node_id]) {\n \n fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut ~[node_id]) {\n     let collect_ids =\n-        visit::mk_simple_visitor(@{visit_expr: {|a|collect_ids_expr(a, rs)},\n-                                   visit_block: {|a|collect_ids_block(a, rs)},\n-                                   visit_stmt: {|a|collect_ids_stmt(a, rs)},\n-                                   visit_local: {|a|\n-                                       collect_ids_local(tcx, a, rs)}\n+        visit::mk_simple_visitor(@{visit_expr: |a| collect_ids_expr(a, rs),\n+                                   visit_block: |a| collect_ids_block(a, rs),\n+                                   visit_stmt: |a| collect_ids_stmt(a, rs),\n+                                   visit_local: |a|\n+                                       collect_ids_local(tcx, a, rs)\n                                    with *visit::default_simple_visitor()});\n     collect_ids.visit_block(body, (), collect_ids);\n }\n \n fn init_vecs(ccx: crate_ctxt, node_ids: ~[node_id], len: uint) {\n-    for node_ids.each {|i|\n+    for node_ids.each |i| {\n         log(debug, int::str(i) + \" |-> \" + uint::str(len));\n         add_node(ccx, i, empty_ann(len));\n     }\n@@ -61,7 +61,7 @@ fn annotate_in_fn(ccx: crate_ctxt, _fk: visit::fn_kind, _decl: fn_decl,\n fn annotate_crate(ccx: crate_ctxt, crate: crate) {\n     let do_ann =\n         visit::mk_simple_visitor(\n-            @{visit_fn: {|a,b,c,d,e|annotate_in_fn(ccx, a, b, c, d, e)}\n+            @{visit_fn: |a,b,c,d,e| annotate_in_fn(ccx, a, b, c, d, e)\n               with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), do_ann);\n }"}, {"sha": "d50e445482a6674c5213afb1bb41a2d5fd2e5422", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -37,7 +37,7 @@ fn def_id_to_str(d: def_id) -> str {\n fn comma_str(args: ~[@constr_arg_use]) -> str {\n     let mut rslt = \"\";\n     let mut comma = false;\n-    for args.each {|a|\n+    for args.each |a| {\n         if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n           carg_base { rslt += \"*\"; }\n@@ -58,7 +58,7 @@ fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> str {\n fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> str {\n     let mut s = \"\";\n     let mut comma = false;\n-    for constraints(fcx).each {|p|\n+    for constraints(fcx).each |p| {\n         alt tritv_get(v, p.bit_num) {\n           dont_care { }\n           tt {\n@@ -79,7 +79,7 @@ fn log_tritv(fcx: fn_ctxt, v: tritv::t) {\n fn first_difference_string(fcx: fn_ctxt, expected: tritv::t, actual: tritv::t)\n    -> str {\n     let mut s = \"\";\n-    for constraints(fcx).each {|c|\n+    for constraints(fcx).each |c| {\n         if tritv_get(expected, c.bit_num) == ttrue &&\n                tritv_get(actual, c.bit_num) != ttrue {\n             s = constraint_to_str(fcx.ccx.tcx, c.c);\n@@ -95,7 +95,7 @@ fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) {\n \n fn tos(v: ~[uint]) -> str {\n     let mut rslt = \"\";\n-    for v.each {|i|\n+    for v.each |i| {\n         if i == 0u {\n             rslt += \"0\";\n         } else if i == 1u { rslt += \"1\"; } else { rslt += \"?\"; }\n@@ -473,7 +473,7 @@ fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option<def> {\n \n fn norm_a_constraint(id: def_id, c: constraint) -> ~[norm_constraint] {\n     let mut rslt: ~[norm_constraint] = ~[];\n-    for (*c.descs).each {|pd|\n+    for (*c.descs).each |pd| {\n         vec::push(rslt,\n                   {bit_num: pd.node.bit_num,\n                    c: respan(pd.span, {path: c.path,\n@@ -488,7 +488,7 @@ fn norm_a_constraint(id: def_id, c: constraint) -> ~[norm_constraint] {\n // non-exhaustive match in trans.\n fn constraints(fcx: fn_ctxt) -> ~[norm_constraint] {\n     let mut rslt: ~[norm_constraint] = ~[];\n-    for fcx.enclosing.constrs.each {|key, val|\n+    for fcx.enclosing.constrs.each |key, val| {\n         vec::push_all(rslt, norm_a_constraint(key, val));\n     };\n     ret rslt;\n@@ -500,7 +500,7 @@ fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n               occ: ~[@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\",\n            constr_args_to_str(fn@(i: inst) -> str { ret *i.ident; }, occ));\n-    for (*occs).each {|pd|\n+    for (*occs).each |pd| {\n         log(debug,\n                  \"match_args: candidate \" + pred_args_to_str(pd));\n         fn eq(p: inst, q: inst) -> bool { ret p.node == q.node; }\n@@ -551,9 +551,9 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n \n fn exprs_to_constr_args(tcx: ty::ctxt,\n                         args: ~[@expr]) -> ~[@constr_arg_use] {\n-    let f = {|a|expr_to_constr_arg(tcx, a)};\n+    let f = |a| expr_to_constr_arg(tcx, a);\n     let mut rslt: ~[@constr_arg_use] = ~[];\n-    for args.each {|e| vec::push(rslt, f(e)); }\n+    for args.each |e| { vec::push(rslt, f(e)); }\n     rslt\n }\n \n@@ -588,7 +588,7 @@ fn pred_args_to_str(p: pred_args) -> str {\n fn substitute_constr_args(cx: ty::ctxt, actuals: ~[@expr], c: @ty::constr) ->\n    tsconstr {\n     let mut rslt: ~[@constr_arg_use] = ~[];\n-    for c.node.args.each {|a|\n+    for c.node.args.each |a| {\n         vec::push(rslt, substitute_arg(cx, actuals, a));\n     }\n     ret {path: c.node.path,\n@@ -616,7 +616,7 @@ fn pred_args_matches(pattern: ~[constr_arg_general_<inst>],\n                      desc: pred_args) ->\n    bool {\n     let mut i = 0u;\n-    for desc.node.args.each {|c|\n+    for desc.node.args.each |c| {\n         let n = pattern[i];\n         alt c.node {\n           carg_ident(p) {\n@@ -641,7 +641,7 @@ fn pred_args_matches(pattern: ~[constr_arg_general_<inst>],\n fn find_instance_(pattern: ~[constr_arg_general_<inst>],\n                   descs: ~[pred_args]) ->\n    option<uint> {\n-    for descs.each {|d|\n+    for descs.each |d| {\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n     ret none;\n@@ -661,9 +661,9 @@ fn find_instances(_fcx: fn_ctxt, subst: subst,\n \n     if vec::len(subst) == 0u { ret ~[]; }\n     let mut res = ~[];\n-    do (*c.descs).swap { |v|\n+    do (*c.descs).swap |v| {\n         let v <- vec::from_mut(v);\n-        for v.each { |d|\n+        for v.each |d| {\n             if args_mention(d.node.args, find_in_subst_bool, subst) {\n                 let old_bit_num = d.node.bit_num;\n                 let newv = replace(subst, d);\n@@ -679,7 +679,7 @@ fn find_instances(_fcx: fn_ctxt, subst: subst,\n }\n \n fn find_in_subst(id: node_id, s: subst) -> option<inst> {\n-    for s.each {|p|\n+    for s.each |p| {\n         if id == p.from.node { ret some(p.to); }\n     }\n     ret none;\n@@ -691,7 +691,7 @@ fn find_in_subst_bool(s: subst, id: node_id) -> bool {\n \n fn insts_to_str(stuff: ~[constr_arg_general_<inst>]) -> str {\n     let mut rslt = \"<\";\n-    for stuff.each {|i|\n+    for stuff.each |i| {\n         rslt +=\n             \" \" +\n                 alt i {\n@@ -706,7 +706,7 @@ fn insts_to_str(stuff: ~[constr_arg_general_<inst>]) -> str {\n \n fn replace(subst: subst, d: pred_args) -> ~[constr_arg_general_<inst>] {\n     let mut rslt: ~[constr_arg_general_<inst>] = ~[];\n-    for d.node.args.each {|c|\n+    for d.node.args.each |c| {\n         alt c.node {\n           carg_ident(p) {\n             alt find_in_subst(p.node, subst) {\n@@ -727,7 +727,7 @@ enum if_ty { if_check, plain_if, }\n \n fn for_constraints_mentioning(fcx: fn_ctxt, id: node_id,\n                               f: fn(norm_constraint)) {\n-    for constraints(fcx).each {|c|\n+    for constraints(fcx).each |c| {\n         if constraint_mentions(fcx, c, id) { f(c); }\n     };\n }\n@@ -805,11 +805,11 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n     }\n \n \n-    for fcx.enclosing.constrs.each_value {|val|\n+    for fcx.enclosing.constrs.each_value |val| {\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n         let insts = find_instances(fcx, subst, val);\n-        for insts.each {|p|\n+        for insts.each |p| {\n             if bitvectors::promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n@@ -821,8 +821,8 @@ fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    do option::iter(d) {|d_id|\n-        do for_constraints_mentioning(fcx, d_id) {|c|\n+    do option::iter(d) |d_id| {\n+        do for_constraints_mentioning(fcx, d_id) |c| {\n                 #debug(\"clearing constraint %u %s\",\n                        c.bit_num,\n                        constraint_to_str(fcx.ccx.tcx, c.c));\n@@ -838,16 +838,16 @@ fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     let mut changed = false;\n-    do option::iter(d) {|d_id|\n-        do for_constraints_mentioning(fcx, d_id) {|c|\n+    do option::iter(d) |d_id| {\n+        do for_constraints_mentioning(fcx, d_id) |c| {\n                 changed |= clear_in_poststate_(c.bit_num, p);\n         }\n     }\n     ret changed;\n }\n \n fn any_eq(v: ~[node_id], d: node_id) -> bool {\n-    for v.each {|i| if i == d { ret true; } }\n+    for v.each |i| { if i == d { ret true; } }\n     false\n }\n \n@@ -860,7 +860,7 @@ fn args_mention<T>(args: ~[@constr_arg_use],\n                    q: fn(~[T], node_id) -> bool,\n                    s: ~[T]) -> bool {\n \n-    for args.each {|a|\n+    for args.each |a| {\n         alt a.node { carg_ident(p1) { if q(s, p1.node) { ret true; } } _ { } }\n     }\n     ret false;\n@@ -886,7 +886,7 @@ fn args_to_constr_args(tcx: ty::ctxt, args: ~[arg],\n     -> ~[@constr_arg_use] {\n     let mut actuals: ~[@constr_arg_use] = ~[];\n     let num_args = vec::len(args);\n-    for indices.each {|a|\n+    for indices.each |a| {\n         vec::push(\n             actuals,\n             @respan(a.span,\n@@ -926,15 +926,15 @@ type binding = {lhs: ~[dest], rhs: option<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let mut lhs = ~[];\n-    do pat_bindings(tcx.def_map, loc.node.pat) {|p_id, _s, name|\n+    do pat_bindings(tcx.def_map, loc.node.pat) |p_id, _s, name| {\n       vec::push(lhs, local_dest({ident: path_to_ident(name), node: p_id}));\n     };\n     {lhs: lhs, rhs: loc.node.init}\n }\n \n fn locals_to_bindings(tcx: ty::ctxt, locals: ~[@local]) -> ~[binding] {\n     let mut rslt = ~[];\n-    for locals.each {|loc| vec::push(rslt, local_to_bindings(tcx, loc)); }\n+    for locals.each |loc| { vec::push(rslt, local_to_bindings(tcx, loc)); }\n     ret rslt;\n }\n \n@@ -944,7 +944,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n     alt ty::get(ty).struct {\n       ty::ty_fn({inputs: args, _}) {\n         let mut modes = ~[];\n-        for args.each {|arg| vec::push(modes, arg.mode); }\n+        for args.each |arg| { vec::push(modes, arg.mode); }\n         ret modes;\n       }\n       _ {\n@@ -956,7 +956,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n }\n \n fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> ~[init_op] {\n-    do vec::map(callee_modes(fcx, callee)) {|m|\n+    do vec::map(callee_modes(fcx, callee)) |m| {\n         alt ty::resolved_mode(fcx.ccx.tcx, m) {\n           by_move { init_move }\n           by_copy | by_ref | by_val | by_mutbl_ref { init_assign }\n@@ -967,7 +967,7 @@ fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> ~[init_op] {\n fn arg_bindings(ops: ~[init_op], es: ~[@expr]) -> ~[binding] {\n     let mut bindings: ~[binding] = ~[];\n     let mut i = 0u;\n-    for ops.each {|op|\n+    for ops.each |op| {\n         vec::push(bindings,\n                   {lhs: ~[call], rhs: some({op: op, expr: es[i]})});\n         i += 1u;"}, {"sha": "83151d8627a24c230a0bb650ef8503eeafccaedc", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -49,7 +49,7 @@ fn seq_postconds(fcx: fn_ctxt, ps: ~[postcond]) -> postcond {\n     let sz = vec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps[0]);\n-        vec::iter_between(ps, 1u, sz, {|p| seq_tritv(prev, p); });\n+        vec::iter_between(ps, 1u, sz, |p| seq_tritv(prev, p) );\n         ret prev;\n     } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n }"}, {"sha": "b5e9c5d32c888bfa6ba094c1bd046536f04b8210", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -80,7 +80,7 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n     let visitor = visit::mk_vt(\n         @{visit_stmt: check_states_stmt,\n           visit_expr: check_states_expr,\n-          visit_fn: {|a,b,c,d,e,f,g|\n+          visit_fn: |a,b,c,d,e,f,g| {\n               do_nothing::<fn_ctxt>(a, b, c, d, e, f, g)\n           }\n           with *visit::default_visitor::<fn_ctxt>()});"}, {"sha": "6c5eebbcb0b445638e5f77935d8bc97eb6232bc5", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -22,7 +22,7 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n       expr_call(operator, operands, _) {\n-        for constraints_expr(cx.tcx, operator).each {|c|\n+        for constraints_expr(cx.tcx, operator).each |c| {\n             let ct: sp_constr =\n                 respan(c.span,\n                        aux::substitute_constr_args(cx.tcx, operands, c));\n@@ -126,7 +126,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n         }\n         /* if this function has any constraints, instantiate them to the\n         argument names and add them */\n-        for f_decl.constraints.each {|c|\n+        for f_decl.constraints.each |c| {\n             let sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n             next = add_constraint(cx.tcx, sc, next, res_map);\n         }\n@@ -150,9 +150,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n fn mk_f_to_fn_info(ccx: crate_ctxt, c: @crate) {\n     let visitor =\n         visit::mk_simple_visitor(@{\n-            visit_fn: {|a,b,c,d,e|\n-                mk_fn_info(ccx, a, b, c, d, e)\n-            }\n+            visit_fn: |a,b,c,d,e| mk_fn_info(ccx, a, b, c, d, e)\n             with *visit::default_simple_visitor()});\n     visit::visit_crate(*c, (), visitor);\n }"}, {"sha": "197ed4b310848854c2b51aae4b73e13ba1a73584", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -53,7 +53,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n           fail \"find_pre_post_item: shouldn't be called on item_class\";\n       }\n       item_impl(_, _, _, _, ms) {\n-        for ms.each {|m| find_pre_post_method(ccx, m); }\n+        for ms.each |m| { find_pre_post_method(ccx, m); }\n       }\n     }\n }\n@@ -68,12 +68,12 @@ fn find_pre_post_exprs(fcx: fn_ctxt, args: ~[@expr], id: node_id) {\n         #debug[\"find_pre_post_exprs: oper = %s\", expr_to_str(args[0])];\n     }\n     fn do_one(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n-    for args.each {|e| do_one(fcx, e); }\n+    for args.each |e| { do_one(fcx, e); }\n \n     fn get_pp(ccx: crate_ctxt, &&e: @expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    let pps = vec::map(args, {|a|get_pp(fcx.ccx, a)});\n+    let pps = vec::map(args, |a| get_pp(fcx.ccx, a) );\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n                      seq_postconds(fcx, vec::map(pps, get_post)));\n@@ -230,7 +230,7 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n \n fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: ~[mode],\n                         operands: ~[@expr]) {\n-    do vec::iteri(modes) {|i,mode|\n+    do vec::iteri(modes) |i,mode| {\n         alt ty::resolved_mode(fcx.ccx.tcx, mode) {\n           by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n           by_ref | by_val | by_mutbl_ref | by_copy { }\n@@ -259,7 +259,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n \n         find_pre_post_exprs(fcx, args, e.id);\n         /* see if the call has any constraints on its type */\n-        for constraints_expr(fcx.ccx.tcx, operator).each {|c|\n+        for constraints_expr(fcx.ccx.tcx, operator).each |c| {\n             let i =\n                 bit_num(fcx, substitute_constr_args(fcx.ccx.tcx, args, c));\n             require(i, expr_pp(fcx.ccx, e));\n@@ -295,12 +295,12 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n         find_pre_post_expr_fn_upvars(fcx, e);\n \n-        for (*cap_clause).each { |cap_item|\n+        for (*cap_clause).each |cap_item| {\n             let d = local_node_id_to_local_def_id(fcx, cap_item.id);\n-            option::iter(d, { |id| use_var(fcx, id) });\n+            option::iter(d, |id| use_var(fcx, id) );\n         }\n \n-        for (*cap_clause).each { |cap_item|\n+        for (*cap_clause).each |cap_item| {\n             if cap_item.is_move {\n                 log(debug, (\"forget_in_postcond: \", cap_item));\n                 forget_in_postcond(fcx, e.id, cap_item.id);\n@@ -398,7 +398,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n         let mut alt_pps = ~[];\n-        for alts.each {|a| vec::push(alt_pps, do_an_alt(fcx, a)); }\n+        for alts.each |a| { vec::push(alt_pps, do_an_alt(fcx, a)); }\n         fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n                       &&next: pre_and_post) -> pre_and_post {\n             union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n@@ -409,7 +409,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         let e_pp =\n             {precondition: empty_prestate(num_local_vars),\n              postcondition: false_postcond(num_local_vars)};\n-        let g = {|a,b|combine_pp(antec_pp, fcx, a, b)};\n+        let g = |a,b| combine_pp(antec_pp, fcx, a, b);\n         let alts_overall_pp =\n             vec::foldl(e_pp, alt_pps, g);\n         set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n@@ -457,14 +457,14 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n         alt adecl.node {\n           decl_local(alocals) {\n             let prev_pp = empty_pre_post(num_constraints(fcx.enclosing));\n-            for alocals.each {|alocal|\n+            for alocals.each |alocal| {\n                 alt alocal.node.init {\n                   some(an_init) {\n                     /* LHS always becomes initialized,\n                      whether or not this is a move */\n                     find_pre_post_expr(fcx, an_init.expr);\n                     do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n-                        {|p_id, _s, _n|\n+                        |p_id, _s, _n| {\n                         copy_pre_post(fcx.ccx, p_id, an_init.expr);\n                     };\n                     /* Inherit ann from initializer, and add var being\n@@ -478,7 +478,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     }\n \n                     do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n-                        {|p_id, _s, n|\n+                        |p_id, _s, n| {\n                         let ident = path_to_ident(n);\n                         alt p {\n                           some(p) {\n@@ -506,7 +506,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                   }\n                   none {\n                     do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n-                        {|p_id, _s, _n|\n+                        |p_id, _s, _n| {\n                         clear_pp(node_id_to_ts_ann(fcx.ccx, p_id).conditions);\n                     };\n                     clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n@@ -549,13 +549,13 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     fn do_one_(fcx: fn_ctxt, s: @stmt) {\n         find_pre_post_stmt(fcx, *s);\n     }\n-    for b.node.stmts.each {|s| do_one_(fcx, s); }\n+    for b.node.stmts.each |s| { do_one_(fcx, s); }\n     fn do_inner_(fcx: fn_ctxt, &&e: @expr) { find_pre_post_expr(fcx, e); }\n-    let do_inner = {|a|do_inner_(fcx, a)};\n+    let do_inner = |a| do_inner_(fcx, a);\n     option::map::<@expr, ()>(b.node.expr, do_inner);\n \n     let mut pps: ~[pre_and_post] = ~[];\n-    for b.node.stmts.each {|s| vec::push(pps, stmt_pp(fcx.ccx, *s)); }\n+    for b.node.stmts.each |s| { vec::push(pps, stmt_pp(fcx.ccx, *s)); }\n     alt b.node.expr {\n       none {/* no-op */ }\n       some(e) { vec::push(pps, expr_pp(fcx.ccx, e)); }\n@@ -564,7 +564,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     let block_precond = seq_preconds(fcx, pps);\n \n     let mut postconds = ~[];\n-    for pps.each {|pp| vec::push(postconds, get_post(pp)); }\n+    for pps.each |pp| { vec::push(postconds, get_post(pp)); }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */"}, {"sha": "adf1efc85626f0981a0d558e6eb885c08b806504", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -58,14 +58,14 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: ~[binding]) ->\n    {changed: bool, post: poststate} {\n     let mut changed = false;\n     let mut post = tritv_clone(pres);\n-    for bindings.each {|b|\n+    for bindings.each |b| {\n         alt b.rhs {\n           some(an_init) {\n             // an expression, with or without a destination\n             changed |=\n                 find_pre_post_state_expr(fcx, post, an_init.expr) || changed;\n             post = tritv_clone(expr_poststate(fcx.ccx, an_init.expr));\n-            for b.lhs.each {|d|\n+            for b.lhs.each |d| {\n                 alt an_init.expr.node {\n                   expr_path(p) {\n                     handle_move_or_copy(fcx, post, p, an_init.expr.id, d,\n@@ -271,7 +271,7 @@ fn find_pre_post_state_cap_clause(fcx: fn_ctxt, e_id: node_id,\n     let ccx = fcx.ccx;\n     let pres_changed = set_prestate_ann(ccx, e_id, pres);\n     let post = tritv_clone(pres);\n-    for (*cap_clause).each { |cap_item|\n+    for (*cap_clause).each |cap_item| {\n         if cap_item.is_move {\n             forget_in_poststate(fcx, post, cap_item.id);\n         }\n@@ -332,10 +332,11 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n \n         let base_pres = alt vec::last_opt(exs) { none { pres }\n                           some(f) { expr_poststate(fcx.ccx, f) }};\n-        option::iter(maybe_base, {|base|\n+        option::iter(maybe_base, |base| {\n             changed |= find_pre_post_state_expr(fcx, base_pres, base) |\n-              set_poststate_ann(fcx.ccx, e.id,\n-                                expr_poststate(fcx.ccx, base))});\n+                set_poststate_ann(fcx.ccx, e.id,\n+                                  expr_poststate(fcx.ccx, base))\n+        });\n         ret changed;\n       }\n       expr_tup(elts) {\n@@ -449,7 +450,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         let mut a_post;\n         if vec::len(alts) > 0u {\n             a_post = false_postcond(num_constrs);\n-            for alts.each {|an_alt|\n+            for alts.each |an_alt| {\n                 alt an_alt.guard {\n                   some(e) {\n                     changed |= find_pre_post_state_expr(fcx, e_post, e);\n@@ -483,8 +484,10 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         let post = false_postcond(num_constrs);\n         ret set_prestate_ann(fcx.ccx, e.id, pres) |\n                 set_poststate_ann(fcx.ccx, e.id, post) |\n-                option::map_default(maybe_fail_val, false, {|fail_val|\n-                        find_pre_post_state_expr(fcx, pres, fail_val)});\n+                option::map_default(\n+                    maybe_fail_val, false,\n+                    |fail_val|\n+                    find_pre_post_state_expr(fcx, pres, fail_val) );\n       }\n       expr_check(_, p) {\n         /* predicate p holds after this expression executes */\n@@ -563,7 +566,7 @@ fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n      initializes.  Then <pres> becomes the new poststate. */\n \n     let mut changed = false;\n-    for b.node.stmts.each {|s|\n+    for b.node.stmts.each |s| {\n         changed |= find_pre_post_state_stmt(fcx, pres, s);\n         pres = stmt_poststate(fcx.ccx, *s);\n     }\n@@ -591,7 +594,7 @@ fn find_pre_post_state_fn(fcx: fn_ctxt,\n \n     // Instantiate any constraints on the arguments so we can use them\n     let block_pre = block_prestate(fcx.ccx, f_body);\n-    for f_decl.constraints.each {|c|\n+    for f_decl.constraints.each |c| {\n         let tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f_decl.inputs, c);\n         set_in_prestate_constr(fcx, tsc, block_pre);\n     }"}, {"sha": "8e47c3abaf249c2b3c949dee1c512eef035c9bb2", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 105, "deletions": 108, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -458,7 +458,7 @@ impl of to_str::to_str for purity {\n \n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable();\n-    for vec::each(*bounds) {|bound|\n+    for vec::each(*bounds) |bound| {\n         alt bound {\n           bound_copy {\n             kind = raise_kind(kind, kind_implicitly_copyable());\n@@ -491,17 +491,17 @@ fn mk_rcache() -> creader_cache {\n }\n \n fn new_ty_hash<V: copy>() -> map::hashmap<t, V> {\n-    map::hashmap({|&&t: t| type_id(t)},\n-                    {|&&a: t, &&b: t| type_id(a) == type_id(b)})\n+    map::hashmap(|&&t: t| type_id(t),\n+                 |&&a: t, &&b: t| type_id(a) == type_id(b))\n }\n \n fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map,\n            region_map: middle::region::region_map) -> ctxt {\n-    let interner = map::hashmap({|&&k: intern_key|\n+    let interner = map::hashmap(|&&k: intern_key| {\n         hash_type_structure(k.struct) +\n             option::map_default(k.o_def_id, 0u, ast_util::hash_def)\n-    }, {|&&a, &&b| a == b});\n+    }, |&&a, &&b| a == b);\n     let vecs_implicitly_copyable =\n         get_warning_level(s.warning_settings.default_settings,\n                           vecs_not_implicitly_copyable) == ignore;\n@@ -557,8 +557,8 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n     }\n     fn sflags(substs: substs) -> uint {\n         let mut f = 0u;\n-        for substs.tps.each {|tt| f |= get(tt).flags; }\n-        substs.self_r.iter({ |r| f |= rflags(r) });\n+        for substs.tps.each |tt| { f |= get(tt).flags; }\n+        substs.self_r.iter(|r| f |= rflags(r));\n         ret f;\n     }\n     alt st {\n@@ -587,13 +587,13 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         flags |= get(m.ty).flags;\n       }\n       ty_rec(flds) {\n-        for flds.each {|f| flags |= get(f.mt.ty).flags; }\n+        for flds.each |f| { flags |= get(f.mt.ty).flags; }\n       }\n       ty_tup(ts) {\n-        for ts.each {|tt| flags |= get(tt).flags; }\n+        for ts.each |tt| { flags |= get(tt).flags; }\n       }\n       ty_fn(f) {\n-        for f.inputs.each {|a| flags |= get(a.ty).flags; }\n+        for f.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.output).flags;\n       }\n       ty_constr(tt, _) {\n@@ -756,7 +756,7 @@ fn encl_region(cx: ctxt, id: ast::node_id) -> ty::region {\n }\n \n fn walk_ty(ty: t, f: fn(t)) {\n-    maybe_walk_ty(ty, {|t| f(t); true});\n+    maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n@@ -773,14 +773,14 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       }\n       ty_enum(_, substs) | ty_class(_, substs) |\n       ty_iface(_, substs) {\n-        for substs.tps.each {|subty| maybe_walk_ty(subty, f); }\n+        for substs.tps.each |subty| { maybe_walk_ty(subty, f); }\n       }\n       ty_rec(fields) {\n-        for fields.each {|fl| maybe_walk_ty(fl.mt.ty, f); }\n+        for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n       }\n-      ty_tup(ts) { for ts.each {|tt| maybe_walk_ty(tt, f); } }\n+      ty_tup(ts) { for ts.each |tt| { maybe_walk_ty(tt, f); } }\n       ty_fn(ft) {\n-        for ft.inputs.each {|a| maybe_walk_ty(a.ty, f); }\n+        for ft.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.output, f);\n       }\n       ty_constr(sub, _) { maybe_walk_ty(sub, f); }\n@@ -795,8 +795,8 @@ fn fold_sty_to_ty(tcx: ty::ctxt, sty: sty, foldop: fn(t) -> t) -> t {\n fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n     fn fold_substs(substs: substs, fldop: fn(t) -> t) -> substs {\n         {self_r: substs.self_r,\n-         self_ty: substs.self_ty.map({ |t| fldop(t) }),\n-         tps: substs.tps.map({ |t| fldop(t) })}\n+         self_ty: substs.self_ty.map(|t| fldop(t)),\n+         tps: substs.tps.map(|t| fldop(t))}\n     }\n \n     alt sty {\n@@ -825,19 +825,19 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n         ty_iface(did, fold_substs(substs, fldop))\n       }\n       ty_rec(fields) {\n-        let new_fields = do vec::map(fields) {|fl|\n+        let new_fields = do vec::map(fields) |fl| {\n             let new_ty = fldop(fl.mt.ty);\n             let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n             {ident: fl.ident, mt: new_mt}\n         };\n         ty_rec(new_fields)\n       }\n       ty_tup(ts) {\n-        let new_ts = vec::map(ts, {|tt| fldop(tt) });\n+        let new_ts = vec::map(ts, |tt| fldop(tt));\n         ty_tup(new_ts)\n       }\n       ty_fn(f) {\n-        let new_args = vec::map(f.inputs, {|a|\n+        let new_args = vec::map(f.inputs, |a| {\n             let new_ty = fldop(a.ty);\n             {mode: a.mode, ty: new_ty}\n         });\n@@ -863,7 +863,7 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n \n // Folds types from the bottom up.\n fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n-    let sty = fold_sty(get(t0).struct, {|t| fold_ty(cx, fldop(t), fldop) });\n+    let sty = fold_sty(get(t0).struct, |t| fold_ty(cx, fldop(t), fldop));\n     fldop(mk_t(cx, sty))\n }\n \n@@ -876,9 +876,9 @@ fn walk_regions_and_ty(\n     if (walkt(ty)) {\n         fold_regions_and_ty(\n             cx, ty,\n-            { |r| walkr(r); r },\n-            { |t| walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t },\n-            { |t| walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t });\n+            |r| { walkr(r); r },\n+            |t| { walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t },\n+            |t| { walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t });\n     }\n }\n \n@@ -894,9 +894,9 @@ fn fold_regions_and_ty(\n         fldr: fn(r: region) -> region,\n         fldt: fn(t: t) -> t) -> substs {\n \n-        {self_r: substs.self_r.map({ |r| fldr(r) }),\n-         self_ty: substs.self_ty.map({ |t| fldt(t) }),\n-         tps: substs.tps.map({ |t| fldt(t) })}\n+        {self_r: substs.self_r.map(|r| fldr(r)),\n+         self_ty: substs.self_ty.map(|t| fldt(t)),\n+         tps: substs.tps.map(|t| fldt(t))}\n     }\n \n     let tb = ty::get(ty);\n@@ -925,10 +925,10 @@ fn fold_regions_and_ty(\n         ty::mk_iface(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n       sty @ ty_fn(_) {\n-        fold_sty_to_ty(cx, sty, {|t| fldfnt(t) })\n+        fold_sty_to_ty(cx, sty, |t| fldfnt(t))\n       }\n       sty {\n-        fold_sty_to_ty(cx, sty, {|t| fldt(t) })\n+        fold_sty_to_ty(cx, sty, |t| fldt(t))\n       }\n     }\n }\n@@ -945,9 +945,9 @@ fn fold_regions(\n         if !type_has_regions(ty) { ret ty; }\n         fold_regions_and_ty(\n             cx, ty,\n-            { |r| fldr(r, in_fn) },\n-            { |t| do_fold(cx, t, true, fldr) },\n-            { |t| do_fold(cx, t, in_fn, fldr) })\n+            |r| fldr(r, in_fn),\n+            |t| do_fold(cx, t, true, fldr),\n+            |t| do_fold(cx, t, in_fn, fldr))\n     }\n     do_fold(cx, ty, false, fldr)\n }\n@@ -977,7 +977,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n             t0\n           }\n           sty {\n-            do fold_sty_to_ty(cx, sty) {|t|\n+            do fold_sty_to_ty(cx, sty) |t| {\n                 do_fold(cx, t, under_r, fldop)\n             }\n           }\n@@ -994,7 +994,7 @@ fn subst_tps(cx: ctxt, tps: ~[t], typ: t) -> t {\n     if !tbox_has_flag(tb, has_params) { ret typ; }\n     alt tb.struct {\n       ty_param(idx, _) { tps[idx] }\n-      sty { fold_sty_to_ty(cx, sty, {|t| subst_tps(cx, tps, t) }) }\n+      sty { fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, t)) }\n     }\n }\n \n@@ -1006,9 +1006,9 @@ fn substs_is_noop(substs: substs) -> bool {\n \n fn substs_to_str(cx: ctxt, substs: substs) -> str {\n     #fmt[\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n-         substs.self_r.map_default(\"none\", { |r| region_to_str(cx, r) }),\n-         substs.self_ty.map_default(\"none\", { |t| ty_to_str(cx, t) }),\n-         substs.tps.map({ |t| ty_to_str(cx, t) })]\n+         substs.self_r.map_default(\"none\", |r| region_to_str(cx, r)),\n+         substs.self_ty.map_default(\"none\", |t| ty_to_str(cx, t)),\n+         substs.tps.map(|t| ty_to_str(cx, t))]\n }\n \n fn subst(cx: ctxt,\n@@ -1035,14 +1035,12 @@ fn subst(cx: ctxt,\n           _ {\n             fold_regions_and_ty(\n                 cx, typ,\n-                { |r|\n-                    alt r {\n-                      re_bound(br_self) {substs.self_r.get()}\n-                      _ {r}\n-                    }\n+                |r| alt r {\n+                    re_bound(br_self) {substs.self_r.get()}\n+                    _ {r}\n                 },\n-                { |t| do_subst(cx, substs, t) },\n-                { |t| do_subst(cx, substs, t) })\n+                |t| do_subst(cx, substs, t),\n+                |t| do_subst(cx, substs, t))\n           }\n         }\n     }\n@@ -1202,26 +1200,28 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_evec(mt, vstore_fixed(_)) { type_needs_drop(cx, mt.ty) }\n       ty_unboxed_vec(mt) { type_needs_drop(cx, mt.ty) }\n       ty_rec(flds) {\n-        for flds.each {|f| if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n+        for flds.each |f| {\n+            if type_needs_drop(cx, f.mt.ty) { accum = true; }\n+        }\n         accum\n       }\n       ty_class(did, substs) {\n          // Any class with a dtor needs a drop\n          option::is_some(ty_dtor(cx, did)) || {\n-           for vec::each(ty::class_items_as_fields(cx, did, substs)) {|f|\n+             for vec::each(ty::class_items_as_fields(cx, did, substs)) |f| {\n              if type_needs_drop(cx, f.mt.ty) { accum = true; }\n            }\n            accum\n          }\n       }\n       ty_tup(elts) {\n-        for elts.each {|m| if type_needs_drop(cx, m) { accum = true; } }\n+          for elts.each |m| { if type_needs_drop(cx, m) { accum = true; } }\n         accum\n       }\n       ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n-        for vec::each(*variants) {|variant|\n-            for variant.args.each {|aty|\n+          for vec::each(*variants) |variant| {\n+              for variant.args.each |aty| {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = subst(cx, substs, aty);\n                 if type_needs_drop(cx, arg_ty) { accum = true; }\n@@ -1272,7 +1272,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n     let mut encountered_box = encountered_box;\n     let mut needs_unwind_cleanup = false;\n-    do maybe_walk_ty(ty) {|ty|\n+    do maybe_walk_ty(ty) |ty| {\n         let old_encountered_box = encountered_box;\n         let result = alt get(ty).struct {\n           ty_box(_) | ty_opaque_box {\n@@ -1285,8 +1285,8 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             true\n           }\n           ty_enum(did, substs) {\n-            for vec::each(*enum_variants(cx, did)) {|v|\n-                for v.args.each {|aty|\n+            for vec::each(*enum_variants(cx, did)) |v| {\n+                for v.args.each |aty| {\n                     let t = subst(cx, substs, aty);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n@@ -1533,7 +1533,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         let mut lowest = kind_top();\n-        for flds.each {|f|\n+        for flds.each |f| {\n             lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n         }\n         lowest\n@@ -1544,7 +1544,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         // also factor out this code, copied from the records case\n         let mut lowest = kind_top();\n         let flds = class_items_as_fields(cx, did, substs);\n-        for flds.each {|f|\n+        for flds.each |f| {\n             lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n         }\n         // ...but classes with dtors are never copyable (they can be\n@@ -1557,7 +1557,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         let mut lowest = kind_top();\n-        for tys.each {|ty| lowest = lower_kind(lowest, type_kind(cx, ty)); }\n+        for tys.each |ty| { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n       // Enums lower to the lowest of their variants.\n@@ -1567,8 +1567,8 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         if vec::len(*variants) == 0u {\n             lowest = kind_send_only();\n         } else {\n-            for vec::each(*variants) {|variant|\n-                for variant.args.each {|aty|\n+            for vec::each(*variants) |variant| {\n+                for variant.args.each |aty| {\n                     // Perform any type parameter substitutions.\n                     let arg_ty = subst(cx, substs, aty);\n                     lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n@@ -1661,7 +1661,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           }\n \n           ty_rec(fields) {\n-            do vec::any(fields) {|field|\n+            do vec::any(fields) |field| {\n                 type_requires(cx, seen, r_ty, field.mt.ty)\n             }\n           }\n@@ -1676,16 +1676,14 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n           ty_class(did, substs) {\n             vec::push(*seen, did);\n-            let r = vec::any(class_items_as_fields(cx, did, substs),{|f|\n-                      type_requires(cx, seen, r_ty, f.mt.ty)});\n+            let r = vec::any(class_items_as_fields(cx, did, substs),\n+                             |f| type_requires(cx, seen, r_ty, f.mt.ty));\n             vec::pop(*seen);\n             r\n           }\n \n           ty_tup(ts) {\n-            vec::any(ts, {|t|\n-                type_requires(cx, seen, r_ty, t)\n-            })\n+            vec::any(ts, |t| type_requires(cx, seen, r_ty, t))\n           }\n \n           ty_enum(did, _) if vec::contains(*seen, did) {\n@@ -1695,8 +1693,8 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_enum(did, substs) {\n             vec::push(*seen, did);\n             let vs = enum_variants(cx, did);\n-            let r = vec::len(*vs) > 0u && vec::all(*vs, {|variant|\n-                vec::any(variant.args, {|aty|\n+            let r = vec::len(*vs) > 0u && vec::all(*vs, |variant| {\n+                vec::any(variant.args, |aty| {\n                     let sty = subst(cx, substs, aty);\n                     type_requires(cx, seen, r_ty, sty)\n                 })\n@@ -1725,30 +1723,30 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     if test(sty) { ret true; }\n     alt sty {\n       ty_enum(did, substs) {\n-        for vec::each(*enum_variants(cx, did)) {|variant|\n-            for variant.args.each {|aty|\n+        for vec::each(*enum_variants(cx, did)) |variant| {\n+            for variant.args.each |aty| {\n                 let sty = subst(cx, substs, aty);\n                 if type_structurally_contains(cx, sty, test) { ret true; }\n             }\n         }\n         ret false;\n       }\n       ty_rec(fields) {\n-        for fields.each {|field|\n+        for fields.each |field| {\n             if type_structurally_contains(cx, field.mt.ty, test) { ret true; }\n         }\n         ret false;\n       }\n       ty_class(did, substs) {\n-        for lookup_class_fields(cx, did).each {|field|\n+        for lookup_class_fields(cx, did).each |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n             if type_structurally_contains(cx, ft, test) { ret true; }\n         }\n         ret false;\n       }\n \n       ty_tup(ts) {\n-        for ts.each {|tt|\n+        for ts.each |tt| {\n             if type_structurally_contains(cx, tt, test) { ret true; }\n         }\n         ret false;\n@@ -1764,7 +1762,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n // distinguished from the value itself. I.e. types with mut content that's\n // not shared through a pointer.\n fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n-    ret !type_structurally_contains(cx, ty, {|sty|\n+    ret !type_structurally_contains(cx, ty, |sty| {\n         alt sty {\n           ty_param(_, _) { true }\n \n@@ -1776,15 +1774,15 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n             mt.mutbl != ast::m_imm\n           }\n           ty_rec(fields) {\n-            vec::any(fields, {|f| f.mt.mutbl != ast::m_imm})\n+            vec::any(fields, |f| f.mt.mutbl != ast::m_imm)\n           }\n           _ { false }\n         }\n     }) && type_kind(cx, ty) != kind_noncopyable();\n }\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n-    ret type_structurally_contains(cx, ty, {|sty|\n+    ret type_structurally_contains(cx, ty, |sty| {\n         alt sty {\n           ty_uniq(_) |\n           ty_vec(_) |\n@@ -1837,7 +1835,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n-        for vec::each(*variants) {|variant|\n+        for vec::each(*variants) |variant| {\n             let tup_ty = mk_tup(cx, variant.args);\n \n             // Perform any type parameter substitutions.\n@@ -1846,12 +1844,12 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         }\n       }\n       ty_rec(flds) {\n-        for flds.each {|f|\n+        for flds.each |f| {\n             if !type_is_pod(cx, f.mt.ty) { result = false; }\n         }\n       }\n       ty_tup(elts) {\n-        for elts.each {|elt| if !type_is_pod(cx, elt) { result = false; } }\n+        for elts.each |elt| { if !type_is_pod(cx, elt) { result = false; } }\n       }\n       ty_estr(vstore_fixed(_)) { result = true; }\n       ty_evec(mt, vstore_fixed(_)) | ty_unboxed_vec(mt) {\n@@ -1861,7 +1859,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_param(_, _) { result = false; }\n       ty_opaque_closure_ptr(_) { result = true; }\n       ty_class(did, substs) {\n-        result = vec::any(lookup_class_fields(cx, did), { |f|\n+        result = vec::any(lookup_class_fields(cx, did), |f| {\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n             type_is_pod(cx, sty)\n@@ -1893,7 +1891,7 @@ fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     alt get(ty).struct {\n       ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n-        let some_n_ary = vec::any(*variants, {|v| vec::len(v.args) > 0u});\n+        let some_n_ary = vec::any(*variants, |v| vec::len(v.args) > 0u);\n         ret !some_n_ary;\n       }\n       _ { ret false;}\n@@ -1972,7 +1970,7 @@ fn hash_bound_region(br: bound_region) -> uint {\n \n fn br_hashmap<V:copy>() -> hashmap<bound_region, V> {\n     map::hashmap(hash_bound_region,\n-                 {|&&a: bound_region, &&b: bound_region| a == b })\n+                 |&&a: bound_region, &&b: bound_region| a == b)\n }\n \n // Type hashing.\n@@ -1985,13 +1983,13 @@ fn hash_type_structure(st: sty) -> uint {\n     fn hash_subty(id: uint, subty: t) -> uint { (id << 2u) + type_id(subty) }\n     fn hash_subtys(id: uint, subtys: ~[t]) -> uint {\n         let mut h = id;\n-        for subtys.each {|s| h = (h << 2u) + type_id(s) }\n+        for subtys.each |s| { h = (h << 2u) + type_id(s) }\n         h\n     }\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let mut h = id;\n         h = (h << 2u) + hash_def(h, c.node.id);\n-        for c.node.args.each {|a|\n+        for c.node.args.each |a| {\n             alt a.node {\n               carg_base { h += h << 2u; }\n               carg_lit(_) { fail \"lit args not implemented yet\"; }\n@@ -2044,12 +2042,12 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_tup(ts) { hash_subtys(25u, ts) }\n       ty_rec(fields) {\n         let mut h = 26u;\n-        for fields.each {|f| h = hash_subty(h, f.mt.ty); }\n+        for fields.each |f| { h = hash_subty(h, f.mt.ty); }\n         h\n       }\n       ty_fn(f) {\n         let mut h = 27u;\n-        for f.inputs.each {|a| h = hash_subty(h, a.ty); }\n+        for f.inputs.each |a| { h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n       }\n       ty_self { 28u }\n@@ -2061,7 +2059,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_ptr(mt) { hash_subty(35u, mt.ty) }\n       ty_constr(t, cs) {\n         let mut h = hash_subty(36u, t);\n-        for cs.each {|c| h = (h << 2u) + hash_type_constr(h, c); }\n+        for cs.each |c| { h = (h << 2u) + hash_type_constr(h, c); }\n         h\n       }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n@@ -2107,7 +2105,7 @@ fn args_eq<T>(eq: fn(T, T) -> bool,\n               a: ~[@sp_constr_arg<T>],\n               b: ~[@sp_constr_arg<T>]) -> bool {\n     let mut i: uint = 0u;\n-    for a.each {|arg|\n+    for a.each |arg| {\n         if !arg_eq(eq, arg, b[i]) { ret false; }\n         i += 1u;\n     }\n@@ -2123,7 +2121,7 @@ fn constr_eq(c: @constr, d: @constr) -> bool {\n fn constrs_eq(cs: ~[@constr], ds: ~[@constr]) -> bool {\n     if vec::len(cs) != vec::len(ds) { ret false; }\n     let mut i = 0u;\n-    for cs.each {|c| if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n+    for cs.each |c| { if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n     ret true;\n }\n \n@@ -2184,7 +2182,7 @@ fn is_fn_ty(fty: t) -> bool {\n \n // Returns a vec of all the input and output types of fty.\n fn tys_in_fn_ty(fty: fn_ty) -> ~[t] {\n-    vec::append_one(fty.inputs.map({|a| a.ty}), fty.output)\n+    vec::append_one(fty.inputs.map(|a| a.ty), fty.output)\n }\n \n // Just checks whether it's a fn that returns bool,\n@@ -2262,12 +2260,12 @@ fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n \n fn field_idx(id: ast::ident, fields: ~[field]) -> option<uint> {\n     let mut i = 0u;\n-    for fields.each {|f| if f.ident == id { ret some(i); } i += 1u; }\n+    for fields.each |f| { if f.ident == id { ret some(i); } i += 1u; }\n     ret none;\n }\n \n fn get_field(rec_ty: t, id: ast::ident) -> field {\n-    alt check vec::find(get_fields(rec_ty), {|f| str::eq(*f.ident, *id) }) {\n+    alt check vec::find(get_fields(rec_ty), |f| str::eq(*f.ident, *id)) {\n       some(f) { f }\n     }\n }\n@@ -2280,7 +2278,7 @@ fn get_fields(rec_ty:t) -> ~[field] {\n \n fn method_idx(id: ast::ident, meths: ~[method]) -> option<uint> {\n     let mut i = 0u;\n-    for meths.each {|m| if m.ident == id { ret some(i); } i += 1u; }\n+    for meths.each |m| { if m.ident == id { ret some(i); } i += 1u; }\n     ret none;\n }\n \n@@ -2290,7 +2288,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n     // contain duplicates.  (Integral type vars aren't counted.)\n     fn vars_in_type(ty: t) -> ~[tv_vid] {\n         let mut rslt = ~[];\n-        do walk_ty(ty) {|ty|\n+        do walk_ty(ty) |ty| {\n             alt get(ty).struct { ty_var(v) { vec::push(rslt, v); } _ { } }\n         }\n         rslt\n@@ -2570,10 +2568,9 @@ type variant_info = @{args: ~[t], ctor_ty: t, name: ast::ident,\n fn substd_enum_variants(cx: ctxt,\n                         id: ast::def_id,\n                         substs: substs) -> ~[variant_info] {\n-    do vec::map(*enum_variants(cx, id)) { |variant_info|\n-        let substd_args = vec::map(variant_info.args, {|aty|\n-            subst(cx, substs, aty)\n-        });\n+    do vec::map(*enum_variants(cx, id)) |variant_info| {\n+        let substd_args = vec::map(variant_info.args,\n+                                   |aty| subst(cx, substs, aty));\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n@@ -2674,11 +2671,11 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n         alt cx.items.get(id.node) {\n           ast_map::node_item(@{node: ast::item_enum(variants, _, _), _}, _) {\n             let mut disr_val = -1;\n-            @vec::map(variants, {|variant|\n+            @vec::map(variants, |variant| {\n                 let ctor_ty = node_id_to_type(cx, variant.node.id);\n                 let arg_tys = {\n                     if vec::len(variant.node.args) > 0u {\n-                        ty_fn_args(ctor_ty).map({ |a| a.ty })\n+                        ty_fn_args(ctor_ty).map(|a| a.ty)\n                     } else { ~[] }\n                 };\n                 alt variant.node.disr_expr {\n@@ -2788,7 +2785,7 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n fn lookup_class_field(cx: ctxt, parent: ast::def_id, field_id: ast::def_id)\n     -> field_ty {\n     alt vec::find(lookup_class_fields(cx, parent),\n-                 {|f| f.id.node == field_id.node}) {\n+                 |f| f.id.node == field_id.node) {\n         some(t) { t }\n         none { cx.sess.bug(\"class ID not found in parent's fields\"); }\n     }\n@@ -2812,8 +2809,8 @@ fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(@{node: item_class(_,_,items,_,_,_), _}, _)) {\n          let (_,ms) = split_class_items(items);\n-         vec::map(ms, {|m| {name: m.ident, id: m.id,\n-                            vis: m.vis}})\n+         vec::map(ms, |m| {name: m.ident, id: m.id,\n+                            vis: m.vis})\n        }\n        _ {\n            cx.sess.bug(\"lookup_class_method_ids: id not bound to a class\");\n@@ -2830,7 +2827,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n                                sp: span) -> def_id {\n     if check is_local(did) {\n        let ms = lookup_class_method_ids(cx, did);\n-       for ms.each {|m|\n+        for ms.each |m| {\n          if m.name == name {\n              ret ast_util::local_def(m.id);\n          }\n@@ -2845,7 +2842,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n \n fn class_field_tys(items: ~[@class_member]) -> ~[field_ty] {\n     let mut rslt = ~[];\n-    for items.each {|it|\n+    for items.each |it| {\n        alt it.node {\n           instance_var(nm, _, cm, id, vis) {\n               vec::push(rslt, {ident: nm, id: ast_util::local_def(id),\n@@ -2865,24 +2862,24 @@ fn class_field_tys(items: ~[@class_member]) -> ~[field_ty] {\n // be used in trans.\n fn class_items_as_mutable_fields(cx:ctxt, did: ast::def_id,\n                          substs: substs) -> ~[field] {\n-    class_item_fields(cx, did, substs, {|_mt| m_mutbl})\n+    class_item_fields(cx, did, substs, |_mt| m_mutbl)\n }\n \n // Same as class_items_as_mutable_fields, but doesn't change\n // mutability.\n fn class_items_as_fields(cx:ctxt, did: ast::def_id,\n                          substs: substs) -> ~[field] {\n-    class_item_fields(cx, did, substs, {|mt| alt mt {\n+    class_item_fields(cx, did, substs, |mt| alt mt {\n       class_mutable { m_mutbl }\n-      class_immutable { m_imm }}})\n+      class_immutable { m_imm }})\n }\n \n \n fn class_item_fields(cx:ctxt, did: ast::def_id,\n   substs: substs, frob_mutability: fn(class_mutability) -> mutability)\n     -> ~[field] {\n     let mut rslt = ~[];\n-    for lookup_class_fields(cx, did).each {|f|\n+    for lookup_class_fields(cx, did).each |f| {\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n        vec::push(rslt, {ident: f.ident, mt:\n@@ -2985,7 +2982,7 @@ fn ast_constr_to_constr<T>(tcx: ctxt, c: @ast::constr_general<T>) ->\n }\n \n fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n-    vec::from_fn(tps.len(), {|i|\n+    vec::from_fn(tps.len(), |i| {\n                 ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))\n         })\n }\n@@ -3025,7 +3022,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n     // types, which isn't necessary after #2187\n     let t = mk_t(cx, mach_sty(cx.sess.targ_cfg, t));\n \n-    let sty = fold_sty(get(t).struct, {|t| normalize_ty(cx, t) });\n+    let sty = fold_sty(get(t).struct, |t| { normalize_ty(cx, t) });\n     let t_norm = mk_t(cx, sty);\n     cx.normalized_cache.insert(t, t_norm);\n     ret t_norm;"}, {"sha": "a6f1501efe71b84c14fe5709c2cebb2a94e53781", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -121,7 +121,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n             #fmt[\"wrong number of type arguments, expected %u but found %u\",\n                  (*decl_bounds).len(), path.types.len()]);\n     }\n-    let tps = path.types.map({ |a_t| ast_ty_to_ty(self, rscope, a_t) });\n+    let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, a_t));\n \n     let substs = {self_r:self_r, self_ty:none, tps:tps};\n     {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n@@ -244,11 +244,11 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ty::mk_rptr(tcx, r, mt)\n       }\n       ast::ty_tup(fields) {\n-        let flds = vec::map(fields, { |t| ast_ty_to_ty(self, rscope, t) });\n+        let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_rec(fields) {\n-        let flds = do fields.map {|f|\n+        let flds = do fields.map |f| {\n             let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n             {ident: f.node.ident, mt: tm}\n         };\n@@ -338,7 +338,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n       }\n       ast::ty_constr(t, cs) {\n         let mut out_cs = ~[];\n-        for cs.each {|constr|\n+        for cs.each |constr| {\n             vec::push(out_cs, ty::ast_constr_to_constr(tcx, constr));\n         }\n         ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n@@ -412,28 +412,28 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n     expected_tys: expected_tys) -> ty::fn_ty {\n \n     #debug[\"ty_of_fn_decl\"];\n-    do indent {||\n+    do indent || {\n         // new region names that appear inside of the fn decl are bound to\n         // that function type\n         let rb = in_binding_rscope(rscope);\n \n-        let input_tys = do decl.inputs.mapi { |i, a|\n-            let expected_arg_ty = do expected_tys.chain { |e|\n+        let input_tys = do decl.inputs.mapi |i, a| {\n+            let expected_arg_ty = do expected_tys.chain |e| {\n                 // no guarantee that the correct number of expected args\n                 // were supplied\n                 if i < e.inputs.len() {some(e.inputs[i])} else {none}\n             };\n             ty_of_arg(self, rb, a, expected_arg_ty)\n         };\n \n-        let expected_ret_ty = expected_tys.map({ |e| e.output });\n+        let expected_ret_ty = expected_tys.map(|e| e.output);\n         let output_ty = alt decl.output.node {\n           ast::ty_infer if expected_ret_ty.is_some() {expected_ret_ty.get()}\n           ast::ty_infer {self.ty_infer(decl.output.span)}\n           _ {ast_ty_to_ty(self, rb, decl.output)}\n         };\n \n-        let out_constrs = vec::map(decl.constraints, {|constr|\n+        let out_constrs = vec::map(decl.constraints, |constr| {\n             ty::ast_constr_to_constr(self.tcx(), constr)\n         });\n "}, {"sha": "aac959b4cb456b7029935fe68aaede32118fa67a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -124,7 +124,7 @@ impl methods for isr_alist {\n     }\n \n     fn find(br: ty::bound_region) -> option<ty::region> {\n-        for list::each(self) { |isr|\n+        for list::each(self) |isr| {\n             let (isr_br, isr_r) = isr;\n             if isr_br == br { ret some(isr_r); }\n         }\n@@ -134,7 +134,7 @@ impl methods for isr_alist {\n \n fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     let visit = visit::mk_simple_visitor(@{\n-        visit_item: {|a|check_item(ccx, a)}\n+        visit_item: |a| check_item(ccx, a)\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), visit);\n@@ -167,18 +167,18 @@ fn check_fn(ccx: @crate_ctxt,\n \n     let {isr, self_ty, fn_ty} = {\n         let old_isr = option::map_default(old_fcx, @nil,\n-                                         { |fcx| fcx.in_scope_regions });\n+                                         |fcx| fcx.in_scope_regions);\n         replace_bound_regions_in_fn_ty(tcx, old_isr, self_ty, fn_ty,\n-                                       { |br| ty::re_free(body.node.id, br) })\n+                                       |br| ty::re_free(body.node.id, br))\n     };\n \n-    let arg_tys = fn_ty.inputs.map({ |a| a.ty });\n+    let arg_tys = fn_ty.inputs.map(|a| a.ty);\n     let ret_ty = fn_ty.output;\n \n     #debug[\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n-           arg_tys.map({|a| ty_to_str(tcx, a) }),\n+           arg_tys.map(|a| ty_to_str(tcx, a)),\n            ty_to_str(tcx, ret_ty),\n-           option::map(self_ty, {|st| ty_to_str(tcx, st) })];\n+           option::map(self_ty, |st| ty_to_str(tcx, st))];\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -239,7 +239,7 @@ fn check_fn(ccx: @crate_ctxt,\n     }\n \n     let mut i = 0u;\n-    do vec::iter(arg_tys) {|arg|\n+    do vec::iter(arg_tys) |arg| {\n         fcx.write_ty(decl.inputs[i].id, arg);\n         i += 1u;\n     }\n@@ -272,7 +272,7 @@ fn check_fn(ccx: @crate_ctxt,\n         };\n \n         // Add formal parameters.\n-        do vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n+        do vec::iter2(arg_tys, decl.inputs) |arg_ty, input| {\n             assign(input.id, some(arg_ty));\n             #debug[\"Argument %s is assigned to %s\",\n                    *input.ident, fcx.locals.get(input.id).to_str()];\n@@ -356,7 +356,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_impl(tps, rp, _, ty, ms) {\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n-        for ms.each {|m| check_method(ccx, m, self_ty);}\n+        for ms.each |m| { check_method(ccx, m, self_ty);}\n       }\n       ast::item_class(tps, ifaces, members, ctor, m_dtor, rp) {\n           let tcx = ccx.tcx;\n@@ -368,7 +368,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           // Write the ctor's self's type\n           write_ty_to_tcx(tcx, ctor.node.self_id, class_t);\n \n-          do option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) |dtor| {\n             // typecheck the dtor\n            check_bare_fn(ccx, ast_util::dtor_dec(),\n                            dtor.node.body, dtor.node.id,\n@@ -377,7 +377,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n            write_ty_to_tcx(tcx, dtor.node.self_id, class_t);\n           };\n           // typecheck the members\n-          for members.each {|m| check_class_member(ccx, class_t, m); }\n+        for members.each |m| { check_class_member(ccx, class_t, m); }\n           // Check that there's at least one field\n           let (fields,_) = split_class_items(members);\n           if fields.len() < 1u {\n@@ -394,11 +394,11 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_foreign_mod(m) {\n         if syntax::attr::foreign_abi(it.attrs) ==\n             either::right(ast::foreign_abi_rust_intrinsic) {\n-            for m.items.each { |item|\n+            for m.items.each |item| {\n                 check_intrinsic_type(ccx, item);\n             }\n         } else {\n-            for m.items.each { |item|\n+            for m.items.each |item| {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if (*tpt.bounds).is_not_empty() {\n                     ccx.tcx.sess.span_err(\n@@ -430,7 +430,7 @@ impl of region_scope for @fn_ctxt {\n         result::ok(self.infcx.next_region_var())\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, str> {\n-        do empty_rscope.named_region(id).chain_err { |_e|\n+        do empty_rscope.named_region(id).chain_err |_e| {\n             alt self.in_scope_regions.find(ty::br_named(id)) {\n               some(r) { result::ok(r) }\n               none if *id == \"blk\" { self.block_region() }\n@@ -632,8 +632,8 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n \n fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n               expected: option<ty::t>) -> bool {\n-    ret do check_expr_with_unifier(fcx, expr, expected) {||\n-        for expected.each {|t|\n+    ret do check_expr_with_unifier(fcx, expr, expected) || {\n+        for expected.each |t| {\n             demand::suptype(fcx, expr.span, t, fcx.expr_ty(expr));\n         }\n     };\n@@ -696,8 +696,8 @@ fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n                    items:~[ty::field_ty], fieldname: ast::ident,\n                    substs: ty::substs) -> option<ty::t> {\n \n-    let o_field = vec::find(items, {|f| f.ident == fieldname});\n-    do option::map(o_field) {|f|\n+    let o_field = vec::find(items, |f| f.ident == fieldname);\n+    do option::map(o_field) |f| {\n         ty::lookup_field_type(tcx, class_id, f.id, substs)\n     }\n }\n@@ -733,7 +733,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               sty @ ty::ty_fn(fn_ty) {\n                 replace_bound_regions_in_fn_ty(\n                     fcx.ccx.tcx, @nil, none, fn_ty,\n-                    { |_br| fcx.infcx.next_region_var() }).fn_ty\n+                    |_br| fcx.infcx.next_region_var()).fn_ty\n               }\n               sty {\n                 // I would like to make this span_err, but it's\n@@ -756,7 +756,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // if the wrong number of arguments were supplied\n         let expected_arg_count = vec::len(fn_ty.inputs);\n         let arg_tys = if expected_arg_count == supplied_arg_count {\n-            fn_ty.inputs.map({ |a| a.ty })\n+            fn_ty.inputs.map(|a| a.ty)\n         } else {\n             fcx.ccx.tcx.sess.span_err(\n                 sp, #fmt[\"this function takes %u parameter%s but %u \\\n@@ -781,8 +781,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // functions. This is so that we have more information about the types\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n-        for [false, true]/_.each { |check_blocks|\n-            for args.eachi {|i, a_opt|\n+        for [false, true]/_.each |check_blocks| {\n+            for args.eachi |i, a_opt| {\n                 alt a_opt {\n                   some(a) {\n                     let is_block = alt a.node {\n@@ -792,10 +792,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     if is_block == check_blocks {\n                         let arg_ty = arg_tys[i];\n                         bot |= check_expr_with_unifier(\n-                            fcx, a, some(arg_ty), {||\n-                            demand::assign(fcx, a.span, call_expr_id,\n-                                           arg_ty, a);\n-                        });\n+                            fcx, a, some(arg_ty),\n+                            || demand::assign(fcx, a.span, call_expr_id,\n+                                              arg_ty, a)\n+                        );\n                     }\n                   }\n                   none { }\n@@ -824,7 +824,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Call the generic checker.\n         let fty = {\n-            let args_opt = args.map({ |arg| some(arg) });\n+            let args_opt = args.map(|arg| some(arg));\n             let r = check_call_or_bind(fcx, sp, call_expr_id,\n                                        fn_ty, args_opt);\n             bot |= r.bot;\n@@ -1021,7 +1021,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                      expected: option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n \n-        let expected_tys = do unpack_expected(fcx, expected) { |sty|\n+        let expected_tys = do unpack_expected(fcx, expected) |sty| {\n             alt sty {\n               ty::ty_fn(fn_ty) {some({inputs:fn_ty.inputs,\n                                       output:fn_ty.output})}\n@@ -1057,7 +1057,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           ast::expr_vec(args, mutbl) {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vec::len(args), vst);\n             let t: ty::t = fcx.infcx.next_ty_var();\n-            for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n+            for args.each |e| { bot |= check_expr_with(fcx, e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n           _ {\n@@ -1106,7 +1106,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_nil(expr.id);\n       }\n       ast::expr_unary(unop, oprnd) {\n-        let exp_inner = do unpack_expected(fcx, expected) {|sty|\n+        let exp_inner = do unpack_expected(fcx, expected) |sty| {\n             alt unop {\n               ast::box(_) | ast::uniq(_) {\n                 alt sty {\n@@ -1182,9 +1182,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::expr_addr_of(mutbl, oprnd) {\n-        bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected, {|ty|\n+        bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected, |ty|\n             alt ty { ty::ty_rptr(_, mt) { some(mt.ty) } _ { none } }\n-        }));\n+        ));\n         let region = region_of(fcx, oprnd);\n         let tm = { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = ty::mk_rptr(tcx, region, tm);\n@@ -1280,9 +1280,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_fn_block(decl, body, cap_clause) {\n         // Take the prototype from the expected type, but default to block:\n-        let proto = unpack_expected(fcx, expected, {|sty|\n+        let proto = unpack_expected(fcx, expected, |sty|\n             alt sty { ty::ty_fn({proto, _}) { some(proto) } _ { none } }\n-        }).get_default(ast::proto_box);\n+        ).get_default(ast::proto_box);\n         check_expr_fn(fcx, expr, proto, decl, body, false, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n@@ -1293,7 +1293,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // parameter. The catch here is that we need to validate two things:\n         // 1. a closure that returns a bool is expected\n         // 2. the cloure that was given returns unit\n-        let expected_sty = unpack_expected(fcx, expected, {|x|some(x)}).get();\n+        let expected_sty = unpack_expected(fcx, expected, |x| some(x)).get();\n         let (inner_ty, proto) = alt expected_sty {\n           ty::ty_fn(fty) {\n             alt infer::mk_subty(fcx.infcx, fty.output, ty::mk_bool(tcx)) {\n@@ -1330,7 +1330,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n       }\n       ast::expr_do_body(b) {\n-        let expected_sty = unpack_expected(fcx, expected, {|x|some(x)}).get();\n+        let expected_sty = unpack_expected(fcx, expected, |x| some(x)).get();\n         let (inner_ty, proto) = alt expected_sty {\n           ty::ty_fn(fty) {\n             (ty::mk_fn(tcx, fty), fty.proto)\n@@ -1411,36 +1411,36 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_vec(args, mutbl) {\n         let t: ty::t = fcx.infcx.next_ty_var();\n-        for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n+        for args.each |e| { bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_vec(tcx, {ty: t, mutbl: mutbl});\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_tup(elts) {\n         let mut elt_ts = ~[];\n         vec::reserve(elt_ts, vec::len(elts));\n-        let flds = unpack_expected(fcx, expected, {|sty|\n+        let flds = unpack_expected(fcx, expected, |sty| {\n             alt sty { ty::ty_tup(flds) { some(flds) } _ { none } }\n         });\n-        for elts.eachi {|i, e|\n-            check_expr(fcx, e, flds.map({|fs| fs[i]}));\n+        for elts.eachi |i, e| {\n+            check_expr(fcx, e, flds.map(|fs| fs[i]));\n             let ety = fcx.expr_ty(e);\n             vec::push(elt_ts, ety);\n         }\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_rec(fields, base) {\n-        option::iter(base, {|b| check_expr(fcx, b, expected); });\n+        option::iter(base, |b| { check_expr(fcx, b, expected); });\n         let expected = if expected == none && base != none {\n             some(fcx.expr_ty(base.get()))\n         } else { expected };\n-        let flds = unpack_expected(fcx, expected, {|sty|\n+        let flds = unpack_expected(fcx, expected, |sty|\n             alt sty { ty::ty_rec(flds) { some(flds) } _ { none } }\n-        });\n-        let fields_t = vec::map(fields, {|f|\n-            bot |= check_expr(fcx, f.node.expr, flds.chain({|flds|\n-                vec::find(flds, {|tf| tf.ident == f.node.ident})\n-            }).map({|tf| tf.mt.ty}));\n+        );\n+        let fields_t = vec::map(fields, |f| {\n+            bot |= check_expr(fcx, f.node.expr, flds.chain(|flds|\n+                vec::find(flds, |tf| tf.ident == f.node.ident)\n+            ).map(|tf| tf.mt.ty));\n             let expr_t = fcx.expr_ty(f.node.expr);\n             let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n@@ -1463,9 +1463,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n             };\n             fcx.write_ty(id, bexpr_t);\n-            for fields_t.each {|f|\n+            for fields_t.each |f| {\n                 let mut found = false;\n-                for base_fields.each {|bf|\n+                for base_fields.each |bf| {\n                     if str::eq(*f.node.ident, *bf.ident) {\n                         demand::suptype(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n@@ -1533,7 +1533,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ {}\n         }\n         if !handled {\n-            let tps = vec::map(tys, { |ty| fcx.to_ty(ty) });\n+            let tps = vec::map(tys, |ty| fcx.to_ty(ty));\n             let is_self_ref = self_ref(fcx, base.id);\n \n             // this will be the call or block that immediately\n@@ -1698,7 +1698,7 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n         node_id = id;\n         alt decl.node {\n           ast::decl_local(ls) {\n-            for ls.each {|l| bot |= check_decl_local(fcx, l); }\n+            for ls.each |l| { bot |= check_decl_local(fcx, l); }\n           }\n           ast::decl_item(_) {/* ignore for now */ }\n         }\n@@ -1735,7 +1735,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     vec::push(fcx.blocks, blk.node.id);\n     let mut bot = false;\n     let mut warned = false;\n-    for blk.node.stmts.each {|s|\n+    for blk.node.stmts.each |s| {\n         if bot && !warned &&\n                alt s.node {\n                  ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n@@ -1799,7 +1799,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     let mut disr_vals: ~[int] = ~[];\n     let mut disr_val = 0;\n     let mut variants = ~[];\n-    for vs.each {|v|\n+    for vs.each |v| {\n         alt v.node.disr_expr {\n           some(e) {\n             check_expr(fcx, e, none);\n@@ -1829,7 +1829,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n         vec::push(disr_vals, disr_val);\n         let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n         let arg_tys = if v.node.args.len() > 0u {\n-            ty::ty_fn_args(ctor_ty).map({|a| a.ty })\n+            ty::ty_fn_args(ctor_ty).map(|a| a.ty)\n           } else { ~[] };\n         vec::push(variants, @{args: arg_tys, ctor_ty: ctor_ty,\n               name: v.node.name, id: local_def(v.node.id),\n@@ -1842,7 +1842,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n \n     // Check that it is possible to represent this enum:\n     let mut outer = true, did = local_def(id);\n-    if ty::type_structurally_contains(ccx.tcx, rty, {|sty|\n+    if ty::type_structurally_contains(ccx.tcx, rty, |sty| {\n         alt sty {\n           ty::ty_enum(id, _) if id == did {\n             if outer { outer = false; false }\n@@ -1887,7 +1887,7 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n                                              in constraint\");\n               }\n             }\n-            for operands.each {|operand|\n+            for operands.each |operand| {\n                 if !ast_util::is_constraint_arg(operand) {\n                     let s =\n                         \"constraint args must be slot variables or literals\";\n@@ -1910,9 +1910,9 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n fn check_constraints(fcx: @fn_ctxt, cs: ~[@ast::constr],\n                      args: ~[ast::arg]) {\n     let num_args = vec::len(args);\n-    for cs.each {|c|\n+    for cs.each |c| {\n         let mut c_args = ~[];\n-        for c.node.args.each {|a|\n+        for c.node.args.each |a| {\n             vec::push(c_args,\n                  // \"base\" should not occur in a fn type thing, as of\n                  // yet, b/c we don't allow constraints on the return type\n@@ -2098,7 +2098,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n             (sp, \"not enough type parameters provided for this item\");\n         fcx.infcx.next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map({ |aty| fcx.to_ty(aty) })\n+        pth.types.map(|aty| fcx.to_ty(aty))\n     };\n \n     let substs = {self_r: self_r, self_ty: none, tps: tps};\n@@ -2182,13 +2182,13 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n \n     ty::walk_regions_and_ty(\n         ccx.tcx, ty,\n-        { |r|\n+        |r| {\n             alt r {\n               ty::re_bound(_) { r_used = true; }\n               _ { }\n             }\n         },\n-        { |t|\n+        |t| {\n             alt ty::get(t).struct {\n               ty::ty_param(idx, _) { tps_used[idx] = true; }\n               _ { }\n@@ -2202,7 +2202,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n                    reference-parameterized type\");\n     }\n \n-    for tps_used.eachi { |i, b|\n+    for tps_used.eachi |i, b| {\n         if !b {\n             ccx.tcx.sess.span_err(\n                 span, #fmt[\"type parameter `%s` is unused\", *tps[i].ident]);\n@@ -2285,8 +2285,8 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n     } else {\n         require_same_types(\n             tcx, none, it.span, i_ty.ty, fty,\n-            {|| #fmt[\"intrinsic has wrong type: \\\n+            || #fmt[\"intrinsic has wrong type: \\\n                       expected `%s`\",\n-                     ty_to_str(ccx.tcx, fty)]});\n+                     ty_to_str(ccx.tcx, fty)]);\n     }\n }"}, {"sha": "e45c5f308eabe4dd609ae53f6045eae21dd1f51b", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -13,7 +13,7 @@ fn check_alt(fcx: @fn_ctxt,\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n-    for arms.each {|arm|\n+    for arms.each |arm| {\n         let pcx = {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n@@ -22,12 +22,12 @@ fn check_alt(fcx: @fn_ctxt,\n             pat_region: ty::re_scope(expr.id)\n         };\n \n-        for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n+        for arm.pats.each |p| { check_pat(pcx, p, pattern_ty);}\n     }\n     // Now typecheck the blocks.\n     let mut result_ty = fcx.infcx.next_ty_var();\n     let mut arm_non_bot = false;\n-    for arms.each {|arm|\n+    for arms.each |arm| {\n         alt arm.guard {\n           some(e) { check_expr_with(fcx, e, ty::mk_bool(tcx)); }\n           none { }\n@@ -79,7 +79,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             let vinfo =\n                 ty::enum_variant_with_id(\n                     tcx, v_def_ids.enm, v_def_ids.var);\n-            vinfo.args.map({ |t| ty::subst(tcx, expected_substs, t) })\n+            vinfo.args.map(|t| { ty::subst(tcx, expected_substs, t) })\n         };\n         let arg_len = arg_types.len(), subpats_len = alt subpats {\n             none { arg_len }\n@@ -96,8 +96,8 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                 tcx.sess.span_fatal(pat.span, s);\n             }\n \n-            do option::iter(subpats) {|pats|\n-                do vec::iter2(pats, arg_types) {|subpat, arg_ty|\n+            do option::iter(subpats) |pats| {\n+                do vec::iter2(pats, arg_types) |subpat, arg_ty| {\n                   check_pat(pcx, subpat, arg_ty);\n                 }\n             };\n@@ -143,7 +143,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         #debug[\"pat_range ending type: %?\", e_ty];\n         if !require_same_types(\n             tcx, some(fcx.infcx), pat.span, b_ty, e_ty,\n-            {|| \"mismatched types in range\" }) {\n+            || \"mismatched types in range\") {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n@@ -197,8 +197,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fn matches(name: ast::ident, f: ty::field) -> bool {\n             ret str::eq(*name, *f.ident);\n         }\n-        for fields.each {|f|\n-            alt vec::find(ex_fields, {|a|matches(f.ident, a)}) {\n+        for fields.each |f| {\n+            alt vec::find(ex_fields, |a| matches(f.ident, a)) {\n               some(field) {\n                 check_pat(pcx, f.pat, field.mt.ty);\n               }\n@@ -230,7 +230,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                       fields\", vec::len(ex_elts), e_count]);\n         }\n         let mut i = 0u;\n-        for elts.each {|elt|\n+        for elts.each |elt| {\n             check_pat(pcx, elt, ex_elts[i]);\n             i += 1u;\n         }"}, {"sha": "3cbdfe9819886ce194d2b36d5b4d7ea30e52d54d", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -105,7 +105,7 @@ class lookup {\n                 self.expr.span,\n                 \"multiple applicable methods in scope\");\n \n-            for self.candidates.eachi { |i, candidate|\n+            for self.candidates.eachi |i, candidate| {\n                 alt candidate.entry.origin {\n                   method_static(did) {\n                     self.report_static_candidate(i, did);\n@@ -163,7 +163,7 @@ class lookup {\n         let tcx = self.tcx();\n         let mut iface_bnd_idx = 0u; // count only iface bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n-        for vec::each(*bounds) {|bound|\n+        for vec::each(*bounds) |bound| {\n             let (iid, bound_substs) = alt bound {\n               ty::bound_copy | ty::bound_send | ty::bound_const {\n                 cont; /* ok */\n@@ -176,7 +176,7 @@ class lookup {\n             };\n \n             let ifce_methods = ty::iface_methods(tcx, iid);\n-            alt vec::position(*ifce_methods, {|m| m.ident == self.m_name}) {\n+            alt vec::position(*ifce_methods, |m| m.ident == self.m_name) {\n               none {\n                 /* check next bound */\n                 iface_bnd_idx += 1u;\n@@ -210,7 +210,7 @@ class lookup {\n         #debug[\"method_from_iface\"];\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n-        for ms.eachi {|i, m|\n+        for ms.eachi |i, m| {\n             if m.ident != self.m_name { cont; }\n \n             let m_fty = ty::mk_fn(self.tcx(), m.fty);\n@@ -246,7 +246,7 @@ class lookup {\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n \n-        for ms.each {|m|\n+        for ms.each |m| {\n             if m.ident != self.m_name { cont; }\n \n             if m.vis == ast::private && !self.include_private {\n@@ -296,10 +296,10 @@ class lookup {\n \n         #debug[\"method_from_scope\"];\n \n-        for list::each(impls_vecs) {|impls|\n-            for vec::each(*impls) {|im|\n+        for list::each(impls_vecs) |impls| {\n+            for vec::each(*impls) |im| {\n                 // Check whether this impl has a method with the right name.\n-                for im.methods.find({|m| m.ident == self.m_name}).each {|m|\n+                for im.methods.find(|m| m.ident == self.m_name).each |m| {\n \n                     // determine the `self` of the impl with fresh\n                     // variables for each parameter:"}, {"sha": "9350f5778047649913589ad932dd6014ee2df13a", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -55,7 +55,7 @@ fn visit_local(l: @ast::local, &&rcx: rcx, v: rvt) {\n     }\n \n     v.visit_ty(l.node.ty, rcx, v);\n-    for l.node.init.each { |i|\n+    for l.node.init.each |i| {\n         v.visit_expr(i.expr, rcx, v);\n     }\n }\n@@ -134,8 +134,8 @@ fn visit_node(id: ast::node_id, span: span, rcx: rcx) -> bool {\n     let e = rcx.errors_reported;\n     ty::walk_regions_and_ty(\n         tcx, ty,\n-        { |r| constrain_region(rcx, encl_region, span, r); },\n-        { |t| ty::type_has_regions(t) });\n+        |r| constrain_region(rcx, encl_region, span, r),\n+        |t| ty::type_has_regions(t));\n     ret (e == rcx.errors_reported);\n \n     fn constrain_region(rcx: rcx,"}, {"sha": "2231d9b320aa2c52390d385861fd627f83b22e27", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -12,25 +12,25 @@ fn replace_bound_regions_in_fn_ty(\n                                                   fn_ty: ty::fn_ty} {\n \n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n-    for self_ty.each { |t| vec::push(all_tys, t) }\n+    for self_ty.each |t| { vec::push(all_tys, t) }\n \n     #debug[\"replace_bound_regions_in_fn_ty(self_ty=%?, fn_ty=%s, all_tys=%?)\",\n-           self_ty.map({ |t| ty_to_str(tcx, t) }),\n+           self_ty.map(|t| ty_to_str(tcx, t)),\n            ty_to_str(tcx, ty::mk_fn(tcx, fn_ty)),\n-           all_tys.map({ |t| ty_to_str(tcx, t) })];\n+           all_tys.map(|t| ty_to_str(tcx, t))];\n     let _i = indenter();\n \n-    let isr = do create_bound_region_mapping(tcx, isr, all_tys) { |br|\n+    let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n         #debug[\"br=%?\", br];\n         mapf(br)\n     };\n-    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(fn_ty), { |t|\n+    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(fn_ty), |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n-    let t_self = self_ty.map({ |t| replace_bound_regions(tcx, isr, t) });\n+    let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n \n     #debug[\"result of replace_bound_regions_in_fn_ty: self_ty=%?, fn_ty=%s\",\n-           t_self.map({ |t| ty_to_str(tcx, t) }),\n+           t_self.map(|t| ty_to_str(tcx, t)),\n            ty_to_str(tcx, t_fn)];\n \n     ret {isr: isr,\n@@ -78,15 +78,15 @@ fn replace_bound_regions_in_fn_ty(\n         }\n \n         // For each type `ty` in `tys`...\n-        do tys.foldl(isr) { |isr, ty|\n+        do tys.foldl(isr) |isr, ty| {\n             let mut isr = isr;\n \n             // Using fold_regions is inefficient, because it\n             // constructs new types, but it avoids code duplication in\n             // terms of locating all the regions within the various\n             // kinds of types.  This had already caused me several\n             // bugs so I decided to switch over.\n-            do ty::fold_regions(tcx, ty) { |r, in_fn|\n+            do ty::fold_regions(tcx, ty) |r, in_fn| {\n                 if !in_fn { isr = append_isr(isr, to_r, r); }\n                 r\n             };\n@@ -104,7 +104,7 @@ fn replace_bound_regions_in_fn_ty(\n         isr: isr_alist,\n         ty: ty::t) -> ty::t {\n \n-        do ty::fold_regions(tcx, ty) { |r, in_fn|\n+        do ty::fold_regions(tcx, ty) |r, in_fn| {\n             alt r {\n               // As long as we are not within a fn() type, `&T` is\n               // mapped to the free region anon_r.  But within a fn"}, {"sha": "b5391d96a8c8e54bb1396f9128bacdf521238bd1", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -1,8 +1,8 @@\n import check::{fn_ctxt, impl_self_ty, methods};\n \n fn has_iface_bounds(tps: ~[ty::param_bounds]) -> bool {\n-    vec::any(tps, {|bs|\n-        vec::any(*bs, {|b|\n+    vec::any(tps, |bs| {\n+        vec::any(*bs, |b| {\n             alt b { ty::bound_iface(_) { true } _ { false } }\n         })\n     })\n@@ -13,8 +13,8 @@ fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                   allow_unsafe: bool) -> vtable_res {\n     let tcx = fcx.ccx.tcx;\n     let mut result = ~[], i = 0u;\n-    for substs.tps.each {|ty|\n-        for vec::each(*bounds[i]) {|bound|\n+    for substs.tps.each |ty| {\n+        for vec::each(*bounds[i]) |bound| {\n             alt bound {\n               ty::bound_iface(i_ty) {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n@@ -65,7 +65,7 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n     alt ty::get(ty).struct {\n       ty::ty_param(n, did) {\n         let mut n_bound = 0u;\n-        for vec::each(*tcx.ty_param_bounds.get(did.node)) { |bound|\n+        for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n             alt bound {\n               ty::bound_send | ty::bound_copy | ty::bound_const {\n                 /* ignore */\n@@ -88,7 +88,7 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n       ty::ty_iface(did, substs) if iface_id == did {\n         relate_iface_tys(fcx, sp, iface_ty, ty);\n         if !allow_unsafe {\n-            for vec::each(*ty::iface_methods(tcx, did)) {|m|\n+            for vec::each(*ty::iface_methods(tcx, did)) |m| {\n                 if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n                     tcx.sess.span_err(\n                         sp, \"a boxed iface with self types may not be \\\n@@ -107,9 +107,9 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n       _ {\n         let mut found = ~[];\n \n-        for list::each(isc) {|impls|\n+        for list::each(isc) |impls| {\n             /* For each impl in scope... */\n-                for vec::each(*impls) {|im|\n+            for vec::each(*impls) |im| {\n                     // im = one specific impl\n                     // find the iface that im implements (if any)\n                     let of_ty = alt ty::impl_iface(tcx, im.did) {\n@@ -189,7 +189,7 @@ fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: ~[ty::t],\n     alt check ty::get(iface_ty).struct {\n       ty::ty_iface(_, substs) {\n         vec::iter2(substs.tps, iface_tys,\n-                   {|a, b| demand::suptype(fcx, sp, a, b);});\n+                   |a, b| demand::suptype(fcx, sp, a, b));\n       }\n     }\n }"}, {"sha": "9b51a3cb98e6310f8d63061ea8a5eaf9290fdd28", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -41,7 +41,7 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n         alt fcx.opt_node_ty_substs(id) {\n           some(substs) {\n             let mut new_tps = ~[];\n-            for substs.tps.each {|subst|\n+            for substs.tps.each |subst| {\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n                   some(t) { vec::push(new_tps, t); }\n                   none { wbcx.success = false; ret none; }\n@@ -83,7 +83,7 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     alt e.node {\n       ast::expr_fn(_, decl, _, _) |\n       ast::expr_fn_block(decl, _, _) {\n-        do vec::iter(decl.inputs) {|input|\n+        do vec::iter(decl.inputs) |input| {\n             let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n \n             // Just in case we never constrained the mode to anything,\n@@ -176,7 +176,7 @@ fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n     visit.visit_block(blk, wbcx, visit);\n-    for decl.inputs.each {|arg|\n+    for decl.inputs.each |arg| {\n         resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n     }\n     ret wbcx.success;"}, {"sha": "a713ae675484110e2d63c03154760f924296ebbb", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -28,11 +28,11 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     // FIXME (#2592): hooking into the \"intrinsic\" root module is crude.\n     // There ought to be a better approach. Attributes?\n \n-    for crate.node.module.items.each {|crate_item|\n+    for crate.node.module.items.each |crate_item| {\n         if *crate_item.ident == \"intrinsic\" {\n             alt crate_item.node {\n               ast::item_mod(m) {\n-                for m.items.each {|intrinsic_item|\n+                for m.items.each |intrinsic_item| {\n                     alt intrinsic_item.node {\n                       ast::item_iface(_, _, _) {\n                         let def_id = { crate: ast::local_crate,\n@@ -53,8 +53,8 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     }\n \n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: {|a|convert(ccx, a)},\n-        visit_foreign_item: {|a|convert_foreign(ccx, a)}\n+        visit_item: |a|convert(ccx, a),\n+        visit_foreign_item: |a|convert_foreign(ccx, a)\n         with *visit::default_simple_visitor()\n     }));\n }\n@@ -102,14 +102,14 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n-    for variants.each {|variant|\n+    for variants.each |variant| {\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n         let result_ty = if vec::len(variant.node.args) == 0u {\n             enum_ty\n         } else {\n             let rs = type_rscope(rp);\n-            let args = variant.node.args.map({ |va|\n+            let args = variant.node.args.map(|va| {\n                 let arg_ty = ccx.to_ty(rs, va.ty);\n                 {mode: ast::expl(ast::by_copy), ty: arg_ty}\n             });\n@@ -137,15 +137,15 @@ fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n     let tcx = ccx.tcx;\n     alt check tcx.items.get(id) {\n       ast_map::node_item(@{node: ast::item_iface(_, rp, ms), _}, _) {\n-        store_methods::<ast::ty_method>(ccx, id, ms, {|m|\n+        store_methods::<ast::ty_method>(ccx, id, ms, |m| {\n             ty_of_ty_method(ccx, m, rp)\n         });\n       }\n       ast_map::node_item(@{node: ast::item_class(_,_,its,_,_,rp), _}, _) {\n         let (_,ms) = split_class_items(its);\n         // All methods need to be stored, since lookup_method\n         // relies on the same method cache for self-calls\n-        store_methods::<@ast::method>(ccx, id, ms, {|m|\n+        store_methods::<@ast::method>(ccx, id, ms, |m| {\n             ty_of_method(ccx, m, rp)\n         });\n       }\n@@ -196,7 +196,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n     let if_fty = {\n-        let dummy_tps = do vec::from_fn((*if_m.tps).len()) { |i|\n+        let dummy_tps = do vec::from_fn((*if_m.tps).len()) |i| {\n             // hack: we don't know the def id of the impl tp, but it\n             // is not important for unification\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n@@ -211,13 +211,13 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n     };\n     require_same_types(\n         tcx, none, sp, impl_fty, if_fty,\n-        {|| \"method `\" + *if_m.ident + \"` has an incompatible type\"});\n+        || \"method `\" + *if_m.ident + \"` has an incompatible type\");\n     ret;\n \n     // Replaces bound references to the self region with `with_r`.\n     fn replace_bound_self(tcx: ty::ctxt, ty: ty::t,\n                           with_r: ty::region) -> ty::t {\n-        do ty::fold_regions(tcx, ty) { |r, _in_fn|\n+        do ty::fold_regions(tcx, ty) |r, _in_fn| {\n             if r == ty::re_bound(ty::br_self) {with_r} else {r}\n         }\n     }\n@@ -235,8 +235,8 @@ fn check_methods_against_iface(ccx: @crate_ctxt,\n     if did.crate == ast::local_crate {\n         ensure_iface_methods(ccx, did.node);\n     }\n-    for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n-        alt vec::find(ms, {|m| if_m.ident == m.mty.ident}) {\n+    for vec::each(*ty::iface_methods(tcx, did)) |if_m| {\n+        alt vec::find(ms, |m| if_m.ident == m.mty.ident) {\n           some({mty: m, id, span}) {\n             if m.purity != if_m.purity {\n                 ccx.tcx.sess.span_err(\n@@ -276,7 +276,7 @@ fn convert_methods(ccx: @crate_ctxt,\n                    self_ty: ty::t) -> ~[converted_method] {\n \n     let tcx = ccx.tcx;\n-    do vec::map(ms) { |m|\n+    do vec::map(ms) |m| {\n         write_ty_to_tcx(tcx, m.self_id, self_ty);\n         let bounds = ty_param_bounds(ccx, m.tps);\n         let mty = ty_of_method(ccx, m, rp);\n@@ -313,7 +313,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                            ty: selfty});\n \n         let cms = convert_methods(ccx, ms, rp, i_bounds, selfty);\n-        for ifce.each { |t|\n+        for ifce.each |t| {\n             check_methods_against_iface(ccx, tps, rp, selfty, t, cms);\n         }\n       }\n@@ -330,8 +330,8 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         // Write the ctor type\n-        let t_args = ctor.node.dec.inputs.map({|a|\n-                           ty_of_arg(ccx, type_rscope(rp), a, none)});\n+        let t_args = ctor.node.dec.inputs.map(\n+            |a| ty_of_arg(ccx, type_rscope(rp), a, none) );\n         let t_res = ty::mk_class(tcx, local_def(it.id),\n                                  {self_r: alt rp {\n                        ast::rp_none { none }\n@@ -350,7 +350,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                           {bounds: tpt.bounds,\n                            rp: rp,\n                            ty: t_ctor});\n-        do option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) |dtor| {\n             // Write the dtor type\n             let t_dtor = ty::mk_fn(\n                 tcx,\n@@ -366,13 +366,13 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n \n         // Write the type of each of the members\n         let (fields, methods) = split_class_items(members);\n-        for fields.each {|f|\n+        for fields.each |f| {\n            convert_class_item(ccx, rp, tpt.bounds, f);\n         }\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n         let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n-        for ifaces.each { |ifce|\n+        for ifaces.each |ifce| {\n             check_methods_against_iface(ccx, tps, rp, selfty, ifce, cms);\n \n             // FIXME #2434---this is somewhat bogus, but it seems that\n@@ -553,7 +553,7 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n \n     fn compute_bounds(ccx: @crate_ctxt,\n                       param: ast::ty_param) -> ty::param_bounds {\n-        @do vec::flat_map(*param.bounds) { |b|\n+        @do vec::flat_map(*param.bounds) |b| {\n             alt b {\n               ast::bound_send { ~[ty::bound_send] }\n               ast::bound_copy { ~[ty::bound_copy] }\n@@ -576,7 +576,7 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n         }\n     }\n \n-    @do params.map { |param|\n+    @do params.map |param| {\n         alt ccx.tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none {\n@@ -595,7 +595,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n \n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = decl.inputs.map({ |a| ty_of_arg(ccx, rb, a, none) });\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, a, none) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n     let t_fn = ty::mk_fn(ccx.tcx, {purity: decl.purity,\n@@ -615,7 +615,7 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n     let mut i = 0u;\n     let bounds = ty_param_bounds(ccx, atps);\n     {bounds: bounds,\n-     params: vec::map(atps, {|atp|\n+     params: vec::map(atps, |atp| {\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n          i += 1u;\n          t"}, {"sha": "ba4d9152228ad4bbc86457d2aa7e3786660829f8", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 124, "deletions": 142, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -355,31 +355,31 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent({|| cx.commit({|| sub(cx).tys(a, b) }) }).to_ures()\n+    indent(|| cx.commit(|| sub(cx).tys(a, b) ) ).to_ures()\n }\n \n fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent({|| cx.probe({|| sub(cx).tys(a, b) }) }).to_ures()\n+    indent(|| cx.probe(|| sub(cx).tys(a, b) ) ).to_ures()\n }\n \n fn mk_subr(cx: infer_ctxt, a: ty::region, b: ty::region) -> ures {\n     #debug[\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent({|| cx.commit({|| sub(cx).regions(a, b) }) }).to_ures()\n+    indent(|| cx.commit(|| sub(cx).regions(a, b) ) ).to_ures()\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent({|| cx.commit({|| cx.eq_tys(a, b) }) }).to_ures()\n+    indent(|| cx.commit(|| cx.eq_tys(a, b) ) ).to_ures()\n }\n \n fn mk_assignty(cx: infer_ctxt, anmnt: assignment,\n                a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_assignty(%? / %s <: %s)\",\n            anmnt, a.to_str(cx), b.to_str(cx)];\n-    indent({|| cx.commit({||\n+    indent(|| cx.commit(||\n         cx.assign_tys(anmnt, a, b)\n-    }) }).to_ures()\n+    ) ).to_ures()\n }\n \n fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n@@ -392,9 +392,9 @@ fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n     // used in method lookup, and there must be exactly one match or an\n     // error is reported. Still, it should be fixed.\n \n-    indent({|| cx.probe({||\n+    indent(|| cx.probe(||\n         cx.assign_tys(anmnt, a, b)\n-    }) }).to_ures()\n+    ) ).to_ures()\n }\n \n // See comment on the type `resolve_state` below\n@@ -418,7 +418,7 @@ fn resolve_deep(cx: infer_ctxt, a: ty::t, force_vars: force_level)\n impl methods for ures {\n     fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n         -> result<T,ty::type_err> {\n-        self.chain({|_i| f() })\n+        self.chain(|_i| f())\n     }\n }\n \n@@ -431,7 +431,7 @@ impl methods<T:copy> for cres<T> {\n     }\n \n     fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n-        do self.chain {|s|\n+        do self.chain |s| {\n             if s == t {\n                 self\n             } else {\n@@ -520,7 +520,7 @@ impl of st for ty::t {\n \n impl of st for ty::region {\n     fn sub(infcx: infer_ctxt, &&b: ty::region) -> ures {\n-        sub(infcx).regions(self, b).chain({|_r| ok(()) })\n+        sub(infcx).regions(self, b).chain(|_r| ok(()))\n     }\n \n     fn lub(infcx: infer_ctxt, &&b: ty::region) -> cres<ty::region> {\n@@ -605,7 +605,7 @@ impl methods for infer_ctxt {\n     }\n \n     fn next_ty_vars(n: uint) -> ~[ty::t] {\n-        vec::from_fn(n, {|_i| self.next_ty_var() })\n+        vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n     fn next_ty_var_integral_id() -> tvi_vid {\n@@ -706,7 +706,7 @@ impl unify_methods for infer_ctxt {\n             ok(b)\n           }\n           (some(v_a), some(v_b)) {\n-            do merge_op(v_a, v_b).chain {|v|\n+            do merge_op(v_a, v_b).chain |v| {\n                 ok(some(v))\n             }\n           }\n@@ -719,11 +719,11 @@ impl unify_methods for infer_ctxt {\n         glb: fn(V,V) -> cres<V>) -> cres<bounds<V>> {\n \n         let _r = indenter();\n-        do self.merge_bnd(a.ub, b.ub, glb).chain {|ub|\n+        do self.merge_bnd(a.ub, b.ub, glb).chain |ub| {\n             #debug[\"glb of ubs %s and %s is %s\",\n                    a.ub.to_str(self), b.ub.to_str(self),\n                    ub.to_str(self)];\n-            do self.merge_bnd(a.lb, b.lb, lub).chain {|lb|\n+            do self.merge_bnd(a.lb, b.lb, lub).chain |lb| {\n                 #debug[\"lub of lbs %s and %s is %s\",\n                        a.lb.to_str(self), b.lb.to_str(self),\n                        lb.to_str(self)];\n@@ -771,22 +771,22 @@ impl unify_methods for infer_ctxt {\n         // them explicitly gives the type inferencer more\n         // information and helps to produce tighter bounds\n         // when necessary.\n-        do indent {||\n-        do self.bnds(a.lb, b.ub).then {||\n-        do self.bnds(b.lb, a.ub).then {||\n-        do self.merge_bnd(a.ub, b.ub, {|x, y| x.glb(self, y)}).chain {|ub|\n-        do self.merge_bnd(a.lb, b.lb, {|x, y| x.lub(self, y)}).chain {|lb|\n+        do indent || {\n+        do self.bnds(a.lb, b.ub).then || {\n+        do self.bnds(b.lb, a.ub).then || {\n+        do self.merge_bnd(a.ub, b.ub, |x, y| x.glb(self, y) ).chain |ub| {\n+        do self.merge_bnd(a.lb, b.lb, |x, y| x.lub(self, y) ).chain |lb| {\n             let bnds = {lb: lb, ub: ub};\n             #debug[\"merge(%s): bnds=%s\",\n                    v_id.to_str(),\n                    bnds.to_str(self)];\n \n             // the new bounds must themselves\n             // be relatable:\n-            do self.bnds(bnds.lb, bnds.ub).then {||\n+            do self.bnds(bnds.lb, bnds.ub).then || {\n                 self.set(vb, v_id, root(bnds, rank));\n                 uok()\n-        }\n+            }\n         }}}}}\n     }\n \n@@ -812,7 +812,7 @@ impl unify_methods for infer_ctxt {\n         // see if we can make those types subtypes.\n         alt (a_bounds.ub, b_bounds.lb) {\n           (some(a_ub), some(b_lb)) {\n-            let r = self.try({|| a_ub.sub(self, b_lb) });\n+            let r = self.try(|| a_ub.sub(self, b_lb));\n             alt r {\n               ok(()) { ret result::ok(()); }\n               err(_) { /*fallthrough */ }\n@@ -835,17 +835,13 @@ impl unify_methods for infer_ctxt {\n             // i.e., b should redirect to a.\n             self.set(vb, b_id, redirect(a_id));\n             self.set_var_to_merged_bounds(\n-                vb, a_id, a_bounds, b_bounds, nde_a.rank).then({||\n-                uok()\n-            })\n+                vb, a_id, a_bounds, b_bounds, nde_a.rank).then(|| uok() )\n         } else if nde_a.rank < nde_b.rank {\n             #debug[\"vars(): b has smaller rank\"];\n             // b has greater rank, so a should redirect to b.\n             self.set(vb, a_id, redirect(b_id));\n             self.set_var_to_merged_bounds(\n-                vb, b_id, a_bounds, b_bounds, nde_b.rank).then({||\n-                uok()\n-            })\n+                vb, b_id, a_bounds, b_bounds, nde_b.rank).then(|| uok() )\n         } else {\n             #debug[\"vars(): a and b have equal rank\"];\n             assert nde_a.rank == nde_b.rank;\n@@ -854,9 +850,8 @@ impl unify_methods for infer_ctxt {\n             // to a and increment a's rank.\n             self.set(vb, b_id, redirect(a_id));\n             self.set_var_to_merged_bounds(\n-                vb, a_id, a_bounds, b_bounds, nde_a.rank + 1u).then({||\n-                uok()\n-            })\n+                vb, a_id, a_bounds, b_bounds, nde_a.rank + 1u\n+            ).then(|| uok() )\n         }\n     }\n \n@@ -991,7 +986,7 @@ impl unify_methods for infer_ctxt {\n         let actual_arg_len = vec::len(actual_constr.node.args);\n         if expected_arg_len != actual_arg_len { ret err_res; }\n         let mut i = 0u;\n-        for expected.node.args.each {|a|\n+        for expected.node.args.each |a| {\n             let actual = actual_constr.node.args[i];\n             alt a.node {\n               ast::carg_base {\n@@ -1026,7 +1021,7 @@ impl unify_methods for infer_ctxt {\n         a: bound<T>, b: bound<T>) -> ures {\n \n         #debug(\"bnds(%s <: %s)\", a.to_str(self), b.to_str(self));\n-        do indent {||\n+        do indent || {\n             alt (a, b) {\n               (none, none) |\n               (some(_), none) |\n@@ -1044,7 +1039,7 @@ impl unify_methods for infer_ctxt {\n         as: ~[@ty::type_constr], bs: ~[@ty::type_constr]) -> ures {\n \n         if check vec::same_length(as, bs) {\n-            do iter_vec2(as, bs) {|a,b|\n+            do iter_vec2(as, bs) |a,b| {\n                 self.constrs(a, b)\n             }\n         } else {\n@@ -1053,24 +1048,24 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn sub_tys(a: ty::t, b: ty::t) -> ures {\n-        sub(self).tys(a, b).chain({|_t| ok(()) })\n+        sub(self).tys(a, b).chain(|_t| ok(()) )\n     }\n \n     fn sub_regions(a: ty::region, b: ty::region) -> ures {\n-        sub(self).regions(a, b).chain({|_t| ok(()) })\n+        sub(self).regions(a, b).chain(|_t| ok(()) )\n     }\n \n     fn eq_tys(a: ty::t, b: ty::t) -> ures {\n-        self.sub_tys(a, b).then({||\n+        self.sub_tys(a, b).then(|| {\n             self.sub_tys(b, a)\n         })\n     }\n \n     fn eq_regions(a: ty::region, b: ty::region) -> ures {\n         #debug[\"eq_regions(%s, %s)\",\n                a.to_str(self), b.to_str(self)];\n-        do indent {||\n-            do self.sub_regions(a, b).then {||\n+        do indent || {\n+            do self.sub_regions(a, b).then || {\n                 self.sub_regions(b, a)\n             }\n         }\n@@ -1134,7 +1129,7 @@ impl methods for resolve_state {\n         // allow us to pass back errors in any useful way.\n \n         assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n-        let rty = indent({|| self.resolve1(typ) });\n+        let rty = indent(|| self.resolve1(typ) );\n         assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n         alt self.err {\n           none {\n@@ -1166,9 +1161,9 @@ impl methods for resolve_state {\n               _ {\n                 ty::fold_regions_and_ty(\n                     self.infcx.tcx, typ,\n-                    { |r| self.resolve_region(r) },\n-                    { |t| self.resolve_if_deep(t) },\n-                    { |t| self.resolve_if_deep(t) })\n+                    |r| self.resolve_region(r),\n+                    |t| self.resolve_if_deep(t),\n+                    |t| self.resolve_if_deep(t))\n               }\n             }\n         })\n@@ -1462,11 +1457,11 @@ impl assignment for infer_ctxt {\n                anmnt, a.to_str(self), nr_b.to_str(self),\n                r_b.to_str(self)];\n \n-        do indent {||\n-            do self.sub_tys(a, nr_b).then {||\n+        do indent || {\n+            do self.sub_tys(a, nr_b).then || {\n                 let r_a = ty::re_scope(anmnt.borrow_scope);\n                 #debug[\"anmnt=%?\", anmnt];\n-                do sub(self).contraregions(r_a, r_b).chain {|_r|\n+                do sub(self).contraregions(r_a, r_b).chain |_r| {\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n                     #debug[\"borrowing expression #%?\", anmnt];\n@@ -1564,7 +1559,7 @@ fn super_substs<C:combine>(\n             ok(none)\n           }\n           (some(a), some(b)) {\n-            do infcx.eq_regions(a, b).then {||\n+            do infcx.eq_regions(a, b).then || {\n                 ok(some(a))\n             }\n           }\n@@ -1582,10 +1577,10 @@ fn super_substs<C:combine>(\n         }\n     }\n \n-    do self.tps(a.tps, b.tps).chain { |tps|\n-        do self.self_tys(a.self_ty, b.self_ty).chain { |self_ty|\n-            do eq_opt_regions(self.infcx(), a.self_r, b.self_r).chain {\n-                |self_r|\n+    do self.tps(a.tps, b.tps).chain |tps| {\n+        do self.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n+            do eq_opt_regions(self.infcx(), a.self_r, b.self_r).chain\n+                |self_r| {\n                 ok({self_r: self_r, self_ty: self_ty, tps: tps})\n             }\n         }\n@@ -1601,11 +1596,9 @@ fn super_tps<C:combine>(\n     // variance.\n \n     if check vec::same_length(as, bs) {\n-        iter_vec2(as, bs, {|a, b|\n+        iter_vec2(as, bs, |a, b| {\n             self.infcx().eq_tys(a, b)\n-        }).then({||\n-            ok(as)\n-        })\n+        }).then(|| ok(as) )\n     } else {\n         err(ty::terr_ty_param_size(bs.len(), as.len()))\n     }\n@@ -1622,9 +1615,7 @@ fn super_self_tys<C:combine>(\n         ok(none)\n       }\n       (some(a), some(b)) {\n-        self.infcx().eq_tys(a, b).then({||\n-            ok(some(a))\n-        })\n+        self.infcx().eq_tys(a, b).then(|| ok(some(a)) )\n       }\n       (none, some(_)) |\n       (some(_), none) {\n@@ -1640,11 +1631,9 @@ fn super_flds<C:combine>(\n     self: C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n     if a.ident == b.ident {\n-        self.mts(a.mt, b.mt).chain({|mt|\n-            ok({ident: a.ident, mt: mt})\n-        }).chain_err({|e|\n-            err(ty::terr_in_field(@e, a.ident))\n-        })\n+        self.mts(a.mt, b.mt)\n+            .chain(|mt| ok({ident: a.ident, mt: mt}) )\n+            .chain_err(|e| err(ty::terr_in_field(@e, a.ident)) )\n     } else {\n         err(ty::terr_record_fields(b.ident, a.ident))\n     }\n@@ -1662,8 +1651,8 @@ fn super_args<C:combine>(\n     self: C, a: ty::arg, b: ty::arg)\n     -> cres<ty::arg> {\n \n-    do self.modes(a.mode, b.mode).chain {|m|\n-        do self.contratys(a.ty, b.ty).chain {|t|\n+    do self.modes(a.mode, b.mode).chain |m| {\n+        do self.contratys(a.ty, b.ty).chain |t| {\n             ok({mode: m, ty: t})\n         }\n     }\n@@ -1675,7 +1664,7 @@ fn super_vstores<C:combine>(\n \n     alt (a, b) {\n       (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) {\n-        do self.contraregions(a_r, b_r).chain {|r|\n+        do self.contraregions(a_r, b_r).chain |r| {\n             ok(ty::vstore_slice(r))\n         }\n       }\n@@ -1697,17 +1686,17 @@ fn super_fns<C:combine>(\n                           b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n \n         if check vec::same_length(a_args, b_args) {\n-            map_vec2(a_args, b_args, {|a, b| self.args(a, b) })\n+            map_vec2(a_args, b_args, |a, b| self.args(a, b) )\n         } else {\n             err(ty::terr_arg_count)\n         }\n     }\n \n-    do self.protos(a_f.proto, b_f.proto).chain {|p|\n-        do self.ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n-            do argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n-                do self.tys(a_f.output, b_f.output).chain {|output|\n-                    do self.purities(a_f.purity, b_f.purity).chain {|purity|\n+    do self.protos(a_f.proto, b_f.proto).chain |p| {\n+        do self.ret_styles(a_f.ret_style, b_f.ret_style).chain |rs| {\n+            do argvecs(self, a_f.inputs, b_f.inputs).chain |inputs| {\n+                do self.tys(a_f.output, b_f.output).chain |output| {\n+                    do self.purities(a_f.purity, b_f.purity).chain |purity| {\n                     // FIXME: uncomment if #2588 doesn't get accepted:\n                     // self.infcx().constrvecs(a_f.constraints,\n                     //                         b_f.constraints).then {||\n@@ -1744,18 +1733,18 @@ fn super_tys<C:combine>(\n \n       // Have to handle these first\n       (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) {\n-        self.infcx().vars_integral(self.infcx().tvib, a_id, b_id).then({||\n-            ok(a) })\n+        self.infcx().vars_integral(self.infcx().tvib, a_id, b_id)\n+            .then(|| ok(a) )\n       }\n       (ty::ty_var_integral(a_id), ty::ty_int(_)) |\n       (ty::ty_var_integral(a_id), ty::ty_uint(_)) {\n-        self.infcx().vart_integral(self.infcx().tvib, a_id, b).then({||\n-            ok(a) })\n+        self.infcx().vart_integral(self.infcx().tvib, a_id, b)\n+            .then(|| ok(a) )\n       }\n       (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n       (ty::ty_uint(_), ty::ty_var_integral(b_id)) {\n-        self.infcx().tvar_integral(self.infcx().tvib, a, b_id).then({||\n-            ok(a) })\n+        self.infcx().tvar_integral(self.infcx().tvib, a, b_id)\n+            .then(|| ok(a) )\n       }\n \n       (ty::ty_int(_), _) |\n@@ -1787,102 +1776,99 @@ fn super_tys<C:combine>(\n \n       (ty::ty_enum(a_id, a_substs), ty::ty_enum(b_id, b_substs))\n       if a_id == b_id {\n-        do self.substs(a_substs, b_substs).chain {|tps|\n+        do self.substs(a_substs, b_substs).chain |tps| {\n             ok(ty::mk_enum(tcx, a_id, tps))\n         }\n       }\n \n       (ty::ty_iface(a_id, a_substs), ty::ty_iface(b_id, b_substs))\n       if a_id == b_id {\n-        do self.substs(a_substs, b_substs).chain {|substs|\n+        do self.substs(a_substs, b_substs).chain |substs| {\n             ok(ty::mk_iface(tcx, a_id, substs))\n         }\n       }\n \n       (ty::ty_class(a_id, a_substs), ty::ty_class(b_id, b_substs))\n       if a_id == b_id {\n-        do self.substs(a_substs, b_substs).chain {|substs|\n+        do self.substs(a_substs, b_substs).chain |substs| {\n             ok(ty::mk_class(tcx, a_id, substs))\n         }\n       }\n \n       (ty::ty_box(a_mt), ty::ty_box(b_mt)) {\n-        do self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain |mt| {\n             ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n       (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) {\n-        do self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain |mt| {\n             ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n       (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) {\n-        do self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain |mt| {\n             ok(ty::mk_vec(tcx, mt))\n         }\n       }\n \n       (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n-        do self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain |mt| {\n             ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n \n       (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n-        do self.contraregions(a_r, b_r).chain {|r|\n-            do self.mts(a_mt, b_mt).chain {|mt|\n+        do self.contraregions(a_r, b_r).chain |r| {\n+            do self.mts(a_mt, b_mt).chain |mt| {\n                 ok(ty::mk_rptr(tcx, r, mt))\n             }\n         }\n       }\n \n       (ty::ty_evec(a_mt, vs_a), ty::ty_evec(b_mt, vs_b)) {\n-        do self.mts(a_mt, b_mt).chain {|mt|\n-            do self.vstores(ty::terr_vec, vs_a, vs_b).chain {|vs|\n+        do self.mts(a_mt, b_mt).chain |mt| {\n+            do self.vstores(ty::terr_vec, vs_a, vs_b).chain |vs| {\n                 ok(ty::mk_evec(tcx, mt, vs))\n             }\n         }\n       }\n \n       (ty::ty_estr(vs_a), ty::ty_estr(vs_b)) {\n-        do self.vstores(ty::terr_str, vs_a, vs_b).chain {|vs|\n+        do self.vstores(ty::terr_str, vs_a, vs_b).chain |vs| {\n             ok(ty::mk_estr(tcx,vs))\n         }\n       }\n \n       (ty::ty_rec(as), ty::ty_rec(bs)) {\n         if check vec::same_length(as, bs) {\n-            map_vec2(as, bs, {|a,b|\n+            map_vec2(as, bs, |a,b| {\n                 self.flds(a, b)\n-            }).chain({|flds|\n-                ok(ty::mk_rec(tcx, flds))\n-            })\n+            }).chain(|flds| ok(ty::mk_rec(tcx, flds)) )\n         } else {\n             err(ty::terr_record_size(bs.len(), as.len()))\n         }\n       }\n \n       (ty::ty_tup(as), ty::ty_tup(bs)) {\n         if check vec::same_length(as, bs) {\n-            map_vec2(as, bs, {|a, b| self.tys(a, b) }).chain({|ts|\n-                ok(ty::mk_tup(tcx, ts))\n-            })\n+            map_vec2(as, bs, |a, b| self.tys(a, b) )\n+                .chain(|ts| ok(ty::mk_tup(tcx, ts)) )\n         } else {\n             err(ty::terr_tuple_size(bs.len(), as.len()))\n         }\n       }\n \n       (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n-        do self.fns(a_fty, b_fty).chain {|fty|\n+        do self.fns(a_fty, b_fty).chain |fty| {\n             ok(ty::mk_fn(tcx, fty))\n         }\n       }\n \n       (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n-        do self.tys(a_t, b_t).chain {|t|\n-            do self.infcx().constrvecs(a_constrs, b_constrs).then {||\n+        do self.tys(a_t, b_t).chain |t| {\n+            do self.infcx().constrvecs(a_constrs, b_constrs).then || {\n                 ok(ty::mk_constr(tcx, t, a_constrs))\n             }\n         }\n@@ -1911,25 +1897,25 @@ impl of combine for sub {\n                self.tag(),\n                a.to_str(self.infcx()),\n                b.to_str(self.infcx())];\n-        do indent {||\n+        do indent || {\n             alt (a, b) {\n               (ty::re_var(a_id), ty::re_var(b_id)) {\n-                do self.infcx().vars(self.rb, a_id, b_id).then {||\n+                do self.infcx().vars(self.rb, a_id, b_id).then || {\n                     ok(a)\n                 }\n               }\n               (ty::re_var(a_id), _) {\n-                  do self.infcx().vart(self.rb, a_id, b).then {||\n+                do self.infcx().vart(self.rb, a_id, b).then || {\n                       ok(a)\n                   }\n               }\n               (_, ty::re_var(b_id)) {\n-                  do self.infcx().tvar(self.rb, a, b_id).then {||\n+                  do self.infcx().tvar(self.rb, a, b_id).then || {\n                       ok(a)\n                   }\n               }\n               _ {\n-                do self.lub().regions(a, b).compare(b) {||\n+                  do self.lub().regions(a, b).compare(b) || {\n                     ty::terr_regions_differ(b, a)\n                 }\n               }\n@@ -1948,29 +1934,29 @@ impl of combine for sub {\n           m_mutbl {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n-            self.infcx().eq_tys(a.ty, b.ty).then({|| ok(a) })\n+            self.infcx().eq_tys(a.ty, b.ty).then(|| ok(a) )\n           }\n           m_imm | m_const {\n             // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).chain({|_t| ok(a) })\n+            self.tys(a.ty, b.ty).chain(|_t| ok(a) )\n           }\n         }\n     }\n \n     fn protos(a: ast::proto, b: ast::proto) -> cres<ast::proto> {\n-        self.lub().protos(a, b).compare(b, {||\n+        self.lub().protos(a, b).compare(b, || {\n             ty::terr_proto_mismatch(b, a)\n         })\n     }\n \n     fn purities(f1: purity, f2: purity) -> cres<purity> {\n-        self.lub().purities(f1, f2).compare(f2, {||\n+        self.lub().purities(f1, f2).compare(f2, || {\n             ty::terr_purity_mismatch(f2, f1)\n         })\n     }\n \n     fn ret_styles(a: ret_style, b: ret_style) -> cres<ret_style> {\n-        self.lub().ret_styles(a, b).compare(b, {||\n+        self.lub().ret_styles(a, b).compare(b, || {\n             ty::terr_ret_style_mismatch(b, a)\n         })\n     }\n@@ -1979,19 +1965,19 @@ impl of combine for sub {\n         #debug(\"%s.tys(%s, %s)\", self.tag(),\n                a.to_str(*self), b.to_str(*self));\n         if a == b { ret ok(a); }\n-        do indent {||\n+        do indent || {\n             alt (ty::get(a).struct, ty::get(b).struct) {\n               (ty::ty_bot, _) {\n                 ok(a)\n               }\n               (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-                self.infcx().vars(self.tvb, a_id, b_id).then({|| ok(a) })\n+                self.infcx().vars(self.tvb, a_id, b_id).then(|| ok(a) )\n               }\n               (ty::ty_var(a_id), _) {\n-                self.infcx().vart(self.tvb, a_id, b).then({|| ok(a) })\n+                self.infcx().vart(self.tvb, a_id, b).then(|| ok(a) )\n               }\n               (_, ty::ty_var(b_id)) {\n-                self.infcx().tvar(self.tvb, a, b_id).then({|| ok(a) })\n+                self.infcx().tvar(self.tvb, a, b_id).then(|| ok(a) )\n               }\n               (_, ty::ty_bot) {\n                 err(ty::terr_sorts(b, a))\n@@ -2012,7 +1998,7 @@ impl of combine for sub {\n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let {fn_ty: a_fn_ty, _} = {\n-            do replace_bound_regions_in_fn_ty(self.tcx, @nil, none, a) { |br|\n+            do replace_bound_regions_in_fn_ty(self.tcx, @nil, none, a) |br| {\n                 // N.B.: The name of the bound region doesn't have\n                 // anything to do with the region variable that's created\n                 // for it.  The only thing we're doing with `br` here is\n@@ -2028,7 +2014,7 @@ impl of combine for sub {\n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let {fn_ty: b_fn_ty, _} = {\n-            do replace_bound_regions_in_fn_ty(self.tcx, @nil, none, b) { |br|\n+            do replace_bound_regions_in_fn_ty(self.tcx, @nil, none, b) |br| {\n                 // FIXME: eventually re_skolemized (issue #2263)\n                 ty::re_bound(br)\n             }\n@@ -2094,18 +2080,16 @@ impl of combine for lub {\n \n         alt m {\n           m_imm | m_const {\n-            self.tys(a.ty, b.ty).chain({|t|\n-                ok({ty: t, mutbl: m})\n-            })\n+            self.tys(a.ty, b.ty).chain(|t| ok({ty: t, mutbl: m}) )\n           }\n \n           m_mutbl {\n-            self.infcx().try({||\n-                self.infcx().eq_tys(a.ty, b.ty).then({||\n+            self.infcx().try(|| {\n+                self.infcx().eq_tys(a.ty, b.ty).then(|| {\n                     ok({ty: a.ty, mutbl: m})\n                 })\n-            }).chain_err({|_e|\n-                self.tys(a.ty, b.ty).chain({|t|\n+            }).chain_err(|_e| {\n+                self.tys(a.ty, b.ty).chain(|t| {\n                     ok({ty: t, mutbl: m_const})\n                 })\n             })\n@@ -2160,7 +2144,7 @@ impl of combine for lub {\n                a.to_str(self.infcx()),\n                b.to_str(self.infcx())];\n \n-        do indent {||\n+        do indent || {\n             alt (a, b) {\n               (ty::re_static, _) | (_, ty::re_static) {\n                 ok(ty::re_static) // nothing lives longer than static\n@@ -2273,17 +2257,17 @@ impl of combine for glb {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n           (m_mutbl, m_const) {\n-            sub(*self).tys(a.ty, b.ty).chain({|_t|\n+            sub(*self).tys(a.ty, b.ty).chain(|_t| {\n                 ok({ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_const, m_mutbl) {\n-            sub(*self).tys(b.ty, a.ty).chain({|_t|\n+            sub(*self).tys(b.ty, a.ty).chain(|_t| {\n                 ok({ty: b.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_mutbl, m_mutbl) {\n-            self.infcx().eq_tys(a.ty, b.ty).then({||\n+            self.infcx().eq_tys(a.ty, b.ty).then(|| {\n                 ok({ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n@@ -2293,15 +2277,15 @@ impl of combine for glb {\n           (m_imm, m_const) |\n           (m_const, m_imm) |\n           (m_imm, m_imm) {\n-            self.tys(a.ty, b.ty).chain({|t|\n+            self.tys(a.ty, b.ty).chain(|t| {\n                 ok({ty: t, mutbl: m_imm})\n             })\n           }\n \n           // If both sides are const, then we can use GLB of both\n           // sides and mutbl of only `m_const`.\n           (m_const, m_const) {\n-            self.tys(a.ty, b.ty).chain({|t|\n+            self.tys(a.ty, b.ty).chain(|t| {\n                 ok({ty: t, mutbl: m_const})\n             })\n           }\n@@ -2357,7 +2341,7 @@ impl of combine for glb {\n                a.to_str(self.infcx()),\n                b.to_str(self.infcx())];\n \n-        do indent {||\n+        do indent || {\n             alt (a, b) {\n               (ty::re_static, r) | (r, ty::re_static) {\n                 // static lives longer than everything else\n@@ -2495,25 +2479,25 @@ fn lattice_tys<L:lattice_ops combine>(\n            a.to_str(self.infcx()),\n            b.to_str(self.infcx()));\n     if a == b { ret ok(a); }\n-    do indent {||\n+    do indent || {\n         alt (ty::get(a).struct, ty::get(b).struct) {\n           (ty::ty_bot, _) { self.ty_bot(b) }\n           (_, ty::ty_bot) { self.ty_bot(a) }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) {\n             lattice_vars(self, self.infcx().tvb,\n                          a, a_id, b_id,\n-                         {|x, y| self.tys(x, y) })\n+                         |x, y| self.tys(x, y) )\n           }\n \n           (ty::ty_var(a_id), _) {\n             lattice_var_t(self, self.infcx().tvb, a_id, b,\n-                          {|x, y| self.tys(x, y) })\n+                          |x, y| self.tys(x, y) )\n           }\n \n           (_, ty::ty_var(b_id)) {\n             lattice_var_t(self, self.infcx().tvb, b_id, a,\n-                          {|x, y| self.tys(x, y) })\n+                          |x, y| self.tys(x, y) )\n           }\n           _ {\n             super_tys(self, a, b)\n@@ -2530,13 +2514,13 @@ fn lattice_rvars<L:lattice_ops combine>(\n       (ty::re_var(a_id), ty::re_var(b_id)) {\n         lattice_vars(self, self.infcx().rb,\n                      a, a_id, b_id,\n-                     {|x, y| self.regions(x, y) })\n+                     |x, y| self.regions(x, y) )\n       }\n \n       (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) {\n         lattice_var_t(self, self.infcx().rb,\n                       v_id, r,\n-                      {|x, y| self.regions(x, y) })\n+                      |x, y| self.regions(x, y) )\n       }\n \n       _ {\n@@ -2581,7 +2565,7 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n     alt (a_bnd, b_bnd) {\n       (some(a_ty), some(b_ty)) {\n-        alt self.infcx().try({|| c_ts(a_ty, b_ty) }) {\n+        alt self.infcx().try(|| c_ts(a_ty, b_ty) ) {\n             ok(t) { ret ok(t); }\n             err(_) { /*fallthrough */ }\n         }\n@@ -2591,9 +2575,7 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n \n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n-    self.infcx().vars(vb, a_vid, b_vid).then({||\n-        ok(a_t)\n-    })\n+    self.infcx().vars(vb, a_vid, b_vid).then(|| ok(a_t) )\n }\n \n fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n@@ -2624,7 +2606,7 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n         // and then return b.\n         #debug[\"bnd=none\"];\n         let a_bounds = self.with_bnd(a_bounds, b);\n-        do self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n+        do self.infcx().bnds(a_bounds.lb, a_bounds.ub).then || {\n             self.infcx().set(vb, a_id, root(a_bounds,\n                                             nde_a.rank));\n             ok(b)"}, {"sha": "f9f467a90fa8a1c70b491150c5b22fd728050b0c", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -28,7 +28,7 @@ impl of region_scope for type_rscope {\n         }\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, str> {\n-        do empty_rscope.named_region(id).chain_err { |_e|\n+        do empty_rscope.named_region(id).chain_err |_e| {\n             if *id == \"self\" { self.anon_region() }\n             else {\n                 result::err(\"named regions other than `self` are not \\\n@@ -62,7 +62,7 @@ impl of region_scope for @binding_rscope {\n         result::ok(ty::re_bound(ty::br_anon))\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, str> {\n-        do self.base.named_region(id).chain_err {|_e|\n+        do self.base.named_region(id).chain_err |_e| {\n             result::ok(ty::re_bound(ty::br_named(id)))\n         }\n     }"}, {"sha": "6a594879d1d41a47c9008ef6cc55b52428aac278", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -31,16 +31,16 @@ fn field_expr(f: ast::field) -> @ast::expr { ret f.node.expr; }\n \n fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n     let mut es = ~[];\n-    for fields.each {|f| vec::push(es, f.node.expr); }\n+    for fields.each |f| { vec::push(es, f.node.expr); }\n     ret es;\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n-    let visit_expr = {|e: @ast::expr, &&flag: @mut bool,\n-                       v: visit::vt<@mut bool>|\n+    let visit_expr =\n+        |e: @ast::expr, &&flag: @mut bool, v: visit::vt<@mut bool>| {\n         *flag |= p(e.node);\n         alt e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n@@ -56,13 +56,13 @@ fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n }\n \n fn has_nonlocal_exits(b: ast::blk) -> bool {\n-    do loop_query(b) {|e| alt e {\n+    do loop_query(b) |e| { alt e {\n       ast::expr_break | ast::expr_cont { true }\n       _ { false }}}\n }\n \n fn may_break(b: ast::blk) -> bool {\n-    do loop_query(b) {|e| alt e {\n+    do loop_query(b) |e| { alt e {\n       ast::expr_break { true }\n       _ { false }}}\n }"}, {"sha": "674f79ece79590847cd60e622e698e7eb0d1d1f3", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -98,7 +98,7 @@ fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> str {\n \n fn tys_to_str(cx: ctxt, ts: ~[t]) -> str {\n     let mut rs = \"\";\n-    for ts.each {|t| rs += ty_to_str(cx, t); }\n+    for ts.each |t| { rs += ty_to_str(cx, t); }\n     rs\n }\n \n@@ -133,7 +133,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         alt ident { some(i) { s += \" \"; s += *i; } _ { } }\n         s += \"(\";\n         let mut strs = ~[];\n-        for inputs.each {|a| vec::push(strs, fn_input_to_str(cx, a)); }\n+        for inputs.each |a| { vec::push(strs, fn_input_to_str(cx, a)); }\n         s += str::connect(strs, \", \");\n         s += \")\";\n         if ty::get(output).struct != ty_nil {\n@@ -156,7 +156,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n \n     // if there is an id, print that instead of the structural type:\n-    for ty::type_def_id(typ).each { |def_id|\n+    for ty::type_def_id(typ).each |def_id| {\n         // note that this typedef cannot have type parameters\n         ret ast_map::path_to_str(ty::item_path(cx, def_id));\n     }\n@@ -190,12 +190,12 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_type { \"type\" }\n       ty_rec(elems) {\n         let mut strs: ~[str] = ~[];\n-        for elems.each {|fld| vec::push(strs, field_to_str(cx, fld)); }\n+        for elems.each |fld| { vec::push(strs, field_to_str(cx, fld)); }\n         \"{\" + str::connect(strs, \",\") + \"}\"\n       }\n       ty_tup(elems) {\n         let mut strs = ~[];\n-        for elems.each {|elem| vec::push(strs, ty_to_str(cx, elem)); }\n+        for elems.each |elem| { vec::push(strs, ty_to_str(cx, elem)); }\n         \"(\" + str::connect(strs, \",\") + \")\"\n       }\n       ty_fn(f) {\n@@ -244,7 +244,7 @@ fn parameterized(cx: ctxt,\n     };\n \n     if vec::len(tps) > 0u {\n-        let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n+        let strs = vec::map(tps, |t| ty_to_str(cx, t) );\n         #fmt[\"%s%s<%s>\", base, r_str, str::connect(strs, \",\")]\n     } else {\n         #fmt[\"%s%s\", base, r_str]\n@@ -265,7 +265,7 @@ fn constr_to_str(c: @constr) -> str {\n fn constrs_str(constrs: ~[@constr]) -> str {\n     let mut s = \"\";\n     let mut colon = true;\n-    for constrs.each {|c|\n+    for constrs.each |c| {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);\n     }"}, {"sha": "255d49b6f74568dae2ed6ea01ab460591b18901b", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -60,7 +60,7 @@ fn from_file<T>(file: str, owner: srv_owner<T>) -> T {\n fn run<T>(owner: srv_owner<T>, source: str, +parse: parser) -> T {\n \n     let srv_ = srv({\n-        ch: do task::spawn_listener {|po|\n+        ch: do task::spawn_listener |po| {\n             act(po, source, parse);\n         }\n     });\n@@ -199,8 +199,8 @@ fn build_error_handlers(\n #[test]\n fn should_prune_unconfigured_items() {\n     let source = \"#[cfg(shut_up_and_leave_me_alone)]fn a() { }\";\n-    do from_str(source) {|srv|\n-        do exec(srv) {|ctxt|\n+    do from_str(source) |srv| {\n+        do exec(srv) |ctxt| {\n             assert vec::is_empty(ctxt.ast.node.module.items);\n         }\n     }\n@@ -209,8 +209,8 @@ fn should_prune_unconfigured_items() {\n #[test]\n fn srv_should_build_ast_map() {\n     let source = \"fn a() { }\";\n-    do from_str(source) {|srv|\n-        do exec(srv) {|ctxt|\n+    do from_str(source) |srv| {\n+        do exec(srv) |ctxt| {\n             assert ctxt.ast_map.size() != 0u\n         };\n     }\n@@ -219,8 +219,8 @@ fn srv_should_build_ast_map() {\n #[test]\n fn srv_should_build_reexport_map() {\n     let source = \"import a::b; export b; mod a { mod b { } }\";\n-    do from_str(source) {|srv|\n-        do exec(srv) {|ctxt|\n+    do from_str(source) |srv| {\n+        do exec(srv) |ctxt| {\n             assert ctxt.exp_map.size() != 0u\n         };\n     }\n@@ -232,41 +232,41 @@ fn srv_should_resolve_external_crates() {\n                   fn f() -> std::sha1::sha1 {\\\n                   std::sha1::mk_sha1() }\";\n     // Just testing that resolve doesn't crash\n-    from_str(source, {|_srv| })\n+    from_str(source, |_srv| { } )\n }\n \n #[test]\n fn srv_should_resolve_core_crate() {\n     let source = \"fn a() -> option { fail }\";\n     // Just testing that resolve doesn't crash\n-    from_str(source, {|_srv| })\n+    from_str(source, |_srv| { } )\n }\n \n #[test]\n fn srv_should_resolve_non_existant_imports() {\n     // We want to ignore things we can't resolve. Shouldn't\n     // need to be able to find external crates to create docs.\n     let source = \"import wooboo; fn a() { }\";\n-    from_str(source, {|_srv| })\n+    from_str(source, |_srv| { } )\n }\n \n #[test]\n fn srv_should_resolve_non_existant_uses() {\n     let source = \"use forble; fn a() { }\";\n-    from_str(source, {|_srv| })\n+    from_str(source, |_srv| { } )\n }\n \n #[test]\n fn should_ignore_external_import_paths_that_dont_exist() {\n     let source = \"use forble; import forble::bippy;\";\n-    from_str(source, {|_srv| })\n+    from_str(source, |_srv| { } )\n }\n \n #[test]\n fn srv_should_return_request_result() {\n     let source = \"fn a() { }\";\n-    do from_str(source) {|srv|\n-        let result = exec(srv, {|_ctxt| 1000});\n+    do from_str(source) |srv| {\n+        let result = exec(srv, |_ctxt| 1000 );\n         assert result == 1000;\n     }\n }"}, {"sha": "9046496b9e59dc59d91d4ea69e5720ae1ea51d6f", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -60,7 +60,7 @@ fn parse_crate(attrs: ~[ast::attribute]) -> crate_attrs {\n \n     {\n         name: attr::last_meta_item_value_str_by_name(\n-            link_metas, \"name\").map({|x|*x})\n+            link_metas, \"name\").map(|x| *x )\n     }\n }\n \n@@ -91,7 +91,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n fn parse_desc(attrs: ~[ast::attribute]) -> option<str> {\n     alt doc_meta(attrs) {\n       some(meta) {\n-        attr::get_meta_item_value_str(meta).map({|x|*x})\n+        attr::get_meta_item_value_str(meta).map(|x| *x )\n       }\n       none { none }\n     }"}, {"sha": "0a00a5ef58c428c4949196145e28942c7e9d1fa0", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -42,7 +42,7 @@ fn fold_crate(\n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_crate(fold, doc);\n \n-    let attrs = do astsrv::exec(srv) {|ctxt|\n+    let attrs = do astsrv::exec(srv) |ctxt| {\n         let attrs = ctxt.ast.node.attrs;\n         attr_parser::parse_crate(attrs)\n     };\n@@ -74,7 +74,7 @@ fn fold_item(\n \n     let desc = if doc.id == ast::crate_node_id {\n         // This is the top-level mod, use the crate attributes\n-        do astsrv::exec(srv) {|ctxt|\n+        do astsrv::exec(srv) |ctxt| {\n             attr_parser::parse_desc(ctxt.ast.node.attrs)\n         }\n     } else {\n@@ -91,7 +91,7 @@ fn parse_item_attrs<T:send>(\n     srv: astsrv::srv,\n     id: doc::ast_id,\n     +parse_attrs: fn~(~[ast::attribute]) -> T) -> T {\n-    do astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) |ctxt| {\n         let attrs = alt ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) { item.attrs }\n           ast_map::node_foreign_item(item, _, _) { item.attrs }\n@@ -143,14 +143,14 @@ fn fold_enum(\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     {\n-        variants: do par::anymap(doc.variants) {|variant|\n-            let desc = do astsrv::exec(srv) {|ctxt|\n+        variants: do par::anymap(doc.variants) |variant| {\n+            let desc = do astsrv::exec(srv) |ctxt| {\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n-                        vec::find(ast_variants, {|v|\n+                        vec::find(ast_variants, |v| {\n                             *v.node.name == variant.name\n                         }));\n \n@@ -201,27 +201,27 @@ fn merge_method_attrs(\n ) -> ~[doc::methoddoc] {\n \n     // Create an assoc list from method name to attributes\n-    let attrs: ~[(str, option<str>)] = do astsrv::exec(srv) {|ctxt|\n+    let attrs: ~[(str, option<str>)] = do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, _, methods), _\n           }, _) {\n-            par::seqmap(methods, {|method|\n+            par::seqmap(methods, |method| {\n                 (*method.ident, attr_parser::parse_desc(method.attrs))\n             })\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n-            par::seqmap(methods, {|method|\n+            par::seqmap(methods, |method| {\n                 (*method.ident, attr_parser::parse_desc(method.attrs))\n             })\n           }\n           _ { fail \"unexpected item\" }\n         }\n     };\n \n-    do vec::map2(docs, attrs) {|doc, attrs|\n+    do vec::map2(docs, attrs) |doc, attrs| {\n         assert doc.name == tuple::first(attrs);\n         let desc = tuple::second(attrs);\n \n@@ -282,7 +282,7 @@ fn should_extract_impl_method_docs() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "c316b175e66184365cfe56af5260e2ace81bca43", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -59,7 +59,7 @@ fn usage() {\n \n     println(\"Usage: rustdoc ~[options] <cratefile>\\n\");\n     println(\"Options:\\n\");\n-    for opts().each {|opt|\n+    for opts().each |opt| {\n         println(#fmt(\"    %s\", tuple::second(opt)));\n     }\n     println(\"\");\n@@ -122,20 +122,20 @@ fn config_from_opts(\n \n     let config = default_config(input_crate);\n     let result = result::ok(config);\n-    let result = do result::chain(result) {|config|\n+    let result = do result::chain(result) |config| {\n         let output_dir = getopts::opt_maybe_str(match, opt_output_dir());\n         result::ok({\n             output_dir: option::get_default(output_dir, config.output_dir)\n             with config\n         })\n     };\n-    let result = do result::chain(result) {|config|\n+    let result = do result::chain(result) |config| {\n         let output_format = getopts::opt_maybe_str(\n             match, opt_output_format());\n         do option::map_default(output_format, result::ok(config))\n-           {|output_format|\n+            |output_format| {\n             do result::chain(parse_output_format(output_format))\n-                {|output_format|\n+                |output_format| {\n \n                 result::ok({\n                     output_format: output_format\n@@ -144,23 +144,24 @@ fn config_from_opts(\n             }\n         }\n     };\n-    let result = do result::chain(result) {|config|\n+    let result = do result::chain(result) |config| {\n         let output_style = getopts::opt_maybe_str(match, opt_output_style());\n         do option::map_default(output_style, result::ok(config))\n-          {|output_style|\n-            do result::chain(parse_output_style(output_style)) {|output_style|\n+            |output_style| {\n+            do result::chain(parse_output_style(output_style))\n+                |output_style| {\n                 result::ok({\n                     output_style: output_style\n                     with config\n                 })\n             }\n         }\n     };\n-    let result = do result::chain(result) {|config|\n+    let result = do result::chain(result) |config| {\n         let pandoc_cmd = getopts::opt_maybe_str(match, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             config, pandoc_cmd, program_output);\n-        do result::chain(pandoc_cmd) {|pandoc_cmd|\n+        do result::chain(pandoc_cmd) |pandoc_cmd| {\n             result::ok({\n                 pandoc_cmd: pandoc_cmd\n                 with config\n@@ -207,7 +208,7 @@ fn maybe_find_pandoc(\n       }\n     };\n \n-    let pandoc = do vec::find(possible_pandocs) {|pandoc|\n+    let pandoc = do vec::find(possible_pandocs) |pandoc| {\n         let output = program_output(pandoc, ~[\"--version\"]);\n         #debug(\"testing pandoc cmd %s: %?\", pandoc, output);\n         output.status == 0"}, {"sha": "f4b0a52a268e0f66b89e97c489249e59ba9095a8", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -42,11 +42,9 @@ fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     let doc =fold::default_seq_fold_iface(fold, doc);\n \n     {\n-        methods: par::anymap(doc.methods, {|doc|\n-            {\n-                brief: extract(doc.desc)\n-                with doc\n-            }\n+        methods: par::anymap(doc.methods, |doc| {\n+            brief: extract(doc.desc)\n+            with doc\n         })\n         with doc\n     }\n@@ -56,11 +54,9 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n     let doc =fold::default_seq_fold_impl(fold, doc);\n \n     {\n-        methods: par::anymap(doc.methods, {|doc|\n-            {\n-                brief: extract(doc.desc)\n-                with doc\n-            }\n+        methods: par::anymap(doc.methods, |doc| {\n+            brief: extract(doc.desc)\n+            with doc\n         })\n         with doc\n     }\n@@ -88,7 +84,7 @@ fn should_promote_impl_method_desc() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             run(srv, doc)\n@@ -134,7 +130,7 @@ fn first_sentence_(s: str) -> str {\n     let mut dotcount = 0;\n     // The index of the character following a single dot. This allows\n     // Things like [0..1) to appear in the brief description\n-    let idx = do str::find(s) {|ch|\n+    let idx = do str::find(s) |ch| {\n         if ch == '.' {\n             dotcount += 1;\n             false\n@@ -165,7 +161,7 @@ fn paragraphs(s: str) -> ~[str] {\n     let lines = str::lines_any(s);\n     let mut whitespace_lines = 0;\n     let mut accum = \"\";\n-    let paras = do vec::foldl(~[], lines) {|paras, line|\n+    let paras = do vec::foldl(~[], lines) |paras, line| {\n         let mut res = paras;\n \n         if str::is_whitespace(line) {"}, {"sha": "cd83b70bbeaa24f42d3750ac7d69bb2b3b14ae85", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -128,7 +128,7 @@ type index_entry = {\n \n impl util for doc {\n     fn cratedoc() -> cratedoc {\n-        option::get(vec::foldl(none, self.pages, {|_m, page|\n+        option::get(vec::foldl(none, self.pages, |_m, page| {\n             alt page {\n               doc::cratepage(doc) { some(doc) }\n               _ { none }\n@@ -145,7 +145,7 @@ impl util for doc {\n impl util for moddoc {\n \n     fn mods() -> ~[moddoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               modtag(moddoc) { some(moddoc) }\n               _ { none }\n@@ -154,7 +154,7 @@ impl util for moddoc {\n     }\n \n     fn nmods() -> ~[nmoddoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               nmodtag(nmoddoc) { some(nmoddoc) }\n               _ { none }\n@@ -163,7 +163,7 @@ impl util for moddoc {\n     }\n \n     fn fns() -> ~[fndoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               fntag(fndoc) { some(fndoc) }\n               _ { none }\n@@ -172,7 +172,7 @@ impl util for moddoc {\n     }\n \n     fn consts() -> ~[constdoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               consttag(constdoc) { some(constdoc) }\n               _ { none }\n@@ -181,7 +181,7 @@ impl util for moddoc {\n     }\n \n     fn enums() -> ~[enumdoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               enumtag(enumdoc) { some(enumdoc) }\n               _ { none }\n@@ -190,7 +190,7 @@ impl util for moddoc {\n     }\n \n     fn ifaces() -> ~[ifacedoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               ifacetag(ifacedoc) { some(ifacedoc) }\n               _ { none }\n@@ -199,7 +199,7 @@ impl util for moddoc {\n     }\n \n     fn impls() -> ~[impldoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               impltag(impldoc) { some(impldoc) }\n               _ { none }\n@@ -208,7 +208,7 @@ impl util for moddoc {\n     }\n \n     fn types() -> ~[tydoc] {\n-        do vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n               tytag(tydoc) { some(tydoc) }\n               _ { none }\n@@ -220,7 +220,7 @@ impl util for moddoc {\n impl util for ~[page] {\n \n     fn mods() -> ~[moddoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(modtag(moddoc)) { some(moddoc) }\n               _ { none }\n@@ -229,7 +229,7 @@ impl util for ~[page] {\n     }\n \n     fn nmods() -> ~[nmoddoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(nmodtag(nmoddoc)) { some(nmoddoc) }\n               _ { none }\n@@ -238,7 +238,7 @@ impl util for ~[page] {\n     }\n \n     fn fns() -> ~[fndoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(fntag(fndoc)) { some(fndoc) }\n               _ { none }\n@@ -247,7 +247,7 @@ impl util for ~[page] {\n     }\n \n     fn consts() -> ~[constdoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(consttag(constdoc)) { some(constdoc) }\n               _ { none }\n@@ -256,7 +256,7 @@ impl util for ~[page] {\n     }\n \n     fn enums() -> ~[enumdoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(enumtag(enumdoc)) { some(enumdoc) }\n               _ { none }\n@@ -265,7 +265,7 @@ impl util for ~[page] {\n     }\n \n     fn ifaces() -> ~[ifacedoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(ifacetag(ifacedoc)) { some(ifacedoc) }\n               _ { none }\n@@ -274,7 +274,7 @@ impl util for ~[page] {\n     }\n \n     fn impls() -> ~[impldoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(impltag(impldoc)) { some(impldoc) }\n               _ { none }\n@@ -283,7 +283,7 @@ impl util for ~[page] {\n     }\n \n     fn types() -> ~[tydoc] {\n-        do vec::filter_map(self) {|page|\n+        do vec::filter_map(self) |page| {\n             alt page {\n               itempage(tytag(tydoc)) { some(tydoc) }\n               _ { none }"}, {"sha": "66585d5683eda20c8eba7872f1e18fd3b2116e64", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -11,7 +11,7 @@ fn from_srv(\n \n     #[doc = \"Use the AST service to create a document tree\"];\n \n-    do astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) |ctxt| {\n         extract(ctxt.ast, default_name)\n     }\n }\n@@ -55,7 +55,7 @@ fn moddoc_from_mod(\n ) -> doc::moddoc {\n     {\n         item: itemdoc,\n-        items: do vec::filter_map(module.items) {|item|\n+        items: do vec::filter_map(module.items) |item| {\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n               ast::item_mod(m) {\n@@ -113,7 +113,7 @@ fn nmoddoc_from_mod(\n ) -> doc::nmoddoc {\n     {\n         item: itemdoc,\n-        fns: do par::seqmap(module.items) {|item|\n+        fns: do par::seqmap(module.items) |item| {\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n               ast::foreign_item_fn(_, _) {\n@@ -189,7 +189,7 @@ fn ifacedoc_from_iface(\n ) -> doc::ifacedoc {\n     {\n         item: itemdoc,\n-        methods: do par::seqmap(methods) {|method|\n+        methods: do par::seqmap(methods) |method| {\n             {\n                 name: *method.ident,\n                 brief: none,\n@@ -221,7 +221,7 @@ fn impldoc_from_impl(\n         item: itemdoc,\n         iface_ty: none,\n         self_ty: none,\n-        methods: do par::seqmap(methods) {|method|\n+        methods: do par::seqmap(methods) |method| {\n             {\n                 name: *method.ident,\n                 brief: none,\n@@ -339,7 +339,7 @@ mod test {\n     #[test]\n     fn extract_from_seq_srv() {\n         let source = \"\";\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, \"name\");\n             assert doc.cratemod().name() == \"name\";\n         }"}, {"sha": "9d560c7486d11b58fa84022bb1c63a4b59e27b08", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -83,57 +83,57 @@ fn mk_fold<T:copy>(\n fn default_any_fold<T:send copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n-        {|f, d| default_seq_fold_doc(f, d)},\n-        {|f, d| default_seq_fold_crate(f, d)},\n-        {|f, d| default_seq_fold_item(f, d)},\n-        {|f, d| default_any_fold_mod(f, d)},\n-        {|f, d| default_any_fold_nmod(f, d)},\n-        {|f, d| default_seq_fold_fn(f, d)},\n-        {|f, d| default_seq_fold_const(f, d)},\n-        {|f, d| default_seq_fold_enum(f, d)},\n-        {|f, d| default_seq_fold_iface(f, d)},\n-        {|f, d| default_seq_fold_impl(f, d)},\n-        {|f, d| default_seq_fold_type(f, d)}\n+        |f, d| default_seq_fold_doc(f, d),\n+        |f, d| default_seq_fold_crate(f, d),\n+        |f, d| default_seq_fold_item(f, d),\n+        |f, d| default_any_fold_mod(f, d),\n+        |f, d| default_any_fold_nmod(f, d),\n+        |f, d| default_seq_fold_fn(f, d),\n+        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_enum(f, d),\n+        |f, d| default_seq_fold_iface(f, d),\n+        |f, d| default_seq_fold_impl(f, d),\n+        |f, d| default_seq_fold_type(f, d)\n     )\n }\n \n fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n-        {|f, d| default_seq_fold_doc(f, d)},\n-        {|f, d| default_seq_fold_crate(f, d)},\n-        {|f, d| default_seq_fold_item(f, d)},\n-        {|f, d| default_seq_fold_mod(f, d)},\n-        {|f, d| default_seq_fold_nmod(f, d)},\n-        {|f, d| default_seq_fold_fn(f, d)},\n-        {|f, d| default_seq_fold_const(f, d)},\n-        {|f, d| default_seq_fold_enum(f, d)},\n-        {|f, d| default_seq_fold_iface(f, d)},\n-        {|f, d| default_seq_fold_impl(f, d)},\n-        {|f, d| default_seq_fold_type(f, d)}\n+        |f, d| default_seq_fold_doc(f, d),\n+        |f, d| default_seq_fold_crate(f, d),\n+        |f, d| default_seq_fold_item(f, d),\n+        |f, d| default_seq_fold_mod(f, d),\n+        |f, d| default_seq_fold_nmod(f, d),\n+        |f, d| default_seq_fold_fn(f, d),\n+        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_enum(f, d),\n+        |f, d| default_seq_fold_iface(f, d),\n+        |f, d| default_seq_fold_impl(f, d),\n+        |f, d| default_seq_fold_type(f, d)\n     )\n }\n \n fn default_par_fold<T:send copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n-        {|f, d| default_seq_fold_doc(f, d)},\n-        {|f, d| default_seq_fold_crate(f, d)},\n-        {|f, d| default_seq_fold_item(f, d)},\n-        {|f, d| default_par_fold_mod(f, d)},\n-        {|f, d| default_par_fold_nmod(f, d)},\n-        {|f, d| default_seq_fold_fn(f, d)},\n-        {|f, d| default_seq_fold_const(f, d)},\n-        {|f, d| default_seq_fold_enum(f, d)},\n-        {|f, d| default_seq_fold_iface(f, d)},\n-        {|f, d| default_seq_fold_impl(f, d)},\n-        {|f, d| default_seq_fold_type(f, d)}\n+        |f, d| default_seq_fold_doc(f, d),\n+        |f, d| default_seq_fold_crate(f, d),\n+        |f, d| default_seq_fold_item(f, d),\n+        |f, d| default_par_fold_mod(f, d),\n+        |f, d| default_par_fold_nmod(f, d),\n+        |f, d| default_seq_fold_fn(f, d),\n+        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_enum(f, d),\n+        |f, d| default_seq_fold_iface(f, d),\n+        |f, d| default_seq_fold_impl(f, d),\n+        |f, d| default_seq_fold_type(f, d)\n     )\n }\n \n fn default_seq_fold_doc<T>(fold: fold<T>, doc: doc::doc) -> doc::doc {\n     {\n-        pages: do par::seqmap(doc.pages) {|page|\n+        pages: do par::seqmap(doc.pages) |page| {\n             alt page {\n               doc::cratepage(doc) {\n                 doc::cratepage(fold.fold_crate(fold, doc))\n@@ -169,7 +169,7 @@ fn default_any_fold_mod<T:send copy>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::anymap(doc.items, {|itemtag, copy fold|\n+        items: par::anymap(doc.items, |itemtag, copy fold| {\n             fold_itemtag(fold, itemtag)\n         })\n         with doc\n@@ -182,7 +182,7 @@ fn default_seq_fold_mod<T>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::seqmap(doc.items, {|itemtag|\n+        items: par::seqmap(doc.items, |itemtag| {\n             fold_itemtag(fold, itemtag)\n         })\n         with doc\n@@ -195,7 +195,7 @@ fn default_par_fold_mod<T:send copy>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::parmap(doc.items, {|itemtag, copy fold|\n+        items: par::parmap(doc.items, |itemtag, copy fold| {\n             fold_itemtag(fold, itemtag)\n         })\n         with doc\n@@ -208,7 +208,7 @@ fn default_any_fold_nmod<T:send copy>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::anymap(doc.fns, {|fndoc, copy fold|\n+        fns: par::anymap(doc.fns, |fndoc, copy fold| {\n             fold.fold_fn(fold, fndoc)\n         })\n         with doc\n@@ -221,7 +221,7 @@ fn default_seq_fold_nmod<T>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::seqmap(doc.fns, {|fndoc|\n+        fns: par::seqmap(doc.fns, |fndoc| {\n             fold.fold_fn(fold, fndoc)\n         })\n         with doc\n@@ -234,7 +234,7 @@ fn default_par_fold_nmod<T:send copy>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::parmap(doc.fns, {|fndoc, copy fold|\n+        fns: par::parmap(doc.fns, |fndoc, copy fold| {\n             fold.fold_fn(fold, fndoc)\n         })\n         with doc"}, {"sha": "25691cb79d910d2a8368e12fe91b054106274cc4", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -55,7 +55,7 @@ fn build_mod_index(\n     config: config::config\n ) -> doc::index {\n     {\n-        entries: par::anymap(doc.items, {|doc|\n+        entries: par::anymap(doc.items, |doc| {\n             item_to_entry(doc, config)\n         })\n     }\n@@ -66,7 +66,7 @@ fn build_nmod_index(\n     config: config::config\n ) -> doc::index {\n     {\n-        entries: par::anymap(doc.fns, {|doc|\n+        entries: par::anymap(doc.fns, |doc| {\n             item_to_entry(doc::fntag(doc), config)\n         })\n     }\n@@ -215,7 +215,7 @@ fn should_index_foreign_mod_contents() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(output_style: config::output_style, source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let config = {\n                 output_style: output_style\n                 with config::default_config(\"whatever\")"}, {"sha": "a616897f3b24d05071cbbef23525238d000d869e", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -82,7 +82,7 @@ fn write_markdown(\n     doc: doc::doc,\n     +writer_factory: writer_factory\n ) {\n-    do par::anymap(doc.pages) {|page|\n+    do par::anymap(doc.pages) |page| {\n         let ctxt = {\n             w: writer_factory(page)\n         };\n@@ -115,7 +115,7 @@ fn should_request_new_writer_for_each_page() {\n     let doc = page_pass::mk_pass(config::doc_per_mod).f(srv, doc);\n     write_markdown(doc, writer_factory);\n     // We expect two pages to have been written\n-    do iter::repeat(2u) {||\n+    do iter::repeat(2u) || {\n         comm::recv(po);\n     }\n }\n@@ -146,7 +146,7 @@ fn should_write_title_for_each_page() {\n         \"#[link(name = \\\"core\\\")]; mod a { }\");\n     let doc = page_pass::mk_pass(config::doc_per_mod).f(srv, doc);\n     write_markdown(doc, writer_factory);\n-    do iter::repeat(2u) {||\n+    do iter::repeat(2u) || {\n         let (page, markdown) = comm::recv(po);\n         alt page {\n           doc::cratepage(_) {\n@@ -295,7 +295,7 @@ fn write_desc(\n }\n \n fn write_sections(ctxt: ctxt, sections: ~[doc::section]) {\n-    do vec::iter(sections) {|section|\n+    do vec::iter(sections) |section| {\n         write_section(ctxt, section);\n     }\n }\n@@ -325,7 +325,7 @@ fn write_mod_contents(\n         write_index(ctxt, option::get(doc.index));\n     }\n \n-    for doc.items.each {|itemtag|\n+    for doc.items.each |itemtag| {\n         write_item(ctxt, itemtag);\n     }\n }\n@@ -377,7 +377,7 @@ fn write_index(ctxt: ctxt, index: doc::index) {\n         ret;\n     }\n \n-    for index.entries.each {|entry|\n+    for index.entries.each |entry| {\n         let header = header_text_(entry.kind, entry.name);\n         let id = entry.link;\n         if option::is_some(entry.brief) {\n@@ -427,7 +427,7 @@ fn write_nmod(ctxt: ctxt, doc: doc::nmoddoc) {\n         write_index(ctxt, option::get(doc.index));\n     }\n \n-    for doc.fns.each {|fndoc|\n+    for doc.fns.each |fndoc| {\n         write_item_header(ctxt, doc::fntag(fndoc));\n         write_fn(ctxt, fndoc);\n     }\n@@ -486,7 +486,7 @@ fn write_sig(ctxt: ctxt, sig: option<str>) {\n \n fn code_block_indent(s: str) -> str {\n     let lines = str::lines_any(s);\n-    let indented = par::seqmap(lines, { |line| #fmt(\"    %s\", line) });\n+    let indented = par::seqmap(lines, |line| #fmt(\"    %s\", line) );\n     str::connect(indented, \"\\n\")\n }\n \n@@ -588,7 +588,7 @@ fn write_variants(\n \n     write_header_(ctxt, h4, \"Variants\");\n \n-    vec::iter(docs, {|variant| write_variant(ctxt, variant) });\n+    vec::iter(docs, |variant| write_variant(ctxt, variant) );\n \n     ctxt.w.write_line(\"\");\n }\n@@ -645,7 +645,7 @@ fn write_iface(ctxt: ctxt, doc: doc::ifacedoc) {\n }\n \n fn write_methods(ctxt: ctxt, docs: ~[doc::methoddoc]) {\n-    do vec::iter(docs) {|doc| write_method(ctxt, doc) }\n+    do vec::iter(docs) |doc| { write_method(ctxt, doc) }\n }\n \n fn write_method(ctxt: ctxt, doc: doc::methoddoc) {\n@@ -760,7 +760,7 @@ mod test {\n     }\n \n     fn create_doc_srv(source: str) -> (astsrv::srv, doc::doc) {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n \n             let config = {\n                 output_style: config::doc_per_crate"}, {"sha": "ee968174aa24b2886a31dca48232a27f4ef36305", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -56,7 +56,7 @@ fn markdown_writer(\n     page: doc::page\n ) -> writer {\n     let filename = make_local_filename(config, page);\n-    do generic_writer {|markdown|\n+    do generic_writer |markdown| {\n         write_file(filename, markdown);\n     }\n }\n@@ -78,7 +78,7 @@ fn pandoc_writer(\n         \"--output=\" + filename\n     ];\n \n-    do generic_writer {|markdown|\n+    do generic_writer |markdown| {\n         import io::writer_util;\n \n         #debug(\"pandoc cmd: %s\", pandoc_cmd);\n@@ -101,14 +101,14 @@ fn pandoc_writer(\n \n         let stdout_po = comm::port();\n         let stdout_ch = comm::chan(stdout_po);\n-        do task::spawn_sched(task::single_threaded) {||\n+        do task::spawn_sched(task::single_threaded) || {\n             comm::send(stdout_ch, readclose(pipe_out.in));\n         }\n         let stdout = comm::recv(stdout_po);\n \n         let stderr_po = comm::port();\n         let stderr_ch = comm::chan(stderr_po);\n-        do task::spawn_sched(task::single_threaded) {||\n+        do task::spawn_sched(task::single_threaded) || {\n             comm::send(stderr_ch, readclose(pipe_err.in));\n         }\n         let stderr = comm::recv(stderr_po);\n@@ -137,7 +137,7 @@ fn readclose(fd: libc::c_int) -> str {\n }\n \n fn generic_writer(+process: fn~(markdown: str)) -> writer {\n-    let ch = do task::spawn_listener {|po: comm::port<writeinstr>|\n+    let ch = do task::spawn_listener |po: comm::port<writeinstr>| {\n         let mut markdown = \"\";\n         let mut keep_going = true;\n         while keep_going {\n@@ -236,7 +236,7 @@ fn should_name_mod_file_names_by_path() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(name: str, source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, name);\n             let doc = path_pass::mk_pass().f(srv, doc);\n             doc\n@@ -262,7 +262,7 @@ fn future_writer_factory(\n     let writer_factory = fn~(page: doc::page) -> writer {\n         let writer_po = comm::port();\n         let writer_ch = comm::chan(writer_po);\n-        do task::spawn {||\n+        do task::spawn || {\n             let (writer, future) = future_writer();\n             comm::send(writer_ch, writer);\n             let s = future::get(future);\n@@ -280,7 +280,7 @@ fn future_writer() -> (writer, future::future<str>) {\n     let writer = fn~(+instr: writeinstr) {\n         comm::send(chan, copy instr);\n     };\n-    let future = do future::from_fn {||\n+    let future = do future::from_fn || {\n         let mut res = \"\";\n         loop {\n             alt comm::recv(port) {"}, {"sha": "80af8f2553fb63f882196db4a5409267cfaae1e4", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -32,7 +32,7 @@ fn run(\n \n     let result_port = comm::port();\n     let result_chan = comm::chan(result_port);\n-    let page_chan = do task::spawn_listener {|page_port|\n+    let page_chan = do task::spawn_listener |page_port| {\n         comm::send(result_chan, make_doc_from_pages(page_port));\n     };\n \n@@ -106,7 +106,7 @@ fn fold_mod(\n \n fn strip_mod(doc: doc::moddoc) -> doc::moddoc {\n     {\n-        items: do vec::filter(doc.items) {|item|\n+        items: do vec::filter(doc.items) |item| {\n             alt item {\n               doc::modtag(_) { false }\n               doc::nmodtag(_) { false }\n@@ -166,7 +166,7 @@ mod test {\n         output_style: config::output_style,\n         source: str\n     ) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc, output_style)\n         }"}, {"sha": "d64a89714cebc47a6806a58718d3c1495a416ab9", "filename": "src/rustdoc/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpar.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -9,23 +9,23 @@ fn seqmap<T, U>(v: ~[T], f: fn(T) -> U) -> ~[U] {\n }\n \n fn parmap<T:send, U:send>(v: ~[T], f: fn~(T) -> U) -> ~[U] unsafe {\n-    let futures = do vec::map(v) {|elt|\n+    let futures = do vec::map(v) |elt| {\n         let po = comm::port();\n         let ch = comm::chan(po);\n         let addr = ptr::addr_of(elt);\n-        do task::spawn {|copy f|\n+        do task::spawn |copy f| {\n             comm::send(ch, f(*addr));\n         }\n         po\n     };\n-    do vec::map(futures) {|future|\n+    do vec::map(futures) |future| {\n         comm::recv(future)\n     }\n }\n \n #[test]\n fn test_parallel_map() {\n     let i = ~[1, 2, 3, 4];\n-    let j = parmap(i, {|e| e + 1 });\n+    let j = parmap(i, |e| e + 1 );\n     assert j == ~[2, 3, 4, 5];\n }"}, {"sha": "99be48c03620bd4ac3569694ee66d308a2364cf1", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -66,7 +66,7 @@ fn fold_nmod(fold: fold::fold<ctxt>, doc: doc::nmoddoc) -> doc::nmoddoc {\n #[test]\n fn should_record_mod_paths() {\n     let source = \"mod a { mod b { mod c { } } mod d { mod e { } } }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n@@ -79,7 +79,7 @@ fn should_record_mod_paths() {\n #[test]\n fn should_record_fn_paths() {\n     let source = \"mod a { fn b() { } }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().mods()[0].fns()[0].path() == ~[\"a\"];\n@@ -89,7 +89,7 @@ fn should_record_fn_paths() {\n #[test]\n fn should_record_foreign_mod_paths() {\n     let source = \"mod a { native mod b { } }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().mods()[0].nmods()[0].path() == ~[\"a\"];\n@@ -99,7 +99,7 @@ fn should_record_foreign_mod_paths() {\n #[test]\n fn should_record_foreign_fn_paths() {\n     let source = \"native mod a { fn b(); }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().nmods()[0].fns[0].path() == ~[\"a\"];"}, {"sha": "783ca6d3f1465b9f3c2ff8218338ad07a40599ca", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -25,7 +25,7 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     {\n-        items: vec::filter(doc.items, {|itemtag|\n+        items: vec::filter(doc.items, |itemtag| {\n             !is_hidden(fold.ctxt, itemtag.item())\n         })\n         with doc\n@@ -36,7 +36,7 @@ fn is_hidden(srv: astsrv::srv, doc: doc::itemdoc) -> bool {\n     import syntax::ast_map;\n \n     let id = doc.id;\n-    do astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) |ctxt| {\n         let attrs = alt ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) { item.attrs }\n           _ { ~[] }\n@@ -54,7 +54,7 @@ fn should_prune_hidden_items() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "753100c1f09f02b342f9aa080761f344140edccf", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -62,7 +62,7 @@ fn exported_items_from_mod(\n     srv: astsrv::srv,\n     doc: doc::moddoc\n ) -> ~[doc::itemtag] {\n-    exported_items_from(srv, doc, {|a,b|\n+    exported_items_from(srv, doc, |a,b| {\n         is_exported_from_mod(a, doc.id(), b)\n     })\n }\n@@ -72,7 +72,7 @@ fn exported_items_from(\n     doc: doc::moddoc,\n     is_exported: fn(astsrv::srv, str) -> bool\n ) -> ~[doc::itemtag] {\n-    do vec::filter_map(doc.items) { |itemtag|\n+    do vec::filter_map(doc.items) |itemtag| {\n         let itemtag = alt itemtag {\n           doc::enumtag(enumdoc) {\n             // Also need to check variant exportedness\n@@ -97,7 +97,7 @@ fn exported_variants_from(\n     doc: doc::enumdoc,\n     is_exported: fn(astsrv::srv, str) -> bool\n ) -> ~[doc::variantdoc] {\n-    do vec::filter_map(doc.variants) { |doc|\n+    do vec::filter_map(doc.variants) |doc| {\n         if is_exported(srv, doc.name) {\n             some(doc)\n         } else {\n@@ -111,7 +111,7 @@ fn is_exported_from_mod(\n     mod_id: doc::ast_id,\n     item_name: str\n ) -> bool {\n-    do astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(mod_id) {\n           ast_map::node_item(item, _) {\n             alt item.node {\n@@ -132,7 +132,7 @@ fn is_exported_from_crate(\n     srv: astsrv::srv,\n     item_name: str\n ) -> bool {\n-    do astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) |ctxt| {\n         ast_util::is_exported(@item_name, ctxt.ast.node.module)\n     }\n }\n@@ -223,7 +223,7 @@ fn should_prune_unexported_types() {\n #[test]\n fn should_not_prune_reexports() {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             let doc = reexport_pass::mk_pass().f(srv, doc);\n             run(srv, doc)\n@@ -238,7 +238,7 @@ fn should_not_prune_reexports() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "a998faeac31372884370dd25697befff5666245a", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -46,7 +46,7 @@ fn to_assoc_list<K:copy, V:copy>(\n ) -> ~[(K, V)] {\n \n     let mut vec = ~[];\n-    for map.each {|k, v|\n+    for map.each |k, v| {\n         vec += ~[(k, v)];\n     }\n     ret vec;\n@@ -58,7 +58,7 @@ fn from_assoc_list<K:copy, V:copy>(\n ) -> map::hashmap<K, V> {\n \n     let map = new_hash();\n-    do vec::iter(list) {|elt|\n+    do vec::iter(list) |elt| {\n         let (k, v) = elt;\n         map.insert(k, v);\n     }\n@@ -78,16 +78,16 @@ fn from_str_assoc_list<V:copy>(\n }\n \n fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n-    let assoc_list = do astsrv::exec(srv) {|ctxt|\n+    let assoc_list = do astsrv::exec(srv) |ctxt| {\n         let def_set = ast_util::new_def_hash();\n-        for ctxt.exp_map.each {|_id, defs|\n-            for defs.each {|def|\n+        for ctxt.exp_map.each |_id, defs| {\n+            for defs.each |def| {\n                 if def.reexp {\n                     def_set.insert(def.id, ());\n                 }\n             }\n         }\n-        for find_reexport_impls(ctxt).each {|def|\n+        for find_reexport_impls(ctxt).each |def| {\n             def_set.insert(def, ());\n         }\n         to_assoc_list(def_set)\n@@ -98,7 +98,7 @@ fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n \n fn find_reexport_impls(ctxt: astsrv::ctxt) -> ~[ast::def_id] {\n     let defs = @mut ~[];\n-    do for_each_reexported_impl(ctxt) {|_mod_id, i|\n+    do for_each_reexported_impl(ctxt) |_mod_id, i| {\n         *defs += ~[i.did]\n     }\n     ret *defs;\n@@ -136,7 +136,7 @@ fn build_reexport_def_map(\n     fn fold_mod(fold: fold::fold<ctxt>, doc: doc::moddoc) -> doc::moddoc {\n         let doc = fold::default_seq_fold_mod(fold, doc);\n \n-        for doc.items.each {|item|\n+        for doc.items.each |item| {\n             let def_id = ast_util::local_def(item.id());\n             if fold.ctxt.def_set.contains_key(def_id) {\n                 fold.ctxt.def_map.insert(def_id, item);\n@@ -149,7 +149,7 @@ fn build_reexport_def_map(\n     fn fold_nmod(fold: fold::fold<ctxt>, doc: doc::nmoddoc) -> doc::nmoddoc {\n         let doc = fold::default_seq_fold_nmod(fold, doc);\n \n-        for doc.fns.each {|fndoc|\n+        for doc.fns.each |fndoc| {\n             let def_id = ast_util::local_def(fndoc.id());\n             if fold.ctxt.def_set.contains_key(def_id) {\n                 fold.ctxt.def_map.insert(def_id, doc::fntag(fndoc));\n@@ -166,12 +166,12 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n     let def_assoc_list = to_assoc_list(def_map);\n     #debug(\"def_map: %?\", def_assoc_list);\n \n-    let assoc_list = do astsrv::exec(srv) {|ctxt|\n+    let assoc_list = do astsrv::exec(srv) |ctxt| {\n \n         let def_map = from_def_assoc_list(def_assoc_list);\n         let path_map = map::str_hash::<~[(str,doc::itemtag)]>();\n \n-        for ctxt.exp_map.each {|exp_id, defs|\n+        for ctxt.exp_map.each |exp_id, defs| {\n             let path = alt check ctxt.ast_map.get(exp_id) {\n               ast_map::node_export(_, path) { path }\n             };\n@@ -183,7 +183,7 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n             let modpath = ast_map::path_to_str(vec::init(*path));\n \n             let mut reexportdocs = ~[];\n-            for defs.each {|def|\n+            for defs.each |def| {\n                 if !def.reexp { cont; }\n                 alt def_map.find(def.id) {\n                   some(itemtag) {\n@@ -194,8 +194,8 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n             }\n \n             if reexportdocs.len() > 0u {\n-                do option::iter(path_map.find(modpath)) {|docs|\n-                    reexportdocs = docs + vec::filter(reexportdocs, {|x|\n+                do option::iter(path_map.find(modpath)) |docs| {\n+                    reexportdocs = docs + vec::filter(reexportdocs, |x| {\n                         !vec::contains(docs, x)\n                     });\n                 }\n@@ -205,7 +205,7 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n             }\n         }\n \n-        for find_reexport_impl_docs(ctxt, def_map).each {|elt|\n+        for find_reexport_impl_docs(ctxt, def_map).each |elt| {\n             let (path, doc) = elt;\n             let docs = alt path_map.find(path) {\n               some(docs) { docs + ~[(doc)] }\n@@ -226,7 +226,7 @@ fn find_reexport_impl_docs(\n ) -> ~[(str, (str, doc::itemtag))] {\n     let docs = @mut ~[];\n \n-    do for_each_reexported_impl(ctxt) {|mod_id, i|\n+    do for_each_reexported_impl(ctxt) |mod_id, i| {\n         let path = alt ctxt.ast_map.find(mod_id) {\n           some(ast_map::node_item(item, path)) {\n             let path = ast_map::path_to_str(*path);\n@@ -256,7 +256,7 @@ fn for_each_reexported_impl(\n     f: fn@(ast::node_id, resolve::_impl)\n ) {\n     let visitor = @{\n-        visit_mod: {|a,b,c|visit_mod(ctxt, f, a, b, c)}\n+        visit_mod: |a,b,c| visit_mod(ctxt, f, a, b, c)\n         with *visit::default_simple_visitor()\n     };\n     let visitor = visit::mk_simple_visitor(visitor);\n@@ -272,7 +272,7 @@ fn for_each_reexported_impl(\n         let all_impls = all_impls(m);\n         alt check *ctxt.impl_map.get(mod_id) {\n           list::cons(impls, @list::nil) {\n-            for vec::each(*impls) {|i|\n+            for vec::each(*impls) |i| {\n                 // This impl is not an item in the current mod\n                 if !all_impls.contains_key(i.did) {\n                     // Ignore external impls because I don't\n@@ -289,7 +289,7 @@ fn for_each_reexported_impl(\n \n fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n     let all_impls = ast_util::new_def_hash();\n-    for m.items.each {|item|\n+    for m.items.each |item| {\n         alt item.node {\n           ast::item_impl(_, _, _, _, _) {\n             all_impls.insert(ast_util::local_def(item.id), ());\n@@ -338,7 +338,7 @@ fn merge_reexports(\n         #debug(\"looking for reexports in path %?\", path);\n         alt path_map.find(str::connect(path, \"::\")) {\n           some(name_docs) {\n-            do vec::foldl(~[], name_docs) {|v, name_doc|\n+            do vec::foldl(~[], name_docs) |v, name_doc| {\n                 let (name, doc) = name_doc;\n                 v + ~[reexport_doc(doc, name)]\n             }\n@@ -462,7 +462,7 @@ fn should_duplicate_multiple_reexported_items() {\n                   import a::b; import a::c; \\\n                   export b; export c; \\\n                   }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = path_pass::mk_pass().f(srv, doc);\n         let doc = run(srv, doc);\n@@ -484,7 +484,7 @@ fn should_rename_items_reexported_with_different_names() {\n #[test]\n fn should_reexport_in_topmod() {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"core\");\n             let doc = path_pass::mk_pass().f(srv, doc);\n             run(srv, doc)\n@@ -515,7 +515,7 @@ fn should_not_reexport_multiple_times() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             let doc = path_pass::mk_pass().f(srv, doc);\n             run(srv, doc)"}, {"sha": "0d7f59e6b6dd989a2a2f9c430f5b2b314cf7f444", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -31,11 +31,11 @@ fn run_passes(\n     )];\n \n     let mut passno = 0;\n-    do vec::foldl(doc, passes) {|doc, pass|\n+    do vec::foldl(doc, passes) |doc, pass| {\n         log(debug, #fmt(\"pass #%d\", passno));\n         passno += 1;\n         log(debug, doc);\n-        do time(pass.name) {||\n+        do time(pass.name) || {\n             pass.f(srv, doc)\n         }\n     }\n@@ -82,7 +82,7 @@ fn test_run_passes() {\n         }\n     }\n     let source = \"\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let passes = ~[\n             {\n                 name: \"\",\n@@ -129,11 +129,11 @@ fn time<T>(what: str, f: fn() -> T) -> T {\n fn run(config: config::config) {\n \n     let source_file = config.input_crate;\n-    do astsrv::from_file(source_file) {|srv|\n-        do time(\"wait_ast\") {||\n-            do astsrv::exec(srv) {|_ctxt| () }\n+    do astsrv::from_file(source_file) |srv| {\n+        do time(\"wait_ast\") || {\n+            do astsrv::exec(srv) |_ctxt| { }\n         };\n-        let doc = time(\"extract\", {||\n+        let doc = time(\"extract\", || {\n             let default_name = source_file;\n             extract::from_srv(srv, default_name)\n         });"}, {"sha": "85879c94ba9ab427c75c35af3900cedf15bf17eb", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -34,7 +34,7 @@ fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     let doc = fold::default_seq_fold_iface(fold, doc);\n \n     {\n-        methods: do par::anymap(doc.methods) {|method|\n+        methods: do par::anymap(doc.methods) |method| {\n             let (desc, sections) = sectionalize(method.desc);\n \n             {\n@@ -51,7 +51,7 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     {\n-        methods: do par::anymap(doc.methods) {|method|\n+        methods: do par::anymap(doc.methods) |method| {\n             let (desc, sections) = sectionalize(method.desc);\n \n             {\n@@ -94,7 +94,7 @@ fn sectionalize(desc: option<str>) -> (option<str>, ~[doc::section]) {\n     let mut current_section = none;\n     let mut sections = ~[];\n \n-    for lines.each {|line|\n+    for lines.each |line| {\n         alt parse_header(line) {\n           some(header) {\n             if option::is_some(current_section) {\n@@ -228,7 +228,7 @@ fn should_sectionalize_impl_methods() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             run(srv, doc)"}, {"sha": "c791c099b43b11c8174c196ae4f6123f42b9ee08", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -3,15 +3,15 @@\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    sort_pass::mk_pass(\"sort_item_name\", { |item1, item2|\n+    sort_pass::mk_pass(\"sort_item_name\", |item1, item2| {\n         str::le(item1.name(), item2.name())\n     })\n }\n \n #[test]\n fn test() {\n     let source = \"mod z { } fn y() { }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass().f(srv, doc);\n         assert doc.cratemod().items[0].name() == \"y\";"}, {"sha": "7536da57150d16bacf497aa3e50e9c47be59f89d", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -3,7 +3,7 @@\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    do sort_pass::mk_pass(\"sort_item_type\") { |item1, item2|\n+    do sort_pass::mk_pass(\"sort_item_type\") |item1, item2| {\n         fn score(item: doc::itemtag) -> int {\n             alt item {\n               doc::consttag(_) { 0 }\n@@ -32,7 +32,7 @@ fn test() {\n          iface iiface { fn a(); } \\\n          impl iimpl for int { fn a() { } } \\\n          type itype = int;\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass().f(srv, doc);\n         assert doc.cratemod().items[0].name() == \"iconst\";"}, {"sha": "7cc537851dcb4dcc81d5a8d4a9476b76a8fd7c56", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -47,7 +47,7 @@ fn test() {\n     }\n \n     let source = \"mod z { mod y { } fn x() { } } mod w { }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass(\"\", name_lteq).f(srv, doc);\n         assert doc.cratemod().mods()[0].name() == \"w\";\n@@ -64,7 +64,7 @@ fn should_be_stable() {\n     }\n \n     let source = \"mod a { mod b { } } mod c { mod d { } }\";\n-    do astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass(\"\", always_eq).f(srv, doc);\n         assert doc.cratemod().mods()[0].items[0].name() == \"b\";"}, {"sha": "6d3ef691f64f09cf2fe6d4a0316347abaf6b05e1", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -30,7 +30,7 @@ fn run(\n }\n \n fn maybe_apply_op(op: op, s: option<str>) -> option<str> {\n-    option::map(s, {|s| op(s) })\n+    option::map(s, |s| op(s) )\n }\n \n fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n@@ -45,19 +45,17 @@ fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n }\n \n fn apply_to_sections(op: op, sections: ~[doc::section]) -> ~[doc::section] {\n-    par::anymap(sections, {|section, copy op|\n-        {\n-            header: op(section.header),\n-            body: op(section.body)\n-        }\n+    par::anymap(sections, |section, copy op| {\n+        header: op(section.header),\n+        body: op(section.body)\n     })\n }\n \n fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     {\n-        variants: do par::anymap(doc.variants) {|variant, copy fold|\n+        variants: do par::anymap(doc.variants) |variant, copy fold| {\n             {\n                 desc: maybe_apply_op(fold.ctxt, variant.desc)\n                 with variant\n@@ -77,7 +75,7 @@ fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n }\n \n fn apply_to_methods(op: op, docs: ~[doc::methoddoc]) -> ~[doc::methoddoc] {\n-    do par::anymap(docs) {|doc, copy op|\n+    do par::anymap(docs) |doc, copy op| {\n         {\n             brief: maybe_apply_op(op, doc.brief),\n             desc: maybe_apply_op(op, doc.desc),\n@@ -253,12 +251,12 @@ fn should_execute_on_impl_method_section_bodies() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             let doc = desc_to_brief_pass::mk_pass().f(srv, doc);\n             let doc = sectionalize_pass::mk_pass().f(srv, doc);\n-            mk_pass(\"\", {|s| str::trim(s)}).f(srv, doc)\n+            mk_pass(\"\", |s| str::trim(s) ).f(srv, doc)\n         }\n     }\n }"}, {"sha": "4f7a90743ac8e7865780b95447e85659eb48e7bc", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -10,7 +10,7 @@ is interpreted as the brief description.\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    text_pass::mk_pass(\"trim\", {|s| str::trim(s)})\n+    text_pass::mk_pass(\"trim\", |s| str::trim(s) )\n }\n \n #[test]\n@@ -23,7 +23,7 @@ fn should_trim_text() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             mk_pass().f(srv, doc)"}, {"sha": "69b86bff19b3a4a0ce8da7cb93339f7429b71b92", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -45,7 +45,7 @@ fn fold_fn(\n }\n \n fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n-    do astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) |ctxt| {\n         alt check ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             ident: ident,\n@@ -80,7 +80,7 @@ fn fold_const(\n     let srv = fold.ctxt;\n \n     {\n-        sig: some(do astsrv::exec(srv) {|ctxt|\n+        sig: some(do astsrv::exec(srv) |ctxt| {\n             alt check ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 node: ast::item_const(ty, _), _\n@@ -107,14 +107,14 @@ fn fold_enum(\n     let srv = fold.ctxt;\n \n     {\n-        variants: do par::anymap(doc.variants) {|variant|\n-            let sig = do astsrv::exec(srv) {|ctxt|\n+        variants: do par::anymap(doc.variants) |variant| {\n+            let sig = do astsrv::exec(srv) |ctxt| {\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n-                        do vec::find(ast_variants) {|v|\n+                        do vec::find(ast_variants) |v| {\n                             *v.node.name == variant.name\n                         });\n \n@@ -153,7 +153,7 @@ fn merge_methods(\n     item_id: doc::ast_id,\n     docs: ~[doc::methoddoc]\n ) -> ~[doc::methoddoc] {\n-    do par::anymap(docs) {|doc|\n+    do par::anymap(docs) |doc| {\n         {\n             sig: get_method_sig(srv, item_id, doc.name)\n             with doc\n@@ -166,12 +166,12 @@ fn get_method_sig(\n     item_id: doc::ast_id,\n     method_name: str\n ) -> option<str> {\n-    do astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) |ctxt| {\n         alt check ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, _, methods), _\n           }, _) {\n-            alt check vec::find(methods, {|method|\n+            alt check vec::find(methods, |method| {\n                 *method.ident == method_name\n             }) {\n                 some(method) {\n@@ -186,7 +186,7 @@ fn get_method_sig(\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n-            alt check vec::find(methods, {|method|\n+            alt check vec::find(methods, |method| {\n                 *method.ident == method_name\n             }) {\n                 some(method) {\n@@ -216,12 +216,12 @@ fn fold_impl(\n \n     let srv = fold.ctxt;\n \n-    let (iface_ty, self_ty) = do astsrv::exec(srv) {|ctxt|\n+    let (iface_ty, self_ty) = do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(doc.id()) {\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, iface_ty, self_ty, _), _\n           }, _) {\n-            let iface_ty = option::map(iface_ty, {|p|\n+            let iface_ty = option::map(iface_ty, |p| {\n                 pprust::path_to_str(p.path)\n             });\n             (iface_ty, some(pprust::ty_to_str(self_ty)))\n@@ -271,7 +271,7 @@ fn fold_type(\n     let srv = fold.ctxt;\n \n     {\n-        sig: do astsrv::exec(srv) {|ctxt|\n+        sig: do astsrv::exec(srv) |ctxt| {\n             alt ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 ident: ident,\n@@ -300,7 +300,7 @@ fn should_add_type_signatures() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        do astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "b5e11b0dfd9b7236e72806446343b768b52e143a", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -21,7 +21,8 @@ fn unindent(s: str) -> str {\n     let lines = str::lines_any(s);\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = do vec::foldl(uint::max_value, lines) {|min_indent, line|\n+    let min_indent = do vec::foldl(uint::max_value, lines)\n+        |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at\n         // the line we have. If it is not whitespace, and therefore\n@@ -47,7 +48,7 @@ fn unindent(s: str) -> str {\n         } else {\n             saw_first_line = true;\n             let mut spaces = 0u;\n-            do str::all(line) {|char|\n+            do str::all(line) |char| {\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {\n@@ -63,7 +64,7 @@ fn unindent(s: str) -> str {\n \n     if check vec::is_not_empty(lines) {\n         let unindented = ~[str::trim(vec::head(lines))]\n-            + do par::anymap(vec::tail(lines)) {|line|\n+            + do par::anymap(vec::tail(lines)) |line| {\n             if str::is_whitespace(line) {\n                 line\n             } else {"}, {"sha": "d14ed0e99f5e90abbc538efc8e1eb9a5fe8441f1", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -5,7 +5,7 @@ import comm::*;\n fn foo<T: send copy>(x: T) -> port<T> {\n     let p = port();\n     let c = chan(p);\n-    do task::spawn() {|copy c, copy x|\n+    do task::spawn() |copy c, copy x| {\n         c.send(x);\n     }\n     p"}, {"sha": "9a3f0a0ad362f7c4424ca0239dacadf605630069", "filename": "src/test/auxiliary/cci_class_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -3,7 +3,7 @@ mod kitties {\n class cat {\n   priv {\n     let mut meows : uint;\n-    fn nap() { for uint::range(1u, 10000u) {|_i|}}\n+      fn nap() { for uint::range(1u, 10000u) |_i|{}}\n   }\n \n   let how_hungry : int;"}, {"sha": "cb3d9de652f7d353d0064bb39308af09f23a51f3", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -9,7 +9,7 @@ fn alist_add<A: copy, B: copy>(lst: alist<A,B>, k: A, v: B) {\n \n fn alist_get<A: copy, B: copy>(lst: alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n-    for lst.data.each {|entry|\n+    for lst.data.each |entry| {\n         if eq_fn(entry.key, k) { ret entry.value; }\n     }\n     fail;"}, {"sha": "50553fbdacf9c640c66d03aea14f6037211aaede", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -34,7 +34,7 @@ class port_ptr<T:send> {\n     self.po = po; }\n    drop unsafe {\n     #debug(\"in the port_ptr destructor\");\n-    do task::unkillable {||\n+       do task::unkillable || {\n         let yield = 0u;\n         let yieldp = ptr::addr_of(yield);\n         rustrt::rust_port_begin_detach(self.po, yieldp);"}, {"sha": "52c279716ea52dbacdcd7b7a55d918b14beebeca", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -57,7 +57,7 @@ fn read_line() {\n         \"src/test/bench/shootout-k-nucleotide.data\"\n     );\n \n-    for int::range(0, 3) {|_i|\n+    for int::range(0, 3) |_i| {\n         let reader = result::get(io::file_reader(path));\n         while !reader.eof() {\n             reader.read_line();\n@@ -70,12 +70,12 @@ fn str_set() {\n \n     let s = map::hashmap(str::hash, str::eq);\n \n-    for int::range(0, 1000) {|_i|\n+    for int::range(0, 1000) |_i| {\n         map::set_add(s, r.gen_str(10));\n     }\n     \n     let mut found = 0;\n-    for int::range(0, 1000) {|_i|\n+    for int::range(0, 1000) |_i| {\n         alt s.find(r.gen_str(10)) {\n           some(_) { found += 1; }\n           none { }\n@@ -121,7 +121,7 @@ fn vec_push_all() {\n     let r = rand::rng();\n \n     let mut v = ~[];\n-    for uint::range(0, 1500) {|i|\n+    for uint::range(0, 1500) |i| {\n         let mut rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n         if r.gen_bool() {\n             vec::push_all(v, rv);"}, {"sha": "5dac712414d51ea78056873d510d34c6c9f9dced", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -9,7 +9,7 @@ fn main(args: ~[str]) {\n \n     let n = uint::from_str(args[1]).get();\n \n-    for uint::range(0u, n) {|i|\n+    for uint::range(0u, n) |i| {\n         let x = uint::to_str(i, 10u);\n         log(debug, x);\n     }"}, {"sha": "7e4a327ea12e72c8f1654d1d426b97050068e24c", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -6,15 +6,15 @@ import io::writer_util;\n \n fn collect_raw(num: uint) -> ~[uint] {\n     let mut result = ~[];\n-    for uint::range(0u, num) { |i|\n+    for uint::range(0u, num) |i| {\n         vec::push(result, i);\n     }\n     ret result;\n }\n \n fn collect_dvec(num: uint) -> ~[mut uint] {\n     let result = dvec();\n-    for uint::range(0u, num) { |i|\n+    for uint::range(0u, num) |i| {\n         result.push(i);\n     }\n     ret dvec::unwrap(result);\n@@ -37,9 +37,9 @@ fn main(args: ~[str]) {\n \n     // check each vector\n     assert raw_v.len() == max;\n-    for raw_v.eachi { |i, v| assert i == v; }\n+    for raw_v.eachi |i, v| { assert i == v; }\n     assert dvec_v.len() == max;\n-    for dvec_v.eachi { |i, v| assert i == v; }\n+    for dvec_v.eachi |i, v| { assert i == v; }\n \n     let raw = mid - start;\n     let dvec = end - mid;"}, {"sha": "9e24e9defcc49ee4d088b2a5dd42df6a880a39e1", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -60,36 +60,36 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n         }\n     }\n \n-    do vec::from_fn((1u << scale) * edgefactor) {|_i|\n+    do vec::from_fn((1u << scale) * edgefactor) |_i| {\n         choose_edge(0i64, 0i64, scale, r)\n     }\n }\n \n fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n-    let graph = do vec::from_fn(N) {|_i| \n-        map::hashmap::<node_id, ()>({|x| x as uint }, {|x, y| x == y })\n+    let graph = do vec::from_fn(N) |_i| {\n+        map::hashmap::<node_id, ()>(|x| x as uint , |x, y| x == y )\n     };\n \n-    do vec::each(edges) {|e| \n+    do vec::each(edges) |e| {\n         let (i, j) = e;\n         map::set_add(graph[i], j);\n         map::set_add(graph[j], i);\n         true\n     }\n \n-    do graph.map() {|v|\n+    do graph.map() |v| {\n         map::vec_from_set(v)\n     }\n }\n \n fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n-    let keys = map::hashmap::<node_id, ()>({|x| x as uint }, {|x, y| x == y });\n+    let keys = map::hashmap::<node_id, ()>(|x| x as uint , |x, y| x == y );\n     let r = rand::rng();\n \n     while keys.size() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n-        if graph[k].len() > 0u && vec::any(graph[k], {|i|\n+        if graph[k].len() > 0u && vec::any(graph[k], |i| {\n             i != k as node_id\n         }) {\n             map::set_add(keys, k as node_id);\n@@ -113,7 +113,7 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     while Q.size() > 0u {\n         let t = Q.pop_front();\n \n-        do graph[t].each() {|k| \n+        do graph[t].each() |k| {\n             if marks[k] == -1i64 {\n                 marks[k] = t;\n                 Q.add_back(k);\n@@ -140,7 +140,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         black(node_id)\n     };\n \n-    let mut colors = do vec::from_fn(graph.len()) {|i|\n+    let mut colors = do vec::from_fn(graph.len()) |i| {\n         if i as node_id == key {\n             gray(key)\n         }\n@@ -161,7 +161,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         // Do the BFS.\n         log(info, #fmt(\"PBFS iteration %?\", i));\n         i += 1u;\n-        colors = do colors.mapi() {|i, c|\n+        colors = do colors.mapi() |i, c| {\n             let c : color = c;\n             alt c {\n               white {\n@@ -171,7 +171,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n                 \n                 let mut color = white;\n \n-                do neighbors.each() {|k|\n+                do neighbors.each() |k| {\n                     if is_gray(colors[k]) {\n                         color = gray(k);\n                         false\n@@ -188,7 +188,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     // Convert the results.\n-    do vec::map(colors) {|c|\n+    do vec::map(colors) |c| {\n         alt c {\n           white { -1i64 }\n           black(parent) { parent }\n@@ -209,7 +209,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n         black(node_id)\n     };\n \n-    let mut colors = do vec::from_fn((*arc::get(&graph)).len()) {|i|\n+    let mut colors = do vec::from_fn((*arc::get(&graph)).len()) |i| {\n         if i as node_id == key {\n             gray(key)\n         }\n@@ -235,7 +235,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n \n         let color = arc::arc(colors);\n \n-        colors = do par::mapi_factory(*arc::get(&color)) {||\n+        colors = do par::mapi_factory(*arc::get(&color)) || {\n             let colors = arc::clone(&color);\n             let graph = arc::clone(&graph);\n             fn~(i: uint, c: color) -> color {\n@@ -250,7 +250,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n                     \n                     let mut color = white;\n                     \n-                    do neighbors.each() {|k|\n+                    do neighbors.each() |k| {\n                         if is_gray(colors[k]) {\n                             color = gray(k);\n                             false\n@@ -268,7 +268,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n     }\n \n     // Convert the results.\n-    do par::map(colors) {|c|\n+    do par::map(colors) |c| {\n         alt c {\n           white { -1i64 }\n           black(parent) { parent }\n@@ -291,7 +291,7 @@ fn validate(edges: ~[(node_id, node_id)],\n     log(info, \"Verifying tree structure...\");\n \n     let mut status = true;\n-    let level = do tree.map() {|parent| \n+    let level = do tree.map() |parent| {\n         let mut parent = parent;\n         let mut path = ~[];\n \n@@ -322,7 +322,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, \"Verifying tree edges...\");\n \n-    let status = do tree.alli() {|k, parent|\n+    let status = do tree.alli() |k, parent| {\n         if parent != root && parent != -1i64 {\n             level[parent] == level[k] - 1\n         }\n@@ -338,7 +338,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, \"Verifying graph edges...\");\n \n-    let status = do edges.all() {|e| \n+    let status = do edges.all() |e| {\n         let (u, v) = e;\n \n         abs(level[u] - level[v]) <= 1\n@@ -355,7 +355,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, \"Verifying tree and graph edges...\");\n \n-    let status = do par::alli(tree) {|u, v|\n+    let status = do par::alli(tree) |u, v| {\n         let u = u as node_id;\n         if v == -1i64 || u == root {\n             true\n@@ -397,7 +397,7 @@ fn main(args: ~[str]) {\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0u;\n-    vec::each(graph, {|edges| total_edges += edges.len(); true });\n+    vec::each(graph, |edges| { total_edges += edges.len(); true });\n \n     io::stdout().write_line(#fmt(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2u,\n@@ -408,7 +408,7 @@ fn main(args: ~[str]) {\n \n     let graph_arc = arc::arc(copy graph);\n \n-    do gen_search_keys(graph, num_keys).map() {|root|\n+    do gen_search_keys(graph, num_keys).map() |root| {\n         io::stdout().write_line(\"\");\n         io::stdout().write_line(#fmt(\"Search key: %?\", root));\n "}, {"sha": "3d72895038c0fc85ab45761433234455e130bc68", "filename": "src/test/bench/msgsend-ring-new.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -15,7 +15,7 @@ fn thread_ring(i: uint,\n                num_chan: chan<uint>,\n                num_port: port<uint>) {\n     // Send/Receive lots of messages.\n-    for uint::range(0u, count) {|j|\n+    for uint::range(0u, count) |j| {\n         num_chan.send(i * j);\n         num_port.recv();\n     };\n@@ -41,12 +41,12 @@ fn main(args: ~[str]) {\n     // create the ring\n     let mut futures = ~[];\n \n-    for uint::range(1u, num_tasks) {|i|\n+    for uint::range(1u, num_tasks) |i| {\n         let get_chan = port();\n         let get_chan_chan = chan(get_chan);\n         {\n             let num_chan = num_chan.clone();\n-            futures += ~[do future::spawn {|move num_chan, move get_chan_chan|\n+            futures += ~[do future::spawn |move num_chan, move get_chan_chan| {\n                 let p = port();\n                 get_chan_chan.send(chan(p));\n                 thread_ring(i, msg_per_task, num_chan,  p)\n@@ -60,7 +60,7 @@ fn main(args: ~[str]) {\n     thread_ring(0u, msg_per_task, num_chan, num_port);\n \n     // synchronize\n-    for futures.each {|f| f.get() };\n+    for futures.each |f| { f.get() };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "59da4b6c9c17f4c73d064ba9b50f5ac0a740e7b5", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -15,7 +15,7 @@ fn thread_ring(i: uint,\n                num_chan: comm::chan<uint>,\n                num_port: comm::port<uint>) {\n     // Send/Receive lots of messages.\n-    for uint::range(0u, count) {|j|\n+    for uint::range(0u, count) |j| {\n         num_chan.send(i * j);\n         num_port.recv();\n     };\n@@ -41,11 +41,11 @@ fn main(args: ~[str]) {\n     // create the ring\n     let mut futures = ~[];\n \n-    for uint::range(1u, num_tasks) {|i|\n+    for uint::range(1u, num_tasks) |i| {\n         let get_chan = port();\n         let get_chan_chan = chan(get_chan);\n \n-        futures += ~[do future::spawn {|copy num_chan, move get_chan_chan|\n+        futures += ~[do future::spawn |copy num_chan, move get_chan_chan| {\n             let p = port();\n             get_chan_chan.send(chan(p));\n             thread_ring(i, msg_per_task, num_chan,  p)\n@@ -58,7 +58,7 @@ fn main(args: ~[str]) {\n     thread_ring(0u, msg_per_task, num_chan, num_port);\n \n     // synchronize\n-    for futures.each {|f| f.get() };\n+    for futures.each |f| { f.get() };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "2b47e78204f81109468647a288207bc0519c3ccf", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -30,24 +30,24 @@ fn server(requests: comm::port<request>, responses: comm::chan<uint>) {\n fn run(args: ~[str]) {\n     let from_child = comm::port();\n     let to_parent = comm::chan(from_child);\n-    let to_child = do task::spawn_listener {|po|\n+    let to_child = do task::spawn_listener |po| {\n         server(po, to_parent);\n     };\n     let size = option::get(uint::from_str(args[1]));\n     let workers = option::get(uint::from_str(args[2]));\n     let start = std::time::precise_time_s();\n     let to_child = to_child;\n     let mut worker_results = ~[];\n-    for uint::range(0u, workers) {|_i|\n+    for uint::range(0u, workers) |_i| {\n         let builder = task::builder();\n         vec::push(worker_results, task::future_result(builder));\n-        do task::run(builder) {||\n-            for uint::range(0u, size / workers) {|_i|\n+        do task::run(builder) || {\n+            for uint::range(0u, size / workers) |_i| {\n                 comm::send(to_child, bytes(100u));\n             }\n         };\n     }\n-    vec::iter(worker_results, {|r| future::get(r); });\n+    vec::iter(worker_results, |r| { future::get(r); } );\n     comm::send(to_child, stop);\n     let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();"}, {"sha": "5f7dbdf71fff54d721dfed2b9df5cc9816daf1a2", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -26,7 +26,7 @@ type aminoacids = {ch: char, prob: u32};\n fn make_cumulative(aa: ~[aminoacids]) -> ~[aminoacids] {\n     let mut cp: u32 = 0u32;\n     let mut ans: ~[aminoacids] = ~[];\n-    for aa.each {|a| cp += a.prob; ans += ~[{ch: a.ch, prob: cp}]; }\n+    for aa.each |a| { cp += a.prob; ans += ~[{ch: a.ch, prob: cp}]; }\n     ret ans;\n }\n \n@@ -47,7 +47,7 @@ fn make_random_fasta(wr: io::writer, id: str, desc: str, genelist: ~[aminoacids]\n     wr.write_line(\">\" + id + \" \" + desc);\n     let rng = @{mut last: std::rand::rng().next()};\n     let mut op: str = \"\";\n-    for uint::range(0u, n as uint) {|_i|\n+    for uint::range(0u, n as uint) |_i| {\n         str::push_char(op, select_random(myrandom_next(rng, 100u32),\n                                          genelist));\n         if str::len(op) >= LINE_LENGTH() {\n@@ -62,7 +62,7 @@ fn make_repeat_fasta(wr: io::writer, id: str, desc: str, s: str, n: int) unsafe\n     wr.write_line(\">\" + id + \" \" + desc);\n     let mut op: str = \"\";\n     let sl: uint = str::len(s);\n-    for uint::range(0u, n as uint) {|i|\n+    for uint::range(0u, n as uint) |i| {\n         str::unsafe::push_byte(op, s[i % sl]);\n         if str::len(op) >= LINE_LENGTH() {\n             wr.write_line(op);"}, {"sha": "0054aad92f618982b3c6a85b8d5be50f0586332b", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -100,7 +100,7 @@ fn make_sequence_processor(sz: uint, from_parent: comm::port<~[u8]>,\n       line = comm::recv(from_parent);\n       if line == ~[] { break; }\n \n-      carry = windows_with_carry(carry + line, sz, { |window|\n+       carry = windows_with_carry(carry + line, sz, |window| {\n          update_freq(freqs, window);\n          total += 1u;\n       });\n@@ -139,10 +139,10 @@ fn main(args: ~[str]) {\n \n    // initialize each sequence sorter\n    let sizes = ~[1u,2u,3u,4u,6u,12u,18u];\n-   let from_child = vec::map (sizes, { |_sz|     comm::port() });\n-   let to_parent  = vec::mapi(sizes, { |ii, _sz| comm::chan(from_child[ii]) });\n+   let from_child = vec::map (sizes, |_sz| comm::port() );\n+   let to_parent  = vec::mapi(sizes, |ii, _sz| comm::chan(from_child[ii]) );\n    let to_child   = vec::mapi(sizes, fn@(ii: uint, sz: uint) -> comm::chan<~[u8]> {\n-      ret do task::spawn_listener { |from_parent|\n+       ret do task::spawn_listener |from_parent| {\n          make_sequence_processor(sz, from_parent, to_parent[ii]);\n       };\n    });\n@@ -174,7 +174,7 @@ fn main(args: ~[str]) {\n          (_, true) {\n             let line_bytes = str::bytes(line);\n \n-            for sizes.eachi { |ii, _sz|\n+           for sizes.eachi |ii, _sz| {\n                let mut lb = line_bytes;\n                comm::send(to_child[ii], lb);\n             }\n@@ -186,12 +186,12 @@ fn main(args: ~[str]) {\n    }\n \n    // finish...\n-   for sizes.eachi { |ii, _sz|\n+    for sizes.eachi |ii, _sz| {\n       comm::send(to_child[ii], ~[]);\n    }\n \n    // now fetch and print result messages\n-   for sizes.eachi { |ii, _sz|\n+    for sizes.eachi |ii, _sz| {\n       io::println(comm::recv(from_child[ii]));\n    }\n }"}, {"sha": "d400990ff6d83324f91f9aa84fbd6d1e948c0340", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -69,8 +69,7 @@ fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n     let incr = 2f64/(size as f64);\n     let y = incr*(i as f64) - 1f64;\n     let xincr = 8f64*incr;\n-    for uint::range(0_u, size/8_u) {\n-        |j|\n+    for uint::range(0_u, size/8_u) |j| {\n         let x = {re: xincr*(j as f64) - 1.5f64, im: y};\n         vec::push(crv, fillbyte(x, incr));\n     };\n@@ -158,12 +157,12 @@ fn main(args: ~[str]) {\n \n     let writep = comm::port();\n     let writech = comm::chan(writep);\n-    do task::spawn {||\n+    do task::spawn || {\n         writer(path, writech, size);\n     };\n     let ch = comm::recv(writep);\n-    for uint::range(0_u, size) {|j|\n-        do task::spawn {|| chanmb(j, size, ch);};\n+    for uint::range(0_u, size) |j| {\n+        task::spawn(|| chanmb(j, size, ch) );\n         if j % yieldevery == 0_u {\n             #debug(\"Y %u\", j);\n             task::yield();"}, {"sha": "8ce91865b04c7e72176a60e0c0b9ade448e50656", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -32,15 +32,15 @@ fn fib(n: int) -> int {\n         } else {\n             let p = port();\n             let ch = chan(p);\n-            task::spawn({|| pfib(ch, n - 1); });\n-            task::spawn({|| pfib(ch, n - 2); });\n+            task::spawn(|| pfib(ch, n - 1) );\n+            task::spawn(|| pfib(ch, n - 2) );\n             send(c, recv(p) + recv(p));\n         }\n     }\n \n     let p = port();\n     let ch = chan(p);\n-    let t = task::spawn({|| pfib(ch, n); });\n+    let t = task::spawn(|| pfib(ch, n) );\n     ret recv(p);\n }\n \n@@ -70,12 +70,12 @@ fn stress_task(&&id: int) {\n \n fn stress(num_tasks: int) {\n     let mut results = ~[];\n-    for range(0, num_tasks) {|i|\n+    for range(0, num_tasks) |i| {\n         let builder = task::builder();\n         results += ~[task::future_result(builder)];\n-        task::run(builder, {|| stress_task(i); });\n+        task::run(builder, || stress_task(i) );\n     }\n-    for results.each {|r| future::get(r); }\n+    for results.each |r| { future::get(r); }\n }\n \n fn main(args: ~[str]) {\n@@ -99,8 +99,8 @@ fn main(args: ~[str]) {\n \n         let out = io::stdout();\n \n-        for range(1, max + 1) {|n|\n-            for range(0, num_trials) {|i|\n+        for range(1, max + 1) |n| {\n+            for range(0, num_trials) |i| {\n                 let start = time::precise_time_ns();\n                 let fibn = fib(n);\n                 let stop = time::precise_time_ns();"}, {"sha": "be2e1fc3ad884065c035531aec8c8873495f9736", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -8,9 +8,9 @@ fn start(+token: int) {\n \n     let p = comm::port();\n     let mut ch = comm::chan(p);\n-    for int::range(2, n_threads + 1) { |i|\n+    for int::range(2, n_threads + 1) |i| {\n         let id = n_threads + 2 - i;\n-        let to_child = do task::spawn_listener::<int> {|p, copy ch|\n+        let to_child = do task::spawn_listener::<int> |p, copy ch| {\n             roundtrip(id, p, ch)\n         };\n         ch = to_child;"}, {"sha": "4a712e2d995e111124203f24fa0e9c70eb2fb498", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -6,13 +6,13 @@ import std::smallintmap::{smallintmap, map};\n import io::writer_util;\n \n fn append_sequential(min: uint, max: uint, map: smallintmap<uint>) {\n-    for uint::range(min, max) { |i|\n+    for uint::range(min, max) |i| {\n         map.insert(i, i + 22u);\n     }\n }\n \n fn check_sequential(min: uint, max: uint, map: smallintmap<uint>) {\n-    for uint::range(min, max) { |i|\n+    for uint::range(min, max) |i| {\n         assert map.get(i) == i + 22u;\n     }\n }\n@@ -31,7 +31,7 @@ fn main(args: ~[str]) {\n     let mut checkf = 0.0;\n     let mut appendf = 0.0;\n \n-    for uint::range(0u, rep) {|_r|\n+    for uint::range(0u, rep) |_r| {\n         let map = smallintmap::mk();\n         let start = std::time::precise_time_s();\n         append_sequential(0u, max, map);"}, {"sha": "61055b49c5d6e4cca7aeaa8c973521a50763d448", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -51,15 +51,15 @@ fn solve_grid(g: grid_t) {\n         if start_color < 10u8 {\n             // colors not yet used\n             let avail = bitv::bitv(10u, false);\n-            for u8::range(start_color, 10u8) { |color|\n+            for u8::range(start_color, 10u8) |color| {\n                 bitv::set(avail, color as uint, true);\n             }\n \n             // drop colors already in use in neighbourhood\n             drop_colors(g, avail, row, col);\n \n             // find first remaining color that is available\n-            for uint::range(1u, 10u) {|i|\n+            for uint::range(1u, 10u) |i| {\n                 if bitv::get(avail, i) {\n                     g[row][col] = i as u8;\n                     ret true;\n@@ -77,24 +77,24 @@ fn solve_grid(g: grid_t) {\n             if color != 0u8 { bitv::set(colors, color as uint, false); }\n         }\n \n-        let it = {|a,b|drop_color(g, avail, a, b)};\n+        let it = |a,b| drop_color(g, avail, a, b);\n \n-        for u8::range(0u8, 9u8) { |idx|\n+        for u8::range(0u8, 9u8) |idx| {\n             it(idx, col); /* check same column fields */\n             it(row, idx); /* check same row fields */\n         }\n \n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n-        for u8::range(row0, row0 + 3u8) { |alt_row|\n-            for u8::range(col0, col0 + 3u8) { |alt_col| it(alt_row, alt_col); }\n+        for u8::range(row0, row0 + 3u8) |alt_row| {\n+            for u8::range(col0, col0 + 3u8) |alt_col| { it(alt_row, alt_col); }\n         }\n     }\n \n     let mut work: ~[(u8, u8)] = ~[]; /* queue of uncolored fields */\n-    for u8::range(0u8, 9u8) { |row|\n-        for u8::range(0u8, 9u8) { |col|\n+    for u8::range(0u8, 9u8) |row| {\n+        for u8::range(0u8, 9u8) |col| {\n             let color = (*g)[row][col];\n             if color == 0u8 { work += ~[(row, col)]; }\n         }\n@@ -117,9 +117,9 @@ fn solve_grid(g: grid_t) {\n }\n \n fn write_grid(f: io::writer, g: grid_t) {\n-    for u8::range(0u8, 9u8) { |row|\n+    for u8::range(0u8, 9u8) |row| {\n         f.write_str(#fmt(\"%u\", (*g)[row][0] as uint));\n-        for u8::range(1u8, 9u8) { |col|\n+        for u8::range(1u8, 9u8) |col| {\n             f.write_str(#fmt(\" %u\", (*g)[row][col] as uint));\n         }\n         f.write_char('\\n');\n@@ -130,7 +130,7 @@ fn main(args: ~[str]) {\n     let grid = if vec::len(args) == 1u {\n         // FIXME create sudoku inline since nested vec consts dont work yet\n         // (#571)\n-        let g = vec::from_fn(10u, {|_i|\n+        let g = vec::from_fn(10u, |_i| {\n             vec::to_mut(vec::from_elem(10u, 0 as u8))\n         });\n         g[0][1] = 4u8;"}, {"sha": "d898acb28abbe5c32683ee84e7dc3172c0976bc6", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b", "patch": "@@ -17,9 +17,9 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    do iter::repeat(repeat as uint) { ||\n+    do iter::repeat(repeat as uint) || {\n         #debug(\"starting %.4f\", precise_time_s());\n-        do task::try { ||\n+        do task::try || {\n             recurse_or_fail(depth, none)\n         };\n         #debug(\"stopping %.4f\", precise_time_s());"}, {"sha": "43c778d37375082eabec7b564a8dbf1695f05e85", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "7cc9446250e24db535092f7aa7d02e0fd8abaa4f", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "fa22e77eac7fddc43ffc26909f2986af767792e8", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "83c0eb53d99b369655fc3cff65fae76429a9712c", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "617af110991a7fc38de6ce79b6d48c47224daa9e", "filename": "src/test/compile-fail/bad-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "e4671431e4c5afa09edfca9351d8fde027cde987", "filename": "src/test/compile-fail/bad-var-env-capture-in-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fbad-var-env-capture-in-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fbad-var-env-capture-in-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-var-env-capture-in-block-arg.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "72128316f0aafd05feec4433d4bd6712eef4aeb1", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "d1d1731e8c5993015838b9eac299182a028ceed7", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "679e3c4797b92c4a878cec97fba5da9bb3fb3087", "filename": "src/test/compile-fail/block-deinitializes-upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "41a2182ba2b26923f803c41624e2abc2471ec881", "filename": "src/test/compile-fail/block-must-not-have-result-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "3c8d9ececb8004c8e4a94ccf3b9966af0c0bed00", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "04bb2dcafabd41a254c724a44d4dfaf46e773e2b", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "9a6ea30553fc04aac3c43a9686e388ff35206ca1", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "27359cfef90b45fbcce1cb13b038744fc43dd530", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "638692ee7c4e4fa67e07899cb1a982372ac1a26e", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "37f7b2161dc678792995b84fb32a267017d5155e", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "a2d27a6c77d59463a22a124ee89a8a3f390283dc", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "24abb7dae5929b4652118bb4cea5293638850f9d", "filename": "src/test/compile-fail/cap-clause-with-stack-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "8bea4fcf9348ca6c5938dc393943a9acd8e25e65", "filename": "src/test/compile-fail/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "00f9433eef0f38fb6948d498c34aab6e207fa0ad", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "d9d536418f3ba549e3460d4208aeedb362290deb", "filename": "src/test/compile-fail/issue-1896.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "b5e68b51ed473cfe7e278d5a9e2d6fbb7066e3f7", "filename": "src/test/compile-fail/issue-1965.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4927144e2597c3c9011fc15f0418c946e0b6a970", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "f70fcf520d263e9f4ad4ee4765f55e6d53b609f7", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "81182c4e9ab5651394d0df4243b4b065df94a82f", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4a7a6d4d44095b817970278c2065ae55d70afb5d", "filename": "src/test/compile-fail/issue-2487-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "7e3265f36e3b9db94068f8318d45ecb5d291b81e", "filename": "src/test/compile-fail/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "944282a4deb06fae36d945155bbb6c335606557f", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "105ffa11703046eaa2e88a2bf6d93151ad845926", "filename": "src/test/compile-fail/liveness-closure-require-ret.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "7177470e136a0767ed38530ebf8495b0fe3f872f", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "299b491605edbb3c6ff2926f2a6590ee438c7638", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "ca45ce26f169fb5c9b0b2939694e0053eb2faeb7", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "a89f11be34357b26a17fb8688516be9088863349", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "1a2fd1a6eb1a64d1d004dd5bcee7ee7710b4b39b", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "5d5ced198f1ea1d86fcc78e4d6ecbad829972abc", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "986e0801e74318f7d45f970c93714c8cf6a42c45", "filename": "src/test/compile-fail/pure-loop-body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4920d1c71f520719227c9bac12bb2763ceafe3bc", "filename": "src/test/compile-fail/regions-addr-of-upvar-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "69bfe7bd020a94fa2b2b70430d34786bb3081271", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "0e83f30e8a34d62ec6b4746524e902abc5273040", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "974e01c061513adaef76b6b4e99091e52076ff59", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4418d82a0e612e4c18d71d070b3a5d6dc47378f1", "filename": "src/test/pretty/block-arg-disambig.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "546020b6cd87fb5f74ee6e08b5454bbef4df51d4", "filename": "src/test/pretty/disamb-stmt-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "1536a294d186567a2809370e71f24997626ce971", "filename": "src/test/pretty/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fpretty%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Fpretty%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdo1.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "3fcc768c4d9569aef18d2002d2071796c52b2250", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "8dac4036c0aab5a4488ab46c5275c05d554ab5e2", "filename": "src/test/run-fail/crust-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fcrust-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fcrust-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fcrust-fail.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "a52b75f6cad7eff6bda470bf136004fa49cfbef3", "filename": "src/test/run-fail/for-each-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "1c64b20c0b75679e5c32b3197f875f04e696c780", "filename": "src/test/run-fail/issue-2144.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fissue-2144.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fissue-2144.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2144.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "921842a32d20dba74d8995009aec30316f216f9d", "filename": "src/test/run-fail/issue-2156.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "6189567d01706193105c2f29dc9ab37f19edb1ba", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "f2ad8fb39ea4fb31a2a788ebb1c3bf6c31420eec", "filename": "src/test/run-fail/linked-failure2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "22f6661716c67b2bc430c68d374863770211e5db", "filename": "src/test/run-fail/linked-failure3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure3.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "fb7d596145d4f96d0048c99d502ff918da51bd65", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "9ecc3c6a07b0488a51f22551076f9d13130d2f65", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "281b36e27a31b6b84f19655ae03bdcb6652377a3", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "a10f23c911784914c211a303a050f6a99b125b9c", "filename": "src/test/run-fail/morestack4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack4.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "a38b9ed1f70a86ae0f2cd9a0ca5889df58febabd", "filename": "src/test/run-fail/rt-set-exit-status-fail2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "5d780f1f5f1a29fa7aacae2e7066cfa14bb974ce", "filename": "src/test/run-fail/spawnfail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fspawnfail.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "1e703bc47f93e431a9d514f7bfec56aa89c64ade", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "ef3d38ab86ef1e855d7a73c0696c3fe05a95856b", "filename": "src/test/run-fail/unwind-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "babf617dd7281bbbc9f98b6b0d1d609f1bc81616", "filename": "src/test/run-fail/unwind-iter2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "cc516c550a246c60bd98b6be1203a1044885b2bf", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "7dc9b112f23c0f6ea026f386a90f85e6b3fa2fc6", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "ecd9ee45034c4cee97c8cfaa9f2fd8c356628a61", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "5a99563e2af0f9b3e9229ef880444fabd291e6be", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4a349a827a45e9b8d1c57fac32043f62f089f60c", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "fa2a05365e94505cd5007cd36a9afda2d43d90c5", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "f33f0b3bc8f924c7eaef22845ba2dfc5886be295", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "5e9c22d05094cab96b5b7d1ab3fd9327d9e42365", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4b912938e4abb182b8ceda745a180f97d77de9db", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "039caef3d998bc3fb667ce29963ae31e4a7697b3", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "9c2b4311b9099339f12ed099708ab50e2eb8a120", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "94c55ba33a18ab6b4657e1d00f6ad04d25ae08c2", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "53f158471e8b1cd7dd610cd41670d416845914b8", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "f2d7c5a7cceb62d4a7ab2be0ae3b0eafc616bb9b", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "c3bb0cb77a703315f51a8ce36bee62e397174d67", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4d479418877c34ab40e161ac228aa000bfe0171a", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "8a2d77c4d96485aed062ffde08340103dfbcfc21", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "46f3276a4e53b340f02c4180dc54c9e3c90907a1", "filename": "src/test/run-pass/block-arg-used-as-lambda.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "2bcdcfccdfd564d776b8a2b5562b58f701706e70", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "ca6fe9b659da37bf832f41e4d1d495affd1cb421", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "e9d548dd6ef246f72e8d9b7f6f94b984508bbb0c", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "125e003a3f5cbb6438b68bdb56a70eea2d7de15c", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "4c98bb840b4815983ab000dc993bac9fc1305099", "filename": "src/test/run-pass/block-vec-map2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "723d0079617aaee172b0f4352ee85080109c97c4", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "e5ea87b99964fb85db7e44645a3d84f3bdba538a", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "9320d91e4a0a1de6a6b142284e2665e48abf0825", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "abe1faeed59707e6ea7bcb4aec60b8c5facd160f", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "68c7c768618f8c9594005970fc8fcbd60252df52", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "f04c81527c206d90a17e3d629de88c9ebfb3a7dc", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "d8c6fb29c3b235737bb30808cddd39e78a7994e9", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "260c1d45b76b8b5c8eb7bf1ab76dac156890e513", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "d69982b58de9bcc6e0a5f416a2c17f8ccd71b6e5", "filename": "src/test/run-pass/cci_impl_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "9e8986bd5ba2254fa21020223da4e499686dcc2e", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "070cad2dfb40c8fc20d307deb1a75117371b8430", "filename": "src/test/run-pass/cci_no_inline_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "ffd115c5b4e44cb8f413df32787c63ab6901a2f1", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "1c3ad872477b4fbcbf765ff5f71ad5356509d0b8", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "89f5e656a68b64d180d2c2409da8e685175606ca", "filename": "src/test/run-pass/class-cast-to-iface-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "8f7c41132684e3c8b5eb253e55015f96ada3ed99", "filename": "src/test/run-pass/class-iface-bounded-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}, {"sha": "127a743427cdbb2be67b9b0f527e034aa5811e65", "filename": "src/test/run-pass/class-impl-parameterized-iface.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc2b5995fdef69fe1dbdbba3703398c0aa547b/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs?ref=d1fc2b5995fdef69fe1dbdbba3703398c0aa547b"}]}