{"sha": "438eabbba4c4540b4c28aa20c863f05e90d0b18c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzOGVhYmJiYTRjNDU0MGI0YzI4YWEyMGM4NjNmMDVlOTBkMGIxOGM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-09T01:54:03Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-09T01:54:03Z"}, "message": "Add background and intro to first implementation.", "tree": {"sha": "e51eb011e6839e16b0f23512a0d454b1800142ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e51eb011e6839e16b0f23512a0d454b1800142ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/438eabbba4c4540b4c28aa20c863f05e90d0b18c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/438eabbba4c4540b4c28aa20c863f05e90d0b18c", "html_url": "https://github.com/rust-lang/rust/commit/438eabbba4c4540b4c28aa20c863f05e90d0b18c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/438eabbba4c4540b4c28aa20c863f05e90d0b18c/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e68cf00d09a16f99cbe656e72e99b8f4743527e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e68cf00d09a16f99cbe656e72e99b8f4743527e4", "html_url": "https://github.com/rust-lang/rust/commit/e68cf00d09a16f99cbe656e72e99b8f4743527e4"}], "stats": {"total": 102, "additions": 99, "deletions": 3}, "files": [{"sha": "20a0dd4c1d21b058414d8e83eda641ad33da553c", "filename": "tex/paper/miri.tex", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/438eabbba4c4540b4c28aa20c863f05e90d0b18c/tex%2Fpaper%2Fmiri.tex", "raw_url": "https://github.com/rust-lang/rust/raw/438eabbba4c4540b4c28aa20c863f05e90d0b18c/tex%2Fpaper%2Fmiri.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Fpaper%2Fmiri.tex?ref=438eabbba4c4540b4c28aa20c863f05e90d0b18c", "patch": "@@ -2,11 +2,15 @@\n \n \\documentclass[twocolumn]{article}\n \\usepackage{blindtext}\n+\\usepackage[hypcap]{caption}\n \\usepackage{fontspec}\n \\usepackage[colorlinks, urlcolor={blue!80!black}]{hyperref}\n+\\usepackage[outputdir=out]{minted}\n \\usepackage{relsize}\n \\usepackage{xcolor}\n \n+\\newcommand{\\rust}[1]{\\mintinline{rust}{#1}}\n+\n \\begin{document}\n \n \\title{Miri: \\\\ \\smaller{An interpreter for Rust's mid-level intermediate representation}}\n@@ -33,23 +37,115 @@ \\section{Abstract}\n surprisingly effective approach for supporting a large proportion of Rust's features in compile-time\n execution.\n \n-\\section{Motivation}\n+\\section{Background}\n \n-\\blindtext\n+The Rust compiler (\\texttt{rustc}) generates an instance of \\rust{Mir} [\\autoref{fig:mir}] for each\n+function. Each \\rust{Mir} structure represents a control-flow graph for a given function, and\n+contains a list of ``basic blocks'' which in turn contain a list of statements followed by a single\n+terminator. Each statement is of the form \\rust{lvalue = rvalue}. An \\rust{Lvalue} is used for\n+referencing variables and calculating addresses such as when dereferencing pointers, accessing\n+fields, or indexing arrays. An \\rust{Rvalue} represents the core set of operations possible in MIR,\n+including reading a value from an lvalue, performing math operations, creating new pointers,\n+structs, and arrays, and so on. Finally, a terminator decides where control will flow next,\n+optionally based on a boolean or some other condition.\n+\n+\\begin{figure}[ht]\n+  \\begin{minted}[autogobble]{rust}\n+    struct Mir {\n+      basic_blocks: Vec<BasicBlockData>,\n+      // ...\n+    }\n+    struct BasicBlockData {\n+      statements: Vec<Statement>,\n+      terminator: Terminator,\n+      // ...\n+    }\n+    struct Statement {\n+      lvalue: Lvalue,\n+      rvalue: Rvalue\n+    }\n+    enum Terminator {\n+      Goto { target: BasicBlock },\n+      If {\n+        cond: Operand,\n+        targets: [BasicBlock; 2]\n+      },\n+      // ...\n+    }\n+  \\end{minted}\n+  \\caption{MIR (simplified)}\n+  \\label{fig:mir}\n+\\end{figure}\n \n \\section{First implementation}\n \n+\\subsection{Basic operation}\n+\n+Initially, I wrote a simple version of Miri that was quite capable despite its flaws. The structure\n+of the interpreter essentially mirrors the structure of MIR itself. Miri starts executing a function\n+by iterating the list of statements in the starting basic block, matching over the lvalue to produce\n+a pointer and matching over the rvalue to decide what to write into that pointer. Evaluating the\n+rvalue may generally involve reads (such as for the left and right hand side of a binary operation)\n+or construction of new values. Upon reaching the terminator, a similar matching is done and a new\n+basic block is selected. Finally, Miri returns to the top of the main interpreter loop and this\n+entire process repeats, reading statements from the new block.\n+\n+\\subsection{Function calls}\n+\n+To handle function call terminators\\footnote{Calls occur only as terminators, never as rvalues.},\n+Miri is required to store some information in a virtual call stack so that it may pick up where it\n+left off when the callee returns. Each stack frame stores a reference to the \\rust{Mir} for the\n+function being executed, its local variables, its return value location\\footnote{Return value\n+pointers are passed in by callers.}, and the basic block where execution should resume. To\n+facilitate returning, there is a \\rust{Return} terminator which causes Miri to pop a stack frame and\n+resume the previous function. The entire execution of a program completes when the first function\n+that Miri called returns, rendering the call stack empty.\n+\n+It should be noted that Miri does not itself recurse when a function is called; it merely pushes a\n+virtual stack frame and jumps to the top of the interpreter loop. This property implies that Miri\n+can interpret deeply recursive programs without crashing. Alternately, Miri could set a stack\n+depth limit and return an error when a program exceeds it.\n+\n+\\subsection{Flaws}\n+\n+% TODO(tsion): Incorporate this text from the slides.\n+% At first I wrote a naive version with a number of downsides:\n+%  * I represented values in a traditional dynamic language format,\n+% where every value was the same size.\n+%  * I didn\u2019t work well for aggregates (structs, enums, arrays, etc.).\n+%  *I made unsafe programming tricks that make assumptions\n+% about low-level value layout essentially impossible\n+\n % TODO(tsion): Find a place for this text.\n Making Miri work was primarily an implementation problem. Writing an interpreter which models values\n of varying sizes, stack and heap allocation, unsafe memory operations, and more requires some\n unconventional techniques compared to many interpreters. Miri's execution remains safe even while\n simulating execution of unsafe code, which allows it to detect when unsafe code does something\n invalid.\n \n-\\blindtext[2]\n+\\blindtext\n \n \\section{Data layout}\n \n \\blindtext\n \n+\\section{Future work}\n+\n+Other possible uses for Miri include:\n+\n+\\begin{itemize}\n+  \\item A graphical or text-mode debugger that steps through MIR execution one statement at a time,\n+    for figuring out why some compile-time execution is raising an error or simply learning how Rust\n+    works at a low level.\n+  \\item An read-eval-print-loop (REPL) for Rust may be easier to implement on top of Miri than the\n+    usual LLVM back-end.\n+  \\item An extended version of Miri could be developed apart from the purpose of compile-time\n+    execution that is able to run foreign functions from C/C++ and generally have full access to the\n+    operating system. Such a version of Miri could be used to more quickly prototype changes to the\n+    Rust language that would otherwise require changes to the LLVM back-end.\n+  \\item Miri might be useful for unit-testing the compiler by comparing the results of Miri's\n+    execution against the results of LLVM-compiled machine code's execution. This would help to\n+    guarantee that compile-time execution works the same as runtime execution.\n+\\end{itemize}\n+\n \\end{document}"}]}