{"sha": "d118a949f7c2193146861ae468aa12ae1e6b6d31", "node_id": "C_kwDOAAsO6NoAKGQxMThhOTQ5ZjdjMjE5MzE0Njg2MWFlNDY4YWExMmFlMWU2YjZkMzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-02T00:14:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-02T00:14:06Z"}, "message": "Auto merge of #2302 - RalfJung:datarace, r=RalfJung\n\navoid copying thread manager state in data race detector\n\nWhen doing https://github.com/rust-lang/miri/pull/2047 I did not realize that there is some redundant state here that we can now remove from the data race detector.\n\nAlso this removes the vector clocks from the data race errors since those don't really help diagnose the problem.", "tree": {"sha": "bbe3d74901b264fd6eabd7531073e637d6d8ede7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbe3d74901b264fd6eabd7531073e637d6d8ede7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d118a949f7c2193146861ae468aa12ae1e6b6d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d118a949f7c2193146861ae468aa12ae1e6b6d31", "html_url": "https://github.com/rust-lang/rust/commit/d118a949f7c2193146861ae468aa12ae1e6b6d31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d118a949f7c2193146861ae468aa12ae1e6b6d31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70b97a5d7b9931a731d12f427855b9090620bf69", "url": "https://api.github.com/repos/rust-lang/rust/commits/70b97a5d7b9931a731d12f427855b9090620bf69", "html_url": "https://github.com/rust-lang/rust/commit/70b97a5d7b9931a731d12f427855b9090620bf69"}, {"sha": "d09db1660b0c7baca06029369bc48b8d9c604f0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d09db1660b0c7baca06029369bc48b8d9c604f0a", "html_url": "https://github.com/rust-lang/rust/commit/d09db1660b0c7baca06029369bc48b8d9c604f0a"}], "stats": {"total": 850, "additions": 431, "deletions": 419}, "files": [{"sha": "4b402b51fc59da040346c4d35d4a748cb84f71a6", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 129, "deletions": 156, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -39,11 +39,6 @@\n //! so some atomic operations that only perform acquires do not increment the timestamp. Due to shared\n //! code some atomic operations may increment the timestamp when not necessary but this has no effect\n //! on the data-race detection code.\n-//!\n-//! FIXME:\n-//! currently we have our own local copy of the currently active thread index and names, this is due\n-//! in part to the inability to access the current location of threads.active_thread inside the AllocExtra\n-//! read, write and deallocate functions and should be cleaned up in the future.\n \n use std::{\n     cell::{Cell, Ref, RefCell, RefMut},\n@@ -62,35 +57,35 @@ use super::weak_memory::EvalContextExt as _;\n \n pub type AllocExtra = VClockAlloc;\n \n-/// Valid atomic read-write operations, alias of atomic::Ordering (not non-exhaustive).\n+/// Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicRwOp {\n+pub enum AtomicRwOrd {\n     Relaxed,\n     Acquire,\n     Release,\n     AcqRel,\n     SeqCst,\n }\n \n-/// Valid atomic read operations, subset of atomic::Ordering.\n+/// Valid atomic read orderings, subset of atomic::Ordering.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicReadOp {\n+pub enum AtomicReadOrd {\n     Relaxed,\n     Acquire,\n     SeqCst,\n }\n \n-/// Valid atomic write operations, subset of atomic::Ordering.\n+/// Valid atomic write orderings, subset of atomic::Ordering.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicWriteOp {\n+pub enum AtomicWriteOrd {\n     Relaxed,\n     Release,\n     SeqCst,\n }\n \n-/// Valid atomic fence operations, subset of atomic::Ordering.\n+/// Valid atomic fence orderings, subset of atomic::Ordering.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicFenceOp {\n+pub enum AtomicFenceOrd {\n     Acquire,\n     Release,\n     AcqRel,\n@@ -486,7 +481,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n@@ -500,7 +495,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         offset: u64,\n         value: impl Into<ScalarMaybeUninit<Tag>>,\n         layout: TyAndLayout<'tcx>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n@@ -511,7 +506,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn read_scalar_atomic(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         // This will read from the last store in the modification order of this location. In case\n@@ -531,7 +526,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n         dest: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.validate_overlapping_atomic(dest)?;\n@@ -552,7 +547,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         rhs: &ImmTy<'tcx, Tag>,\n         op: mir::BinOp,\n         neg: bool,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n \n@@ -581,7 +576,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n         new: ScalarMaybeUninit<Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_mut();\n \n@@ -602,7 +597,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         place: &MPlaceTy<'tcx, Tag>,\n         rhs: ImmTy<'tcx, Tag>,\n         min: bool,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n \n@@ -642,8 +637,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         place: &MPlaceTy<'tcx, Tag>,\n         expect_old: &ImmTy<'tcx, Tag>,\n         new: ScalarMaybeUninit<Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n         can_fail_spuriously: bool,\n     ) -> InterpResult<'tcx, Immediate<Tag>> {\n         use rand::Rng as _;\n@@ -696,7 +691,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_load(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         this.validate_overlapping_atomic(place)?;\n@@ -705,7 +700,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             atomic,\n             \"Atomic Load\",\n             move |memory, clocks, index, atomic| {\n-                if atomic == AtomicReadOp::Relaxed {\n+                if atomic == AtomicReadOrd::Relaxed {\n                     memory.load_relaxed(&mut *clocks, index)\n                 } else {\n                     memory.load_acquire(&mut *clocks, index)\n@@ -719,7 +714,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_store(\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.validate_overlapping_atomic(place)?;\n@@ -728,7 +723,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             atomic,\n             \"Atomic Store\",\n             move |memory, clocks, index, atomic| {\n-                if atomic == AtomicWriteOp::Relaxed {\n+                if atomic == AtomicWriteOrd::Relaxed {\n                     memory.store_relaxed(clocks, index)\n                 } else {\n                     memory.store_release(clocks, index)\n@@ -742,9 +737,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_rmw(\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n-        use AtomicRwOp::*;\n+        use AtomicRwOrd::*;\n         let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n         let release = matches!(atomic, Release | AcqRel | SeqCst);\n         let this = self.eval_context_mut();\n@@ -764,31 +759,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     }\n \n     /// Update the data-race detector for an atomic fence on the current thread.\n-    fn validate_atomic_fence(&mut self, atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n+    fn validate_atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.maybe_perform_sync_operation(|index, mut clocks| {\n+            data_race.maybe_perform_sync_operation(&this.machine.threads, |index, mut clocks| {\n                 log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n \n                 // Apply data-race detection for the current fences\n                 // this treats AcqRel and SeqCst as the same as an acquire\n                 // and release fence applied in the same timestamp.\n-                if atomic != AtomicFenceOp::Release {\n+                if atomic != AtomicFenceOrd::Release {\n                     // Either Acquire | AcqRel | SeqCst\n                     clocks.apply_acquire_fence();\n                 }\n-                if atomic != AtomicFenceOp::Acquire {\n+                if atomic != AtomicFenceOrd::Acquire {\n                     // Either Release | AcqRel | SeqCst\n                     clocks.apply_release_fence();\n                 }\n-                if atomic == AtomicFenceOp::SeqCst {\n+                if atomic == AtomicFenceOrd::SeqCst {\n                     data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n                     clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n                     clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n                 }\n \n                 // Increment timestamp in case of release semantics.\n-                Ok(atomic != AtomicFenceOp::Acquire)\n+                Ok(atomic != AtomicFenceOrd::Acquire)\n             })\n         } else {\n             Ok(())\n@@ -807,6 +802,7 @@ impl VClockAlloc {\n     /// Create a new data-race detector for newly allocated memory.\n     pub fn new_allocation(\n         global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         len: Size,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> VClockAlloc {\n@@ -816,7 +812,7 @@ impl VClockAlloc {\n                 MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n             )\n             | MemoryKind::Stack => {\n-                let (alloc_index, clocks) = global.current_thread_state();\n+                let (alloc_index, clocks) = global.current_thread_state(thread_mgr);\n                 let alloc_timestamp = clocks.clock[alloc_index];\n                 (alloc_timestamp, alloc_index)\n             }\n@@ -878,14 +874,15 @@ impl VClockAlloc {\n     #[inline(never)]\n     fn report_data_race<'tcx>(\n         global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         range: &MemoryCellClocks,\n         action: &str,\n         is_atomic: bool,\n         ptr_dbg: Pointer<AllocId>,\n     ) -> InterpResult<'tcx> {\n-        let (current_index, current_clocks) = global.current_thread_state();\n+        let (current_index, current_clocks) = global.current_thread_state(thread_mgr);\n         let write_clock;\n-        let (other_action, other_thread, other_clock) = if range.write\n+        let (other_action, other_thread, _other_clock) = if range.write\n             > current_clocks.clock[range.write_index]\n         {\n             // Convert the write action into the vector clock it\n@@ -918,27 +915,30 @@ impl VClockAlloc {\n         };\n \n         // Load elaborated thread information about the racing thread actions.\n-        let current_thread_info = global.print_thread_metadata(current_index);\n-        let other_thread_info = global.print_thread_metadata(other_thread);\n+        let current_thread_info = global.print_thread_metadata(thread_mgr, current_index);\n+        let other_thread_info = global.print_thread_metadata(thread_mgr, other_thread);\n \n         // Throw the data-race detection.\n         throw_ub_format!(\n-            \"Data race detected between {} on {} and {} on {} at {:?} (current vector clock = {:?}, conflicting timestamp = {:?})\",\n+            \"Data race detected between {} on {} and {} on {} at {:?}\",\n             action,\n             current_thread_info,\n             other_action,\n             other_thread_info,\n             ptr_dbg,\n-            current_clocks.clock,\n-            other_clock\n         )\n     }\n \n     /// Detect racing atomic read and writes (not data races)\n     /// on every byte of the current access range\n-    pub(super) fn race_free_with_atomic(&self, range: AllocRange, global: &GlobalState) -> bool {\n+    pub(super) fn race_free_with_atomic(\n+        &self,\n+        range: AllocRange,\n+        global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> bool {\n         if global.race_detecting() {\n-            let (_, clocks) = global.current_thread_state();\n+            let (_, clocks) = global.current_thread_state(thread_mgr);\n             let alloc_ranges = self.alloc_ranges.borrow();\n             for (_, range) in alloc_ranges.iter(range.start, range.size) {\n                 if !range.race_free_with_atomic(&clocks) {\n@@ -959,15 +959,17 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state();\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n+                        thread_mgr,\n                         range,\n                         \"Read\",\n                         false,\n@@ -988,14 +990,16 @@ impl VClockAlloc {\n         range: AllocRange,\n         write_type: WriteType,\n         global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state();\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n+                        thread_mgr,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -1018,8 +1022,9 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Write, global)\n+        self.unique_access(alloc_id, range, WriteType::Write, global, thread_mgr)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n@@ -1031,8 +1036,9 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Deallocate, global)\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, global, thread_mgr)\n     }\n }\n \n@@ -1068,26 +1074,30 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 );\n \n                 // Perform the atomic operation.\n-                data_race.maybe_perform_sync_operation(|index, mut clocks| {\n-                    for (offset, range) in\n-                        alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n-                    {\n-                        if let Err(DataRace) = op(range, &mut clocks, index, atomic) {\n-                            mem::drop(clocks);\n-                            return VClockAlloc::report_data_race(\n-                                data_race,\n-                                range,\n-                                description,\n-                                true,\n-                                Pointer::new(alloc_id, offset),\n-                            )\n-                            .map(|_| true);\n+                data_race.maybe_perform_sync_operation(\n+                    &this.machine.threads,\n+                    |index, mut clocks| {\n+                        for (offset, range) in\n+                            alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n+                        {\n+                            if let Err(DataRace) = op(range, &mut clocks, index, atomic) {\n+                                mem::drop(clocks);\n+                                return VClockAlloc::report_data_race(\n+                                    data_race,\n+                                    &this.machine.threads,\n+                                    range,\n+                                    description,\n+                                    true,\n+                                    Pointer::new(alloc_id, offset),\n+                                )\n+                                .map(|_| true);\n+                            }\n                         }\n-                    }\n \n-                    // This conservatively assumes all operations have release semantics\n-                    Ok(true)\n-                })?;\n+                        // This conservatively assumes all operations have release semantics\n+                        Ok(true)\n+                    },\n+                )?;\n \n                 // Log changes to atomic memory.\n                 if log::log_enabled!(log::Level::Trace) {\n@@ -1117,11 +1127,6 @@ struct ThreadExtraState {\n     /// read during data-race reporting.\n     vector_index: Option<VectorIdx>,\n \n-    /// The name of the thread, updated for better\n-    /// diagnostics when reporting detected data\n-    /// races.\n-    thread_name: Option<Box<str>>,\n-\n     /// Thread termination vector clock, this\n     /// is set on thread termination and is used\n     /// for joining on threads since the vector_index\n@@ -1161,9 +1166,6 @@ pub struct GlobalState {\n     /// The mapping of a given thread to associated thread metadata.\n     thread_info: RefCell<IndexVec<ThreadId, ThreadExtraState>>,\n \n-    /// The current vector index being executed.\n-    current_index: Cell<VectorIdx>,\n-\n     /// Potential vector indices that could be re-used on thread creation\n     /// values are inserted here on after the thread has terminated and\n     /// been joined with, and hence may potentially become free\n@@ -1173,12 +1175,6 @@ pub struct GlobalState {\n     /// active vector-clocks catch up with the threads timestamp.\n     reuse_candidates: RefCell<FxHashSet<VectorIdx>>,\n \n-    /// Counts the number of threads that are currently active\n-    /// if the number of active threads reduces to 1 and then\n-    /// a join operation occurs with the remaining main thread\n-    /// then multi-threaded execution may be disabled.\n-    active_thread_count: Cell<usize>,\n-\n     /// This contains threads that have terminated, but not yet joined\n     /// and so cannot become re-use candidates until a join operation\n     /// occurs.\n@@ -1203,24 +1199,20 @@ impl GlobalState {\n             vector_clocks: RefCell::new(IndexVec::new()),\n             vector_info: RefCell::new(IndexVec::new()),\n             thread_info: RefCell::new(IndexVec::new()),\n-            current_index: Cell::new(VectorIdx::new(0)),\n-            active_thread_count: Cell::new(1),\n             reuse_candidates: RefCell::new(FxHashSet::default()),\n             terminated_threads: RefCell::new(FxHashMap::default()),\n             last_sc_fence: RefCell::new(VClock::default()),\n             last_sc_write: RefCell::new(VClock::default()),\n         };\n \n         // Setup the main-thread since it is not explicitly created:\n-        // uses vector index and thread-id 0, also the rust runtime gives\n-        // the main-thread a name of \"main\".\n+        // uses vector index and thread-id 0.\n         let index = global_state.vector_clocks.get_mut().push(ThreadClockSet::default());\n         global_state.vector_info.get_mut().push(ThreadId::new(0));\n-        global_state.thread_info.get_mut().push(ThreadExtraState {\n-            vector_index: Some(index),\n-            thread_name: Some(\"main\".to_string().into_boxed_str()),\n-            termination_vector_clock: None,\n-        });\n+        global_state\n+            .thread_info\n+            .get_mut()\n+            .push(ThreadExtraState { vector_index: Some(index), termination_vector_clock: None });\n \n         global_state\n     }\n@@ -1274,14 +1266,10 @@ impl GlobalState {\n     // Hook for thread creation, enabled multi-threaded execution and marks\n     // the current thread timestamp as happening-before the current thread.\n     #[inline]\n-    pub fn thread_created(&mut self, thread: ThreadId) {\n-        let current_index = self.current_index();\n-\n-        // Increment the number of active threads.\n-        let active_threads = self.active_thread_count.get();\n-        self.active_thread_count.set(active_threads + 1);\n+    pub fn thread_created(&mut self, thread_mgr: &ThreadManager<'_, '_>, thread: ThreadId) {\n+        let current_index = self.current_index(thread_mgr);\n \n-        // Enable multi-threaded execution, there are now two threads\n+        // Enable multi-threaded execution, there are now at least two threads\n         // so data-races are now possible.\n         self.multi_threaded.set(true);\n \n@@ -1339,21 +1327,27 @@ impl GlobalState {\n         created.increment_clock(created_index);\n     }\n \n-    /// Hook on a thread join to update the implicit happens-before relation\n-    /// between the joined thread and the current thread.\n+    /// Hook on a thread join to update the implicit happens-before relation between the joined\n+    /// thread (the joinee, the thread that someone waited on) and the current thread (the joiner,\n+    /// the thread who was waiting).\n     #[inline]\n-    pub fn thread_joined(&mut self, current_thread: ThreadId, join_thread: ThreadId) {\n+    pub fn thread_joined(\n+        &mut self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        joiner: ThreadId,\n+        joinee: ThreadId,\n+    ) {\n         let clocks_vec = self.vector_clocks.get_mut();\n         let thread_info = self.thread_info.get_mut();\n \n         // Load the vector clock of the current thread.\n-        let current_index = thread_info[current_thread]\n+        let current_index = thread_info[joiner]\n             .vector_index\n             .expect(\"Performed thread join on thread with no assigned vector\");\n         let current = &mut clocks_vec[current_index];\n \n         // Load the associated vector clock for the terminated thread.\n-        let join_clock = thread_info[join_thread]\n+        let join_clock = thread_info[joinee]\n             .termination_vector_clock\n             .as_ref()\n             .expect(\"Joined with thread but thread has not terminated\");\n@@ -1363,10 +1357,9 @@ impl GlobalState {\n         // Is not a release operation so the clock is not incremented.\n         current.clock.join(join_clock);\n \n-        // Check the number of active threads, if the value is 1\n+        // Check the number of live threads, if the value is 1\n         // then test for potentially disabling multi-threaded execution.\n-        let active_threads = self.active_thread_count.get();\n-        if active_threads == 1 {\n+        if thread_mgr.get_live_thread_count() == 1 {\n             // May potentially be able to disable multi-threaded execution.\n             let current_clock = &clocks_vec[current_index];\n             if clocks_vec\n@@ -1383,7 +1376,7 @@ impl GlobalState {\n         // If the thread is marked as terminated but not joined\n         // then move the thread to the re-use set.\n         let termination = self.terminated_threads.get_mut();\n-        if let Some(index) = termination.remove(&join_thread) {\n+        if let Some(index) = termination.remove(&joinee) {\n             let reuse = self.reuse_candidates.get_mut();\n             reuse.insert(index);\n         }\n@@ -1397,8 +1390,8 @@ impl GlobalState {\n     /// This should be called strictly before any calls to\n     /// `thread_joined`.\n     #[inline]\n-    pub fn thread_terminated(&mut self) {\n-        let current_index = self.current_index();\n+    pub fn thread_terminated(&mut self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let current_index = self.current_index(thread_mgr);\n \n         // Increment the clock to a unique termination timestamp.\n         let vector_clocks = self.vector_clocks.get_mut();\n@@ -1420,35 +1413,6 @@ impl GlobalState {\n         // occurs.\n         let termination = self.terminated_threads.get_mut();\n         termination.insert(current_thread, current_index);\n-\n-        // Reduce the number of active threads, now that a thread has\n-        // terminated.\n-        let mut active_threads = self.active_thread_count.get();\n-        active_threads -= 1;\n-        self.active_thread_count.set(active_threads);\n-    }\n-\n-    /// Hook for updating the local tracker of the currently\n-    /// enabled thread, should always be updated whenever\n-    /// `active_thread` in thread.rs is updated.\n-    #[inline]\n-    pub fn thread_set_active(&self, thread: ThreadId) {\n-        let thread_info = self.thread_info.borrow();\n-        let vector_idx = thread_info[thread]\n-            .vector_index\n-            .expect(\"Setting thread active with no assigned vector\");\n-        self.current_index.set(vector_idx);\n-    }\n-\n-    /// Hook for updating the local tracker of the threads name\n-    /// this should always mirror the local value in thread.rs\n-    /// the thread name is used for improved diagnostics\n-    /// during a data-race.\n-    #[inline]\n-    pub fn thread_set_name(&mut self, thread: ThreadId, name: String) {\n-        let name = name.into_boxed_str();\n-        let thread_info = self.thread_info.get_mut();\n-        thread_info[thread].thread_name = Some(name);\n     }\n \n     /// Attempt to perform a synchronized operation, this\n@@ -1460,12 +1424,13 @@ impl GlobalState {\n     /// operation may create.\n     fn maybe_perform_sync_operation<'tcx>(\n         &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         op: impl FnOnce(VectorIdx, RefMut<'_, ThreadClockSet>) -> InterpResult<'tcx, bool>,\n     ) -> InterpResult<'tcx> {\n         if self.multi_threaded.get() {\n-            let (index, clocks) = self.current_thread_state_mut();\n+            let (index, clocks) = self.current_thread_state_mut(thread_mgr);\n             if op(index, clocks)? {\n-                let (_, mut clocks) = self.current_thread_state_mut();\n+                let (_, mut clocks) = self.current_thread_state_mut(thread_mgr);\n                 clocks.increment_clock(index);\n             }\n         }\n@@ -1474,15 +1439,14 @@ impl GlobalState {\n \n     /// Internal utility to identify a thread stored internally\n     /// returns the id and the name for better diagnostics.\n-    fn print_thread_metadata(&self, vector: VectorIdx) -> String {\n+    fn print_thread_metadata(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        vector: VectorIdx,\n+    ) -> String {\n         let thread = self.vector_info.borrow()[vector];\n-        let thread_name = &self.thread_info.borrow()[thread].thread_name;\n-        if let Some(name) = thread_name {\n-            let name: &str = name;\n-            format!(\"Thread(id = {:?}, name = {:?})\", thread.to_u32(), name)\n-        } else {\n-            format!(\"Thread(id = {:?})\", thread.to_u32())\n-        }\n+        let thread_name = thread_mgr.get_thread_name(thread);\n+        format!(\"thread `{}`\", String::from_utf8_lossy(thread_name))\n     }\n \n     /// Acquire a lock, express that the previous call of\n@@ -1534,8 +1498,11 @@ impl GlobalState {\n     /// Load the current vector clock in use and the current set of thread clocks\n     /// in use for the vector.\n     #[inline]\n-    pub(super) fn current_thread_state(&self) -> (VectorIdx, Ref<'_, ThreadClockSet>) {\n-        let index = self.current_index();\n+    pub(super) fn current_thread_state(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> (VectorIdx, Ref<'_, ThreadClockSet>) {\n+        let index = self.current_index(thread_mgr);\n         let ref_vector = self.vector_clocks.borrow();\n         let clocks = Ref::map(ref_vector, |vec| &vec[index]);\n         (index, clocks)\n@@ -1544,8 +1511,11 @@ impl GlobalState {\n     /// Load the current vector clock in use and the current set of thread clocks\n     /// in use for the vector mutably for modification.\n     #[inline]\n-    pub(super) fn current_thread_state_mut(&self) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n-        let index = self.current_index();\n+    pub(super) fn current_thread_state_mut(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n+        let index = self.current_index(thread_mgr);\n         let ref_vector = self.vector_clocks.borrow_mut();\n         let clocks = RefMut::map(ref_vector, |vec| &mut vec[index]);\n         (index, clocks)\n@@ -1554,19 +1524,22 @@ impl GlobalState {\n     /// Return the current thread, should be the same\n     /// as the data-race active thread.\n     #[inline]\n-    fn current_index(&self) -> VectorIdx {\n-        self.current_index.get()\n+    fn current_index(&self, thread_mgr: &ThreadManager<'_, '_>) -> VectorIdx {\n+        let active_thread_id = thread_mgr.get_active_thread_id();\n+        self.thread_info.borrow()[active_thread_id]\n+            .vector_index\n+            .expect(\"active thread has no assigned vector\")\n     }\n \n     // SC ATOMIC STORE rule in the paper.\n-    pub(super) fn sc_write(&self) {\n-        let (index, clocks) = self.current_thread_state();\n+    pub(super) fn sc_write(&self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let (index, clocks) = self.current_thread_state(thread_mgr);\n         self.last_sc_write.borrow_mut().set_at_index(&clocks.clock, index);\n     }\n \n     // SC ATOMIC READ rule in the paper.\n-    pub(super) fn sc_read(&self) {\n-        let (.., mut clocks) = self.current_thread_state_mut();\n+    pub(super) fn sc_read(&self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let (.., mut clocks) = self.current_thread_state_mut(thread_mgr);\n         clocks.read_seqcst.join(&self.last_sc_fence.borrow());\n     }\n }"}, {"sha": "f7cc9c4732ace716df4d117017c463cd3c82fdae", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -9,7 +9,7 @@\n //! Note that this implementation does not take into account of C++20's memory model revision to SC accesses\n //! and fences introduced by P0668 (<https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html>).\n //! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n-//! disallows.\n+//! disallows (<https://github.com/rust-lang/miri/issues/2301>).\n //!\n //! Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s\n //! std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the\n@@ -82,10 +82,12 @@ use rustc_const_eval::interpret::{\n };\n use rustc_data_structures::fx::FxHashMap;\n \n-use crate::{AtomicReadOp, AtomicRwOp, AtomicWriteOp, Tag, VClock, VTimestamp, VectorIdx};\n+use crate::{\n+    AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Tag, ThreadManager, VClock, VTimestamp, VectorIdx,\n+};\n \n use super::{\n-    data_race::{GlobalState, ThreadClockSet},\n+    data_race::{GlobalState as DataRaceState, ThreadClockSet},\n     range_object_map::{AccessType, RangeObjectMap},\n };\n \n@@ -149,7 +151,7 @@ impl StoreBufferAlloc {\n     /// before without data race, we can determine that the non-atomic access fully happens\n     /// after all the prior atomic accesses so the location no longer needs to exhibit\n     /// any weak memory behaviours until further atomic accesses.\n-    pub fn memory_accessed(&self, range: AllocRange, global: &GlobalState) {\n+    pub fn memory_accessed(&self, range: AllocRange, global: &DataRaceState) {\n         if !global.ongoing_action_data_race_free() {\n             let mut buffers = self.store_buffers.borrow_mut();\n             let access_type = buffers.access_type(range);\n@@ -236,17 +238,18 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n     }\n \n     /// Reads from the last store in modification order\n-    fn read_from_last_store(&self, global: &GlobalState) {\n+    fn read_from_last_store(&self, global: &DataRaceState, thread_mgr: &ThreadManager<'_, '_>) {\n         let store_elem = self.buffer.back();\n         if let Some(store_elem) = store_elem {\n-            let (index, clocks) = global.current_thread_state();\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n             store_elem.load_impl(index, &clocks);\n         }\n     }\n \n     fn buffered_read(\n         &self,\n-        global: &GlobalState,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n@@ -257,7 +260,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         let store_elem = {\n             // The `clocks` we got here must be dropped before calling validate_atomic_load\n             // as the race detector will update it\n-            let (.., clocks) = global.current_thread_state();\n+            let (.., clocks) = global.current_thread_state(thread_mgr);\n             // Load from a valid entry in the store buffer\n             self.fetch_store(is_seqcst, &clocks, &mut *rng)\n         };\n@@ -268,18 +271,19 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         // requires access to ThreadClockSet.clock, which is updated by the race detector\n         validate()?;\n \n-        let (index, clocks) = global.current_thread_state();\n+        let (index, clocks) = global.current_thread_state(thread_mgr);\n         let loaded = store_elem.load_impl(index, &clocks);\n         Ok(loaded)\n     }\n \n     fn buffered_write(\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n-        global: &GlobalState,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         is_seqcst: bool,\n     ) -> InterpResult<'tcx> {\n-        let (index, clocks) = global.current_thread_state();\n+        let (index, clocks) = global.current_thread_state(thread_mgr);\n \n         self.store_impl(val, index, &clocks.clock, is_seqcst);\n         Ok(())\n@@ -428,8 +432,11 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         {\n             let range = alloc_range(base_offset, place.layout.size);\n             if alloc_buffers.is_overlapping(range)\n-                && !alloc_clocks\n-                    .race_free_with_atomic(range, this.machine.data_race.as_ref().unwrap())\n+                && !alloc_clocks.race_free_with_atomic(\n+                    range,\n+                    this.machine.data_race.as_ref().unwrap(),\n+                    &this.machine.threads,\n+                )\n             {\n                 throw_unsup_format!(\n                     \"racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\"\n@@ -443,41 +450,41 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         &mut self,\n         new_val: ScalarMaybeUninit<Tag>,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n         init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n         if let (\n             crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n-            crate::Evaluator { data_race: Some(global), .. },\n+            crate::Evaluator { data_race: Some(global), threads, .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n-            if atomic == AtomicRwOp::SeqCst {\n-                global.sc_read();\n-                global.sc_write();\n+            if atomic == AtomicRwOrd::SeqCst {\n+                global.sc_read(threads);\n+                global.sc_write(threads);\n             }\n             let range = alloc_range(base_offset, place.layout.size);\n             let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n-            buffer.read_from_last_store(global);\n-            buffer.buffered_write(new_val, global, atomic == AtomicRwOp::SeqCst)?;\n+            buffer.read_from_last_store(global, threads);\n+            buffer.buffered_write(new_val, global, threads, atomic == AtomicRwOrd::SeqCst)?;\n         }\n         Ok(())\n     }\n \n     fn buffered_atomic_read(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n         latest_in_mo: ScalarMaybeUninit<Tag>,\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         if let Some(global) = &this.machine.data_race {\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n-                if atomic == AtomicReadOp::SeqCst {\n-                    global.sc_read();\n+                if atomic == AtomicReadOrd::SeqCst {\n+                    global.sc_read(&this.machine.threads);\n                 }\n                 let mut rng = this.machine.rng.borrow_mut();\n                 let buffer = alloc_buffers.get_or_create_store_buffer(\n@@ -486,7 +493,8 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 )?;\n                 let loaded = buffer.buffered_read(\n                     global,\n-                    atomic == AtomicReadOp::SeqCst,\n+                    &this.machine.threads,\n+                    atomic == AtomicReadOrd::SeqCst,\n                     &mut *rng,\n                     validate,\n                 )?;\n@@ -504,18 +512,18 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n         dest: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n         init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n         if let (\n             crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n-            crate::Evaluator { data_race: Some(global), .. },\n+            crate::Evaluator { data_race: Some(global), threads, .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n-            if atomic == AtomicWriteOp::SeqCst {\n-                global.sc_write();\n+            if atomic == AtomicWriteOrd::SeqCst {\n+                global.sc_write(threads);\n             }\n \n             // UGLY HACK: in write_scalar_atomic() we don't know the value before our write,\n@@ -535,7 +543,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 buffer.buffer.pop_front();\n             }\n \n-            buffer.buffered_write(val, global, atomic == AtomicWriteOp::SeqCst)?;\n+            buffer.buffered_write(val, global, threads, atomic == AtomicWriteOrd::SeqCst)?;\n         }\n \n         // Caller should've written to dest with the vanilla scalar write, we do nothing here\n@@ -548,21 +556,21 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n     fn perform_read_on_buffered_latest(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n         init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n \n         if let Some(global) = &this.machine.data_race {\n-            if atomic == AtomicReadOp::SeqCst {\n-                global.sc_read();\n+            if atomic == AtomicReadOrd::SeqCst {\n+                global.sc_read(&this.machine.threads);\n             }\n             let size = place.layout.size;\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n                 let buffer = alloc_buffers\n                     .get_or_create_store_buffer(alloc_range(base_offset, size), init)?;\n-                buffer.read_from_last_store(global);\n+                buffer.read_from_last_store(global, &this.machine.threads);\n             }\n         }\n         Ok(())"}, {"sha": "b3d408a6dc07244945073a84014a923dd2d350e4", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -70,7 +70,7 @@ pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n pub use crate::shims::EvalContextExt as _;\n \n pub use crate::concurrency::data_race::{\n-    AtomicFenceOp, AtomicReadOp, AtomicRwOp, AtomicWriteOp,\n+    AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n     EvalContextExt as DataRaceEvalContextExt,\n };\n pub use crate::diagnostics::{"}, {"sha": "86b174182c1f10dbbbfe23026b326a76edad1c2b", "filename": "src/machine.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -647,7 +647,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             None\n         };\n         let race_alloc = if let Some(data_race) = &ecx.machine.data_race {\n-            Some(data_race::AllocExtra::new_allocation(data_race, alloc.size(), kind))\n+            Some(data_race::AllocExtra::new_allocation(\n+                data_race,\n+                &ecx.machine.threads,\n+                alloc.size(),\n+                kind,\n+            ))\n         } else {\n             None\n         };\n@@ -756,7 +761,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(alloc_id, range, machine.data_race.as_ref().unwrap())?;\n+            data_race.read(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_ref().unwrap(),\n+                &machine.threads,\n+            )?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n             stacked_borrows.borrow_mut().memory_read(\n@@ -782,7 +792,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n+            data_race.write(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_mut().unwrap(),\n+                &machine.threads,\n+            )?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().memory_written(\n@@ -811,7 +826,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n+            data_race.deallocate(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_mut().unwrap(),\n+                &machine.threads,\n+            )?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().memory_deallocated("}, {"sha": "d8f6292e9df399a2da37c675fc38012770664fb0", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 103, "deletions": 99, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -864,216 +864,220 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Atomic operations\n-            \"atomic_load_seqcst\" => this.atomic_load(args, dest, AtomicReadOp::SeqCst)?,\n-            \"atomic_load_relaxed\" => this.atomic_load(args, dest, AtomicReadOp::Relaxed)?,\n-            \"atomic_load_acquire\" => this.atomic_load(args, dest, AtomicReadOp::Acquire)?,\n+            \"atomic_load_seqcst\" => this.atomic_load(args, dest, AtomicReadOrd::SeqCst)?,\n+            \"atomic_load_relaxed\" => this.atomic_load(args, dest, AtomicReadOrd::Relaxed)?,\n+            \"atomic_load_acquire\" => this.atomic_load(args, dest, AtomicReadOrd::Acquire)?,\n \n-            \"atomic_store_seqcst\" => this.atomic_store(args, AtomicWriteOp::SeqCst)?,\n-            \"atomic_store_relaxed\" => this.atomic_store(args, AtomicWriteOp::Relaxed)?,\n-            \"atomic_store_release\" => this.atomic_store(args, AtomicWriteOp::Release)?,\n+            \"atomic_store_seqcst\" => this.atomic_store(args, AtomicWriteOrd::SeqCst)?,\n+            \"atomic_store_relaxed\" => this.atomic_store(args, AtomicWriteOrd::Relaxed)?,\n+            \"atomic_store_release\" => this.atomic_store(args, AtomicWriteOrd::Release)?,\n \n-            \"atomic_fence_acquire\" => this.atomic_fence(args, AtomicFenceOp::Acquire)?,\n-            \"atomic_fence_release\" => this.atomic_fence(args, AtomicFenceOp::Release)?,\n-            \"atomic_fence_acqrel\" => this.atomic_fence(args, AtomicFenceOp::AcqRel)?,\n-            \"atomic_fence_seqcst\" => this.atomic_fence(args, AtomicFenceOp::SeqCst)?,\n+            \"atomic_fence_acquire\" => this.atomic_fence(args, AtomicFenceOrd::Acquire)?,\n+            \"atomic_fence_release\" => this.atomic_fence(args, AtomicFenceOrd::Release)?,\n+            \"atomic_fence_acqrel\" => this.atomic_fence(args, AtomicFenceOrd::AcqRel)?,\n+            \"atomic_fence_seqcst\" => this.atomic_fence(args, AtomicFenceOrd::SeqCst)?,\n \n             \"atomic_singlethreadfence_acquire\" =>\n-                this.compiler_fence(args, AtomicFenceOp::Acquire)?,\n+                this.compiler_fence(args, AtomicFenceOrd::Acquire)?,\n             \"atomic_singlethreadfence_release\" =>\n-                this.compiler_fence(args, AtomicFenceOp::Release)?,\n+                this.compiler_fence(args, AtomicFenceOrd::Release)?,\n             \"atomic_singlethreadfence_acqrel\" =>\n-                this.compiler_fence(args, AtomicFenceOp::AcqRel)?,\n+                this.compiler_fence(args, AtomicFenceOrd::AcqRel)?,\n             \"atomic_singlethreadfence_seqcst\" =>\n-                this.compiler_fence(args, AtomicFenceOp::SeqCst)?,\n+                this.compiler_fence(args, AtomicFenceOrd::SeqCst)?,\n \n-            \"atomic_xchg_seqcst\" => this.atomic_exchange(args, dest, AtomicRwOp::SeqCst)?,\n-            \"atomic_xchg_acquire\" => this.atomic_exchange(args, dest, AtomicRwOp::Acquire)?,\n-            \"atomic_xchg_release\" => this.atomic_exchange(args, dest, AtomicRwOp::Release)?,\n-            \"atomic_xchg_acqrel\" => this.atomic_exchange(args, dest, AtomicRwOp::AcqRel)?,\n-            \"atomic_xchg_relaxed\" => this.atomic_exchange(args, dest, AtomicRwOp::Relaxed)?,\n+            \"atomic_xchg_seqcst\" => this.atomic_exchange(args, dest, AtomicRwOrd::SeqCst)?,\n+            \"atomic_xchg_acquire\" => this.atomic_exchange(args, dest, AtomicRwOrd::Acquire)?,\n+            \"atomic_xchg_release\" => this.atomic_exchange(args, dest, AtomicRwOrd::Release)?,\n+            \"atomic_xchg_acqrel\" => this.atomic_exchange(args, dest, AtomicRwOrd::AcqRel)?,\n+            \"atomic_xchg_relaxed\" => this.atomic_exchange(args, dest, AtomicRwOrd::Relaxed)?,\n \n             #[rustfmt::skip]\n             \"atomic_cxchg_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::SeqCst)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acquire_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_release_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Release, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acqrel_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Relaxed, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acquire_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_seqcst_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n \n             #[rustfmt::skip]\n             \"atomic_cxchgweak_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::SeqCst)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acquire_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_release_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Release, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acqrel_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Relaxed, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acquire_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_seqcst_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n \n             #[rustfmt::skip]\n             \"atomic_or_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_or_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_or_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_or_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_or_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_xor_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_xor_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_xor_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_xor_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_xor_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_and_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_and_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_and_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_and_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_and_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_nand_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_nand_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_nand_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_nand_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_nand_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::Relaxed)?,\n-            \"atomic_min_seqcst\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Relaxed)?,\n+            \"atomic_min_seqcst\" =>\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n             \"atomic_min_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n             \"atomic_min_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Release)?,\n-            \"atomic_min_acqrel\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n+            \"atomic_min_acqrel\" =>\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n             \"atomic_min_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Relaxed)?,\n-            \"atomic_max_seqcst\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n+            \"atomic_max_seqcst\" =>\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n             \"atomic_max_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n             \"atomic_max_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Release)?,\n-            \"atomic_max_acqrel\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n+            \"atomic_max_acqrel\" =>\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n             \"atomic_max_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n             \"atomic_umin_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n             \"atomic_umin_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n             \"atomic_umin_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n             \"atomic_umin_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n             \"atomic_umin_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n             \"atomic_umax_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n             \"atomic_umax_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n             \"atomic_umax_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n             \"atomic_umax_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n             \"atomic_umax_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n \n             // Other\n             \"exact_div\" => {\n@@ -1101,7 +1105,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1129,7 +1133,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn atomic_store(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1156,7 +1160,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn compiler_fence(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicFenceOp,\n+        atomic: AtomicFenceOrd,\n     ) -> InterpResult<'tcx> {\n         let [] = check_arg_count(args)?;\n         let _ = atomic;\n@@ -1167,7 +1171,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn atomic_fence(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicFenceOp,\n+        atomic: AtomicFenceOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let [] = check_arg_count(args)?;\n@@ -1180,7 +1184,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         atomic_op: AtomicOp,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1226,7 +1230,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1254,8 +1258,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n         can_fail_spuriously: bool,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -1294,8 +1298,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n     }\n@@ -1304,8 +1308,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, true)\n     }"}, {"sha": "a0e35c730c3d6ead7e70da6b492be7efe422fe89", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -169,15 +169,15 @@ pub fn futex<'tcx>(\n             //\n             // Thankfully, preemptions cannot happen inside a Miri shim, so we do not need to\n             // do anything special to guarantee fence-load-comparison atomicity.\n-            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n+            this.atomic_fence(&[], AtomicFenceOrd::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n             let futex_val = this\n                 .read_scalar_at_offset_atomic(\n                     &addr.into(),\n                     0,\n                     this.machine.layouts.i32,\n-                    AtomicReadOp::Relaxed,\n+                    AtomicReadOrd::Relaxed,\n                 )?\n                 .to_i32()?;\n             if val == futex_val {\n@@ -240,7 +240,7 @@ pub fn futex<'tcx>(\n             // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n             // will see the latest value on addr which could be changed by our caller\n             // before doing the syscall.\n-            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n+            this.atomic_fence(&[], AtomicFenceOrd::SeqCst)?;\n             let mut n = 0;\n             for _ in 0..val {\n                 if let Some(thread) = this.futex_wake(addr_usize, bitset) {"}, {"sha": "ae63907c2c86577f5cc08fe72c5fadc0f584a808", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -68,7 +68,7 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n         mutex_op,\n         offset,\n         ecx.machine.layouts.i32,\n-        AtomicReadOp::Relaxed,\n+        AtomicReadOrd::Relaxed,\n     )\n }\n \n@@ -83,15 +83,15 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n         offset,\n         kind,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n+    ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n@@ -104,7 +104,7 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n         4,\n         id,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n@@ -120,8 +120,8 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()\n@@ -147,7 +147,7 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n+    ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn rwlock_set_id<'mir, 'tcx: 'mir>(\n@@ -160,7 +160,7 @@ fn rwlock_set_id<'mir, 'tcx: 'mir>(\n         4,\n         id,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n@@ -176,8 +176,8 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()\n@@ -231,7 +231,7 @@ fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n+    ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n@@ -244,7 +244,7 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n         4,\n         id,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n@@ -260,8 +260,8 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()"}, {"sha": "35603f7f38632053049bd22a0e21037921664bf8", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -15,8 +15,8 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()"}, {"sha": "420eeb810fd874a75fb77a45a6bbea1211c10915", "filename": "src/thread.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -170,6 +170,14 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n     }\n }\n \n+impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n+    fn new(name: &str) -> Self {\n+        let mut thread = Thread::default();\n+        thread.thread_name = Some(Vec::from(name.as_bytes()));\n+        thread\n+    }\n+}\n+\n /// A specific moment in time.\n #[derive(Debug)]\n pub enum Time {\n@@ -230,7 +238,7 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n     fn default() -> Self {\n         let mut threads = IndexVec::new();\n         // Create the main thread and add it to the list of threads.\n-        let mut main_thread = Thread::default();\n+        let mut main_thread = Thread::new(\"main\");\n         // The main thread can *not* be joined on.\n         main_thread.join_status = ThreadJoinStatus::Detached;\n         threads.push(main_thread);\n@@ -289,15 +297,21 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get the id of the currently active thread.\n-    fn get_active_thread_id(&self) -> ThreadId {\n+    pub fn get_active_thread_id(&self) -> ThreadId {\n         self.active_thread\n     }\n \n     /// Get the total number of threads that were ever spawn by this program.\n-    fn get_total_thread_count(&self) -> usize {\n+    pub fn get_total_thread_count(&self) -> usize {\n         self.threads.len()\n     }\n \n+    /// Get the total of threads that are currently live, i.e., not yet terminated.\n+    /// (They might be blocked.)\n+    pub fn get_live_thread_count(&self) -> usize {\n+        self.threads.iter().filter(|t| !matches!(t.state, ThreadState::Terminated)).count()\n+    }\n+\n     /// Has the given thread terminated?\n     fn has_terminated(&self, thread_id: ThreadId) -> bool {\n         self.threads[thread_id].state == ThreadState::Terminated\n@@ -366,22 +380,27 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         } else {\n             // The thread has already terminated - mark join happens-before\n             if let Some(data_race) = data_race {\n-                data_race.thread_joined(self.active_thread, joined_thread_id);\n+                data_race.thread_joined(self, self.active_thread, joined_thread_id);\n             }\n         }\n         Ok(())\n     }\n \n     /// Set the name of the active thread.\n-    fn set_thread_name(&mut self, new_thread_name: Vec<u8>) {\n+    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         self.active_thread_mut().thread_name = Some(new_thread_name);\n     }\n \n     /// Get the name of the active thread.\n-    fn get_thread_name(&self) -> &[u8] {\n+    pub fn get_active_thread_name(&self) -> &[u8] {\n         self.active_thread_ref().thread_name()\n     }\n \n+    /// Get the name of the given thread.\n+    pub fn get_thread_name(&self, thread: ThreadId) -> &[u8] {\n+        self.threads[thread].thread_name()\n+    }\n+\n     /// Put the thread into the blocked state.\n     fn block_thread(&mut self, thread: ThreadId) {\n         let state = &mut self.threads[thread].state;\n@@ -460,21 +479,25 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 false\n             });\n         }\n-        // Set the thread into a terminated state in the data-race detector\n+        // Set the thread into a terminated state in the data-race detector.\n         if let Some(ref mut data_race) = data_race {\n-            data_race.thread_terminated();\n+            data_race.thread_terminated(self);\n         }\n         // Check if we need to unblock any threads.\n+        let mut joined_threads = vec![]; // store which threads joined, we'll need it\n         for (i, thread) in self.threads.iter_enumerated_mut() {\n             if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n                 // The thread has terminated, mark happens-before edge to joining thread\n-                if let Some(ref mut data_race) = data_race {\n-                    data_race.thread_joined(i, self.active_thread);\n+                if data_race.is_some() {\n+                    joined_threads.push(i);\n                 }\n                 trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n                 thread.state = ThreadState::Enabled;\n             }\n         }\n+        for &i in &joined_threads {\n+            data_race.as_mut().unwrap().thread_joined(self, i, self.active_thread);\n+        }\n         free_tls_statics\n     }\n \n@@ -484,10 +507,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// used in stateless model checkers such as Loom: run the active thread as\n     /// long as we can and switch only when we have to (the active thread was\n     /// blocked, terminated, or has explicitly asked to be preempted).\n-    fn schedule(\n-        &mut self,\n-        data_race: &Option<data_race::GlobalState>,\n-    ) -> InterpResult<'tcx, SchedulingAction> {\n+    fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         // Check whether the thread has **just** terminated (`check_terminated`\n         // checks whether the thread has popped all its stack and if yes, sets\n         // the thread state to terminated).\n@@ -535,9 +555,6 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             debug_assert_ne!(self.active_thread, id);\n             if thread.state == ThreadState::Enabled {\n                 self.active_thread = id;\n-                if let Some(data_race) = data_race {\n-                    data_race.thread_set_active(self.active_thread);\n-                }\n                 break;\n             }\n         }\n@@ -598,7 +615,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let id = this.machine.threads.create_thread();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.thread_created(id);\n+            data_race.thread_created(&this.machine.threads, id);\n         }\n         id\n     }\n@@ -619,9 +636,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.thread_set_active(thread_id);\n-        }\n         this.machine.threads.set_active_thread_id(thread_id)\n     }\n \n@@ -682,12 +696,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &mut this.machine.data_race {\n-            if let Ok(string) = String::from_utf8(new_thread_name.clone()) {\n-                data_race.thread_set_name(this.machine.threads.active_thread, string);\n-            }\n-        }\n-        this.machine.threads.set_thread_name(new_thread_name);\n+        this.machine.threads.set_active_thread_name(new_thread_name);\n     }\n \n     #[inline]\n@@ -696,7 +705,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         'mir: 'c,\n     {\n         let this = self.eval_context_ref();\n-        this.machine.threads.get_thread_name()\n+        this.machine.threads.get_active_thread_name()\n     }\n \n     #[inline]\n@@ -776,8 +785,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         let this = self.eval_context_mut();\n-        let data_race = &this.machine.data_race;\n-        this.machine.threads.schedule(data_race)\n+        this.machine.threads.schedule()\n     }\n \n     /// Handles thread termination of the active thread: wakes up threads joining on this one,"}, {"sha": "754fccd63b13d1638260e5d0dd7c8669c113dcd4", "filename": "tests/compiletest.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -94,8 +94,6 @@ regexes! {\n     \"([0-9]+: ) +0x[0-9a-f]+ - (.*)\" => \"$1$2\",\n     // erase long hexadecimals\n     r\"0x[0-9a-fA-F]+[0-9a-fA-F]{2,2}\" => \"$$HEX\",\n-    // erase clocks\n-    r\"VClock\\(\\[[^\\]]+\\]\\)\"      => \"VClock\",\n     // erase specific alignments\n     \"alignment [0-9]+\"               => \"alignment ALIGN\",\n     // erase thread caller ids"}, {"sha": "1eac8ce0f26c6e58feab38b05208f1c6950b630b", "filename": "tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n             let pointer = &*ptr.0;\n \n             // Note: could also error due to reading uninitialized memory, but the data-race detector triggers first.\n-            *pointer.load(Ordering::Relaxed) //~ ERROR Data race detected between Read on Thread(id = 2) and Allocate on Thread(id = 1)\n+            *pointer.load(Ordering::Relaxed) //~ ERROR Data race detected between Read on thread `<unnamed>` and Allocate on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "2049e4f4a193ade7a4dc8d121ae40935d397095c", "filename": "tests/fail/data_race/alloc_read_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n   --> $DIR/alloc_read_race.rs:LL:CC\n    |\n LL |             *pointer.load(Ordering::Relaxed)\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "e618b72a822700750910631a101b15558cf5f197", "filename": "tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -36,7 +36,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let pointer = &*ptr.0;\n-            *pointer.load(Ordering::Relaxed) = 2; //~ ERROR Data race detected between Write on Thread(id = 2) and Allocate on Thread(id = 1)\n+            *pointer.load(Ordering::Relaxed) = 2; //~ ERROR Data race detected between Write on thread `<unnamed>` and Allocate on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "82e3d92479d94aa2b4d06fbedacf77cb1a443a02", "filename": "tests/fail/data_race/alloc_write_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n   --> $DIR/alloc_write_race.rs:LL:CC\n    |\n LL |             *pointer.load(Ordering::Relaxed) = 2;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "3b948eea9805102cc3d29963ac1fee2a740a3ed3", "filename": "tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             //Equivalent to: (&*c.0).load(Ordering::SeqCst)\n-            intrinsics::atomic_load_seqcst(c.0 as *mut usize) //~ ERROR Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1)\n+            intrinsics::atomic_load_seqcst(c.0 as *mut usize) //~ ERROR Data race detected between Atomic Load on thread `<unnamed>` and Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "4b5355e866e25c03c3c10a5c99c67297619c584b", "filename": "tests/fail/data_race/atomic_read_na_write_race1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Atomic Load on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/atomic_read_na_write_race1.rs:LL:CC\n    |\n LL |             intrinsics::atomic_load_seqcst(c.0 as *mut usize)\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Load on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "44b4eebee8051efe9573b8af359411233775cadd", "filename": "tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() = 32; //~ ERROR Data race detected between Write on Thread(id = 2) and Atomic Load on Thread(id = 1)\n+            *atomic_ref.get_mut() = 32; //~ ERROR Data race detected between Write on thread `<unnamed>` and Atomic Load on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "3eb9f17bae760043648a76c3ac99e5e6a17fa22a", "filename": "tests/fail/data_race/atomic_read_na_write_race2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Atomic Load on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Atomic Load on thread `<unnamed>` at ALLOC\n   --> $DIR/atomic_read_na_write_race2.rs:LL:CC\n    |\n LL |             *atomic_ref.get_mut() = 32;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on Thread(id = 2) and Atomic Load on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Atomic Load on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "44dc1a9084168fc74c2dee884ecbb693c77e0b92", "filename": "tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() //~ ERROR Data race detected between Read on Thread(id = 2) and Atomic Store on Thread(id = 1)\n+            *atomic_ref.get_mut() //~ ERROR Data race detected between Read on thread `<unnamed>` and Atomic Store on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "810fa54d41cee261e5a110e6b75e810dde52c91f", "filename": "tests/fail/data_race/atomic_write_na_read_race1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n   --> $DIR/atomic_write_na_read_race1.rs:LL:CC\n    |\n LL |             *atomic_ref.get_mut()\n-   |             ^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "b4b21b64fc1fb00d81b86295846ca30a3fa6754f", "filename": "tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             //Equivalent to: (&*c.0).store(32, Ordering::SeqCst)\n-            atomic_store(c.0 as *mut usize, 32); //~ ERROR Data race detected between Atomic Store on Thread(id = 2) and Read on Thread(id = 1)\n+            atomic_store(c.0 as *mut usize, 32); //~ ERROR Data race detected between Atomic Store on thread `<unnamed>` and Read on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "77f69e2bc3400fded011b23c061db9540ae887cc", "filename": "tests/fail/data_race/atomic_write_na_read_race2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Atomic Store on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Atomic Store on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n   --> $DIR/atomic_write_na_read_race2.rs:LL:CC\n    |\n LL |             atomic_store(c.0 as *mut usize, 32);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "b1a4cfb98bd1359b8c2471fc0967c6173d0c3e2b", "filename": "tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             //Equivalent to: (&*c.0).store(64, Ordering::SeqCst)\n-            atomic_store(c.0 as *mut usize, 64); //~ ERROR Data race detected between Atomic Store on Thread(id = 2) and Write on Thread(id = 1)\n+            atomic_store(c.0 as *mut usize, 64); //~ ERROR Data race detected between Atomic Store on thread `<unnamed>` and Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "8e70de5e4aff6c1e9136440962693df67496ad9e", "filename": "tests/fail/data_race/atomic_write_na_write_race1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Atomic Store on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Atomic Store on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/atomic_write_na_write_race1.rs:LL:CC\n    |\n LL |             atomic_store(c.0 as *mut usize, 64);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "dbdce8f6237ce98f5a231b598696be40de21c8a9", "filename": "tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() = 32; //~ ERROR Data race detected between Write on Thread(id = 2) and Atomic Store on Thread(id = 1)\n+            *atomic_ref.get_mut() = 32; //~ ERROR Data race detected between Write on thread `<unnamed>` and Atomic Store on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "310c2ed7df8a1f7cbd2f39823715800296953a02", "filename": "tests/fail/data_race/atomic_write_na_write_race2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n   --> $DIR/atomic_write_na_write_race2.rs:LL:CC\n    |\n LL |             *atomic_ref.get_mut() = 32;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "65325b60f2f39471d203d09133aa414c88638cd4", "filename": "tests/fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -34,7 +34,7 @@ fn main() {\n \n     let join2 = unsafe {\n         spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 3) and Write on Thread(id = 1)\n+            *c.0 = 64; //~ ERROR Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n         })\n     };\n "}, {"sha": "efdc913ce27a92143e9157276fd3785e04376ba1", "filename": "tests/fail/data_race/dangling_thread_async_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/dangling_thread_async_race.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "09e7032c933085d9d0ed48d5075eb703422b5ef1", "filename": "tests/fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -33,6 +33,6 @@ fn main() {\n     spawn(|| ()).join().unwrap();\n \n     unsafe {\n-        *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1)\n+        *c.0 = 64; //~ ERROR Data race detected between Write on thread `main` and Write on thread `<unnamed>`\n     }\n }"}, {"sha": "899cfdd095e385eaae79741f184d4d6c5aa3331d", "filename": "tests/fail/data_race/dangling_thread_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/dangling_thread_race.rs:LL:CC\n    |\n LL |         *c.0 = 64;\n-   |         ^^^^^^^^^ Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |         ^^^^^^^^^ Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "ff2ac8ca522a5ed175fe7d16e2fea98f36343008", "filename": "tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -24,7 +24,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             __rust_dealloc(\n-                //~^ ERROR Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1)\n+                //~^ ERROR Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>`\n                 ptr.0 as *mut _,\n                 std::mem::size_of::<usize>(),\n                 std::mem::align_of::<usize>(),"}, {"sha": "9e35fb7b6bd82397f570b0e05d336aa7af7be483", "filename": "tests/fail/data_race/dealloc_read_race1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,4 +1,4 @@\n-error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n   --> $DIR/dealloc_read_race1.rs:LL:CC\n    |\n LL | /             __rust_dealloc(\n@@ -7,7 +7,7 @@ LL | |                 ptr.0 as *mut _,\n LL | |                 std::mem::size_of::<usize>(),\n LL | |                 std::mem::align_of::<usize>(),\n LL | |             );\n-   | |_____________^ Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   | |_____________^ Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "4bb6444f6a626610c743b152d3e5bf03b461b16b", "filename": "tests/fail/data_race/dealloc_read_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -27,7 +27,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            // Also an error of the form: Data race detected between Read on Thread(id = 2) and Deallocate on Thread(id = 1)\n+            // Also an error of the form: Data race detected between Read on thread `<unnamed>` and Deallocate on thread `<unnamed>`\n             // but the invalid allocation is detected first.\n             *ptr.0 //~ ERROR dereferenced after this allocation got freed\n         });"}, {"sha": "e079581a0d89bca1f05f721ba314b4a8ff7796a3", "filename": "tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -36,7 +36,7 @@ pub fn main() {\n                 sleep(Duration::from_millis(200));\n \n                 // Now `stack_var` gets deallocated.\n-            } //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2)\n+            } //~ ERROR Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>`\n         });\n \n         let j2 = spawn(move || {"}, {"sha": "b1e7d3649ecb32a4aa81e7479667bd3e71357161", "filename": "tests/fail/data_race/dealloc_read_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n   --> $DIR/dealloc_read_race_stack.rs:LL:CC\n    |\n LL |             }\n-   |             ^ Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^ Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "9cd0ebc64252178de411727de16de17295711833", "filename": "tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             __rust_dealloc(\n-                //~^ ERROR Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1)\n+                //~^ ERROR Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>`\n                 ptr.0 as *mut _,\n                 std::mem::size_of::<usize>(),\n                 std::mem::align_of::<usize>(),"}, {"sha": "a9ac03eb31db9820eb6c83ca3d9389352bf4a5ba", "filename": "tests/fail/data_race/dealloc_write_race1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,4 +1,4 @@\n-error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/dealloc_write_race1.rs:LL:CC\n    |\n LL | /             __rust_dealloc(\n@@ -7,7 +7,7 @@ LL | |                 ptr.0 as *mut _,\n LL | |                 std::mem::size_of::<usize>(),\n LL | |                 std::mem::align_of::<usize>(),\n LL | |             );\n-   | |_____________^ Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   | |_____________^ Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "9b1b8f0614754755e4ef67980a97c6bd428bdd40", "filename": "tests/fail/data_race/dealloc_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -26,7 +26,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            // Also an error of the form: Data race detected between Write on Thread(id = 2) and Deallocate on Thread(id = 1)\n+            // Also an error of the form: Data race detected between Write on thread `<unnamed>` and Deallocate on thread `<unnamed>`\n             // but the invalid allocation is detected first.\n             *ptr.0 = 2; //~ ERROR dereferenced after this allocation got freed\n         });"}, {"sha": "2f12570892732e4f04b9e9349658510aee21eab3", "filename": "tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -36,7 +36,7 @@ pub fn main() {\n                 sleep(Duration::from_millis(200));\n \n                 // Now `stack_var` gets deallocated.\n-            } //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Write on Thread(id = 2)\n+            } //~ ERROR Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>`\n         });\n \n         let j2 = spawn(move || {"}, {"sha": "622ac25189be51f180e10d3576e5e4b4025d6b64", "filename": "tests/fail/data_race/dealloc_write_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/dealloc_write_race_stack.rs:LL:CC\n    |\n LL |             }\n-   |             ^ Data race detected between Deallocate on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^ Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "6f0735fac897c6c666dbdb82ccf48e7dc34a7b36", "filename": "tests/fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -29,7 +29,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 6) and Write on Thread(id = 5)\n+            *c.0 = 64; //~ ERROR Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "4426952e44b55ca2282f14081e3c4bc2e88ee835", "filename": "tests/fail/data_race/enable_after_join_to_main.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 6) and Write on Thread(id = 5) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/enable_after_join_to_main.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on Thread(id = 6) and Write on Thread(id = 5) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "5a8c2e585f49a66fbaddf32ef5a3634647d3278c", "filename": "tests/fail/data_race/fence_after_load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -21,5 +21,5 @@ fn main() {\n     // The fence is useless, since it did not happen-after the `store` in the other thread.\n     // Hence this is a data race.\n     // Also see https://github.com/rust-lang/miri/issues/2192.\n-    unsafe { V = 2 } //~ERROR Data race detected\n+    unsafe { V = 2 } //~ERROR Data race detected between Write on thread `main` and Write on thread `<unnamed>`\n }"}, {"sha": "b9cffeda27befff56ae4aac714b7529f70b3f306", "filename": "tests/fail/data_race/fence_after_load.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/fence_after_load.rs:LL:CC\n    |\n LL |     unsafe { V = 2 }\n-   |              ^^^^^ Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |              ^^^^^ Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "eeb49bb42ab7ca4480122b8753863883967e1de4", "filename": "tests/fail/data_race/read_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 2) and Read on Thread(id = 1)\n+            *c.0 = 64; //~ ERROR Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "a65e7006cf0a80234d669eb762e1048c1b2daf1b", "filename": "tests/fail/data_race/read_write_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n   --> $DIR/read_write_race.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "124f12d1ecd28fe9ab4b74c41e13bfbc9c338e8a", "filename": "tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -43,7 +43,7 @@ pub fn main() {\n \n             sleep(Duration::from_millis(200));\n \n-            stack_var //~ ERROR Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2)\n+            stack_var //~ ERROR Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n         });\n \n         let j2 = spawn(move || {"}, {"sha": "390b3ab38ede0d508dc216b0691df6d5e323684d", "filename": "tests/fail/data_race/read_write_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/read_write_race_stack.rs:LL:CC\n    |\n LL |             stack_var\n-   |             ^^^^^^^^^ Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "faa23a150e3fabb3fdf3ab3345b25c11e995082a", "filename": "tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n \n         let j3 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 2 {\n-                *c.0 //~ ERROR Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1)\n+                *c.0 //~ ERROR Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "85de60c02655094d5544d58e04dee70030c4178d", "filename": "tests/fail/data_race/relax_acquire_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/relax_acquire_race.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "ab6926102a2a170ed684a9acd2b2a700274c364e", "filename": "tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -42,7 +42,7 @@ pub fn main() {\n         let j3 = spawn(move || {\n             sleep(Duration::from_millis(500));\n             if SYNC.load(Ordering::Acquire) == 3 {\n-                *c.0 //~ ERROR Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1)\n+                *c.0 //~ ERROR Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "db333d756f855da20514c9b826fc7cd2a9f0bd5f", "filename": "tests/fail/data_race/release_seq_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/release_seq_race.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "d3d18f0e2540dacfca93c114774faaebb25ba079", "filename": "tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 2 {\n-                *c.0 //~ ERROR Data race detected between Read on Thread(id = 2) and Write on Thread(id = 1)\n+                *c.0 //~ ERROR Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "f4c38d5315006a386bc59c55ef1aaf0b75b76dd1", "filename": "tests/fail/data_race/release_seq_race_same_thread.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/release_seq_race_same_thread.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "800b1043c00b5e0051ce0d204d99e54b81e8f670", "filename": "tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -39,7 +39,7 @@ pub fn main() {\n \n         let j3 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 3 {\n-                *c.0 //~ ERROR Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1)\n+                *c.0 //~ ERROR Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "346fcc31b9c06539989317a5fdf34b67a5a7c4df", "filename": "tests/fail/data_race/rmw_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frmw_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Frmw_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/rmw_race.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "989ae31a6d281f199faa9f4ffbbc1f536d17d05a", "filename": "tests/fail/data_race/write_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 2) and Write on Thread(id = 1)\n+            *c.0 = 64; //~ ERROR Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "e6254281aef36ccd041094780fb42bb6b6220739", "filename": "tests/fail/data_race/write_write_race.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/write_write_race.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "3c1eabbf251b2cc6f929bf3a0d203281f50c61f5", "filename": "tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -40,7 +40,7 @@ pub fn main() {\n \n             sleep(Duration::from_millis(200));\n \n-            stack_var = 1usize; //~ ERROR Data race detected between Write on Thread(id = 1) and Write on Thread(id = 2)\n+            stack_var = 1usize; //~ ERROR Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n \n             // read to silence errors\n             stack_var"}, {"sha": "1f7318e6f95152eba9e0b53e50db0f8223f51305", "filename": "tests/fail/data_race/write_write_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: Data race detected between Write on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n   --> $DIR/write_write_race_stack.rs:LL:CC\n    |\n LL |             stack_var = 1usize;\n-   |             ^^^^^^^^^^^^^^^^^^ Data race detected between Write on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+   |             ^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "bf7a59da973cdfc2e5ead089a8dd164968e9a67a", "filename": "tests/pass/libc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Fpass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118a949f7c2193146861ae468aa12ae1e6b6d31/tests%2Fpass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.rs?ref=d118a949f7c2193146861ae468aa12ae1e6b6d31", "patch": "@@ -218,7 +218,8 @@ fn test_prctl_thread_name() {\n             libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long),\n             0,\n         );\n-        assert_eq!(b\"<unnamed>\\0\", &buf);\n+        // Rust runtime might set thread name, so we allow two options here.\n+        assert!(&buf[..10] == b\"<unnamed>\\0\" || &buf[..5] == b\"main\\0\");\n         let thread_name = CString::new(\"hello\").expect(\"CString::new failed\");\n         assert_eq!(\n             libc::prctl("}]}