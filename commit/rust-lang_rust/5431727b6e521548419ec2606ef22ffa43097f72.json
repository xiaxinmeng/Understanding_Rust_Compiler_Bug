{"sha": "5431727b6e521548419ec2606ef22ffa43097f72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MzE3MjdiNmU1MjE1NDg0MTllYzI2MDZlZjIyZmZhNDMwOTdmNzI=", "commit": {"author": {"name": "Alfie John", "email": "alfiej@fastmail.fm", "date": "2015-01-18T12:43:12Z"}, "committer": {"name": "Alfie John", "email": "alfiej@fastmail.fm", "date": "2015-01-18T12:43:12Z"}, "message": "docs: replacing more deprecated integer suffixes", "tree": {"sha": "03024fd62ecce6ea5d2b18aefd2c13b6b2b77759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03024fd62ecce6ea5d2b18aefd2c13b6b2b77759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5431727b6e521548419ec2606ef22ffa43097f72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5431727b6e521548419ec2606ef22ffa43097f72", "html_url": "https://github.com/rust-lang/rust/commit/5431727b6e521548419ec2606ef22ffa43097f72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5431727b6e521548419ec2606ef22ffa43097f72/comments", "author": null, "committer": null, "parents": [{"sha": "66003c06a19836f049996a629e8db4b6a118d5fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/66003c06a19836f049996a629e8db4b6a118d5fa", "html_url": "https://github.com/rust-lang/rust/commit/66003c06a19836f049996a629e8db4b6a118d5fa"}], "stats": {"total": 160, "additions": 80, "deletions": 80}, "files": [{"sha": "8d5a895c2a8c3eec3f0da73ccf05c61fffae21c7", "filename": "src/doc/reference.md", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/5431727b6e521548419ec2606ef22ffa43097f72/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/5431727b6e521548419ec2606ef22ffa43097f72/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=5431727b6e521548419ec2606ef22ffa43097f72", "patch": "@@ -578,8 +578,8 @@ Two examples of paths with type arguments:\n # struct HashMap<K, V>;\n # fn f() {\n # fn id<T>(t: T) -> T { t }\n-type T = HashMap<int,String>;  // Type arguments used in a type expression\n-let x = id::<int>(10);       // Type arguments used in a call expression\n+type T = HashMap<i32,String>; // Type arguments used in a type expression\n+let x  = id::<i32>(10);       // Type arguments used in a call expression\n # }\n ```\n \n@@ -1104,7 +1104,7 @@ interpreted as an implicit `return` expression applied to the final-expression.\n An example of a function:\n \n ```\n-fn add(x: int, y: int) -> int {\n+fn add(x: i32, y: i32) -> i32 {\n     return x + y;\n }\n ```\n@@ -1113,7 +1113,7 @@ As with `let` bindings, function arguments are irrefutable patterns, so any\n pattern that is valid in a let binding is also valid as an argument.\n \n ```\n-fn first((value, _): (int, int)) -> int { value }\n+fn first((value, _): (i32, i32)) -> i32 { value }\n ```\n \n \n@@ -1139,8 +1139,8 @@ used as a type name.\n \n When a generic function is referenced, its type is instantiated based on the\n context of the reference. For example, calling the `iter` function defined\n-above on `[1, 2]` will instantiate type parameter `T` with `int`, and require\n-the closure parameter to have type `fn(int)`.\n+above on `[1, 2]` will instantiate type parameter `T` with `isize`, and require\n+the closure parameter to have type `fn(isize)`.\n \n The type parameters can also be explicitly supplied in a trailing\n [path](#paths) component after the function name. This might be necessary if\n@@ -1272,7 +1272,7 @@ typecheck:\n ```\n # fn my_err(s: &str) -> ! { panic!() }\n \n-fn f(i: int) -> int {\n+fn f(i: i32) -> i32 {\n    if i == 42 {\n      return 42;\n    }\n@@ -1283,7 +1283,7 @@ fn f(i: int) -> int {\n ```\n \n This will not compile without the `!` annotation on `my_err`, since the `else`\n-branch of the conditional in `f` does not return an `int`, as required by the\n+branch of the conditional in `f` does not return an `i32`, as required by the\n signature of `f`. Adding the `!` annotation to `my_err` informs the\n typechecker that, should control ever enter `my_err`, no further type judgments\n about `f` need to hold, since control will never resume in any context that\n@@ -1301,18 +1301,18 @@ modifier.\n \n ```\n // Declares an extern fn, the ABI defaults to \"C\"\n-extern fn new_int() -> int { 0 }\n+extern fn new_i32() -> i32 { 0 }\n \n // Declares an extern fn with \"stdcall\" ABI\n-extern \"stdcall\" fn new_int_stdcall() -> int { 0 }\n+extern \"stdcall\" fn new_i32_stdcall() -> i32 { 0 }\n ```\n \n Unlike normal functions, extern fns have an `extern \"ABI\" fn()`. This is the\n same type as the functions declared in an extern block.\n \n ```\n-# extern fn new_int() -> int { 0 }\n-let fptr: extern \"C\" fn() -> int = new_int;\n+# extern fn new_i32() -> i32 { 0 }\n+let fptr: extern \"C\" fn() -> i32 = new_i32;\n ```\n \n Extern functions may be called directly from Rust code as Rust uses large,\n@@ -1348,18 +1348,18 @@ keyword `struct`.\n An example of a `struct` item and its use:\n \n ```\n-struct Point {x: int, y: int}\n+struct Point {x: i32, y: i32}\n let p = Point {x: 10, y: 11};\n-let px: int = p.x;\n+let px: i32 = p.x;\n ```\n \n A _tuple structure_ is a nominal [tuple type](#tuple-types), also defined with\n the keyword `struct`. For example:\n \n ```\n-struct Point(int, int);\n+struct Point(i32, i32);\n let p = Point(10, 11);\n-let px: int = match p { Point(x, _) => x };\n+let px: i32 = match p { Point(x, _) => x };\n ```\n \n A _unit-like struct_ is a structure without any fields, defined by leaving off\n@@ -1457,14 +1457,14 @@ a type derived from those primitive types. The derived types are references with\n the `static` lifetime, fixed-size arrays, tuples, enum variants, and structs.\n \n ```\n-const BIT1: uint = 1 << 0;\n-const BIT2: uint = 1 << 1;\n+const BIT1: u32 = 1 << 0;\n+const BIT2: u32 = 1 << 1;\n \n-const BITS: [uint; 2] = [BIT1, BIT2];\n+const BITS: [u32; 2] = [BIT1, BIT2];\n const STRING: &'static str = \"bitstring\";\n \n struct BitsNStrings<'a> {\n-    mybits: [uint; 2],\n+    mybits: [u32; 2],\n     mystring: &'a str\n }\n \n@@ -1500,14 +1500,14 @@ Constants should in general be preferred over statics, unless large amounts of\n data are being stored, or single-address and mutability properties are required.\n \n ```\n-use std::sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};;\n+use std::sync::atomic::{AtomicUint, Ordering, ATOMIC_USIZE_INIT};;\n \n-// Note that ATOMIC_UINT_INIT is a *const*, but it may be used to initialize a\n+// Note that ATOMIC_USIZE_INIT is a *const*, but it may be used to initialize a\n // static. This static can be modified, so it is not placed in read-only memory.\n-static COUNTER: AtomicUint = ATOMIC_UINT_INIT;\n+static COUNTER: AtomicUint = ATOMIC_USIZE_INIT;\n \n // This table is a candidate to be placed in read-only memory.\n-static TABLE: &'static [uint] = &[1, 2, 3, /* ... */];\n+static TABLE: &'static [usize] = &[1, 2, 3, /* ... */];\n \n for slot in TABLE.iter() {\n     println!(\"{}\", slot);\n@@ -1529,13 +1529,13 @@ Mutable statics are still very useful, however. They can be used with C\n libraries and can also be bound from C libraries (in an `extern` block).\n \n ```\n-# fn atomic_add(_: &mut uint, _: uint) -> uint { 2 }\n+# fn atomic_add(_: &mut u32, _: u32) -> u32 { 2 }\n \n-static mut LEVELS: uint = 0;\n+static mut LEVELS: u32 = 0;\n \n // This violates the idea of no shared state, and this doesn't internally\n // protect against races, so this function is `unsafe`\n-unsafe fn bump_levels_unsafe1() -> uint {\n+unsafe fn bump_levels_unsafe1() -> u32 {\n     let ret = LEVELS;\n     LEVELS += 1;\n     return ret;\n@@ -1544,7 +1544,7 @@ unsafe fn bump_levels_unsafe1() -> uint {\n // Assuming that we have an atomic_add function which returns the old value,\n // this function is \"safe\" but the meaning of the return value may not be what\n // callers expect, so it's still marked as `unsafe`\n-unsafe fn bump_levels_unsafe2() -> uint {\n+unsafe fn bump_levels_unsafe2() -> u32 {\n     return atomic_add(&mut LEVELS, 1);\n }\n ```\n@@ -1564,8 +1564,8 @@ Traits are implemented for specific types through separate\n [implementations](#implementations).\n \n ```\n-# type Surface = int;\n-# type BoundingBox = int;\n+# type Surface = i32;\n+# type BoundingBox = i32;\n trait Shape {\n     fn draw(&self, Surface);\n     fn bounding_box(&self) -> BoundingBox;\n@@ -1583,8 +1583,8 @@ functions](#generic-functions).\n \n ```\n trait Seq<T> {\n-   fn len(&self) -> uint;\n-   fn elt_at(&self, n: uint) -> T;\n+   fn len(&self) -> u32;\n+   fn elt_at(&self, n: u32) -> T;\n    fn iter<F>(&self, F) where F: Fn(T);\n }\n ```\n@@ -1595,7 +1595,7 @@ parameter, and within the generic function, the methods of the trait can be\n called on values that have the parameter's type. For example:\n \n ```\n-# type Surface = int;\n+# type Surface = i32;\n # trait Shape { fn draw(&self, Surface); }\n fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n     sh.draw(surface);\n@@ -1610,8 +1610,8 @@ trait is in scope) to pointers to the trait name, used as a type.\n \n ```\n # trait Shape { }\n-# impl Shape for int { }\n-# let mycircle = 0is;\n+# impl Shape for i32 { }\n+# let mycircle = 0i32;\n let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n ```\n \n@@ -1629,12 +1629,12 @@ module. For example:\n \n ```\n trait Num {\n-    fn from_int(n: int) -> Self;\n+    fn from_i32(n: i32) -> Self;\n }\n impl Num for f64 {\n-    fn from_int(n: int) -> f64 { n as f64 }\n+    fn from_i32(n: i32) -> f64 { n as f64 }\n }\n-let x: f64 = Num::from_int(42);\n+let x: f64 = Num::from_i32(42);\n ```\n \n Traits may inherit from other traits. For example, in\n@@ -1669,9 +1669,9 @@ Likewise, supertrait methods may also be called on trait objects.\n ```{.ignore}\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n-# impl Shape for int { fn area(&self) -> f64 { 0.0 } }\n-# impl Circle for int { fn radius(&self) -> f64 { 0.0 } }\n-# let mycircle = 0;\n+# impl Shape for i32 { fn area(&self) -> f64 { 0.0 } }\n+# impl Circle for i32 { fn radius(&self) -> f64 { 0.0 } }\n+# let mycircle = 0i32;\n let mycircle = Box::new(mycircle) as Box<Circle>;\n let nonsense = mycircle.radius() * mycircle.area();\n ```\n@@ -1686,7 +1686,7 @@ Implementations are defined with the keyword `impl`.\n ```\n # struct Point {x: f64, y: f64};\n # impl Copy for Point {}\n-# type Surface = int;\n+# type Surface = i32;\n # struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n # trait Shape { fn draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; }\n # fn do_draw_circle(s: Surface, c: Circle) { }\n@@ -1715,7 +1715,7 @@ limited to nominal types (enums, structs), and the implementation must appear\n in the same module or a sub-module as the `self` type:\n \n ```\n-struct Point {x: int, y: int}\n+struct Point {x: i32, y: i32}\n \n impl Point {\n     fn log(&self) {\n@@ -1826,7 +1826,7 @@ struct Foo;\n \n // Declare a public struct with a private field\n pub struct Bar {\n-    field: int\n+    field: i32\n }\n \n // Declare a public enum with two public variants\n@@ -2226,15 +2226,15 @@ plugins](book/plugin.html#lint-plugins) can provide additional lint checks.\n mod m1 {\n     // Missing documentation is ignored here\n     #[allow(missing_docs)]\n-    pub fn undocumented_one() -> int { 1 }\n+    pub fn undocumented_one() -> i32 { 1 }\n \n     // Missing documentation signals a warning here\n     #[warn(missing_docs)]\n-    pub fn undocumented_too() -> int { 2 }\n+    pub fn undocumented_too() -> i32 { 2 }\n \n     // Missing documentation signals an error here\n     #[deny(missing_docs)]\n-    pub fn undocumented_end() -> int { 3 }\n+    pub fn undocumented_end() -> i32 { 3 }\n }\n ```\n \n@@ -2247,16 +2247,16 @@ mod m2{\n     #[allow(missing_docs)]\n     mod nested {\n         // Missing documentation is ignored here\n-        pub fn undocumented_one() -> int { 1 }\n+        pub fn undocumented_one() -> i32 { 1 }\n \n         // Missing documentation signals a warning here,\n         // despite the allow above.\n         #[warn(missing_docs)]\n-        pub fn undocumented_two() -> int { 2 }\n+        pub fn undocumented_two() -> i32 { 2 }\n     }\n \n     // Missing documentation signals a warning here\n-    pub fn undocumented_too() -> int { 3 }\n+    pub fn undocumented_too() -> i32 { 3 }\n }\n ```\n \n@@ -2269,7 +2269,7 @@ mod m3 {\n     // Attempting to toggle warning signals an error here\n     #[allow(missing_docs)]\n     /// Returns 2.\n-    pub fn undocumented_too() -> int { 2 }\n+    pub fn undocumented_too() -> i32 { 2 }\n }\n ```\n \n@@ -2461,15 +2461,15 @@ the `PartialEq` or `Clone` constraints for the appropriate `impl`:\n ```\n #[derive(PartialEq, Clone)]\n struct Foo<T> {\n-    a: int,\n+    a: i32,\n     b: T\n }\n ```\n \n The generated `impl` for `PartialEq` is equivalent to\n \n ```\n-# struct Foo<T> { a: int, b: T }\n+# struct Foo<T> { a: i32, b: T }\n impl<T: PartialEq> PartialEq for Foo<T> {\n     fn eq(&self, other: &Foo<T>) -> bool {\n         self.a == other.a && self.b == other.b\n@@ -2862,7 +2862,7 @@ The following are examples of structure expressions:\n ```\n # struct Point { x: f64, y: f64 }\n # struct TuplePoint(f64, f64);\n-# mod game { pub struct User<'a> { pub name: &'a str, pub age: uint, pub score: uint } }\n+# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: uint } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10.0, y: 20.0};\n TuplePoint(10.0, 20.0);\n@@ -2883,7 +2883,7 @@ were explicitly specified and the values in the base expression for all other\n fields.\n \n ```\n-# struct Point3d { x: int, y: int, z: int }\n+# struct Point3d { x: i32, y: i32, z: i32 }\n let base = Point3d {x: 1, y: 2, z: 3};\n Point3d {y: 0, z: 10, .. base};\n ```\n@@ -3113,7 +3113,7 @@ An example of an `as` expression:\n \n ```\n # fn sum(v: &[f64]) -> f64 { 0.0 }\n-# fn len(v: &[f64]) -> int { 0 }\n+# fn len(v: &[f64]) -> i32 { 0 }\n \n fn avg(v: &[f64]) -> f64 {\n   let sum: f64 = sum(v);\n@@ -3184,7 +3184,7 @@ paren_expr : '(' expr ')' ;\n An example of a parenthesized expression:\n \n ```\n-let x: int = (2 + 3) * 4;\n+let x: i32 = (2 + 3) * 4;\n ```\n \n \n@@ -3204,9 +3204,9 @@ then the expression completes.\n Some examples of call expressions:\n \n ```\n-# fn add(x: int, y: int) -> int { 0 }\n+# fn add(x: i32, y: i32) -> i32 { 0 }\n \n-let x: int = add(1, 2);\n+let x: i32 = add(1i32, 2i32);\n let pi: Option<f32> = \"3.14\".parse();\n ```\n \n@@ -3245,8 +3245,8 @@ In this example, we define a function `ten_times` that takes a higher-order\n function argument, and call it with a lambda expression as an argument:\n \n ```\n-fn ten_times<F>(f: F) where F: Fn(int) {\n-    let mut i = 0;\n+fn ten_times<F>(f: F) where F: Fn(i32) {\n+    let mut i = 0i32;\n     while i < 10 {\n         f(i);\n         i += 1;\n@@ -3333,7 +3333,7 @@ by an implementation of `std::iter::Iterator`.\n An example of a for loop over the contents of an array:\n \n ```\n-# type Foo = int;\n+# type Foo = i32;\n # fn bar(f: Foo) { }\n # let a = 0;\n # let b = 0;\n@@ -3402,7 +3402,7 @@ fields of a particular variant. For example:\n enum List<X> { Nil, Cons(X, Box<List<X>>) }\n \n fn main() {\n-    let x: List<int> = List::Cons(10, box List::Cons(11, box List::Nil));\n+    let x: List<i32> = List::Cons(10, box List::Cons(11, box List::Nil));\n \n     match x {\n         List::Cons(_, box List::Nil) => panic!(\"singleton list\"),\n@@ -3428,7 +3428,7 @@ corresponding slice to the variable. Example:\n \n ```\n # #![feature(advanced_slice_patterns)]\n-fn is_symmetric(list: &[uint]) -> bool {\n+fn is_symmetric(list: &[u32]) -> bool {\n     match list {\n         [] | [_]                   => true,\n         [x, inside.., y] if x == y => is_symmetric(inside),\n@@ -3437,8 +3437,8 @@ fn is_symmetric(list: &[uint]) -> bool {\n }\n \n fn main() {\n-    let sym     = &[0, 1, 4, 2, 4, 1, 0];\n-    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n+    let sym     = &[0us, 1, 4, 2, 4, 1, 0];\n+    let not_sym = &[0us, 1, 7, 2, 4, 1, 0];\n     assert!(is_symmetric(sym));\n     assert!(!is_symmetric(not_sym));\n }\n@@ -3462,13 +3462,13 @@ An example of a `match` expression:\n \n ```\n #![feature(box_syntax)]\n-# fn process_pair(a: int, b: int) { }\n+# fn process_pair(a: i32, b: i32) { }\n # fn process_ten() { }\n \n enum List<X> { Nil, Cons(X, Box<List<X>>) }\n \n fn main() {\n-    let x: List<int> = List::Cons(10, box List::Cons(11, box List::Nil));\n+    let x: List<i32> = List::Cons(10, box List::Cons(11, box List::Nil));\n \n     match x {\n         List::Cons(a, box List::Cons(b, _)) => {\n@@ -3565,8 +3565,8 @@ may refer to the variables bound within the pattern they follow.\n \n ```\n # let maybe_digit = Some(0);\n-# fn process_digit(i: int) { }\n-# fn process_other(i: int) { }\n+# fn process_digit(i: i32) { }\n+# fn process_other(i: i32) { }\n \n let message = match maybe_digit {\n   Some(x) if x < 10 => process_digit(x),\n@@ -3614,7 +3614,7 @@ caller frame.\n An example of a `return` expression:\n \n ```\n-fn max(a: int, b: int) -> int {\n+fn max(a: i32, b: i32) -> i32 {\n    if a > b {\n       return a;\n    }\n@@ -3666,12 +3666,12 @@ The machine types are the following:\n \n #### Machine-dependent integer types\n \n-The `uint` type is an unsigned integer type with the same number of bits as the\n+The `usize` type is an unsigned integer type with the same number of bits as the\n platform's pointer type. It can represent every memory address in the process.\n \n-The `int` type is a signed integer type with the same number of bits as the\n+The `isize` type is a signed integer type with the same number of bits as the\n platform's pointer type. The theoretical upper bound on object and array size\n-is the maximum `int` value. This ensures that `int` can be used to calculate\n+is the maximum `isize` value. This ensures that `isize` can be used to calculate\n differences between pointers into an object or array and can address every byte\n within an object along with one byte past the end.\n \n@@ -3707,7 +3707,7 @@ by the tuple type.\n An example of a tuple type and its use:\n \n ```\n-type Pair<'a> = (int, &'a str);\n+type Pair<'a> = (i32, &'a str);\n let p: Pair<'static> = (10, \"hello\");\n let (a, b) = p;\n assert!(b != \"world\");\n@@ -3858,13 +3858,13 @@ or `extern`), a sequence of input types and an output type.\n An example of a `fn` type:\n \n ```\n-fn add(x: int, y: int) -> int {\n+fn add(x: i32, y: i32) -> i32 {\n   return x + y;\n }\n \n let mut x = add(5,7);\n \n-type Binop = fn(int, int) -> int;\n+type Binop = fn(i32, i32) -> i32;\n let bo: Binop = add;\n x = bo(5,7);\n ```\n@@ -4102,7 +4102,7 @@ Local variables are immutable unless declared otherwise like: `let mut x = ...`.\n \n Function parameters are immutable unless declared with `mut`. The `mut` keyword\n applies only to the following parameter (so `|mut x, y|` and `fn f(mut x:\n-Box<int>, y: Box<int>)` declare one mutable variable `x` and one immutable\n+Box<i32>, y: Box<i32>)` declare one mutable variable `x` and one immutable\n variable `y`).\n \n Methods that take either `self` or `Box<Self>` can optionally place them in a\n@@ -4130,7 +4130,7 @@ the type of a box is `std::owned::Box<T>`.\n An example of a box type and value:\n \n ```\n-let x: Box<int> = Box::new(10);\n+let x: Box<i32> = Box::new(10);\n ```\n \n Box values exist in 1:1 correspondence with their heap allocation, copying a\n@@ -4139,7 +4139,7 @@ copy of a box to move ownership of the value. After a value has been moved,\n the source location cannot be used unless it is reinitialized.\n \n ```\n-let x: Box<int> = Box::new(10);\n+let x: Box<i32> = Box::new(10);\n let y = x;\n // attempting to use `x` will result in an error here\n ```"}]}