{"sha": "6db27d9f90223693e84d230e5654d4c1a5afe700", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYjI3ZDlmOTAyMjM2OTNlODRkMjMwZTU2NTRkNGMxYTVhZmU3MDA=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-25T11:51:49Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-02T13:36:47Z"}, "message": "incr.comp.: Add minimal version of try_mark_green procedure.", "tree": {"sha": "8c531466374214251f179d026e8de608fdc2bf3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c531466374214251f179d026e8de608fdc2bf3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6db27d9f90223693e84d230e5654d4c1a5afe700", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6db27d9f90223693e84d230e5654d4c1a5afe700", "html_url": "https://github.com/rust-lang/rust/commit/6db27d9f90223693e84d230e5654d4c1a5afe700", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6db27d9f90223693e84d230e5654d4c1a5afe700/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a948be81cda8ed8145f4e1d7cf6b0a59efb8e240", "url": "https://api.github.com/repos/rust-lang/rust/commits/a948be81cda8ed8145f4e1d7cf6b0a59efb8e240", "html_url": "https://github.com/rust-lang/rust/commit/a948be81cda8ed8145f4e1d7cf6b0a59efb8e240"}], "stats": {"total": 324, "additions": 268, "deletions": 56}, "files": [{"sha": "071f233b188f8591f43be2ee65788340f6345900", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 131, "deletions": 15, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=6db27d9f90223693e84d230e5654d4c1a5afe700", "patch": "@@ -16,6 +16,7 @@ use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::hash::Hash;\n use std::rc::Rc;\n+use ty::TyCtxt;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n use ich::Fingerprint;\n@@ -28,6 +29,7 @@ use super::edges::{self, DepGraphEdges};\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n use super::prev::PreviousDepGraph;\n \n+\n #[derive(Clone)]\n pub struct DepGraph {\n     data: Option<Rc<DepGraphData>>,\n@@ -62,8 +64,7 @@ impl DepNodeIndex {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum DepNodeColor {\n     Red,\n-    Green,\n-    Gray\n+    Green(DepNodeIndex)\n }\n \n struct DepGraphData {\n@@ -178,6 +179,8 @@ impl DepGraph {\n               R: HashStable<HCX>,\n     {\n         if let Some(ref data) = self.data {\n+            debug_assert!(!data.colors.borrow().contains_key(&key));\n+\n             data.edges.borrow_mut().push_task(key);\n             data.current.borrow_mut().push_task(key);\n             if cfg!(debug_assertions) {\n@@ -212,7 +215,10 @@ impl DepGraph {\n             let prev_fingerprint = data.previous.fingerprint_of(&key);\n \n             let color = if Some(current_fingerprint) == prev_fingerprint {\n-                DepNodeColor::Green\n+                DepNodeColor::Green(DepNodeIndex {\n+                    legacy: dep_node_index_legacy,\n+                    new: dep_node_index_new,\n+                })\n             } else {\n                 DepNodeColor::Red\n             };\n@@ -310,18 +316,6 @@ impl DepGraph {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n-    pub fn node_color(&self, dep_node: &DepNode) -> DepNodeColor {\n-        match self.data.as_ref().unwrap().colors.borrow().get(dep_node) {\n-            Some(&color) => {\n-                debug_assert!(color != DepNodeColor::Gray);\n-                color\n-            }\n-            None => {\n-                DepNodeColor::Gray\n-            }\n-        }\n-    }\n-\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory).\n@@ -426,6 +420,128 @@ impl DepGraph {\n             edge_list_data,\n         }\n     }\n+\n+    pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n+        self.data.as_ref().and_then(|data| data.colors.borrow().get(dep_node).cloned())\n+    }\n+\n+    pub fn try_mark_green(&self,\n+                          tcx: TyCtxt,\n+                          dep_node: &DepNode)\n+                          -> Option<DepNodeIndex> {\n+        let data = self.data.as_ref().unwrap();\n+\n+        debug_assert!(!data.colors.borrow().contains_key(dep_node));\n+        debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n+\n+        if dep_node.kind.is_input() {\n+            // We should only hit try_mark_green() for inputs that do not exist\n+            // anymore in the current compilation session. Existing inputs are\n+            // eagerly marked as either red/green before any queries are\n+            // executed.\n+            debug_assert!(dep_node.extract_def_id(tcx).is_none());\n+            return None;\n+        }\n+\n+        let (prev_deps, prev_dep_node_index) = match data.previous.edges_from(dep_node) {\n+            Some(prev) => {\n+                // This DepNode and the corresponding query invocation existed\n+                // in the previous compilation session too, so we can try to\n+                // mark it as green by recursively marking all of its\n+                // dependencies green.\n+                prev\n+            }\n+            None => {\n+                // This DepNode did not exist in the previous compilation session,\n+                // so we cannot mark it as green.\n+                return None\n+            }\n+        };\n+\n+        let mut current_deps = Vec::new();\n+\n+        for &dep_dep_node in prev_deps {\n+            let dep_dep_node = &data.previous.index_to_node(dep_dep_node);\n+            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node).cloned();\n+            match dep_dep_node_color {\n+                Some(DepNodeColor::Green(node_index)) => {\n+                    // This dependency has been marked as green before, we are\n+                    // still fine and can continue with checking the other\n+                    // dependencies.\n+                    current_deps.push(node_index);\n+                }\n+                Some(DepNodeColor::Red) => {\n+                    // We found a dependency the value of which has changed\n+                    // compared to the previous compilation session. We cannot\n+                    // mark the DepNode as green and also don't need to bother\n+                    // with checking any of the other dependencies.\n+                    return None\n+                }\n+                None => {\n+                    // We don't know the state of this dependency. Let's try to\n+                    // mark it green.\n+                    if let Some(node_index) = self.try_mark_green(tcx, dep_dep_node) {\n+                        current_deps.push(node_index);\n+                    } else {\n+                        // We failed to mark it green. This can have various\n+                        // reasons.\n+                        return None\n+                    }\n+                }\n+            }\n+        }\n+\n+        // If we got here without hitting a `return` that means that all\n+        // dependencies of this DepNode could be marked as green. Therefore we\n+        // can also mark this DepNode as green. We do so by...\n+\n+        // ... allocating an entry for it in the current dependency graph and\n+        // adding all the appropriate edges imported from the previous graph ...\n+        let node_index_new = data.current\n+                                 .borrow_mut()\n+                                 .alloc_node(*dep_node,\n+                                             current_deps.iter().map(|n| n.new).collect());\n+        let dep_node_index_legacy = {\n+            let mut legacy_graph = data.edges.borrow_mut();\n+            legacy_graph.push_task(*dep_node);\n+            for node_index in current_deps.into_iter().map(|n| n.legacy) {\n+                legacy_graph.read_index(node_index);\n+            }\n+            legacy_graph.pop_task(*dep_node)\n+        };\n+\n+        // ... copying the fingerprint from the previous graph too, so we don't\n+        // have to recompute it ...\n+        let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n+        assert!(self.fingerprints\n+                    .borrow_mut()\n+                    .insert(*dep_node, fingerprint)\n+                    .is_none());\n+\n+        let node_index = DepNodeIndex {\n+            legacy: dep_node_index_legacy,\n+            new: node_index_new,\n+        };\n+\n+        // ... and finally storing a \"Green\" entry in the color map.\n+        assert!(data.colors\n+                    .borrow_mut()\n+                    .insert(*dep_node, DepNodeColor::Green(node_index))\n+                    .is_none());\n+\n+        Some(node_index)\n+    }\n+\n+    // Used in various assertions\n+    pub fn is_green(&self, dep_node_index: DepNodeIndex) -> bool {\n+        let dep_node = self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index.new];\n+        self.data.as_ref().unwrap().colors.borrow().get(&dep_node).map(|&color| {\n+            match color {\n+                DepNodeColor::Red => false,\n+                DepNodeColor::Green(_) => true,\n+            }\n+        }).unwrap_or(false)\n+    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the"}, {"sha": "a8f78336b37ced73bbf2bc1070348a0da5f3add1", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=6db27d9f90223693e84d230e5654d4c1a5afe700", "patch": "@@ -21,7 +21,7 @@ mod serialized;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId};\n-pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor};\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;"}, {"sha": "17001bbb0c38a4b1362c64391e37af2134014e0b", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=6db27d9f90223693e84d230e5654d4c1a5afe700", "patch": "@@ -28,20 +28,33 @@ impl PreviousDepGraph {\n         PreviousDepGraph { data, index }\n     }\n \n-    pub fn with_edges_from<F>(&self, dep_node: &DepNode, mut f: F)\n-    where\n-        F: FnMut(&(DepNode, Fingerprint)),\n-    {\n-        let node_index = self.index[dep_node];\n-        self.data\n-            .edge_targets_from(node_index)\n-            .into_iter()\n-            .for_each(|&index| f(&self.data.nodes[index]));\n+    #[inline]\n+    pub fn edges_from(&self,\n+                      dep_node: &DepNode)\n+                      -> Option<(&[SerializedDepNodeIndex], SerializedDepNodeIndex)> {\n+        self.index\n+            .get(dep_node)\n+            .map(|&node_index| {\n+                (self.data.edge_targets_from(node_index), node_index)\n+            })\n+    }\n+\n+    #[inline]\n+    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode {\n+        self.data.nodes[dep_node_index].0\n     }\n \n+    #[inline]\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index\n             .get(dep_node)\n             .map(|&node_index| self.data.nodes[node_index].1)\n     }\n+\n+    #[inline]\n+    pub fn fingerprint_by_index(&self,\n+                                dep_node_index: SerializedDepNodeIndex)\n+                                -> Fingerprint {\n+        self.data.nodes[dep_node_index].1\n+    }\n }"}, {"sha": "db66c279961b0fa0fdcd73aeb8426a443908c8b5", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=6db27d9f90223693e84d230e5654d4c1a5afe700", "patch": "@@ -43,7 +43,6 @@ use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;\n-use std::cell::{RefCell, Cell};\n \n use std::ops::Deref;\n use std::rc::Rc;"}, {"sha": "c7c81e3cf89baf7d7b0dee0aa142f5b0b8a5e8f5", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 97, "deletions": 25, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=6db27d9f90223693e84d230e5654d4c1a5afe700", "patch": "@@ -36,6 +36,26 @@ pub(super) struct QueryValue<T> {\n     pub(super) diagnostics: Option<Box<QueryDiagnostics>>,\n }\n \n+impl<T> QueryValue<T> {\n+    pub(super) fn new(value: T,\n+                      dep_node_index: DepNodeIndex,\n+                      diagnostics: Vec<Diagnostic>)\n+                      -> QueryValue<T> {\n+        QueryValue {\n+            value,\n+            index: dep_node_index,\n+            diagnostics: if diagnostics.len() == 0 {\n+                None\n+            } else {\n+                Some(Box::new(QueryDiagnostics {\n+                    diagnostics,\n+                    emitted_diagnostics: Cell::new(true),\n+                }))\n+            },\n+        }\n+    }\n+}\n+\n pub(super) struct QueryDiagnostics {\n     pub(super) diagnostics: Vec<Diagnostic>,\n     pub(super) emitted_diagnostics: Cell<bool>,\n@@ -142,6 +162,10 @@ macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+\n+        use dep_graph::DepNodeIndex;\n+        use std::cell::RefCell;\n+\n         define_map_struct! {\n             tcx: $tcx,\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n@@ -200,6 +224,7 @@ macro_rules! define_maps {\n         }\n \n         impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+\n             #[allow(unused)]\n             fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n@@ -241,9 +266,6 @@ macro_rules! define_maps {\n                     tcx.dep_graph.read_index(value.index);\n                     return Ok(f(&value.value));\n                 }\n-                // else, we are going to run the provider:\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-\n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n                 // default_span calls def_span query internally.\n@@ -252,42 +274,92 @@ macro_rules! define_maps {\n                 }\n \n                 let dep_node = Self::to_dep_node(tcx, &key);\n+\n+                if !dep_node.kind.is_input() && tcx.sess.opts.build_dep_graph() {\n+                    use dep_graph::DepNodeColor;\n+                    if let Some(DepNodeColor::Green(dep_node_index)) = tcx.dep_graph\n+                                                                          .node_color(&dep_node) {\n+                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                        tcx.dep_graph.read_index(dep_node_index);\n+                        return Self::load_from_disk_and_cache_in_memory(tcx,\n+                                                                        key,\n+                                                                        span,\n+                                                                        dep_node_index,\n+                                                                        f)\n+                    }\n+\n+                    if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n+                        debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n+                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                        tcx.dep_graph.read_index(dep_node_index);\n+                        return Self::load_from_disk_and_cache_in_memory(tcx,\n+                                                                        key,\n+                                                                        span,\n+                                                                        dep_node_index,\n+                                                                        f)\n+                    }\n+                }\n+\n+                // else, we are going to run the provider:\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n+\n                 let res = tcx.cycle_check(span, Query::$name(key), || {\n                     tcx.sess.diagnostic().track_diagnostics(|| {\n                         if dep_node.kind.is_anon() {\n                             tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                                provider(tcx.global_tcx(), key)\n+                                Self::compute_result(tcx.global_tcx(), key)\n                             })\n                         } else {\n-                            fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n-                                                            key: $K)\n-                                                            -> $V {\n-                                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                                provider(tcx.global_tcx(), key)\n-                            }\n-\n-                            tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n+                            tcx.dep_graph.with_task(dep_node,\n+                                                    tcx,\n+                                                    key,\n+                                                    Self::compute_result)\n                         }\n                     })\n                 })?;\n+\n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n                 let ((result, dep_node_index), diagnostics) = res;\n \n                 tcx.dep_graph.read_index(dep_node_index);\n \n-                let value = QueryValue {\n-                    value: result,\n-                    index: dep_node_index,\n-                    diagnostics: if diagnostics.len() == 0 {\n-                        None\n-                    } else {\n-                        Some(Box::new(QueryDiagnostics {\n-                            diagnostics,\n-                            emitted_diagnostics: Cell::new(true),\n-                        }))\n-                    },\n-                };\n+                let value = QueryValue::new(result, dep_node_index, diagnostics);\n+\n+                Ok(f(&tcx.maps\n+                         .$name\n+                         .borrow_mut()\n+                         .map\n+                         .entry(key)\n+                         .or_insert(value)\n+                         .value))\n+            }\n+\n+            fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n+                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                provider(tcx.global_tcx(), key)\n+            }\n+\n+            fn load_from_disk_and_cache_in_memory<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                                                        key: $K,\n+                                                        span: Span,\n+                                                        dep_node_index: DepNodeIndex,\n+                                                        f: F)\n+                                                        -> Result<R, CycleError<'a, $tcx>>\n+                where F: FnOnce(&$V) -> R\n+            {\n+                debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n+\n+                // We don't do any caching yet, so recompute\n+                let (result, diagnostics) = tcx.cycle_check(span, Query::$name(key), || {\n+                    tcx.sess.diagnostic().track_diagnostics(|| {\n+                        // The dep-graph for this computation is already in place\n+                        tcx.dep_graph.with_ignore(|| {\n+                            Self::compute_result(tcx, key)\n+                        })\n+                    })\n+                })?;\n+\n+                let value = QueryValue::new(result, dep_node_index, diagnostics);\n \n                 Ok(f(&tcx.maps\n                          .$name"}, {"sha": "c1653cfb43bc8f1f33bf618f03efe8e8d0b8dd93", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db27d9f90223693e84d230e5654d4c1a5afe700/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=6db27d9f90223693e84d230e5654d4c1a5afe700", "patch": "@@ -14,7 +14,7 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use rustc::dep_graph::{DepGraphSafe, DepKind};\n+use rustc::dep_graph::{DepGraphSafe, DepKind, DepNodeColor};\n use rustc::ich::StableHashingContext;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -162,10 +162,22 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // See README.md for a detailed discussion\n         // on dep-graph management.\n         let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-        tcx.dep_graph.with_task(dep_node,\n-                                self,\n-                                def_id,\n-                                visit_item_task);\n+\n+        if let Some(DepNodeColor::Green(_)) = tcx.dep_graph.node_color(&dep_node) {\n+            // If the corresponding node has already been marked as green, the\n+            // appropriate portion of the DepGraph has already been loaded from\n+            // the previous graph, so we don't do any dep-tracking. Since we\n+            // don't cache any values though, we still have to re-run the\n+            // computation.\n+            tcx.dep_graph.with_ignore(|| {\n+                self.build_constraints_for_item(def_id);\n+            });\n+        } else {\n+            tcx.dep_graph.with_task(dep_node,\n+                                    self,\n+                                    def_id,\n+                                    visit_item_task);\n+        }\n \n         fn visit_item_task<'a, 'tcx>(ccx: &mut ConstraintContext<'a, 'tcx>,\n                                      def_id: DefId)"}]}