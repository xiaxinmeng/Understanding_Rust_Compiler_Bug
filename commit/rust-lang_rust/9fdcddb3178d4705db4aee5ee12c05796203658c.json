{"sha": "9fdcddb3178d4705db4aee5ee12c05796203658c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZGNkZGIzMTc4ZDQ3MDVkYjRhZWU1ZWUxMmMwNTc5NjIwMzY1OGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-31T22:58:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:48Z"}, "message": "std: Make the TCP/UDP connect_timeout methods take Duration\n\n[breaking-change]", "tree": {"sha": "bf89747f277fc55b3f4c85f92a21008a248c0fbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf89747f277fc55b3f4c85f92a21008a248c0fbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fdcddb3178d4705db4aee5ee12c05796203658c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fdcddb3178d4705db4aee5ee12c05796203658c", "html_url": "https://github.com/rust-lang/rust/commit/9fdcddb3178d4705db4aee5ee12c05796203658c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fdcddb3178d4705db4aee5ee12c05796203658c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63cd4acf535f8df177459559fe2d7e6ab390c6d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/63cd4acf535f8df177459559fe2d7e6ab390c6d8", "html_url": "https://github.com/rust-lang/rust/commit/63cd4acf535f8df177459559fe2d7e6ab390c6d8"}], "stats": {"total": 40, "additions": 24, "deletions": 16}, "files": [{"sha": "84065bc936ecd891b7857320afa764b390d28f95", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9fdcddb3178d4705db4aee5ee12c05796203658c/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdcddb3178d4705db4aee5ee12c05796203658c/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=9fdcddb3178d4705db4aee5ee12c05796203658c", "patch": "@@ -34,6 +34,7 @@ use boxed::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n use rt::rtio;\n+use time::Duration;\n \n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n@@ -102,11 +103,11 @@ impl TcpStream {\n     /// and port, similar to the API seen in `connect`.\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n-                           timeout_ms: u64) -> IoResult<TcpStream> {\n+                           timeout: Duration) -> IoResult<TcpStream> {\n         let SocketAddr { ip, port } = addr;\n         let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n         LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr, Some(timeout_ms)).map(TcpStream::new)\n+            io.tcp_connect(addr, Some(in_ms_u64(timeout))).map(TcpStream::new)\n         }).map_err(IoError::from_rtio_error)\n     }\n \n@@ -443,6 +444,12 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n     }\n }\n \n+fn in_ms_u64(d: Duration) -> u64 {\n+    let ms = d.num_milliseconds();\n+    if ms < 0 { return 0 };\n+    return ms as u64;\n+}\n+\n #[cfg(test)]\n #[allow(experimental)]\n mod test {"}, {"sha": "8847b4c9214ad732a5cab3c09f5420e6da471323", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fdcddb3178d4705db4aee5ee12c05796203658c/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdcddb3178d4705db4aee5ee12c05796203658c/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=9fdcddb3178d4705db4aee5ee12c05796203658c", "patch": "@@ -33,6 +33,7 @@ use kinds::Send;\n use boxed::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n+use time::Duration;\n \n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n@@ -68,9 +69,9 @@ impl UnixStream {\n     /// elapses the function will return an error of kind `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P: ToCStr>(path: &P,\n-                                      timeout_ms: u64) -> IoResult<UnixStream> {\n+                                      timeout: Duration) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n-            let s = io.unix_connect(&path.to_c_str(), Some(timeout_ms));\n+            let s = io.unix_connect(&path.to_c_str(), Some(in_ms_u64(timeout)));\n             s.map(|p| UnixStream { obj: p })\n         }).map_err(IoError::from_rtio_error)\n     }\n@@ -499,13 +500,13 @@ mod tests {\n \n     iotest!(fn connect_timeout_error() {\n         let addr = next_test_unix();\n-        assert!(UnixStream::connect_timeout(&addr, 100).is_err());\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_err());\n     })\n \n     iotest!(fn connect_timeout_success() {\n         let addr = next_test_unix();\n         let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, 100).is_ok());\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_ok());\n     })\n \n     iotest!(fn close_readwrite_smoke() {"}, {"sha": "3045871ce7ac47db6a8b33508035c9ecf3be9ada", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9fdcddb3178d4705db4aee5ee12c05796203658c/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdcddb3178d4705db4aee5ee12c05796203658c/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=9fdcddb3178d4705db4aee5ee12c05796203658c", "patch": "@@ -72,12 +72,6 @@ pub struct Timer {\n \n struct TimerCallback { tx: Sender<()> }\n \n-fn in_ms(d: Duration) -> u64 {\n-    let ms = d.num_milliseconds();\n-    if ms < 0 { return 0 };\n-    return ms as u64;\n-}\n-\n /// Sleep the current task for the specified duration.\n ///\n /// When provided a zero or negative `duration`, the function will\n@@ -108,7 +102,7 @@ impl Timer {\n     /// return immediately.\n     pub fn sleep(&mut self, duration: Duration) {\n         // Short-circuit the timer backend for 0 duration\n-        let ms = in_ms(duration);\n+        let ms = in_ms_u64(duration);\n         if ms == 0 { return }\n         self.obj.sleep(ms);\n     }\n@@ -153,8 +147,8 @@ impl Timer {\n     pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> {\n         let (tx, rx) = channel();\n         // Short-circuit the timer backend for 0 duration\n-        if in_ms(duration) != 0 {\n-            self.obj.oneshot(in_ms(duration), box TimerCallback { tx: tx });\n+        if in_ms_u64(duration) != 0 {\n+            self.obj.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n         } else {\n             tx.send(());\n         }\n@@ -207,7 +201,7 @@ impl Timer {\n     /// When provided a zero or negative `duration`, the messages will\n     /// be sent without delay.\n     pub fn periodic(&mut self, duration: Duration) -> Receiver<()> {\n-        let ms = in_ms(duration);\n+        let ms = in_ms_u64(duration);\n         // FIXME: The backend implementations don't ever send a message\n         // if given a 0 ms duration. Temporarily using 1ms. It's\n         // not clear what use a 0ms period is anyway...\n@@ -224,6 +218,12 @@ impl Callback for TimerCallback {\n     }\n }\n \n+fn in_ms_u64(d: Duration) -> u64 {\n+    let ms = d.num_milliseconds();\n+    if ms < 0 { return 0 };\n+    return ms as u64;\n+}\n+\n #[cfg(test)]\n mod test {\n     iotest!(fn test_io_timer_sleep_simple() {"}]}