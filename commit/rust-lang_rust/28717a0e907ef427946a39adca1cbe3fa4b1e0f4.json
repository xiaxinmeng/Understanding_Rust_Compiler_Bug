{"sha": "28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NzE3YTBlOTA3ZWY0Mjc5NDZhMzlhZGNhMWNiZTNmYTRiMWUwZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-03T15:59:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-03T15:59:56Z"}, "message": "Auto merge of #1776 - hyd-dev:1170, r=RalfJung\n\nImplement calls to exported symbols (#1170)\n\nCloses #1170.", "tree": {"sha": "be57377af5c754be31ddeaa35c45dd55d2c9f047", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be57377af5c754be31ddeaa35c45dd55d2c9f047"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "html_url": "https://github.com/rust-lang/rust/commit/28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44122f9ff287f6bf2f1209244631ceb544a8f90a", "url": "https://api.github.com/repos/rust-lang/rust/commits/44122f9ff287f6bf2f1209244631ceb544a8f90a", "html_url": "https://github.com/rust-lang/rust/commit/44122f9ff287f6bf2f1209244631ceb544a8f90a"}, {"sha": "57e4f1d285c53d8826a6911c84230a46720c7498", "url": "https://api.github.com/repos/rust-lang/rust/commits/57e4f1d285c53d8826a6911c84230a46720c7498", "html_url": "https://github.com/rust-lang/rust/commit/57e4f1d285c53d8826a6911c84230a46720c7498"}], "stats": {"total": 1112, "additions": 828, "deletions": 284}, "files": [{"sha": "f0e14a9125c614293465ea96320f137a91c41eab", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -200,6 +200,8 @@ environment variable:\n   `compare_exchange_weak` operations. The default is `0.8` (so 4 out of 5 weak ops will fail).\n   You can change it to any value between `0.0` and `1.0`, where `1.0` means it\n   will always fail and `0.0` means it will never fail.\n+* `-Zmiri-disable-abi-check` disables checking [function ABI]. Using this flag\n+  is **unsound**.\n * `-Zmiri-disable-alignment-check` disables checking pointer alignment, so you\n   can focus on other failures, but it means Miri can miss bugs in your program.\n   Using this flag is **unsound**.\n@@ -263,6 +265,8 @@ environment variable:\n   with `-Zmiri-track-raw-pointers` also works without\n   `-Zmiri-track-raw-pointers`, but for the vast majority of code, this will be the case.\n \n+[function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n+\n Some native rustc `-Z` flags are also very relevant for Miri:\n \n * `-Zmir-opt-level` controls how many MIR optimizations are performed.  Miri"}, {"sha": "514e5b0aebe94f8ab1c4627b393c2194e183bc33", "filename": "src/bin/miri.rs", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,29 +1,52 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, bool_to_option, stmt_expr_attributes)]\n \n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_interface;\n+extern crate rustc_metadata;\n extern crate rustc_middle;\n extern crate rustc_session;\n \n use std::convert::TryFrom;\n use std::env;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n use std::str::FromStr;\n \n use hex::FromHexError;\n use log::debug;\n \n use rustc_driver::Compilation;\n use rustc_errors::emitter::{ColorConfig, HumanReadableErrorType};\n-use rustc_middle::ty::TyCtxt;\n-use rustc_session::{config::ErrorOutputType, CtfeBacktrace};\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_interface::interface::Config;\n+use rustc_middle::{\n+    middle::exported_symbols::{ExportedSymbol, SymbolExportLevel},\n+    ty::{query::Providers, TyCtxt},\n+};\n+use rustc_session::{config::ErrorOutputType, search_paths::PathKind, CtfeBacktrace};\n \n struct MiriCompilerCalls {\n     miri_config: miri::MiriConfig,\n }\n \n impl rustc_driver::Callbacks for MiriCompilerCalls {\n+    fn config(&mut self, config: &mut Config) {\n+        config.override_queries = Some(|_, _, external_providers| {\n+            external_providers.used_crate_source = |tcx, cnum| {\n+                let mut providers = Providers::default();\n+                rustc_metadata::provide_extern(&mut providers);\n+                let mut crate_source = (providers.used_crate_source)(tcx, cnum);\n+                // HACK: rustc will emit \"crate ... required to be available in rlib format, but\n+                // was not found in this form\" errors once we use `tcx.dependency_formats()` if\n+                // there's no rlib provided, so setting a dummy path here to workaround those errors.\n+                Rc::make_mut(&mut crate_source).rlib = Some((PathBuf::new(), PathKind::All));\n+                crate_source\n+            };\n+        });\n+    }\n+\n     fn after_analysis<'tcx>(\n         &mut self,\n         compiler: &rustc_interface::interface::Compiler,\n@@ -67,6 +90,39 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n     }\n }\n \n+struct MiriBeRustCompilerCalls {\n+    target_crate: bool,\n+}\n+\n+impl rustc_driver::Callbacks for MiriBeRustCompilerCalls {\n+    fn config(&mut self, config: &mut Config) {\n+        if config.opts.prints.is_empty() && self.target_crate {\n+            // Queries overriden here affect the data stored in `rmeta` files of dependencies,\n+            // which will be used later in non-`MIRI_BE_RUSTC` mode.\n+            config.override_queries = Some(|_, local_providers, _| {\n+                // `exported_symbols()` provided by rustc always returns empty result if\n+                // `tcx.sess.opts.output_types.should_codegen()` is false.\n+                local_providers.exported_symbols = |tcx, cnum| {\n+                    assert_eq!(cnum, LOCAL_CRATE);\n+                    tcx.arena.alloc_from_iter(\n+                        // This is based on:\n+                        // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L62-L63\n+                        // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L174\n+                        tcx.reachable_set(()).iter().filter_map(|&local_def_id| {\n+                            tcx.codegen_fn_attrs(local_def_id)\n+                                .contains_extern_indicator()\n+                                .then_some((\n+                                    ExportedSymbol::NonGeneric(local_def_id.to_def_id()),\n+                                    SymbolExportLevel::C,\n+                                ))\n+                        }),\n+                    )\n+                }\n+            });\n+        }\n+    }\n+}\n+\n fn init_early_loggers() {\n     // Note that our `extern crate log` is *not* the same as rustc's; as a result, we have to\n     // initialize them both, and we always initialize `miri`'s first.\n@@ -179,11 +235,7 @@ fn main() {\n     if let Some(crate_kind) = env::var_os(\"MIRI_BE_RUSTC\") {\n         rustc_driver::init_rustc_env_logger();\n \n-        // Don't insert `MIRI_DEFAULT_ARGS`, in particular, `--cfg=miri`, if we are building a\n-        // \"host\" crate. That may cause procedural macros (and probably build scripts) to depend\n-        // on Miri-only symbols, such as `miri_resolve_frame`:\n-        // https://github.com/rust-lang/miri/issues/1760\n-        let insert_default_args = if crate_kind == \"target\" {\n+        let target_crate = if crate_kind == \"target\" {\n             true\n         } else if crate_kind == \"host\" {\n             false\n@@ -192,8 +244,16 @@ fn main() {\n         };\n \n         // We cannot use `rustc_driver::main` as we need to adjust the CLI arguments.\n-        let mut callbacks = rustc_driver::TimePassesCallbacks::default();\n-        run_compiler(env::args().collect(), &mut callbacks, insert_default_args)\n+        run_compiler(\n+            env::args().collect(),\n+            &mut MiriBeRustCompilerCalls { target_crate },\n+            // Don't insert `MIRI_DEFAULT_ARGS`, in particular, `--cfg=miri`, if we are building\n+            // a \"host\" crate. That may cause procedural macros (and probably build scripts) to\n+            // depend on Miri-only symbols, such as `miri_resolve_frame`:\n+            // https://github.com/rust-lang/miri/issues/1760\n+            #[rustfmt::skip]\n+            /* insert_default_args: */ target_crate,\n+        )\n     }\n \n     // Init loggers the Miri way.\n@@ -227,6 +287,9 @@ fn main() {\n                 \"-Zmiri-symbolic-alignment-check\" => {\n                     miri_config.check_alignment = miri::AlignmentCheck::Symbolic;\n                 }\n+                \"-Zmiri-disable-abi-check\" => {\n+                    miri_config.check_abi = false;\n+                }\n                 \"-Zmiri-disable-isolation\" => {\n                     miri_config.communicate = true;\n                 }"}, {"sha": "f273cf04203da2f49c630af9d2f2b3867e2fc2a0", "filename": "src/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -5,7 +5,7 @@ use std::num::NonZeroU64;\n use log::trace;\n \n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_span::{source_map::DUMMY_SP, Span};\n+use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n use crate::*;\n \n@@ -14,8 +14,18 @@ pub enum TerminationInfo {\n     Exit(i64),\n     Abort(String),\n     UnsupportedInIsolation(String),\n-    ExperimentalUb { msg: String, url: String },\n+    ExperimentalUb {\n+        msg: String,\n+        url: String,\n+    },\n     Deadlock,\n+    MultipleSymbolDefinitions {\n+        link_name: Symbol,\n+        first: SpanData,\n+        first_crate: Symbol,\n+        second: SpanData,\n+        second_crate: Symbol,\n+    },\n }\n \n impl fmt::Display for TerminationInfo {\n@@ -27,6 +37,8 @@ impl fmt::Display for TerminationInfo {\n             UnsupportedInIsolation(msg) => write!(f, \"{}\", msg),\n             ExperimentalUb { msg, .. } => write!(f, \"{}\", msg),\n             Deadlock => write!(f, \"the evaluated program deadlocked\"),\n+            MultipleSymbolDefinitions { link_name, .. } =>\n+                write!(f, \"multiple definitions of symbol `{}`\", link_name),\n         }\n     }\n }\n@@ -55,19 +67,25 @@ pub fn report_error<'tcx, 'mir>(\n             use TerminationInfo::*;\n             let title = match info {\n                 Exit(code) => return Some(*code),\n-                Abort(_) => \"abnormal termination\",\n-                UnsupportedInIsolation(_) => \"unsupported operation\",\n-                ExperimentalUb { .. } => \"Undefined Behavior\",\n-                Deadlock => \"deadlock\",\n+                Abort(_) => Some(\"abnormal termination\"),\n+                UnsupportedInIsolation(_) => Some(\"unsupported operation\"),\n+                ExperimentalUb { .. } => Some(\"Undefined Behavior\"),\n+                Deadlock => Some(\"deadlock\"),\n+                MultipleSymbolDefinitions { .. } => None,\n             };\n             #[rustfmt::skip]\n             let helps = match info {\n                 UnsupportedInIsolation(_) =>\n-                    vec![format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation\")],\n+                    vec![(None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation\"))],\n                 ExperimentalUb { url, .. } =>\n                     vec![\n-                        format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\"),\n-                        format!(\"see {} for further information\", url),\n+                        (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\")),\n+                        (None, format!(\"see {} for further information\", url)),\n+                    ],\n+                MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>\n+                    vec![\n+                        (Some(*first), format!(\"it's first defined here, in crate `{}`\", first_crate)),\n+                        (Some(*second), format!(\"then it's defined here again, in crate `{}`\", second_crate)),\n                     ],\n                 _ => vec![],\n             };\n@@ -92,26 +110,26 @@ pub fn report_error<'tcx, 'mir>(\n             #[rustfmt::skip]\n             let helps = match e.kind() {\n                 Unsupported(UnsupportedOpInfo::NoMirFor(..)) =>\n-                    vec![format!(\"make sure to use a Miri sysroot, which you can prepare with `cargo miri setup`\")],\n+                    vec![(None, format!(\"make sure to use a Miri sysroot, which you can prepare with `cargo miri setup`\"))],\n                 Unsupported(UnsupportedOpInfo::ReadBytesAsPointer | UnsupportedOpInfo::ThreadLocalStatic(_) | UnsupportedOpInfo::ReadExternStatic(_)) =>\n                     panic!(\"Error should never be raised by Miri: {:?}\", e.kind()),\n                 Unsupported(_) =>\n-                    vec![format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\")],\n+                    vec![(None, format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\"))],\n                 UndefinedBehavior(UndefinedBehaviorInfo::AlignmentCheckFailed { .. })\n                     if ecx.memory.extra.check_alignment == AlignmentCheck::Symbolic\n                 =>\n                     vec![\n-                        format!(\"this usually indicates that your program performed an invalid operation and caused Undefined Behavior\"),\n-                        format!(\"but due to `-Zmiri-symbolic-alignment-check`, alignment errors can also be false positives\"),\n+                        (None, format!(\"this usually indicates that your program performed an invalid operation and caused Undefined Behavior\")),\n+                        (None, format!(\"but due to `-Zmiri-symbolic-alignment-check`, alignment errors can also be false positives\")),\n                     ],\n                 UndefinedBehavior(_) =>\n                     vec![\n-                        format!(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\"),\n-                        format!(\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\"),\n+                        (None, format!(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\")),\n+                        (None, format!(\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\")),\n                     ],\n                 _ => vec![],\n             };\n-            (title, helps)\n+            (Some(title), helps)\n         }\n     };\n \n@@ -120,7 +138,7 @@ pub fn report_error<'tcx, 'mir>(\n     report_msg(\n         *ecx.tcx,\n         /*error*/ true,\n-        &format!(\"{}: {}\", title, msg),\n+        &if let Some(title) = title { format!(\"{}: {}\", title, msg) } else { msg.clone() },\n         msg,\n         helps,\n         &ecx.generate_stacktrace(),\n@@ -159,7 +177,7 @@ fn report_msg<'tcx>(\n     error: bool,\n     title: &str,\n     span_msg: String,\n-    mut helps: Vec<String>,\n+    mut helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n ) {\n     let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n@@ -179,9 +197,13 @@ fn report_msg<'tcx>(\n     // Show help messages.\n     if !helps.is_empty() {\n         // Add visual separator before backtrace.\n-        helps.last_mut().unwrap().push_str(\"\\n\");\n-        for help in helps {\n-            err.help(&help);\n+        helps.last_mut().unwrap().1.push_str(\"\\n\");\n+        for (span_data, help) in helps {\n+            if let Some(span_data) = span_data {\n+                err.span_help(span_data.span(), &help);\n+            } else {\n+                err.help(&help);\n+            }\n         }\n     }\n     // Add backtrace"}, {"sha": "6646783d349cae3358cba1b66c2c84dada45c163", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -31,6 +31,8 @@ pub struct MiriConfig {\n     pub stacked_borrows: bool,\n     /// Controls alignment checking.\n     pub check_alignment: AlignmentCheck,\n+    /// Controls function [ABI](Abi) checking.\n+    pub check_abi: bool,\n     /// Determines if communication with the host environment is enabled.\n     pub communicate: bool,\n     /// Determines if memory leaks should be ignored.\n@@ -65,6 +67,7 @@ impl Default for MiriConfig {\n             validate: true,\n             stacked_borrows: true,\n             check_alignment: AlignmentCheck::Int,\n+            check_abi: true,\n             communicate: false,\n             ignore_leaks: false,\n             excluded_env_vars: vec![],"}, {"sha": "b71f830b2b10a214cfd8a25a7876413373932c39", "filename": "src/helpers.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -165,7 +165,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let param_env = ty::ParamEnv::reveal_all(); // in Miri this is always the param_env we use... and this.param_env is private.\n         let callee_abi = f.ty(*this.tcx, param_env).fn_sig(*this.tcx).abi();\n-        if callee_abi != caller_abi {\n+        if this.machine.enforce_abi && callee_abi != caller_abi {\n             throw_ub_format!(\n                 \"calling a function with ABI {} using caller ABI {}\",\n                 callee_abi.name(),\n@@ -616,6 +616,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(wchars)\n     }\n+\n+    /// Check that the ABI is what we expect.\n+    fn check_abi<'a>(&self, abi: Abi, exp_abi: Abi) -> InterpResult<'a, ()> {\n+        if self.eval_context_ref().machine.enforce_abi && abi != exp_abi {\n+            throw_ub_format!(\n+                \"calling a function with ABI {} using caller ABI {}\",\n+                exp_abi.name(),\n+                abi.name()\n+            )\n+        }\n+        Ok(())\n+    }\n }\n \n /// Check that the number of args is what we expect.\n@@ -631,19 +643,6 @@ where\n     throw_ub_format!(\"incorrect number of arguments: got {}, expected {}\", args.len(), N)\n }\n \n-/// Check that the ABI is what we expect.\n-pub fn check_abi<'a>(abi: Abi, exp_abi: Abi) -> InterpResult<'a, ()> {\n-    if abi == exp_abi {\n-        Ok(())\n-    } else {\n-        throw_ub_format!(\n-            \"calling a function with ABI {} using caller ABI {}\",\n-            exp_abi.name(),\n-            abi.name()\n-        )\n-    }\n-}\n-\n pub fn isolation_error(name: &str) -> InterpResult<'static> {\n     throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n         \"{} not available when isolation is enabled\","}, {"sha": "25806b472b6034604ac008fc0f51cec34a145845", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -3,6 +3,7 @@\n #![feature(map_try_insert)]\n #![feature(never_type)]\n #![feature(try_blocks)]\n+#![feature(bool_to_option)]\n #![warn(rust_2018_idioms)]\n #![allow(clippy::cast_lossless)]\n \n@@ -14,6 +15,7 @@ extern crate rustc_data_structures;\n extern crate rustc_hir;\n extern crate rustc_index;\n extern crate rustc_mir;\n+extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n "}, {"sha": "9c49575ded324f042c3c1d62ac47c6cababd7b63", "filename": "src/machine.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::{\n     ty::{\n         self,\n         layout::{LayoutCx, LayoutError, TyAndLayout},\n-        TyCtxt,\n+        Instance, TyCtxt,\n     },\n };\n use rustc_span::def_id::DefId;\n@@ -270,6 +270,9 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n \n+    /// Whether to enforce [ABI](Abi) of function calls.\n+    pub(crate) enforce_abi: bool,\n+\n     pub(crate) file_handler: shims::posix::FileHandler,\n     pub(crate) dir_handler: shims::posix::DirHandler,\n \n@@ -291,6 +294,9 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Used with `profiler` to cache the `StringId`s for event names\n     /// uesd with `measureme`.\n     string_cache: FxHashMap<String, measureme::StringId>,\n+\n+    /// Cache of `Instance` exported under the given `Symbol` name.\n+    pub(crate) exported_symbols_cache: FxHashMap<Symbol, Instance<'tcx>>,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n@@ -310,6 +316,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             tls: TlsData::default(),\n             communicate: config.communicate,\n             validate: config.validate,\n+            enforce_abi: config.check_abi,\n             file_handler: Default::default(),\n             dir_handler: Default::default(),\n             time_anchor: Instant::now(),\n@@ -318,6 +325,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             static_roots: Vec::new(),\n             profiler,\n             string_cache: Default::default(),\n+            exported_symbols_cache: FxHashMap::default(),\n         }\n     }\n }\n@@ -371,6 +379,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx.machine.validate\n     }\n \n+    #[inline(always)]\n+    fn enforce_abi(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        ecx.machine.enforce_abi\n+    }\n+\n     #[inline(always)]\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "c838c136c3f413e949ec642477841dfaf9e8b87a", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 148, "deletions": 68, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -6,18 +6,36 @@ use std::{\n use log::trace;\n \n use rustc_apfloat::Float;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::{\n+    def::DefKind,\n+    def_id::{CrateNum, DefId, LOCAL_CRATE},\n+};\n+use rustc_middle::middle::{\n+    codegen_fn_attrs::CodegenFnAttrFlags, dependency_format::Linkage,\n+    exported_symbols::ExportedSymbol,\n+};\n use rustc_middle::mir;\n use rustc_middle::ty;\n-use rustc_span::symbol::sym;\n+use rustc_session::config::CrateType;\n+use rustc_span::{symbol::sym, Symbol};\n use rustc_target::{\n     abi::{Align, Size},\n-    spec::{abi::Abi, PanicStrategy},\n+    spec::abi::Abi,\n };\n \n use super::backtrace::EvalContextExt as _;\n use crate::*;\n-use helpers::{check_abi, check_arg_count};\n+use helpers::check_arg_count;\n+\n+/// Returned by `emulate_foreign_item_by_name`.\n+pub enum EmulateByNameResult {\n+    /// The caller is expected to jump to the return block.\n+    NeedsJumping,\n+    /// Jumping has already been taken care of.\n+    AlreadyJumped,\n+    /// The item is not supported.\n+    NotSupported,\n+}\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -108,6 +126,77 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n+    /// Lookup the body of a function that has `link_name` as the symbol name.\n+    fn lookup_exported_symbol(\n+        &mut self,\n+        link_name: Symbol,\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx.tcx;\n+\n+        // If the result was cached, just return it.\n+        if let Some(instance) = this.machine.exported_symbols_cache.get(&link_name) {\n+            return Ok(Some(this.load_mir(instance.def, None)?));\n+        }\n+\n+        // Find it if it was not cached.\n+        let mut instance_and_crate: Option<(ty::Instance<'_>, CrateNum)> = None;\n+        // `dependency_formats` includes all the transitive informations needed to link a crate,\n+        // which is what we need here since we need to dig out `exported_symbols` from all transitive\n+        // dependencies.\n+        let dependency_formats = tcx.dependency_formats(());\n+        let dependency_format = dependency_formats\n+            .iter()\n+            .find(|(crate_type, _)| *crate_type == CrateType::Executable)\n+            .expect(\"interpreting a non-executable crate\");\n+        for cnum in\n+            iter::once(LOCAL_CRATE).chain(dependency_format.1.iter().enumerate().filter_map(\n+                |(num, &linkage)| (linkage != Linkage::NotLinked).then_some(CrateNum::new(num + 1)),\n+            ))\n+        {\n+            // We can ignore `_export_level` here: we are a Rust crate, and everything is exported\n+            // from a Rust crate.\n+            for &(symbol, _export_level) in tcx.exported_symbols(cnum) {\n+                if let ExportedSymbol::NonGeneric(def_id) = symbol {\n+                    let attrs = tcx.codegen_fn_attrs(def_id);\n+                    let symbol_name = if let Some(export_name) = attrs.export_name {\n+                        export_name\n+                    } else if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n+                        tcx.item_name(def_id)\n+                    } else {\n+                        // Skip over items without an explicitly defined symbol name.\n+                        continue;\n+                    };\n+                    if symbol_name == link_name {\n+                        if let Some((instance, original_cnum)) = instance_and_crate {\n+                            throw_machine_stop!(TerminationInfo::MultipleSymbolDefinitions {\n+                                link_name,\n+                                first: tcx.def_span(instance.def_id()).data(),\n+                                first_crate: tcx.crate_name(original_cnum),\n+                                second: tcx.def_span(def_id).data(),\n+                                second_crate: tcx.crate_name(cnum),\n+                            });\n+                        }\n+                        if tcx.def_kind(def_id) != DefKind::Fn {\n+                            throw_ub_format!(\n+                                \"attempt to call an exported symbol that is not defined as a function\"\n+                            );\n+                        }\n+                        instance_and_crate = Some((ty::Instance::mono(tcx, def_id), cnum));\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Cache it and load its MIR, if found.\n+        instance_and_crate\n+            .map(|(instance, _)| {\n+                this.machine.exported_symbols_cache.insert(link_name, instance);\n+                this.load_mir(instance.def, None)\n+            })\n+            .transpose()\n+    }\n+\n     /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n     /// Returns Ok(None) if the foreign item was completely handled\n@@ -124,10 +213,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n-        let link_name = match this.tcx.sess.first_attr_value_str_by_name(&attrs, sym::link_name) {\n-            Some(name) => name.as_str(),\n-            None => this.tcx.item_name(def_id).as_str(),\n-        };\n+        let link_name_sym = this\n+            .tcx\n+            .sess\n+            .first_attr_value_str_by_name(&attrs, sym::link_name)\n+            .unwrap_or_else(|| this.tcx.item_name(def_id));\n+        let link_name = link_name_sym.as_str();\n         // Strip linker suffixes (seen on 32-bit macOS).\n         let link_name = link_name.trim_end_matches(\"$UNIX2003\");\n         let tcx = this.tcx.tcx;\n@@ -136,14 +227,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let (dest, ret) = match ret {\n             None => match link_name {\n                 \"miri_start_panic\" => {\n-                    check_abi(abi, Abi::Rust)?;\n+                    this.check_abi(abi, Abi::Rust)?;\n                     this.handle_miri_start_panic(args, unwind)?;\n                     return Ok(None);\n                 }\n                 // This matches calls to the foreign item `panic_impl`.\n                 // The implementation is provided by the function with the `#[panic_handler]` attribute.\n                 \"panic_impl\" => {\n-                    check_abi(abi, Abi::Rust)?;\n+                    this.check_abi(abi, Abi::Rust)?;\n                     let panic_impl_id = tcx.lang_items().panic_impl().unwrap();\n                     let panic_impl_instance = ty::Instance::mono(tcx, panic_impl_id);\n                     return Ok(Some(&*this.load_mir(panic_impl_instance.def, None)?));\n@@ -152,76 +243,63 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 | \"exit\"\n                 | \"ExitProcess\"\n                 => {\n-                    check_abi(abi, if link_name == \"exit\" { Abi::C { unwind: false } } else { Abi::System { unwind: false } })?;\n+                    this.check_abi(abi, if link_name == \"exit\" { Abi::C { unwind: false } } else { Abi::System { unwind: false } })?;\n                     let &[ref code] = check_arg_count(args)?;\n                     // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n                     let code = this.read_scalar(code)?.to_i32()?;\n                     throw_machine_stop!(TerminationInfo::Exit(code.into()));\n                 }\n                 \"abort\" => {\n-                    check_abi(abi, Abi::C { unwind: false })?;\n+                    this.check_abi(abi, Abi::C { unwind: false })?;\n                     throw_machine_stop!(TerminationInfo::Abort(\n                         \"the program aborted execution\".to_owned()\n                     ))\n                 }\n-                _ => throw_unsup_format!(\"can't call (diverging) foreign function: {}\", link_name),\n+                _ => {\n+                    if let Some(body) = this.lookup_exported_symbol(link_name_sym)? {\n+                        return Ok(Some(body));\n+                    }\n+                    throw_unsup_format!(\"can't call (diverging) foreign function: {}\", link_name);\n+                }\n             },\n             Some(p) => p,\n         };\n \n-        // Second: some functions that we forward to MIR implementations.\n-        match link_name {\n-            // This matches calls to the foreign item `__rust_start_panic`, that is,\n-            // calls to `extern \"Rust\" { fn __rust_start_panic(...) }`\n-            // (and `__rust_panic_cleanup`, respectively).\n-            // We forward this to the underlying *implementation* in the panic runtime crate.\n-            // Normally, this will be either `libpanic_unwind` or `libpanic_abort`, but it could\n-            // also be a custom user-provided implementation via `#![feature(panic_runtime)]`\n-            #[rustfmt::skip]\n-            \"__rust_start_panic\" |\n-            \"__rust_panic_cleanup\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n-                // This replicates some of the logic in `inject_panic_runtime`.\n-                // FIXME: is there a way to reuse that logic?\n-                let panic_runtime = match this.tcx.sess.panic_strategy() {\n-                    PanicStrategy::Unwind => sym::panic_unwind,\n-                    PanicStrategy::Abort => sym::panic_abort,\n-                };\n-                let start_panic_instance =\n-                    this.resolve_path(&[&*panic_runtime.as_str(), link_name]);\n-                return Ok(Some(&*this.load_mir(start_panic_instance.def, None)?));\n+        // Second: functions that return.\n+        match this.emulate_foreign_item_by_name(link_name, abi, args, dest, ret)? {\n+            EmulateByNameResult::NeedsJumping => {\n+                trace!(\"{:?}\", this.dump_place(**dest));\n+                this.go_to_block(ret);\n+            }\n+            EmulateByNameResult::AlreadyJumped => (),\n+            EmulateByNameResult::NotSupported => {\n+                if let Some(body) = this.lookup_exported_symbol(link_name_sym)? {\n+                    return Ok(Some(body));\n+                }\n+                throw_unsup_format!(\"can't call foreign function: {}\", link_name);\n             }\n-            _ => {}\n-        }\n-\n-        // Third: functions that return.\n-        if this.emulate_foreign_item_by_name(link_name, abi, args, dest, ret)? {\n-            trace!(\"{:?}\", this.dump_place(**dest));\n-            this.go_to_block(ret);\n         }\n \n         Ok(None)\n     }\n \n-    /// Emulates calling a foreign item using its name, failing if the item is not supported.\n-    /// Returns `true` if the caller is expected to jump to the return block, and `false` if\n-    /// jumping has already been taken care of.\n+    /// Emulates calling a foreign item using its name.\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: &str,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         ret: mir::BasicBlock,\n-    ) -> InterpResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n         // Here we dispatch all the shims for foreign functions. If you have a platform specific\n         // shim, add it to the corresponding submodule.\n         match link_name {\n             // Miri-specific extern functions\n             \"miri_static_root\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                this.check_abi(abi, Abi::Rust)?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let ptr = this.force_ptr(ptr)?;\n@@ -233,27 +311,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Obtains a Miri backtrace. See the README for details.\n             \"miri_get_backtrace\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                this.check_abi(abi, Abi::Rust)?;\n                 this.handle_miri_get_backtrace(args, dest)?;\n             }\n \n             // Resolves a Miri backtrace frame. See the README for details.\n             \"miri_resolve_frame\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                this.check_abi(abi, Abi::Rust)?;\n                 this.handle_miri_resolve_frame(args, dest)?;\n             }\n \n \n             // Standard C allocation\n             \"malloc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref size] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref items, ref len] = check_arg_count(args)?;\n                 let items = this.read_scalar(items)?.to_machine_usize(this)?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n@@ -263,13 +341,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"free\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref old_ptr, ref new_size] = check_arg_count(args)?;\n                 let old_ptr = this.read_scalar(old_ptr)?.check_init()?;\n                 let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n@@ -281,7 +359,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // (Usually these would be forwarded to to `#[global_allocator]`; we instead implement a generic\n             // allocation that also checks that all conditions are met, such as not permitting zero-sized allocations.)\n             \"__rust_alloc\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                this.check_abi(abi, Abi::Rust)?;\n                 let &[ref size, ref align] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -294,7 +372,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                this.check_abi(abi, Abi::Rust)?;\n                 let &[ref size, ref align] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -309,7 +387,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                this.check_abi(abi, Abi::Rust)?;\n                 let &[ref ptr, ref old_size, ref align] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n@@ -323,7 +401,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                this.check_abi(abi, Abi::Rust)?;\n                 let &[ref ptr, ref old_size, ref align, ref new_size] = check_arg_count(args)?;\n                 let ptr = this.force_ptr(this.read_scalar(ptr)?.check_init()?)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n@@ -344,7 +422,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // C memory handling functions\n             \"memcmp\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref left, ref right, ref n] = check_arg_count(args)?;\n                 let left = this.read_scalar(left)?.check_init()?;\n                 let right = this.read_scalar(right)?.check_init()?;\n@@ -365,7 +443,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"memrchr\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n@@ -384,7 +462,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"memchr\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n@@ -402,7 +480,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"strlen\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let n = this.read_c_str(ptr)?.len();\n@@ -419,7 +497,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asinf\"\n             | \"atanf\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n@@ -440,7 +518,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypotf\"\n             | \"atan2f\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref f1, ref f2] = check_arg_count(args)?;\n                 // underscore case for windows, here and below\n                 // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n@@ -463,7 +541,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asin\"\n             | \"atan\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n@@ -484,7 +562,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypot\"\n             | \"atan2\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref f1, ref f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n@@ -501,7 +579,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"ldexp\"\n             | \"scalbn\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref x, ref exp] = check_arg_count(args)?;\n                 // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n                 let x = this.read_scalar(x)?.to_f64()?;\n@@ -523,12 +601,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Architecture-specific shims\n             \"llvm.x86.sse2.pause\" if this.tcx.sess.target.arch == \"x86\" || this.tcx.sess.target.arch == \"x86_64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.yield_active_thread();\n             }\n             \"llvm.aarch64.isb\" if this.tcx.sess.target.arch == \"aarch64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref arg] = check_arg_count(args)?;\n                 let arg = this.read_scalar(arg)?.to_i32()?;\n                 match arg {\n@@ -549,7 +627,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         };\n \n-        Ok(true)\n+        // We only fall through to here if we did *not* hit the `_` arm above,\n+        // i.e., if we actually emulated the function.\n+        Ok(EmulateByNameResult::NeedsJumping)\n     }\n \n     /// Check some basic requirements for this allocation request:"}, {"sha": "b07bf91a69a54ffa18746f36afbe88deffd9cc49", "filename": "src/shims/posix/dlsym.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fdlsym.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -2,7 +2,6 @@ use rustc_middle::mir;\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::check_abi;\n use shims::posix::linux::dlsym as linux;\n use shims::posix::macos::dlsym as macos;\n \n@@ -35,7 +34,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        check_abi(abi, Abi::C { unwind: false })?;\n+        this.check_abi(abi, Abi::C { unwind: false })?;\n \n         match dlsym {\n             Dlsym::Linux(dlsym) => linux::EvalContextExt::call_dlsym(this, dlsym, args, ret),"}, {"sha": "a756256aab41976f64b583a15d4a358d660071f5", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -5,7 +5,8 @@ use rustc_target::abi::{Align, LayoutOf, Size};\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::{check_abi, check_arg_count};\n+use helpers::check_arg_count;\n+use shims::foreign_items::EmulateByNameResult;\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::sync::EvalContextExt as _;\n use shims::posix::thread::EvalContextExt as _;\n@@ -19,57 +20,57 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         ret: mir::BasicBlock,\n-    ) -> InterpResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n         match link_name {\n             // Environment related shims\n             \"getenv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.getenv(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"unsetenv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.unsetenv(name)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name, ref value, ref overwrite] = check_arg_count(args)?;\n                 this.read_scalar(overwrite)?.to_i32()?;\n                 let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"getcwd\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.getcwd(buf, size)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"chdir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.chdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"open\" | \"open64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref flag, ref mode] = check_arg_count(args)?;\n                 let result = this.open(path, flag, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fcntl\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let result = this.fcntl(args)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"read\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf, ref count] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -78,7 +79,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf, ref n] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -89,70 +90,70 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.unlink(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"symlink\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref target, ref linkpath] = check_arg_count(args)?;\n                 let result = this.symlink(target, linkpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rename\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref oldpath, ref newpath] = check_arg_count(args)?;\n                 let result = this.rename(oldpath, newpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mkdir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref mode] = check_arg_count(args)?;\n                 let result = this.mkdir(path, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rmdir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.rmdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"closedir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dirp] = check_arg_count(args)?;\n                 let result = this.closedir(dirp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lseek\" | \"lseek64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref whence] = check_arg_count(args)?;\n                 let result = this.lseek64(fd, offset, whence)?;\n                 // \"lseek\" is only used on macOS which is 64bit-only, so `i64` always works.\n                 this.write_scalar(Scalar::from_i64(result), dest)?;\n             }\n             \"fsync\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fsync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fdatasync\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fdatasync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"readlink\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref pathname, ref buf, ref bufsize] = check_arg_count(args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n \n             // Allocation\n             \"posix_memalign\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ret, ref align, ref size] = check_arg_count(args)?;\n                 let ret = this.deref_operand(ret)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -183,7 +184,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamic symbol loading\n             \"dlsym\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref handle, ref symbol] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n                 let symbol = this.read_scalar(symbol)?.check_init()?;\n@@ -198,7 +199,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"sysconf\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.to_i32()?;\n \n@@ -224,7 +225,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"pthread_key_create\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key, ref dtor] = check_arg_count(args)?;\n                 let key_place = this.deref_operand(key)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n@@ -253,23 +254,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n@@ -282,177 +283,177 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_settype\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref kind] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_settype(attr, kind)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_init(mutex, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_lock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_lock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_trylock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_trylock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_unlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_unlock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_destroy(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_rdlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_rdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_tryrdlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_wrlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_wrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_trywrlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_trywrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_unlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_unlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_destroy(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_cond_init(cond, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_signal\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_signal(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_broadcast\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_broadcast(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_wait\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_cond_wait(cond, mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_timedwait\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref mutex, ref abstime] = check_arg_count(args)?;\n                 this.pthread_cond_timedwait(cond, mutex, abstime, dest)?;\n             }\n             \"pthread_cond_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_destroy(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Threading\n             \"pthread_create\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread, ref attr, ref start, ref arg] = check_arg_count(args)?;\n                 let result = this.pthread_create(thread, attr, start, arg)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_join\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread, ref retval] = check_arg_count(args)?;\n                 let result = this.pthread_join(thread, retval)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_detach\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 let result = this.pthread_detach(thread)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_self\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.pthread_self(dest)?;\n             }\n             \"sched_yield\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.sched_yield()?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"nanosleep\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref req, ref rem] = check_arg_count(args)?;\n                 let result = this.nanosleep(req, rem)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"isatty\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n@@ -462,7 +463,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_atfork\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref prepare, ref parent, ref child] = check_arg_count(args)?;\n                 this.force_bits(this.read_scalar(prepare)?.check_init()?, this.memory.pointer_size())?;\n                 this.force_bits(this.read_scalar(parent)?.check_init()?, this.memory.pointer_size())?;\n@@ -475,7 +476,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_attr_getguardsize\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref _attr, ref guard_size] = check_arg_count(args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n@@ -488,28 +489,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n             | \"pthread_attr_setstacksize\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n \n             | \"signal\"\n             | \"sigaltstack\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n             | \"sigaction\"\n             | \"mprotect\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_, _, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n@@ -524,6 +525,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         };\n \n-        Ok(true)\n+        Ok(EmulateByNameResult::NeedsJumping)\n     }\n }"}, {"sha": "598d89fe1f343306972e01740fb048a3fdba4fb6", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,8 +1,9 @@\n use rustc_middle::mir;\n use rustc_target::spec::abi::Abi;\n \n-use crate::helpers::{check_abi, check_arg_count};\n+use crate::helpers::check_arg_count;\n use crate::*;\n+use shims::foreign_items::EmulateByNameResult;\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::linux::sync::futex;\n use shims::posix::sync::EvalContextExt as _;\n@@ -17,13 +18,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n-    ) -> InterpResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n         match link_name {\n             // errno\n             \"__errno_location\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n@@ -33,32 +34,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These symbols have different names on Linux and macOS, which is the only reason they are not\n             // in the `posix` module.\n             \"close\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.close(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir64_r\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.linux_readdir64_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             // Linux-only\n             \"posix_fadvise\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref len, ref advice] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 this.read_scalar(offset)?.to_machine_isize(this)?;\n@@ -68,15 +69,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"sync_file_range\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref nbytes, ref flags] = check_arg_count(args)?;\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Time related shims\n             \"clock_gettime\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 // This is a POSIX function but it has only been tested on linux.\n                 let &[ref clk_id, ref tp] = check_arg_count(args)?;\n                 let result = this.clock_gettime(clk_id, tp)?;\n@@ -85,7 +86,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_attr_getstack\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n                 let &[ref attr_place, ref addr_place, ref size_place] = check_arg_count(args)?;\n                 this.deref_operand(attr_place)?;\n@@ -107,27 +108,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"prctl\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref option, ref arg2, ref arg3, ref arg4, ref arg5] = check_arg_count(args)?;\n                 let result = this.prctl(option, arg2, arg3, arg4, arg5)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_setclock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_setclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_getclock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_getclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 // The syscall variadic function is legal to call with more arguments than needed,\n                 // extra arguments are simply ignored. However, all arguments need to be scalars;\n                 // other types might be treated differently by the calling convention.\n@@ -188,12 +189,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Miscelanneous\n             \"getrandom\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ptr, ref len, ref flags] = check_arg_count(args)?;\n                 getrandom(this, ptr, len, flags, dest)?;\n             }\n             \"sched_getaffinity\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref pid, ref cpusetsize, ref mask] = check_arg_count(args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n                 this.read_scalar(cpusetsize)?.to_machine_usize(this)?;\n@@ -209,15 +210,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_getattr_np\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") =>\n             {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref _thread, ref _attr] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n \n-            _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n+            _ => return Ok(EmulateByNameResult::NotSupported),\n         };\n \n-        Ok(true)\n+        Ok(EmulateByNameResult::NeedsJumping)\n     }\n }\n "}, {"sha": "d54e1bfbe8195a4b74a70691f0afefe3e58c6cb0", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -2,7 +2,8 @@ use rustc_middle::mir;\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::{check_abi, check_arg_count};\n+use helpers::check_arg_count;\n+use shims::foreign_items::EmulateByNameResult;\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::thread::EvalContextExt as _;\n \n@@ -15,105 +16,105 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n-    ) -> InterpResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n         match link_name {\n             // errno\n             \"__error\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             // File related shims\n             \"close\" | \"close$NOCANCEL\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref result] = check_arg_count(args)?;\n                 let result = this.close(result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"stat\" | \"stat$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_stat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lstat\" | \"lstat$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_lstat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fstat\" | \"fstat$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_fstat(fd, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" | \"opendir$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir_r\" | \"readdir_r$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.macos_readdir_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Environment related shims\n             \"_NSGetEnviron\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.env_vars.environ.unwrap().ptr, dest)?;\n             }\n \n             // Time related shims\n             \"gettimeofday\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref tv, ref tz] = check_arg_count(args)?;\n                 let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mach_absolute_time\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.mach_absolute_time()?;\n                 this.write_scalar(Scalar::from_u64(result), dest)?;\n             }\n \n             \"mach_timebase_info\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref info] = check_arg_count(args)?;\n                 let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"_NSGetArgv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dtor, ref data] = check_arg_count(args)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n@@ -124,14 +125,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n@@ -140,7 +141,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"pthread_setname_np\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.check_init()?;\n                 this.pthread_setname_np(name)?;\n@@ -149,16 +150,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                this.check_abi(abi, Abi::C { unwind: false })?;\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n                 let &[ref addr, _, _, _, _, _] = check_arg_count(args)?;\n                 let addr = this.read_scalar(addr)?.check_init()?;\n                 this.write_scalar(addr, dest)?;\n             }\n \n-            _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n+            _ => return Ok(EmulateByNameResult::NotSupported),\n         };\n \n-        Ok(true)\n+        Ok(EmulateByNameResult::NeedsJumping)\n     }\n }"}, {"sha": "325100bdb3a7d40f431fb64c2d1cbe3db9532476", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -2,7 +2,6 @@ use rustc_middle::mir;\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::check_abi;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {}\n@@ -31,7 +30,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let (_dest, _ret) = ret.expect(\"we don't support any diverging dlsym\");\n         assert!(this.tcx.sess.target.os == \"windows\");\n \n-        check_abi(abi, Abi::System { unwind: false })?;\n+        this.check_abi(abi, Abi::System { unwind: false })?;\n \n         match dlsym {}\n     }"}, {"sha": "3c7451352dfd24d81fcfae3a3adc0cf2a13b02bf", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -5,7 +5,8 @@ use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::{check_abi, check_arg_count};\n+use helpers::check_arg_count;\n+use shims::foreign_items::EmulateByNameResult;\n use shims::windows::sync::EvalContextExt as _;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -17,7 +18,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n-    ) -> InterpResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n         // Windows API stubs.\n@@ -28,53 +29,53 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref name, ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentVariableW(name, buf, size)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref name, ref value] = check_arg_count(args)?;\n                 let result = this.SetEnvironmentVariableW(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetEnvironmentStringsW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentStringsW()?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref env_block] = check_arg_count(args)?;\n                 let result = this.FreeEnvironmentStringsW(env_block)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref size, ref buf] = check_arg_count(args)?;\n                 let result = this.GetCurrentDirectoryW(size, buf)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.SetCurrentDirectoryW(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"GetStdHandle\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref which] = check_arg_count(args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `WriteFile`\n                 // which one it is.\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"WriteFile\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] =\n                     check_arg_count(args)?;\n                 this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n@@ -110,7 +111,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Allocation\n             \"HeapAlloc\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n@@ -120,7 +121,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref ptr] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -129,7 +130,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref ptr, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -141,21 +142,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // errno\n             \"SetLastError\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref error] = check_arg_count(args)?;\n                 let error = this.read_scalar(error)?.check_init()?;\n                 this.set_last_error(error)?;\n             }\n             \"GetLastError\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let last_error = this.get_last_error()?;\n                 this.write_scalar(last_error, dest)?;\n             }\n \n             // Querying system information\n             \"GetSystemInfo\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref system_info] = check_arg_count(args)?;\n                 let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n@@ -171,7 +172,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"TlsAlloc\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n                 // Create key and return it.\n@@ -180,15 +181,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n@@ -201,7 +202,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Access to command-line arguments\n             \"GetCommandLineW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(\n                     this.machine.cmd_line.expect(\"machine must be initialized\"),\n@@ -211,20 +212,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Time related shims\n             \"GetSystemTimeAsFileTime\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref LPFILETIME] = check_arg_count(args)?;\n                 this.GetSystemTimeAsFileTime(LPFILETIME)?;\n             }\n             \"QueryPerformanceCounter\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref lpPerformanceCount] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref lpFrequency] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n@@ -233,41 +234,41 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockExclusive(ptr)?;\n             }\n             \"ReleaseSRWLockExclusive\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockExclusive(ptr)?;\n             }\n             \"TryAcquireSRWLockExclusive\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n             \"AcquireSRWLockShared\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockShared(ptr)?;\n             }\n             \"ReleaseSRWLockShared\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockShared(ptr)?;\n             }\n             \"TryAcquireSRWLockShared\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref hModule, ref lpProcName] = check_arg_count(args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n@@ -283,15 +284,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Miscellaneous\n             \"SystemFunction036\" => {\n                 // This is really 'RtlGenRandom'.\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr, ref len] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n             \"BCryptGenRandom\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref algorithm, ref ptr, ref len, ref flags] = check_arg_count(args)?;\n                 let algorithm = this.read_scalar(algorithm)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n@@ -312,7 +313,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?; // STATUS_SUCCESS\n             }\n             \"GetConsoleScreenBufferInfo\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 // `term` needs this, so we fake it.\n                 let &[ref console, ref buffer_info] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n@@ -322,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"GetConsoleMode\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 // Windows \"isatty\" (in libtest) needs this, so we fake it.\n                 let &[ref console, ref mode] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n@@ -332,7 +333,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"SwitchToThread\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 // Note that once Miri supports concurrency, this will need to return a nonzero\n                 // value if this call does result in switching to another thread.\n@@ -341,7 +342,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 throw_unsup_format!(\"Miri does not support concurrency on Windows\");\n             }\n \n@@ -350,15 +351,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"GetProcessHeap\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"SetConsoleTextAttribute\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _hConsoleOutput, ref _wAttribute] = check_arg_count(args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n@@ -367,7 +368,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"AddVectoredExceptionHandler\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _First, ref _Handler] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n@@ -376,7 +377,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"SetThreadStackGuarantee\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[_StackSizeInBytes] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n@@ -388,7 +389,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"DeleteCriticalSection\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(\n@@ -403,7 +404,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"TryEnterCriticalSection\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(\n@@ -415,9 +416,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n \n-            _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n+            _ => return Ok(EmulateByNameResult::NotSupported),\n         }\n \n-        Ok(true)\n+        Ok(EmulateByNameResult::NeedsJumping)\n     }\n }"}, {"sha": "9a9fa4797bf2677370b47a9dc6e7dc4fee3ca18a", "filename": "test-cargo-miri/Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.lock?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -14,6 +14,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"byteorder\",\n  \"cdylib\",\n+ \"exported_symbol\",\n  \"getrandom 0.1.16\",\n  \"getrandom 0.2.2\",\n  \"issue_1567\",\n@@ -37,6 +38,17 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n+[[package]]\n+name = \"exported_symbol\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"exported_symbol_dep\",\n+]\n+\n+[[package]]\n+name = \"exported_symbol_dep\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"getrandom\"\n version = \"0.1.16\""}, {"sha": "cf557bd60ef39643d652d8239258f2c4a4227c5d", "filename": "test-cargo-miri/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.toml?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,5 +1,5 @@\n [workspace]\n-members = [\"subcrate\", \"issue-1567\"]\n+members = [\"subcrate\", \"issue-1567\", \"exported-symbol-dep\"]\n \n [package]\n name = \"cargo-miri-test\"\n@@ -10,6 +10,7 @@ edition = \"2018\"\n [dependencies]\n byteorder = \"1.0\"\n cdylib = { path = \"cdylib\" }\n+exported_symbol = { path = \"exported-symbol\" }\n issue_1567 = { path = \"issue-1567\" }\n issue_1691 = { path = \"issue-1691\" }\n issue_1705 = { path = \"issue-1705\" }"}, {"sha": "00c41172c3af20a4f071721d1aedbda42ef2c199", "filename": "test-cargo-miri/exported-symbol-dep/Cargo.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol-dep%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol-dep%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fexported-symbol-dep%2FCargo.toml?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,5 @@\n+[package]\n+name = \"exported_symbol_dep\"\n+version = \"0.1.0\"\n+authors = [\"Miri Team\"]\n+edition = \"2018\""}, {"sha": "4cc18fb9b2fbca6a594778842d5ff0a94eeffae5", "filename": "test-cargo-miri/exported-symbol-dep/src/lib.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol-dep%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol-dep%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fexported-symbol-dep%2Fsrc%2Flib.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,4 @@\n+#[no_mangle]\n+fn exported_symbol() -> i32 {\n+    123456\n+}"}, {"sha": "7c01be1a85f9ce109d341f584b7d7da750f54423", "filename": "test-cargo-miri/exported-symbol/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fexported-symbol%2FCargo.toml?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"exported_symbol\"\n+version = \"0.1.0\"\n+authors = [\"Miri Team\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+# This will become a transitive dependency of doctests in `test-cargo-miri/src/lib.rs`,\n+# and the purpose of the test is to make sure Miri can find a `#[no_mangle]` function in a\n+# transitive dependency like `exported_symbol_dep`.\n+exported_symbol_dep = { path = \"../exported-symbol-dep\" }"}, {"sha": "de55eb2a1a5a003b0b9575d118274d26d470b3ef", "filename": "test-cargo-miri/exported-symbol/src/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fexported-symbol%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fexported-symbol%2Fsrc%2Flib.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1 @@\n+extern crate exported_symbol_dep;"}, {"sha": "6d9158c54ef4d9c91af1134848ead1e20dffe334", "filename": "test-cargo-miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsrc%2Flib.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -8,6 +8,7 @@\n /// ```rust,compile_fail\n /// assert!(cargo_miri_test::make_true() == 5);\n /// ```\n+#[no_mangle]\n pub fn make_true() -> bool {\n     issue_1567::use_the_dependency();\n     issue_1705::use_the_dependency();"}, {"sha": "a5669ef3087c53a4df47884a6e5cce4c45d784f8", "filename": "test-cargo-miri/src/main.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsrc%2Fmain.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -57,4 +57,20 @@ mod test {\n         assert_ne!(x as usize, y);\n         assert_ne!(y as u128, z);\n     }\n+\n+    #[test]\n+    fn exported_symbol() {\n+        extern crate cargo_miri_test;\n+        extern crate exported_symbol;\n+        // Test calling exported symbols in (transitive) dependencies.\n+        // Repeat calls to make sure the `Instance` cache is not broken.\n+        for _ in 0..3 {\n+            extern \"Rust\" {\n+                fn exported_symbol() -> i32;\n+                fn make_true() -> bool;\n+            }\n+            assert_eq!(unsafe { exported_symbol() }, 123456);\n+            assert!(unsafe { make_true() });\n+        }\n+    }\n }"}, {"sha": "62cfd1d37a172afeec43fb124857f8db0de97864", "filename": "test-cargo-miri/test.bin-target.stdout.ref", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.bin-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.bin-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.bin-target.stdout.ref?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,6 +1,7 @@\n \n-running 1 test\n+running 2 tests\n+test test::exported_symbol ... ok\n test test::rng ... ok\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "aa4a5839b14534b946212edbf50c18746fbbc3e1", "filename": "test-cargo-miri/test.cross-target.stdout.ref", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.cross-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.cross-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.cross-target.stdout.ref?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,7 +1,7 @@\n \n-running 1 test\n-.\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+running 2 tests\n+..\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n \n imported main\n "}, {"sha": "6c7d284a84ac8e8a0f36802597be0a7900e00b29", "filename": "test-cargo-miri/test.default.stdout.ref", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.default.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.default.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.default.stdout.ref?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,7 +1,7 @@\n \n-running 1 test\n-.\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+running 2 tests\n+..\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n \n imported main\n "}, {"sha": "b38aac9aa868dea75a90df3509e8afd0207c3100", "filename": "test-cargo-miri/test.filter.cross-target.stdout.ref", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.filter.cross-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.filter.cross-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.filter.cross-target.stdout.ref?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,7 +1,7 @@\n \n running 0 tests\n \n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n \n imported main\n "}, {"sha": "6b26e17ff8bb9b5cf2d72852a462bb0925684ded", "filename": "test-cargo-miri/test.filter.stdout.ref", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.filter.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/test-cargo-miri%2Ftest.filter.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.filter.stdout.ref?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,7 +1,7 @@\n \n running 0 tests\n \n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n \n imported main\n "}, {"sha": "138a43d9d7310cc69f7b971e9dcdf72f9d126d67", "filename": "tests/compile-fail/concurrency/unwind_top_of_stack.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Fconcurrency%2Funwind_top_of_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Fconcurrency%2Funwind_top_of_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Funwind_top_of_stack.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -1,10 +1,8 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// error-pattern: calling a function with ABI C-unwind using caller ABI C\n+// compile-flags: -Zmiri-disable-abi-check\n+// error-pattern: unwinding past the topmost frame of the stack\n \n //! Unwinding past the top frame of a stack is Undefined Behavior.\n-//! However, it is impossible to do that in pure Rust since one cannot write an unwinding\n-//! function with `C` ABI... so let's instead test that we are indeed correctly checking\n-//! the callee ABI in `pthread_create`.\n \n #![feature(rustc_private, c_unwind)]\n "}, {"sha": "5656c7a0e4cb6969f6804a9caa90d66baee543c3", "filename": "tests/compile-fail/function_calls/check_arg_abi.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_abi.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "previous_filename": "tests/compile-fail/check_arg_abi.rs"}, {"sha": "e1cea99eb90b25289e498e425c8d650ece74e70d", "filename": "tests/compile-fail/function_calls/check_arg_count_too_few_args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_too_few_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_too_few_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_too_few_args.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "previous_filename": "tests/compile-fail/check_arg_count_too_few_args.rs"}, {"sha": "c4028b940ff035c4732a32ed4fdda4f9b9525648", "filename": "tests/compile-fail/function_calls/check_arg_count_too_many_args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_too_many_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_too_many_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_too_many_args.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "previous_filename": "tests/compile-fail/check_arg_count_too_many_args.rs"}, {"sha": "e36bfe1c5783eb3b8652bd6e8cd496dfac7623ef", "filename": "tests/compile-fail/function_calls/check_callback_abi.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_callback_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_callback_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_callback_abi.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,17 @@\n+#![feature(core_intrinsics)]\n+\n+extern \"C\" fn try_fn(_: *mut u8) {\n+    unreachable!();\n+}\n+\n+fn main() {\n+    unsafe {\n+        // Make sure we check the ABI when Miri itself invokes a function\n+        // as part of a shim implementation.\n+        std::intrinsics::r#try( //~ ERROR calling a function with ABI C using caller ABI Rust\n+            std::mem::transmute::<extern \"C\" fn(*mut u8), _>(try_fn),\n+            std::ptr::null_mut(),\n+            |_, _| unreachable!(),\n+        );\n+    }\n+}"}, {"sha": "f92fae5d29355b2d50f550377fb2e5ad23269511", "filename": "tests/compile-fail/function_calls/exported_symbol_abi_mismatch.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,29 @@\n+// revisions: no_cache cache fn_ptr\n+\n+#[no_mangle]\n+fn foo() {}\n+\n+fn main() {\n+    #[cfg(any(cache, fn_ptr))]\n+    extern \"Rust\" {\n+        fn foo();\n+    }\n+\n+    #[cfg(fn_ptr)]\n+    unsafe { std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)() }\n+    //[fn_ptr]~^ ERROR calling a function with ABI Rust using caller ABI C\n+\n+    // `Instance` caching should not suppress ABI check.\n+    #[cfg(cache)]\n+    unsafe { foo() }\n+\n+    {\n+        #[cfg_attr(any(cache, fn_ptr), allow(clashing_extern_declarations))]\n+        extern \"C\" {\n+            fn foo();\n+        }\n+        unsafe { foo() }\n+        //[no_cache]~^ ERROR calling a function with ABI Rust using caller ABI C\n+        //[cache]~^^ ERROR calling a function with ABI Rust using caller ABI C\n+    }\n+}"}, {"sha": "91b0e8fc03f222e38a8b8e5916c0335bda551dcd", "filename": "tests/compile-fail/function_calls/exported_symbol_bad_unwind1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind1.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Zmiri-disable-abi-check\n+#![feature(c_unwind)]\n+\n+#[no_mangle]\n+extern \"C-unwind\" fn unwind() {\n+    panic!();\n+}\n+\n+fn main() {\n+    extern \"C\" {\n+        fn unwind();\n+    }\n+    unsafe { unwind() }\n+    //~^ ERROR unwinding past a stack frame that does not allow unwinding\n+}"}, {"sha": "85cca8f1a6bd3a08e3c4346f879a384f6d270cfa", "filename": "tests/compile-fail/function_calls/exported_symbol_bad_unwind2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind2.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,19 @@\n+// revisions: extern_block definition both\n+#![feature(rustc_attrs, c_unwind)]\n+\n+#[cfg_attr(any(definition, both), rustc_allocator_nounwind)]\n+#[no_mangle]\n+extern \"C-unwind\" fn nounwind() {\n+    panic!();\n+}\n+\n+fn main() {\n+    extern \"C-unwind\" {\n+        #[cfg_attr(any(extern_block, both), rustc_allocator_nounwind)]\n+        fn nounwind();\n+    }\n+    unsafe { nounwind() }\n+    //[extern_block]~^ ERROR unwinding past a stack frame that does not allow unwinding\n+    //[definition]~^^ ERROR unwinding past a stack frame that does not allow unwinding\n+    //[both]~^^^ ERROR unwinding past a stack frame that does not allow unwinding\n+}"}, {"sha": "bbbe677d3651e17eba26a4f160b86af36662d8fb", "filename": "tests/compile-fail/function_calls/exported_symbol_bad_unwind3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_bad_unwind3.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,15 @@\n+#![feature(unwind_attributes)]\n+\n+#[unwind(allowed)]\n+#[no_mangle]\n+extern \"C\" fn unwind() {\n+    panic!();\n+}\n+\n+fn main() {\n+    extern \"C\" {\n+        fn unwind();\n+    }\n+    unsafe { unwind() }\n+    //~^ ERROR unwinding past a stack frame that does not allow unwinding\n+}"}, {"sha": "105d98fc10a97b3e83fd0568e0b75cf481ada285", "filename": "tests/compile-fail/function_calls/exported_symbol_clashing.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_clashing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_clashing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_clashing.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,15 @@\n+#[no_mangle]\n+fn foo() {}\n+//~^ HELP then it's defined here again, in crate `exported_symbol_clashing`\n+\n+#[export_name = \"foo\"]\n+fn bar() {}\n+//~^ HELP it's first defined here, in crate `exported_symbol_clashing`\n+\n+fn main() {\n+    extern \"Rust\" {\n+        fn foo();\n+    }\n+    unsafe { foo() }\n+    //~^ ERROR multiple definitions of symbol `foo`\n+}"}, {"sha": "8fb364bb9bd104eb925fd98a7df1f9581297d75a", "filename": "tests/compile-fail/function_calls/exported_symbol_wrong_arguments.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_wrong_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_wrong_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_wrong_arguments.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,9 @@\n+#[no_mangle]\n+fn foo() {}\n+\n+fn main() {\n+    extern \"Rust\" {\n+        fn foo(_: i32);\n+    }\n+    unsafe { foo(1) } //~ ERROR calling a function with more arguments than it expected\n+}"}, {"sha": "3ffd506c94bb57df8b9c146ef93d3f0a2c59de4c", "filename": "tests/compile-fail/function_calls/exported_symbol_wrong_type.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_wrong_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_wrong_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_wrong_type.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,9 @@\n+#[no_mangle]\n+static FOO: () = ();\n+\n+fn main() {\n+    extern \"C\" {\n+        fn FOO();\n+    }\n+    unsafe { FOO() } //~ ERROR attempt to call an exported symbol that is not defined as a function\n+}"}, {"sha": "f77f892abc1c164007e4e94e852178e792135df0", "filename": "tests/compile-fail/panic/bad_miri_start_panic.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Fpanic%2Fbad_miri_start_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Fcompile-fail%2Fpanic%2Fbad_miri_start_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fbad_miri_start_panic.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Zmiri-disable-abi-check\n+\n+extern \"C\" {\n+    fn miri_start_panic(payload: *mut u8) -> !;\n+}\n+\n+fn main() {\n+    unsafe { miri_start_panic(&mut 0) }\n+    //~^ ERROR unwinding past a stack frame that does not allow unwinding\n+}"}, {"sha": "1f8554741376ba13e4f65f19fe24552fb0e5cb74", "filename": "tests/run-pass/function_calls/disable_abi_check.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fdisable_abi_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fdisable_abi_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_calls%2Fdisable_abi_check.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Zmiri-disable-abi-check\n+#![feature(core_intrinsics)]\n+\n+fn main() {\n+    fn foo() {}\n+\n+    extern \"C\" fn try_fn(ptr: *mut u8) {\n+        assert!(ptr.is_null());\n+    }\n+\n+    extern \"Rust\" {\n+        fn malloc(size: usize) -> *mut std::ffi::c_void;\n+    }\n+\n+    unsafe {\n+        let _ = malloc(0);\n+        std::mem::transmute::<fn(), extern \"C\" fn()>(foo)();\n+        std::intrinsics::r#try(\n+            std::mem::transmute::<extern \"C\" fn(*mut u8), _>(try_fn),\n+            std::ptr::null_mut(),\n+            |_, _| unreachable!(),\n+        );\n+    }\n+}"}, {"sha": "96bf8170c6eb1d5d5d4438b96403fc465c35977b", "filename": "tests/run-pass/function_calls/exported_symbol.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,73 @@\n+#![feature(rustc_attrs)]\n+\n+#[no_mangle]\n+extern \"C\" fn foo() -> i32 {\n+    -1\n+}\n+\n+#[export_name = \"bar\"]\n+fn bar() -> i32 {\n+    -2\n+}\n+\n+#[rustc_std_internal_symbol]\n+fn baz() -> i32 {\n+    -3\n+}\n+\n+// Make sure shims take precedence.\n+#[no_mangle]\n+extern \"C\" fn exit(_: i32) -> ! {\n+    unreachable!()\n+}\n+\n+#[no_mangle]\n+extern \"C\" fn ExitProcess(_: u32) -> ! {\n+    unreachable!()\n+}\n+\n+fn main() {\n+    // Repeat calls to make sure the `Instance` cache is not broken.\n+    for _ in 0..3 {\n+        extern \"C\" {\n+            fn foo() -> i32;\n+        }\n+\n+        assert_eq!(unsafe { foo() }, -1);\n+\n+        extern \"Rust\" {\n+            fn bar() -> i32;\n+            fn baz() -> i32;\n+        }\n+\n+        assert_eq!(unsafe { bar() }, -2);\n+        assert_eq!(unsafe { baz() }, -3);\n+\n+        #[allow(clashing_extern_declarations)]\n+        {\n+            extern \"Rust\" {\n+                fn foo() -> i32;\n+            }\n+\n+            assert_eq!(\n+                unsafe {\n+                    std::mem::transmute::<unsafe fn() -> i32, unsafe extern \"C\" fn() -> i32>(foo)()\n+                },\n+                -1\n+            );\n+\n+            extern \"C\" {\n+                fn bar() -> i32;\n+                fn baz() -> i32;\n+            }\n+\n+            unsafe {\n+                let transmute = |f| {\n+                    std::mem::transmute::<unsafe extern \"C\" fn() -> i32, unsafe fn() -> i32>(f)\n+                };\n+                assert_eq!(transmute(bar)(), -2);\n+                assert_eq!(transmute(baz)(), -3);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3dd3b8f22de5750af9c2247d7e8ea4e5e3d8ab9f", "filename": "tests/run-pass/function_calls/exported_symbol_good_unwind.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_good_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_good_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_good_unwind.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,49 @@\n+// Make sure the workaround for \"crate ... required to be available in rlib format, but was not\n+// found in this form\" errors works without `-C prefer-dynamic` (`panic!` calls foreign function\n+// `__rust_start_panic`).\n+// no-prefer-dynamic\n+#![feature(c_unwind, unboxed_closures, unwind_attributes)]\n+\n+use std::panic;\n+\n+#[no_mangle]\n+#[unwind(allowed)]\n+extern \"C\" fn good_unwind_allowed() {\n+    panic!();\n+}\n+\n+#[no_mangle]\n+extern \"C-unwind\" fn good_unwind_c() {\n+    panic!();\n+}\n+\n+#[no_mangle]\n+fn good_unwind_rust() {\n+    panic!();\n+}\n+\n+// Diverging function calls are on a different code path.\n+#[no_mangle]\n+extern \"rust-call\" fn good_unwind_rust_call(_: ()) -> ! {\n+    panic!();\n+}\n+\n+fn main() -> ! {\n+    extern \"C\" {\n+        #[unwind(allowed)]\n+        fn good_unwind_allowed();\n+    }\n+    panic::catch_unwind(|| unsafe { good_unwind_allowed() }).unwrap_err();\n+    extern \"C-unwind\" {\n+        fn good_unwind_c();\n+    }\n+    panic::catch_unwind(|| unsafe { good_unwind_c() }).unwrap_err();\n+    extern \"Rust\" {\n+        fn good_unwind_rust();\n+    }\n+    panic::catch_unwind(|| unsafe { good_unwind_rust() }).unwrap_err();\n+    extern \"rust-call\" {\n+        fn good_unwind_rust_call(_: ()) -> !;\n+    }\n+    unsafe { good_unwind_rust_call(()) }\n+}"}, {"sha": "3347f00b65eabe3395a3175ee0ad8cca10bbac64", "filename": "tests/run-pass/function_calls/exported_symbol_good_unwind.stderr", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_good_unwind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_good_unwind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_good_unwind.stderr?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,5 @@\n+thread 'main' panicked at 'explicit panic', $DIR/exported_symbol_good_unwind.rs:12:5\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n+thread 'main' panicked at 'explicit panic', $DIR/exported_symbol_good_unwind.rs:17:5\n+thread 'main' panicked at 'explicit panic', $DIR/exported_symbol_good_unwind.rs:22:5\n+thread 'main' panicked at 'explicit panic', $DIR/exported_symbol_good_unwind.rs:28:5"}, {"sha": "0e4ec5739a8a0765d77ba523fe8ec42fbabb687f", "filename": "tests/run-pass/function_calls/exported_symbol_unwind_allowed.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_unwind_allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_unwind_allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_unwind_allowed.rs?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Zmiri-disable-abi-check\n+#![feature(unwind_attributes, c_unwind)]\n+\n+#[no_mangle]\n+extern \"C-unwind\" fn unwind() {\n+    panic!();\n+}\n+\n+fn main() {\n+    extern \"C\" {\n+        #[unwind(allowed)]\n+        fn unwind();\n+    }\n+    unsafe { unwind() }\n+}"}, {"sha": "14ee43950cec718e79e198a012cd2d0be7f173c8", "filename": "tests/run-pass/function_calls/exported_symbol_unwind_allowed.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_unwind_allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28717a0e907ef427946a39adca1cbe3fa4b1e0f4/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_unwind_allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol_unwind_allowed.stderr?ref=28717a0e907ef427946a39adca1cbe3fa4b1e0f4", "patch": "@@ -0,0 +1,2 @@\n+thread 'main' panicked at 'explicit panic', $DIR/exported_symbol_unwind_allowed.rs:6:5\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}]}