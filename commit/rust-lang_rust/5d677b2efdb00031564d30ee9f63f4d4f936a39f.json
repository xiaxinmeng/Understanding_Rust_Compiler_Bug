{"sha": "5d677b2efdb00031564d30ee9f63f4d4f936a39f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNjc3YjJlZmRiMDAwMzE1NjRkMzBlZTlmNjNmNGQ0ZjkzNmEzOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-23T12:28:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-23T12:28:12Z"}, "message": "Auto merge of #60861 - Centril:let-chains-ast-intro, r=petrochenkov\n\n[let_chains, 2/6] Introduce `Let(..)` in AST, remove IfLet + WhileLet and parse let chains\n\nHere we remove `ast::ExprKind::{IfLet, WhileLet}` and introduce `ast::ExprKind::Let`.\nMoreover, we also:\n+ connect the parsing logic for let chains\n+ introduce the feature gate\n+ rewire HIR lowering a bit.\n\nHowever, this does not connect the new syntax to semantics in HIR.\nThat will be the subject of a subsequent PR.\n\nPer https://github.com/rust-lang/rust/issues/53667#issuecomment-471583239.\nNext step after https://github.com/rust-lang/rust/pull/59288.\n\ncc @Manishearth re. Clippy.\n\nr? @oli-obk", "tree": {"sha": "cf7f1b1a463a8a5ebbd802bd9cb61fe10d3fea0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf7f1b1a463a8a5ebbd802bd9cb61fe10d3fea0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d677b2efdb00031564d30ee9f63f4d4f936a39f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d677b2efdb00031564d30ee9f63f4d4f936a39f", "html_url": "https://github.com/rust-lang/rust/commit/5d677b2efdb00031564d30ee9f63f4d4f936a39f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d677b2efdb00031564d30ee9f63f4d4f936a39f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a96ba969156d257e5d5b692946fa8fe40ed6543a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a96ba969156d257e5d5b692946fa8fe40ed6543a", "html_url": "https://github.com/rust-lang/rust/commit/a96ba969156d257e5d5b692946fa8fe40ed6543a"}, {"sha": "c75f7ecaee508c568c0bc01c102965ce8b2246ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/c75f7ecaee508c568c0bc01c102965ce8b2246ef", "html_url": "https://github.com/rust-lang/rust/commit/c75f7ecaee508c568c0bc01c102965ce8b2246ef"}], "stats": {"total": 2959, "additions": 2334, "deletions": 625}, "files": [{"sha": "36b29ae6e607643cfbbcccf1758ee1c59f80d87a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 140, "deletions": 140, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -4344,53 +4344,147 @@ impl<'a> LoweringContext<'a> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            // More complicated than you might expect because the else branch\n-            // might be `if let`.\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                // If we got here, the `let` expression is not allowed.\n+                self.sess\n+                    .struct_span_err(e.span, \"`let` expressions are not supported here\")\n+                    .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+                    .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                    .emit();\n+\n+                // For better recovery, we emit:\n+                // ```\n+                // match scrutinee { pats => true, _ => false }\n+                // ```\n+                // While this doesn't fully match the user's intent, it has key advantages:\n+                // 1. We can avoid using `abort_if_errors`.\n+                // 2. We can typeck both `pats` and `scrutinee`.\n+                // 3. `pats` is allowed to be refutable.\n+                // 4. The return type of the block is `bool` which seems like what the user wanted.\n+                let scrutinee = self.lower_expr(scrutinee);\n+                let then_arm = {\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    let expr = self.expr_bool(e.span, true);\n+                    self.arm(pats, P(expr))\n+                };\n+                let else_arm = {\n+                    let pats = hir_vec![self.pat_wild(e.span)];\n+                    let expr = self.expr_bool(e.span, false);\n+                    self.arm(pats, P(expr))\n+                };\n+                hir::ExprKind::Match(\n+                    P(scrutinee),\n+                    vec![then_arm, else_arm].into(),\n+                    hir::MatchSource::Normal,\n+                )\n+            }\n+            // FIXME(#53667): handle lowering of && and parens.\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n-                // `true => then`:\n-                let then_pat = self.pat_bool(e.span, true);\n-                let then_blk = self.lower_block(then, false);\n-                let then_expr = self.expr_block(then_blk, ThinVec::new());\n-                let then_arm = self.arm(hir_vec![then_pat], P(then_expr));\n-\n                 // `_ => else_block` where `else_block` is `{}` if there's `None`:\n                 let else_pat = self.pat_wild(e.span);\n-                let else_expr = match else_opt {\n-                    None => self.expr_block_empty(e.span),\n-                    Some(els) => match els.node {\n-                        ExprKind::IfLet(..) => {\n-                            // Wrap the `if let` expr in a block.\n-                            let els = self.lower_expr(els);\n-                            let blk = self.block_all(els.span, hir_vec![], Some(P(els)));\n-                            self.expr_block(P(blk), ThinVec::new())\n-                        }\n-                        _ => self.lower_expr(els),\n-                    }\n+                let (else_expr, contains_else_clause) = match else_opt {\n+                    None => (self.expr_block_empty(e.span), false),\n+                    Some(els) => (self.lower_expr(els), true),\n                 };\n                 let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n \n-                // Lower condition:\n-                let span_block = self.mark_span_with_reason(IfTemporary, cond.span, None);\n-                let cond = self.lower_expr(cond);\n-                // Wrap in a construct equivalent to `{ let _t = $cond; _t }` to preserve drop\n-                // semantics since `if cond { ... }` don't let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+                // Handle then + scrutinee:\n+                let then_blk = self.lower_block(then, false);\n+                let then_expr = self.expr_block(then_blk, ThinVec::new());\n+                let (then_pats, scrutinee, desugar) = match cond.node {\n+                    // `<pat> => <then>`\n+                    ExprKind::Let(ref pats, ref scrutinee) => {\n+                        let scrutinee = self.lower_expr(scrutinee);\n+                        let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                        let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n+                        (pats, scrutinee, desugar)\n+                    }\n+                    // `true => then`:\n+                    _ => {\n+                        // Lower condition:\n+                        let cond = self.lower_expr(cond);\n+                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                        // to preserve drop semantics since `if cond { ... }`\n+                        // don't let temporaries live outside of `cond`.\n+                        let span_block = self.mark_span_with_reason(IfTemporary, cond.span, None);\n+                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                        // to preserve drop semantics since `if cond { ... }` does not\n+                        // let temporaries live outside of `cond`.\n+                        let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+\n+                        let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n+                        let pats = hir_vec![self.pat_bool(e.span, true)];\n+                        (pats, cond, desugar)\n+                    }\n+                };\n+                let then_arm = self.arm(then_pats, P(then_expr));\n \n-                hir::ExprKind::Match(\n-                    P(cond),\n-                    vec![then_arm, else_arm].into(),\n-                    hir::MatchSource::IfDesugar {\n-                        contains_else_clause: else_opt.is_some()\n-                    },\n-                )\n+                hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n+            }\n+            // FIXME(#53667): handle lowering of && and parens.\n+            ExprKind::While(ref cond, ref body, opt_label) => {\n+                // Desugar `ExprWhileLet`\n+                // from: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n+                if let ExprKind::Let(ref pats, ref sub_expr) = cond.node {\n+                    // to:\n+                    //\n+                    //   [opt_ident]: loop {\n+                    //     match <sub_expr> {\n+                    //       <pat> => <body>,\n+                    //       _ => break\n+                    //     }\n+                    //   }\n+\n+                    // Note that the block AND the condition are evaluated in the loop scope.\n+                    // This is done to allow `break` from inside the condition of the loop.\n+                    let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| {\n+                        (\n+                            this.lower_block(body, false),\n+                            this.expr_break(e.span, ThinVec::new()),\n+                            this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n+                        )\n+                    });\n+\n+                    // `<pat> => <body>`\n+                    let pat_arm = {\n+                        let body_expr = P(self.expr_block(body, ThinVec::new()));\n+                        let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                        self.arm(pats, body_expr)\n+                    };\n+\n+                    // `_ => break`\n+                    let break_arm = {\n+                        let pat_under = self.pat_wild(e.span);\n+                        self.arm(hir_vec![pat_under], break_expr)\n+                    };\n+\n+                    // `match <sub_expr> { ... }`\n+                    let arms = hir_vec![pat_arm, break_arm];\n+                    let match_expr = self.expr(\n+                        sub_expr.span,\n+                        hir::ExprKind::Match(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n+                        ThinVec::new(),\n+                    );\n+\n+                    // `[opt_ident]: loop { ... }`\n+                    let loop_block = P(self.block_expr(P(match_expr)));\n+                    let loop_expr = hir::ExprKind::Loop(\n+                        loop_block,\n+                        self.lower_label(opt_label),\n+                        hir::LoopSource::WhileLet,\n+                    );\n+                    // Add attributes to the outer returned expr node.\n+                    loop_expr\n+                } else {\n+                    self.with_loop_scope(e.id, |this| {\n+                        hir::ExprKind::While(\n+                            this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n+                            this.lower_block(body, false),\n+                            this.lower_label(opt_label),\n+                        )\n+                    })\n+                }\n             }\n-            ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprKind::While(\n-                    this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n-                    this.lower_block(body, false),\n-                    this.lower_label(opt_label),\n-                )\n-            }),\n             ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n                 hir::ExprKind::Loop(\n                     this.lower_block(body, false),\n@@ -4703,105 +4797,6 @@ impl<'a> LoweringContext<'a> {\n \n             ExprKind::Err => hir::ExprKind::Err,\n \n-            // Desugar `ExprIfLet`\n-            // from: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n-            ExprKind::IfLet(ref pats, ref sub_expr, ref body, ref else_opt) => {\n-                // to:\n-                //\n-                //   match <sub_expr> {\n-                //     <pat> => <body>,\n-                //     _ => [<else_opt> | ()]\n-                //   }\n-\n-                let mut arms = vec![];\n-\n-                // `<pat> => <body>`\n-                {\n-                    let body = self.lower_block(body, false);\n-                    let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                    arms.push(self.arm(pats, body_expr));\n-                }\n-\n-                // _ => [<else_opt>|{}]\n-                {\n-                    let wildcard_arm: Option<&Expr> = else_opt.as_ref().map(|p| &**p);\n-                    let wildcard_pattern = self.pat_wild(e.span);\n-                    let body = if let Some(else_expr) = wildcard_arm {\n-                        self.lower_expr(else_expr)\n-                    } else {\n-                        self.expr_block_empty(e.span)\n-                    };\n-                    arms.push(self.arm(hir_vec![wildcard_pattern], P(body)));\n-                }\n-\n-                let contains_else_clause = else_opt.is_some();\n-\n-                let sub_expr = P(self.lower_expr(sub_expr));\n-\n-                hir::ExprKind::Match(\n-                    sub_expr,\n-                    arms.into(),\n-                    hir::MatchSource::IfLetDesugar {\n-                        contains_else_clause,\n-                    },\n-                )\n-            }\n-\n-            // Desugar `ExprWhileLet`\n-            // from: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprKind::WhileLet(ref pats, ref sub_expr, ref body, opt_label) => {\n-                // to:\n-                //\n-                //   [opt_ident]: loop {\n-                //     match <sub_expr> {\n-                //       <pat> => <body>,\n-                //       _ => break\n-                //     }\n-                //   }\n-\n-                // Note that the block AND the condition are evaluated in the loop scope.\n-                // This is done to allow `break` from inside the condition of the loop.\n-                let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| {\n-                    (\n-                        this.lower_block(body, false),\n-                        this.expr_break(e.span, ThinVec::new()),\n-                        this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n-                    )\n-                });\n-\n-                // `<pat> => <body>`\n-                let pat_arm = {\n-                    let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                    self.arm(pats, body_expr)\n-                };\n-\n-                // `_ => break`\n-                let break_arm = {\n-                    let pat_under = self.pat_wild(e.span);\n-                    self.arm(hir_vec![pat_under], break_expr)\n-                };\n-\n-                // `match <sub_expr> { ... }`\n-                let arms = hir_vec![pat_arm, break_arm];\n-                let match_expr = self.expr(\n-                    sub_expr.span,\n-                    hir::ExprKind::Match(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n-                    ThinVec::new(),\n-                );\n-\n-                // `[opt_ident]: loop { ... }`\n-                let loop_block = P(self.block_expr(P(match_expr)));\n-                let loop_expr = hir::ExprKind::Loop(\n-                    loop_block,\n-                    self.lower_label(opt_label),\n-                    hir::LoopSource::WhileLet,\n-                );\n-                // Add attributes to the outer returned expr node.\n-                loop_expr\n-            }\n-\n             // Desugar `ExprForLoop`\n             // from: `[opt_ident]: for <pat> in <head> <body>`\n             ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n@@ -5463,10 +5458,15 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n+    /// Constructs a `true` or `false` literal expression.\n+    fn expr_bool(&mut self, span: Span, val: bool) -> hir::Expr {\n+        let lit = Spanned { span, node: LitKind::Bool(val) };\n+        self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new())\n+    }\n+\n     /// Constructs a `true` or `false` literal pattern.\n     fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat> {\n-        let lit = Spanned { span, node: LitKind::Bool(val) };\n-        let expr = self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new());\n+        let expr = self.expr_bool(span, val);\n         self.pat(span, hir::PatKind::Lit(P(expr)))\n     }\n "}, {"sha": "b5c5fc0608b950c5bf75065b5f5252c83706c014", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -324,20 +324,28 @@ impl UnusedParens {\n                                 value: &ast::Expr,\n                                 msg: &str,\n                                 followed_by_block: bool) {\n-        if let ast::ExprKind::Paren(ref inner) = value.node {\n-            let necessary = followed_by_block && match inner.node {\n-                ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n-                _ => parser::contains_exterior_struct_lit(&inner),\n-            };\n-            if !necessary {\n-                let expr_text = if let Ok(snippet) = cx.sess().source_map()\n-                    .span_to_snippet(value.span) {\n-                        snippet\n-                    } else {\n-                        pprust::expr_to_string(value)\n-                    };\n-                Self::remove_outer_parens(cx, value.span, &expr_text, msg);\n+        match value.node {\n+            ast::ExprKind::Paren(ref inner) => {\n+                let necessary = followed_by_block && match inner.node {\n+                    ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n+                    _ => parser::contains_exterior_struct_lit(&inner),\n+                };\n+                if !necessary {\n+                    let expr_text = if let Ok(snippet) = cx.sess().source_map()\n+                        .span_to_snippet(value.span) {\n+                            snippet\n+                        } else {\n+                            pprust::expr_to_string(value)\n+                        };\n+                    Self::remove_outer_parens(cx, value.span, &expr_text, msg);\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_parens_expr(cx, expr, \"`let` head expression\", followed_by_block);\n             }\n+            _ => {}\n         }\n     }\n \n@@ -399,8 +407,6 @@ impl EarlyLintPass for UnusedParens {\n         let (value, msg, followed_by_block) = match e.node {\n             If(ref cond, ..) => (cond, \"`if` condition\", true),\n             While(ref cond, ..) => (cond, \"`while` condition\", true),\n-            IfLet(_, ref cond, ..) => (cond, \"`if let` head expression\", true),\n-            WhileLet(_, ref cond, ..) => (cond, \"`while let` head expression\", true),\n             ForLoop(_, ref cond, ..) => (cond, \"`for` head expression\", true),\n             Match(ref head, _) => (head, \"`match` head expression\", true),\n             Ret(Some(ref value)) => (value, \"`return` value\", false),"}, {"sha": "2da9c5adf9baf7a24fd96bed15978cccd37375a0", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 55, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -17,13 +17,11 @@ use syntax::attr;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym};\n-use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n use syntax_ext::proc_macro_decls::is_proc_macro_attr;\n use syntax_pos::{Span, MultiSpan};\n use errors::{Applicability, FatalError};\n-use log::debug;\n \n #[derive(Copy, Clone, Debug)]\n struct OuterImplTrait {\n@@ -319,54 +317,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    /// With eRFC 2497, we need to check whether an expression is ambiguous and warn or error\n-    /// depending on the edition, this function handles that.\n-    fn while_if_let_ambiguity(&self, expr: &P<Expr>) {\n-        if let Some((span, op_kind)) = self.while_if_let_expr_ambiguity(&expr) {\n-            let mut err = self.err_handler().struct_span_err(\n-                span, &format!(\"ambiguous use of `{}`\", op_kind.to_string())\n-            );\n-\n-            err.note(\n-                \"this will be a error until the `let_chains` feature is stabilized\"\n-            );\n-            err.note(\n-                \"see rust-lang/rust#53668 for more information\"\n-            );\n-\n-            if let Ok(snippet) = self.session.source_map().span_to_snippet(span) {\n-                err.span_suggestion(\n-                    span, \"consider adding parentheses\", format!(\"({})\", snippet),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            err.emit();\n-        }\n-    }\n-\n-    /// With eRFC 2497 adding if-let chains, there is a requirement that the parsing of\n-    /// `&&` and `||` in a if-let statement be unambiguous. This function returns a span and\n-    /// a `BinOpKind` (either `&&` or `||` depending on what was ambiguous) if it is determined\n-    /// that the current expression parsed is ambiguous and will break in future.\n-    fn while_if_let_expr_ambiguity(&self, expr: &P<Expr>) -> Option<(Span, BinOpKind)> {\n-        debug!(\"while_if_let_expr_ambiguity: expr.node: {:?}\", expr.node);\n-        match &expr.node {\n-            ExprKind::Binary(op, _, _) if op.node == BinOpKind::And || op.node == BinOpKind::Or => {\n-                Some((expr.span, op.node))\n-            },\n-            ExprKind::Range(ref lhs, ref rhs, _) => {\n-                let lhs_ambiguous = lhs.as_ref()\n-                    .and_then(|lhs| self.while_if_let_expr_ambiguity(lhs));\n-                let rhs_ambiguous = rhs.as_ref()\n-                    .and_then(|rhs| self.while_if_let_expr_ambiguity(rhs));\n-\n-                lhs_ambiguous.or(rhs_ambiguous)\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     fn check_fn_decl(&self, fn_decl: &FnDecl) {\n         fn_decl\n             .inputs\n@@ -493,19 +443,17 @@ fn validate_generics_order<'a>(\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        match expr.node {\n-            ExprKind::Closure(_, _, _, ref fn_decl, _, _) => {\n+        match &expr.node {\n+            ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n                 self.check_fn_decl(fn_decl);\n             }\n-            ExprKind::IfLet(_, ref expr, _, _) | ExprKind::WhileLet(_, ref expr, _, _) =>\n-                self.while_if_let_ambiguity(&expr),\n             ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n                 span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n             }\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr)\n+        visit::walk_expr(self, expr);\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {"}, {"sha": "5f3d7159be6ce88fc8bc5c9707842bb19007de53", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -8,6 +8,7 @@\n \n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(bind_by_move_pattern_guards)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "a9e4ffd5e7f02753a9801c0722bb4a7bf4610466", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -485,8 +485,6 @@ type BindingMap = FxHashMap<Ident, BindingInfo>;\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n     Match,\n-    IfLet,\n-    WhileLet,\n     Let,\n     For,\n     FnParam,\n@@ -496,8 +494,6 @@ impl PatternSource {\n     fn descr(self) -> &'static str {\n         match self {\n             PatternSource::Match => \"match binding\",\n-            PatternSource::IfLet => \"if let binding\",\n-            PatternSource::WhileLet => \"while let binding\",\n             PatternSource::Let => \"let binding\",\n             PatternSource::For => \"for binding\",\n             PatternSource::FnParam => \"function parameter\",\n@@ -3057,13 +3053,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_arm(&mut self, arm: &Arm) {\n         self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n \n-        let mut bindings_list = FxHashMap::default();\n-        for pattern in &arm.pats {\n-            self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n-        }\n-\n-        // This has to happen *after* we determine which pat_idents are variants.\n-        self.check_consistent_bindings(&arm.pats);\n+        self.resolve_pats(&arm.pats, PatternSource::Match);\n \n         if let Some(ast::Guard::If(ref expr)) = arm.guard {\n             self.visit_expr(expr)\n@@ -3073,6 +3063,16 @@ impl<'a> Resolver<'a> {\n         self.ribs[ValueNS].pop();\n     }\n \n+    /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n+    fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n+        let mut bindings_list = FxHashMap::default();\n+        for pat in pats {\n+            self.resolve_pattern(pat, source, &mut bindings_list);\n+        }\n+        // This has to happen *after* we determine which pat_idents are variants\n+        self.check_consistent_bindings(pats);\n+    }\n+\n     fn resolve_block(&mut self, block: &Block) {\n         debug!(\"(resolving block) entering block\");\n         // Move down in the graph, if there's an anonymous module rooted here.\n@@ -3151,8 +3151,7 @@ impl<'a> Resolver<'a> {\n                 );\n             }\n             Some(..) if pat_src == PatternSource::Match ||\n-                        pat_src == PatternSource::IfLet ||\n-                        pat_src == PatternSource::WhileLet => {\n+                        pat_src == PatternSource::Let => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n                 res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n@@ -4345,41 +4344,26 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprKind::IfLet(ref pats, ref subexpression, ref if_block, ref optional_else) => {\n-                self.visit_expr(subexpression);\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                self.visit_expr(scrutinee);\n+                self.resolve_pats(pats, PatternSource::Let);\n+            }\n \n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n                 self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                let mut bindings_list = FxHashMap::default();\n-                for pat in pats {\n-                    self.resolve_pattern(pat, PatternSource::IfLet, &mut bindings_list);\n-                }\n-                // This has to happen *after* we determine which pat_idents are variants\n-                self.check_consistent_bindings(pats);\n-                self.visit_block(if_block);\n+                self.visit_expr(cond);\n+                self.visit_block(then);\n                 self.ribs[ValueNS].pop();\n \n-                optional_else.as_ref().map(|expr| self.visit_expr(expr));\n+                opt_else.as_ref().map(|expr| self.visit_expr(expr));\n             }\n \n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n \n             ExprKind::While(ref subexpression, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {\n-                    this.visit_expr(subexpression);\n-                    this.visit_block(block);\n-                });\n-            }\n-\n-            ExprKind::WhileLet(ref pats, ref subexpression, ref block, label) => {\n-                self.with_resolved_label(label, expr.id, |this| {\n-                    this.visit_expr(subexpression);\n                     this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                    let mut bindings_list = FxHashMap::default();\n-                    for pat in pats {\n-                        this.resolve_pattern(pat, PatternSource::WhileLet, &mut bindings_list);\n-                    }\n-                    // This has to happen *after* we determine which pat_idents are variants.\n-                    this.check_consistent_bindings(pats);\n+                    this.visit_expr(subexpression);\n                     this.visit_block(block);\n                     this.ribs[ValueNS].pop();\n                 });"}, {"sha": "09406f7306dd7ce0fccaa1c7ffb0105e2a8e188e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -1580,17 +1580,9 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, '\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }\n-            ast::ExprKind::WhileLet(ref pats, ref subexpression, ref block, _) => {\n+            ast::ExprKind::Let(ref pats, ref scrutinee) => {\n                 self.process_var_decl_multi(pats);\n-                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n-                self.visit_expr(subexpression);\n-                visit::walk_block(self, block);\n-            }\n-            ast::ExprKind::IfLet(ref pats, ref subexpression, ref block, ref opt_else) => {\n-                self.process_var_decl_multi(pats);\n-                self.visit_expr(subexpression);\n-                visit::walk_block(self, block);\n-                opt_else.as_ref().map(|el| self.visit_expr(el));\n+                self.visit_expr(scrutinee);\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.visit_expr(element);"}, {"sha": "21704206cbf86d4eaea90e0edbed1efb09d54654", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -1032,10 +1032,9 @@ impl Expr {\n             ExprKind::Unary(..) => ExprPrecedence::Unary,\n             ExprKind::Lit(_) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n+            ExprKind::Let(..) => ExprPrecedence::Let,\n             ExprKind::If(..) => ExprPrecedence::If,\n-            ExprKind::IfLet(..) => ExprPrecedence::IfLet,\n             ExprKind::While(..) => ExprPrecedence::While,\n-            ExprKind::WhileLet(..) => ExprPrecedence::WhileLet,\n             ExprKind::ForLoop(..) => ExprPrecedence::ForLoop,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n             ExprKind::Match(..) => ExprPrecedence::Match,\n@@ -1116,26 +1115,20 @@ pub enum ExprKind {\n     Cast(P<Expr>, P<Ty>),\n     /// A type ascription (e.g., `42: usize`).\n     Type(P<Expr>, P<Ty>),\n+    /// A `let pats = expr` expression that is only semantically allowed in the condition\n+    /// of `if` / `while` expressions. (e.g., `if let 0 = x { .. }`).\n+    ///\n+    /// The `Vec<P<Pat>>` is for or-patterns at the top level.\n+    /// FIXME(54883): Change this to just `P<Pat>`.\n+    Let(Vec<P<Pat>>, P<Expr>),\n     /// An `if` block, with an optional `else` block.\n     ///\n     /// `if expr { block } else { expr }`\n     If(P<Expr>, P<Block>, Option<P<Expr>>),\n-    /// An `if let` expression with an optional else block\n-    ///\n-    /// `if let pat = expr { block } else { expr }`\n-    ///\n-    /// This is desugared to a `match` expression.\n-    IfLet(Vec<P<Pat>>, P<Expr>, P<Block>, Option<P<Expr>>),\n-    /// A while loop, with an optional label\n+    /// A while loop, with an optional label.\n     ///\n     /// `'label: while expr { block }`\n     While(P<Expr>, P<Block>, Option<Label>),\n-    /// A `while let` loop, with an optional label.\n-    ///\n-    /// `'label: while let pat = expr { block }`\n-    ///\n-    /// This is desugared to a combination of `loop` and `match` expressions.\n-    WhileLet(Vec<P<Pat>>, P<Expr>, P<Block>, Option<Label>),\n     /// A `for` loop, with an optional label.\n     ///\n     /// `'label: for pat in expr { block }`"}, {"sha": "92ce3779a3c8153999c862a14a41c72b9a97388b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -825,7 +825,9 @@ fn may_begin_with(token: &Token, name: Name) -> bool {\n     }\n \n     match name {\n-        sym::expr => token.can_begin_expr(),\n+        sym::expr => token.can_begin_expr()\n+            // This exception is here for backwards compatibility.\n+            && !token.is_keyword(kw::Let),\n         sym::ty => token.can_begin_type(),\n         sym::ident => get_macro_name(token).is_some(),\n         sym::literal => token.can_begin_literal_or_bool(),"}, {"sha": "8ec07de5fab73d926967966fd88e89a2b7443df2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -560,6 +560,9 @@ declare_features! (\n     // Allows calling constructor functions in `const fn`.\n     (active, const_constructor, \"1.37.0\", Some(61456), None),\n \n+    // Allows `if/while p && let q = r && ...` chains.\n+    (active, let_chains, \"1.37.0\", Some(53667), None),\n+\n     // #[repr(transparent)] on enums.\n     (active, transparent_enums, \"1.37.0\", Some(60405), None),\n \n@@ -577,7 +580,8 @@ declare_features! (\n const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::impl_trait_in_bindings,\n     sym::generic_associated_types,\n-    sym::const_generics\n+    sym::const_generics,\n+    sym::let_chains,\n ];\n \n declare_features! (\n@@ -2517,6 +2521,17 @@ pub fn check_crate(krate: &ast::Crate,\n             \"attributes on function parameters are unstable\"\n         ));\n \n+    sess\n+        .let_chains_spans\n+        .borrow()\n+        .iter()\n+        .for_each(|span| gate_feature!(\n+            &ctx,\n+            let_chains,\n+            *span,\n+            \"`let` expressions in this position are experimental\"\n+        ));\n+\n     let visitor = &mut PostExpansionVisitor {\n         context: &ctx,\n         builtin_attributes: &*BUILTIN_ATTRIBUTE_MAP,"}, {"sha": "35aa2eead0b2b186429f1e3dd5cbec3c1c4104cf", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -1110,28 +1110,20 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n             vis.visit_ty(ty);\n         }\n         ExprKind::AddrOf(_m, ohs) => vis.visit_expr(ohs),\n+        ExprKind::Let(pats, scrutinee) => {\n+            visit_vec(pats, |pat| vis.visit_pat(pat));\n+            vis.visit_expr(scrutinee);\n+        }\n         ExprKind::If(cond, tr, fl) => {\n             vis.visit_expr(cond);\n             vis.visit_block(tr);\n             visit_opt(fl, |fl| vis.visit_expr(fl));\n         }\n-        ExprKind::IfLet(pats, expr, tr, fl) => {\n-            visit_vec(pats, |pat| vis.visit_pat(pat));\n-            vis.visit_expr(expr);\n-            vis.visit_block(tr);\n-            visit_opt(fl, |fl| vis.visit_expr(fl));\n-        }\n         ExprKind::While(cond, body, label) => {\n             vis.visit_expr(cond);\n             vis.visit_block(body);\n             visit_opt(label, |label| vis.visit_label(label));\n         }\n-        ExprKind::WhileLet(pats, expr, body, label) => {\n-            visit_vec(pats, |pat| vis.visit_pat(pat));\n-            vis.visit_expr(expr);\n-            vis.visit_block(body);\n-            visit_opt(label, |label| vis.visit_label(label));\n-        }\n         ExprKind::ForLoop(pat, iter, body, label) => {\n             vis.visit_pat(pat);\n             vis.visit_expr(iter);"}, {"sha": "6ebfab3a133ef80da61e6f8d75be0c8afa8314c4", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -14,11 +14,9 @@ use crate::ast;\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n     match e.node {\n         ast::ExprKind::If(..) |\n-        ast::ExprKind::IfLet(..) |\n         ast::ExprKind::Match(..) |\n         ast::ExprKind::Block(..) |\n         ast::ExprKind::While(..) |\n-        ast::ExprKind::WhileLet(..) |\n         ast::ExprKind::Loop(..) |\n         ast::ExprKind::ForLoop(..) |\n         ast::ExprKind::TryBlock(..) => false,"}, {"sha": "ead5d543bec7d80368d762174b3c9bed7d3642d7", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -1491,6 +1491,7 @@ mod tests {\n             edition: Edition::from_session(),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             param_attr_spans: Lock::new(Vec::new()),\n+            let_chains_spans: Lock::new(Vec::new()),\n         }\n     }\n "}, {"sha": "e19eab371f44ed1550eae1a6e13372b2889ad419", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -54,7 +54,9 @@ pub struct ParseSess {\n     /// operation token that followed it, but that the parser cannot identify without further\n     /// analysis.\n     pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n-    pub param_attr_spans: Lock<Vec<Span>>\n+    pub param_attr_spans: Lock<Vec<Span>>,\n+    // Places where `let` exprs were used and should be feature gated according to `let_chains`.\n+    pub let_chains_spans: Lock<Vec<Span>>,\n }\n \n impl ParseSess {\n@@ -81,6 +83,7 @@ impl ParseSess {\n             edition: Edition::from_session(),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             param_attr_spans: Lock::new(Vec::new()),\n+            let_chains_spans: Lock::new(Vec::new()),\n         }\n     }\n "}, {"sha": "b2003e2d6bd66a18e3738bf41f0b502b3895359c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 54, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -41,7 +41,7 @@ use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::{Token, TokenKind, DelimToken};\n use crate::parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n-use crate::util::parser::{AssocOp, Fixity};\n+use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::parse::PResult;\n@@ -2215,13 +2215,8 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ex = ExprKind::Yield(None);\n                     }\n-                } else if self.token.is_keyword(kw::Let) {\n-                    // Catch this syntax error here, instead of in `parse_ident`, so\n-                    // that we can explicitly mention that let is not to be used as an expression\n-                    let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n-                    db.span_label(self.token.span, \"expected expression\");\n-                    db.note(\"variable declaration using `let` is a statement\");\n-                    return Err(db);\n+                } else if self.eat_keyword(kw::Let) {\n+                    return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n                     let (await_hi, e_kind) = self.parse_await_macro_or_alt(lo, self.prev_span)?;\n                     hi = await_hi;\n@@ -2483,15 +2478,13 @@ impl<'a> Parser<'a> {\n                 attrs.extend::<Vec<_>>(expr.attrs.into());\n                 expr.attrs = attrs;\n                 match expr.node {\n-                    ExprKind::If(..) | ExprKind::IfLet(..) => {\n-                        if !expr.attrs.is_empty() {\n-                            // Just point to the first attribute in there...\n-                            let span = expr.attrs[0].span;\n-\n-                            self.span_err(span,\n-                                \"attributes are not yet allowed on `if` \\\n-                                expressions\");\n-                        }\n+                    ExprKind::If(..) if !expr.attrs.is_empty() => {\n+                        // Just point to the first attribute in there...\n+                        let span = expr.attrs[0].span;\n+\n+                        self.span_err(span,\n+                            \"attributes are not yet allowed on `if` \\\n+                            expressions\");\n                     }\n                     _ => {}\n                 }\n@@ -3161,13 +3154,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses an `if` or `if let` expression (`if` token already eaten).\n+    /// Parses an `if` expression (`if` token already eaten).\n     fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        if self.check_keyword(kw::Let) {\n-            return self.parse_if_let_expr(attrs);\n-        }\n         let lo = self.prev_span;\n-        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_cond_expr()?;\n \n         // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n         // verify that the last statement is either an implicit return (no `;`) or an explicit\n@@ -3197,22 +3187,32 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(hi), ExprKind::If(cond, thn, els), attrs))\n     }\n \n-    /// Parses an `if let` expression (`if` token already eaten).\n-    fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n-                             -> PResult<'a, P<Expr>> {\n+    /// Parse the condition of a `if`- or `while`-expression\n+    fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+\n+        if let ExprKind::Let(..) = cond.node {\n+            // Remove the last feature gating of a `let` expression since it's stable.\n+            let last = self.sess.let_chains_spans.borrow_mut().pop();\n+            debug_assert_eq!(cond.span, last.unwrap());\n+        }\n+\n+        Ok(cond)\n+    }\n+\n+    /// Parses a `let $pats = $expr` pseudo-expression.\n+    /// The `let` token has already been eaten.\n+    fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n-        self.expect_keyword(kw::Let)?;\n         let pats = self.parse_pats()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n-        let thn = self.parse_block()?;\n-        let (hi, els) = if self.eat_keyword(kw::Else) {\n-            let expr = self.parse_else_expr()?;\n-            (expr.span, Some(expr))\n-        } else {\n-            (thn.span, None)\n-        };\n-        Ok(self.mk_expr(lo.to(hi), ExprKind::IfLet(pats, expr, thn, els), attrs))\n+        let expr = self.with_res(\n+            Restrictions::NO_STRUCT_LITERAL,\n+            |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n+        )?;\n+        let span = lo.to(expr.span);\n+        self.sess.let_chains_spans.borrow_mut().push(span);\n+        Ok(self.mk_expr(span, ExprKind::Let(pats, expr), attrs))\n     }\n \n     /// Parses `move |args| expr`.\n@@ -3299,28 +3299,11 @@ impl<'a> Parser<'a> {\n     fn parse_while_expr(&mut self, opt_label: Option<Label>,\n                             span_lo: Span,\n                             mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        if self.token.is_keyword(kw::Let) {\n-            return self.parse_while_let_expr(opt_label, span_lo, attrs);\n-        }\n-        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-        let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs));\n-    }\n-\n-    /// Parses a `while let` expression (`while` token already eaten).\n-    fn parse_while_let_expr(&mut self, opt_label: Option<Label>,\n-                                span_lo: Span,\n-                                mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        self.expect_keyword(kw::Let)?;\n-        let pats = self.parse_pats()?;\n-        self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_cond_expr()?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::WhileLet(pats, expr, body, opt_label), attrs));\n+        Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs))\n     }\n \n     // parse `loop {...}`, `loop` token already eaten"}, {"sha": "ebd0decacb59fff2032d61444af8d801f78a6cc4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -135,6 +135,7 @@ pub(crate) fn ident_can_begin_expr(name: ast::Name, span: Span, is_raw: bool) ->\n         kw::False,\n         kw::For,\n         kw::If,\n+        kw::Let,\n         kw::Loop,\n         kw::Match,\n         kw::Move,"}, {"sha": "164fe2f36e1dae57660c3aa847bf9b2bd9a3950a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 41, "deletions": 51, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -1715,6 +1715,21 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n+    /// Print a `let pats = scrutinee` expression.\n+    pub fn print_let(&mut self, pats: &[P<ast::Pat>], scrutinee: &ast::Expr) -> io::Result<()> {\n+        self.s.word(\"let \")?;\n+\n+        self.print_pats(pats)?;\n+        self.s.space()?;\n+\n+        self.word_space(\"=\")?;\n+        self.print_expr_cond_paren(\n+            scrutinee,\n+            Self::cond_needs_par(scrutinee)\n+            || parser::needs_par_as_let_scrutinee(scrutinee.precedence().order())\n+        )\n+    }\n+\n     fn print_else(&mut self, els: Option<&ast::Expr>) -> io::Result<()> {\n         match els {\n             Some(_else) => {\n@@ -1729,19 +1744,6 @@ impl<'a> State<'a> {\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n-                    // Another `else if let` block.\n-                    ast::ExprKind::IfLet(ref pats, ref expr, ref then, ref e) => {\n-                        self.cbox(INDENT_UNIT - 1)?;\n-                        self.ibox(0)?;\n-                        self.s.word(\" else if let \")?;\n-                        self.print_pats(pats)?;\n-                        self.s.space()?;\n-                        self.word_space(\"=\")?;\n-                        self.print_expr_as_cond(expr)?;\n-                        self.s.space()?;\n-                        self.print_block(then)?;\n-                        self.print_else(e.as_ref().map(|e| &**e))\n-                    }\n                     // Final `else` block.\n                     ast::ExprKind::Block(ref b, _) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n@@ -1762,20 +1764,10 @@ impl<'a> State<'a> {\n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n                     elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if\")?;\n+\n         self.print_expr_as_cond(test)?;\n         self.s.space()?;\n-        self.print_block(blk)?;\n-        self.print_else(elseopt)\n-    }\n \n-    pub fn print_if_let(&mut self, pats: &[P<ast::Pat>], expr: &ast::Expr, blk: &ast::Block,\n-                        elseopt: Option<&ast::Expr>) -> io::Result<()> {\n-        self.head(\"if let\")?;\n-        self.print_pats(pats)?;\n-        self.s.space()?;\n-        self.word_space(\"=\")?;\n-        self.print_expr_as_cond(expr)?;\n-        self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n     }\n@@ -1807,30 +1799,30 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = expr.precedence().order() < prec;\n-        if needs_par {\n-            self.popen()?;\n-        }\n-        self.print_expr(expr)?;\n-        if needs_par {\n-            self.pclose()?;\n-        }\n-        Ok(())\n+        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n     }\n \n     /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n     pub fn print_expr_as_cond(&mut self, expr: &ast::Expr) -> io::Result<()> {\n-        let needs_par = match expr.node {\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n+    }\n+\n+    /// Does `expr` need parenthesis when printed in a condition position?\n+    fn cond_needs_par(expr: &ast::Expr) -> bool {\n+        match expr.node {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n             ast::ExprKind::Closure(..) |\n             ast::ExprKind::Ret(..) |\n             ast::ExprKind::Break(..) => true,\n \n             _ => parser::contains_exterior_struct_lit(expr),\n-        };\n+        }\n+    }\n \n+    /// Print `expr` or `(expr)` when `needs_par` holds.\n+    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) -> io::Result<()> {\n         if needs_par {\n             self.popen()?;\n         }\n@@ -1962,6 +1954,17 @@ impl<'a> State<'a> {\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n             (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt) |\n             (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Shl) => parser::PREC_FORCE_PAREN,\n+            // We are given `(let _ = a) OP b`.\n+            //\n+            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n+            //   as the parser will interpret this as `(let _ = a) OP b`.\n+            //\n+            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n+            //   parens are required since the parser would interpret `let a = b < c` as\n+            //   `let a = (b < c)`. To achieve this, we force parens.\n+            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n             _ => left_prec,\n         };\n \n@@ -2052,12 +2055,12 @@ impl<'a> State<'a> {\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n             }\n+            ast::ExprKind::Let(ref pats, ref scrutinee) => {\n+                self.print_let(pats, scrutinee)?;\n+            }\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(test, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            ast::ExprKind::IfLet(ref pats, ref expr, ref blk, ref elseopt) => {\n-                self.print_if_let(pats, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n-            }\n             ast::ExprKind::While(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n@@ -2068,19 +2071,6 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::WhileLet(ref pats, ref expr, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident)?;\n-                    self.word_space(\":\")?;\n-                }\n-                self.head(\"while let\")?;\n-                self.print_pats(pats)?;\n-                self.s.space()?;\n-                self.word_space(\"=\")?;\n-                self.print_expr_as_cond(expr)?;\n-                self.s.space()?;\n-                self.print_block_with_attrs(blk, attrs)?;\n-            }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;"}, {"sha": "1e52186a106c12f80753be3b183139b4bc78dbb7", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -260,6 +260,7 @@ pub enum ExprPrecedence {\n \n     Box,\n     AddrOf,\n+    Let,\n     Unary,\n \n     Call,\n@@ -277,9 +278,7 @@ pub enum ExprPrecedence {\n     Path,\n     Paren,\n     If,\n-    IfLet,\n     While,\n-    WhileLet,\n     ForLoop,\n     Loop,\n     Match,\n@@ -318,6 +317,11 @@ impl ExprPrecedence {\n             // Unary, prefix\n             ExprPrecedence::Box |\n             ExprPrecedence::AddrOf |\n+            // Here `let pats = expr` has `let pats =` as a \"unary\" prefix of `expr`.\n+            // However, this is not exactly right. When `let _ = a` is the LHS of a binop we\n+            // need parens sometimes. E.g. we can print `(let _ = a) && b` as `let _ = a && b`\n+            // but we need to print `(let _ = a) < b` as-is with parens.\n+            ExprPrecedence::Let |\n             ExprPrecedence::Unary => PREC_PREFIX,\n \n             // Unary, postfix\n@@ -338,9 +342,7 @@ impl ExprPrecedence {\n             ExprPrecedence::Path |\n             ExprPrecedence::Paren |\n             ExprPrecedence::If |\n-            ExprPrecedence::IfLet |\n             ExprPrecedence::While |\n-            ExprPrecedence::WhileLet |\n             ExprPrecedence::ForLoop |\n             ExprPrecedence::Loop |\n             ExprPrecedence::Match |\n@@ -353,6 +355,19 @@ impl ExprPrecedence {\n     }\n }\n \n+/// In `let p = e`, operators with precedence `<=` this one requires parenthesis in `e`.\n+crate fn prec_let_scrutinee_needs_par() -> usize {\n+    AssocOp::LAnd.precedence()\n+}\n+\n+/// Suppose we have `let _ = e` and the `order` of `e`.\n+/// Is the `order` such that `e` in `let _ = e` needs parenthesis when it is on the RHS?\n+///\n+/// Conversely, suppose that we have `(let _ = a) OP b` and `order` is that of `OP`.\n+/// Can we print this as `let _ = a OP b`?\n+crate fn needs_par_as_let_scrutinee(order: i8) -> bool {\n+    order <= prec_let_scrutinee_needs_par() as i8\n+}\n \n /// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and"}, {"sha": "4d961142ff1c75f1d0f0b3ff4777e92566700cac", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -719,6 +719,10 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n+        ExprKind::Let(ref pats, ref scrutinee) => {\n+            walk_list!(visitor, visit_pat, pats);\n+            visitor.visit_expr(scrutinee);\n+        }\n         ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_block(if_block);\n@@ -729,18 +733,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::IfLet(ref pats, ref subexpression, ref if_block, ref optional_else) => {\n-            walk_list!(visitor, visit_pat, pats);\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_block(if_block);\n-            walk_list!(visitor, visit_expr, optional_else);\n-        }\n-        ExprKind::WhileLet(ref pats, ref subexpression, ref block, ref opt_label) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            walk_list!(visitor, visit_pat, pats);\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_block(block);\n-        }\n         ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);"}, {"sha": "756bc8c29d8287b739ffe87528a64970f434ffd4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -354,6 +354,7 @@ symbols! {\n         label_break_value,\n         lang,\n         lang_items,\n+        let_chains,\n         lhs,\n         lib,\n         lifetime,"}, {"sha": "5716e6d45a0b613652ab0d025d2139df625c7636", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -68,7 +68,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n \n     let mut g = |e| f(expr(e));\n \n-    for kind in 0 .. 16 {\n+    for kind in 0..=19 {\n         match kind {\n             0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n             1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n@@ -79,25 +79,26 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n                             seg.clone(), vec![make_x(), e])));\n             },\n-            3 => {\n-                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Add };\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n-            },\n-            4 => {\n-                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Mul };\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n-            },\n-            5 => {\n-                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Shl };\n+            3..=8 => {\n+                let op = Spanned {\n+                    span: DUMMY_SP,\n+                    node: match kind {\n+                        3 => BinOpKind::Add,\n+                        4 => BinOpKind::Mul,\n+                        5 => BinOpKind::Shl,\n+                        6 => BinOpKind::And,\n+                        7 => BinOpKind::Or,\n+                        8 => BinOpKind::Lt,\n+                        _ => unreachable!(),\n+                    }\n+                };\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n             },\n-            6 => {\n+            9 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Unary(UnOp::Deref, e)));\n             },\n-            7 => {\n+            10 => {\n                 let block = P(Block {\n                     stmts: Vec::new(),\n                     id: DUMMY_NODE_ID,\n@@ -106,7 +107,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::If(e, block.clone(), None)));\n             },\n-            8 => {\n+            11 => {\n                 let decl = P(FnDecl {\n                     inputs: vec![],\n                     output: FunctionRetTy::Default(DUMMY_SP),\n@@ -120,33 +121,41 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                                           e,\n                                           DUMMY_SP)));\n             },\n-            9 => {\n+            12 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x())));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e)));\n             },\n-            10 => {\n+            13 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, Ident::from_str(\"f\"))));\n             },\n-            11 => {\n+            14 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n                             Some(e), Some(make_x()), RangeLimits::HalfOpen)));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n                             Some(make_x()), Some(e), RangeLimits::HalfOpen)));\n             },\n-            12 => {\n+            15 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::AddrOf(Mutability::Immutable, e)));\n             },\n-            13 => {\n+            16 => {\n                 g(ExprKind::Ret(None));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n             },\n-            14 => {\n+            17 => {\n                 let path = Path::from_ident(Ident::from_str(\"S\"));\n                 g(ExprKind::Struct(path, vec![], Some(make_x())));\n             },\n-            15 => {\n+            18 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));\n             },\n+            19 => {\n+                let ps = vec![P(Pat {\n+                    id: DUMMY_NODE_ID,\n+                    node: PatKind::Wild,\n+                    span: DUMMY_SP,\n+                })];\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(ps.clone(), e)))\n+            },\n             _ => panic!(\"bad counter value in iter_exprs\"),\n         }\n     }"}, {"sha": "c36101043a7f711b2bee404aace082a7753bd45a", "filename": "src/test/ui/lint/lint-unnecessary-parens.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -22,8 +22,8 @@ fn main() {\n     match (true) { //~ ERROR unnecessary parentheses around `match` head expression\n         _ => {}\n     }\n-    if let 1 = (1) {} //~ ERROR unnecessary parentheses around `if let` head expression\n-    while let 1 = (2) {} //~ ERROR unnecessary parentheses around `while let` head expression\n+    if let 1 = (1) {} //~ ERROR unnecessary parentheses around `let` head expression\n+    while let 1 = (2) {} //~ ERROR unnecessary parentheses around `let` head expression\n     let v = X { y: false };\n     // struct lits needs parens, so these shouldn't warn.\n     if (v == X { y: true }) {}"}, {"sha": "dfbefd7b03ee5338d6e76a265a5f95400ee0c27d", "filename": "src/test/ui/lint/lint-unnecessary-parens.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -40,13 +40,13 @@ error: unnecessary parentheses around `match` head expression\n LL |     match (true) {\n    |           ^^^^^^ help: remove these parentheses\n \n-error: unnecessary parentheses around `if let` head expression\n+error: unnecessary parentheses around `let` head expression\n   --> $DIR/lint-unnecessary-parens.rs:25:16\n    |\n LL |     if let 1 = (1) {}\n    |                ^^^ help: remove these parentheses\n \n-error: unnecessary parentheses around `while let` head expression\n+error: unnecessary parentheses around `let` head expression\n   --> $DIR/lint-unnecessary-parens.rs:26:19\n    |\n LL |     while let 1 = (2) {}"}, {"sha": "e66d46575664f5dc25dcf935d84cb5cdd8589a6c", "filename": "src/test/ui/rfc-2497-if-let-chains/ast-pretty-check.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -0,0 +1,6 @@\n+// compile-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+fn main() {\n+    if let 0 = 1 {}\n+}"}, {"sha": "a6b15f9bbf65d94d34bfd5434aed2531ed5133f8", "filename": "src/test/ui/rfc-2497-if-let-chains/ast-pretty-check.stdout", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.stdout?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -0,0 +1,10 @@\n+#![feature(prelude_import)]\n+#![no_std]\n+#[prelude_import]\n+use ::std::prelude::v1::*;\n+#[macro_use]\n+extern crate std;\n+// compile-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+fn main() { if let 0 = 1 { } }"}, {"sha": "7d1e5c3d64df3f3989051e920a8b9fab658b85bb", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -0,0 +1,244 @@\n+// Here we test that `lowering` behaves correctly wrt. `let $pats = $expr` expressions.\n+//\n+// We want to make sure that `let` is banned in situations other than:\n+//\n+// expr =\n+//   | ...\n+//   | \"if\" expr_with_let block {\"else\" block}?\n+//   | {label \":\"}? while\" expr_with_let block\n+//   ;\n+//\n+// expr_with_let =\n+//   | \"let\" top_pats \"=\" expr\n+//   | expr_with_let \"&&\" expr_with_let\n+//   | \"(\" expr_with_let \")\"\n+//   | expr\n+//   ;\n+//\n+// To that end, we check some positions which is not part of the language above.\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete\n+#![feature(let_chains)] // Avoid inflating `.stderr` with overzealous gates in this test.\n+//~^ WARN the feature `let_chains` is incomplete\n+\n+#![allow(irrefutable_let_patterns)]\n+\n+use std::ops::Range;\n+\n+fn main() {}\n+\n+fn nested_within_if_expr() {\n+    if &let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+\n+    if !let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    if *let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR type `bool` cannot be dereferenced\n+    if -let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR cannot apply unary operator `-` to type `bool`\n+\n+    fn _check_try_binds_tighter() -> Result<(), ()> {\n+        if let 0 = 0? {}\n+        //~^ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+        Ok(())\n+    }\n+    if (let 0 = 0)? {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    //~| ERROR the `?` operator can only be used in a function that returns `Result`\n+\n+    if true || let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    if (true || let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    if true && (true || let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    if true || (true && let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+\n+    let mut x = true;\n+    if x = let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+\n+    if true..(let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+    if ..(let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+    if (let 0 = 0).. {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+\n+    // Binds as `(let ... = true)..true &&/|| false`.\n+    if let Range { start: _, end: _ } = true..true && false {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    if let Range { start: _, end: _ } = true..true || false {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    // Binds as `(let Range { start: F, end } = F)..(|| true)`.\n+    const F: fn() -> bool = || true;\n+    if let Range { start: F, end } = F..|| true {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    // Binds as `(let Range { start: true, end } = t)..(&&false)`.\n+    let t = &&true;\n+    if let Range { start: true, end } = t..&&false {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    if let true = let true = true {} //~ ERROR `let` expressions are not supported here\n+}\n+\n+fn nested_within_while_expr() {\n+    while &let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+\n+    while !let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    while *let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR type `bool` cannot be dereferenced\n+    while -let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR cannot apply unary operator `-` to type `bool`\n+\n+    fn _check_try_binds_tighter() -> Result<(), ()> {\n+        while let 0 = 0? {}\n+        //~^ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+        Ok(())\n+    }\n+    while (let 0 = 0)? {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    //~| ERROR the `?` operator can only be used in a function that returns `Result`\n+\n+    while true || let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    while (true || let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    while true && (true || let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    while true || (true && let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+\n+    let mut x = true;\n+    while x = let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+\n+    while true..(let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+    while ..(let 0 = 0) {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+    while (let 0 = 0).. {} //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR mismatched types\n+\n+    // Binds as `(let ... = true)..true &&/|| false`.\n+    while let Range { start: _, end: _ } = true..true && false {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    while let Range { start: _, end: _ } = true..true || false {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    // Binds as `(let Range { start: F, end } = F)..(|| true)`.\n+    const F: fn() -> bool = || true;\n+    while let Range { start: F, end } = F..|| true {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    // Binds as `(let Range { start: true, end } = t)..(&&false)`.\n+    let t = &&true;\n+    while let Range { start: true, end } = t..&&false {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    while let true = let true = true {} //~ ERROR `let` expressions are not supported here\n+}\n+\n+fn not_error_because_clarified_intent() {\n+    if let Range { start: _, end: _ } = (true..true || false) { }\n+\n+    if let Range { start: _, end: _ } = (true..true && false) { }\n+\n+    while let Range { start: _, end: _ } = (true..true || false) { }\n+\n+    while let Range { start: _, end: _ } = (true..true && false) { }\n+}\n+\n+fn outside_if_and_while_expr() {\n+    &let 0 = 0; //~ ERROR `let` expressions are not supported here\n+\n+    !let 0 = 0; //~ ERROR `let` expressions are not supported here\n+    *let 0 = 0; //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR type `bool` cannot be dereferenced\n+    -let 0 = 0; //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR cannot apply unary operator `-` to type `bool`\n+\n+    fn _check_try_binds_tighter() -> Result<(), ()> {\n+        let 0 = 0?;\n+        //~^ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+        Ok(())\n+    }\n+    (let 0 = 0)?; //~ ERROR `let` expressions are not supported here\n+    //~^ ERROR the `?` operator can only be used in a function that returns `Result`\n+    //~| ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+\n+    true || let 0 = 0; //~ ERROR `let` expressions are not supported here\n+    (true || let 0 = 0); //~ ERROR `let` expressions are not supported here\n+    true && (true || let 0 = 0); //~ ERROR `let` expressions are not supported here\n+\n+    let mut x = true;\n+    x = let 0 = 0; //~ ERROR `let` expressions are not supported here\n+\n+    true..(let 0 = 0); //~ ERROR `let` expressions are not supported here\n+    ..(let 0 = 0); //~ ERROR `let` expressions are not supported here\n+    (let 0 = 0)..; //~ ERROR `let` expressions are not supported here\n+\n+    (let Range { start: _, end: _ } = true..true || false);\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+\n+    (let true = let true = true);\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+\n+    // Check function tail position.\n+    &let 0 = 0\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+}\n+\n+// Let's make sure that `let` inside const generic arguments are considered.\n+fn inside_const_generic_arguments() {\n+    struct A<const B: bool>;\n+    impl<const B: bool> A<{B}> { const O: u32 = 5; }\n+\n+    if let A::<{\n+        true && let 1 = 1 //~ ERROR `let` expressions are not supported here\n+        //~^ ERROR constant contains unimplemented expression type\n+        //~| ERROR constant contains unimplemented expression type\n+    }>::O = 5 {}\n+\n+    while let A::<{\n+        true && let 1 = 1 //~ ERROR `let` expressions are not supported here\n+        //~^ ERROR constant contains unimplemented expression type\n+        //~| ERROR constant contains unimplemented expression type\n+    }>::O = 5 {}\n+\n+    if A::<{\n+        true && let 1 = 1 //~ ERROR `let` expressions are not supported here\n+        //~^ ERROR constant contains unimplemented expression type\n+        //~| ERROR constant contains unimplemented expression type\n+    }>::O == 5 {}\n+\n+    // In the cases above we have `ExprKind::Block` to help us out.\n+    // Below however, we would not have a block and so an implementation might go\n+    // from visiting expressions to types without banning `let` expressions down the tree.\n+    // This tests ensures that we are not caught by surprise should the parser\n+    // admit non-IDENT expressions in const generic arguments.\n+\n+    if A::<\n+        true && let 1 = 1 //~ ERROR expected one of `,` or `>`, found `&&`\n+    >::O == 5 {}\n+}"}, {"sha": "207d0d6d6b84a431bf4b5eb1e674f041c8f7b329", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "added", "additions": 987, "deletions": 0, "changes": 987, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -0,0 +1,987 @@\n+error: expected one of `,` or `>`, found `&&`\n+  --> $DIR/disallowed-positions.rs:242:14\n+   |\n+LL |         true && let 1 = 1\n+   |              ^^ expected one of `,` or `>` here\n+\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/disallowed-positions.rs:20:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+warning: the feature `let_chains` is incomplete and may cause the compiler to crash\n+  --> $DIR/disallowed-positions.rs:22:12\n+   |\n+LL | #![feature(let_chains)] // Avoid inflating `.stderr` with overzealous gates in this test.\n+   |            ^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:32:9\n+   |\n+LL |     if &let 0 = 0 {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:35:9\n+   |\n+LL |     if !let 0 = 0 {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:36:9\n+   |\n+LL |     if *let 0 = 0 {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:38:9\n+   |\n+LL |     if -let 0 = 0 {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:46:9\n+   |\n+LL |     if (let 0 = 0)? {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:50:16\n+   |\n+LL |     if true || let 0 = 0 {}\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:51:17\n+   |\n+LL |     if (true || let 0 = 0) {}\n+   |                 ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:52:25\n+   |\n+LL |     if true && (true || let 0 = 0) {}\n+   |                         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:53:25\n+   |\n+LL |     if true || (true && let 0 = 0) {}\n+   |                         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:56:12\n+   |\n+LL |     if x = let 0 = 0 {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:59:15\n+   |\n+LL |     if true..(let 0 = 0) {}\n+   |               ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:61:11\n+   |\n+LL |     if ..(let 0 = 0) {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:63:9\n+   |\n+LL |     if (let 0 = 0).. {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:67:8\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true && false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:71:8\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true || false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:78:8\n+   |\n+LL |     if let Range { start: F, end } = F..|| true {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:86:8\n+   |\n+LL |     if let Range { start: true, end } = t..&&false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:92:19\n+   |\n+LL |     if let true = let true = true {}\n+   |                   ^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:96:12\n+   |\n+LL |     while &let 0 = 0 {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:99:12\n+   |\n+LL |     while !let 0 = 0 {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:100:12\n+   |\n+LL |     while *let 0 = 0 {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:102:12\n+   |\n+LL |     while -let 0 = 0 {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:110:12\n+   |\n+LL |     while (let 0 = 0)? {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:114:19\n+   |\n+LL |     while true || let 0 = 0 {}\n+   |                   ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:115:20\n+   |\n+LL |     while (true || let 0 = 0) {}\n+   |                    ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:116:28\n+   |\n+LL |     while true && (true || let 0 = 0) {}\n+   |                            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:117:28\n+   |\n+LL |     while true || (true && let 0 = 0) {}\n+   |                            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:120:15\n+   |\n+LL |     while x = let 0 = 0 {}\n+   |               ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:123:18\n+   |\n+LL |     while true..(let 0 = 0) {}\n+   |                  ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:125:14\n+   |\n+LL |     while ..(let 0 = 0) {}\n+   |              ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:127:12\n+   |\n+LL |     while (let 0 = 0).. {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:131:11\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true && false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:135:11\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true || false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:142:11\n+   |\n+LL |     while let Range { start: F, end } = F..|| true {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:150:11\n+   |\n+LL |     while let Range { start: true, end } = t..&&false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:156:22\n+   |\n+LL |     while let true = let true = true {}\n+   |                      ^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:170:6\n+   |\n+LL |     &let 0 = 0;\n+   |      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:172:6\n+   |\n+LL |     !let 0 = 0;\n+   |      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:173:6\n+   |\n+LL |     *let 0 = 0;\n+   |      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:175:6\n+   |\n+LL |     -let 0 = 0;\n+   |      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:183:6\n+   |\n+LL |     (let 0 = 0)?;\n+   |      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:187:13\n+   |\n+LL |     true || let 0 = 0;\n+   |             ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:188:14\n+   |\n+LL |     (true || let 0 = 0);\n+   |              ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:189:22\n+   |\n+LL |     true && (true || let 0 = 0);\n+   |                      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:192:9\n+   |\n+LL |     x = let 0 = 0;\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:194:12\n+   |\n+LL |     true..(let 0 = 0);\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:195:8\n+   |\n+LL |     ..(let 0 = 0);\n+   |        ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:196:6\n+   |\n+LL |     (let 0 = 0)..;\n+   |      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:198:6\n+   |\n+LL |     (let Range { start: _, end: _ } = true..true || false);\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:202:6\n+   |\n+LL |     (let true = let true = true);\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:202:17\n+   |\n+LL |     (let true = let true = true);\n+   |                 ^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:207:6\n+   |\n+LL |     &let 0 = 0\n+   |      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:218:17\n+   |\n+LL |         true && let 1 = 1\n+   |                 ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:224:17\n+   |\n+LL |         true && let 1 = 1\n+   |                 ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:230:17\n+   |\n+LL |         true && let 1 = 1\n+   |                 ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:32:8\n+   |\n+LL |     if &let 0 = 0 {}\n+   |        ^^^^^^^^^^ expected bool, found &bool\n+   |\n+   = note: expected type `bool`\n+              found type `&bool`\n+\n+error[E0614]: type `bool` cannot be dereferenced\n+  --> $DIR/disallowed-positions.rs:36:8\n+   |\n+LL |     if *let 0 = 0 {}\n+   |        ^^^^^^^^^^\n+\n+error[E0600]: cannot apply unary operator `-` to type `bool`\n+  --> $DIR/disallowed-positions.rs:38:8\n+   |\n+LL |     if -let 0 = 0 {}\n+   |        ^^^^^^^^^^ cannot apply unary operator `-`\n+   |\n+   = note: an implementation of `std::ops::Neg` might be missing for `bool`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/disallowed-positions.rs:46:8\n+   |\n+LL |     if (let 0 = 0)? {}\n+   |        ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `bool`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/disallowed-positions.rs:46:8\n+   |\n+LL |     if (let 0 = 0)? {}\n+   |        ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `()`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:56:8\n+   |\n+LL |     if x = let 0 = 0 {}\n+   |        ^^^^^^^^^^^^^\n+   |        |\n+   |        expected bool, found ()\n+   |        help: try comparing for equality: `x == let 0 = 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:59:8\n+   |\n+LL |     if true..(let 0 = 0) {}\n+   |        ^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:61:8\n+   |\n+LL |     if ..(let 0 = 0) {}\n+   |        ^^^^^^^^^^^^^ expected bool, found struct `std::ops::RangeTo`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::RangeTo<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:63:8\n+   |\n+LL |     if (let 0 = 0).. {}\n+   |        ^^^^^^^^^^^^^ expected bool, found struct `std::ops::RangeFrom`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::RangeFrom<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:67:12\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true && false {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |            |\n+   |            expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:67:8\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true && false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:71:12\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true || false {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |            |\n+   |            expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:71:8\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true || false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:78:12\n+   |\n+LL |     if let Range { start: F, end } = F..|| true {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^ expected fn pointer, found struct `std::ops::Range`\n+   |\n+   = note: expected type `fn() -> bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:78:41\n+   |\n+LL |     if let Range { start: F, end } = F..|| true {}\n+   |                                         ^^^^^^^ expected bool, found closure\n+   |\n+   = note: expected type `bool`\n+              found type `[closure@$DIR/disallowed-positions.rs:78:41: 78:48]`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:78:8\n+   |\n+LL |     if let Range { start: F, end } = F..|| true {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:86:12\n+   |\n+LL |     if let Range { start: true, end } = t..&&false {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this match expression has type `bool`\n+   |            |\n+   |            expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:86:44\n+   |\n+LL |     if let Range { start: true, end } = t..&&false {}\n+   |                                            ^^^^^^^ expected bool, found &&bool\n+   |\n+   = note: expected type `bool`\n+              found type `&&bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:86:8\n+   |\n+LL |     if let Range { start: true, end } = t..&&false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/disallowed-positions.rs:42:20\n+   |\n+LL |         if let 0 = 0? {}\n+   |                    ^^ the `?` operator cannot be applied to type `{integer}`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `{integer}`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:96:11\n+   |\n+LL |     while &let 0 = 0 {}\n+   |           ^^^^^^^^^^ expected bool, found &bool\n+   |\n+   = note: expected type `bool`\n+              found type `&bool`\n+\n+error[E0614]: type `bool` cannot be dereferenced\n+  --> $DIR/disallowed-positions.rs:100:11\n+   |\n+LL |     while *let 0 = 0 {}\n+   |           ^^^^^^^^^^\n+\n+error[E0600]: cannot apply unary operator `-` to type `bool`\n+  --> $DIR/disallowed-positions.rs:102:11\n+   |\n+LL |     while -let 0 = 0 {}\n+   |           ^^^^^^^^^^ cannot apply unary operator `-`\n+   |\n+   = note: an implementation of `std::ops::Neg` might be missing for `bool`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/disallowed-positions.rs:110:11\n+   |\n+LL |     while (let 0 = 0)? {}\n+   |           ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `bool`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/disallowed-positions.rs:110:11\n+   |\n+LL |     while (let 0 = 0)? {}\n+   |           ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `()`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:120:11\n+   |\n+LL |     while x = let 0 = 0 {}\n+   |           ^^^^^^^^^^^^^\n+   |           |\n+   |           expected bool, found ()\n+   |           help: try comparing for equality: `x == let 0 = 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:123:11\n+   |\n+LL |     while true..(let 0 = 0) {}\n+   |           ^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:125:11\n+   |\n+LL |     while ..(let 0 = 0) {}\n+   |           ^^^^^^^^^^^^^ expected bool, found struct `std::ops::RangeTo`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::RangeTo<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:127:11\n+   |\n+LL |     while (let 0 = 0).. {}\n+   |           ^^^^^^^^^^^^^ expected bool, found struct `std::ops::RangeFrom`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::RangeFrom<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:131:15\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true && false {}\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |               |\n+   |               expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:131:11\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true && false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:135:15\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true || false {}\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |               |\n+   |               expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:135:11\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true || false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:142:15\n+   |\n+LL |     while let Range { start: F, end } = F..|| true {}\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^ expected fn pointer, found struct `std::ops::Range`\n+   |\n+   = note: expected type `fn() -> bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:142:44\n+   |\n+LL |     while let Range { start: F, end } = F..|| true {}\n+   |                                            ^^^^^^^ expected bool, found closure\n+   |\n+   = note: expected type `bool`\n+              found type `[closure@$DIR/disallowed-positions.rs:142:44: 142:51]`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:142:11\n+   |\n+LL |     while let Range { start: F, end } = F..|| true {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:150:15\n+   |\n+LL |     while let Range { start: true, end } = t..&&false {}\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this match expression has type `bool`\n+   |               |\n+   |               expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:150:47\n+   |\n+LL |     while let Range { start: true, end } = t..&&false {}\n+   |                                               ^^^^^^^ expected bool, found &&bool\n+   |\n+   = note: expected type `bool`\n+              found type `&&bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:150:11\n+   |\n+LL |     while let Range { start: true, end } = t..&&false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<bool>`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/disallowed-positions.rs:106:23\n+   |\n+LL |         while let 0 = 0? {}\n+   |                       ^^ the `?` operator cannot be applied to type `{integer}`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `{integer}`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0614]: type `bool` cannot be dereferenced\n+  --> $DIR/disallowed-positions.rs:173:5\n+   |\n+LL |     *let 0 = 0;\n+   |     ^^^^^^^^^^\n+\n+error[E0600]: cannot apply unary operator `-` to type `bool`\n+  --> $DIR/disallowed-positions.rs:175:5\n+   |\n+LL |     -let 0 = 0;\n+   |     ^^^^^^^^^^ cannot apply unary operator `-`\n+   |\n+   = note: an implementation of `std::ops::Neg` might be missing for `bool`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/disallowed-positions.rs:183:5\n+   |\n+LL |     (let 0 = 0)?;\n+   |     ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `bool`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/disallowed-positions.rs:183:5\n+   |\n+LL |     (let 0 = 0)?;\n+   |     ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `()`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:198:10\n+   |\n+LL |     (let Range { start: _, end: _ } = true..true || false);\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |          |\n+   |          expected bool, found struct `std::ops::Range`\n+   |\n+   = note: expected type `bool`\n+              found type `std::ops::Range<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/disallowed-positions.rs:207:5\n+   |\n+LL | fn outside_if_and_while_expr() {\n+   |                                - help: try adding a return type: `-> &bool`\n+...\n+LL |     &let 0 = 0\n+   |     ^^^^^^^^^^ expected (), found &bool\n+   |\n+   = note: expected type `()`\n+              found type `&bool`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/disallowed-positions.rs:179:17\n+   |\n+LL |         let 0 = 0?;\n+   |                 ^^ the `?` operator cannot be applied to type `{integer}`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `{integer}`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/disallowed-positions.rs:218:25\n+   |\n+LL |         true && let 1 = 1\n+   |                         ^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/disallowed-positions.rs:218:21\n+   |\n+LL |         true && let 1 = 1\n+   |                     ^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/disallowed-positions.rs:224:25\n+   |\n+LL |         true && let 1 = 1\n+   |                         ^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/disallowed-positions.rs:224:21\n+   |\n+LL |         true && let 1 = 1\n+   |                     ^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/disallowed-positions.rs:230:25\n+   |\n+LL |         true && let 1 = 1\n+   |                         ^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/disallowed-positions.rs:230:21\n+   |\n+LL |         true && let 1 = 1\n+   |                     ^\n+\n+error: aborting due to 109 previous errors\n+\n+Some errors have detailed explanations: E0019, E0277, E0308, E0600, E0614.\n+For more information about an error, try `rustc --explain E0019`."}, {"sha": "64987663adb90bb3a7d520e82267520d59d18a6f", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -0,0 +1,136 @@\n+// gate-test-let_chains\n+\n+// Here we test feature gating for \u00b4let_chains`.\n+// See `disallowed-positions.rs` for the grammar\n+// defining the language for gated allowed positions.\n+\n+#![allow(irrefutable_let_patterns)]\n+\n+use std::ops::Range;\n+\n+fn _if() {\n+    if let 0 = 1 {} // Stable!\n+\n+    if (let 0 = 1) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if (((let 0 = 1))) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if true && let 0 = 1 {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if let 0 = 1 && true {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if (let 0 = 1) && true {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if true && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if (let 0 = 1) && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if let Range { start: _, end: _ } = (true..true) && false {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+}\n+\n+fn _while() {\n+    while let 0 = 1 {} // Stable!\n+\n+    while (let 0 = 1) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while (((let 0 = 1))) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while true && let 0 = 1 {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while let 0 = 1 && true {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while (let 0 = 1) && true {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while true && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while (let 0 = 1) && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while let Range { start: _, end: _ } = (true..true) && false {}\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+}\n+\n+fn _macros() {\n+    macro_rules! noop_expr { ($e:expr) => {}; }\n+\n+    noop_expr!((let 0 = 1));\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+\n+    macro_rules! use_expr {\n+        ($e:expr) => {\n+            if $e {}\n+            while $e {}\n+        }\n+    }\n+    use_expr!((let 0 = 1 && 0 == 0));\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+    use_expr!((let 0 = 1));\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~| ERROR `let` expressions are not supported here\n+    #[cfg(FALSE)] (let 0 = 1);\n+    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    use_expr!(let 0 = 1);\n+    //~^ ERROR no rules expected the token `let`\n+    // ^--- FIXME(53667): Consider whether `Let` can be added to `ident_can_begin_expr`.\n+}\n+\n+fn main() {}"}, {"sha": "6167427fa9fdc8268c0d71bcaf31b5757f315470", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.stderr", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -0,0 +1,570 @@\n+error: no rules expected the token `let`\n+  --> $DIR/feature-gate.rs:131:15\n+   |\n+LL |     macro_rules! use_expr {\n+   |     --------------------- when calling this macro\n+...\n+LL |     use_expr!(let 0 = 1);\n+   |               ^^^ no rules expected this token in macro call\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:14:9\n+   |\n+LL |     if (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:18:11\n+   |\n+LL |     if (((let 0 = 1))) {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:22:16\n+   |\n+LL |     if true && let 0 = 1 {}\n+   |                ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:26:8\n+   |\n+LL |     if let 0 = 1 && true {}\n+   |        ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:30:9\n+   |\n+LL |     if (let 0 = 1) && true {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:34:17\n+   |\n+LL |     if true && (let 0 = 1) {}\n+   |                 ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:38:9\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:38:24\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |                        ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:44:8\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |        ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:44:21\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                     ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:44:35\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                   ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:44:48\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:44:61\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                             ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:56:8\n+   |\n+LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:64:12\n+   |\n+LL |     while (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:68:14\n+   |\n+LL |     while (((let 0 = 1))) {}\n+   |              ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:72:19\n+   |\n+LL |     while true && let 0 = 1 {}\n+   |                   ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:76:11\n+   |\n+LL |     while let 0 = 1 && true {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:80:12\n+   |\n+LL |     while (let 0 = 1) && true {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:84:20\n+   |\n+LL |     while true && (let 0 = 1) {}\n+   |                    ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:88:12\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:88:27\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |                           ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:94:11\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:94:24\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                        ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:94:38\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                      ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:94:51\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                   ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:94:64\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                                ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:106:11\n+   |\n+LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:129:20\n+   |\n+LL |     #[cfg(FALSE)] (let 0 = 1);\n+   |                    ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:114:17\n+   |\n+LL |     noop_expr!((let 0 = 1));\n+   |                 ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:123:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error[E0658]: `let` expressions in this position are experimental\n+  --> $DIR/feature-gate.rs:126:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53667\n+   = help: add #![feature(let_chains)] to the crate attributes to enable\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:14:9\n+   |\n+LL |     if (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:18:11\n+   |\n+LL |     if (((let 0 = 1))) {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:22:16\n+   |\n+LL |     if true && let 0 = 1 {}\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:26:8\n+   |\n+LL |     if let 0 = 1 && true {}\n+   |        ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:30:9\n+   |\n+LL |     if (let 0 = 1) && true {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:34:17\n+   |\n+LL |     if true && (let 0 = 1) {}\n+   |                 ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:38:9\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:38:24\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |                        ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:44:8\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |        ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:44:21\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                     ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:44:35\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                   ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:44:48\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:44:61\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                             ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:56:8\n+   |\n+LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:64:12\n+   |\n+LL |     while (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:68:14\n+   |\n+LL |     while (((let 0 = 1))) {}\n+   |              ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:72:19\n+   |\n+LL |     while true && let 0 = 1 {}\n+   |                   ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:76:11\n+   |\n+LL |     while let 0 = 1 && true {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:80:12\n+   |\n+LL |     while (let 0 = 1) && true {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:84:20\n+   |\n+LL |     while true && (let 0 = 1) {}\n+   |                    ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:88:12\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:88:27\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |                           ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:94:11\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:94:24\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                        ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:94:38\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:94:51\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                   ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:94:64\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:106:11\n+   |\n+LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:123:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:126:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+error: aborting due to 63 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1de4e5bcebee9be423bbf5fdbdae1de67ac7b5fc", "filename": "src/test/ui/rfc-2497-if-let-chains/protect-precedences.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d677b2efdb00031564d30ee9f63f4d4f936a39f/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.rs?ref=5d677b2efdb00031564d30ee9f63f4d4f936a39f", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+\n+#![allow(irrefutable_let_patterns)]\n+\n+use std::ops::Range;\n+\n+fn main() {\n+    let x: bool;\n+    // This should associate as: `(x = (true && false));`.\n+    x = true && false;\n+    assert!(!x);\n+\n+    fn _f1() -> bool {\n+        // Should associate as `(let _ = (return (true && false)))`.\n+        if let _ = return true && false {};\n+    }\n+    assert!(!_f1());\n+}"}, {"sha": "d79798d57e820622787d44647a523bf8b90e35fd", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2015.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs?ref=a96ba969156d257e5d5b692946fa8fe40ed6543a", "patch": "@@ -1,38 +0,0 @@\n-// edition:2015\n-\n-// Enabling `ireffutable_let_patterns` isn't necessary for what this tests, but it makes coming up\n-// with examples easier.\n-\n-#[allow(irrefutable_let_patterns)]\n-fn main() {\n-    use std::ops::Range;\n-\n-    if let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    if let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambiguous use of `||`\n-\n-    while let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    while let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambiguous use of `||`\n-\n-    if let true = false && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    while let true = (1 == 2) && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    // The following cases are not an error as parenthesis are used to\n-    // clarify intent:\n-\n-    if let Range { start: _, end: _ } = true..(true || false) { }\n-\n-    if let Range { start: _, end: _ } = true..(true && false) { }\n-\n-    while let Range { start: _, end: _ } = true..(true || false) { }\n-\n-    while let Range { start: _, end: _ } = true..(true && false) { }\n-}"}, {"sha": "2cd59fe56cf2d111a346af2c792663d6bab6d3df", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2015.stderr", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr?ref=a96ba969156d257e5d5b692946fa8fe40ed6543a", "patch": "@@ -1,56 +0,0 @@\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2015.rs:10:47\n-   |\n-LL |     if let Range { start: _, end: _ } = true..true && false { }\n-   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `||`\n-  --> $DIR/syntax-ambiguity-2015.rs:13:47\n-   |\n-LL |     if let Range { start: _, end: _ } = true..true || false { }\n-   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2015.rs:16:50\n-   |\n-LL |     while let Range { start: _, end: _ } = true..true && false { }\n-   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `||`\n-  --> $DIR/syntax-ambiguity-2015.rs:19:50\n-   |\n-LL |     while let Range { start: _, end: _ } = true..true || false { }\n-   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2015.rs:22:19\n-   |\n-LL |     if let true = false && false { }\n-   |                   ^^^^^^^^^^^^^^ help: consider adding parentheses: `(false && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2015.rs:25:22\n-   |\n-LL |     while let true = (1 == 2) && false { }\n-   |                      ^^^^^^^^^^^^^^^^^ help: consider adding parentheses: `((1 == 2) && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: aborting due to 6 previous errors\n-"}, {"sha": "687bf659416ab27a2172be16cbc15f365d7a7d6b", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2018.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs?ref=a96ba969156d257e5d5b692946fa8fe40ed6543a", "patch": "@@ -1,38 +0,0 @@\n-// edition:2018\n-\n-// Enabling `ireffutable_let_patterns` isn't necessary for what this tests, but it makes coming up\n-// with examples easier.\n-\n-#[allow(irrefutable_let_patterns)]\n-fn main() {\n-    use std::ops::Range;\n-\n-    if let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    if let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambiguous use of `||`\n-\n-    while let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    while let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambiguous use of `||`\n-\n-    if let true = false && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    while let true = (1 == 2) && false { }\n-    //~^ ERROR ambiguous use of `&&`\n-\n-    // The following cases are not an error as parenthesis are used to\n-    // clarify intent:\n-\n-    if let Range { start: _, end: _ } = true..(true || false) { }\n-\n-    if let Range { start: _, end: _ } = true..(true && false) { }\n-\n-    while let Range { start: _, end: _ } = true..(true || false) { }\n-\n-    while let Range { start: _, end: _ } = true..(true && false) { }\n-}"}, {"sha": "cbba2d7473334ef4f582901cfd21d3b28828f098", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2018.stderr", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a96ba969156d257e5d5b692946fa8fe40ed6543a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr?ref=a96ba969156d257e5d5b692946fa8fe40ed6543a", "patch": "@@ -1,56 +0,0 @@\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2018.rs:10:47\n-   |\n-LL |     if let Range { start: _, end: _ } = true..true && false { }\n-   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `||`\n-  --> $DIR/syntax-ambiguity-2018.rs:13:47\n-   |\n-LL |     if let Range { start: _, end: _ } = true..true || false { }\n-   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2018.rs:16:50\n-   |\n-LL |     while let Range { start: _, end: _ } = true..true && false { }\n-   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `||`\n-  --> $DIR/syntax-ambiguity-2018.rs:19:50\n-   |\n-LL |     while let Range { start: _, end: _ } = true..true || false { }\n-   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2018.rs:22:19\n-   |\n-LL |     if let true = false && false { }\n-   |                   ^^^^^^^^^^^^^^ help: consider adding parentheses: `(false && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: ambiguous use of `&&`\n-  --> $DIR/syntax-ambiguity-2018.rs:25:22\n-   |\n-LL |     while let true = (1 == 2) && false { }\n-   |                      ^^^^^^^^^^^^^^^^^ help: consider adding parentheses: `((1 == 2) && false)`\n-   |\n-   = note: this will be a error until the `let_chains` feature is stabilized\n-   = note: see rust-lang/rust#53668 for more information\n-\n-error: aborting due to 6 previous errors\n-"}]}