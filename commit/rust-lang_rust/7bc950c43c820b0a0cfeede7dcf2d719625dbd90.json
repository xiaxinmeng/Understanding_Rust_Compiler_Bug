{"sha": "7bc950c43c820b0a0cfeede7dcf2d719625dbd90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYzk1MGM0M2M4MjBiMGEwY2ZlZWRlN2RjZjJkNzE5NjI1ZGJkOTA=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-01T01:48:06Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-02T00:37:57Z"}, "message": "Refactor some hashmap code into a new private function mangle()\n\nAdd new private hashmap function\n\n    fn mangle(&mut self,\n              k: K,\n              not_found: &fn(&K) -> V,\n              found: &fn(&K, &mut V)) -> uint\n\nRewrite find_or_insert() and find_or_insert_with() on top of mangle().\n\nAlso take the opportunity to change the return type of find_or_insert()\nand find_or_insert_with() to &'a mut V. This fixes #6394.", "tree": {"sha": "0b3ad1ed07d3a78a7342ae6886b3d59b5a0eade9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b3ad1ed07d3a78a7342ae6886b3d59b5a0eade9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc950c43c820b0a0cfeede7dcf2d719625dbd90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc950c43c820b0a0cfeede7dcf2d719625dbd90", "html_url": "https://github.com/rust-lang/rust/commit/7bc950c43c820b0a0cfeede7dcf2d719625dbd90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc950c43c820b0a0cfeede7dcf2d719625dbd90/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44af5064d0ac3d45223f1555b299f10fd4902f5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/44af5064d0ac3d45223f1555b299f10fd4902f5c", "html_url": "https://github.com/rust-lang/rust/commit/44af5064d0ac3d45223f1555b299f10fd4902f5c"}], "stats": {"total": 58, "additions": 21, "deletions": 37}, "files": [{"sha": "3221ff4730dac253fc3fc8da4a75f79cf81ea197", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7bc950c43c820b0a0cfeede7dcf2d719625dbd90/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc950c43c820b0a0cfeede7dcf2d719625dbd90/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=7bc950c43c820b0a0cfeede7dcf2d719625dbd90", "patch": "@@ -425,9 +425,10 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n+    /// Modify and return the value corresponding to the key in the map, or\n+    /// insert and return a new value if it doesn't exist.\n+    pub fn mangle<'a,A>(&'a mut self, k: K, a: A, not_found: &fn(&K, A) -> V,\n+                        found: &fn(&K, &mut V, A)) -> &'a mut V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n             // that we do not resize if this call to insert is\n@@ -441,46 +442,29 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         let idx = match self.bucket_for_key_with_hash(hash, &k) {\n             TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n+            FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n             FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n+                let v = not_found(&k, a);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k, value: v});\n                 self.size += 1;\n                 idx\n-            },\n+            }\n         };\n \n-        self.value_for_bucket(idx)\n+        self.mut_value_for_bucket(idx)\n+    }\n+\n+    /// Return the value corresponding to the key in the map, or insert\n+    /// and return the value if it doesn't exist.\n+    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n+        self.mangle(k, v, |_k, a| a, |_k,_v,_a| ())\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V)\n-                                   -> &'a V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                let v = f(&k);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n-\n-        self.value_for_bucket(idx)\n+                               -> &'a mut V {\n+        self.mangle(k, (), |k,_a| f(k), |_k,_v,_a| ())\n     }\n \n     /// Calls a function on each element of a hash map, destroying the hash\n@@ -763,15 +747,15 @@ mod test_map {\n     #[test]\n     fn test_find_or_insert() {\n         let mut m = HashMap::new::<int, int>();\n-        assert_eq!(m.find_or_insert(1, 2), &2);\n-        assert_eq!(m.find_or_insert(1, 3), &2);\n+        assert_eq!(*m.find_or_insert(1, 2), 2);\n+        assert_eq!(*m.find_or_insert(1, 3), 2);\n     }\n \n     #[test]\n     fn test_find_or_insert_with() {\n         let mut m = HashMap::new::<int, int>();\n-        assert_eq!(m.find_or_insert_with(1, |_| 2), &2);\n-        assert_eq!(m.find_or_insert_with(1, |_| 3), &2);\n+        assert_eq!(*m.find_or_insert_with(1, |_| 2), 2);\n+        assert_eq!(*m.find_or_insert_with(1, |_| 3), 2);\n     }\n \n     #[test]"}]}