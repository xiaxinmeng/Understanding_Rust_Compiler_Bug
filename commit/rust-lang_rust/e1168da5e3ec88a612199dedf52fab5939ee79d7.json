{"sha": "e1168da5e3ec88a612199dedf52fab5939ee79d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMTY4ZGE1ZTNlYzg4YTYxMjE5OWRlZGY1MmZhYjU5MzllZTc5ZDc=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-20T01:55:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-20T01:55:37Z"}, "message": "Rollup merge of #41348 - lukaramu:std-path-docs, r=frewsxcv\n\nImprove std::path docs\n\nFixes #29368.\n\nThis PR contains a pretty significant redistribution of some of the module docs to more appropriate places, as well as general expansion, clarification, and additional examples.\n\nFor more details, see the commit descriptions.\n\nr? @steveklabnik", "tree": {"sha": "a8d33dd6bd939d683f154d1f1329bd9fbe161250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8d33dd6bd939d683f154d1f1329bd9fbe161250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1168da5e3ec88a612199dedf52fab5939ee79d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1168da5e3ec88a612199dedf52fab5939ee79d7", "html_url": "https://github.com/rust-lang/rust/commit/e1168da5e3ec88a612199dedf52fab5939ee79d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1168da5e3ec88a612199dedf52fab5939ee79d7/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a97309d8c86bf5d41110a5575b28ce403266ca2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a97309d8c86bf5d41110a5575b28ce403266ca2e", "html_url": "https://github.com/rust-lang/rust/commit/a97309d8c86bf5d41110a5575b28ce403266ca2e"}, {"sha": "d6f7577279b28ab0551e60820b737aebf4f61105", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6f7577279b28ab0551e60820b737aebf4f61105", "html_url": "https://github.com/rust-lang/rust/commit/d6f7577279b28ab0551e60820b737aebf4f61105"}], "stats": {"total": 377, "additions": 257, "deletions": 120}, "files": [{"sha": "22889b5de4c2aeb01176f7a06c1ba9cecaa69450", "filename": "src/libstd/path.rs", "status": "modified", "additions": 257, "deletions": 120, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/e1168da5e3ec88a612199dedf52fab5939ee79d7/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1168da5e3ec88a612199dedf52fab5939ee79d7/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=e1168da5e3ec88a612199dedf52fab5939ee79d7", "patch": "@@ -10,11 +10,18 @@\n \n //! Cross-platform path manipulation.\n //!\n-//! This module provides two types, [`PathBuf`] and [`Path`][`Path`] (akin to [`String`]\n+//! This module provides two types, [`PathBuf`] and [`Path`] (akin to [`String`]\n //! and [`str`]), for working with paths abstractly. These types are thin wrappers\n //! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n //! on strings according to the local platform's path syntax.\n //!\n+//! Paths can be parsed into [`Component`]s by iterating over the structure\n+//! returned by the [`components`] method on [`Path`]. [`Component`]s roughly\n+//! correspond to the substrings between path separators (`/` or `\\`). You can\n+//! reconstruct an equivalent path from components with the [`push`] method on\n+//! [`PathBuf`]; note that the paths may differ syntactically by the\n+//! normalization described in the documentation for the [`components`] method.\n+//!\n //! ## Simple usage\n //!\n //! Path manipulation includes both parsing components from slices and building\n@@ -50,62 +57,11 @@\n //! path.set_extension(\"dll\");\n //! ```\n //!\n-//! ## Path components and normalization\n-//!\n-//! The path APIs are built around the notion of \"components\", which roughly\n-//! correspond to the substrings between path separators (`/` and, on Windows,\n-//! `\\`). The APIs for path parsing are largely specified in terms of the path's\n-//! components, so it's important to clearly understand how those are\n-//! determined.\n-//!\n-//! A path can always be reconstructed into an *equivalent* path by\n-//! putting together its components via `push`. Syntactically, the\n-//! paths may differ by the normalization described below.\n-//!\n-//! ### Component types\n-//!\n-//! Components come in several types:\n-//!\n-//! * Normal components are the default: standard references to files or\n-//! directories. The path `a/b` has two normal components, `a` and `b`.\n-//!\n-//! * Current directory components represent the `.` character. For example,\n-//! `./a` has a current directory component and a normal component `a`.\n-//!\n-//! * The root directory component represents a separator that designates\n-//!   starting from root. For example, `/a/b` has a root directory component\n-//!   followed by normal components `a` and `b`.\n-//!\n-//! On Windows, an additional component type comes into play:\n-//!\n-//! * Prefix components, of which there is a large variety. For example, `C:`\n-//! and `\\\\server\\share` are prefixes. The path `C:windows` has a prefix\n-//! component `C:` and a normal component `windows`; the path `C:\\windows` has a\n-//! prefix component `C:`, a root directory component, and a normal component\n-//! `windows`.\n-//!\n-//! ### Normalization\n-//!\n-//! Aside from splitting on the separator(s), there is a small amount of\n-//! \"normalization\":\n-//!\n-//! * Repeated separators are ignored: `a/b` and `a//b` both have components `a`\n-//!   and `b`.\n-//!\n-//! * Occurrences of `.` are normalized away, *except* if they are at\n-//! the beginning of the path (in which case they are often meaningful\n-//! in terms of path searching). So, for example, `a/./b`, `a/b/`,\n-//! `/a/b/.` and `a/b` all have components `a` and `b`, but `./a/b`\n-//! has a leading current directory component.\n-//!\n-//! No other normalization takes place by default. In particular,\n-//! `a/c` and `a/b/../c` are distinct, to account for the possibility\n-//! that `b` is a symbolic link (so its parent isn't `a`). Further\n-//! normalization is possible to build on top of the components APIs,\n-//! and will be included in this library in the near future.\n-//!\n+//! [`Component`]: ../../std/path/enum.Component.html\n+//! [`components`]: ../../std/path/struct.Path.html#method.components\n //! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n //! [`Path`]: ../../std/path/struct.Path.html\n+//! [`push`]: ../../std/path/struct.PathBuf.html#method.push\n //! [`String`]: ../../std/string/struct.String.html\n //! [`str`]: ../../std/primitive.str.html\n //! [`OsString`]: ../../std/ffi/struct.OsString.html\n@@ -143,36 +99,81 @@ use sys::path::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n // Windows Prefixes\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Path prefixes (Windows only).\n+/// Windows path prefixes, e.g. `C:` or `\\\\server\\share`.\n ///\n-/// Windows uses a variety of path styles, including references to drive\n-/// volumes (like `C:`), network shared folders (like `\\\\server\\share`) and\n-/// others. In addition, some path prefixes are \"verbatim\", in which case\n-/// `/` is *not* treated as a separator and essentially no normalization is\n-/// performed.\n+/// Windows uses a variety of path prefix styles, including references to drive\n+/// volumes (like `C:`), network shared folders (like `\\\\server\\share`), and\n+/// others. In addition, some path prefixes are \"verbatim\" (i.e. prefixed with\n+/// `\\\\?\\`), in which case `/` is *not* treated as a separator and essentially\n+/// no normalization is performed.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path::{Component, Path, Prefix};\n+/// use std::path::Prefix::*;\n+/// use std::ffi::OsStr;\n+///\n+/// fn get_path_prefix(s: &str) -> Prefix {\n+///     let path = Path::new(s);\n+///     match path.components().next().unwrap() {\n+///         Component::Prefix(prefix_component) => prefix_component.kind(),\n+///         _ => panic!(),\n+///     }\n+/// }\n+///\n+/// # if cfg!(windows) {\n+/// assert_eq!(Verbatim(OsStr::new(\"pictures\")),\n+///            get_path_prefix(r\"\\\\?\\pictures\\kittens\"));\n+/// assert_eq!(VerbatimUNC(OsStr::new(\"server\"), OsStr::new(\"share\")),\n+///            get_path_prefix(r\"\\\\?\\UNC\\server\\share\"));\n+/// assert_eq!(VerbatimDisk('C' as u8), get_path_prefix(r\"\\\\?\\c:\\\"));\n+/// assert_eq!(DeviceNS(OsStr::new(\"BrainInterface\")),\n+///            get_path_prefix(r\"\\\\.\\BrainInterface\"));\n+/// assert_eq!(UNC(OsStr::new(\"server\"), OsStr::new(\"share\")),\n+///            get_path_prefix(r\"\\\\server\\share\"));\n+/// assert_eq!(Disk('C' as u8), get_path_prefix(r\"C:\\Users\\Rust\\Pictures\\Ferris\"));\n+/// # }\n+/// ```\n #[derive(Copy, Clone, Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Prefix<'a> {\n-    /// Prefix `\\\\?\\`, together with the given component immediately following it.\n+    /// Verbatim prefix, e.g. `\\\\?\\cat_pics`.\n+    ///\n+    /// Verbatim prefixes consist of `\\\\?\\` immediately followed by the given\n+    /// component.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Verbatim(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n \n-    /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n+    /// Verbatim prefix using Windows' _**U**niform **N**aming **C**onvention_,\n+    /// e.g. `\\\\?\\UNC\\server\\share`.\n+    ///\n+    /// Verbatim UNC prefixes consist of `\\\\?\\UNC\\` immediately followed by the\n+    /// server's hostname and a share name.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     VerbatimUNC(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n     ),\n \n-    /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n+    /// Verbatim disk prefix, e.g. `\\\\?\\C:\\`.\n+    ///\n+    /// Verbatim disk prefixes consist of `\\\\?\\` immediately followed by the\n+    /// drive letter and `:\\`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     VerbatimDisk(#[stable(feature = \"rust1\", since = \"1.0.0\")] u8),\n \n-    /// Prefix `\\\\.\\`, together with the given component immediately following it.\n+    /// Device namespace prefix, e.g. `\\\\.\\COM42`.\n+    ///\n+    /// Device namespace prefixes consist of `\\\\.\\` immediately followed by the\n+    /// device name.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     DeviceNS(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n \n-    /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n+    /// Prefix using Windows' _**U**niform **N**aming **C**onvention_, e.g.\n+    /// `\\\\server\\share`.\n+    ///\n+    /// UNC prefixes consist of the server's hostname and a share name.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     UNC(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n@@ -217,6 +218,20 @@ impl<'a> Prefix<'a> {\n     }\n \n     /// Determines if the prefix is verbatim, i.e. begins with `\\\\?\\`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Prefix::*;\n+    /// use std::ffi::OsStr;\n+    ///\n+    /// assert!(Verbatim(OsStr::new(\"pictures\")).is_verbatim());\n+    /// assert!(VerbatimUNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n+    /// assert!(VerbatimDisk('C' as u8).is_verbatim());\n+    /// assert!(!DeviceNS(OsStr::new(\"BrainInterface\")).is_verbatim());\n+    /// assert!(!UNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n+    /// assert!(!Disk('C' as u8).is_verbatim());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_verbatim(&self) -> bool {\n@@ -356,9 +371,42 @@ enum State {\n     Done = 3,\n }\n \n-/// A Windows path prefix, e.g. `C:` or `\\\\server\\share`.\n+/// A structure wrapping a Windows path prefix as well as its unparsed string\n+/// representation.\n+///\n+/// In addition to the parsed [`Prefix`] information returned by [`kind`],\n+/// `PrefixComponent` also holds the raw and unparsed [`OsStr`] slice,\n+/// returned by [`as_os_str`].\n+///\n+/// Instances of this `struct` can be obtained by matching against the\n+/// [`Prefix` variant] on [`Component`].\n ///\n /// Does not occur on Unix.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # if cfg!(windows) {\n+/// use std::path::{Component, Path, Prefix};\n+/// use std::ffi::OsStr;\n+///\n+/// let path = Path::new(r\"c:\\you\\later\\\");\n+/// match path.components().next().unwrap() {\n+///     Component::Prefix(prefix_component) => {\n+///         assert_eq!(Prefix::Disk('C' as u8), prefix_component.kind());\n+///         assert_eq!(OsStr::new(\"c:\"), prefix_component.as_os_str());\n+///     }\n+///     _ => unreachable!(),\n+/// }\n+/// # }\n+/// ```\n+///\n+/// [`as_os_str`]: #method.as_os_str\n+/// [`Component`]: enum.Component.html\n+/// [`kind`]: #method.kind\n+/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n+/// [`Prefix` variant]: enum.Component.html#variant.Prefix\n+/// [`Prefix`]: enum.Prefix.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Eq, Debug)]\n pub struct PrefixComponent<'a> {\n@@ -370,13 +418,20 @@ pub struct PrefixComponent<'a> {\n }\n \n impl<'a> PrefixComponent<'a> {\n-    /// The parsed prefix data.\n+    /// Returns the parsed prefix data.\n+    ///\n+    /// See [`Prefix`]'s documentation for more information on the different\n+    /// kinds of prefixes.\n+    ///\n+    /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn kind(&self) -> Prefix<'a> {\n         self.parsed\n     }\n \n-    /// The raw `OsStr` slice for this prefix.\n+    /// Returns the raw [`OsStr`] slice for this prefix.\n+    ///\n+    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &'a OsStr {\n         self.raw\n@@ -413,11 +468,11 @@ impl<'a> Hash for PrefixComponent<'a> {\n \n /// A single component of a path.\n ///\n-/// See the module documentation for an in-depth explanation of components and\n-/// their role in the API.\n+/// A `Component` roughtly corresponds to a substring between path separators\n+/// (`/` or `\\`).\n ///\n-/// This `enum` is created from iterating over the [`path::Components`]\n-/// `struct`.\n+/// This `enum` is created by iterating over [`Components`], which in turn is\n+/// created by the [`components`][`Path::components`] method on [`Path`].\n ///\n /// # Examples\n ///\n@@ -434,37 +489,49 @@ impl<'a> Hash for PrefixComponent<'a> {\n /// ]);\n /// ```\n ///\n-/// [`path::Components`]: struct.Components.html\n+/// [`Components`]: struct.Components.html\n+/// [`Path`]: struct.Path.html\n+/// [`Path::components`]: struct.Path.html#method.components\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Component<'a> {\n     /// A Windows path prefix, e.g. `C:` or `\\\\server\\share`.\n     ///\n+    /// There is a large variety of prefix types, see [`Prefix`]'s documentation\n+    /// for more.\n+    ///\n     /// Does not occur on Unix.\n+    ///\n+    /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Prefix(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>\n     ),\n \n-    /// The root directory component, appears after any prefix and before anything else\n+    /// The root directory component, appears after any prefix and before anything else.\n+    ///\n+    /// It represents a separator that designates that a path starts from root.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     RootDir,\n \n-    /// A reference to the current directory, i.e. `.`\n+    /// A reference to the current directory, i.e. `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     CurDir,\n \n-    /// A reference to the parent directory, i.e. `..`\n+    /// A reference to the parent directory, i.e. `..`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     ParentDir,\n \n-    /// A normal component, i.e. `a` and `b` in `a/b`\n+    /// A normal component, e.g. `a` and `b` in `a/b`.\n+    ///\n+    /// This variant is the most common one, it represents references to files\n+    /// or directories.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Normal(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n }\n \n impl<'a> Component<'a> {\n-    /// Extracts the underlying `OsStr` slice.\n+    /// Extracts the underlying [`OsStr`] slice.\n     ///\n     /// # Examples\n     ///\n@@ -475,6 +542,8 @@ impl<'a> Component<'a> {\n     /// let components: Vec<_> = path.components().map(|comp| comp.as_os_str()).collect();\n     /// assert_eq!(&components, &[\".\", \"tmp\", \"foo\", \"bar.txt\"]);\n     /// ```\n+    ///\n+    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n@@ -494,12 +563,10 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n     }\n }\n \n-/// The core iterator giving the components of a path.\n-///\n-/// See the module documentation for an in-depth explanation of components and\n-/// their role in the API.\n+/// An interator over the [`Component`]s of a [`Path`].\n ///\n-/// This `struct` is created by the [`path::Path::components`] method.\n+/// This `struct` is created by the [`components`] method on [`Path`].\n+/// See its documentation for more.\n ///\n /// # Examples\n ///\n@@ -513,7 +580,9 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n /// }\n /// ```\n ///\n-/// [`path::Path::components`]: struct.Path.html#method.components\n+/// [`Component`]: enum.Component.html\n+/// [`components`]: struct.Path.html#method.components\n+/// [`Path`]: struct.Path.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n@@ -534,9 +603,15 @@ pub struct Components<'a> {\n     back: State,\n }\n \n-/// An iterator over the components of a path, as [`OsStr`] slices.\n+/// An iterator over the [`Component`]s of a [`Path`], as [`OsStr`] slices.\n ///\n+/// This `struct` is created by the [`iter`] method on [`Path`].\n+/// See its documentation for more.\n+///\n+/// [`Component`]: enum.Component.html\n+/// [`iter`]: struct.Path.html#method.iter\n /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n+/// [`Path`]: struct.Path.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n@@ -762,6 +837,18 @@ impl<'a> fmt::Debug for Iter<'a> {\n \n impl<'a> Iter<'a> {\n     /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let mut iter = Path::new(\"/tmp/foo/bar.txt\").iter();\n+    /// iter.next();\n+    /// iter.next();\n+    ///\n+    /// assert_eq!(Path::new(\"foo/bar.txt\"), iter.as_path());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         self.inner.as_path()\n@@ -1067,9 +1154,10 @@ impl PathBuf {\n \n     /// Truncate `self` to [`self.parent`].\n     ///\n-    /// Returns false and does nothing if [`self.file_name`] is `None`.\n+    /// Returns `false` and does nothing if [`self.file_name`] is [`None`].\n     /// Otherwise, returns `true`.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     /// [`self.parent`]: struct.PathBuf.html#method.parent\n     /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n     ///\n@@ -1132,10 +1220,11 @@ impl PathBuf {\n \n     /// Updates [`self.extension`] to `extension`.\n     ///\n-    /// If [`self.file_name`] is `None`, does nothing and returns `false`.\n+    /// Returns `false` and does nothing if [`self.file_name`] is [`None`],\n+    /// returns `true` and updates the extension otherwise.\n     ///\n-    /// Otherwise, returns `true`; if [`self.extension`] is [`None`], the\n-    /// extension is added; otherwise it is replaced.\n+    /// If [`self.extension`] is [`None`], the extension is added; otherwise\n+    /// it is replaced.\n     ///\n     /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n     /// [`self.extension`]: struct.PathBuf.html#method.extension\n@@ -1195,7 +1284,10 @@ impl PathBuf {\n         self.inner\n     }\n \n-    /// Converts this `PathBuf` into a boxed `Path`.\n+    /// Converts this `PathBuf` into a [boxed][`Box`] [`Path`].\n+    ///\n+    /// [`Box`]: ../../std/boxed/struct.Box.html\n+    /// [`Path`]: struct.Path.html\n     #[unstable(feature = \"into_boxed_path\", issue = \"40380\")]\n     pub fn into_boxed_path(self) -> Box<Path> {\n         unsafe { mem::transmute(self.inner.into_boxed_os_str()) }\n@@ -1402,10 +1494,14 @@ pub struct Path {\n     inner: OsStr,\n }\n \n-/// An error returned from the [`Path::strip_prefix`] method indicating that the\n-/// prefix was not found in `self`.\n+/// An error returned from [`Path::strip_prefix`][`strip_prefix`] if the prefix\n+/// was not found.\n+///\n+/// This `struct` is created by the [`strip_prefix`] method on [`Path`].\n+/// See its documentation for more.\n ///\n-/// [`Path::strip_prefix`]: struct.Path.html#method.strip_prefix\n+/// [`strip_prefix`]: struct.Path.html#method.strip_prefix\n+/// [`Path`]: struct.Path.html\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n pub struct StripPrefixError(());\n@@ -1421,7 +1517,7 @@ impl Path {\n         os_str_as_u8_slice(&self.inner)\n     }\n \n-    /// Directly wrap a string slice as a `Path` slice.\n+    /// Directly wraps a string slice as a `Path` slice.\n     ///\n     /// This is a cost-free conversion.\n     ///\n@@ -1525,10 +1621,11 @@ impl Path {\n         PathBuf::from(self.inner.to_os_string())\n     }\n \n-    /// A path is *absolute* if it is independent of the current directory.\n+    /// Returns `true` if the `Path` is absolute, i.e. if it is independent of\n+    /// the current directory.\n     ///\n     /// * On Unix, a path is absolute if it starts with the root, so\n-    /// `is_absolute` and `has_root` are equivalent.\n+    /// `is_absolute` and [`has_root`] are equivalent.\n     ///\n     /// * On Windows, a path is absolute if it has a prefix and starts with the\n     /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not.\n@@ -1540,14 +1637,18 @@ impl Path {\n     ///\n     /// assert!(!Path::new(\"foo.txt\").is_absolute());\n     /// ```\n+    ///\n+    /// [`has_root`]: #method.has_root\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n         // FIXME: Remove target_os = \"redox\" and allow Redox prefixes\n         self.has_root() && (cfg!(unix) || cfg!(target_os = \"redox\") || self.prefix().is_some())\n     }\n \n-    /// A path is *relative* if it is not absolute.\n+    /// Return `false` if the `Path` is relative, i.e. not absolute.\n+    ///\n+    /// See [`is_absolute`]'s documentation for more details.\n     ///\n     /// # Examples\n     ///\n@@ -1556,6 +1657,8 @@ impl Path {\n     ///\n     /// assert!(Path::new(\"foo.txt\").is_relative());\n     /// ```\n+    ///\n+    /// [`is_absolute`]: #method.is_absolute\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n@@ -1565,7 +1668,7 @@ impl Path {\n         self.components().prefix\n     }\n \n-    /// A path has a root if the body of the path begins with the directory separator.\n+    /// Returns `true` if the `Path` has a root.\n     ///\n     /// * On Unix, a path has a root if it begins with `/`.\n     ///\n@@ -1586,7 +1689,7 @@ impl Path {\n         self.components().has_root()\n     }\n \n-    /// The path without its final component, if any.\n+    /// Returns the `Path` without its final component, if there is one.\n     ///\n     /// Returns [`None`] if the path terminates in a root or prefix.\n     ///\n@@ -1619,9 +1722,9 @@ impl Path {\n         })\n     }\n \n-    /// The final component of the path, if it is a normal file.\n+    /// Returns the final component of the `Path`, if it is a normal file.\n     ///\n-    /// If the path terminates in `..`, `file_name` will return [`None`].\n+    /// Returns [`None`] If the path terminates in `..`.\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n@@ -1631,18 +1734,7 @@ impl Path {\n     /// use std::path::Path;\n     /// use std::ffi::OsStr;\n     ///\n-    /// let path = Path::new(\"foo.txt\");\n-    /// let os_str = OsStr::new(\"foo.txt\");\n-    ///\n-    /// assert_eq!(Some(os_str), path.file_name());\n-    /// ```\n-    ///\n-    /// # Other examples\n-    ///\n-    /// ```\n-    /// use std::path::Path;\n-    /// use std::ffi::OsStr;\n-    ///\n+    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt\").file_name());\n     /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\n     /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\n     /// assert_eq!(None, Path::new(\"foo.txt/..\").file_name());\n@@ -1869,7 +1961,21 @@ impl Path {\n         buf\n     }\n \n-    /// Produce an iterator over the components of the path.\n+    /// Produces an iterator over the [`Component`]s of the path.\n+    ///\n+    /// When parsing the path, there is a small amount of normalization:\n+    ///\n+    /// * Repeated separators are ignored, so `a/b` and `a//b` both have\n+    ///   `a` and `b` as components.\n+    ///\n+    /// * Occurentces of `.` are normalized away, exept if they are at the\n+    ///   beginning of the path. For example, `a/./b`, `a/b/`, `a/b/.` and\n+    ///   `a/b` all have `a` and `b` as components, but `./a/b` starts with\n+    ///   an additional [`CurDir`] component.\n+    ///\n+    /// Note that no other normalization takes place; in particular, `a/c`\n+    /// and `a/b/../c` are distinct, to account for the possibility that `b`\n+    /// is a symbolic link (so its parent isn't `a`).\n     ///\n     /// # Examples\n     ///\n@@ -1884,6 +1990,9 @@ impl Path {\n     /// assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"foo.txt\"))));\n     /// assert_eq!(components.next(), None)\n     /// ```\n+    ///\n+    /// [`Component`]: enum.Component.html\n+    /// [`CurDir`]: enum.Component.html#variant.CurDir\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components {\n         let prefix = parse_prefix(self.as_os_str());\n@@ -1896,8 +2005,13 @@ impl Path {\n         }\n     }\n \n-    /// Produce an iterator over the path's components viewed as [`OsStr`] slices.\n+    /// Produces an iterator over the path's components viewed as [`OsStr`]\n+    /// slices.\n+    ///\n+    /// For more information about the particulars of how the path is separated\n+    /// into components, see [`components`].\n     ///\n+    /// [`components`]: #method.components\n     /// [`OsStr`]: ../ffi/struct.OsStr.html\n     ///\n     /// # Examples\n@@ -1936,7 +2050,7 @@ impl Path {\n         Display { path: self }\n     }\n \n-    /// Query the file system to get information about a file, directory, etc.\n+    /// Queries the file system to get information about a file, directory, etc.\n     ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file.\n@@ -1959,7 +2073,7 @@ impl Path {\n         fs::metadata(self)\n     }\n \n-    /// Query the metadata about a file without following symlinks.\n+    /// Queries the metadata about a file without following symlinks.\n     ///\n     /// This is an alias to [`fs::symlink_metadata`].\n     ///\n@@ -2096,7 +2210,11 @@ impl Path {\n         fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)\n     }\n \n-    /// Converts a `Box<Path>` into a `PathBuf` without copying or allocating.\n+    /// Converts a [`Box<Path>`][`Box`] into a [`PathBuf`] without copying or\n+    /// allocating.\n+    ///\n+    /// [`Box`]: ../../std/boxed/struct.Box.html\n+    /// [`PathBuf`]: struct.PathBuf.html\n     #[unstable(feature = \"into_boxed_path\", issue = \"40380\")]\n     pub fn into_path_buf(self: Box<Path>) -> PathBuf {\n         let inner: Box<OsStr> = unsafe { mem::transmute(self) };\n@@ -2118,7 +2236,26 @@ impl fmt::Debug for Path {\n     }\n }\n \n-/// Helper struct for safely printing paths with `format!()` and `{}`\n+/// Helper struct for safely printing paths with [`format!`] and `{}`.\n+///\n+/// A [`Path`] might contain non-Unicode data. This `struct` implements the\n+/// [`Display`] trait in a way that mitigates that. It is created by the\n+/// [`display`][`Path::display`] method on [`Path`].\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path::Path;\n+///\n+/// let path = Path::new(\"/tmp/foo.rs\");\n+///\n+/// println!(\"{}\", path.display());\n+/// ```\n+///\n+/// [`Display`]: ../../std/fmt/trait.Display.html\n+/// [`format!`]: ../../std/macro.format.html\n+/// [`Path`]: struct.Path.html\n+/// [`Path::display`]: struct.Path.html#method.display\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Display<'a> {\n     path: &'a Path,"}]}