{"sha": "4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlOWY5MzI5ZTNlMjE0M2I1NThhOWVkODBjMjIwZDVkMDFmNmJkMDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-21T21:32:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-10T07:50:06Z"}, "message": "miri engine: basic support for pointer provenance tracking", "tree": {"sha": "9654d4182e144d37b8647e237aba2ed4397802da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9654d4182e144d37b8647e237aba2ed4397802da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "html_url": "https://github.com/rust-lang/rust/commit/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4623d4889373702428251967d9bf6ff6d677ec1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4623d4889373702428251967d9bf6ff6d677ec1a", "html_url": "https://github.com/rust-lang/rust/commit/4623d4889373702428251967d9bf6ff6d677ec1a"}], "stats": {"total": 1368, "additions": 870, "deletions": 498}, "files": [{"sha": "e8c89cb3e0e7eb17bdbb6b207855fb86699f2a18", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -391,10 +391,39 @@ for ::mir::interpret::ConstValue<'gcx> {\n     }\n }\n \n-impl_stable_hash_for!(struct mir::interpret::Pointer {\n-    alloc_id,\n-    offset\n-});\n+impl<'a, Tag> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::Pointer<Tag>\n+where Tag: HashStable<StableHashingContext<'a>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ::mir::interpret::Pointer { alloc_id, offset, tag } = self;\n+        alloc_id.hash_stable(hcx, hasher);\n+        offset.hash_stable(hcx, hasher);\n+        tag.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, Tag> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::Scalar<Tag>\n+where Tag: HashStable<StableHashingContext<'a>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::Scalar::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Bits { bits, size } => {\n+                bits.hash_stable(hcx, hasher);\n+                size.hash_stable(hcx, hasher);\n+            },\n+            Ptr(ptr) => ptr.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n \n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     fn hash_stable<W: StableHasherResult>(\n@@ -449,25 +478,6 @@ impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n     Mutable\n });\n \n-\n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::Scalar {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::Scalar::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Bits { bits, size } => {\n-                bits.hash_stable(hcx, hasher);\n-                size.hash_stable(hcx, hasher);\n-            },\n-            Ptr(ptr) => ptr.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n impl_stable_hash_for!(struct ty::Const<'tcx> {\n     ty,\n     val"}, {"sha": "5eee0fba5fb463bfb5a53fec00f34f418c629406", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -138,54 +138,82 @@ impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n /// each context.\n ///\n /// Defaults to the index based and loosely coupled AllocId.\n+///\n+/// Pointer is also generic over the `Tag` associated with each pointer,\n+/// which is used to do provenance tracking during execution.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub struct Pointer<Id=AllocId> {\n+pub struct Pointer<Tag=(),Id=AllocId> {\n     pub alloc_id: Id,\n     pub offset: Size,\n+    pub tag: Tag,\n }\n \n /// Produces a `Pointer` which points to the beginning of the Allocation\n impl From<AllocId> for Pointer {\n+    #[inline(always)]\n     fn from(alloc_id: AllocId) -> Self {\n         Pointer::new(alloc_id, Size::ZERO)\n     }\n }\n \n-impl<'tcx> Pointer {\n+impl<'tcx> Pointer<()> {\n+    #[inline(always)]\n     pub fn new(alloc_id: AllocId, offset: Size) -> Self {\n-        Pointer { alloc_id, offset }\n+        Pointer { alloc_id, offset, tag: () }\n+    }\n+\n+    #[inline(always)]\n+    pub fn with_default_tag<Tag>(self) -> Pointer<Tag>\n+        where Tag: Default\n+    {\n+        Pointer::new_with_tag(self.alloc_id, self.offset, Default::default())\n+    }\n+}\n+\n+impl<'tcx, Tag> Pointer<Tag> {\n+    #[inline(always)]\n+    pub fn new_with_tag(alloc_id: AllocId, offset: Size, tag: Tag) -> Self {\n+        Pointer { alloc_id, offset, tag }\n     }\n \n     pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n-        Pointer::new(\n+        Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n+            self.tag,\n         )\n     }\n \n     pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n-        (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n+        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n     pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new(\n+        Ok(Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n+            self.tag,\n         ))\n     }\n \n     pub fn overflowing_offset<C: HasDataLayout>(self, i: Size, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n-        (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n+        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n     pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new(\n+        Ok(Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n+            self.tag\n         ))\n     }\n+\n+    #[inline]\n+    pub fn erase_tag(self) -> Pointer {\n+        Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n+    }\n }\n \n \n@@ -496,15 +524,15 @@ impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Allocation {\n+pub struct Allocation<Tag=()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n-    /// Maps from byte addresses to allocations.\n+    /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n-    pub relocations: Relocations,\n+    pub relocations: Relocations<Tag>,\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n@@ -515,7 +543,7 @@ pub struct Allocation {\n     pub mutability: Mutability,\n }\n \n-impl Allocation {\n+impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n         let mut undef_mask = UndefMask::new(Size::ZERO);\n@@ -548,29 +576,29 @@ impl Allocation {\n impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Relocations<Id=AllocId>(SortedMap<Size, Id>);\n+pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n \n-impl<Id> Relocations<Id> {\n+impl<Tag, Id> Relocations<Tag, Id> {\n     pub fn new() -> Self {\n         Relocations(SortedMap::new())\n     }\n \n     // The caller must guarantee that the given relocations are already sorted\n     // by address and contain no duplicates.\n-    pub fn from_presorted(r: Vec<(Size, Id)>) -> Self {\n+    pub fn from_presorted(r: Vec<(Size, (Tag, Id))>) -> Self {\n         Relocations(SortedMap::from_presorted_elements(r))\n     }\n }\n \n-impl Deref for Relocations {\n-    type Target = SortedMap<Size, AllocId>;\n+impl<Tag> Deref for Relocations<Tag> {\n+    type Target = SortedMap<Size, (Tag, AllocId)>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }\n }\n \n-impl DerefMut for Relocations {\n+impl<Tag> DerefMut for Relocations<Tag> {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         &mut self.0\n     }"}, {"sha": "d782c491948116a73d3a7640a37e2315ebdf68a2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -79,7 +79,47 @@ impl<'tcx> ConstValue<'tcx> {\n     }\n }\n \n-impl<'tcx> Scalar {\n+/// A `Scalar` represents an immediate, primitive value existing outside of a\n+/// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n+/// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n+/// of a simple value or a pointer into another `Allocation`\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+pub enum Scalar<Tag=(),Id=AllocId> {\n+    /// The raw bytes of a simple value.\n+    Bits {\n+        /// The first `size` bytes are the value.\n+        /// Do not try to read less or more bytes that that. The remaining bytes must be 0.\n+        size: u8,\n+        bits: u128,\n+    },\n+\n+    /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n+    /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n+    /// relocation and its associated offset together as a `Pointer` here.\n+    Ptr(Pointer<Tag,Id>),\n+}\n+\n+impl<'tcx> Scalar<()> {\n+    #[inline]\n+    pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n+        where Tag: Default\n+    {\n+        match self {\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_default_tag()),\n+            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+        }\n+    }\n+}\n+\n+impl<'tcx, Tag> Scalar<Tag> {\n+    #[inline]\n+    pub fn erase_tag(self) -> Scalar {\n+        match self {\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n+            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+        }\n+    }\n+\n     #[inline]\n     pub fn ptr_null(cx: impl HasDataLayout) -> Self {\n         Scalar::Bits {\n@@ -208,7 +248,7 @@ impl<'tcx> Scalar {\n     }\n \n     #[inline]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         match self {\n             Scalar::Bits { bits: 0, .. } => err!(InvalidNullPointerUsage),\n             Scalar::Bits { .. } => err!(ReadBytesAsPointer),\n@@ -317,29 +357,9 @@ impl<'tcx> Scalar {\n     }\n }\n \n-impl From<Pointer> for Scalar {\n+impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     #[inline(always)]\n-    fn from(ptr: Pointer) -> Self {\n+    fn from(ptr: Pointer<Tag>) -> Self {\n         Scalar::Ptr(ptr)\n     }\n }\n-\n-/// A `Scalar` represents an immediate, primitive value existing outside of a\n-/// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n-/// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n-/// of a simple value or a pointer into another `Allocation`\n-#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum Scalar<Id=AllocId> {\n-    /// The raw bytes of a simple value.\n-    Bits {\n-        /// The first `size` bytes are the value.\n-        /// Do not try to read less or more bytes that that. The remaining bytes must be 0.\n-        size: u8,\n-        bits: u128,\n-    },\n-\n-    /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n-    /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n-    /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer<Id>),\n-}"}, {"sha": "9f0f744389089c56981a35d1a08a55be3dc4ec32", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -92,7 +92,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n     let pointer_size = layout.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.relocations.iter() {\n+    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n@@ -105,7 +105,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(scalar_to_llvm(\n             cx,\n-            Pointer { alloc_id, offset: Size::from_bytes(ptr_offset) }.into(),\n+            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n             &layout::Scalar {\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0"}, {"sha": "affd54f5c254f2f91c72b1db64c1db521776d1ea", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -12,6 +12,7 @@\n \n use std::fmt;\n use std::error::Error;\n+use std::borrow::Cow;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir::interpret::ConstEvalErr;\n@@ -272,8 +273,9 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n {\n     type MemoryData = ();\n     type MemoryKinds = !;\n+    type PointerTag = ();\n \n-    const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n+    const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n     const ENFORCE_VALIDITY: bool = false; // for now, we don't\n \n     fn find_fn(\n@@ -339,10 +341,18 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn find_foreign_static(\n         _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         _def_id: DefId,\n-    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n \n+    #[inline(always)]\n+    fn static_with_default_tag(\n+        alloc: &'_ Allocation\n+    ) -> Cow<'_, Allocation<Self::PointerTag>> {\n+        // We do not use a tag so we can just cheapyl forward the reference\n+        Cow::Borrowed(alloc)\n+    }\n+\n     fn box_alloc(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,"}, {"sha": "bfc7e6801fc463fe39fd778fef7e4bdeede63d63", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -33,9 +33,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     pub fn cast(\n         &mut self,\n-        src: OpTy<'tcx>,\n+        src: OpTy<'tcx, M::PointerTag>,\n         kind: CastKind,\n-        dest: PlaceTy<'tcx>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         let src_layout = src.layout;\n         let dst_layout = dest.layout;\n@@ -143,10 +143,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     pub(super) fn cast_scalar(\n         &self,\n-        val: Scalar,\n+        val: Scalar<M::PointerTag>,\n         src_layout: TyLayout<'tcx>,\n         dest_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar> {\n+    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n@@ -182,7 +182,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         v: u128,\n         src_layout: TyLayout<'tcx>,\n         dest_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar> {\n+    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         let signed = src_layout.abi.is_signed();\n         let v = if signed {\n             self.sign_extend(v, src_layout)\n@@ -239,7 +239,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         bits: u128,\n         fty: FloatTy,\n         dest_ty: Ty<'tcx>\n-    ) -> EvalResult<'tcx, Scalar> {\n+    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n         use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n@@ -283,7 +283,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n     }\n \n-    fn cast_from_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n+    fn cast_from_ptr(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        ty: Ty<'tcx>\n+    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc,\n@@ -298,8 +302,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     fn unsize_into_ptr(\n         &mut self,\n-        src: OpTy<'tcx>,\n-        dest: PlaceTy<'tcx>,\n+        src: OpTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n         // The pointee types\n         sty: Ty<'tcx>,\n         dty: Ty<'tcx>,\n@@ -339,8 +343,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     fn unsize_into(\n         &mut self,\n-        src: OpTy<'tcx>,\n-        dest: PlaceTy<'tcx>,\n+        src: OpTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, d, _)) |"}, {"sha": "cf4ff448ee505007569163e3cf56daa3811630ca", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -49,12 +49,12 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub memory: Memory<'a, 'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag>>,\n }\n \n /// A stack frame.\n #[derive(Clone)]\n-pub struct Frame<'mir, 'tcx: 'mir> {\n+pub struct Frame<'mir, 'tcx: 'mir, Tag=()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -74,14 +74,14 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub return_to_block: StackPopCleanup,\n \n     /// The location where the result of the current stack frame should be written to.\n-    pub return_place: Place,\n+    pub return_place: Place<Tag>,\n \n     /// The list of locals for this stack frame, stored in order as\n     /// `[return_ptr, arguments..., variables..., temporaries...]`.\n     /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n-    pub locals: IndexVec<mir::Local, LocalValue<AllocId>>,\n+    pub locals: IndexVec<mir::Local, LocalValue<Tag>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -108,24 +108,24 @@ pub enum StackPopCleanup {\n \n // State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum LocalValue<Id=AllocId> {\n+pub enum LocalValue<Tag=(), Id=AllocId> {\n     Dead,\n     // Mostly for convenience, we re-use the `Operand` type here.\n     // This is an optimization over just always having a pointer here;\n     // we can thus avoid doing an allocation when the local just stores\n     // immediate values *and* never has its address taken.\n-    Live(Operand<Id>),\n+    Live(Operand<Tag, Id>),\n }\n \n-impl<'tcx> LocalValue {\n-    pub fn access(&self) -> EvalResult<'tcx, &Operand> {\n+impl<'tcx, Tag> LocalValue<Tag> {\n+    pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n         match self {\n             LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Live(ref val) => Ok(val),\n         }\n     }\n \n-    pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand> {\n+    pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand<Tag>> {\n         match self {\n             LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Live(ref mut val) => Ok(val),\n@@ -218,7 +218,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         &mut self.memory\n     }\n \n-    pub fn stack(&self) -> &[Frame<'mir, 'tcx>] {\n+    pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag>] {\n         &self.stack\n     }\n \n@@ -230,7 +230,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n \n     /// Mark a storage as live, killing the previous content and returning it.\n     /// Remember to deallocate that!\n-    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue> {\n+    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue<M::PointerTag>> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n@@ -242,14 +242,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n \n     /// Returns the old value of the local.\n     /// Remember to deallocate that!\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue<M::PointerTag> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n         mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n     }\n \n-    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n+    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value<M::PointerTag>> {\n         let ptr = self.memory.allocate_static_bytes(s.as_bytes());\n         Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n@@ -330,7 +330,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     /// Only the \"extra\" (metadata) part of the place matters.\n     pub(super) fn size_and_align_of(\n         &self,\n-        metadata: Option<Scalar>,\n+        metadata: Option<Scalar<M::PointerTag>>,\n         layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let metadata = match metadata {\n@@ -411,7 +411,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     #[inline]\n     pub fn size_and_align_of_mplace(\n         &self,\n-        mplace: MPlaceTy<'tcx>\n+        mplace: MPlaceTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         self.size_and_align_of(mplace.extra, mplace.layout)\n     }\n@@ -421,7 +421,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         instance: ty::Instance<'tcx>,\n         span: source_map::Span,\n         mir: &'mir mir::Mir<'tcx>,\n-        return_place: Place,\n+        return_place: Place<M::PointerTag>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n@@ -519,7 +519,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         Ok(())\n     }\n \n-    pub(super) fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n+    pub(super) fn deallocate_local(&mut self, local: LocalValue<M::PointerTag>) -> EvalResult<'tcx> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");\n@@ -541,12 +541,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     #[inline(always)]\n-    pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n+    pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n     #[inline(always)]\n-    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n+    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n@@ -562,7 +562,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         }\n     }\n \n-    pub fn dump_place(&self, place: Place) {\n+    pub fn dump_place(&self, place: Place<M::PointerTag>) {\n         // Debug output\n         if !log_enabled!(::log::Level::Trace) {\n             return;"}, {"sha": "a669b2aafc2b8868a0a743e8372208bd270c4cbb", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -25,11 +25,11 @@ use super::{\n };\n \n \n-fn numeric_intrinsic<'tcx>(\n+fn numeric_intrinsic<'tcx, Tag>(\n     name: &str,\n     bits: u128,\n     kind: Primitive,\n-) -> EvalResult<'tcx, Scalar> {\n+) -> EvalResult<'tcx, Scalar<Tag>> {\n     let size = match kind {\n         Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n@@ -51,8 +51,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn emulate_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, M::PointerTag>],\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, bool> {\n         let substs = instance.substs;\n \n@@ -169,8 +169,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn hook_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, M::PointerTag>],\n+        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n     ) -> EvalResult<'tcx, bool> {\n         let def_id = instance.def_id();\n         // Some fn calls are actually BinOp intrinsics"}, {"sha": "c7f47a93dae514c83ee1c2fbcc4335cae43cdba6", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -12,6 +12,9 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n+use std::borrow::Cow;\n+use std::hash::Hash;\n+\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{Allocation, EvalResult, Scalar};\n use rustc::mir;\n@@ -30,8 +33,16 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + Copy + Eq;\n \n-    /// The memory kind to use for mutated statics -- or None if those are not supported.\n-    const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n+    /// Tag tracked alongside every pointer.  This is inert for now, in preparation for\n+    /// a future implementation of \"Stacked Borrows\"\n+    /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n+    type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n+\n+    /// The memory kind to use for copied statics -- or None if those are not supported.\n+    /// Statics are copied under two circumstances: When they are mutated, and when\n+    /// `static_with_default_tag` or `find_foreign_static` (see below) returns an owned allocation\n+    /// that is added to the memory so that the work is not done twice.\n+    const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n     const ENFORCE_VALIDITY: bool;\n@@ -53,8 +64,8 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Self::PointerTag>],\n+        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>>;\n \n@@ -63,18 +74,28 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn call_intrinsic(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Self::PointerTag>],\n+        dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n     /// Called for read access to a foreign static item.\n-    /// This can be called multiple times for the same static item and should return consistent\n-    /// results.  Once the item is *written* the first time, as usual for statics a copy is\n-    /// made and this function is not called again.\n+    ///\n+    /// This will only be called once per static and machine; the result is cached in\n+    /// the machine memory.\n     fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-    ) -> EvalResult<'tcx, &'tcx Allocation>;\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>>;\n+\n+    /// Called to turn an allocation obtained from the `tcx` into one that has\n+    /// the appropriate tags on each pointer.\n+    ///\n+    /// This should avoid copying if no work has to be done! If this returns an owned\n+    /// allocation (because a copy had to be done to add the tags), machibe memory will\n+    /// cache the result.\n+    fn static_with_default_tag(\n+        alloc: &'_ Allocation\n+    ) -> Cow<'_, Allocation<Self::PointerTag>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n@@ -83,18 +104,18 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn ptr_op(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<Self::PointerTag>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<Self::PointerTag>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword\n     ///\n     /// Returns a pointer to the allocated memory\n     fn box_alloc(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx>,\n+        dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n     /// Execute a validation operation"}, {"sha": "ab5e37a1d4501eeaa2103af344b23322698646cb", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 237, "deletions": 178, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -16,8 +16,10 @@\n //! integer.  It is crucial that these operations call `check_align` *before*\n //! short-circuiting the empty case!\n \n+use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n use std::ptr;\n+use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n@@ -29,12 +31,14 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n \n-use super::{Machine, ScalarMaybeUndef};\n+use super::{Machine, MonoHashMap, ScalarMaybeUndef};\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n+    /// Error if ever deallocated\n+    Vtable,\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     Machine(T),\n }\n@@ -50,7 +54,9 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// deallocation.  When an allocation is not found here, it is a\n     /// static and looked up in the `tcx` for read access.  Writing to\n     /// a static creates a copy here, in the machine.\n-    alloc_map: FxHashMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n+    /// We have this in a RefCell to be able to cache when a new allocation\n+    /// for a static has to be created on a read access.\n+    alloc_map: MonoHashMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<M::PointerTag>)>,\n \n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n@@ -98,23 +104,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n-            alloc_map: FxHashMap::default(),\n+            alloc_map: MonoHashMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n             tcx,\n         }\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n-        self.tcx.alloc_map.lock().create_fn_alloc(instance).into()\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n+        Pointer::from(self.tcx.alloc_map.lock().create_fn_alloc(instance)).with_default_tag()\n     }\n \n-    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer {\n-        self.tcx.allocate_bytes(bytes).into()\n+    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer<M::PointerTag> {\n+        Pointer::from(self.tcx.allocate_bytes(bytes)).with_default_tag()\n     }\n \n     pub fn allocate_with(\n         &mut self,\n-        alloc: Allocation,\n+        alloc: Allocation<M::PointerTag>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, AllocId> {\n         let id = self.tcx.alloc_map.lock().reserve();\n@@ -127,19 +133,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer> {\n-        self.allocate_with(Allocation::undef(size, align), kind).map(Pointer::from)\n+    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n+        let ptr = Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?);\n+        Ok(ptr.with_default_tag())\n     }\n \n     pub fn reallocate(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         old_size: Size,\n         old_align: Align,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -160,7 +167,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Deallocate a local, or do nothing if that local has been made into a static\n-    pub fn deallocate_local(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n+    pub fn deallocate_local(&mut self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx> {\n         // The allocation might be already removed by static interning.\n         // This can only really happen in the CTFE instance, not in miri.\n         if self.alloc_map.contains_key(&ptr.alloc_id) {\n@@ -172,7 +179,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn deallocate(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n@@ -231,7 +238,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check that the pointer is aligned AND non-NULL. This supports ZSTs in two ways:\n     /// You can pass a scalar, and a `Pointer` does not have to actually still be allocated.\n-    pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n+    pub fn check_align(\n+        &self,\n+        ptr: Scalar<M::PointerTag>,\n+        required_align: Align\n+    ) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n             Scalar::Ptr(ptr) => {\n@@ -240,7 +251,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 // of some (potentially dead) allocation.\n                 if ptr.offset > size {\n                     return err!(PointerOutOfBounds {\n-                        ptr,\n+                        ptr: ptr.erase_tag(),\n                         access: true,\n                         allocation_size: size,\n                     });\n@@ -284,12 +295,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// If you want to check bounds before doing a memory access, be sure to\n     /// check the pointer one past the end of your access, then everything will\n     /// work out exactly.\n-    pub fn check_bounds_ptr(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds_ptr(&self, ptr: Pointer<M::PointerTag>, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset.bytes() > allocation_size {\n             return err!(PointerOutOfBounds {\n-                ptr,\n+                ptr: ptr.erase_tag(),\n                 access,\n                 allocation_size: Size::from_bytes(allocation_size),\n             });\n@@ -299,7 +310,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n     #[inline(always)]\n-    pub fn check_bounds(&self, ptr: Pointer, size: Size, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds(&self, ptr: Pointer<M::PointerTag>, size: Size, access: bool) -> EvalResult<'tcx> {\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_bounds_ptr(ptr.offset(size, &*self)?, access)\n     }\n@@ -311,11 +322,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_static_alloc(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         id: AllocId,\n-    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let def_id = match alloc {\n             Some(AllocType::Memory(mem)) => {\n-                return Ok(mem)\n+                return Ok(M::static_with_default_tag(mem))\n             }\n             Some(AllocType::Function(..)) => {\n                 return err!(DerefFunctionPointer)\n@@ -342,20 +353,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             EvalErrorKind::ReferencedConstant(err).into()\n         }).map(|const_val| {\n             if let ConstValue::ByRef(_, allocation, _) = const_val.val {\n-                allocation\n+                M::static_with_default_tag(allocation)\n             } else {\n                 bug!(\"Matching on non-ByRef static\")\n             }\n         })\n     }\n \n-    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n-        match self.alloc_map.get(&id) {\n-            // Normal alloc?\n-            Some(alloc) => Ok(&alloc.1),\n-            // Static. No need to make any copies, just provide read access to the global static\n-            // memory in tcx.\n-            None => Self::get_static_alloc(self.tcx, id),\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::PointerTag>> {\n+        // The error type of the inner closure here is somewhat funny.  We have two\n+        // ways of \"erroring\": An actual error, or because we got a reference from\n+        // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n+        // So the error type is `EvalResult<'tcx, &Allocation<M::PointerTag>>`.\n+        let a = self.alloc_map.get_or(id, || {\n+            let alloc = Self::get_static_alloc(self.tcx, id).map_err(Err)?;\n+            match alloc {\n+                Cow::Borrowed(alloc) => {\n+                    // We got a ref, cheaply return that as an \"error\"\n+                    Err(Ok(alloc))\n+                }\n+                Cow::Owned(alloc) => {\n+                    // Need to put it into the map and return a ref to that\n+                    let kind = M::STATIC_KIND.expect(\n+                        \"I got an owned allocation that I have to copy but the machine does \\\n+                            not expect that to happen\"\n+                    );\n+                    Ok((MemoryKind::Machine(kind), alloc))\n+                }\n+            }\n+        });\n+        // Now unpack that funny error type\n+        match a {\n+            Ok(a) => Ok(&a.1),\n+            Err(a) => a\n         }\n     }\n \n@@ -386,28 +416,34 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> EvalResult<'tcx, &mut Allocation> {\n-        // Static?\n-        if !self.alloc_map.contains_key(&id) {\n-            // Ask the machine for what to do\n-            if let Some(kind) = M::MUT_STATIC_KIND {\n-                // The machine supports mutating statics.  Make a copy, use that.\n-                self.deep_copy_static(id, MemoryKind::Machine(kind))?;\n-            } else {\n-                return err!(ModifiedConstantMemory)\n+    ) -> EvalResult<'tcx, &mut Allocation<M::PointerTag>> {\n+        Ok(match self.alloc_map.entry(id) {\n+            // Normal alloc?\n+            Entry::Occupied(alloc) => {\n+                let alloc = &mut alloc.into_mut().1;\n+                if alloc.mutability == Mutability::Immutable {\n+                    return err!(ModifiedConstantMemory);\n+                }\n+                alloc\n             }\n-        }\n-        // If we come here, we know the allocation is in our map\n-        let alloc = &mut self.alloc_map.get_mut(&id).unwrap().1;\n-        // See if we are allowed to mutate this\n-        if alloc.mutability == Mutability::Immutable {\n-            err!(ModifiedConstantMemory)\n-        } else {\n-            Ok(alloc)\n-        }\n+            // Static.\n+            Entry::Vacant(entry) => {\n+                // Need to make a copy, even if `get_static_alloc` is able\n+                // to give us a cheap reference.\n+                let alloc = Self::get_static_alloc(self.tcx, id)?;\n+                if alloc.mutability == Mutability::Immutable {\n+                    return err!(ModifiedConstantMemory);\n+                }\n+                let kind = M::STATIC_KIND.expect(\n+                    \"I got an owned allocation that I have to copy but the machine does \\\n+                        not expect that to happen\"\n+                );\n+                &mut entry.insert(Box::new((MemoryKind::Machine(kind), alloc.into_owned()))).1\n+            }\n+        })\n     }\n \n-    pub fn get_fn(&self, ptr: Pointer) -> EvalResult<'tcx, Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx, Instance<'tcx>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n@@ -418,108 +454,127 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    pub fn mark_immutable(&mut self, id: AllocId) -> EvalResult<'tcx> {\n+        self.get_mut(id)?.mutability = Mutability::Immutable;\n+        Ok(())\n+    }\n+\n     /// For debugging, print an allocation and all allocations it points to, recursively.\n     pub fn dump_alloc(&self, id: AllocId) {\n-        if !log_enabled!(::log::Level::Trace) {\n-            return;\n-        }\n         self.dump_allocs(vec![id]);\n     }\n \n+    fn dump_alloc_helper<Tag>(\n+        &self,\n+        allocs_seen: &mut FxHashSet<AllocId>,\n+        allocs_to_print: &mut VecDeque<AllocId>,\n+        mut msg: String,\n+        alloc: &Allocation<Tag>,\n+        extra: String,\n+    ) {\n+        use std::fmt::Write;\n+\n+        let prefix_len = msg.len();\n+        let mut relocations = vec![];\n+\n+        for i in 0..(alloc.bytes.len() as u64) {\n+            let i = Size::from_bytes(i);\n+            if let Some(&(_, target_id)) = alloc.relocations.get(&i) {\n+                if allocs_seen.insert(target_id) {\n+                    allocs_to_print.push_back(target_id);\n+                }\n+                relocations.push((i, target_id));\n+            }\n+            if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n+                // this `as usize` is fine, since `i` came from a `usize`\n+                write!(msg, \"{:02x} \", alloc.bytes[i.bytes() as usize]).unwrap();\n+            } else {\n+                msg.push_str(\"__ \");\n+            }\n+        }\n+\n+        trace!(\n+            \"{}({} bytes, alignment {}){}\",\n+            msg,\n+            alloc.bytes.len(),\n+            alloc.align.abi(),\n+            extra\n+        );\n+\n+        if !relocations.is_empty() {\n+            msg.clear();\n+            write!(msg, \"{:1$}\", \"\", prefix_len).unwrap(); // Print spaces.\n+            let mut pos = Size::ZERO;\n+            let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n+            for (i, target_id) in relocations {\n+                // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n+                write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes() as usize).unwrap();\n+                let target = format!(\"({})\", target_id);\n+                // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n+                write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n+                pos = i + self.pointer_size();\n+            }\n+            trace!(\"{}\", msg);\n+        }\n+    }\n+\n     /// For debugging, print a list of allocations and all allocations they point to, recursively.\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n         if !log_enabled!(::log::Level::Trace) {\n             return;\n         }\n-        use std::fmt::Write;\n         allocs.sort();\n         allocs.dedup();\n         let mut allocs_to_print = VecDeque::from(allocs);\n         let mut allocs_seen = FxHashSet::default();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n-            let prefix_len = msg.len();\n-            let mut relocations = vec![];\n-\n-            let (alloc, immutable) =\n-                // normal alloc?\n-                match self.alloc_map.get(&id) {\n-                    Some((kind, alloc)) => (alloc, match kind {\n+            let msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n+\n+            // normal alloc?\n+            match self.alloc_map.get(&id) {\n+                Some((kind, alloc)) => {\n+                    let extra = match kind {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n+                        MemoryKind::Vtable => \" (vtable)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n-                    }),\n-                    None => {\n-                        // static alloc?\n-                        match self.tcx.alloc_map.lock().get(id) {\n-                            Some(AllocType::Memory(a)) => (a, \" (immutable)\".to_owned()),\n-                            Some(AllocType::Function(func)) => {\n-                                trace!(\"{} {}\", msg, func);\n-                                continue;\n-                            }\n-                            Some(AllocType::Static(did)) => {\n-                                trace!(\"{} {:?}\", msg, did);\n-                                continue;\n-                            }\n-                            None => {\n-                                trace!(\"{} (deallocated)\", msg);\n-                                continue;\n-                            }\n+                    };\n+                    self.dump_alloc_helper(\n+                        &mut allocs_seen, &mut allocs_to_print,\n+                        msg, alloc, extra\n+                    );\n+                },\n+                None => {\n+                    // static alloc?\n+                    match self.tcx.alloc_map.lock().get(id) {\n+                        Some(AllocType::Memory(alloc)) => {\n+                            self.dump_alloc_helper(\n+                                &mut allocs_seen, &mut allocs_to_print,\n+                                msg, alloc, \" (immutable)\".to_owned()\n+                            );\n+                        }\n+                        Some(AllocType::Function(func)) => {\n+                            trace!(\"{} {}\", msg, func);\n+                        }\n+                        Some(AllocType::Static(did)) => {\n+                            trace!(\"{} {:?}\", msg, did);\n+                        }\n+                        None => {\n+                            trace!(\"{} (deallocated)\", msg);\n                         }\n-                    },\n-                };\n-\n-            for i in 0..(alloc.bytes.len() as u64) {\n-                let i = Size::from_bytes(i);\n-                if let Some(&target_id) = alloc.relocations.get(&i) {\n-                    if allocs_seen.insert(target_id) {\n-                        allocs_to_print.push_back(target_id);\n                     }\n-                    relocations.push((i, target_id));\n-                }\n-                if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n-                    // this `as usize` is fine, since `i` came from a `usize`\n-                    write!(msg, \"{:02x} \", alloc.bytes[i.bytes() as usize]).unwrap();\n-                } else {\n-                    msg.push_str(\"__ \");\n-                }\n-            }\n+                },\n+            };\n \n-            trace!(\n-                \"{}({} bytes, alignment {}){}\",\n-                msg,\n-                alloc.bytes.len(),\n-                alloc.align.abi(),\n-                immutable\n-            );\n-\n-            if !relocations.is_empty() {\n-                msg.clear();\n-                write!(msg, \"{:1$}\", \"\", prefix_len).unwrap(); // Print spaces.\n-                let mut pos = Size::ZERO;\n-                let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n-                for (i, target_id) in relocations {\n-                    // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n-                    write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes() as usize).unwrap();\n-                    let target = format!(\"({})\", target_id);\n-                    // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n-                    write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n-                    pos = i + self.pointer_size();\n-                }\n-                trace!(\"{}\", msg);\n-            }\n         }\n     }\n \n     pub fn leak_report(&self) -> usize {\n         trace!(\"### LEAK REPORT ###\");\n-        let mut_static_kind = M::MUT_STATIC_KIND.map(|k| MemoryKind::Machine(k));\n-        let leaks: Vec<_> = self.alloc_map\n-            .iter()\n-            .filter_map(|(&id, &(kind, _))|\n+        let static_kind = M::STATIC_KIND.map(|k| MemoryKind::Machine(k));\n+        let leaks: Vec<_> = self.alloc_map.filter_map_collect(|&id, &(kind, _)|\n                 // exclude mutable statics\n-                if Some(kind) == mut_static_kind { None } else { Some(id) } )\n-            .collect();\n+                if Some(kind) == static_kind { None } else { Some(id) } );\n         let n = leaks.len();\n         self.dump_allocs(leaks);\n         n\n@@ -533,7 +588,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// `get_bytes_with_undef_and_ptr` instead,\n     fn get_bytes_internal(\n         &self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         size: Size,\n         align: Align,\n         check_defined_and_ptr: bool,\n@@ -558,7 +613,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     #[inline]\n-    fn get_bytes(&self, ptr: Pointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        size: Size,\n+        align: Align\n+    ) -> EvalResult<'tcx, &[u8]> {\n         self.get_bytes_internal(ptr, size, align, true)\n     }\n \n@@ -567,7 +627,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn get_bytes_with_undef_and_ptr(\n         &self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         size: Size,\n         align: Align\n     ) -> EvalResult<'tcx, &[u8]> {\n@@ -578,7 +638,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// so be sure to actually put data there!\n     fn get_bytes_mut(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n@@ -597,8 +657,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n }\n \n-/// Reading and writing\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+/// Interning (for CTFE)\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx, PointerTag=()>> Memory<'a, 'mir, 'tcx, M> {\n     /// mark an allocation as static and initialized, either mutable or not\n     pub fn intern_static(\n         &mut self,\n@@ -614,14 +674,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let (kind, mut alloc) = self.alloc_map.remove(&alloc_id).unwrap();\n         match kind {\n             MemoryKind::Machine(_) => bug!(\"Static cannot refer to machine memory\"),\n-            MemoryKind::Stack => {},\n+            MemoryKind::Stack | MemoryKind::Vtable => {},\n         }\n         // ensure llvm knows not to put this into immutable memory\n         alloc.mutability = mutability;\n         let alloc = self.tcx.intern_const_alloc(alloc);\n         self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n         // recurse into inner allocations\n-        for &alloc in alloc.relocations.values() {\n+        for &(_, alloc) in alloc.relocations.values() {\n             // FIXME: Reusing the mutability here is likely incorrect.  It is originally\n             // determined via `is_freeze`, and data is considered frozen if there is no\n             // `UnsafeCell` *immediately* in that data -- however, this search stops\n@@ -635,28 +695,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         Ok(())\n     }\n+}\n \n-    /// The alloc_id must refer to a (mutable) static; a deep copy of that\n-    /// static is made into this memory.\n-    fn deep_copy_static(\n-        &mut self,\n-        id: AllocId,\n-        kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx> {\n-        let alloc = Self::get_static_alloc(self.tcx, id)?;\n-        if alloc.mutability == Mutability::Immutable {\n-            return err!(ModifiedConstantMemory);\n-        }\n-        let old = self.alloc_map.insert(id, (kind, alloc.clone()));\n-        assert!(old.is_none(), \"deep_copy_static: must not overwrite existing memory\");\n-        Ok(())\n-    }\n-\n+/// Reading and writing\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn copy(\n         &mut self,\n-        src: Scalar,\n+        src: Scalar<M::PointerTag>,\n         src_align: Align,\n-        dest: Scalar,\n+        dest: Scalar<M::PointerTag>,\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n@@ -666,9 +713,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn copy_repeatedly(\n         &mut self,\n-        src: Scalar,\n+        src: Scalar<M::PointerTag>,\n         src_align: Align,\n-        dest: Scalar,\n+        dest: Scalar<M::PointerTag>,\n         dest_align: Align,\n         size: Size,\n         length: u64,\n@@ -695,9 +742,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 new_relocations.extend(\n                     relocations\n                     .iter()\n-                    .map(|&(offset, alloc_id)| {\n+                    .map(|&(offset, reloc)| {\n                     (offset + dest.offset - src.offset + (i * size * relocations.len() as u64),\n-                    alloc_id)\n+                     reloc)\n                     })\n                 );\n             }\n@@ -747,7 +794,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_c_str(&self, ptr: Pointer) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_c_str(&self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -758,11 +805,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 self.check_defined(ptr, p1)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             }\n-            None => err!(UnterminatedCString(ptr)),\n+            None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: Scalar, size: Size) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(&self, ptr: Scalar<M::PointerTag>, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         if size.bytes() == 0 {\n@@ -772,7 +819,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.get_bytes(ptr.to_ptr()?, size, align)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Scalar, src: &[u8]) -> EvalResult<'tcx> {\n+    pub fn write_bytes(&mut self, ptr: Scalar<M::PointerTag>, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         if src.is_empty() {\n@@ -784,7 +831,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Scalar, val: u8, count: Size) -> EvalResult<'tcx> {\n+    pub fn write_repeat(\n+        &mut self,\n+        ptr: Scalar<M::PointerTag>,\n+        val: u8,\n+        count: Size\n+    ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         if count.bytes() == 0 {\n@@ -801,10 +853,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Read a *non-ZST* scalar\n     pub fn read_scalar(\n         &self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         ptr_align: Align,\n         size: Size\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n         // get_bytes_unchecked tests alignment and relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(\n             ptr, size, ptr_align.min(self.int_align(size))\n@@ -825,8 +877,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => {\n-                    let ptr = Pointer::new(alloc_id, Size::from_bytes(bits as u64));\n+                Some(&(tag, alloc_id)) => {\n+                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits as u64), tag);\n                     return Ok(ScalarMaybeUndef::Scalar(ptr.into()))\n                 }\n                 None => {},\n@@ -836,17 +888,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n-    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align)\n-        -> EvalResult<'tcx, ScalarMaybeUndef> {\n+    pub fn read_ptr_sized(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        ptr_align: Align\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n     /// Write a *non-ZST* scalar\n     pub fn write_scalar(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         ptr_align: Align,\n-        val: ScalarMaybeUndef,\n+        val: ScalarMaybeUndef<M::PointerTag>,\n         type_size: Size,\n     ) -> EvalResult<'tcx> {\n         let val = match val {\n@@ -880,7 +935,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Scalar::Ptr(val) => {\n                 self.get_mut(ptr.alloc_id)?.relocations.insert(\n                     ptr.offset,\n-                    val.alloc_id,\n+                    (val.tag, val.alloc_id),\n                 );\n             }\n             _ => {}\n@@ -889,8 +944,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef)\n-        -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized(\n+        &mut self,\n+        ptr: Pointer<M::PointerTag>,\n+        ptr_align: Align,\n+        val: ScalarMaybeUndef<M::PointerTag>\n+    ) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n         self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n     }\n@@ -915,9 +974,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Return all relocations overlapping with the given ptr-offset pair.\n     fn relocations(\n         &self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[(Size, AllocId)]> {\n+    ) -> EvalResult<'tcx, &[(Size, (M::PointerTag, AllocId))]> {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n@@ -927,7 +986,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check that there ar eno relocations overlapping with the given range.\n     #[inline(always)]\n-    fn check_relocations(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+    fn check_relocations(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n         if self.relocations(ptr, size)?.len() != 0 {\n             err!(ReadPointerAsBytes)\n         } else {\n@@ -941,7 +1000,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n-    fn clear_relocations(&mut self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+    fn clear_relocations(&mut self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n@@ -976,7 +1035,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Error if there are relocations overlapping with the egdes of the\n     /// given memory range.\n     #[inline]\n-    fn check_relocation_edges(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+    fn check_relocation_edges(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n         self.check_relocations(ptr, Size::ZERO)?;\n         self.check_relocations(ptr.offset(size, self)?, Size::ZERO)?;\n         Ok(())\n@@ -988,8 +1047,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     // FIXME: Add a fast version for the common, nonoverlapping case\n     fn copy_undef_mask(\n         &mut self,\n-        src: Pointer,\n-        dest: Pointer,\n+        src: Pointer<M::PointerTag>,\n+        dest: Pointer<M::PointerTag>,\n         size: Size,\n         repeat: u64,\n     ) -> EvalResult<'tcx> {\n@@ -1016,7 +1075,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n     #[inline]\n-    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         alloc.undef_mask.is_range_defined(\n             ptr.offset,\n@@ -1026,7 +1085,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: Pointer<M::PointerTag>,\n         size: Size,\n         new_state: bool,\n     ) -> EvalResult<'tcx> {"}, {"sha": "1cc144cd7915f1d6a84b595b8bc23f694b37eed5", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -23,6 +23,7 @@ mod terminator;\n mod traits;\n mod validity;\n mod intrinsics;\n+mod mono_hash_map;\n \n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,\n@@ -37,3 +38,5 @@ pub use self::machine::Machine;\n pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n \n pub use self::validity::RefTracking;\n+\n+pub use self::mono_hash_map::MonoHashMap;"}, {"sha": "ef9a84fd98d4f14893db85326fb51a70e259f5eb", "filename": "src/librustc_mir/interpret/mono_hash_map.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmono_hash_map.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -0,0 +1,82 @@\n+//! This is a \"monotonic HashMap\": A HashMap that, when shared, can be pushed to but not\n+//! otherwise mutated.  We also Box items in the map. This means we can safely provide\n+//! shared references into existing items in the HashMap, because they will not be dropped\n+//! (from being removed) or moved (because they are boxed).\n+//! The API is is completely tailored to what `memory.rs` needs. It is still in\n+//! a separate file to minimize the amount of code that has to care about the unsafety.\n+\n+use std::collections::hash_map::Entry;\n+use std::cell::RefCell;\n+use std::hash::Hash;\n+use std::borrow::Borrow;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+#[derive(Debug, Clone)]\n+pub struct MonoHashMap<K: Hash + Eq, V>(RefCell<FxHashMap<K, Box<V>>>);\n+\n+impl<K: Hash + Eq, V> Default for MonoHashMap<K, V> {\n+    fn default() -> Self {\n+        MonoHashMap(RefCell::new(Default::default()))\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> MonoHashMap<K, V> {\n+    pub fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+        where K: Borrow<Q>\n+    {\n+        self.0.get_mut().contains_key(k)\n+    }\n+\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V>\n+    {\n+        self.0.get_mut().insert(k, Box::new(v)).map(|x| *x)\n+    }\n+\n+    pub fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+        where K: Borrow<Q>\n+    {\n+        self.0.get_mut().remove(k).map(|x| *x)\n+    }\n+\n+    pub fn entry(&mut self, k: K) -> Entry<K, Box<V>>\n+    {\n+        self.0.get_mut().entry(k)\n+    }\n+\n+    pub fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n+        self.0.borrow()\n+            .iter()\n+            .filter_map(move |(k, v)| f(k, &*v))\n+            .collect()\n+    }\n+\n+    /// The most interesting method: Providing a shared ref without\n+    /// holding the `RefCell` open, and inserting new data if the key\n+    /// is not used yet.\n+    /// `vacant` is called if the key is not found in the map;\n+    /// if it returns a reference, that is used directly, if it\n+    /// returns owned data, that is put into the map and returned.\n+    pub fn get_or<E>(\n+        &self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&V, E> {\n+        let val: *const V = match self.0.borrow_mut().entry(k) {\n+            Entry::Occupied(entry) => &**entry.get(),\n+            Entry::Vacant(entry) => &**entry.insert(Box::new(vacant()?)),\n+        };\n+        // This is safe because `val` points into a `Box`, that we know will not move and\n+        // will also not be dropped as long as the shared reference `self` is live.\n+        unsafe { Ok(&*val) }\n+    }\n+\n+    pub fn get<Q: ?Sized + Hash + Eq>(&self, k: &Q) -> Option<&V>\n+        where K: Borrow<Q>\n+    {\n+        let val: *const V = &**self.0.borrow().get(k)?;\n+        // This is safe because `val` points into a `Box`, that we know will not move and\n+        // will also not be dropped as long as the shared reference `self` is live.\n+        unsafe { Some(&*val) }\n+    }\n+}"}, {"sha": "506287f36fa7935ec44605494937fb70964a82ae", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 166, "deletions": 65, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -25,29 +25,50 @@ use rustc::mir::interpret::{\n use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum ScalarMaybeUndef<Id=AllocId> {\n-    Scalar(Scalar<Id>),\n+pub enum ScalarMaybeUndef<Tag=(),Id=AllocId> {\n+    Scalar(Scalar<Tag,Id>),\n     Undef,\n }\n \n-impl From<Scalar> for ScalarMaybeUndef {\n+impl<Tag> From<Scalar<Tag>> for ScalarMaybeUndef<Tag> {\n     #[inline(always)]\n-    fn from(s: Scalar) -> Self {\n+    fn from(s: Scalar<Tag>) -> Self {\n         ScalarMaybeUndef::Scalar(s)\n     }\n }\n \n-impl<'tcx> ScalarMaybeUndef {\n+impl<'tcx> ScalarMaybeUndef<()> {\n     #[inline]\n-    pub fn not_undef(self) -> EvalResult<'static, Scalar> {\n+    pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n+        where Tag: Default\n+    {\n+        match self {\n+            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.with_default_tag()),\n+            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n+        }\n+    }\n+}\n+\n+impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n+    #[inline]\n+    pub fn erase_tag(self) -> ScalarMaybeUndef\n+    {\n+        match self {\n+            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.erase_tag()),\n+            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn not_undef(self) -> EvalResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUndef::Undef => err!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         self.not_undef()?.to_ptr()\n     }\n \n@@ -126,39 +147,62 @@ impl<'tcx> ScalarMaybeUndef {\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Value`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Value<Id=AllocId> {\n-    Scalar(ScalarMaybeUndef<Id>),\n-    ScalarPair(ScalarMaybeUndef<Id>, ScalarMaybeUndef<Id>),\n+pub enum Value<Tag=(),Id=AllocId> {\n+    Scalar(ScalarMaybeUndef<Tag,Id>),\n+    ScalarPair(ScalarMaybeUndef<Tag,Id>, ScalarMaybeUndef<Tag,Id>),\n }\n \n-impl<'tcx> Value {\n+impl Value {\n+    #[inline]\n+    pub fn with_default_tag<Tag>(self) -> Value<Tag>\n+        where Tag: Default\n+    {\n+        match self {\n+            Value::Scalar(x) => Value::Scalar(x.with_default_tag()),\n+            Value::ScalarPair(x, y) =>\n+                Value::ScalarPair(x.with_default_tag(), y.with_default_tag()),\n+        }\n+    }\n+}\n+\n+impl<'tcx, Tag> Value<Tag> {\n+    #[inline]\n+    pub fn erase_tag(self) -> Value\n+    {\n+        match self {\n+            Value::Scalar(x) => Value::Scalar(x.erase_tag()),\n+            Value::ScalarPair(x, y) =>\n+                Value::ScalarPair(x.erase_tag(), y.erase_tag()),\n+        }\n+    }\n+\n     pub fn new_slice(\n-        val: Scalar,\n+        val: Scalar<Tag>,\n         len: u64,\n         cx: impl HasDataLayout\n     ) -> Self {\n         Value::ScalarPair(val.into(), Scalar::from_uint(len, cx.data_layout().pointer_size).into())\n     }\n \n-    pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n+    pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>) -> Self {\n         Value::ScalarPair(val.into(), Scalar::Ptr(vtable).into())\n     }\n \n     #[inline]\n-    pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef {\n+    pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef<Tag> {\n         match self {\n             Value::Scalar(val) => val,\n             Value::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n         }\n     }\n \n     #[inline]\n-    pub fn to_scalar(self) -> EvalResult<'tcx, Scalar> {\n+    pub fn to_scalar(self) -> EvalResult<'tcx, Scalar<Tag>> {\n         self.to_scalar_or_undef().not_undef()\n     }\n \n     #[inline]\n-    pub fn to_scalar_pair(self) -> EvalResult<'tcx, (Scalar, Scalar)> {\n+    pub fn to_scalar_pair(self) -> EvalResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n         match self {\n             Value::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n             Value::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n@@ -168,7 +212,7 @@ impl<'tcx> Value {\n     /// Convert the value into a pointer (or a pointer-sized integer).\n     /// Throws away the second half of a ScalarPair!\n     #[inline]\n-    pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar> {\n+    pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar<Tag>> {\n         match self {\n             Value::Scalar(ptr) |\n             Value::ScalarPair(ptr, _) => ptr.not_undef(),\n@@ -179,15 +223,15 @@ impl<'tcx> Value {\n // ScalarPair needs a type to interpret, so we often have a value and a type together\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n-pub struct ValTy<'tcx> {\n-    value: Value,\n+pub struct ValTy<'tcx, Tag=()> {\n+    value: Value<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n-    type Target = Value;\n+impl<'tcx, Tag> ::std::ops::Deref for ValTy<'tcx, Tag> {\n+    type Target = Value<Tag>;\n     #[inline(always)]\n-    fn deref(&self) -> &Value {\n+    fn deref(&self) -> &Value<Tag> {\n         &self.value\n     }\n }\n@@ -196,14 +240,37 @@ impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n /// or still in memory.  The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Operand<Id=AllocId> {\n-    Immediate(Value<Id>),\n-    Indirect(MemPlace<Id>),\n+pub enum Operand<Tag=(), Id=AllocId> {\n+    Immediate(Value<Tag, Id>),\n+    Indirect(MemPlace<Tag, Id>),\n }\n \n impl Operand {\n     #[inline]\n-    pub fn to_mem_place(self) -> MemPlace {\n+    pub fn with_default_tag<Tag>(self) -> Operand<Tag>\n+        where Tag: Default\n+    {\n+        match self {\n+            Operand::Immediate(x) => Operand::Immediate(x.with_default_tag()),\n+            Operand::Indirect(x) => Operand::Indirect(x.with_default_tag()),\n+        }\n+    }\n+}\n+\n+impl<Tag> Operand<Tag> {\n+    #[inline]\n+    pub fn erase_tag(self) -> Operand\n+    {\n+        match self {\n+            Operand::Immediate(x) => Operand::Immediate(x.erase_tag()),\n+            Operand::Indirect(x) => Operand::Indirect(x.erase_tag()),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_mem_place(self) -> MemPlace<Tag>\n+        where Tag: ::std::fmt::Debug\n+    {\n         match self {\n             Operand::Indirect(mplace) => mplace,\n             _ => bug!(\"to_mem_place: expected Operand::Indirect, got {:?}\", self),\n@@ -212,7 +279,9 @@ impl Operand {\n     }\n \n     #[inline]\n-    pub fn to_immediate(self) -> Value {\n+    pub fn to_immediate(self) -> Value<Tag>\n+        where Tag: ::std::fmt::Debug\n+    {\n         match self {\n             Operand::Immediate(val) => val,\n             _ => bug!(\"to_immediate: expected Operand::Immediate, got {:?}\", self),\n@@ -222,32 +291,32 @@ impl Operand {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct OpTy<'tcx> {\n-    crate op: Operand, // ideally we'd make this private, but const_prop needs this\n+pub struct OpTy<'tcx, Tag=()> {\n+    crate op: Operand<Tag>, // ideally we'd make this private, but const_prop needs this\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<'tcx> ::std::ops::Deref for OpTy<'tcx> {\n-    type Target = Operand;\n+impl<'tcx, Tag> ::std::ops::Deref for OpTy<'tcx, Tag> {\n+    type Target = Operand<Tag>;\n     #[inline(always)]\n-    fn deref(&self) -> &Operand {\n+    fn deref(&self) -> &Operand<Tag> {\n         &self.op\n     }\n }\n \n-impl<'tcx> From<MPlaceTy<'tcx>> for OpTy<'tcx> {\n+impl<'tcx, Tag: Copy> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    fn from(mplace: MPlaceTy<'tcx>) -> Self {\n+    fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n         OpTy {\n             op: Operand::Indirect(*mplace),\n             layout: mplace.layout\n         }\n     }\n }\n \n-impl<'tcx> From<ValTy<'tcx>> for OpTy<'tcx> {\n+impl<'tcx, Tag> From<ValTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    fn from(val: ValTy<'tcx>) -> Self {\n+    fn from(val: ValTy<'tcx, Tag>) -> Self {\n         OpTy {\n             op: Operand::Immediate(val.value),\n             layout: val.layout\n@@ -256,18 +325,36 @@ impl<'tcx> From<ValTy<'tcx>> for OpTy<'tcx> {\n }\n \n // Validation needs to hash OpTy, but we cannot hash Layout -- so we just hash the type\n-impl<'tcx> Hash for OpTy<'tcx> {\n+impl<'tcx, Tag> Hash for OpTy<'tcx, Tag>\n+    where Tag: Hash\n+{\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.op.hash(state);\n         self.layout.ty.hash(state);\n     }\n }\n-impl<'tcx> PartialEq for OpTy<'tcx> {\n+impl<'tcx, Tag> PartialEq for OpTy<'tcx, Tag>\n+    where Tag: PartialEq\n+{\n     fn eq(&self, other: &Self) -> bool {\n         self.op == other.op && self.layout.ty == other.layout.ty\n     }\n }\n-impl<'tcx> Eq for OpTy<'tcx> {}\n+impl<'tcx, Tag> Eq for OpTy<'tcx, Tag>\n+    where Tag: Eq\n+{}\n+\n+impl<'tcx, Tag> OpTy<'tcx, Tag>\n+{\n+    #[inline]\n+    pub fn erase_tag(self) -> OpTy<'tcx>\n+    {\n+        OpTy {\n+            op: self.op.erase_tag(),\n+            layout: self.layout,\n+        }\n+    }\n+}\n \n // Use the existing layout if given (but sanity check in debug mode),\n // or compute the layout.\n@@ -295,8 +382,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Return None if the layout does not permit loading this as a value.\n     pub(super) fn try_read_value_from_mplace(\n         &self,\n-        mplace: MPlaceTy<'tcx>,\n-    ) -> EvalResult<'tcx, Option<Value>> {\n+        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, Option<Value<M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Dont touch unsized\n             return Ok(None);\n@@ -339,8 +426,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// in a `Value`, not on which data is stored there currently.\n     pub(crate) fn try_read_value(\n         &self,\n-        src: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, Result<Value, MemPlace>> {\n+        src: OpTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, Result<Value<M::PointerTag>, MemPlace<M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_value_from_mplace(mplace)? {\n@@ -355,7 +442,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     /// Read a value from a place, asserting that that is possible with the given layout.\n     #[inline(always)]\n-    pub fn read_value(&self, op: OpTy<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n+    pub fn read_value(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>\n+    ) -> EvalResult<'tcx, ValTy<'tcx, M::PointerTag>> {\n         if let Ok(value) = self.try_read_value(op)? {\n             Ok(ValTy { value, layout: op.layout })\n         } else {\n@@ -364,7 +454,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n     /// Read a scalar from a place\n-    pub fn read_scalar(&self, op: OpTy<'tcx>) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+    pub fn read_scalar(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n         match *self.read_value(op)? {\n             Value::ScalarPair(..) => bug!(\"got ScalarPair for type: {:?}\", op.layout.ty),\n             Value::Scalar(val) => Ok(val),\n@@ -374,7 +467,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     // Turn the MPlace into a string (must already be dereferenced!)\n     pub fn read_str(\n         &self,\n-        mplace: MPlaceTy<'tcx>,\n+        mplace: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n@@ -383,7 +476,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(str)\n     }\n \n-    pub fn uninit_operand(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Operand> {\n+    pub fn uninit_operand(\n+        &mut self,\n+        layout: TyLayout<'tcx>\n+    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n         // This decides which types we will use the Immediate optimization for, and hence should\n         // match what `try_read_value` and `eval_place_to_op` support.\n         if layout.is_zst() {\n@@ -410,9 +506,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Projection functions\n     pub fn operand_field(\n         &self,\n-        op: OpTy<'tcx>,\n+        op: OpTy<'tcx, M::PointerTag>,\n         field: u64,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace() {\n             Ok(mplace) => {\n                 // The easy case\n@@ -445,9 +541,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     pub fn operand_downcast(\n         &self,\n-        op: OpTy<'tcx>,\n+        op: OpTy<'tcx, M::PointerTag>,\n         variant: usize,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         Ok(match op.try_as_mplace() {\n             Ok(mplace) => {\n@@ -464,18 +560,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     // will always be a MemPlace.\n     pub(super) fn deref_operand(\n         &self,\n-        src: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        src: OpTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_value(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n         Ok(self.ref_to_mplace(val)?)\n     }\n \n     pub fn operand_projection(\n         &self,\n-        base: OpTy<'tcx>,\n+        base: OpTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::PlaceElem<'tcx>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n@@ -503,7 +599,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         let op = match *mir_place {\n             Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n@@ -533,7 +629,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         mir_op: &mir::Operand<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Operand::*;\n         let op = match *mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n@@ -558,7 +654,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub(super) fn eval_operands(\n         &self,\n         ops: &[mir::Operand<'tcx>],\n-    ) -> EvalResult<'tcx, Vec<OpTy<'tcx>>> {\n+    ) -> EvalResult<'tcx, Vec<OpTy<'tcx, M::PointerTag>>> {\n         ops.into_iter()\n             .map(|op| self.eval_operand(op, None))\n             .collect()\n@@ -568,7 +664,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub(super) fn const_value_to_op(\n         &self,\n         val: ConstValue<'tcx>,\n-    ) -> EvalResult<'tcx, Operand> {\n+    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n         trace!(\"const_value_to_op: {:?}\", val);\n         match val {\n             ConstValue::Unevaluated(def_id, substs) => {\n@@ -581,31 +677,36 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ConstValue::ByRef(id, alloc, offset) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n-                Ok(Operand::Indirect(MemPlace::from_ptr(Pointer::new(id, offset), alloc.align)))\n+                Ok(Operand::Indirect(\n+                    MemPlace::from_ptr(Pointer::new(id, offset), alloc.align)\n+                ).with_default_tag())\n             },\n             ConstValue::ScalarPair(a, b) =>\n-                Ok(Operand::Immediate(Value::ScalarPair(a.into(), b.into()))),\n+                Ok(Operand::Immediate(Value::ScalarPair(a.into(), b.into())).with_default_tag()),\n             ConstValue::Scalar(x) =>\n-                Ok(Operand::Immediate(Value::Scalar(x.into()))),\n+                Ok(Operand::Immediate(Value::Scalar(x.into())).with_default_tag()),\n         }\n     }\n     pub fn const_to_op(\n         &self,\n         cnst: &ty::Const<'tcx>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let op = self.const_value_to_op(cnst.val)?;\n         Ok(OpTy { op, layout: self.layout_of(cnst.ty)? })\n     }\n \n-    pub(super) fn global_to_op(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n+    pub(super) fn global_to_op(\n+        &self,\n+        gid: GlobalId<'tcx>\n+    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n         let cv = self.const_eval(gid)?;\n         self.const_value_to_op(cv.val)\n     }\n \n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant(\n         &self,\n-        rval: OpTy<'tcx>,\n+        rval: OpTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, (u128, usize)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n         if rval.layout.abi.is_uninhabited() {"}, {"sha": "5f4bafc39f3deec8aa57efb12157d67c36fd7a14", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -24,9 +24,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ValTy<'tcx>,\n-        right: ValTy<'tcx>,\n-        dest: PlaceTy<'tcx>,\n+        left: ValTy<'tcx, M::PointerTag>,\n+        right: ValTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binary_op_val(op, left, right)?;\n         let val = Value::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n@@ -38,9 +38,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn binop_ignore_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ValTy<'tcx>,\n-        right: ValTy<'tcx>,\n-        dest: PlaceTy<'tcx>,\n+        left: ValTy<'tcx, M::PointerTag>,\n+        right: ValTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         let (val, _overflowed) = self.binary_op_val(op, left, right)?;\n         self.write_scalar(val, dest)\n@@ -53,7 +53,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -73,7 +73,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -98,7 +98,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // passing in raw bits\n         l: u128,\n         r: u128,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         macro_rules! float_math {\n@@ -138,7 +138,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         left_layout: TyLayout<'tcx>,\n         r: u128,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         // Shift ops can have an RHS with a different numeric type.\n@@ -288,9 +288,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn binary_op_val(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ValTy<'tcx>,\n-        right: ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        left: ValTy<'tcx, M::PointerTag>,\n+        right: ValTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         self.binary_op(\n             bin_op,\n             left.to_scalar()?, left.layout,\n@@ -302,11 +302,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<M::PointerTag>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<M::PointerTag>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, left, left_layout.ty, right, right_layout.ty);\n \n@@ -352,9 +352,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: Scalar,\n+        val: Scalar<M::PointerTag>,\n         layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar> {\n+    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;"}, {"sha": "988711e2f346e16dd822f9fa3824481dc38bc38e", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 111, "deletions": 78, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -13,6 +13,7 @@\n //! All high-level functions to write to memory work on places as destinations.\n \n use std::convert::TryFrom;\n+use std::hash::Hash;\n \n use rustc::mir;\n use rustc::ty::{self, Ty};\n@@ -24,22 +25,22 @@ use rustc::mir::interpret::{\n use super::{EvalContext, Machine, Value, ValTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct MemPlace<Id=AllocId> {\n+pub struct MemPlace<Tag=(), Id=AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n     /// However, it may never be undef.\n-    pub ptr: Scalar<Id>,\n+    pub ptr: Scalar<Tag, Id>,\n     pub align: Align,\n     /// Metadata for unsized places.  Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g. `extern type`).\n-    pub extra: Option<Scalar<Id>>,\n+    pub extra: Option<Scalar<Tag, Id>>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Place<Id=AllocId> {\n+pub enum Place<Tag=(), Id=AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n-    Ptr(MemPlace<Id>),\n+    Ptr(MemPlace<Tag, Id>),\n \n     /// To support alloc-free locals, we are able to write directly to a local.\n     /// (Without that optimization, we'd just always be a `MemPlace`.)\n@@ -50,37 +51,37 @@ pub enum Place<Id=AllocId> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct PlaceTy<'tcx> {\n-    place: Place,\n+pub struct PlaceTy<'tcx, Tag=()> {\n+    place: Place<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<'tcx> ::std::ops::Deref for PlaceTy<'tcx> {\n-    type Target = Place;\n+impl<'tcx, Tag> ::std::ops::Deref for PlaceTy<'tcx, Tag> {\n+    type Target = Place<Tag>;\n     #[inline(always)]\n-    fn deref(&self) -> &Place {\n+    fn deref(&self) -> &Place<Tag> {\n         &self.place\n     }\n }\n \n /// A MemPlace with its layout. Constructing it is only possible in this module.\n #[derive(Copy, Clone, Debug)]\n-pub struct MPlaceTy<'tcx> {\n-    mplace: MemPlace,\n+pub struct MPlaceTy<'tcx, Tag=()> {\n+    mplace: MemPlace<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<'tcx> ::std::ops::Deref for MPlaceTy<'tcx> {\n-    type Target = MemPlace;\n+impl<'tcx, Tag> ::std::ops::Deref for MPlaceTy<'tcx, Tag> {\n+    type Target = MemPlace<Tag>;\n     #[inline(always)]\n-    fn deref(&self) -> &MemPlace {\n+    fn deref(&self) -> &MemPlace<Tag> {\n         &self.mplace\n     }\n }\n \n-impl<'tcx> From<MPlaceTy<'tcx>> for PlaceTy<'tcx> {\n+impl<'tcx, Tag> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n-    fn from(mplace: MPlaceTy<'tcx>) -> Self {\n+    fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n         PlaceTy {\n             place: Place::Ptr(mplace.mplace),\n             layout: mplace.layout\n@@ -89,8 +90,31 @@ impl<'tcx> From<MPlaceTy<'tcx>> for PlaceTy<'tcx> {\n }\n \n impl MemPlace {\n+    #[inline]\n+    pub fn with_default_tag<Tag>(self) -> MemPlace<Tag>\n+        where Tag: Default\n+    {\n+        MemPlace {\n+            ptr: self.ptr.with_default_tag(),\n+            align: self.align,\n+            extra: self.extra.map(Scalar::with_default_tag),\n+        }\n+    }\n+}\n+\n+impl<Tag> MemPlace<Tag> {\n+    #[inline]\n+    pub fn erase_tag(self) -> MemPlace\n+    {\n+        MemPlace {\n+            ptr: self.ptr.erase_tag(),\n+            align: self.align,\n+            extra: self.extra.map(Scalar::erase_tag),\n+        }\n+    }\n+\n     #[inline(always)]\n-    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n+    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n         MemPlace {\n             ptr,\n             align,\n@@ -99,19 +123,19 @@ impl MemPlace {\n     }\n \n     #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n+    pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n         Self::from_scalar_ptr(ptr.into(), align)\n     }\n \n     #[inline(always)]\n-    pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n-        assert_eq!(self.extra, None);\n+    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n+        assert!(self.extra.is_none());\n         (self.ptr, self.align)\n     }\n \n     /// Extract the ptr part of the mplace\n     #[inline(always)]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         // At this point, we forget about the alignment information --\n         // the place has been turned into a reference, and no matter where it came from,\n         // it now must be aligned.\n@@ -120,7 +144,7 @@ impl MemPlace {\n \n     /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n-    pub fn to_ref(self) -> Value {\n+    pub fn to_ref(self) -> Value<Tag> {\n         // We ignore the alignment of the place here -- special handling for packed structs ends\n         // at the `&` operator.\n         match self.extra {\n@@ -130,7 +154,7 @@ impl MemPlace {\n     }\n }\n \n-impl<'tcx> MPlaceTy<'tcx> {\n+impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n     pub fn dangling(layout: TyLayout<'tcx>, cx: impl HasDataLayout) -> Self {\n@@ -144,7 +168,7 @@ impl<'tcx> MPlaceTy<'tcx> {\n     }\n \n     #[inline]\n-    fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n+    fn from_aligned_ptr(ptr: Pointer<Tag>, layout: TyLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align), layout }\n     }\n \n@@ -154,7 +178,7 @@ impl<'tcx> MPlaceTy<'tcx> {\n             // We need to consult `extra` metadata\n             match self.layout.ty.sty {\n                 ty::Slice(..) | ty::Str =>\n-                    return self.extra.unwrap().to_usize(cx),\n+                    return self.mplace.extra.unwrap().to_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -168,48 +192,48 @@ impl<'tcx> MPlaceTy<'tcx> {\n     }\n \n     #[inline]\n-    pub(super) fn vtable(self) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn vtable(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         match self.layout.ty.sty {\n-            ty::Dynamic(..) => self.extra.unwrap().to_ptr(),\n+            ty::Dynamic(..) => self.mplace.extra.unwrap().to_ptr(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n }\n \n-impl<'tcx> OpTy<'tcx> {\n+impl<'tcx, Tag: ::std::fmt::Debug> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx>, Value> {\n-        match *self {\n+    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Value<Tag>> {\n+        match self.op {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n             Operand::Immediate(value) => Err(value),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn to_mem_place(self) -> MPlaceTy<'tcx> {\n+    pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace().unwrap()\n     }\n }\n \n-impl<'tcx> Place {\n+impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline]\n     pub fn null(cx: impl HasDataLayout) -> Self {\n         Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1, 1).unwrap())\n     }\n \n     #[inline]\n-    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n+    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n         Place::Ptr(MemPlace::from_scalar_ptr(ptr, align))\n     }\n \n     #[inline]\n-    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n+    pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n         Place::Ptr(MemPlace::from_ptr(ptr, align))\n     }\n \n     #[inline]\n-    pub fn to_mem_place(self) -> MemPlace {\n+    pub fn to_mem_place(self) -> MemPlace<Tag> {\n         match self {\n             Place::Ptr(mplace) => mplace,\n             _ => bug!(\"to_mem_place: expected Place::Ptr, got {:?}\", self),\n@@ -218,35 +242,42 @@ impl<'tcx> Place {\n     }\n \n     #[inline]\n-    pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n+    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n         self.to_mem_place().to_scalar_ptr_align()\n     }\n \n     #[inline]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         self.to_mem_place().to_ptr()\n     }\n }\n \n-impl<'tcx> PlaceTy<'tcx> {\n+impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline]\n     pub fn null(cx: impl HasDataLayout, layout: TyLayout<'tcx>) -> Self {\n         PlaceTy { place: Place::from_scalar_ptr(Scalar::ptr_null(cx), layout.align), layout }\n     }\n \n     #[inline]\n-    pub fn to_mem_place(self) -> MPlaceTy<'tcx> {\n+    pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         MPlaceTy { mplace: self.place.to_mem_place(), layout: self.layout }\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+// separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n+impl\n+    <'a, 'mir, 'tcx,\n+        Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n+        M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>\n+    >\n+    EvalContext<'a, 'mir, 'tcx, M>\n+{\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`.\n     pub fn ref_to_mplace(\n-        &self, val: ValTy<'tcx>\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        &self, val: ValTy<'tcx, M::PointerTag>\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n         let align = layout.align;\n@@ -265,9 +296,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     pub fn mplace_field(\n         &self,\n-        base: MPlaceTy<'tcx>,\n+        base: MPlaceTy<'tcx, M::PointerTag>,\n         field: u64,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Not using the layout method because we want to compute on u64\n         let offset = match base.layout.fields {\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } =>\n@@ -314,8 +345,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     // same by repeatedly calling `mplace_array`.\n     pub fn mplace_array_fields(\n         &self,\n-        base: MPlaceTy<'tcx>,\n-    ) -> EvalResult<'tcx, impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx>>> + 'a> {\n+        base: MPlaceTy<'tcx, Tag>,\n+    ) ->\n+        EvalResult<'tcx, impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n+    {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n             layout::FieldPlacement::Array { stride, .. } => stride,\n@@ -334,10 +367,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     pub fn mplace_subslice(\n         &self,\n-        base: MPlaceTy<'tcx>,\n+        base: MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n         to: u64,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         assert!(from <= len - to);\n \n@@ -374,20 +407,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     pub fn mplace_downcast(\n         &self,\n-        base: MPlaceTy<'tcx>,\n+        base: MPlaceTy<'tcx, M::PointerTag>,\n         variant: usize,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        assert_eq!(base.extra, None);\n+        assert!(base.extra.is_none());\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n     /// Project into an mplace\n     pub fn mplace_projection(\n         &self,\n-        base: MPlaceTy<'tcx>,\n+        base: MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::PlaceElem<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n             Field(field, _) => self.mplace_field(base, field.index() as u64)?,\n@@ -428,9 +461,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Just a convenience function, but used quite a bit.\n     pub fn place_field(\n         &mut self,\n-        base: PlaceTy<'tcx>,\n+        base: PlaceTy<'tcx, M::PointerTag>,\n         field: u64,\n-    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let mplace = self.force_allocation(base)?;\n@@ -439,9 +472,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     pub fn place_downcast(\n         &mut self,\n-        base: PlaceTy<'tcx>,\n+        base: PlaceTy<'tcx, M::PointerTag>,\n         variant: usize,\n-    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n         Ok(match base.place {\n             Place::Ptr(mplace) =>\n@@ -456,9 +489,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Project into a place\n     pub fn place_projection(\n         &mut self,\n-        base: PlaceTy<'tcx>,\n+        base: PlaceTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n-    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n             Field(field, _) =>  self.place_field(base, field.index() as u64)?,\n@@ -478,7 +511,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub(super) fn eval_place_to_mplace(\n         &self,\n         mir_place: &mir::Place<'tcx>\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         Ok(match *mir_place {\n             Promoted(ref promoted) => {\n@@ -515,7 +548,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation.\n                 let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n-                MPlaceTy::from_aligned_ptr(alloc.into(), layout)\n+                MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n             }\n \n             _ => bug!(\"eval_place_to_mplace called on {:?}\", mir_place),\n@@ -524,7 +557,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     /// Compute a place.  You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n-    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         let place = match *mir_place {\n             Local(mir::RETURN_PLACE) => PlaceTy {\n@@ -554,17 +587,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Write a scalar to a place\n     pub fn write_scalar(\n         &mut self,\n-        val: impl Into<ScalarMaybeUndef>,\n-        dest: PlaceTy<'tcx>,\n+        val: impl Into<ScalarMaybeUndef<M::PointerTag>>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         self.write_value(Value::Scalar(val.into()), dest)\n     }\n \n     /// Write a value to a place\n     pub fn write_value(\n         &mut self,\n-        src_val: Value,\n-        dest: PlaceTy<'tcx>,\n+        src_val: Value<M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"write_value: {:?} <- {:?}\", *dest, src_val);\n         // Check that the value actually is okay for that type\n@@ -599,8 +632,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// done that before calling this!\n     fn write_value_to_mplace(\n         &mut self,\n-        value: Value,\n-        dest: MPlaceTy<'tcx>,\n+        value: Value<M::PointerTag>,\n+        dest: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n         // Note that it is really important that the type here is the right one, and matches the\n@@ -641,8 +674,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Copy the data from an operand to a place\n     pub fn copy_op(\n         &mut self,\n-        src: OpTy<'tcx>,\n-        dest: PlaceTy<'tcx>,\n+        src: OpTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n             \"Cannot copy unsized data\");\n@@ -678,8 +711,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// This is essentially `force_to_memplace`.\n     pub fn force_allocation(\n         &mut self,\n-        place: PlaceTy<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        place: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let mplace = match place.place {\n             Place::Local { frame, local } => {\n                 match *self.stack[frame].locals[local].access()? {\n@@ -715,7 +748,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &mut self,\n         layout: TyLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n         let ptr = self.memory.allocate(layout.size, layout.align, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n@@ -724,7 +757,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn write_discriminant_index(\n         &mut self,\n         variant_index: usize,\n-        dest: PlaceTy<'tcx>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         match dest.layout.variants {\n             layout::Variants::Single { index } => {\n@@ -772,7 +805,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     /// Every place can be read from, so we can turm them into an operand\n     #[inline(always)]\n-    pub fn place_to_op(&self, place: PlaceTy<'tcx>) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    pub fn place_to_op(&self, place: PlaceTy<'tcx, M::PointerTag>) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let op = match place.place {\n             Place::Ptr(mplace) => {\n                 Operand::Indirect(mplace)\n@@ -785,8 +818,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n     /// Also return some more information so drop doesn't have to run the same code twice.\n-    pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx>)\n-    -> EvalResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx>)> {\n+    pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx, M::PointerTag>)\n+    -> EvalResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n         let vtable = mplace.vtable()?; // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;"}, {"sha": "623b7b2312d376c83a396d33cb09b03d2add01f8", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -99,6 +99,8 @@ macro_rules! __impl_snapshot_field {\n     ($field:ident, $ctx:expr, $delegate:expr) => ($delegate);\n }\n \n+// This assumes the type has two type parameters, first for the tag (set to `()`),\n+// then for the id\n macro_rules! impl_snapshot_for {\n     // FIXME(mark-i-m): Some of these should be `?` rather than `*`.\n     (enum $enum_name:ident {\n@@ -108,7 +110,7 @@ macro_rules! impl_snapshot_for {\n         impl<'a, Ctx> self::Snapshot<'a, Ctx> for $enum_name\n             where Ctx: self::SnapshotContext<'a>,\n         {\n-            type Item = $enum_name<AllocIdSnapshot<'a>>;\n+            type Item = $enum_name<(),AllocIdSnapshot<'a>>;\n \n             #[inline]\n             fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n@@ -129,7 +131,7 @@ macro_rules! impl_snapshot_for {\n         impl<'a, Ctx> self::Snapshot<'a, Ctx> for $struct_name\n             where Ctx: self::SnapshotContext<'a>,\n         {\n-            type Item = $struct_name<AllocIdSnapshot<'a>>;\n+            type Item = $struct_name<(),AllocIdSnapshot<'a>>;\n \n             #[inline]\n             fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n@@ -175,12 +177,13 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n impl_snapshot_for!(struct Pointer {\n     alloc_id,\n     offset -> *offset, // just copy offset verbatim\n+    tag -> *tag, // just copy tag\n });\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n     where Ctx: SnapshotContext<'a>,\n {\n-    type Item = Scalar<AllocIdSnapshot<'a>>;\n+    type Item = Scalar<(),AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         match self {\n@@ -234,7 +237,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Place {\n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     where Ctx: SnapshotContext<'a>,\n {\n-    type Item = Place<AllocIdSnapshot<'a>>;\n+    type Item = Place<(),AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         match self {\n@@ -278,19 +281,19 @@ impl_snapshot_for!(enum LocalValue {\n impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n     where Ctx: SnapshotContext<'a>,\n {\n-    type Item = Relocations<AllocIdSnapshot<'a>>;\n+    type Item = Relocations<(),AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         Relocations::from_presorted(self.iter()\n-            .map(|(size, id)| (*size, id.snapshot(ctx)))\n+            .map(|(size, ((), id))| (*size, ((), id.snapshot(ctx))))\n             .collect())\n     }\n }\n \n #[derive(Eq, PartialEq)]\n struct AllocationSnapshot<'a> {\n     bytes: &'a [u8],\n-    relocations: Relocations<AllocIdSnapshot<'a>>,\n+    relocations: Relocations<(),AllocIdSnapshot<'a>>,\n     undef_mask: &'a UndefMask,\n     align: &'a Align,\n     mutability: &'a Mutability,\n@@ -334,8 +337,8 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     instance: &'a ty::Instance<'tcx>,\n     span: &'a Span,\n     return_to_block: &'a StackPopCleanup,\n-    return_place: Place<AllocIdSnapshot<'a>>,\n-    locals: IndexVec<mir::Local, LocalValue<AllocIdSnapshot<'a>>>,\n+    return_place: Place<(),AllocIdSnapshot<'a>>,\n+    locals: IndexVec<mir::Local, LocalValue<(),AllocIdSnapshot<'a>>>,\n     block: &'a mir::BasicBlock,\n     stmt: usize,\n }"}, {"sha": "e599608b2dac99d875218f4f98c7e9ce6240d57d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -205,8 +205,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     fn pass_argument(\n         &mut self,\n         skip_zst: bool,\n-        caller_arg: &mut impl Iterator<Item=OpTy<'tcx>>,\n-        callee_arg: PlaceTy<'tcx>,\n+        caller_arg: &mut impl Iterator<Item=OpTy<'tcx, M::PointerTag>>,\n+        callee_arg: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         if skip_zst && callee_arg.layout.is_zst() {\n             // Nothing to do.\n@@ -231,8 +231,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         instance: ty::Instance<'tcx>,\n         span: Span,\n         caller_abi: Abi,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, M::PointerTag>],\n+        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n@@ -330,7 +330,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // last incoming argument.  These two iterators do not have the same type,\n                     // so to keep the code paths uniform we accept an allocation\n                     // (for RustCall ABI only).\n-                    let caller_args : Cow<[OpTy<'tcx>]> =\n+                    let caller_args : Cow<[OpTy<'tcx, M::PointerTag>]> =\n                         if caller_abi == Abi::RustCall && !args.is_empty() {\n                             // Untuple\n                             let (&untuple_arg, args) = args.split_last().unwrap();\n@@ -339,7 +339,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                                 .chain((0..untuple_arg.layout.fields.count()).into_iter()\n                                     .map(|i| self.operand_field(untuple_arg, i as u64))\n                                 )\n-                                .collect::<EvalResult<Vec<OpTy<'tcx>>>>()?)\n+                                .collect::<EvalResult<Vec<OpTy<'tcx, M::PointerTag>>>>()?)\n                         } else {\n                             // Plain arg passing\n                             Cow::from(args)\n@@ -426,7 +426,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     fn drop_in_place(\n         &mut self,\n-        place: PlaceTy<'tcx>,\n+        place: PlaceTy<'tcx, M::PointerTag>,\n         instance: ty::Instance<'tcx>,\n         span: Span,\n         target: mir::BasicBlock,"}, {"sha": "227c85772d228aa22f5179c0726fb0f22e5164c0", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -12,8 +12,6 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n \n-use syntax::ast::Mutability;\n-\n use super::{EvalContext, Machine, MemoryKind};\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -27,9 +25,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &mut self,\n         ty: Ty<'tcx>,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n+        // FIXME: Cache this!\n+\n         let layout = self.layout_of(trait_ref.self_ty())?;\n         assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n         let size = layout.size.bytes();\n@@ -41,7 +41,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let vtable = self.memory.allocate(\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n-            MemoryKind::Stack,\n+            MemoryKind::Vtable,\n         )?;\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n@@ -63,18 +63,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n         }\n \n-        self.memory.intern_static(\n-            vtable.alloc_id,\n-            Mutability::Immutable,\n-        )?;\n+        self.memory.mark_immutable(vtable.alloc_id)?;\n \n         Ok(vtable)\n     }\n \n     /// Return the drop fn instance as well as the actual dynamic type\n     pub fn read_drop_type_from_vtable(\n         &self,\n-        vtable: Pointer,\n+        vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (ty::Instance<'tcx>, ty::Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n@@ -90,7 +87,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     pub fn read_size_and_align_from_vtable(\n         &self,\n-        vtable: Pointer,\n+        vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;"}, {"sha": "eaa6247ec96a8ca11ba7252a359597d4766ec2df", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::fmt::Write;\n+use std::hash::Hash;\n \n use syntax_pos::symbol::Symbol;\n use rustc::ty::layout::{self, Size, Align, TyLayout};\n@@ -80,13 +81,13 @@ pub enum PathElem {\n }\n \n /// State for tracking recursive validation of references\n-pub struct RefTracking<'tcx> {\n-    pub seen: FxHashSet<(OpTy<'tcx>)>,\n-    pub todo: Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n+pub struct RefTracking<'tcx, Tag> {\n+    pub seen: FxHashSet<(OpTy<'tcx, Tag>)>,\n+    pub todo: Vec<(OpTy<'tcx, Tag>, Vec<PathElem>)>,\n }\n \n-impl<'tcx> RefTracking<'tcx> {\n-    pub fn new(op: OpTy<'tcx>) -> Self {\n+impl<'tcx, Tag: Copy+Eq+Hash> RefTracking<'tcx, Tag> {\n+    pub fn new(op: OpTy<'tcx, Tag>) -> Self {\n         let mut ref_tracking = RefTracking {\n             seen: FxHashSet(),\n             todo: vec![(op, Vec::new())],\n@@ -128,7 +129,7 @@ fn path_format(path: &Vec<PathElem>) -> String {\n     out\n }\n \n-fn scalar_format(value: ScalarMaybeUndef) -> String {\n+fn scalar_format<Tag>(value: ScalarMaybeUndef<Tag>) -> String {\n     match value {\n         ScalarMaybeUndef::Undef =>\n             \"uninitialized bytes\".to_owned(),\n@@ -143,9 +144,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Make sure that `value` is valid for `ty`, *assuming* `ty` is a primitive type.\n     fn validate_primitive_type(\n         &self,\n-        value: ValTy<'tcx>,\n+        value: ValTy<'tcx, M::PointerTag>,\n         path: &Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<'tcx>>,\n+        ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n         const_mode: bool,\n     ) -> EvalResult<'tcx> {\n         // Go over all the primitive types\n@@ -272,7 +273,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Make sure that `value` matches the\n     fn validate_scalar_layout(\n         &self,\n-        value: ScalarMaybeUndef,\n+        value: ScalarMaybeUndef<M::PointerTag>,\n         size: Size,\n         path: &Vec<PathElem>,\n         layout: &layout::Scalar,\n@@ -363,9 +364,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// validation (e.g., pointer values are fine in integers at runtime).\n     pub fn validate_operand(\n         &self,\n-        dest: OpTy<'tcx>,\n+        dest: OpTy<'tcx, M::PointerTag>,\n         path: &mut Vec<PathElem>,\n-        mut ref_tracking: Option<&mut RefTracking<'tcx>>,\n+        mut ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n         const_mode: bool,\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:?}\", *dest, dest.layout.ty);"}, {"sha": "29f167629441b964f2a2090649eb64a15eadc561", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f9329e3e2143b558a9ed80c220d5d01f6bd02/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=4e9f9329e3e2143b558a9ed80c220d5d01f6bd02", "patch": "@@ -1163,7 +1163,7 @@ fn collect_miri<'a, 'tcx>(\n         }\n         Some(AllocType::Memory(alloc)) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-            for &inner in alloc.relocations.values() {\n+            for &((), inner) in alloc.relocations.values() {\n                 collect_miri(tcx, inner, output);\n             }\n         },\n@@ -1272,7 +1272,7 @@ fn collect_const<'a, 'tcx>(\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstValue::ByRef(_id, alloc, _offset) => {\n-            for &id in alloc.relocations.values() {\n+            for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }\n         }"}]}