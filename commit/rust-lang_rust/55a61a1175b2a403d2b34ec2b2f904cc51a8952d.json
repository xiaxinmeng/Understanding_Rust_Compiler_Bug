{"sha": "55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YTYxYTExNzViMmE0MDNkMmIzNGVjMmIyZjkwNGNjNTFhODk1MmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-16T17:45:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-16T17:45:35Z"}, "message": "Auto merge of #36536 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 8 pull requests\n\n- Successful merges: #36383, #36424, #36480, #36484, #36505, #36509, #36519, #36521\n- Failed merges:", "tree": {"sha": "2097608190f0de00b0f3a7555b2ae410901d97a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2097608190f0de00b0f3a7555b2ae410901d97a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "html_url": "https://github.com/rust-lang/rust/commit/55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6673db58d117d5c554559ae51b4ddf0aae3de00", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6673db58d117d5c554559ae51b4ddf0aae3de00", "html_url": "https://github.com/rust-lang/rust/commit/c6673db58d117d5c554559ae51b4ddf0aae3de00"}, {"sha": "ab7425dcd48813dfd74f4655c357328467ee1278", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7425dcd48813dfd74f4655c357328467ee1278", "html_url": "https://github.com/rust-lang/rust/commit/ab7425dcd48813dfd74f4655c357328467ee1278"}], "stats": {"total": 500, "additions": 332, "deletions": 168}, "files": [{"sha": "14a985e93ce01b6d3f3a8d46f41d650467bf0fd9", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -269,15 +269,16 @@ def run(self, args, env):\n             sys.exit(ret)\n \n     def build_triple(self):\n+        default_encoding = sys.getdefaultencoding()\n         config = self.get_toml('build')\n         if config:\n             return config\n         config = self.get_mk('CFG_BUILD')\n         if config:\n             return config\n         try:\n-            ostype = subprocess.check_output(['uname', '-s']).strip()\n-            cputype = subprocess.check_output(['uname', '-m']).strip()\n+            ostype = subprocess.check_output(['uname', '-s']).strip().decode(default_encoding)\n+            cputype = subprocess.check_output(['uname', '-m']).strip().decode(default_encoding)\n         except (subprocess.CalledProcessError, WindowsError):\n             if sys.platform == 'win32':\n                 return 'x86_64-pc-windows-msvc'\n@@ -289,7 +290,8 @@ def build_triple(self):\n         # Darwin's `uname -s` lies and always returns i386. We have to use\n         # sysctl instead.\n         if ostype == 'Darwin' and cputype == 'i686':\n-            sysctl = subprocess.check_output(['sysctl', 'hw.optional.x86_64'])\n+            args = ['sysctl', 'hw.optional.x86_64']\n+            sysctl = subprocess.check_output(args).decode(default_encoding)\n             if ': 1' in sysctl:\n                 cputype = 'x86_64'\n "}, {"sha": "b0d954adf6771c9bacd8d3877d5dd57ef4abcd34", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -291,7 +291,7 @@ let result = f.write(buf);\n \n We need to `use` the `Write` trait first:\n \n-```rust,ignore\n+```rust,no_run\n use std::io::Write;\n \n let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");"}, {"sha": "5f16a4f2435f8549e49fec9d2016f33262d9ec2f", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -92,6 +92,22 @@ pub trait AsRef<T: ?Sized> {\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n ///\n+/// # Examples\n+///\n+/// [`Box<T>`] implements `AsMut<T>`:\n+///\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+///\n+/// ```\n+/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n+///     *num.as_mut() += 1;\n+/// }\n+///\n+/// let mut boxed_num = Box::new(0);\n+/// add_one(&mut boxed_num);\n+/// assert_eq!(*boxed_num, 1);\n+/// ```\n+///\n /// # Generic Impls\n ///\n /// - `AsMut` auto-dereferences if the inner type is a reference or a mutable"}, {"sha": "5a1a034a36358d9d1098f537517fe2d26c7d8839", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 268, "deletions": 155, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Primitive traits and marker types representing basic 'kinds' of types.\n+//! Primitive traits and types representing basic properties of types.\n //!\n //! Rust types can be classified in various useful ways according to\n-//! intrinsic properties of the type. These classifications, often called\n-//! 'kinds', are represented as traits.\n+//! their intrinsic properties. These classifications are represented\n+//! as traits.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -22,7 +22,21 @@ use hash::Hasher;\n \n /// Types that can be transferred across thread boundaries.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// This trait is automatically implemented when the compiler determines it's\n+/// appropriate.\n+///\n+/// An example of a non-`Send` type is the reference-counting pointer\n+/// [`rc::Rc`][rc]. If two threads attempt to clone `Rc`s that point to the same\n+/// reference-counted value, they might try to update the reference count at the\n+/// same time, which is [undefined behavior][ub] because `Rc` doesn't use atomic\n+/// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n+/// some overhead) and thus is `Send`.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n@@ -38,10 +52,10 @@ impl<T: ?Sized> !Send for *const T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !Send for *mut T { }\n \n-/// Types with a constant size known at compile-time.\n+/// Types with a constant size known at compile time.\n ///\n-/// All type parameters which can be bounded have an implicit bound of `Sized`. The special syntax\n-/// `?Sized` can be used to remove this bound if it is not appropriate.\n+/// All type parameters have an implicit bound of `Sized`. The special syntax\n+/// `?Sized` can be used to remove this bound if it's not appropriate.\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -51,6 +65,26 @@ impl<T: ?Sized> !Send for *mut T { }\n /// // struct FooUse(Foo<[i32]>); // error: Sized is not implemented for [i32]\n /// struct BarUse(Bar<[i32]>); // OK\n /// ```\n+///\n+/// The one exception is the implicit `Self` type of a trait, which does not\n+/// get an implicit `Sized` bound. This is because a `Sized` bound prevents\n+/// the trait from being used to form a [trait object]:\n+///\n+/// ```\n+/// # #![allow(unused_variables)]\n+/// trait Foo { }\n+/// trait Bar: Sized { }\n+///\n+/// struct Impl;\n+/// impl Foo for Impl { }\n+/// impl Bar for Impl { }\n+///\n+/// let x: &Foo = &Impl;    // OK\n+/// // let y: &Bar = &Impl; // error: the trait `Bar` cannot\n+///                         // be made into an object\n+/// ```\n+///\n+/// [trait object]: ../../book/trait-objects.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n@@ -59,14 +93,27 @@ pub trait Sized {\n     // Empty.\n }\n \n-/// Types that can be \"unsized\" to a dynamically sized type.\n+/// Types that can be \"unsized\" to a dynamically-sized type.\n+///\n+/// For example, the sized array type `[i8; 2]` implements `Unsize<[i8]>` and\n+/// `Unsize<fmt::Debug>`.\n+///\n+/// All implementations of `Unsize` are provided automatically by the compiler.\n+///\n+/// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n+/// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n+/// types. See the [DST coercion RFC][RFC982] for more details.\n+///\n+/// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n #[lang=\"unsize\"]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n \n-/// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+/// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n /// words:\n@@ -87,7 +134,8 @@ pub trait Unsize<T: ?Sized> {\n /// However, if a type implements `Copy`, it instead has 'copy semantics':\n ///\n /// ```\n-/// // we can just derive a `Copy` implementation\n+/// // We can derive a `Copy` implementation. `Clone` is also required, as it's\n+/// // a supertrait of `Copy`.\n /// #[derive(Debug, Copy, Clone)]\n /// struct Foo;\n ///\n@@ -100,13 +148,59 @@ pub trait Unsize<T: ?Sized> {\n /// println!(\"{:?}\", x); // A-OK!\n /// ```\n ///\n-/// It's important to note that in these two examples, the only difference is if you are allowed to\n-/// access `x` after the assignment: a move is also a bitwise copy under the hood.\n+/// It's important to note that in these two examples, the only difference is whether you\n+/// are allowed to access `x` after the assignment. Under the hood, both a copy and a move\n+/// can result in bits being copied in memory, although this is sometimes optimized away.\n+///\n+/// ## How can I implement `Copy`?\n+///\n+/// There are two ways to implement `Copy` on your type. The simplest is to use `derive`:\n+///\n+/// ```\n+/// #[derive(Copy, Clone)]\n+/// struct MyStruct;\n+/// ```\n+///\n+/// You can also implement `Copy` and `Clone` manually:\n+///\n+/// ```\n+/// struct MyStruct;\n+///\n+/// impl Copy for MyStruct { }\n+///\n+/// impl Clone for MyStruct {\n+///     fn clone(&self) -> MyStruct {\n+///         *self\n+///     }\n+/// }\n+/// ```\n+///\n+/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n+/// bound on type parameters, which isn't always desired.\n+///\n+/// ## What's the difference between `Copy` and `Clone`?\n+///\n+/// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n+/// `Copy` is not overloadable; it is always a simple bit-wise copy.\n+///\n+/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`][clone] can\n+/// provide any type-specific behavior necessary to duplicate values safely. For example,\n+/// the implementation of `Clone` for [`String`][string] needs to copy the pointed-to string\n+/// buffer in the heap. A simple bitwise copy of `String` values would merely copy the\n+/// pointer, leading to a double free down the line. For this reason, `String` is `Clone`\n+/// but not `Copy`.\n+///\n+/// `Clone` is a supertrait of `Copy`, so everything which is `Copy` must also implement\n+/// `Clone`. If a type is `Copy` then its `Clone` implementation need only return `*self`\n+/// (see the example above).\n+///\n+/// [clone]: ../clone/trait.Clone.html\n+/// [string]: ../../std/string/struct.String.html\n ///\n /// ## When can my type be `Copy`?\n ///\n /// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n-/// `struct` can be `Copy`:\n+/// struct can be `Copy`:\n ///\n /// ```\n /// # #[allow(dead_code)]\n@@ -116,7 +210,8 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// A `struct` can be `Copy`, and `i32` is `Copy`, so therefore, `Point` is eligible to be `Copy`.\n+/// A struct can be `Copy`, and `i32` is `Copy`, therefore `Point` is eligible to be `Copy`.\n+/// By contrast, consider\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -126,57 +221,35 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// The `PointList` `struct` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n+/// The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n /// attempt to derive a `Copy` implementation, we'll get an error:\n ///\n /// ```text\n /// the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n /// ```\n ///\n-/// ## When can my type _not_ be `Copy`?\n+/// ## When *can't* my type be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference, and copying [`String`] would result in two attempts to free the same buffer.\n+/// mutable reference. Copying [`String`] would duplicate responsibility for managing the `String`'s\n+/// buffer, leading to a double free.\n ///\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n-/// ## What if I derive `Copy` on a type that can't?\n-///\n-/// If you try to derive `Copy` on a struct or enum, you will get a compile-time error.\n-/// Specifically, with structs you'll get [E0204](https://doc.rust-lang.org/error-index.html#E0204)\n-/// and with enums you'll get [E0205](https://doc.rust-lang.org/error-index.html#E0205).\n-///\n-/// ## When should my type be `Copy`?\n-///\n-/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n-/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n-/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n-/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n+/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get a\n+/// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n+/// [E0205].\n ///\n-/// ## Derivable\n+/// [E0204]: https://doc.rust-lang.org/error-index.html#E0204\n+/// [E0205]: https://doc.rust-lang.org/error-index.html#E0205\n ///\n-/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type.\n+/// ## When *should* my type be `Copy`?\n ///\n-/// ## How can I implement `Copy`?\n-///\n-/// There are two ways to implement `Copy` on your type:\n-///\n-/// ```\n-/// #[derive(Copy, Clone)]\n-/// struct MyStruct;\n-/// ```\n-///\n-/// and\n-///\n-/// ```\n-/// struct MyStruct;\n-/// impl Copy for MyStruct {}\n-/// impl Clone for MyStruct { fn clone(&self) -> MyStruct { *self } }\n-/// ```\n-///\n-/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n-/// bound on type parameters, which isn't always desired.\n+/// Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,\n+/// that implementing `Copy` is part of the public API of your type. If the type might become\n+/// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n+/// avoid a breaking API change.\n ///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n@@ -188,64 +261,74 @@ pub trait Copy : Clone {\n     // Empty.\n }\n \n-/// Types that can be safely shared between threads when aliased.\n+/// Types for which it is safe to share references between threads.\n+///\n+/// This trait is automatically implemented when the compiler determines\n+/// it's appropriate.\n ///\n /// The precise definition is: a type `T` is `Sync` if `&T` is\n-/// thread-safe. In other words, there is no possibility of data races\n-/// when passing `&T` references between threads.\n-///\n-/// As one would expect, primitive types like [`u8`] and [`f64`] are all\n-/// `Sync`, and so are simple aggregate types containing them (like\n-/// tuples, structs and enums). More instances of basic `Sync` types\n-/// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as [`Box<T>`], [`Vec<T>`] and most other\n-/// collection types. (Generic parameters need to be `Sync` for their\n-/// container to be `Sync`.)\n-///\n-/// A somewhat surprising consequence of the definition is `&mut T` is\n-/// `Sync` (if `T` is `Sync`) even though it seems that it might\n-/// provide unsynchronized mutation. The trick is a mutable reference\n-/// stored in an aliasable reference (that is, `& &mut T`) becomes\n-/// read-only, as if it were a `& &T`, hence there is no risk of a data\n-/// race.\n+/// [`Send`][send]. In other words, if there is no possibility of\n+/// [undefined behavior][ub] (including data races) when passing\n+/// `&T` references between threads.\n+///\n+/// As one would expect, primitive types like [`u8`][u8] and [`f64`][f64]\n+/// are all `Sync`, and so are simple aggregate types containing them,\n+/// like tuples, structs and enums. More examples of basic `Sync`\n+/// types include \"immutable\" types like `&T`, and those with simple\n+/// inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and\n+/// most other collection types. (Generic parameters need to be `Sync`\n+/// for their container to be `Sync`.)\n+///\n+/// A somewhat surprising consequence of the definition is that `&mut T`\n+/// is `Sync` (if `T` is `Sync`) even though it seems like that might\n+/// provide unsynchronized mutation. The trick is that a mutable\n+/// reference behind a shared reference (that is, `& &mut T`)\n+/// becomes read-only, as if it were a `& &T`. Hence there is no risk\n+/// of a data race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe way, such as [`Cell`] and [`RefCell`]\n-/// in [`std::cell`]. These types allow for mutation of their contents\n-/// even when in an immutable, aliasable slot, e.g. the contents of\n-/// [`&Cell<T>`][`Cell`] can be [`.set`], and do not ensure data races are\n-/// impossible, hence they cannot be `Sync`. A higher level example\n-/// of a non-`Sync` type is the reference counted pointer\n-/// [`std::rc::Rc`][`Rc`], because any reference [`&Rc<T>`][`Rc`] can clone a new\n-/// reference, which modifies the reference counts in a non-atomic\n-/// way.\n-///\n-/// For cases when one does need thread-safe interior mutability,\n-/// types like the atomics in [`std::sync`][`sync`] and [`Mutex`] / [`RwLock`] in\n-/// the [`sync`] crate do ensure that any mutation cannot cause data\n-/// races.  Hence these types are `Sync`.\n-///\n-/// Any types with interior mutability must also use the [`std::cell::UnsafeCell`]\n-/// wrapper around the value(s) which can be mutated when behind a `&`\n-/// reference; not doing this is undefined behavior (for example,\n-/// [`transmute`]-ing from `&T` to `&mut T` is invalid).\n+/// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n+/// and [`cell::RefCell`][refcell]. These types allow for mutation of\n+/// their contents even through an immutable, shared reference. For\n+/// example the `set` method on `Cell<T>` takes `&self`, so it requires\n+/// only a shared reference `&Cell<T>`. The method performs no\n+/// synchronization, thus `Cell` cannot be `Sync`.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// Another example of a non-`Sync` type is the reference-counting\n+/// pointer [`rc::Rc`][rc]. Given any reference `&Rc<T>`, you can clone\n+/// a new `Rc<T>`, modifying the reference counts in a non-atomic way.\n ///\n-/// [`u8`]: ../../std/primitive.u8.html\n-/// [`f64`]: ../../std/primitive.f64.html\n-/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`std::cell`]: ../../std/cell/index.html\n-/// [`.set`]: ../../std/cell/struct.Cell.html#method.set\n-/// [`Rc`]: ../../std/rc/struct.Rc.html\n-/// [`sync`]: ../../std/sync/index.html\n-/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n-/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n-/// [`std::cell::UnsafeCell`]: ../../std/cell/struct.UnsafeCell.html\n-/// [`transmute`]: ../../std/mem/fn.transmute.html\n+/// For cases when one does need thread-safe interior mutability,\n+/// Rust provides [atomic data types], as well as explicit locking via\n+/// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n+/// ensure that any mutation cannot cause data races, hence the types\n+/// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n+/// analogue of `Rc`.\n+///\n+/// Any types with interior mutability must also use the\n+/// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which\n+/// can be mutated through a shared reference. Failing to doing this is\n+/// [undefined behavior][ub]. For example, [`transmute`][transmute]-ing\n+/// from `&T` to `&mut T` is invalid.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more\n+/// details about `Sync`.\n+///\n+/// [send]: trait.Send.html\n+/// [u8]: ../../std/primitive.u8.html\n+/// [f64]: ../../std/primitive.f64.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [vec]: ../../std/vec/struct.Vec.html\n+/// [cell]: ../cell/struct.Cell.html\n+/// [refcell]: ../cell/struct.RefCell.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [atomic data types]: ../sync/atomic/index.html\n+/// [mutex]: ../../std/sync/struct.Mutex.html\n+/// [rwlock]: ../../std/sync/struct.RwLock.html\n+/// [unsafecell]: ../cell/struct.UnsafeCell.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n@@ -314,29 +397,30 @@ macro_rules! impls{\n         )\n }\n \n-/// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n-/// even though it does not. This allows you to inform the compiler about certain safety properties\n-/// of your code.\n+/// Zero-sized type used to mark things that \"act like\" they own a `T`.\n ///\n-/// For a more in-depth explanation of how to use `PhantomData<T>`, please see [the Nomicon].\n+/// Adding a `PhantomData<T>` field to your type tells the compiler that your\n+/// type acts as though it stores a value of type `T`, even though it doesn't\n+/// really. This information is used when computing certain safety properties.\n ///\n-/// [the Nomicon]: ../../nomicon/phantom-data.html\n+/// For a more in-depth explanation of how to use `PhantomData<T>`, please see\n+/// [the Nomicon](../../nomicon/phantom-data.html).\n ///\n /// # A ghastly note \ud83d\udc7b\ud83d\udc7b\ud83d\udc7b\n ///\n-/// Though they both have scary names, `PhantomData<T>` and 'phantom types' are related, but not\n-/// identical. Phantom types are a more general concept that don't require `PhantomData<T>` to\n-/// implement, but `PhantomData<T>` is the most common way to implement them in a correct manner.\n+/// Though they both have scary names, `PhantomData` and 'phantom types' are\n+/// related, but not identical. A phantom type parameter is simply a type\n+/// parameter which is never used. In Rust, this often causes the compiler to\n+/// complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.\n ///\n /// # Examples\n ///\n-/// ## Unused lifetime parameter\n+/// ## Unused lifetime parameters\n ///\n-/// Perhaps the most common time that `PhantomData` is required is\n-/// with a struct that has an unused lifetime parameter, typically as\n-/// part of some unsafe code. For example, here is a struct `Slice`\n-/// that has two pointers of type `*const T`, presumably pointing into\n-/// an array somewhere:\n+/// Perhaps the most common use case for `PhantomData` is a struct that has an\n+/// unused lifetime parameter, typically as part of some unsafe code. For\n+/// example, here is a struct `Slice` that has two pointers of type `*const T`,\n+/// presumably pointing into an array somewhere:\n ///\n /// ```ignore\n /// struct Slice<'a, T> {\n@@ -350,7 +434,7 @@ macro_rules! impls{\n /// intent is not expressed in the code, since there are no uses of\n /// the lifetime `'a` and hence it is not clear what data it applies\n /// to. We can correct this by telling the compiler to act *as if* the\n-/// `Slice` struct contained a borrowed reference `&'a T`:\n+/// `Slice` struct contained a reference `&'a T`:\n ///\n /// ```\n /// use std::marker::PhantomData;\n@@ -359,29 +443,53 @@ macro_rules! impls{\n /// struct Slice<'a, T: 'a> {\n ///     start: *const T,\n ///     end: *const T,\n-///     phantom: PhantomData<&'a T>\n+///     phantom: PhantomData<&'a T>,\n /// }\n /// ```\n ///\n-/// This also in turn requires that we annotate `T:'a`, indicating\n-/// that `T` is a type that can be borrowed for the lifetime `'a`.\n+/// This also in turn requires the annotation `T: 'a`, indicating\n+/// that any references in `T` are valid over the lifetime `'a`.\n+///\n+/// When initializing a `Slice` you simply provide the value\n+/// `PhantomData` for the field `phantom`:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// # use std::marker::PhantomData;\n+/// # struct Slice<'a, T: 'a> {\n+/// #     start: *const T,\n+/// #     end: *const T,\n+/// #     phantom: PhantomData<&'a T>,\n+/// # }\n+/// fn borrow_vec<'a, T>(vec: &'a Vec<T>) -> Slice<'a, T> {\n+///     let ptr = vec.as_ptr();\n+///     Slice {\n+///         start: ptr,\n+///         end: unsafe { ptr.offset(vec.len() as isize) },\n+///         phantom: PhantomData,\n+///     }\n+/// }\n+/// ```\n ///\n /// ## Unused type parameters\n ///\n-/// It sometimes happens that there are unused type parameters that\n+/// It sometimes happens that you have unused type parameters which\n /// indicate what type of data a struct is \"tied\" to, even though that\n /// data is not actually found in the struct itself. Here is an\n-/// example where this arises when handling external resources over a\n-/// foreign function interface. `PhantomData<T>` can prevent\n-/// mismatches by enforcing types in the method implementations:\n+/// example where this arises with [FFI]. The foreign interface uses\n+/// handles of type `*mut ()` to refer to Rust values of different\n+/// types. We track the Rust type using a phantom type parameter on\n+/// the struct `ExternalResource` which wraps a handle.\n+///\n+/// [FFI]: ../../book/ffi.html\n ///\n /// ```\n /// # #![allow(dead_code)]\n-/// # trait ResType { fn foo(&self); }\n+/// # trait ResType { }\n /// # struct ParamType;\n /// # mod foreign_lib {\n-/// # pub fn new(_: usize) -> *mut () { 42 as *mut () }\n-/// # pub fn do_stuff(_: *mut (), _: usize) {}\n+/// #     pub fn new(_: usize) -> *mut () { 42 as *mut () }\n+/// #     pub fn do_stuff(_: *mut (), _: usize) {}\n /// # }\n /// # fn convert_params(_: ParamType) -> usize { 42 }\n /// use std::marker::PhantomData;\n@@ -408,21 +516,20 @@ macro_rules! impls{\n /// }\n /// ```\n ///\n-/// ## Indicating ownership\n+/// ## Ownership and the drop check\n ///\n-/// Adding a field of type `PhantomData<T>` also indicates that your\n-/// struct owns data of type `T`. This in turn implies that when your\n-/// struct is dropped, it may in turn drop one or more instances of\n-/// the type `T`, though that may not be apparent from the other\n-/// structure of the type itself. This is commonly necessary if the\n-/// structure is using a raw pointer like `*mut T` whose referent\n-/// may be dropped when the type is dropped, as a `*mut T` is\n-/// otherwise not treated as owned.\n+/// Adding a field of type `PhantomData<T>` indicates that your\n+/// type owns data of type `T`. This in turn implies that when your\n+/// type is dropped, it may drop one or more instances of the type\n+/// `T`. This has bearing on the Rust compiler's [drop check]\n+/// analysis.\n ///\n /// If your struct does not in fact *own* the data of type `T`, it is\n /// better to use a reference type, like `PhantomData<&'a T>`\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n+///\n+/// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n@@ -438,10 +545,13 @@ mod impls {\n \n /// Types that can be reflected over.\n ///\n-/// This trait is implemented for all types. Its purpose is to ensure\n-/// that when you write a generic function that will employ\n-/// reflection, that must be reflected (no pun intended) in the\n-/// generic bounds of that function. Here is an example:\n+/// By \"reflection\" we mean use of the [`Any`][any] trait, or related\n+/// machinery such as [`TypeId`][typeid].\n+///\n+/// `Reflect` is implemented for all types. Its purpose is to ensure\n+/// that when you write a generic function that will employ reflection,\n+/// that must be reflected (no pun intended) in the generic bounds of\n+/// that function.\n ///\n /// ```\n /// #![feature(reflect_marker)]\n@@ -455,21 +565,24 @@ mod impls {\n /// }\n /// ```\n ///\n-/// Without the declaration `T: Reflect`, `foo` would not type check\n-/// (note: as a matter of style, it would be preferable to write\n-/// `T: Any`, because `T: Any` implies `T: Reflect` and `T: 'static`, but\n-/// we use `Reflect` here to show how it works). The `Reflect` bound\n-/// thus serves to alert `foo`'s caller to the fact that `foo` may\n-/// behave differently depending on whether `T = u32` or not. In\n-/// particular, thanks to the `Reflect` bound, callers know that a\n-/// function declared like `fn bar<T>(...)` will always act in\n-/// precisely the same way no matter what type `T` is supplied,\n-/// because there are no bounds declared on `T`. (The ability for a\n-/// caller to reason about what a function may do based solely on what\n-/// generic bounds are declared is often called the [\"parametricity\n-/// property\"][1].)\n-///\n-/// [1]: http://en.wikipedia.org/wiki/Parametricity\n+/// Without the bound `T: Reflect`, `foo` would not typecheck. (As\n+/// a matter of style, it would be preferable to write `T: Any`,\n+/// because `T: Any` implies `T: Reflect` and `T: 'static`, but we\n+/// use `Reflect` here for illustrative purposes.)\n+///\n+/// The `Reflect` bound serves to alert `foo`'s caller to the\n+/// fact that `foo` may behave differently depending on whether\n+/// `T` is `u32` or not. The ability for a caller to reason about what\n+/// a function may do based solely on what generic bounds are declared\n+/// is often called the \"[parametricity property][param]\". Despite the\n+/// use of `Reflect`, Rust lacks true parametricity because a generic\n+/// function can, at the very least, call [`mem::size_of`][size_of]\n+/// without employing any trait bounds whatsoever.\n+///\n+/// [any]: ../any/trait.Any.html\n+/// [typeid]: ../any/struct.TypeId.html\n+/// [param]: http://en.wikipedia.org/wiki/Parametricity\n+/// [size_of]: ../mem/fn.size_of.html\n #[rustc_reflect_like]\n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\","}, {"sha": "7e96adfc4bdbc006d45a27c2af582fd553f7704a", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -201,7 +201,7 @@ macro_rules! bitflags {\n                 !(*self & other).is_empty()\n             }\n \n-            /// Returns `true` all of the flags in `other` are contained within `self`.\n+            /// Returns `true` if all of the flags in `other` are contained within `self`.\n             #[inline]\n             pub fn contains(&self, other: $BitFlags) -> bool {\n                 (*self & other) == other"}, {"sha": "a18a754b184b0a633d6ef553107d252acd2851e4", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -1054,7 +1054,8 @@ fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<as\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n-    const STACK_SIZE: usize = 8 * 1024 * 1024; // 8MB\n+    // Temporarily have stack size set to 16MB to deal with nom-using crates failing\n+    const STACK_SIZE: usize = 16 * 1024 * 1024; // 16MB\n \n     struct Sink(Arc<Mutex<Vec<u8>>>);\n     impl Write for Sink {"}, {"sha": "faad3f9b000cc0a08b40a7c27770dc895c865d91", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -38,7 +38,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      impl_m_span: Span,\n                                      impl_m_body_id: ast::NodeId,\n                                      trait_m: &ty::Method<'tcx>,\n-                                     impl_trait_ref: &ty::TraitRef<'tcx>) {\n+                                     impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                     trait_item_span: Option<Span>) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n@@ -97,14 +98,42 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let num_impl_m_type_params = impl_m.generics.types.len();\n     let num_trait_m_type_params = trait_m.generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n-        span_err!(tcx.sess, impl_m_span, E0049,\n+        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+        let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+            ImplItemKind::Method(ref impl_m_sig, _) => {\n+                if impl_m_sig.generics.is_parameterized() {\n+                    impl_m_sig.generics.span\n+                } else {\n+                    impl_m_span\n+                }\n+            }\n+            _ => bug!(\"{:?} is not a method\", impl_m)\n+        };\n+\n+        struct_span_err!(tcx.sess, span, E0049,\n             \"method `{}` has {} type parameter{} \\\n              but its trait declaration has {} type parameter{}\",\n             trait_m.name,\n             num_impl_m_type_params,\n             if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n             num_trait_m_type_params,\n-            if num_trait_m_type_params == 1 {\"\"} else {\"s\"});\n+            if num_trait_m_type_params == 1 {\"\"} else {\"s\"})\n+            .span_label(trait_item_span.unwrap(),\n+                        &format!(\"expected {}\",\n+                                 &if num_trait_m_type_params != 1 {\n+                                     format!(\"{} type parameters\",\n+                                             num_trait_m_type_params)\n+                                 } else {\n+                                     format!(\"{} type parameter\",\n+                                             num_trait_m_type_params)\n+                                 }))\n+            .span_label(span, &format!(\"found {}\",\n+                                       &if num_impl_m_type_params != 1 {\n+                                           format!(\"{} type parameters\", num_impl_m_type_params)\n+                                       } else {\n+                                           format!(\"1 type parameter\")\n+                                       }))\n+            .emit();\n         return;\n     }\n "}, {"sha": "baa084212a2d952753effd3c9eeaabf76d4987a0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -1015,13 +1015,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         _ => span_bug!(impl_item.span, \"non-method impl-item for method\")\n                     };\n \n+                    let trait_span = tcx.map.span_if_local(ty_trait_item.def_id());\n                     if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n                         compare_impl_method(ccx,\n                                             &impl_method,\n                                             impl_item.span,\n                                             body.id,\n                                             &trait_method,\n-                                            &impl_trait_ref);\n+                                            &impl_trait_ref,\n+                                            trait_span);\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\"}, {"sha": "76eb92bd55989880f73416743fc4244ee3839317", "filename": "src/libstd/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -83,7 +83,7 @@ pub struct VarsOs { inner: os_imp::Env }\n /// environment variables of the current process.\n ///\n /// The returned iterator contains a snapshot of the process's environment\n-/// variables at the time of this invocation, modifications to environment\n+/// variables at the time of this invocation. Modifications to environment\n /// variables afterwards will not be reflected in the returned iterator.\n ///\n /// # Panics\n@@ -112,7 +112,7 @@ pub fn vars() -> Vars {\n /// environment variables of the current process.\n ///\n /// The returned iterator contains a snapshot of the process's environment\n-/// variables at the time of this invocation, modifications to environment\n+/// variables at the time of this invocation. Modifications to environment\n /// variables afterwards will not be reflected in the returned iterator.\n ///\n /// # Examples"}, {"sha": "33ebd3f7aca5e345d4d6f8018fd8cd9c7cd6129b", "filename": "src/test/compile-fail/E0049.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Ftest%2Fcompile-fail%2FE0049.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a61a1175b2a403d2b34ec2b2f904cc51a8952d/src%2Ftest%2Fcompile-fail%2FE0049.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0049.rs?ref=55a61a1175b2a403d2b34ec2b2f904cc51a8952d", "patch": "@@ -9,13 +9,14 @@\n // except according to those terms.\n \n trait Foo {\n-    fn foo<T: Default>(x: T) -> Self;\n+    fn foo<T: Default>(x: T) -> Self; //~ NOTE expected 1 type parameter\n }\n \n struct Bar;\n \n impl Foo for Bar {\n     fn foo(x: bool) -> Self { Bar } //~ ERROR E0049\n+                                    //~| NOTE found 0 type parameters\n }\n \n fn main() {"}]}