{"sha": "9883a6250b61eb4bb715684f9b25304f4f0d437e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ODNhNjI1MGI2MWViNGJiNzE1Njg0ZjliMjUzMDRmNGYwZDQzN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-28T23:21:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-28T23:21:04Z"}, "message": "auto merge of #9589 : thestinger/rust/tutorial, r=alexcrichton", "tree": {"sha": "1bb603d573b9a362066818d214fa91295c1b53e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bb603d573b9a362066818d214fa91295c1b53e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9883a6250b61eb4bb715684f9b25304f4f0d437e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9883a6250b61eb4bb715684f9b25304f4f0d437e", "html_url": "https://github.com/rust-lang/rust/commit/9883a6250b61eb4bb715684f9b25304f4f0d437e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9883a6250b61eb4bb715684f9b25304f4f0d437e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e7bb67a8038ff73ad9dc88d8be3d3df4777282", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e7bb67a8038ff73ad9dc88d8be3d3df4777282", "html_url": "https://github.com/rust-lang/rust/commit/92e7bb67a8038ff73ad9dc88d8be3d3df4777282"}, {"sha": "6c8e6aad7344a62d91d5cf10e0dd1769602a5257", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8e6aad7344a62d91d5cf10e0dd1769602a5257", "html_url": "https://github.com/rust-lang/rust/commit/6c8e6aad7344a62d91d5cf10e0dd1769602a5257"}], "stats": {"total": 128, "additions": 70, "deletions": 58}, "files": [{"sha": "1c56257ee9f462a9ad3606cc7414c9fc77b0839a", "filename": "doc/tutorial.md", "status": "modified", "additions": 70, "deletions": 58, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/9883a6250b61eb4bb715684f9b25304f4f0d437e/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9883a6250b61eb4bb715684f9b25304f4f0d437e/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=9883a6250b61eb4bb715684f9b25304f4f0d437e", "patch": "@@ -923,22 +923,60 @@ custom destructors.\n \n # Boxes\n \n-Many modern languages represent values as pointers to heap memory by\n-default. In contrast, Rust, like C and C++, represents such types directly.\n-Another way to say this is that aggregate data in Rust are *unboxed*. This\n-means that if you `let x = Point { x: 1f, y: 1f };`, you are creating a struct\n-on the stack. If you then copy it into a data structure, you copy the entire\n-struct, not just a pointer.\n+A value in Rust is stored directly inside the owner. If a `struct` contains\n+four `int` fields, it will be four times as large as a single `int`.  The\n+following `struct` type is invalid, as it would have an infinite size:\n \n-For small structs like `Point`, this is usually more efficient than allocating\n-memory and indirecting through a pointer. But for big structs, or mutable\n-state, it can be useful to have a single copy on the stack or on the heap, and\n-refer to that through a pointer.\n+~~~~ {.xfail-test}\n+struct List {\n+    next: Option<List>,\n+    data: int\n+}\n+~~~~\n+\n+> ***Note:*** The `Option` type is an enum representing an *optional* value.\n+> It's comparable to a nullable pointer in many other languages, but stores the\n+> contained value unboxed.\n+\n+An *owned box* (`~`) uses a heap allocation to provide the invariant of always\n+being the size of a pointer, regardless of the contained type. This can be\n+leveraged to create a valid recursive `struct` type with a finite size:\n+\n+~~~~\n+struct List {\n+    next: Option<~List>,\n+    data: int\n+}\n+~~~~\n+\n+Since an owned box has a single owner, they are limited to representing\n+tree-like data structures.\n+\n+The most common use case for owned boxes is creating recursive data structures\n+like a binary search tree. Rust's trait-based generics system (covered later in\n+the tutorial) is usually used for static dispatch, but also provides dynamic\n+dispatch via boxing. Values of different types may have different sizes, but a\n+box is able to *erase* the difference via the layer of indirection they\n+provide.\n \n-## Owned boxes\n+In uncommon cases, the indirection can provide a performance gain or memory\n+reduction by making values smaller. However, unboxed values should almost\n+always be preferred.\n \n-An owned box (`~`) is a uniquely owned allocation on the heap. It inherits the\n-mutability and lifetime of the owner as it would if there was no box:\n+Note that returning large unboxed values via boxes is unnecessary. A large\n+value is returned via a hidden output parameter, and the decision on where to\n+place the return value should be left to the caller:\n+\n+~~~~\n+fn foo() -> (int, int, int, int, int, int) {\n+    (5, 5, 5, 5, 5, 5)\n+}\n+\n+let x = ~foo(); // allocates, and writes the integers directly to it\n+~~~~\n+\n+Beyond the properties granted by the size, an owned box behaves as a regular\n+value by inheriting the mutability and lifetime of the owner:\n \n ~~~~\n let x = 5; // immutable\n@@ -950,35 +988,33 @@ let mut y = ~5; // mutable\n *y += 2; // the * operator is needed to access the contained value\n ~~~~\n \n-The purpose of an owned box is to add a layer of indirection in order to create\n-recursive data structures or cheaply pass around an object larger than a\n-pointer. Since an owned box has a unique owner, it can only be used to\n-represent a tree data structure.\n+As covered earlier, an owned box has a destructor to clean up the allocated\n+memory. This makes it more restricted than an unboxed type with no destructor\n+by introducing *move semantics*.\n \n-The following struct won't compile, because the lack of indirection would mean\n-it has an infinite size:\n+# Move semantics\n \n-~~~~ {.xfail-test}\n-struct Foo {\n-    child: Option<Foo>\n-}\n-~~~~\n+Rust uses a shallow copy for parameter passing, assignment and returning from\n+functions. This is considered a move of ownership for types with destructors.\n+After a value has been moved, it can no longer be used from the source location\n+and will not be destroyed when the source goes out of scope.\n \n-> ***Note:*** The `Option` type is an enum that represents an *optional* value.\n-> It's comparable to a nullable pointer in many other languages, but stores the\n-> contained value unboxed.\n+~~~~\n+let x = ~5;\n+let y = x.clone(); // y is a newly allocated box\n+let z = x; // no new memory allocated, x can no longer be used\n+~~~~\n \n-Adding indirection with an owned pointer allocates the child outside of the\n-struct on the heap, which makes it a finite size and won't result in a\n-compile-time error:\n+The mutability of a value may be changed by moving it to a new owner:\n \n ~~~~\n-struct Foo {\n-    child: Option<~Foo>\n-}\n+let r = ~13;\n+let mut s = r; // box becomes mutable\n+*s += 1;\n+let t = s; // box becomes immutable\n ~~~~\n \n-## Managed boxes\n+# Managed boxes\n \n A managed box (`@`) is a heap allocation with the lifetime managed by a\n task-local garbage collector. It will be destroyed at some point after there\n@@ -1023,30 +1059,6 @@ d = b;          // box type is the same, okay\n c = b;          // error\n ~~~~\n \n-# Move semantics\n-\n-Rust uses a shallow copy for parameter passing, assignment and returning values\n-from functions. A shallow copy is considered a move of ownership if the\n-ownership tree of the copied value includes an owned box or a type with a\n-custom destructor. After a value has been moved, it can no longer be used from\n-the source location and will not be destroyed there.\n-\n-~~~~\n-let x = ~5;\n-let y = x.clone(); // y is a newly allocated box\n-let z = x; // no new memory allocated, x can no longer be used\n-~~~~\n-\n-Since in owned boxes mutability is a property of the owner, not the\n-box, mutable boxes may become immutable when they are moved, and vice-versa.\n-\n-~~~~\n-let r = ~13;\n-let mut s = r; // box becomes mutable\n-*s += 1;\n-let t = s; // box becomes immutable\n-~~~~\n-\n # Borrowed pointers\n \n Rust's borrowed pointers are a general purpose reference type. In contrast with"}]}