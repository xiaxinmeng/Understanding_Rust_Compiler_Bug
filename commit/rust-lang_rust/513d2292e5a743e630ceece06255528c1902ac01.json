{"sha": "513d2292e5a743e630ceece06255528c1902ac01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxM2QyMjkyZTVhNzQzZTYzMGNlZWNlMDYyNTU1MjhjMTkwMmFjMDE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T08:28:08Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T16:22:23Z"}, "message": "std: remove foldr and alli methods in vec", "tree": {"sha": "2bfd6a023b397d60a5923a66cdcb47241ac1b043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bfd6a023b397d60a5923a66cdcb47241ac1b043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/513d2292e5a743e630ceece06255528c1902ac01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/513d2292e5a743e630ceece06255528c1902ac01", "html_url": "https://github.com/rust-lang/rust/commit/513d2292e5a743e630ceece06255528c1902ac01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/513d2292e5a743e630ceece06255528c1902ac01/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed299af62566a9f0f285e81408aab5f7680ab4cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed299af62566a9f0f285e81408aab5f7680ab4cc", "html_url": "https://github.com/rust-lang/rust/commit/ed299af62566a9f0f285e81408aab5f7680ab4cc"}], "stats": {"total": 63, "additions": 26, "deletions": 37}, "files": [{"sha": "892908dc0a0d8ed4f2db4529463ce2ec2d0903ce", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -351,6 +351,7 @@ a single large vector of floats. Each task needs the full vector to perform its\n # use std::vec;\n # use std::uint;\n # use std::rand;\n+# use std::iterator::IteratorUtil;\n use extra::arc::ARC;\n \n fn pnorm(nums: &~[float], p: uint) -> float {"}, {"sha": "98f8efb72c80f79d21cdd242ea5c39aaca42c9a3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -19,6 +19,7 @@ use middle::typeck::method_map;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n+use core::iterator::IteratorUtil;\n use core::uint;\n use core::vec;\n use extra::sort;\n@@ -242,7 +243,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 not_useful\n               }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-                let max_len = do m.foldr(0) |r, max_len| {\n+                let max_len = do m.rev_iter().fold(0) |max_len, r| {\n                   match r[0].node {\n                     pat_vec(ref before, _, ref after) => {\n                       uint::max(before.len() + after.len(), max_len)"}, {"sha": "8a9a67db8027154e16e75f191b4de3a16c378fc3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -110,6 +110,7 @@ use middle::ty;\n use middle::typeck;\n use middle::moves;\n \n+use core::iterator::IteratorUtil;\n use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::io;\n@@ -923,7 +924,7 @@ impl Liveness {\n     pub fn propagate_through_block(&self, blk: &blk, succ: LiveNode)\n                                    -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n-        do blk.node.stmts.foldr(succ) |stmt, succ| {\n+        do blk.node.stmts.rev_iter().fold(succ) |succ, stmt| {\n             self.propagate_through_stmt(*stmt, succ)\n         }\n     }\n@@ -977,7 +978,7 @@ impl Liveness {\n \n     pub fn propagate_through_exprs(&self, exprs: &[@expr], succ: LiveNode)\n                                    -> LiveNode {\n-        do exprs.foldr(succ) |expr, succ| {\n+        do exprs.rev_iter().fold(succ) |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         }\n     }\n@@ -1021,7 +1022,7 @@ impl Liveness {\n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n                  let caps = self.ir.captures(expr);\n-                 do caps.foldr(succ) |cap, succ| {\n+                 do caps.rev_iter().fold(succ) |succ, cap| {\n                      self.init_from_succ(cap.ln, succ);\n                      let var = self.variable(cap.var_nid, expr.span);\n                      self.acc(cap.ln, var, ACC_READ | ACC_USE);\n@@ -1159,7 +1160,7 @@ impl Liveness {\n \n           expr_struct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do (*fields).foldr(succ) |field, succ| {\n+            do fields.rev_iter().fold(succ) |succ, field| {\n                 self.propagate_through_expr(field.node.expr, succ)\n             }\n           }\n@@ -1215,10 +1216,10 @@ impl Liveness {\n           }\n \n           expr_inline_asm(ref ia) =>{\n-            let succ = do ia.inputs.foldr(succ) |&(_, expr), succ| {\n+            let succ = do ia.inputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n             };\n-            do ia.outputs.foldr(succ) |&(_, expr), succ| {\n+            do ia.outputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n             }\n           }"}, {"sha": "8e1b165f408969c4b4fdaf5eeb4636e8fb5422ca", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -44,6 +44,7 @@\n  *   taken to it, implementing them for Rust seems difficult.\n  */\n \n+use core::iterator::IteratorUtil;\n use core::container::Map;\n use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n@@ -176,7 +177,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n             // Since there's at least one\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n-            if !cases.alli(|i,c| c.discr == (i as int)) {\n+            if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as int)) {\n                 cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n                                   discriminants\",\n                                  ty::item_path_str(cx.tcx, def_id)))"}, {"sha": "d59635ccd762fe16b214180bdfc2d282e623fd58", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -20,7 +20,6 @@ use middle::trans::common::{T_array, T_ptr, T_void};\n use core::iterator::IteratorUtil;\n use core::option::{Option, None, Some};\n use core::uint;\n-use core::vec;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;"}, {"sha": "bdc9fd0ccad5d5a552dc504d9d39c3f963c010e1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -1821,11 +1821,9 @@ pub trait ImmutableVector<'self, T> {\n     fn last_opt(&self) -> Option<&'self T>;\n     fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U;\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n     fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n@@ -1913,12 +1911,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         rposition(*self, f)\n     }\n \n-    /// Reduce a vector from right to left\n-    #[inline]\n-    fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U {\n-        self.rev_iter().fold(z, |u, t| p(t, u))\n-    }\n-\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n@@ -1942,14 +1934,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         r\n     }\n \n-    /**\n-     * Returns true if the function returns true for all elements.\n-     *\n-     *     If the vector is empty, true is returned.\n-     */\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n-        self.iter().enumerate().all(|(i, t)| f(i,t))\n-    }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector"}, {"sha": "d170ca92678e3e761fc4a37b54114f274f80ec47", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -20,6 +20,7 @@ use opt_vec;\n use parse::token;\n use visit;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::int;\n use core::option;\n@@ -833,7 +834,7 @@ mod test {\n     // returning the resulting index\n     fn unfold_test_sc(tscs : ~[TestSC], tail: SyntaxContext, table : &mut SCTable)\n         -> SyntaxContext {\n-        tscs.foldr(tail, |tsc : &TestSC,tail : SyntaxContext|\n+        tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n                       M(mrk) => new_mark_internal(mrk,tail,table),\n                       R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n@@ -874,7 +875,7 @@ mod test {\n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {\n-        mrks.foldr(tail, |mrk:&Mrk,tail:SyntaxContext|\n+        mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n                    {new_mark_internal(*mrk,tail,table)})\n     }\n "}, {"sha": "078fd4231cab36a965427776dfb51e37f2c46a57", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -1025,11 +1025,11 @@ pub fn cs_fold(use_foldl: bool,\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n-                do all_fields.foldl(base) |&old, &(_, self_f, other_fs)| {\n+                do all_fields.iter().fold(base) |old, &(_, self_f, other_fs)| {\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             } else {\n-                do all_fields.foldr(base) |&(_, self_f, other_fs), old| {\n+                do all_fields.rev_iter().fold(base) |old, &(_, self_f, other_fs)| {\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             }\n@@ -1094,11 +1094,11 @@ pub fn cs_same_method_fold(use_foldl: bool,\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n-                do vals.foldl(base) |&old, &new| {\n+                do vals.iter().fold(base) |old, &new| {\n                     f(cx, span, old, new)\n                 }\n             } else {\n-                do vals.foldr(base) |&new, old| {\n+                do vals.rev_iter().fold(base) |old, &new| {\n                     f(cx, span, old, new)\n                 }\n             }"}, {"sha": "c091ab8b6173692afab70ce5360cbf5fa77fec8b", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -19,6 +19,7 @@ library.\n */\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use ast::{enum_def, ident, item, Generics, meta_item, struct_def};\n use ext::base::ExtCtxt;\n@@ -74,7 +75,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n             in_items\n         }\n         meta_list(_, ref titems) => {\n-            do titems.foldr(in_items) |&titem, in_items| {\n+            do titems.rev_iter().fold(in_items) |in_items, &titem| {\n                 match titem.node {\n                     meta_name_value(tname, _) |\n                     meta_list(tname, _) |"}, {"sha": "dee18c8a1b3ed9973c079c6c1559bdbd7c46ac22", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -363,7 +363,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     info!(~\"Verifying tree edges...\");\n \n-    let status = do tree.alli() |k, parent| {\n+    let status = do tree.iter().enumerate().all |(k, parent)| {\n         if *parent != root && *parent != -1i64 {\n             level[*parent] == level[k] - 1\n         }"}, {"sha": "ee96cc293ebbf9b6a3a1eb3988020b2db8c81c48", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n     do needlesArr.iter().fold() |x, y| {\n     }\n-    //~^ ERROR 1 parameter were supplied (including the closure passed by the `do` keyword)\n+    //~^ ERROR 1 parameter was supplied (including the closure passed by the `do` keyword)\n     //\n     // the first error is, um, non-ideal.\n }"}, {"sha": "522516351d2288be277118006a60f2dc77c77983", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];"}, {"sha": "c6d66e07444c7c1510a10e39b333c441e47f97c1", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     fn f(i: &fn() -> uint) -> uint { i() }"}, {"sha": "a205e9f8f31ef0e67421eb8411fe7d9be72fcd74", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d2292e5a743e630ceece06255528c1902ac01/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=513d2292e5a743e630ceece06255528c1902ac01", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     fn f(i: uint) -> uint { i }"}]}