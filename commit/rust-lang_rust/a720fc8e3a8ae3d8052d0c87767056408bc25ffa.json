{"sha": "a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "node_id": "C_kwDOAAsO6NoAKGE3MjBmYzhlM2E4YWUzZDgwNTJkMGM4Nzc2NzA1NjQwOGJjMjVmZmE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-21T13:51:06Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-21T13:51:06Z"}, "message": "Simplify function rendering, remove constructor structs", "tree": {"sha": "968dc2a997014a7ebdc650c2bda0a258347b39a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/968dc2a997014a7ebdc650c2bda0a258347b39a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "html_url": "https://github.com/rust-lang/rust/commit/a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a720fc8e3a8ae3d8052d0c87767056408bc25ffa/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22b2c2fdf75426003a170c0e0b6e95c0ad7c4a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/22b2c2fdf75426003a170c0e0b6e95c0ad7c4a75", "html_url": "https://github.com/rust-lang/rust/commit/22b2c2fdf75426003a170c0e0b6e95c0ad7c4a75"}], "stats": {"total": 250, "additions": 120, "deletions": 130}, "files": [{"sha": "974264c319bd65cfbc6fb3ef92fedf7e1f0609a1", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a720fc8e3a8ae3d8052d0c87767056408bc25ffa/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a720fc8e3a8ae3d8052d0c87767056408bc25ffa/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "patch": "@@ -115,7 +115,7 @@ impl Completions {\n         if !ctx.is_visible(&func) {\n             return;\n         }\n-        self.add_opt(render_fn(RenderContext::new(ctx), None, local_name, func));\n+        self.add(render_fn(RenderContext::new(ctx), None, local_name, func));\n     }\n \n     pub(crate) fn add_method(\n@@ -128,7 +128,7 @@ impl Completions {\n         if !ctx.is_visible(&func) {\n             return;\n         }\n-        self.add_opt(render_method(RenderContext::new(ctx), None, receiver, local_name, func));\n+        self.add(render_method(RenderContext::new(ctx), None, receiver, local_name, func));\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, konst: hir::Const) {"}, {"sha": "25f46e729925d94064cc48e9a5d0bdd20b35b312", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a720fc8e3a8ae3d8052d0c87767056408bc25ffa/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a720fc8e3a8ae3d8052d0c87767056408bc25ffa/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "patch": "@@ -156,17 +156,16 @@ fn render_resolution_(\n     let _p = profile::span(\"render_resolution\");\n     use hir::ModuleDef::*;\n \n+    let db = ctx.db();\n+\n     let kind = match resolution {\n         ScopeDef::ModuleDef(Function(func)) => {\n-            return render_fn(ctx, import_to_add, Some(local_name), func)\n+            return Some(render_fn(ctx, import_to_add, Some(local_name), func));\n         }\n         ScopeDef::ModuleDef(Variant(var)) if ctx.completion.pattern_ctx.is_none() => {\n-            return Some(render_variant(ctx, import_to_add, Some(local_name), var, None))\n-        }\n-        ScopeDef::MacroDef(mac) => {\n-            let item = render_macro(ctx, import_to_add, local_name, mac);\n-            return item;\n+            return Some(render_variant(ctx, import_to_add, Some(local_name), var, None));\n         }\n+        ScopeDef::MacroDef(mac) => return render_macro(ctx, import_to_add, local_name, mac),\n         ScopeDef::Unknown => {\n             let mut item = CompletionItem::new(\n                 CompletionItemKind::UnresolvedReference,\n@@ -206,9 +205,9 @@ fn render_resolution_(\n     let local_name = local_name.to_smol_str();\n     let mut item = CompletionItem::new(kind, ctx.source_range(), local_name.clone());\n     if let ScopeDef::Local(local) = resolution {\n-        let ty = local.ty(ctx.db());\n+        let ty = local.ty(db);\n         if !ty.is_unknown() {\n-            item.detail(ty.display(ctx.db()).to_string());\n+            item.detail(ty.display(db).to_string());\n         }\n \n         item.set_relevance(CompletionRelevance {\n@@ -224,15 +223,15 @@ fn render_resolution_(\n     };\n \n     // Add `<>` for generic types\n-    if matches!(\n+    let type_path_no_ty_args = matches!(\n         ctx.completion.path_context,\n         Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n-    ) && ctx.completion.config.add_call_parenthesis\n-    {\n+    ) && ctx.completion.config.add_call_parenthesis;\n+    if type_path_no_ty_args {\n         if let Some(cap) = ctx.snippet_cap() {\n             let has_non_default_type_params = match resolution {\n-                ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db()),\n-                ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db()),\n+                ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(db),\n+                ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(db),\n                 _ => false,\n             };\n             if has_non_default_type_params {\n@@ -243,7 +242,7 @@ fn render_resolution_(\n             }\n         }\n     }\n-    item.set_documentation(scope_def_docs(ctx.db(), resolution))\n+    item.set_documentation(scope_def_docs(db, resolution))\n         .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n \n     if let Some(import_to_add) = import_to_add {"}, {"sha": "f166b87ab631c1b0a50732258910d8ad52083608", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 105, "deletions": 114, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/a720fc8e3a8ae3d8052d0c87767056408bc25ffa/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a720fc8e3a8ae3d8052d0c87767056408bc25ffa/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "patch": "@@ -1,162 +1,153 @@\n //! Renderer for function calls.\n \n-use hir::{AsAssocItem, HirDisplay};\n+use hir::{db::HirDatabase, AsAssocItem, HirDisplay};\n use ide_db::SymbolKind;\n use itertools::Itertools;\n use stdx::format_to;\n \n use crate::{\n+    context::CompletionContext,\n     item::{CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit},\n     render::{\n         builder_ext::Params, compute_exact_name_match, compute_ref_match, compute_type_match,\n         RenderContext,\n     },\n };\n \n+enum FuncType {\n+    Function,\n+    Method(Option<hir::Name>),\n+}\n+\n pub(crate) fn render_fn(\n     ctx: RenderContext<'_>,\n     import_to_add: Option<ImportEdit>,\n     local_name: Option<hir::Name>,\n-    fn_: hir::Function,\n-) -> Option<CompletionItem> {\n+    func: hir::Function,\n+) -> CompletionItem {\n     let _p = profile::span(\"render_fn\");\n-    Some(FunctionRender::new(ctx, None, local_name, fn_, false)?.render(import_to_add))\n+    render(ctx, local_name, func, FuncType::Function, import_to_add)\n }\n \n pub(crate) fn render_method(\n     ctx: RenderContext<'_>,\n     import_to_add: Option<ImportEdit>,\n     receiver: Option<hir::Name>,\n     local_name: Option<hir::Name>,\n-    fn_: hir::Function,\n-) -> Option<CompletionItem> {\n+    func: hir::Function,\n+) -> CompletionItem {\n     let _p = profile::span(\"render_method\");\n-    Some(FunctionRender::new(ctx, receiver, local_name, fn_, true)?.render(import_to_add))\n+    render(ctx, local_name, func, FuncType::Method(receiver), import_to_add)\n }\n \n-#[derive(Debug)]\n-struct FunctionRender<'a> {\n-    ctx: RenderContext<'a>,\n-    name: hir::Name,\n-    receiver: Option<hir::Name>,\n+fn render(\n+    ctx @ RenderContext { completion }: RenderContext<'_>,\n+    local_name: Option<hir::Name>,\n     func: hir::Function,\n-    is_method: bool,\n-}\n-\n-impl<'a> FunctionRender<'a> {\n-    fn new(\n-        ctx: RenderContext<'a>,\n-        receiver: Option<hir::Name>,\n-        local_name: Option<hir::Name>,\n-        fn_: hir::Function,\n-        is_method: bool,\n-    ) -> Option<FunctionRender<'a>> {\n-        let name = local_name.unwrap_or_else(|| fn_.name(ctx.db()));\n-\n-        Some(FunctionRender { ctx, name, receiver, func: fn_, is_method })\n-    }\n+    func_type: FuncType,\n+    import_to_add: Option<ImportEdit>,\n+) -> CompletionItem {\n+    let db = completion.db;\n \n-    fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n-        let params = self.params();\n-        let call = match &self.receiver {\n-            Some(receiver) => format!(\"{}.{}\", receiver, &self.name),\n-            None => self.name.to_string(),\n-        };\n-        let mut item = CompletionItem::new(self.kind(), self.ctx.source_range(), call.clone());\n-        item.set_documentation(self.ctx.docs(self.func))\n-            .set_deprecated(\n-                self.ctx.is_deprecated(self.func) || self.ctx.is_deprecated_assoc_item(self.func),\n-            )\n-            .detail(self.detail())\n-            .add_call_parens(self.ctx.completion, call.clone(), params);\n-\n-        if import_to_add.is_none() {\n-            let db = self.ctx.db();\n-            if let Some(actm) = self.func.as_assoc_item(db) {\n-                if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n-                    item.trait_name(trt.name(db).to_smol_str());\n-                }\n-            }\n-        }\n+    let name = local_name.unwrap_or_else(|| func.name(db));\n+    let params = params(completion, func, &func_type);\n \n-        if let Some(import_to_add) = import_to_add {\n-            item.add_import(import_to_add);\n-        }\n-        item.lookup_by(self.name.to_smol_str());\n-\n-        let ret_type = self.func.ret_type(self.ctx.db());\n-        item.set_relevance(CompletionRelevance {\n-            type_match: compute_type_match(self.ctx.completion, &ret_type),\n-            exact_name_match: compute_exact_name_match(self.ctx.completion, &call),\n-            ..CompletionRelevance::default()\n-        });\n-\n-        if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ret_type) {\n-            // FIXME\n-            // For now we don't properly calculate the edits for ref match\n-            // completions on methods, so we've disabled them. See #8058.\n-            if !self.is_method {\n-                item.ref_match(ref_match);\n+    // FIXME: SmolStr?\n+    let call = match &func_type {\n+        FuncType::Method(Some(receiver)) => format!(\"{}.{}\", receiver, &name),\n+        _ => name.to_string(),\n+    };\n+    let mut item = CompletionItem::new(\n+        if func.self_param(db).is_some() {\n+            CompletionItemKind::Method\n+        } else {\n+            CompletionItemKind::SymbolKind(SymbolKind::Function)\n+        },\n+        ctx.source_range(),\n+        call.clone(),\n+    );\n+    item.set_documentation(ctx.docs(func))\n+        .set_deprecated(ctx.is_deprecated(func) || ctx.is_deprecated_assoc_item(func))\n+        .detail(detail(db, func))\n+        .add_call_parens(completion, call.clone(), params);\n+\n+    if import_to_add.is_none() {\n+        if let Some(actm) = func.as_assoc_item(db) {\n+            if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n+                item.trait_name(trt.name(db).to_smol_str());\n             }\n         }\n-\n-        item.build()\n     }\n \n-    fn detail(&self) -> String {\n-        let ret_ty = self.func.ret_type(self.ctx.db());\n-        let mut detail = format!(\"fn({})\", self.params_display());\n-        if !ret_ty.is_unit() {\n-            format_to!(detail, \" -> {}\", ret_ty.display(self.ctx.db()));\n+    if let Some(import_to_add) = import_to_add {\n+        item.add_import(import_to_add);\n+    }\n+    item.lookup_by(name.to_smol_str());\n+\n+    let ret_type = func.ret_type(db);\n+    item.set_relevance(CompletionRelevance {\n+        type_match: compute_type_match(completion, &ret_type),\n+        exact_name_match: compute_exact_name_match(completion, &call),\n+        ..CompletionRelevance::default()\n+    });\n+\n+    if let Some(ref_match) = compute_ref_match(completion, &ret_type) {\n+        // FIXME\n+        // For now we don't properly calculate the edits for ref match\n+        // completions on methods, so we've disabled them. See #8058.\n+        if matches!(func_type, FuncType::Function) {\n+            item.ref_match(ref_match);\n         }\n-        detail\n     }\n \n-    fn params_display(&self) -> String {\n-        if let Some(self_param) = self.func.self_param(self.ctx.db()) {\n-            let params = self\n-                .func\n-                .assoc_fn_params(self.ctx.db())\n-                .into_iter()\n-                .skip(1) // skip the self param because we are manually handling that\n-                .map(|p| p.ty().display(self.ctx.db()).to_string());\n+    item.build()\n+}\n \n-            std::iter::once(self_param.display(self.ctx.db()).to_owned()).chain(params).join(\", \")\n-        } else {\n-            let params = self\n-                .func\n-                .assoc_fn_params(self.ctx.db())\n-                .into_iter()\n-                .map(|p| p.ty().display(self.ctx.db()).to_string())\n-                .join(\", \");\n-            params\n-        }\n+fn detail(db: &dyn HirDatabase, func: hir::Function) -> String {\n+    let ret_ty = func.ret_type(db);\n+    let mut detail = format!(\"fn({})\", params_display(db, func));\n+    if !ret_ty.is_unit() {\n+        format_to!(detail, \" -> {}\", ret_ty.display(db));\n     }\n+    detail\n+}\n \n-    fn params(&self) -> Params {\n-        let (params, self_param) =\n-            if self.ctx.completion.has_dot_receiver() || self.receiver.is_some() {\n-                (self.func.method_params(self.ctx.db()).unwrap_or_default(), None)\n-            } else {\n-                let self_param = self.func.self_param(self.ctx.db());\n-\n-                let mut assoc_params = self.func.assoc_fn_params(self.ctx.db());\n-                if self_param.is_some() {\n-                    assoc_params.remove(0);\n-                }\n-                (assoc_params, self_param)\n-            };\n-\n-        Params::Named(self_param, params)\n+fn params_display(db: &dyn HirDatabase, func: hir::Function) -> String {\n+    if let Some(self_param) = func.self_param(db) {\n+        let assoc_fn_params = func.assoc_fn_params(db);\n+        let params = assoc_fn_params\n+            .iter()\n+            .skip(1) // skip the self param because we are manually handling that\n+            .map(|p| p.ty().display(db));\n+        format!(\n+            \"{}{}\",\n+            self_param.display(db),\n+            params.format_with(\"\", |display, f| {\n+                f(&\", \")?;\n+                f(&display)\n+            })\n+        )\n+    } else {\n+        let assoc_fn_params = func.assoc_fn_params(db);\n+        assoc_fn_params.iter().map(|p| p.ty().display(db)).join(\", \")\n     }\n+}\n \n-    fn kind(&self) -> CompletionItemKind {\n-        if self.func.self_param(self.ctx.db()).is_some() {\n-            CompletionItemKind::Method\n+fn params(ctx: &CompletionContext<'_>, func: hir::Function, func_type: &FuncType) -> Params {\n+    let (params, self_param) =\n+        if ctx.has_dot_receiver() || matches!(func_type, FuncType::Method(Some(_))) {\n+            (func.method_params(ctx.db).unwrap_or_default(), None)\n         } else {\n-            SymbolKind::Function.into()\n-        }\n-    }\n+            let self_param = func.self_param(ctx.db);\n+\n+            let mut assoc_params = func.assoc_fn_params(ctx.db);\n+            if self_param.is_some() {\n+                assoc_params.remove(0);\n+            }\n+            (assoc_params, self_param)\n+        };\n+\n+    Params::Named(self_param, params)\n }\n \n #[cfg(test)]"}]}