{"sha": "151de909c161549f938a2ba624a56969b0056681", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MWRlOTA5YzE2MTU0OWY5MzhhMmJhNjI0YTU2OTY5YjAwNTY2ODE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-31T06:20:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-31T06:20:31Z"}, "message": "rustc: Do less work still in typestate", "tree": {"sha": "7ec6d90e5aae600d4ad63178cb102d915b5cf8fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ec6d90e5aae600d4ad63178cb102d915b5cf8fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/151de909c161549f938a2ba624a56969b0056681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/151de909c161549f938a2ba624a56969b0056681", "html_url": "https://github.com/rust-lang/rust/commit/151de909c161549f938a2ba624a56969b0056681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/151de909c161549f938a2ba624a56969b0056681/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02dde781eb71b9acc42447edcba12a3c380c3269", "url": "https://api.github.com/repos/rust-lang/rust/commits/02dde781eb71b9acc42447edcba12a3c380c3269", "html_url": "https://github.com/rust-lang/rust/commit/02dde781eb71b9acc42447edcba12a3c380c3269"}], "stats": {"total": 98, "additions": 52, "deletions": 46}, "files": [{"sha": "c34953ac33e6f5c3c907bf26101d2eb3d525df97", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=151de909c161549f938a2ba624a56969b0056681", "patch": "@@ -224,7 +224,8 @@ type fn_info =\n     {constrs: constr_map,\n      num_constraints: uint,\n      cf: ret_style,\n-     used_vars: @mut [node_id]};\n+     used_vars: @mut [node_id],\n+     ignore: bool};\n \n /* mapping from node ID to typestate annotation */\n type node_ann_table = @mut [mut ts_ann];"}, {"sha": "a200a05d1794e2cf6ac2e27f851659a2460208a4", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=151de909c161549f938a2ba624a56969b0056681", "patch": "@@ -116,10 +116,11 @@ fn fn_states(fk: visit::fn_kind, f_decl: ast::fn_decl, f_body: ast::blk,\n              sp: span, id: node_id,\n              ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n \n+    visit::visit_fn(fk, f_decl, f_body, sp, id, ccx, v);\n+\n     // We may not care about typestate for this function if it contains\n     // no constrained calls\n-    if ccx.fm.contains_key(id) {\n-        visit::visit_fn(fk, f_decl, f_body, sp, id, ccx, v);\n+    if !ccx.fm.get(id).ignore {\n         /* Look up the var-to-bit-num map for this function */\n \n         let f_info = ccx.fm.get(id);"}, {"sha": "f8575569c5ac89936261753752a95c572ac8dc9c", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=151de909c161549f938a2ba624a56969b0056681", "patch": "@@ -69,6 +69,34 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n     ret next + 1u;\n }\n \n+fn contains_constrained_calls(tcx: ty::ctxt, body: blk) -> bool {\n+    type cx = @{\n+        tcx: ty::ctxt,\n+        mut has: bool\n+    };\n+    let cx = @{\n+        tcx: tcx,\n+        mut has: false\n+    };\n+    let vtor = visit::default_visitor::<cx>();\n+    let vtor = @{visit_expr: visit_expr with *vtor};\n+    visit::visit_block(body, cx, visit::mk_vt(vtor));\n+    ret cx.has;\n+\n+    fn visit_expr(e: @expr, &&cx: cx, v: visit::vt<cx>) {\n+        import syntax::print::pprust;\n+        #debug(\"visiting %?\", pprust::expr_to_str(e));\n+\n+        visit::visit_expr(e, cx, v);\n+\n+        if constraints_expr(cx.tcx, e).is_not_empty() {\n+            #debug(\"has constraints\");\n+            cx.has = true;\n+        } else {\n+            #debug(\"has not constraints\");\n+        }\n+    }\n+}\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n@@ -86,24 +114,29 @@ fn mk_fn_info(ccx: crate_ctxt,\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    let mut i = 0u, l = vec::len(*cx.cs);\n-    while i < l {\n-        next = add_constraint(cx.tcx, copy cx.cs[i], next, res_map);\n-        i += 1u;\n-    }\n-    /* if this function has any constraints, instantiate them to the\n-       argument names and add them */\n-    for f_decl.constraints.each {|c|\n-        let sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n-        next = add_constraint(cx.tcx, sc, next, res_map);\n+    let ignore = !contains_constrained_calls(ccx.tcx, f_body);\n+\n+    if !ignore {\n+        let mut i = 0u, l = vec::len(*cx.cs);\n+        while i < l {\n+            next = add_constraint(cx.tcx, copy cx.cs[i], next, res_map);\n+            i += 1u;\n+        }\n+        /* if this function has any constraints, instantiate them to the\n+        argument names and add them */\n+        for f_decl.constraints.each {|c|\n+            let sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n+            next = add_constraint(cx.tcx, sc, next, res_map);\n+        }\n     }\n \n     let v: @mut [node_id] = @mut [];\n     let rslt =\n         {constrs: res_map,\n          num_constraints: next,\n          cf: f_decl.cf,\n-         used_vars: v};\n+         used_vars: v,\n+         ignore: ignore};\n     ccx.fm.insert(id, rslt);\n     #debug(\"%s has %u constraints\", name, num_constraints(rslt));\n }"}, {"sha": "5890a51b02958b252c7c5e5ffff9afd75a1cb0a1", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151de909c161549f938a2ba624a56969b0056681/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=151de909c161549f938a2ba624a56969b0056681", "patch": "@@ -618,42 +618,13 @@ fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n     }\n }\n \n-fn contains_constrained_calls(tcx: ty::ctxt, body: blk) -> bool {\n-    type cx = @{\n-        tcx: ty::ctxt,\n-        mut has: bool\n-    };\n-    let cx = @{\n-        tcx: tcx,\n-        mut has: false\n-    };\n-    let vtor = visit::default_visitor::<cx>();\n-    let vtor = @{visit_expr: visit_expr with *vtor};\n-    visit::visit_block(body, cx, visit::mk_vt(vtor));\n-    ret cx.has;\n-\n-    fn visit_expr(e: @expr, &&cx: cx, v: visit::vt<cx>) {\n-        import syntax::print::pprust;\n-        #debug(\"visiting %?\", pprust::expr_to_str(e));\n-\n-        visit::visit_expr(e, cx, v);\n-\n-        if constraints_expr(cx.tcx, e).is_not_empty() {\n-            #debug(\"has constraints\");\n-            cx.has = true;\n-        } else {\n-            #debug(\"has not constraints\");\n-        }\n-    }\n-}\n-\n fn fn_pre_post(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n                id: node_id,\n                ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n \n-    if contains_constrained_calls(ccx.tcx, body) {\n-        visit::visit_fn(fk, decl, body, sp, id, ccx, v);\n-        assert (ccx.fm.contains_key(id));\n+    visit::visit_fn(fk, decl, body, sp, id, ccx, v);\n+    assert (ccx.fm.contains_key(id));\n+    if !ccx.fm.get(id).ignore {\n         let fcx =\n             {enclosing: ccx.fm.get(id),\n              id: id,"}]}