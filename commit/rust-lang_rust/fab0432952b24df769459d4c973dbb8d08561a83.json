{"sha": "fab0432952b24df769459d4c973dbb8d08561a83", "node_id": "C_kwDOAAsO6NoAKGZhYjA0MzI5NTJiMjRkZjc2OTQ1OWQ0Yzk3M2RiYjhkMDg1NjFhODM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-30T10:52:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-30T10:52:04Z"}, "message": "Auto merge of #103010 - petrochenkov:effvisdoc, r=GuillaumeGomez\n\nrustdoc: Simplify modifications of effective visibility table\n\nIt is now obvious that rustdoc only calls `set_access_level` with foreign def ids and `AccessLevel::Public`.\n\nThe second commit makes one more step and separates effective visibilities coming from rustc from similar data collected by rustdoc for extern `DefId`s.\nThe original table is no longer modified and now only contains local def ids as populated by rustc.\n\ncc https://github.com/rust-lang/rust/pull/102026 `@Bryanskiy`", "tree": {"sha": "e8ef8844b764e2849249fd92b2bc2124154fc20c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8ef8844b764e2849249fd92b2bc2124154fc20c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab0432952b24df769459d4c973dbb8d08561a83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab0432952b24df769459d4c973dbb8d08561a83", "html_url": "https://github.com/rust-lang/rust/commit/fab0432952b24df769459d4c973dbb8d08561a83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab0432952b24df769459d4c973dbb8d08561a83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96c330af5e3baebe7a80999744e2e082b279d0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96c330af5e3baebe7a80999744e2e082b279d0a", "html_url": "https://github.com/rust-lang/rust/commit/e96c330af5e3baebe7a80999744e2e082b279d0a"}, {"sha": "f1850d4c9b5f4f64ad41193bb8c846027754f0ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1850d4c9b5f4f64ad41193bb8c846027754f0ca", "html_url": "https://github.com/rust-lang/rust/commit/f1850d4c9b5f4f64ad41193bb8c846027754f0ca"}], "stats": {"total": 252, "additions": 108, "deletions": 144}, "files": [{"sha": "ffbd6d10da6b20aaeee2c63541bd04aafa2fac88", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -6,8 +6,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::def_id::{DefId, LocalDefId};\n-use std::hash::Hash;\n+use rustc_span::def_id::LocalDefId;\n \n /// Represents the levels of effective visibility an item can have.\n ///\n@@ -75,33 +74,33 @@ impl EffectiveVisibility {\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n-#[derive(Debug, Clone)]\n-pub struct EffectiveVisibilities<Id = LocalDefId> {\n-    map: FxHashMap<Id, EffectiveVisibility>,\n+#[derive(Default, Clone, Debug)]\n+pub struct EffectiveVisibilities {\n+    map: FxHashMap<LocalDefId, EffectiveVisibility>,\n }\n \n-impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n-    pub fn is_public_at_level(&self, id: Id, level: Level) -> bool {\n+impl EffectiveVisibilities {\n+    pub fn is_public_at_level(&self, id: LocalDefId, level: Level) -> bool {\n         self.effective_vis(id)\n             .map_or(false, |effective_vis| effective_vis.is_public_at_level(level))\n     }\n \n     /// See `Level::Reachable`.\n-    pub fn is_reachable(&self, id: Id) -> bool {\n+    pub fn is_reachable(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Reachable)\n     }\n \n     /// See `Level::Reexported`.\n-    pub fn is_exported(&self, id: Id) -> bool {\n+    pub fn is_exported(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Reexported)\n     }\n \n     /// See `Level::Direct`.\n-    pub fn is_directly_public(&self, id: Id) -> bool {\n+    pub fn is_directly_public(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Direct)\n     }\n \n-    pub fn public_at_level(&self, id: Id) -> Option<Level> {\n+    pub fn public_at_level(&self, id: LocalDefId) -> Option<Level> {\n         self.effective_vis(id).and_then(|effective_vis| {\n             for level in Level::all_levels() {\n                 if effective_vis.is_public_at_level(level) {\n@@ -112,24 +111,17 @@ impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n         })\n     }\n \n-    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+    pub fn effective_vis(&self, id: LocalDefId) -> Option<&EffectiveVisibility> {\n         self.map.get(&id)\n     }\n \n-    pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n+    pub fn iter(&self) -> impl Iterator<Item = (&LocalDefId, &EffectiveVisibility)> {\n         self.map.iter()\n     }\n \n-    pub fn map_id<OutId: Hash + Eq + Copy>(\n-        &self,\n-        f: impl Fn(Id) -> OutId,\n-    ) -> EffectiveVisibilities<OutId> {\n-        EffectiveVisibilities { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n-    }\n-\n     pub fn set_public_at_level(\n         &mut self,\n-        id: Id,\n+        id: LocalDefId,\n         default_vis: impl FnOnce() -> Visibility,\n         level: Level,\n     ) {\n@@ -144,23 +136,21 @@ impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n         }\n         self.map.insert(id, effective_vis);\n     }\n-}\n \n-impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n         &mut self,\n-        id: Id,\n+        id: LocalDefId,\n         nominal_vis: Visibility,\n         default_vis: impl FnOnce() -> Visibility,\n-        parent_id: Id,\n+        parent_id: LocalDefId,\n         level: Level,\n         tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n         let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n-            if id.into().is_crate_root() {\n+            if id.is_top_level_module() {\n                 EffectiveVisibility::from_vis(Visibility::Public)\n             } else {\n                 EffectiveVisibility::from_vis(default_vis())\n@@ -204,12 +194,6 @@ impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     }\n }\n \n-impl<Id> Default for EffectiveVisibilities<Id> {\n-    fn default() -> Self {\n-        EffectiveVisibilities { map: Default::default() }\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let EffectiveVisibilities { ref map } = *self;"}, {"sha": "f82fb498131eb0e286a3b1308288a7d72540e707", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n         for trait_def_id in cx.tcx.all_traits() {\n-            if !cx.cache.effective_visibilities.is_directly_public(trait_def_id)\n+            if !cx.cache.effective_visibilities.is_directly_public(cx.tcx, trait_def_id)\n                 || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n             {\n                 continue;"}, {"sha": "c823ed0f16efb4f4cebd4c710c0f89e757e75855", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -374,7 +374,7 @@ pub(crate) fn build_impl(\n     if !did.is_local() {\n         if let Some(traitref) = associated_trait {\n             let did = traitref.def_id;\n-            if !cx.cache.effective_visibilities.is_directly_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n                 return;\n             }\n \n@@ -403,7 +403,7 @@ pub(crate) fn build_impl(\n     // reachable in rustdoc generated documentation\n     if !did.is_local() {\n         if let Some(did) = for_.def_id(&cx.cache) {\n-            if !cx.cache.effective_visibilities.is_directly_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n                 return;\n             }\n "}, {"sha": "8a0e6a82126bca3ae3cb8c339f754c12bbdf65a9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -1431,7 +1431,7 @@ fn maybe_expand_private_type_alias<'tcx>(\n     let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n     // Substitute private type aliases\n     let def_id = def_id.as_local()?;\n-    let alias = if !cx.cache.effective_visibilities.is_exported(def_id.to_def_id()) {\n+    let alias = if !cx.cache.effective_visibilities.is_exported(cx.tcx, def_id.to_def_id()) {\n         &cx.tcx.hir().expect_item(def_id).kind\n     } else {\n         return None;"}, {"sha": "8f3e29a31a0728ce9bb1fb3cd090db8c04cd37c4", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -8,7 +8,6 @@ use crate::clean::{\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n-use crate::visit_lib::LibEmbargoVisitor;\n \n use rustc_ast as ast;\n use rustc_ast::tokenstream::TokenTree;\n@@ -32,7 +31,7 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n     for &cnum in cx.tcx.crates(()) {\n         // Analyze doc-reachability for extern items\n-        LibEmbargoVisitor::new(cx).visit_lib(cnum);\n+        crate::visit_lib::lib_embargo_visit_item(cx, cnum.as_def_id());\n     }\n \n     // Clean the crate, translating the entire librustc_ast AST to one that is"}, {"sha": "3961802529b294cad1272745b141ba2eb26d0dbe", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -348,7 +348,6 @@ pub(crate) fn run_global_ctxt(\n \n     let auto_traits =\n         tcx.all_traits().filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id)).collect();\n-    let effective_visibilities = tcx.effective_visibilities(()).map_id(Into::into);\n \n     let mut ctxt = DocContext {\n         tcx,\n@@ -361,7 +360,7 @@ pub(crate) fn run_global_ctxt(\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits,\n-        cache: Cache::new(effective_visibilities, render_options.document_private),\n+        cache: Cache::new(render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,\n         render_options,"}, {"sha": "a0cf1ec78e25615cf8e1991d7acc90ca3c6dff2b", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -2,7 +2,6 @@ use std::mem;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n \n@@ -15,6 +14,7 @@ use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::search_index::get_function_type_for_search;\n use crate::html::render::IndexItem;\n+use crate::visit_lib::RustdocEffectiveVisibilities;\n \n /// This cache is used to store information about the [`clean::Crate`] being\n /// rendered in order to provide more useful documentation. This contains\n@@ -78,7 +78,7 @@ pub(crate) struct Cache {\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the effective visibilities from the privacy check pass.\n-    pub(crate) effective_visibilities: EffectiveVisibilities<DefId>,\n+    pub(crate) effective_visibilities: RustdocEffectiveVisibilities,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n     pub(crate) crate_version: Option<String>,\n@@ -132,11 +132,8 @@ struct CacheBuilder<'a, 'tcx> {\n }\n \n impl Cache {\n-    pub(crate) fn new(\n-        effective_visibilities: EffectiveVisibilities<DefId>,\n-        document_private: bool,\n-    ) -> Self {\n-        Cache { effective_visibilities, document_private, ..Cache::default() }\n+    pub(crate) fn new(document_private: bool) -> Self {\n+        Cache { document_private, ..Cache::default() }\n     }\n \n     /// Populates the `Cache` with more data. The returned `Crate` will be missing some data that was\n@@ -387,7 +384,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         || self\n                             .cache\n                             .effective_visibilities\n-                            .is_directly_public(item.item_id.expect_def_id())\n+                            .is_directly_public(self.tcx, item.item_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n                             item.item_id.expect_def_id(),"}, {"sha": "37202f786ed80f7b30cfb1e07f6015a00029ba2a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -659,7 +659,7 @@ pub(crate) fn href_with_root_path(\n     }\n \n     if !did.is_local()\n-        && !cache.effective_visibilities.is_directly_public(did)\n+        && !cache.effective_visibilities.is_directly_public(tcx, did)\n         && !cache.document_private\n         && !cache.primitive_locations.values().any(|&id| id == did)\n     {"}, {"sha": "057d2fdd9d5fce5b568108af8f4c4ce4f71cc509", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -56,7 +56,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.effective_visibilities.is_directly_public(item.item_id.expect_def_id())\n+    if !cx.cache.effective_visibilities.is_directly_public(cx.tcx, item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -130,7 +130,7 @@ pub(crate) fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item\n             );\n         }\n     } else if tests.found_tests > 0\n-        && !cx.cache.effective_visibilities.is_exported(item.item_id.expect_def_id())\n+        && !cx.cache.effective_visibilities.is_exported(cx.tcx, item.item_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "e07a788a72a41e53bc3ea98827579b4717067dc4", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -27,6 +27,7 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n \n     // strip all impls referencing stripped items\n     let mut stripper = ImplStripper {\n+        tcx: cx.tcx,\n         retained: &retained,\n         cache: &cx.cache,\n         is_json_output,"}, {"sha": "e3b958b2036e30e8cb03dc86ea9d5e71c7ea7645", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -22,6 +22,7 @@ pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) ->\n     // strip all private items\n     {\n         let mut stripper = Stripper {\n+            tcx: cx.tcx,\n             retained: &mut retained,\n             effective_visibilities: &cx.cache.effective_visibilities,\n             update_retained: true,\n@@ -32,6 +33,7 @@ pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) ->\n \n     // strip all impls referencing private items\n     let mut stripper = ImplStripper {\n+        tcx: cx.tcx,\n         retained: &retained,\n         cache: &cx.cache,\n         is_json_output,"}, {"sha": "4fa5c04ddf61d8e384834afce02697bd6d13bc13", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -1,17 +1,19 @@\n //! A collection of utility functions for the `strip_*` passes.\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::privacy::EffectiveVisibilities;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n use std::mem;\n \n use crate::clean::{self, Item, ItemId, ItemIdSet, NestedAttributesExt};\n use crate::fold::{strip_item, DocFolder};\n use crate::formats::cache::Cache;\n+use crate::visit_lib::RustdocEffectiveVisibilities;\n \n-pub(crate) struct Stripper<'a> {\n+pub(crate) struct Stripper<'a, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) retained: &'a mut ItemIdSet,\n-    pub(crate) effective_visibilities: &'a EffectiveVisibilities<DefId>,\n+    pub(crate) effective_visibilities: &'a RustdocEffectiveVisibilities,\n     pub(crate) update_retained: bool,\n     pub(crate) is_json_output: bool,\n }\n@@ -21,18 +23,19 @@ pub(crate) struct Stripper<'a> {\n // are in the public API, which is not enough.\n #[inline]\n fn is_item_reachable(\n+    tcx: TyCtxt<'_>,\n     is_json_output: bool,\n-    effective_visibilities: &EffectiveVisibilities<DefId>,\n+    effective_visibilities: &RustdocEffectiveVisibilities,\n     item_id: ItemId,\n ) -> bool {\n     if is_json_output {\n-        effective_visibilities.is_reachable(item_id.expect_def_id())\n+        effective_visibilities.is_reachable(tcx, item_id.expect_def_id())\n     } else {\n-        effective_visibilities.is_exported(item_id.expect_def_id())\n+        effective_visibilities.is_exported(tcx, item_id.expect_def_id())\n     }\n }\n \n-impl<'a> DocFolder for Stripper<'a> {\n+impl<'a> DocFolder for Stripper<'a, '_> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match *i.kind {\n             clean::StrippedItem(..) => {\n@@ -66,7 +69,12 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 let item_id = i.item_id;\n                 if item_id.is_local()\n-                    && !is_item_reachable(self.is_json_output, self.effective_visibilities, item_id)\n+                    && !is_item_reachable(\n+                        self.tcx,\n+                        self.is_json_output,\n+                        self.effective_visibilities,\n+                        item_id,\n+                    )\n                 {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n@@ -146,30 +154,31 @@ impl<'a> DocFolder for Stripper<'a> {\n }\n \n /// This stripper discards all impls which reference stripped items\n-pub(crate) struct ImplStripper<'a> {\n+pub(crate) struct ImplStripper<'a, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) retained: &'a ItemIdSet,\n     pub(crate) cache: &'a Cache,\n     pub(crate) is_json_output: bool,\n     pub(crate) document_private: bool,\n }\n \n-impl<'a> ImplStripper<'a> {\n+impl<'a> ImplStripper<'a, '_> {\n     #[inline]\n     fn should_keep_impl(&self, item: &Item, for_def_id: DefId) -> bool {\n         if !for_def_id.is_local() || self.retained.contains(&for_def_id.into()) {\n             true\n         } else if self.is_json_output {\n             // If the \"for\" item is exported and the impl block isn't `#[doc(hidden)]`, then we\n             // need to keep it.\n-            self.cache.effective_visibilities.is_exported(for_def_id)\n+            self.cache.effective_visibilities.is_exported(self.tcx, for_def_id)\n                 && !item.attrs.lists(sym::doc).has_word(sym::hidden)\n         } else {\n             false\n         }\n     }\n }\n \n-impl<'a> DocFolder for ImplStripper<'a> {\n+impl<'a> DocFolder for ImplStripper<'a, '_> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = *i.kind {\n             // Impl blocks can be skipped if they are: empty; not a trait impl; and have no\n@@ -185,6 +194,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                         let item_id = i.item_id;\n                         item_id.is_local()\n                             && !is_item_reachable(\n+                                self.tcx,\n                                 self.is_json_output,\n                                 &self.cache.effective_visibilities,\n                                 item_id,"}, {"sha": "7ee7eb25e0d90ca8165bf67354f3300e893dae61", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -7,15 +7,14 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_middle::middle::privacy::Level;\n-use rustc_middle::ty::{TyCtxt, Visibility};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use std::mem;\n \n-use crate::clean::{self, cfg::Cfg, AttributesExt, NestedAttributesExt};\n+use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -221,23 +220,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n         if !res_did.is_local() && !is_no_inline {\n-            let attrs = clean::inline::load_attrs(self.cx, res_did);\n-            let self_is_hidden = attrs.lists(sym::doc).has_word(sym::hidden);\n-            if !self_is_hidden {\n-                if let Res::Def(kind, did) = res {\n-                    if kind == DefKind::Mod {\n-                        crate::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did)\n-                    } else {\n-                        // All items need to be handled here in case someone wishes to link\n-                        // to them with intra-doc links\n-                        self.cx.cache.effective_visibilities.set_public_at_level(\n-                            did,\n-                            || Visibility::Restricted(CRATE_DEF_ID),\n-                            Level::Direct,\n-                        );\n-                    }\n-                }\n-            }\n+            crate::visit_lib::lib_embargo_visit_item(self.cx, res_did);\n             return false;\n         }\n \n@@ -246,7 +229,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false,\n         };\n \n-        let is_private = !self.cx.cache.effective_visibilities.is_directly_public(res_did);\n+        let is_private =\n+            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, res_did);\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped."}, {"sha": "e490559b0e92addd40d61d7f25f040749ffa4fb6", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0432952b24df769459d4c973dbb8d08561a83/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=fab0432952b24df769459d4c973dbb8d08561a83", "patch": "@@ -1,86 +1,74 @@\n+use crate::core::DocContext;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n-use rustc_middle::ty::{TyCtxt, Visibility};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::TyCtxt;\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n+#[derive(Default)]\n+pub(crate) struct RustdocEffectiveVisibilities {\n+    extern_public: FxHashSet<DefId>,\n+}\n+\n+macro_rules! define_method {\n+    ($method:ident) => {\n+        pub(crate) fn $method(&self, tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+            match def_id.as_local() {\n+                Some(def_id) => tcx.effective_visibilities(()).$method(def_id),\n+                None => self.extern_public.contains(&def_id),\n+            }\n+        }\n+    };\n+}\n+\n+impl RustdocEffectiveVisibilities {\n+    define_method!(is_directly_public);\n+    define_method!(is_exported);\n+    define_method!(is_reachable);\n+}\n+\n+pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n+    assert!(!def_id.is_local());\n+    LibEmbargoVisitor {\n+        tcx: cx.tcx,\n+        extern_public: &mut cx.cache.effective_visibilities.extern_public,\n+        visited_mods: Default::default(),\n+    }\n+    .visit_item(def_id)\n+}\n+\n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-pub(crate) struct LibEmbargoVisitor<'a, 'tcx> {\n+struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // Effective visibilities for reachable nodes\n-    effective_visibilities: &'a mut EffectiveVisibilities<DefId>,\n-    // Previous level, None means unreachable\n-    prev_level: Option<Level>,\n+    extern_public: &'a mut FxHashSet<DefId>,\n     // Keeps track of already visited modules, in case a module re-exports its parent\n     visited_mods: FxHashSet<DefId>,\n }\n \n-impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n-    pub(crate) fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n-        LibEmbargoVisitor {\n-            tcx: cx.tcx,\n-            effective_visibilities: &mut cx.cache.effective_visibilities,\n-            prev_level: Some(Level::Direct),\n-            visited_mods: FxHashSet::default(),\n-        }\n-    }\n-\n-    pub(crate) fn visit_lib(&mut self, cnum: CrateNum) {\n-        let did = cnum.as_def_id();\n-        self.update(did, Some(Level::Direct));\n-        self.visit_mod(did);\n-    }\n-\n-    // Updates node level and returns the updated level\n-    fn update(&mut self, did: DefId, level: Option<Level>) -> Option<Level> {\n-        let is_hidden = self.tcx.is_doc_hidden(did);\n-\n-        let old_level = self.effective_visibilities.public_at_level(did);\n-        // Visibility levels can only grow\n-        if level > old_level && !is_hidden {\n-            self.effective_visibilities.set_public_at_level(\n-                did,\n-                || Visibility::Restricted(CRATE_DEF_ID),\n-                level.unwrap(),\n-            );\n-            level\n-        } else {\n-            old_level\n-        }\n-    }\n-\n-    pub(crate) fn visit_mod(&mut self, def_id: DefId) {\n+impl LibEmbargoVisitor<'_, '_> {\n+    fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n             return;\n         }\n \n         for item in self.tcx.module_children(def_id).iter() {\n             if let Some(def_id) = item.res.opt_def_id() {\n-                if self.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index)\n-                    || item.vis.is_public()\n-                {\n-                    self.visit_item(item.res);\n+                if item.vis.is_public() {\n+                    self.visit_item(def_id);\n                 }\n             }\n         }\n     }\n \n-    fn visit_item(&mut self, res: Res<!>) {\n-        let def_id = res.def_id();\n-        let vis = self.tcx.visibility(def_id);\n-        let inherited_item_level = if vis.is_public() { self.prev_level } else { None };\n-\n-        let item_level = self.update(def_id, inherited_item_level);\n-\n-        if let Res::Def(DefKind::Mod, _) = res {\n-            let orig_level = self.prev_level;\n-\n-            self.prev_level = item_level;\n-            self.visit_mod(def_id);\n-            self.prev_level = orig_level;\n+    fn visit_item(&mut self, def_id: DefId) {\n+        if !self.tcx.is_doc_hidden(def_id) {\n+            self.extern_public.insert(def_id);\n+            if self.tcx.def_kind(def_id) == DefKind::Mod {\n+                self.visit_mod(def_id);\n+            }\n         }\n     }\n }"}]}