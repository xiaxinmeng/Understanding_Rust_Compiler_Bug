{"sha": "b0a396bb0af5ad7706ffa2fafdec761012df200d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYTM5NmJiMGFmNWFkNzcwNmZmYTJmYWZkZWM3NjEwMTJkZjIwMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-05T09:17:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-05T09:17:00Z"}, "message": "Auto merge of #47920 - Aaron1011:nll-overflow, r=pnkfelix\n\nFix overflow when performing drop check calculations in NLL\n\nClearing out the infcx's region constraints after processing each type\nends up interacting badly with normalizing associated types. This commit\nkeeps all region constraints intact until the end of\nTypeLivenessGenerator.add_drop_live_constraint, ensuring that normalized\ntypes are able to re-use existing inference variables.\n\nFixes #47589", "tree": {"sha": "c94cb08cb72c903c809d84a54b09afb64d6dbb6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c94cb08cb72c903c809d84a54b09afb64d6dbb6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0a396bb0af5ad7706ffa2fafdec761012df200d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a396bb0af5ad7706ffa2fafdec761012df200d", "html_url": "https://github.com/rust-lang/rust/commit/b0a396bb0af5ad7706ffa2fafdec761012df200d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0a396bb0af5ad7706ffa2fafdec761012df200d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07ea2604075d6f896addce0e6949c7cf25dd3715", "url": "https://api.github.com/repos/rust-lang/rust/commits/07ea2604075d6f896addce0e6949c7cf25dd3715", "html_url": "https://github.com/rust-lang/rust/commit/07ea2604075d6f896addce0e6949c7cf25dd3715"}, {"sha": "a7646df923c62343959c0955a955ee19562da1ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7646df923c62343959c0955a955ee19562da1ff", "html_url": "https://github.com/rust-lang/rust/commit/a7646df923c62343959c0955a955ee19562da1ff"}], "stats": {"total": 148, "additions": 111, "deletions": 37}, "files": [{"sha": "a50b99937475eba58f30a0a67ebf517a6d307460", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 78, "deletions": 37, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b0a396bb0af5ad7706ffa2fafdec761012df200d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a396bb0af5ad7706ffa2fafdec761012df200d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=b0a396bb0af5ad7706ffa2fafdec761012df200d", "patch": "@@ -15,7 +15,10 @@ use dataflow::move_paths::{HasMoveData, MoveData};\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::mir::Local;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::traits;\n+use rustc::infer::InferOk;\n use rustc::util::common::ErrorReported;\n+use borrow_check::nll::type_check::AtLocation;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::codemap::DUMMY_SP;\n use util::liveness::LivenessResults;\n@@ -184,48 +187,86 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             location\n         );\n \n-        let tcx = self.cx.infcx.tcx;\n-        let mut types = vec![(dropped_ty, 0)];\n-        let mut known = FxHashSet();\n-        while let Some((ty, depth)) = types.pop() {\n-            let span = DUMMY_SP; // FIXME\n-            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n-                Ok(result) => result,\n-                Err(ErrorReported) => {\n-                    continue;\n-                }\n-            };\n-\n-            let ty::DtorckConstraint {\n-                outlives,\n-                dtorck_types,\n-            } = result;\n-\n-            // All things in the `outlives` array may be touched by\n-            // the destructor and must be live at this point.\n-            for outlive in outlives {\n-                let cause = Cause::DropVar(dropped_local, location);\n-                self.push_type_live_constraint(outlive, location, cause);\n-            }\n+        // If we end visiting the same type twice (usually due to a cycle involving\n+        // associated types), we need to ensure that its region types match up with the type\n+        // we added to the 'known' map the first time around. For this reason, we need\n+        // our infcx to hold onto its calculated region constraints after each call\n+        // to dtorck_constraint_for_ty. Otherwise, normalizing the corresponding associated\n+        // type will end up instantiating the type with a new set of inference variables\n+        // Since this new type will never be in 'known', we end up looping forever.\n+        //\n+        // For this reason, we avoid calling TypeChecker.normalize, instead doing all normalization\n+        // ourselves in one large 'fully_perform_op' callback.\n+        let (type_constraints, kind_constraints) = self.cx.fully_perform_op(location.at_self(),\n+            |cx| {\n+\n+            let tcx = cx.infcx.tcx;\n+            let mut selcx = traits::SelectionContext::new(cx.infcx);\n+            let cause = cx.misc(cx.last_span);\n+\n+            let mut types = vec![(dropped_ty, 0)];\n+            let mut final_obligations = Vec::new();\n+            let mut type_constraints = Vec::new();\n+            let mut kind_constraints = Vec::new();\n \n-            // However, there may also be some types that\n-            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n-            // associated types and parameters). We need to normalize\n-            // associated types here and possibly recursively process.\n-            for ty in dtorck_types {\n-                let ty = self.cx.normalize(&ty, location);\n-                let ty = self.cx.infcx.resolve_type_and_region_vars_if_possible(&ty);\n-                match ty.sty {\n-                    ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                        let cause = Cause::DropVar(dropped_local, location);\n-                        self.push_type_live_constraint(ty, location, cause);\n+            let mut known = FxHashSet();\n+\n+            while let Some((ty, depth)) = types.pop() {\n+                let span = DUMMY_SP; // FIXME\n+                let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n+                    Ok(result) => result,\n+                    Err(ErrorReported) => {\n+                        continue;\n                     }\n+                };\n+\n+                let ty::DtorckConstraint {\n+                    outlives,\n+                    dtorck_types,\n+                } = result;\n+\n+                // All things in the `outlives` array may be touched by\n+                // the destructor and must be live at this point.\n+                for outlive in outlives {\n+                    let cause = Cause::DropVar(dropped_local, location);\n+                    kind_constraints.push((outlive, location, cause));\n+                }\n \n-                    _ => if known.insert(ty) {\n-                        types.push((ty, depth + 1));\n-                    },\n+                // However, there may also be some types that\n+                // `dtorck_constraint_for_ty` could not resolve (e.g.,\n+                // associated types and parameters). We need to normalize\n+                // associated types here and possibly recursively process.\n+                for ty in dtorck_types {\n+                    let traits::Normalized { value: ty, obligations } =\n+                        traits::normalize(&mut selcx, cx.param_env, cause.clone(), &ty);\n+\n+                    final_obligations.extend(obligations);\n+\n+                    let ty = cx.infcx.resolve_type_and_region_vars_if_possible(&ty);\n+                    match ty.sty {\n+                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+                            let cause = Cause::DropVar(dropped_local, location);\n+                            type_constraints.push((ty, location, cause));\n+                        }\n+\n+                        _ => if known.insert(ty) {\n+                            types.push((ty, depth + 1));\n+                        },\n+                    }\n                 }\n             }\n+\n+            Ok(InferOk {\n+                value: (type_constraints, kind_constraints), obligations: final_obligations\n+            })\n+        }).unwrap();\n+\n+        for (ty, location, cause) in type_constraints {\n+            self.push_type_live_constraint(ty, location, cause);\n+        }\n+\n+        for (kind, location, cause) in kind_constraints {\n+            self.push_type_live_constraint(kind, location, cause);\n         }\n     }\n }"}, {"sha": "393c18efad0adb17af157ae551e0e901df419ccd", "filename": "src/test/run-pass/nll/issue-47589.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b0a396bb0af5ad7706ffa2fafdec761012df200d/src%2Ftest%2Frun-pass%2Fnll%2Fissue-47589.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a396bb0af5ad7706ffa2fafdec761012df200d/src%2Ftest%2Frun-pass%2Fnll%2Fissue-47589.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnll%2Fissue-47589.rs?ref=b0a396bb0af5ad7706ffa2fafdec761012df200d", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+pub struct DescriptorSet<'a> {\n+    pub slots: Vec<AttachInfo<'a, Resources>>\n+}\n+\n+pub trait ResourcesTrait<'r>: Sized {\n+    type DescriptorSet: 'r;\n+}\n+\n+pub struct Resources;\n+\n+impl<'a> ResourcesTrait<'a> for Resources {\n+    type DescriptorSet = DescriptorSet<'a>;\n+}\n+\n+pub enum AttachInfo<'a, R: ResourcesTrait<'a>> {\n+    NextDescriptorSet(Box<R::DescriptorSet>)\n+}\n+\n+fn main() {\n+    let _x = DescriptorSet {slots: Vec::new()};\n+}"}]}