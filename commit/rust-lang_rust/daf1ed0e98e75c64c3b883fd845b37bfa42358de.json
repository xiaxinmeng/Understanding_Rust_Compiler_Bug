{"sha": "daf1ed0e98e75c64c3b883fd845b37bfa42358de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjFlZDBlOThlNzVjNjRjM2I4ODNmZDg0NWIzN2JmYTQyMzU4ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T06:36:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T06:36:12Z"}, "message": "Auto merge of #61373 - tmandry:emit-storagedead-along-unwind, r=eddyb\n\nEmit StorageDead along unwind paths for generators\n\nCompletion of the work done in #60840. That PR made a change to implicitly consider a local `StorageDead` after Drop, but that was incorrect for DropAndReplace (see also #61060 which tried to fix this in a different way).\n\nThis finally enables the optimization implemented in #60187.\n\nr? @eddyb\ncc @Zoxc @cramertj @RalfJung", "tree": {"sha": "b837eeea66f507e65fd05df9d7c269fbef684951", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b837eeea66f507e65fd05df9d7c269fbef684951"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf1ed0e98e75c64c3b883fd845b37bfa42358de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf1ed0e98e75c64c3b883fd845b37bfa42358de", "html_url": "https://github.com/rust-lang/rust/commit/daf1ed0e98e75c64c3b883fd845b37bfa42358de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf1ed0e98e75c64c3b883fd845b37bfa42358de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "url": "https://api.github.com/repos/rust-lang/rust/commits/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "html_url": "https://github.com/rust-lang/rust/commit/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27"}, {"sha": "7718b14301b96c06c97d2c200508e0703b3de953", "url": "https://api.github.com/repos/rust-lang/rust/commits/7718b14301b96c06c97d2c200508e0703b3de953", "html_url": "https://github.com/rust-lang/rust/commit/7718b14301b96c06c97d2c200508e0703b3de953"}], "stats": {"total": 344, "additions": 247, "deletions": 97}, "files": [{"sha": "8e2c3dd3d8ad9d5ffb72d70838ebf6dcb86c0750", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -666,7 +666,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     size,\n                     align,\n                 });\n-                debug!(\"generator layout: {:#?}\", layout);\n+                debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n                 layout\n             }\n "}, {"sha": "85423955ce545acc28ff23afc67de49b9f540ecb", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -1,7 +1,7 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::build::scope::{CachedBlock, DropKind};\n+use crate::build::scope::DropKind;\n use crate::hair::*;\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -103,9 +103,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 temp_lifetime,\n                 temp_place,\n                 expr_ty,\n-                DropKind::Value {\n-                    cached_block: CachedBlock::default(),\n-                },\n+                DropKind::Value,\n             );\n         }\n "}, {"sha": "20d1423f8a8b6ef97256e633273b50e0fedfe536", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -5,7 +5,7 @@\n //! This also includes code for pattern bindings in `let` statements and\n //! function parameters.\n \n-use crate::build::scope::{CachedBlock, DropKind};\n+use crate::build::scope::DropKind;\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n@@ -557,9 +557,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             region_scope,\n             &Place::Base(PlaceBase::Local(local_id)),\n             var_ty,\n-            DropKind::Value {\n-                cached_block: CachedBlock::default(),\n-            },\n+            DropKind::Value,\n         );\n     }\n "}, {"sha": "c8a31ecffb84dc03a6ffb345ab12dc817228f97c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -1,5 +1,5 @@\n use crate::build;\n-use crate::build::scope::{CachedBlock, DropKind};\n+use crate::build::scope::DropKind;\n use crate::hair::cx::Cx;\n use crate::hair::{LintLevel, BindingMode, PatternKind};\n use crate::shim;\n@@ -912,8 +912,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n                 pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n-                argument_scope, &place, ty,\n-                DropKind::Value { cached_block: CachedBlock::default() },\n+                argument_scope, &place, ty, DropKind::Value,\n             );\n \n             if let Some(pattern) = pattern {"}, {"sha": "b697b9884367cbf9ef75b81a6792c7b2245e3b33", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 87, "deletions": 75, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -88,7 +88,7 @@ use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::hir;\n use rustc::mir::*;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{DUMMY_SP, Span};\n use rustc_data_structures::fx::FxHashMap;\n use std::collections::hash_map::Entry;\n use std::mem;\n@@ -143,10 +143,13 @@ struct DropData<'tcx> {\n \n     /// Whether this is a value Drop or a StorageDead.\n     kind: DropKind,\n+\n+    /// The cached blocks for unwinds.\n+    cached_block: CachedBlock,\n }\n \n #[derive(Debug, Default, Clone, Copy)]\n-pub(crate) struct CachedBlock {\n+struct CachedBlock {\n     /// The cached block for the cleanups-on-diverge path. This block\n     /// contains code to run the current drop and all the preceding\n     /// drops (i.e., those having lower index in Drop\u2019s Scope drop\n@@ -164,10 +167,8 @@ pub(crate) struct CachedBlock {\n \n #[derive(Debug)]\n pub(crate) enum DropKind {\n-    Value {\n-        cached_block: CachedBlock,\n-    },\n-    Storage\n+    Value,\n+    Storage,\n }\n \n #[derive(Clone, Debug)]\n@@ -210,7 +211,7 @@ impl CachedBlock {\n impl DropKind {\n     fn may_panic(&self) -> bool {\n         match *self {\n-            DropKind::Value { .. } => true,\n+            DropKind::Value => true,\n             DropKind::Storage => false\n         }\n     }\n@@ -225,25 +226,24 @@ impl<'tcx> Scope<'tcx> {\n     /// `storage_only` controls whether to invalidate only drop paths that run `StorageDead`.\n     /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n     /// top-of-scope (as opposed to dependent scopes).\n-    fn invalidate_cache(&mut self, storage_only: bool, this_scope_only: bool) {\n+    fn invalidate_cache(&mut self, storage_only: bool, is_generator: bool, this_scope_only: bool) {\n         // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n         // with lots of `try!`?\n \n         // cached exits drop storage and refer to the top-of-scope\n         self.cached_exits.clear();\n \n-        if !storage_only {\n-            // the current generator drop and unwind ignore\n-            // storage but refer to top-of-scope\n-            self.cached_generator_drop = None;\n+        // the current generator drop and unwind refer to top-of-scope\n+        self.cached_generator_drop = None;\n+\n+        let ignore_unwinds = storage_only && !is_generator;\n+        if !ignore_unwinds {\n             self.cached_unwind.invalidate();\n         }\n \n-        if !storage_only && !this_scope_only {\n+        if !ignore_unwinds && !this_scope_only {\n             for drop_data in &mut self.drops {\n-                if let DropKind::Value { ref mut cached_block } = drop_data.kind {\n-                    cached_block.invalidate();\n-                }\n+                drop_data.cached_block.invalidate();\n             }\n         }\n     }\n@@ -388,6 +388,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         unpack!(block = build_scope_drops(\n             &mut self.cfg,\n+            self.is_generator,\n             &scope,\n             block,\n             unwind_to,\n@@ -454,6 +455,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n+                self.is_generator,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -484,10 +486,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let result = block;\n \n         while let Some(scope) = scopes.next() {\n-            if !scope.needs_cleanup && !self.is_generator {\n-                continue;\n-            }\n-\n             block = if let Some(b) = scope.cached_generator_drop {\n                 self.cfg.terminate(block, src_info,\n                                    TerminatorKind::Goto { target: b });\n@@ -508,6 +506,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n+                self.is_generator,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -642,16 +641,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         place: &Place<'tcx>,\n         place_ty: Ty<'tcx>,\n     ) {\n-        self.schedule_drop(\n-            span, region_scope, place, place_ty,\n-            DropKind::Storage,\n-        );\n-        self.schedule_drop(\n-            span, region_scope, place, place_ty,\n-            DropKind::Value {\n-                cached_block: CachedBlock::default(),\n-            },\n-        );\n+        self.schedule_drop(span, region_scope, place, place_ty, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, place, place_ty, DropKind::Value);\n     }\n \n     // Scheduling drops\n@@ -671,7 +662,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ) {\n         let needs_drop = self.hir.needs_drop(place_ty);\n         match drop_kind {\n-            DropKind::Value { .. } => if !needs_drop { return },\n+            DropKind::Value => if !needs_drop { return },\n             DropKind::Storage => {\n                 match *place {\n                     Place::Base(PlaceBase::Local(index)) => if index.index() <= self.arg_count {\n@@ -736,9 +727,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n             // cache of outer scope stays intact.\n-            scope.invalidate_cache(!needs_drop, this_scope);\n+            scope.invalidate_cache(!needs_drop, self.is_generator, this_scope);\n             if this_scope {\n-                if let DropKind::Value { .. } = drop_kind {\n+                if let DropKind::Value = drop_kind {\n                     scope.needs_cleanup = true;\n                 }\n \n@@ -750,7 +741,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 scope.drops.push(DropData {\n                     span: scope_end,\n                     location: place.clone(),\n-                    kind: drop_kind\n+                    kind: drop_kind,\n+                    cached_block: CachedBlock::default(),\n                 });\n                 return;\n             }\n@@ -797,6 +789,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // to left reading the cached results but never created anything.\n \n         // Find the last cached block\n+        debug!(\"diverge_cleanup_gen(self.scopes = {:?})\", self.scopes);\n         let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n             .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n             (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n@@ -890,7 +883,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n-        top_scope.invalidate_cache(false, true);\n+        top_scope.invalidate_cache(false, self.is_generator, true);\n     }\n \n     /// Drops the single variable provided\n@@ -941,21 +934,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        top_scope.invalidate_cache(true, true);\n+        top_scope.invalidate_cache(true, self.is_generator, true);\n     }\n \n }\n \n /// Builds drops for pop_scope and exit_scope.\n fn build_scope_drops<'tcx>(\n     cfg: &mut CFG<'tcx>,\n+    is_generator: bool,\n     scope: &Scope<'tcx>,\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n     generator_drop: bool,\n ) -> BlockAnd<()> {\n-    debug!(\"build_scope_drops({:?} -> {:?}\", block, scope);\n+    debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n \n     // Build up the drops in evaluation order. The end result will\n     // look like:\n@@ -969,28 +963,20 @@ fn build_scope_drops<'tcx>(\n     // The horizontal arrows represent the execution path when the drops return\n     // successfully. The downwards arrows represent the execution path when the\n     // drops panic (panicking while unwinding will abort, so there's no need for\n-    // another set of arrows). The drops for the unwind path should have already\n-    // been generated by `diverge_cleanup_gen`.\n-\n-    let mut unwind_blocks = scope.drops.iter().rev().filter_map(|drop_data| {\n-        if let DropKind::Value { cached_block } = drop_data.kind {\n-            Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n-                span_bug!(drop_data.span, \"cached block not present?\")\n-            }))\n-        } else {\n-            None\n-        }\n-    });\n-\n-    // When we unwind from a drop, we start cleaning up from the next one, so\n-    // we don't need this block.\n-    unwind_blocks.next();\n+    // another set of arrows).\n+    //\n+    // For generators, we unwind from a drop on a local to its StorageDead\n+    // statement. For other functions we don't worry about StorageDead. The\n+    // drops for the unwind path should have already been generated by\n+    // `diverge_cleanup_gen`.\n \n-    for drop_data in scope.drops.iter().rev() {\n+    for drop_idx in (0..scope.drops.len()).rev() {\n+        let drop_data = &scope.drops[drop_idx];\n         let source_info = scope.source_info(drop_data.span);\n         match drop_data.kind {\n-            DropKind::Value { .. } => {\n-                let unwind_to = unwind_blocks.next().unwrap_or(last_unwind_to);\n+            DropKind::Value => {\n+                let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)\n+                    .unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n@@ -1018,6 +1004,31 @@ fn build_scope_drops<'tcx>(\n     block.unit()\n }\n \n+fn get_unwind_to<'tcx>(\n+    scope: &Scope<'tcx>,\n+    is_generator: bool,\n+    unwind_from: usize,\n+    generator_drop: bool,\n+) -> Option<BasicBlock> {\n+    for drop_idx in (0..unwind_from).rev() {\n+        let drop_data = &scope.drops[drop_idx];\n+        match (is_generator, &drop_data.kind) {\n+            (true, DropKind::Storage) => {\n+                return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n+                    span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n+                }));\n+            }\n+            (false, DropKind::Value) => {\n+                return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n+                    span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n+                }));\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}\n+\n fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                              span: Span,\n                              scope: &mut Scope<'tcx>,\n@@ -1051,6 +1062,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n     // Build up the drops. Here we iterate the vector in\n     // *forward* order, so that we generate drops[0] first (right to\n     // left in diagram above).\n+    debug!(\"build_diverge_scope({:?})\", scope.drops);\n     for (j, drop_data) in scope.drops.iter_mut().enumerate() {\n         debug!(\"build_diverge_scope drop_data[{}]: {:?}\", j, drop_data);\n         // Only full value drops are emitted in the diverging path,\n@@ -1070,20 +1082,30 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                             source_info: source_info(drop_data.span),\n                             kind: StatementKind::StorageDead(index)\n                         });\n+                        if !target_built_by_us {\n+                            // We cannot add statements to an existing block, so we create a new\n+                            // block for our StorageDead statements.\n+                            let block = cfg.start_new_cleanup_block();\n+                            let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n+                            cfg.terminate(block, source_info,\n+                                          TerminatorKind::Goto { target: target });\n+                            target = block;\n+                            target_built_by_us = true;\n+                        }\n                     }\n                     _ => unreachable!(),\n                 };\n+                *drop_data.cached_block.ref_mut(generator_drop) = Some(target);\n             }\n             DropKind::Storage => {}\n-            DropKind::Value { ref mut cached_block } => {\n-                let cached_block = cached_block.ref_mut(generator_drop);\n+            DropKind::Value => {\n+                let cached_block = drop_data.cached_block.ref_mut(generator_drop);\n                 target = if let Some(cached_block) = *cached_block {\n                     storage_deads.clear();\n                     target_built_by_us = false;\n                     cached_block\n                 } else {\n-                    push_storage_deads(\n-                        cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n+                    push_storage_deads(cfg, target, &mut storage_deads);\n                     let block = cfg.start_new_cleanup_block();\n                     cfg.terminate(block, source_info(drop_data.span),\n                                   TerminatorKind::Drop {\n@@ -1098,7 +1120,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n             }\n         };\n     }\n-    push_storage_deads(cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n+    push_storage_deads(cfg, target, &mut storage_deads);\n     *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n \n     assert!(storage_deads.is_empty());\n@@ -1108,23 +1130,13 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n }\n \n fn push_storage_deads(cfg: &mut CFG<'tcx>,\n-                      target: &mut BasicBlock,\n-                      storage_deads: &mut Vec<Statement<'tcx>>,\n-                      target_built_by_us: bool,\n-                      source_scope: SourceScope) {\n+                      target: BasicBlock,\n+                      storage_deads: &mut Vec<Statement<'tcx>>) {\n     if storage_deads.is_empty() { return; }\n-    if !target_built_by_us {\n-        // We cannot add statements to an existing block, so we create a new\n-        // block for our StorageDead statements.\n-        let block = cfg.start_new_cleanup_block();\n-        let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n-        cfg.terminate(block, source_info, TerminatorKind::Goto { target: *target });\n-        *target = block;\n-    }\n-    let statements = &mut cfg.block_data_mut(*target).statements;\n+    let statements = &mut cfg.block_data_mut(target).statements;\n     storage_deads.reverse();\n     debug!(\"push_storage_deads({:?}), storage_deads={:?}, statements={:?}\",\n-           *target, storage_deads, statements);\n+           target, storage_deads, statements);\n     storage_deads.append(statements);\n     mem::swap(statements, storage_deads);\n     assert!(storage_deads.is_empty());"}, {"sha": "9bf346f5f62d64814b4d4b018cefd17fcb6f35c7", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -43,16 +43,9 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     }\n \n     fn terminator_effect(&self,\n-                         sets: &mut BlockSets<'_, Local>,\n-                         loc: Location) {\n-        match &self.mir[loc.block].terminator().kind {\n-            TerminatorKind::Drop { location, .. } => {\n-                if let Some(l) = location.local_or_deref_local() {\n-                    sets.kill(l);\n-                }\n-            }\n-            _ => (),\n-        }\n+                         _sets: &mut BlockSets<'_, Local>,\n+                         _loc: Location) {\n+        // Terminators have no effect\n     }\n \n     fn propagate_call_return("}, {"sha": "7be17c4292ae67b53a236598a34048ea27fd0289", "filename": "src/test/mir-opt/generator-storage-dead-unwind.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -0,0 +1,106 @@\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+// Test that we generate StorageDead on unwind paths for generators.\n+//\n+// Basic block and local names can safely change, but the StorageDead statements\n+// should not go away.\n+\n+#![feature(generators, generator_trait)]\n+\n+struct Foo(i32);\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Bar(i32);\n+\n+fn take<T>(_x: T) {}\n+\n+fn main() {\n+    let _gen = || {\n+        let a = Foo(5);\n+        let b = Bar(6);\n+        yield;\n+        take(a);\n+        take(b);\n+    };\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.main-{{closure}}.StateTransform.before.mir\n+// ...\n+// let _2: Foo;\n+// ...\n+// let mut _7: Foo;\n+// ...\n+// let mut _9: Bar;\n+// scope 1 {\n+//     let _3: Bar;\n+//     scope 2 {\n+//     }\n+// }\n+// bb0: {\n+//     StorageLive(_2);\n+//     _2 = Foo(const 5i32,);\n+//     StorageLive(_3);\n+//     _3 = Bar(const 6i32,);\n+//     ...\n+//     _1 = suspend(move _5) -> [resume: bb2, drop: bb4];\n+// }\n+// bb1 (cleanup): {\n+//     resume;\n+// }\n+// bb2: {\n+//     ...\n+//     StorageLive(_7);\n+//     _7 = move _2;\n+//     _6 = const take::<Foo>(move _7) -> [return: bb9, unwind: bb8];\n+// }\n+// bb3 (cleanup): {\n+//     StorageDead(_2);\n+//     drop(_1) -> bb1;\n+// }\n+// bb4: {\n+//     ...\n+//     StorageDead(_3);\n+//     drop(_2) -> [return: bb5, unwind: bb3];\n+// }\n+// bb5: {\n+//     StorageDead(_2);\n+//     drop(_1) -> [return: bb6, unwind: bb1];\n+// }\n+// bb6: {\n+//     generator_drop;\n+// }\n+// bb7 (cleanup): {\n+//     StorageDead(_3);\n+//     StorageDead(_2);\n+//     drop(_1) -> bb1;\n+// }\n+// bb8 (cleanup): {\n+//     StorageDead(_7);\n+//     goto -> bb7;\n+// }\n+// bb9: {\n+//     StorageDead(_7);\n+//     StorageLive(_9);\n+//     _9 = move _3;\n+//     _8 = const take::<Bar>(move _9) -> [return: bb10, unwind: bb11];\n+// }\n+// bb10: {\n+//     StorageDead(_9);\n+//     ...\n+//     StorageDead(_3);\n+//     StorageDead(_2);\n+//     drop(_1) -> [return: bb12, unwind: bb1];\n+// }\n+// bb11 (cleanup): {\n+//     StorageDead(_9);\n+//     goto -> bb7;\n+// }\n+// bb12: {\n+//     return;\n+// }\n+// END rustc.main-{{closure}}.StateTransform.before.mir"}, {"sha": "042e1276db5c60c2bed61b928ff8252e3e23209f", "filename": "src/test/run-pass/generator/drop-and-replace.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-and-replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1ed0e98e75c64c3b883fd845b37bfa42358de/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-and-replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-and-replace.rs?ref=daf1ed0e98e75c64c3b883fd845b37bfa42358de", "patch": "@@ -0,0 +1,44 @@\n+// Regression test for incorrect DropAndReplace behavior introduced in #60840\n+// and fixed in #61373. When combined with the optimization implemented in\n+// #60187, this produced incorrect code for generators when a saved local was\n+// re-assigned.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+use std::pin::Pin;\n+\n+#[derive(Debug, PartialEq)]\n+struct Foo(i32);\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) { }\n+}\n+\n+fn main() {\n+    let mut a = || {\n+        let mut x = Foo(4);\n+        yield;\n+        assert_eq!(x.0, 4);\n+\n+        // At one point this tricked our dataflow analysis into thinking `x` was\n+        // StorageDead after the assignment.\n+        x = Foo(5);\n+        assert_eq!(x.0, 5);\n+\n+        {\n+            let y = Foo(6);\n+            yield;\n+            assert_eq!(y.0, 6);\n+        }\n+\n+        assert_eq!(x.0, 5);\n+    };\n+\n+    loop {\n+        match Pin::new(&mut a).resume() {\n+            GeneratorState::Complete(()) => break,\n+            _ => (),\n+        }\n+    }\n+}"}]}