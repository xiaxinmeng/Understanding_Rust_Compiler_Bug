{"sha": "45f0ce71c19d8da081714dc917f11a8cc02d15be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZjBjZTcxYzE5ZDhkYTA4MTcxNGRjOTE3ZjExYThjYzAyZDE1YmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-06T02:29:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-06T02:29:34Z"}, "message": "Auto merge of #31920 - jseyfried:fix_spurious_privacy_error, r=nikomatsakis\n\nThis PR allows using methods from traits that are visible but are defined in an inaccessible module (fixes #18241). For example,\n```rust\nmod foo {\n    pub use foo::bar::Tr;\n    mod bar { // This module is inaccessible from `g`\n        pub trait Tr { fn f(&self) {} }\n    }\n}\nfn g<T: foo::Tr>(t: T) {\n    t.f(); // Currently, this is a privacy error even though `foo::Tr` is visible\n}\n```\n\nAfter this PR, it will continue to be a privacy error to use a method from a trait that is not visible. This can happen when a public trait inherits from a private trait (in violation of the `public_in_private` lint) -- see @petrochenkov's example in #28504.\nr? @nikomatsakis", "tree": {"sha": "80b760addf4deae8de33b8c783ea53e374fb36f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80b760addf4deae8de33b8c783ea53e374fb36f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45f0ce71c19d8da081714dc917f11a8cc02d15be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45f0ce71c19d8da081714dc917f11a8cc02d15be", "html_url": "https://github.com/rust-lang/rust/commit/45f0ce71c19d8da081714dc917f11a8cc02d15be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45f0ce71c19d8da081714dc917f11a8cc02d15be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52e0bda644823089f16795cc9e071cf827b4810b", "url": "https://api.github.com/repos/rust-lang/rust/commits/52e0bda644823089f16795cc9e071cf827b4810b", "html_url": "https://github.com/rust-lang/rust/commit/52e0bda644823089f16795cc9e071cf827b4810b"}, {"sha": "d908ff1759bf27a8a8a99f113a246b8abc61f425", "url": "https://api.github.com/repos/rust-lang/rust/commits/d908ff1759bf27a8a8a99f113a246b8abc61f425", "html_url": "https://github.com/rust-lang/rust/commit/d908ff1759bf27a8a8a99f113a246b8abc61f425"}], "stats": {"total": 140, "additions": 67, "deletions": 73}, "files": [{"sha": "214ac81ee5092c3f306c498938f4b02807b33a06", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 36, "deletions": 72, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/45f0ce71c19d8da081714dc917f11a8cc02d15be/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f0ce71c19d8da081714dc917f11a8cc02d15be/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=45f0ce71c19d8da081714dc917f11a8cc02d15be", "patch": "@@ -492,11 +492,6 @@ enum FieldName {\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    // used when debugging\n-    fn nodestr(&self, id: ast::NodeId) -> String {\n-        self.tcx.map.node_to_string(id).to_string()\n-    }\n-\n     // Determines whether the given definition is public from the point of view\n     // of the current item.\n     fn def_privacy(&self, did: DefId) -> PrivacyResult {\n@@ -604,75 +599,44 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             return Allowable;\n         }\n \n-        // We now know that there is at least one private member between the\n-        // destination and the root.\n-        let mut closest_private_id = node_id;\n-        loop {\n-            debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n-            let vis = match self.tcx.map.find(closest_private_id) {\n-                // If this item is a method, then we know for sure that it's an\n-                // actual method and not a static method. The reason for this is\n-                // that these cases are only hit in the ExprMethodCall\n-                // expression, and ExprCall will have its path checked later\n-                // (the path of the trait/impl) if it's a static method.\n-                //\n-                // With this information, then we can completely ignore all\n-                // trait methods. The privacy violation would be if the trait\n-                // couldn't get imported, not if the method couldn't be used\n-                // (all trait methods are public).\n-                //\n-                // However, if this is an impl method, then we dictate this\n-                // decision solely based on the privacy of the method\n-                // invocation.\n-                // FIXME(#10573) is this the right behavior? Why not consider\n-                //               where the method was defined?\n-                Some(ast_map::NodeImplItem(ii)) => {\n-                    match ii.node {\n-                        hir::ImplItemKind::Const(..) |\n-                        hir::ImplItemKind::Method(..) => {\n-                            let imp = self.tcx.map\n-                                          .get_parent_did(closest_private_id);\n-                            match self.tcx.impl_trait_ref(imp) {\n-                                Some(..) => return Allowable,\n-                                _ if ii.vis == hir::Public => {\n-                                    return Allowable\n-                                }\n-                                _ => ii.vis\n-                            }\n-                        }\n-                        hir::ImplItemKind::Type(_) => return Allowable,\n-                    }\n-                }\n-                Some(ast_map::NodeTraitItem(_)) => {\n-                    return Allowable;\n+        let vis = match self.tcx.map.find(node_id) {\n+            // If this item is a method, then we know for sure that it's an\n+            // actual method and not a static method. The reason for this is\n+            // that these cases are only hit in the ExprMethodCall\n+            // expression, and ExprCall will have its path checked later\n+            // (the path of the trait/impl) if it's a static method.\n+            //\n+            // With this information, then we can completely ignore all\n+            // trait methods. The privacy violation would be if the trait\n+            // couldn't get imported, not if the method couldn't be used\n+            // (all trait methods are public).\n+            //\n+            // However, if this is an impl method, then we dictate this\n+            // decision solely based on the privacy of the method\n+            // invocation.\n+            Some(ast_map::NodeImplItem(ii)) => {\n+                let imp = self.tcx.map.get_parent_did(node_id);\n+                match self.tcx.impl_trait_ref(imp) {\n+                    Some(..) => hir::Public,\n+                    _ => ii.vis,\n                 }\n+            }\n+            Some(ast_map::NodeTraitItem(_)) => hir::Public,\n \n-                // This is not a method call, extract the visibility as one\n-                // would normally look at it\n-                Some(ast_map::NodeItem(it)) => it.vis,\n-                Some(ast_map::NodeForeignItem(_)) => {\n-                    self.tcx.map.get_foreign_vis(closest_private_id)\n-                }\n-                Some(ast_map::NodeVariant(..)) => {\n-                    hir::Public // need to move up a level (to the enum)\n-                }\n-                _ => hir::Public,\n-            };\n-            if vis != hir::Public { break }\n-            // if we've reached the root, then everything was allowable and this\n-            // access is public.\n-            if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = *self.parents.get(&closest_private_id).unwrap();\n-\n-            // If we reached the top, then we were public all the way down and\n-            // we can allow this access.\n-            if closest_private_id == ast::DUMMY_NODE_ID { return Allowable }\n-        }\n-        debug!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n-        if self.private_accessible(closest_private_id) {\n+            // This is not a method call, extract the visibility as one\n+            // would normally look at it\n+            Some(ast_map::NodeItem(it)) => it.vis,\n+            Some(ast_map::NodeForeignItem(_)) => {\n+                self.tcx.map.get_foreign_vis(node_id)\n+            }\n+            _ => hir::Public,\n+        };\n+        if vis == hir::Public { return Allowable }\n+\n+        if self.private_accessible(node_id) {\n             Allowable\n         } else {\n-            DisallowedBy(closest_private_id)\n+            DisallowedBy(node_id)\n         }\n     }\n \n@@ -834,8 +798,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n             ty::TraitContainer(trait_def_id) => {\n-                self.report_error(self.ensure_public(span, trait_def_id,\n-                                                     None, \"source trait\"));\n+                let msg = format!(\"source trait `{}`\", self.tcx.item_path_str(trait_def_id));\n+                self.report_error(self.ensure_public(span, trait_def_id, None, &msg));\n             }\n         }\n     }"}, {"sha": "5feef0a24eb0e93a717f61d52b5608410a97ef03", "filename": "src/test/compile-fail/trait-not-accessible.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45f0ce71c19d8da081714dc917f11a8cc02d15be/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f0ce71c19d8da081714dc917f11a8cc02d15be/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs?ref=45f0ce71c19d8da081714dc917f11a8cc02d15be", "patch": "@@ -20,7 +20,7 @@ struct S;\n impl m::Pub for S {}\n \n fn g<T: m::Pub>(arg: T) {\n-    arg.f(); //~ ERROR: source trait is private\n+    arg.f(); //~ ERROR: source trait `m::Priv` is private\n }\n \n fn main() {"}, {"sha": "a0d0014a06471722fe68e7c835d103d0aca0fd18", "filename": "src/test/compile-fail/trait-privacy.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/45f0ce71c19d8da081714dc917f11a8cc02d15be/src%2Ftest%2Fcompile-fail%2Ftrait-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f0ce71c19d8da081714dc917f11a8cc02d15be/src%2Ftest%2Fcompile-fail%2Ftrait-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-privacy.rs?ref=45f0ce71c19d8da081714dc917f11a8cc02d15be", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod foo {\n+    pub use self::bar::T;\n+    mod bar {\n+        pub trait T {\n+            fn f(&self) {}\n+        }\n+        impl T for () {}\n+    }\n+}\n+\n+fn g() {\n+    use foo::T;\n+    ().f(); // Check that this does not trigger a privacy error\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}]}