{"sha": "a5b3f33cb90bf991342afa552bcd993e36f80fa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YjNmMzNjYjkwYmY5OTEzNDJhZmE1NTJiY2Q5OTNlMzZmODBmYTc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-09T16:04:04Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-11T11:24:21Z"}, "message": "Eliminate `comments::Literal`", "tree": {"sha": "b9b0b68babb748088183f59438fed5baeba47fb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9b0b68babb748088183f59438fed5baeba47fb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5b3f33cb90bf991342afa552bcd993e36f80fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b3f33cb90bf991342afa552bcd993e36f80fa7", "html_url": "https://github.com/rust-lang/rust/commit/a5b3f33cb90bf991342afa552bcd993e36f80fa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5b3f33cb90bf991342afa552bcd993e36f80fa7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "751ae5af1a561a93ce61e9971be4b254a57e6576", "url": "https://api.github.com/repos/rust-lang/rust/commits/751ae5af1a561a93ce61e9971be4b254a57e6576", "html_url": "https://github.com/rust-lang/rust/commit/751ae5af1a561a93ce61e9971be4b254a57e6576"}], "stats": {"total": 271, "additions": 61, "deletions": 210}, "files": [{"sha": "6d48ad94a6677a8091d662b71dc02980b99d401b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 7, "deletions": 38, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a5b3f33cb90bf991342afa552bcd993e36f80fa7", "patch": "@@ -19,7 +19,6 @@ use std::ascii;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::io::{self, Write, Read};\n-use std::iter::Peekable;\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -77,7 +76,6 @@ pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a SourceMap>,\n     comments: Option<Vec<comments::Comment>>,\n-    literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (dyn PpAnn + 'a),\n@@ -99,14 +97,6 @@ impl<'a> PrintState<'a> for State<'a> {\n     fn cur_cmnt(&mut self) -> &mut usize {\n         &mut self.cur_cmnt\n     }\n-\n-    fn cur_lit(&mut self) -> Option<&comments::Literal> {\n-        self.literals.peek()\n-    }\n-\n-    fn bump_lit(&mut self) -> Option<comments::Literal> {\n-        self.literals.next()\n-    }\n }\n \n #[allow(non_upper_case_globals)]\n@@ -117,18 +107,16 @@ pub const default_columns: usize = 78;\n \n \n /// Requires you to pass an input filename and reader so that\n-/// it can scan the input text for comments and literals to\n-/// copy forward.\n+/// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n                        input: &mut dyn Read,\n                        out: Box<dyn Write + 'a>,\n-                       ann: &'a dyn PpAnn,\n-                       is_expanded: bool)\n+                       ann: &'a dyn PpAnn)\n                        -> io::Result<()> {\n-    let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n+    let mut s = State::new_from_input(cm, sess, filename, input, out, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -144,36 +132,21 @@ impl<'a> State<'a> {\n                           filename: FileName,\n                           input: &mut dyn Read,\n                           out: Box<dyn Write + 'a>,\n-                          ann: &'a dyn PpAnn,\n-                          is_expanded: bool)\n+                          ann: &'a dyn PpAnn)\n                           -> State<'a> {\n-        let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n-\n-        State::new(cm,\n-                   out,\n-                   ann,\n-                   Some(cmnts),\n-                   // If the code is post expansion, don't use the table of\n-                   // literals, since it doesn't correspond with the literals\n-                   // in the AST anymore.\n-                   if is_expanded {\n-                       None\n-                   } else {\n-                       Some(lits)\n-                   })\n+        let comments = comments::gather_comments(sess, filename, input);\n+        State::new(cm, out, ann, Some(comments))\n     }\n \n     pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write + 'a>,\n                ann: &'a dyn PpAnn,\n-               comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>)\n+               comments: Option<Vec<comments::Comment>>)\n                -> State<'a> {\n         State {\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments,\n-            literals: literals.unwrap_or_default().into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n@@ -190,7 +163,6 @@ pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n             s: pp::mk_printer(Box::new(&mut wr), default_columns),\n             cm: None,\n             comments: None,\n-            literals: vec![].into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n@@ -1279,9 +1251,6 @@ impl<'a> State<'a> {\n \n     fn print_literal(&mut self, lit: &hir::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo())?;\n-        if let Some(ltrl) = self.next_lit(lit.span.lo()) {\n-            return self.writer().word(ltrl.lit.clone());\n-        }\n         match lit.node {\n             hir::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             hir::LitKind::Err(st) => {"}, {"sha": "c74ed5ec30c3cade8d6b7b91cbf1dedc92a4af44", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a5b3f33cb90bf991342afa552bcd993e36f80fa7", "patch": "@@ -805,8 +805,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                                             src_name,\n                                             &mut rdr,\n                                             box out,\n-                                            annotation.pp_ann(),\n-                                            true)\n+                                            annotation.pp_ann())\n                 })\n             }\n \n@@ -829,8 +828,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                                                                          src_name,\n                                                                          &mut rdr,\n                                                                          box out,\n-                                                                         annotation.pp_ann(),\n-                                                                         true);\n+                                                                         annotation.pp_ann());\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let node = hir_map.get(node_id);\n                         pp_state.print_node(node)?;"}, {"sha": "257f02af4cdd8681226e1a7ef903baa7734f179c", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=a5b3f33cb90bf991342afa552bcd993e36f80fa7", "patch": "@@ -414,10 +414,9 @@ impl<'a> fmt::Display for Html<'a> {\n mod test {\n     use super::Cfg;\n \n-    use syntax::symbol::Symbol;\n-    use syntax::ast::*;\n-    use syntax::source_map::dummy_spanned;\n     use syntax_pos::DUMMY_SP;\n+    use syntax::ast::*;\n+    use syntax::symbol::Symbol;\n     use syntax::with_globals;\n \n     fn word_cfg(s: &str) -> Cfg {\n@@ -592,12 +591,11 @@ mod test {\n             let mi = dummy_meta_item_word(\"all\");\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n+            let node = LitKind::Str(Symbol::intern(\"done\"), StrStyle::Cooked);\n+            let (token, suffix) =   node.lit_token();\n             let mi = MetaItem {\n                 path: Path::from_ident(Ident::from_str(\"all\")),\n-                node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n-                    Symbol::intern(\"done\"),\n-                    StrStyle::Cooked,\n-                ))),\n+                node: MetaItemKind::NameValue(Lit { node, token, suffix, span: DUMMY_SP }),\n                 span: DUMMY_SP,\n             };\n             assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n@@ -627,9 +625,11 @@ mod test {\n     #[test]\n     fn test_parse_err() {\n         with_globals(|| {\n+            let node = LitKind::Bool(false);\n+            let (token, suffix) = node.lit_token();\n             let mi = MetaItem {\n                 path: Path::from_ident(Ident::from_str(\"foo\")),\n-                node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n+                node: MetaItemKind::NameValue(Lit { node, token, suffix, span: DUMMY_SP }),\n                 span: DUMMY_SP,\n             };\n             assert!(Cfg::parse(&mi).is_err());"}, {"sha": "e23c18266519fba224b2ff59f23d41f6f59ca196", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=a5b3f33cb90bf991342afa552bcd993e36f80fa7", "patch": "@@ -565,8 +565,9 @@ impl MetaItemKind {\n             Some(TokenTree::Token(_, token::Eq)) => {\n                 tokens.next();\n                 return if let Some(TokenTree::Token(span, token)) = tokens.next() {\n-                    LitKind::from_token(token)\n-                        .map(|(node, token, suffix)| MetaItemKind::NameValue(Lit { node, token, suffix, span }))\n+                    LitKind::from_token(token).map(|(node, token, suffix)| {\n+                        MetaItemKind::NameValue(Lit { node, token, suffix, span })\n+                    })\n                 } else {\n                     None\n                 };\n@@ -635,7 +636,7 @@ impl LitKind {\n         }\n     }\n \n-    pub(crate) fn lit_token(&self) -> (token::Lit, Option<Symbol>) {\n+    pub fn lit_token(&self) -> (token::Lit, Option<Symbol>) {\n         use std::ascii;\n \n         match *self {"}, {"sha": "97d3fc002e9b0de49c84623274564834c2e54dbe", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=a5b3f33cb90bf991342afa552bcd993e36f80fa7", "patch": "@@ -3,8 +3,7 @@ pub use CommentStyle::*;\n use crate::ast;\n use crate::source_map::SourceMap;\n use crate::parse::lexer::{is_block_doc_comment, is_pattern_whitespace};\n-use crate::parse::lexer::{self, ParseSess, StringReader, TokenAndSpan};\n-use crate::print::pprust;\n+use crate::parse::lexer::{self, ParseSess, StringReader};\n \n use syntax_pos::{BytePos, CharPos, Pos, FileName};\n use log::debug;\n@@ -339,16 +338,9 @@ fn consume_comment(rdr: &mut StringReader<'_>,\n     debug!(\"<<< consume comment\");\n }\n \n-#[derive(Clone)]\n-pub struct Literal {\n-    pub lit: String,\n-    pub pos: BytePos,\n-}\n-\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut dyn Read)\n-    -> (Vec<Comment>, Vec<Literal>)\n+pub fn gather_comments(sess: &ParseSess, path: FileName, srdr: &mut dyn Read) -> Vec<Comment>\n {\n     let mut src = String::new();\n     srdr.read_to_string(&mut src).unwrap();\n@@ -357,7 +349,6 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n     let mut rdr = lexer::StringReader::new_raw(sess, source_file, None);\n \n     let mut comments: Vec<Comment> = Vec::new();\n-    let mut literals: Vec<Literal> = Vec::new();\n     let mut code_to_the_left = false; // Only code\n     let mut anything_to_the_left = false; // Code or comments\n \n@@ -382,26 +373,12 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n             }\n         }\n \n-        let bstart = rdr.pos;\n         rdr.next_token();\n-        // discard, and look ahead; we're working with internal state\n-        let TokenAndSpan { tok, sp } = rdr.peek();\n-        if tok.is_lit() {\n-            rdr.with_str_from(bstart, |s| {\n-                debug!(\"tok lit: {}\", s);\n-                literals.push(Literal {\n-                    lit: s.to_string(),\n-                    pos: sp.lo(),\n-                });\n-            })\n-        } else {\n-            debug!(\"tok: {}\", pprust::token_to_string(&tok));\n-        }\n         code_to_the_left = true;\n         anything_to_the_left = true;\n     }\n \n-    (comments, literals)\n+    comments\n }\n \n #[cfg(test)]"}, {"sha": "8c0c2f4b6e28aef885b91b2caf562a8affbd021b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a5b3f33cb90bf991342afa552bcd993e36f80fa7", "patch": "@@ -2121,11 +2121,11 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable,\n                     );\n                     err.emit();\n-                    return Ok(match float_suffix {\n-                        \"f32\" => (ast::LitKind::Float(val, ast::FloatTy::F32), token::Float(val), suffix),\n-                        \"f64\" => (ast::LitKind::Float(val, ast::FloatTy::F64), token::Float(val), suffix),\n-                        _ => (ast::LitKind::FloatUnsuffixed(val), token::Float(val), suffix),\n-                    });\n+                    return Ok((match float_suffix {\n+                        \"f32\" => ast::LitKind::Float(val, ast::FloatTy::F32),\n+                        \"f64\" => ast::LitKind::Float(val, ast::FloatTy::F64),\n+                        _ => ast::LitKind::FloatUnsuffixed(val),\n+                    }, token::Float(val), suffix));\n                 } else {\n                     unreachable!();\n                 };"}, {"sha": "fa16a2b200ff3cdcc7b0bfd4b23df5bb7abfec7a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 126, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b3f33cb90bf991342afa552bcd993e36f80fa7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a5b3f33cb90bf991342afa552bcd993e36f80fa7", "patch": "@@ -20,10 +20,8 @@ use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{self, BytePos};\n use syntax_pos::{DUMMY_SP, FileName};\n \n-use std::ascii;\n use std::borrow::Cow;\n use std::io::{self, Write, Read};\n-use std::iter::Peekable;\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -49,8 +47,7 @@ impl PpAnn for NoAnn {}\n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a SourceMap>,\n-    comments: Option<Vec<comments::Comment> >,\n-    literals: Peekable<vec::IntoIter<comments::Literal>>,\n+    comments: Option<Vec<comments::Comment>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (dyn PpAnn+'a),\n@@ -62,7 +59,6 @@ fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a>\n         s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n         cm: None,\n         comments: None,\n-        literals: vec![].into_iter().peekable(),\n         cur_cmnt: 0,\n         boxes: Vec::new(),\n         ann,\n@@ -75,8 +71,7 @@ pub const INDENT_UNIT: usize = 4;\n pub const DEFAULT_COLUMNS: usize = 78;\n \n /// Requires you to pass an input filename and reader so that\n-/// it can scan the input text for comments and literals to\n-/// copy forward.\n+/// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n@@ -118,36 +113,23 @@ impl<'a> State<'a> {\n                           out: Box<dyn Write+'a>,\n                           ann: &'a dyn PpAnn,\n                           is_expanded: bool) -> State<'a> {\n-        let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n-\n-        State::new(\n-            cm,\n-            out,\n-            ann,\n-            Some(cmnts),\n-            // If the code is post expansion, don't use the table of\n-            // literals, since it doesn't correspond with the literals\n-            // in the AST anymore.\n-            if is_expanded { None } else { Some(lits) },\n-            is_expanded\n-        )\n+        let comments = comments::gather_comments(sess, filename, input);\n+        State::new(cm, out, ann, Some(comments), is_expanded)\n     }\n \n     pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write+'a>,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>,\n                is_expanded: bool) -> State<'a> {\n         State {\n             s: pp::mk_printer(out, DEFAULT_COLUMNS),\n             cm: Some(cm),\n             comments,\n-            literals: literals.unwrap_or_default().into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n-            is_expanded: is_expanded\n+            is_expanded,\n         }\n     }\n }\n@@ -180,6 +162,31 @@ fn binop_to_string(op: BinOpToken) -> &'static str {\n     }\n }\n \n+fn literal_to_string(lit: token::Lit, suffix: Option<ast::Name>) -> String {\n+    let mut out = match lit {\n+        token::Byte(b)           => format!(\"b'{}'\", b),\n+        token::Char(c)           => format!(\"'{}'\", c),\n+        token::Err(c)            => format!(\"'{}'\", c),\n+        token::Bool(c)           |\n+        token::Float(c)          |\n+        token::Integer(c)        => c.to_string(),\n+        token::Str_(s)           => format!(\"\\\"{}\\\"\", s),\n+        token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n+                                            delim=\"#\".repeat(n as usize),\n+                                            string=s),\n+        token::ByteStr(v)        => format!(\"b\\\"{}\\\"\", v),\n+        token::ByteStrRaw(s, n)  => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n+                                            delim=\"#\".repeat(n as usize),\n+                                            string=s),\n+    };\n+\n+    if let Some(suffix) = suffix {\n+        out.push_str(&suffix.as_str())\n+    }\n+\n+    out\n+}\n+\n pub fn token_to_string(tok: &Token) -> String {\n     match *tok {\n         token::Eq                   => \"=\".to_string(),\n@@ -223,30 +230,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::SingleQuote          => \"'\".to_string(),\n \n         /* Literals */\n-        token::Literal(lit, suf) => {\n-            let mut out = match lit {\n-                token::Bool(_)          => panic!(\"literal token contains `Lit::Bool`\"),\n-                token::Byte(b)           => format!(\"b'{}'\", b),\n-                token::Char(c)           => format!(\"'{}'\", c),\n-                token::Err(c)            => format!(\"'{}'\", c),\n-                token::Float(c)          |\n-                token::Integer(c)        => c.to_string(),\n-                token::Str_(s)           => format!(\"\\\"{}\\\"\", s),\n-                token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                                                    delim=\"#\".repeat(n as usize),\n-                                                    string=s),\n-                token::ByteStr(v)         => format!(\"b\\\"{}\\\"\", v),\n-                token::ByteStrRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n-                                                    delim=\"#\".repeat(n as usize),\n-                                                    string=s),\n-            };\n-\n-            if let Some(s) = suf {\n-                out.push_str(&s.as_str())\n-            }\n-\n-            out\n-        }\n+        token::Literal(lit, suf) => literal_to_string(lit, suf),\n \n         /* Name components */\n         token::Ident(s, false)      => s.to_string(),\n@@ -439,8 +423,6 @@ pub trait PrintState<'a> {\n     fn boxes(&mut self) -> &mut Vec<pp::Breaks>;\n     fn comments(&mut self) -> &mut Option<Vec<comments::Comment>>;\n     fn cur_cmnt(&mut self) -> &mut usize;\n-    fn cur_lit(&mut self) -> Option<&comments::Literal>;\n-    fn bump_lit(&mut self) -> Option<comments::Literal>;\n \n     fn word_space<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.writer().word(w)?;\n@@ -505,21 +487,6 @@ pub trait PrintState<'a> {\n         self.end()\n     }\n \n-    fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n-        while let Some(ltrl) = self.cur_lit().cloned() {\n-            if ltrl.pos > pos { break; }\n-\n-            // we don't need the value here since we're forced to clone cur_lit\n-            // due to lack of NLL.\n-            self.bump_lit();\n-            if ltrl.pos == pos {\n-                return Some(ltrl);\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n         while let Some(ref cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n@@ -607,60 +574,7 @@ pub trait PrintState<'a> {\n \n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo())?;\n-        if let Some(ltrl) = self.next_lit(lit.span.lo()) {\n-            return self.writer().word(ltrl.lit.clone());\n-        }\n-        match lit.node {\n-            ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n-            ast::LitKind::Err(st) => {\n-                let st = st.as_str().escape_debug().to_string();\n-                let mut res = String::with_capacity(st.len() + 2);\n-                res.push('\\'');\n-                res.push_str(&st);\n-                res.push('\\'');\n-                self.writer().word(res)\n-            }\n-            ast::LitKind::Byte(byte) => {\n-                let mut res = String::from(\"b'\");\n-                res.extend(ascii::escape_default(byte).map(|c| c as char));\n-                res.push('\\'');\n-                self.writer().word(res)\n-            }\n-            ast::LitKind::Char(ch) => {\n-                let mut res = String::from(\"'\");\n-                res.extend(ch.escape_default());\n-                res.push('\\'');\n-                self.writer().word(res)\n-            }\n-            ast::LitKind::Int(i, t) => {\n-                match t {\n-                    ast::LitIntType::Signed(st) => {\n-                        self.writer().word(st.val_to_string(i as i128))\n-                    }\n-                    ast::LitIntType::Unsigned(ut) => {\n-                        self.writer().word(ut.val_to_string(i))\n-                    }\n-                    ast::LitIntType::Unsuffixed => {\n-                        self.writer().word(i.to_string())\n-                    }\n-                }\n-            }\n-            ast::LitKind::Float(ref f, t) => {\n-                self.writer().word(format!(\"{}{}\", &f, t.ty_to_string()))\n-            }\n-            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(f.as_str().to_string()),\n-            ast::LitKind::Bool(val) => {\n-                if val { self.writer().word(\"true\") } else { self.writer().word(\"false\") }\n-            }\n-            ast::LitKind::ByteStr(ref v) => {\n-                let mut escaped: String = String::new();\n-                for &ch in v.iter() {\n-                    escaped.extend(ascii::escape_default(ch)\n-                                         .map(|c| c as char));\n-                }\n-                self.writer().word(format!(\"b\\\"{}\\\"\", escaped))\n-            }\n-        }\n+        self.writer().word(literal_to_string(lit.token, lit.suffix))\n     }\n \n     fn print_string(&mut self, st: &str,\n@@ -881,14 +795,6 @@ impl<'a> PrintState<'a> for State<'a> {\n     fn cur_cmnt(&mut self) -> &mut usize {\n         &mut self.cur_cmnt\n     }\n-\n-    fn cur_lit(&mut self) -> Option<&comments::Literal> {\n-        self.literals.peek()\n-    }\n-\n-    fn bump_lit(&mut self) -> Option<comments::Literal> {\n-        self.literals.next()\n-    }\n }\n \n impl<'a> State<'a> {"}]}