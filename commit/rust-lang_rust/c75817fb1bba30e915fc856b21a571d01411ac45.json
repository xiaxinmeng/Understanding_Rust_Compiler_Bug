{"sha": "c75817fb1bba30e915fc856b21a571d01411ac45", "node_id": "C_kwDOAAsO6NoAKGM3NTgxN2ZiMWJiYTMwZTkxNWZjODU2YjIxYTU3MWQwMTQxMWFjNDU", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-02T19:07:57Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T14:45:58Z"}, "message": "`rustc_borrowck`: remove `ref` patterns", "tree": {"sha": "cd2409aebb13a1a3388088a0d9ce129e596a8827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd2409aebb13a1a3388088a0d9ce129e596a8827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c75817fb1bba30e915fc856b21a571d01411ac45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c75817fb1bba30e915fc856b21a571d01411ac45", "html_url": "https://github.com/rust-lang/rust/commit/c75817fb1bba30e915fc856b21a571d01411ac45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c75817fb1bba30e915fc856b21a571d01411ac45/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5351ad4dcd9f3d73241b2acbfc6b4631da845c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5351ad4dcd9f3d73241b2acbfc6b4631da845c5", "html_url": "https://github.com/rust-lang/rust/commit/c5351ad4dcd9f3d73241b2acbfc6b4631da845c5"}], "stats": {"total": 305, "additions": 145, "deletions": 160}, "files": [{"sha": "5bb92a3582612f829cadce85e1b52118f4047916", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         rvalue: &mir::Rvalue<'tcx>,\n         location: mir::Location,\n     ) {\n-        if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, borrowed_place) = rvalue {\n             if borrowed_place.ignore_borrow(self.tcx, self.body, &self.locals_state_at_exit) {\n                 debug!(\"ignoring_borrow of {:?}\", borrowed_place);\n                 return;\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 region,\n                 reserve_location: location,\n                 activation_location: TwoPhaseActivation::NotTwoPhase,\n-                borrowed_place: *borrowed_place,\n+                borrowed_place,\n                 assigned_place: *assigned_place,\n             };\n             let (idx, _) = self.location_map.insert_full(location, borrow);\n@@ -273,14 +273,14 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: mir::Location) {\n-        if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, place) = rvalue {\n             // double-check that we already registered a BorrowData for this\n \n             let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n             assert_eq!(borrow_data.region, region.to_region_vid());\n-            assert_eq!(borrow_data.borrowed_place, *place);\n+            assert_eq!(borrow_data.borrowed_place, place);\n         }\n \n         self.super_rvalue(rvalue, location)"}, {"sha": "f825b1d8f70ef502952699fe81e4aecf57edb849", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -358,9 +358,9 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n         stmt: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        match stmt.kind {\n-            mir::StatementKind::Assign(box (lhs, ref rhs)) => {\n-                if let mir::Rvalue::Ref(_, _, place) = *rhs {\n+        match &stmt.kind {\n+            mir::StatementKind::Assign(box (lhs, rhs)) => {\n+                if let mir::Rvalue::Ref(_, _, place) = rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.body,\n@@ -377,13 +377,13 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n \n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n-                self.kill_borrows_on_place(trans, lhs);\n+                self.kill_borrows_on_place(trans, *lhs);\n             }\n \n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(trans, Place::from(local));\n+                self.kill_borrows_on_place(trans, Place::from(*local));\n             }\n \n             mir::StatementKind::FakeRead(..)"}, {"sha": "1550958ab8eee3942710ba5103fab472f560fa02", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -243,9 +243,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_prove_predicate_with_cause(&ocx, key, cause);\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n@@ -284,9 +284,9 @@ where\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -328,9 +328,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }"}, {"sha": "5e3745f17353af8543cc8cbdf52dcf7b1e25cfd6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -265,7 +265,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n             );\n             let note_msg = match opt_name {\n-                Some(ref name) => format!(\"`{}`\", name),\n+                Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n             if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n@@ -1417,7 +1417,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // then just use the normal error. The closure isn't escaping\n             // and `move` will not help here.\n             (\n-                Some(ref name),\n+                Some(name),\n                 BorrowExplanation::MustBeValidFor {\n                     category:\n                         category @ (ConstraintCategory::Return(_)\n@@ -1438,7 +1438,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     &format!(\"`{}`\", name),\n                 ),\n             (\n-                ref name,\n+                name,\n                 BorrowExplanation::MustBeValidFor {\n                     category: ConstraintCategory::Assignment,\n                     from_closure: false,\n@@ -1450,7 +1450,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     span,\n                     ..\n                 },\n-            ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n+            ) => self.report_escaping_data(borrow_span, &name, upvar_span, upvar_name, span),\n             (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n                 location,\n                 &name,\n@@ -2452,7 +2452,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // and it'll make sense.\n         let location = borrow.reserve_location;\n         debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n-        if let Some(&Statement { kind: StatementKind::Assign(box (ref reservation, _)), .. }) =\n+        if let Some(Statement { kind: StatementKind::Assign(box (reservation, _)), .. }) =\n             &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n@@ -2480,8 +2480,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Check if our `target` was captured by a closure.\n                         if let Rvalue::Aggregate(\n                             box AggregateKind::Closure(def_id, substs),\n-                            ref operands,\n-                        ) = *rvalue\n+                            operands,\n+                        ) = rvalue\n                         {\n                             for operand in operands {\n                                 let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n@@ -2505,7 +2505,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // into a place then we should annotate the closure in\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure =\n-                                    self.annotate_fn_sig(def_id, substs.as_closure().sig());\n+                                    self.annotate_fn_sig(*def_id, substs.as_closure().sig());\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\"}, {"sha": "304683618d83ef9dc531c7fcb7f7ed91ed329a7f", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -469,8 +469,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {\n-                    if let TerminatorKind::Call { ref func, from_hir_call: true, .. } =\n-                        block.terminator().kind\n+                    if let TerminatorKind::Call { func, from_hir_call: true, .. } =\n+                        &block.terminator().kind\n                     {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n@@ -515,19 +515,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // will only ever have one item at any given time, but by using a vector, we can pop from\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n-        let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(box (ref place, _)),\n-            ..\n-        }) = stmt\n-        {\n-            if let Some(local) = place.as_local() {\n-                local\n+        let mut target =\n+            if let Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) = stmt {\n+                if let Some(local) = place.as_local() {\n+                    local\n+                } else {\n+                    return false;\n+                }\n             } else {\n                 return false;\n-            }\n-        } else {\n-            return false;\n-        };\n+            };\n \n         debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n         while let Some(current_location) = queue.pop() {"}, {"sha": "4e2271a30672270a5ff8c49c1b4460ab8c11938b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -78,7 +78,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let StatementKind::Assign(box (into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n-                    Operand::Copy(ref place) | Operand::Move(ref place)\n+                    Operand::Copy(place) | Operand::Move(place)\n                         if target == place.local_or_deref_local() =>\n                     {\n                         target = into.local_or_deref_local()\n@@ -101,7 +101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"add_moved_or_invoked_closure_note: id={:?}\", id);\n                 if Some(self.infcx.tcx.parent(id)) == self.infcx.tcx.lang_items().fn_once_trait() {\n                     let closure = match args.first() {\n-                        Some(Operand::Copy(ref place)) | Some(Operand::Move(ref place))\n+                        Some(Operand::Copy(place) | Operand::Move(place))\n                             if target == place.local_or_deref_local() =>\n                         {\n                             place.local_or_deref_local().unwrap()\n@@ -439,9 +439,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if !is_terminator {\n                         continue;\n                     } else if let Some(Terminator {\n-                        kind: TerminatorKind::Call { ref func, from_hir_call: false, .. },\n+                        kind: TerminatorKind::Call { func, from_hir_call: false, .. },\n                         ..\n-                    }) = bbd.terminator\n+                    }) = &bbd.terminator\n                     {\n                         if let Some(source) =\n                             BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n@@ -811,33 +811,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n-        if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            match **kind {\n-                AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n-                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-                    if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n-                        self.closure_span(def_id, moved_place, places)\n-                    {\n-                        return ClosureUse {\n-                            generator_kind,\n-                            args_span,\n-                            capture_kind_span,\n-                            path_span,\n-                        };\n-                    }\n-                }\n-                _ => {}\n+        if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind\n+            && let AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) = **kind\n+        {\n+            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+            if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n+                self.closure_span(def_id, moved_place, places)\n+            {\n+                return ClosureUse {\n+                    generator_kind,\n+                    args_span,\n+                    capture_kind_span,\n+                    path_span,\n+                };\n             }\n         }\n \n         // StatementKind::FakeRead only contains a def_id if they are introduced as a result\n         // of pattern matching within a closure.\n-        if let StatementKind::FakeRead(box (cause, ref place)) = stmt.kind {\n+        if let StatementKind::FakeRead(box (cause, place)) = stmt.kind {\n             match cause {\n                 FakeReadCause::ForMatchedPlace(Some(closure_def_id))\n                 | FakeReadCause::ForLet(Some(closure_def_id)) => {\n                     debug!(\"move_spans: def_id={:?} place={:?}\", closure_def_id, place);\n-                    let places = &[Operand::Move(*place)];\n+                    let places = &[Operand::Move(place)];\n                     if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n                         self.closure_span(closure_def_id, moved_place, places)\n                     {\n@@ -924,7 +921,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n         let target = match self.body[location.block].statements.get(location.statement_index) {\n-            Some(&Statement { kind: StatementKind::Assign(box (ref place, _)), .. }) => {\n+            Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) => {\n                 if let Some(local) = place.as_local() {\n                     local\n                 } else {\n@@ -940,9 +937,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) =\n-                stmt.kind\n-            {\n+            if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind {\n                 let (&def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),\n                     box AggregateKind::Generator(def_id, _, _) => (def_id, true),"}, {"sha": "3319a80681fde277dc0fd3f361c2656adfafe6b6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -219,8 +219,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 local,\n                 projection:\n-                    &[\n-                        ref proj_base @ ..,\n+                    [\n+                        proj_base @ ..,\n                         ProjectionElem::Deref,\n                         ProjectionElem::Field(field, _),\n                         ProjectionElem::Deref,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(span) = get_mut_span_in_struct_field(\n                     self.infcx.tcx,\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty,\n-                    field,\n+                    *field,\n                 ) {\n                     err.span_suggestion_verbose(\n                         span,"}, {"sha": "9bc2e79e29bc17c9b96a77b7ca99013312159a76", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -921,7 +921,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             hir::ExprKind::Block(blk, _) => {\n-                if let Some(ref expr) = blk.expr {\n+                if let Some(expr) = blk.expr {\n                     // only when the block is a closure\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,"}, {"sha": "171e62d91e136463dfd600eb3dc9b51977b6ca59", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -254,7 +254,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_arg_position_impl_trait(fr));\n \n-        if let Some(ref value) = value {\n+        if let Some(value) = &value {\n             self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n         }\n "}, {"sha": "f66a7ab3c031aa87ae54fc658047f2b4cf8384be", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -69,9 +69,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, op);\n             }\n             StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(mir::CopyNonOverlapping {\n-                ref src,\n-                ref dst,\n-                ref count,\n+                src,\n+                dst,\n+                count,\n             })) => {\n                 self.consume_operand(location, src);\n                 self.consume_operand(location, dst);\n@@ -106,7 +106,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match &terminator.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n@@ -119,16 +119,16 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n                 self.mutate_place(location, *drop_place, Deep);\n                 self.consume_operand(location, new_value);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -141,15 +141,15 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 }\n                 self.mutate_place(location, *destination, Deep);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(location, cond);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(location, len);\n                     self.consume_operand(location, index);\n                 }\n             }\n-            TerminatorKind::Yield { ref value, resume, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume, resume_arg, drop: _ } => {\n                 self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n@@ -175,25 +175,25 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(location, value);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n-                            if let Some(place) = place {\n+                            if let &Some(place) = place {\n                                 self.mutate_place(location, place, Shallow(None));\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(location, in_value);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(location, out_place, Shallow(None));\n                             }\n                         }\n@@ -252,8 +252,8 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n     // Simulates consumption of an rvalue\n     fn consume_rvalue(&mut self, location: Location, rvalue: &Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -272,7 +272,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.access_place(location, place, access_kind, LocalMutationIsAllowed::No);\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -288,20 +288,19 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n-                self.consume_operand(location, operand)\n-            }\n-            Rvalue::CopyForDeref(ref place) => {\n-                let op = &Operand::Copy(*place);\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => self.consume_operand(location, operand),\n+\n+            &Rvalue::CopyForDeref(place) => {\n+                let op = &Operand::Copy(place);\n                 self.consume_operand(location, op);\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n-                let af = match *rvalue {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n+                let af = match rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n                     _ => unreachable!(),\n@@ -314,15 +313,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, operand1);\n                 self.consume_operand(location, operand2);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {}\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for operand in operands {\n                     self.consume_operand(location, operand);\n                 }"}, {"sha": "74b4e4a0cabdd6826807ba410ff4af8884fb2c4d", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -578,12 +578,12 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n         self.check_activations(location, span, flow_state);\n \n         match &stmt.kind {\n-            StatementKind::Assign(box (lhs, ref rhs)) => {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n                 self.consume_rvalue(location, (rhs, span), flow_state);\n \n                 self.mutate_place(location, (*lhs, span), Shallow(None), flow_state);\n             }\n-            StatementKind::FakeRead(box (_, ref place)) => {\n+            StatementKind::FakeRead(box (_, place)) => {\n                 // Read for match doesn't access any memory and is used to\n                 // assert that a place is safe and live. So we don't have to\n                 // do any checks here.\n@@ -601,7 +601,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.consume_operand(location, (op, span), flow_state),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     span,\n@@ -643,8 +643,8 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n         self.check_activations(loc, span, flow_state);\n \n-        match term.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+        match &term.kind {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { place, target: _, unwind: _ } => {\n@@ -656,24 +656,24 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n                 self.access_place(\n                     loc,\n-                    (place, span),\n+                    (*place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.mutate_place(loc, (drop_place, span), Deep, flow_state);\n+                self.mutate_place(loc, (*drop_place, span), Deep, flow_state);\n                 self.consume_operand(loc, (new_value, span), flow_state);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -684,43 +684,43 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 for arg in args {\n                     self.consume_operand(loc, (arg, span), flow_state);\n                 }\n-                self.mutate_place(loc, (destination, span), Deep, flow_state);\n+                self.mutate_place(loc, (*destination, span), Deep, flow_state);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(loc, (cond, span), flow_state);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(loc, (len, span), flow_state);\n                     self.consume_operand(loc, (index, span), flow_state);\n                 }\n             }\n \n-            TerminatorKind::Yield { ref value, resume: _, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n-                self.mutate_place(loc, (resume_arg, span), Deep, flow_state);\n+                self.mutate_place(loc, (*resume_arg, span), Deep, flow_state);\n             }\n \n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(loc, (value, span), flow_state);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n                             if let Some(place) = place {\n-                                self.mutate_place(loc, (place, span), Shallow(None), flow_state);\n+                                self.mutate_place(loc, (*place, span), Shallow(None), flow_state);\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(loc, (in_value, span), flow_state);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(\n                                     loc,\n                                     (out_place, span),\n@@ -1164,8 +1164,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         (rvalue, span): (&'cx Rvalue<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -1203,7 +1203,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -1232,14 +1232,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => {\n                 self.consume_operand(location, (operand, span), flow_state)\n             }\n-            Rvalue::CopyForDeref(place) => {\n+\n+            &Rvalue::CopyForDeref(place) => {\n                 self.access_place(\n                     location,\n                     (place, span),\n@@ -1257,7 +1258,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -1278,8 +1279,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, (operand1, span), flow_state);\n                 self.consume_operand(location, (operand2, span), flow_state);\n             }\n@@ -1288,7 +1289,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // nullary ops take no dynamic input; no borrowck effect.\n             }\n \n-            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+            Rvalue::Aggregate(aggregate_kind, operands) => {\n                 // We need to report back the list of mutable upvars that were\n                 // moved into the closure and subsequently used by the closure,\n                 // in order to populate our used_mut set."}, {"sha": "6d4ec6b726eb027f6e330b084370048445bce315", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -1189,8 +1189,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         let tcx = self.tcx();\n         debug!(\"stmt kind: {:?}\", stmt.kind);\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rv)) => {\n+        match &stmt.kind {\n+            StatementKind::Assign(box (place, rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n@@ -1279,11 +1279,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::AscribeUserType(box (ref place, ref projection), variance) => {\n+            StatementKind::AscribeUserType(box (place, projection), variance) => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n-                    variance,\n+                    *variance,\n                     projection,\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.check_operand(op, location),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     stmt.source_info.span,\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n         debug!(\"terminator kind: {:?}\", term.kind);\n-        match term.kind {\n+        match &term.kind {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n@@ -1342,7 +1342,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { ref place, ref value, target: _, unwind: _ } => {\n+            TerminatorKind::DropAndReplace { place, value, target: _, unwind: _ } => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 let rv_ty = value.ty(body, tcx);\n \n@@ -1360,13 +1360,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, .. } => {\n                 self.check_operand(discr, term_location);\n \n                 let discr_ty = discr.ty(body, tcx);\n                 if let Err(terr) = self.sub_types(\n                     discr_ty,\n-                    switch_ty,\n+                    *switch_ty,\n                     term_location.to_locations(),\n                     ConstraintCategory::Assignment,\n                 ) {\n@@ -1384,14 +1384,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                from_hir_call,\n-                target,\n-                ..\n-            } => {\n+            TerminatorKind::Call { func, args, destination, from_hir_call, target, .. } => {\n                 self.check_operand(func, term_location);\n                 for arg in args {\n                     self.check_operand(arg, term_location);\n@@ -1431,7 +1424,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     ConstraintCategory::Boring,\n                 );\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(body, term, &sig, *destination, target, term_location);\n+                self.check_call_dest(body, term, &sig, *destination, *target, term_location);\n \n                 // The ordinary liveness rules will ensure that all\n                 // regions in the type of the callee are live here. We\n@@ -1449,17 +1442,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         .add_element(region_vid, term_location);\n                 }\n \n-                self.check_call_inputs(body, term, &sig, args, term_location, from_hir_call);\n+                self.check_call_inputs(body, term, &sig, args, term_location, *from_hir_call);\n             }\n-            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+            TerminatorKind::Assert { cond, msg, .. } => {\n                 self.check_operand(cond, term_location);\n \n                 let cond_ty = cond.ty(body, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     if len.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n@@ -1468,7 +1461,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            TerminatorKind::Yield { ref value, .. } => {\n+            TerminatorKind::Yield { value, .. } => {\n                 self.check_operand(value, term_location);\n \n                 let value_ty = value.ty(body, tcx);\n@@ -2630,7 +2623,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+        if let Some(closure_requirements) = &tcx.mir_borrowck(def_id).closure_requirements {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx,\n                 self.borrowck_context.universal_regions,"}, {"sha": "a4a0c5b90fed32d2a20372aa908806b81aa9a2fe", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817fb1bba30e915fc856b21a571d01411ac45/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=c75817fb1bba30e915fc856b21a571d01411ac45", "patch": "@@ -587,9 +587,9 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n         let fr_substs = match defining_ty {\n-            DefiningTy::Closure(_, ref substs)\n-            | DefiningTy::Generator(_, ref substs, _)\n-            | DefiningTy::InlineConst(_, ref substs) => {\n+            DefiningTy::Closure(_, substs)\n+            | DefiningTy::Generator(_, substs, _)\n+            | DefiningTy::InlineConst(_, substs) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `typeck_root_def_id`."}]}