{"sha": "444a9c3f1afad7585e7a65a05dbea8025a67b675", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NGE5YzNmMWFmYWQ3NTg1ZTdhNjVhMDVkYmVhODAyNWE2N2I2NzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-26T07:33:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-26T07:33:06Z"}, "message": "Auto merge of #50364 - LukasKalbertodt:improve-duration-debug-impl, r=KodrAus\n\nImprove `Debug` impl of `time::Duration`\n\nHi there!\n\nFor a long time now, I was getting annoyed by the derived `Debug` impl of `Duration`. Usually, I use `Duration` to either do quick'n'dirty benchmarking or measuring the time of some operation in general. The output of the derived Debug impl is hard to parse for humans: is { secs: 0, nanos: 968360102 } or { secs: 0, nanos 98507324 } longer?\n\nSo after running into the annoyance several times (sometimes building my own function to print the Duration properly), I decided to tackle this. Now the output looks like this:\n\n```\nDuration::new(1, 0)                 => 1s\nDuration::new(1, 1)                 => 1.000000001s\nDuration::new(1, 300)               => 1.0000003s\nDuration::new(1, 4000)              => 1.000004s\nDuration::new(1, 600000)            => 1.0006s\nDuration::new(1, 7000000)           => 1.007s\nDuration::new(0, 0)                 => 0ns\nDuration::new(0, 1)                 => 1ns\nDuration::new(0, 300)               => 300ns\nDuration::new(0, 4001)              => 4.001\u00b5s\nDuration::new(0, 600300)            => 600.3\u00b5s\nDuration::new(0, 7000000)           => 7ms\n```\n\nNote that I implemented the formatting manually and didn't use floats. No information is \"lost\" when printing. So `Duration::new(123_456_789_000, 900_000_001)` prints as `123456789000.900000001s`.\n\n~~This is not yet finished~~, but I wanted to open the PR now already in order to get some feedback (maybe everyone likes the derived impl).\n\n### Still ToDo:\n\n- [x] Respect precision ~~and width~~ parameter of the formatter (see [this comment](https://github.com/rust-lang/rust/pull/50364#issuecomment-386107107))\n\n### Alternatives/Decisions\n\n- Should large durations displayed in minutes, hours, days, ...? For now, I decided not to because the current formatting is close the how a `Duration` is stored. From this new `Debug` output, you can still easily see what the values of `secs` and `nanos` are. A formatting like `3h 27m 12s 9ms` might be more appropriate for a `Display` impl?\n- Should this rather be a `Display` impl and should `Debug` be derived? Maybe this formatting is too fancy for `Debug`? In my opinion it's not and, as already mentioned, from the current format one can still very easily determine the values for `secs` and `nanos`.\n- Whitespace between the number and the unit?\n\n### Notes for reviewers\n\n- ~~The combined diff sucks. Rather review both commits individually.~~\n- ~~In the unit test, I am building my own type implementing `fmt::Write` to test the output. Maybe there is already something like that which I can use?~~\n- My `Debug` impl block is marked as `#[stable(...)]`... but that's fine since the derived Debug impl was stable already, right?\n\n---\n\n~~Apart from the main change, I moved all `time` unit tests into the `tests` directory. All other `libcore` tests are there, so I guess it was simply an oversight. Prior to this change, the `time` tests weren't run, so I guess this is kind of a bug fix. If my `Debug` impl is rejected, I can of course just send the fix as PR.~~ (this was already merged in #50466)", "tree": {"sha": "907f10e260ef2a7cbe42ddf1cf10d17f64744f48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/907f10e260ef2a7cbe42ddf1cf10d17f64744f48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/444a9c3f1afad7585e7a65a05dbea8025a67b675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/444a9c3f1afad7585e7a65a05dbea8025a67b675", "html_url": "https://github.com/rust-lang/rust/commit/444a9c3f1afad7585e7a65a05dbea8025a67b675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/444a9c3f1afad7585e7a65a05dbea8025a67b675/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67d99d91e572f335675c47201c476d9fdd17da79", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d99d91e572f335675c47201c476d9fdd17da79", "html_url": "https://github.com/rust-lang/rust/commit/67d99d91e572f335675c47201c476d9fdd17da79"}, {"sha": "59e71141029162fe4b4a3ed4cad430dace3fb995", "url": "https://api.github.com/repos/rust-lang/rust/commits/59e71141029162fe4b4a3ed4cad430dace3fb995", "html_url": "https://github.com/rust-lang/rust/commit/59e71141029162fe4b4a3ed4cad430dace3fb995"}], "stats": {"total": 247, "additions": 246, "deletions": 1}, "files": [{"sha": "df139965753a6fe6bdb6b665208d445f49b085bf", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/444a9c3f1afad7585e7a65a05dbea8025a67b675/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444a9c3f1afad7585e7a65a05dbea8025a67b675/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=444a9c3f1afad7585e7a65a05dbea8025a67b675", "patch": "@@ -160,3 +160,131 @@ fn checked_div() {\n     assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n     assert_eq!(Duration::new(2, 0).checked_div(0), None);\n }\n+\n+#[test]\n+fn debug_formatting_extreme_values() {\n+    assert_eq!(\n+        format!(\"{:?}\", Duration::new(18_446_744_073_709_551_615, 123_456_789)),\n+        \"18446744073709551615.123456789s\"\n+    );\n+}\n+\n+#[test]\n+fn debug_formatting_secs() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_000_000)), \"7s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 100_000_000)), \"7.1s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_010_000)), \"7.00001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_000_001)), \"7.000000001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 123_456_789)), \"7.123456789s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_000_000)), \"88s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 100_000_000)), \"88.1s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_010_000)), \"88.00001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_000_001)), \"88.000000001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 123_456_789)), \"88.123456789s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_000_000)), \"999s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 100_000_000)), \"999.1s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_010_000)), \"999.00001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_000_001)), \"999.000000001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 123_456_789)), \"999.123456789s\");\n+}\n+\n+#[test]\n+fn debug_formatting_millis() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000_000)), \"7ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_100_000)), \"7.1ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000_001)), \"7.000001ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_123_456)), \"7.123456ms\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000_000)), \"88ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_100_000)), \"88.1ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000_001)), \"88.000001ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_123_456)), \"88.123456ms\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000_000)), \"999ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_100_000)), \"999.1ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000_001)), \"999.000001ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_123_456)), \"999.123456ms\");\n+}\n+\n+#[test]\n+fn debug_formatting_micros() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000)), \"7\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_100)), \"7.1\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_001)), \"7.001\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_123)), \"7.123\u00b5s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000)), \"88\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_100)), \"88.1\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_001)), \"88.001\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_123)), \"88.123\u00b5s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000)), \"999\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_100)), \"999.1\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_001)), \"999.001\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_123)), \"999.123\u00b5s\");\n+}\n+\n+#[test]\n+fn debug_formatting_nanos() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 0)), \"0ns\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 1)), \"1ns\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88)), \"88ns\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999)), \"999ns\");\n+}\n+\n+#[test]\n+fn debug_formatting_precision_zero() {\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 0)), \"0ns\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 123)), \"123ns\");\n+\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_001)), \"1\u00b5s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_499)), \"1\u00b5s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_500)), \"2\u00b5s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_999)), \"2\u00b5s\");\n+\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_000_001)), \"1ms\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_499_999)), \"1ms\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_500_000)), \"2ms\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_999_999)), \"2ms\");\n+\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 000_000_001)), \"1s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 499_999_999)), \"1s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 500_000_000)), \"2s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 999_999_999)), \"2s\");\n+}\n+\n+#[test]\n+fn debug_formatting_precision_two() {\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 0)), \"0.00ns\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 123)), \"123.00ns\");\n+\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_000)), \"1.00\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_001)), \"7.00\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_100)), \"7.10\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_109)), \"7.11\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_199)), \"7.20\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_999)), \"2.00\u00b5s\");\n+\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_000_000)), \"1.00ms\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 3_001_000)), \"3.00ms\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 3_100_000)), \"3.10ms\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_999_999)), \"2.00ms\");\n+\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(1, 000_000_000)), \"1.00s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(4, 001_000_000)), \"4.00s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(2, 100_000_000)), \"2.10s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(2, 104_990_000)), \"2.10s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(2, 105_000_000)), \"2.11s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(8, 999_999_999)), \"9.00s\");\n+}\n+\n+#[test]\n+fn debug_formatting_precision_high() {\n+    assert_eq!(format!(\"{:.5?}\",  Duration::new(0, 23_678)), \"23.67800\u00b5s\");\n+\n+    assert_eq!(format!(\"{:.9?}\",  Duration::new(1, 000_000_000)), \"1.000000000s\");\n+    assert_eq!(format!(\"{:.10?}\", Duration::new(4, 001_000_000)), \"4.0010000000s\");\n+    assert_eq!(format!(\"{:.20?}\", Duration::new(4, 001_000_000)), \"4.00100000000000000000s\");\n+}"}, {"sha": "a1815b5f5ef675e5d93be9279a94b951cf2b29de", "filename": "src/libcore/time.rs", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/444a9c3f1afad7585e7a65a05dbea8025a67b675/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444a9c3f1afad7585e7a65a05dbea8025a67b675/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=444a9c3f1afad7585e7a65a05dbea8025a67b675", "patch": "@@ -21,6 +21,7 @@\n //! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n //! ```\n \n+use fmt;\n use iter::Sum;\n use ops::{Add, Sub, Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};\n \n@@ -59,7 +60,7 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n /// let ten_millis = Duration::from_millis(10);\n /// ```\n #[stable(feature = \"duration\", since = \"1.3.0\")]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Default)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n pub struct Duration {\n     secs: u64,\n     nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n@@ -485,3 +486,119 @@ impl<'a> Sum<&'a Duration> for Duration {\n         iter.fold(Duration::new(0, 0), |a, b| a + *b)\n     }\n }\n+\n+#[stable(feature = \"duration_debug_impl\", since = \"1.27.0\")]\n+impl fmt::Debug for Duration {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        /// Formats a floating point number in decimal notation.\n+        ///\n+        /// The number is given as the `integer_part` and a fractional part.\n+        /// The value of the fractional part is `fractional_part / divisor`. So\n+        /// `integer_part` = 3, `fractional_part` = 12 and `divisor` = 100\n+        /// represents the number `3.012`. Trailing zeros are omitted.\n+        ///\n+        /// `divisor` must not be above 100_000_000. It also should be a power\n+        /// of 10, everything else doesn't make sense. `fractional_part` has\n+        /// to be less than `10 * divisor`!\n+        fn fmt_decimal(\n+            f: &mut fmt::Formatter,\n+            mut integer_part: u64,\n+            mut fractional_part: u32,\n+            mut divisor: u32,\n+        ) -> fmt::Result {\n+            // Encode the fractional part into a temporary buffer. The buffer\n+            // only need to hold 9 elements, because `fractional_part` has to\n+            // be smaller than 10^9. The buffer is prefilled with '0' digits\n+            // to simplify the code below.\n+            let mut buf = [b'0'; 9];\n+\n+            // The next digit is written at this position\n+            let mut pos = 0;\n+\n+            // We keep writing digits into the buffer while there are non-zero\n+            // digits left and we haven't written enough digits yet.\n+            while fractional_part > 0 && pos < f.precision().unwrap_or(9) {\n+                // Write new digit into the buffer\n+                buf[pos] = b'0' + (fractional_part / divisor) as u8;\n+\n+                fractional_part %= divisor;\n+                divisor /= 10;\n+                pos += 1;\n+            }\n+\n+            // If a precision < 9 was specified, there may be some non-zero\n+            // digits left that weren't written into the buffer. In that case we\n+            // need to perform rounding to match the semantics of printing\n+            // normal floating point numbers. However, we only need to do work\n+            // when rounding up. This happens if the first digit of the\n+            // remaining ones is >= 5.\n+            if fractional_part > 0 && fractional_part >= divisor * 5 {\n+                // Round up the number contained in the buffer. We go through\n+                // the buffer backwards and keep track of the carry.\n+                let mut rev_pos = pos;\n+                let mut carry = true;\n+                while carry && rev_pos > 0 {\n+                    rev_pos -= 1;\n+\n+                    // If the digit in the buffer is not '9', we just need to\n+                    // increment it and can stop then (since we don't have a\n+                    // carry anymore). Otherwise, we set it to '0' (overflow)\n+                    // and continue.\n+                    if buf[rev_pos] < b'9' {\n+                        buf[rev_pos] += 1;\n+                        carry = false;\n+                    } else {\n+                        buf[rev_pos] = b'0';\n+                    }\n+                }\n+\n+                // If we still have the carry bit set, that means that we set\n+                // the whole buffer to '0's and need to increment the integer\n+                // part.\n+                if carry {\n+                    integer_part += 1;\n+                }\n+            }\n+\n+            // Determine the end of the buffer: if precision is set, we just\n+            // use as many digits from the buffer (capped to 9). If it isn't\n+            // set, we only use all digits up to the last non-zero one.\n+            let end = f.precision().map(|p| ::cmp::min(p, 9)).unwrap_or(pos);\n+\n+            // If we haven't emitted a single fractional digit and the precision\n+            // wasn't set to a non-zero value, we don't print the decimal point.\n+            if end == 0 {\n+                write!(f, \"{}\", integer_part)\n+            } else {\n+                // We are only writing ASCII digits into the buffer and it was\n+                // initialized with '0's, so it contains valid UTF8.\n+                let s = unsafe {\n+                    ::str::from_utf8_unchecked(&buf[..end])\n+                };\n+\n+                // If the user request a precision > 9, we pad '0's at the end.\n+                let w = f.precision().unwrap_or(pos);\n+                write!(f, \"{}.{:0<width$}\", integer_part, s, width = w)\n+            }\n+        }\n+\n+        // Print leading '+' sign if requested\n+        if f.sign_plus() {\n+            write!(f, \"+\")?;\n+        }\n+\n+        if self.secs > 0 {\n+            fmt_decimal(f, self.secs, self.nanos, 100_000_000)?;\n+            f.write_str(\"s\")\n+        } else if self.nanos >= 1_000_000 {\n+            fmt_decimal(f, self.nanos as u64 / 1_000_000, self.nanos % 1_000_000, 100_000)?;\n+            f.write_str(\"ms\")\n+        } else if self.nanos >= 1_000 {\n+            fmt_decimal(f, self.nanos as u64 / 1_000, self.nanos % 1_000, 100)?;\n+            f.write_str(\"\u00b5s\")\n+        } else {\n+            fmt_decimal(f, self.nanos as u64, 0, 1)?;\n+            f.write_str(\"ns\")\n+        }\n+    }\n+}"}]}