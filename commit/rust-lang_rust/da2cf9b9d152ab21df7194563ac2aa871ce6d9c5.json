{"sha": "da2cf9b9d152ab21df7194563ac2aa871ce6d9c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMmNmOWI5ZDE1MmFiMjFkZjcxOTQ1NjNhYzJhYTg3MWNlNmQ5YzU=", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2020-11-30T08:26:22Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-02-04T15:35:52Z"}, "message": "substitutions in trait predicates", "tree": {"sha": "fe3a92a82b4a508d657519859ce533eae9c5ec78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe3a92a82b4a508d657519859ce533eae9c5ec78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da2cf9b9d152ab21df7194563ac2aa871ce6d9c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da2cf9b9d152ab21df7194563ac2aa871ce6d9c5", "html_url": "https://github.com/rust-lang/rust/commit/da2cf9b9d152ab21df7194563ac2aa871ce6d9c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da2cf9b9d152ab21df7194563ac2aa871ce6d9c5/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "760a6654fbddea5d7a9beefe100f0fb784e96928", "url": "https://api.github.com/repos/rust-lang/rust/commits/760a6654fbddea5d7a9beefe100f0fb784e96928", "html_url": "https://github.com/rust-lang/rust/commit/760a6654fbddea5d7a9beefe100f0fb784e96928"}], "stats": {"total": 166, "additions": 104, "deletions": 62}, "files": [{"sha": "5659345f0ff9cfec0c056ad870796e22f4161d25", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 104, "deletions": 62, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/da2cf9b9d152ab21df7194563ac2aa871ce6d9c5/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2cf9b9d152ab21df7194563ac2aa871ce6d9c5/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=da2cf9b9d152ab21df7194563ac2aa871ce6d9c5", "patch": "@@ -112,12 +112,15 @@ pub enum SizedByDefault {\n     No,\n }\n \n+#[derive(Debug)]\n struct ConvertedBinding<'a, 'tcx> {\n     item_name: Ident,\n     kind: ConvertedBindingKind<'a, 'tcx>,\n+    gen_args: &'a GenericArgs<'a>,\n     span: Span,\n }\n \n+#[derive(Debug)]\n enum ConvertedBindingKind<'a, 'tcx> {\n     Equality(Ty<'tcx>),\n     Constraint(&'a [hir::GenericBound<'a>]),\n@@ -323,6 +326,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let tcx = self.tcx();\n         let generics = tcx.generics_of(def_id);\n+        debug!(\"generics: {:?}\", generics);\n \n         if generics.has_self {\n             if generics.parent.is_some() {\n@@ -557,7 +561,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         ConvertedBindingKind::Constraint(bounds)\n                     }\n                 };\n-                ConvertedBinding { item_name: binding.ident, kind, span: binding.span }\n+                ConvertedBinding {\n+                    item_name: binding.ident,\n+                    kind,\n+                    gen_args: binding.gen_args,\n+                    span: binding.span,\n+                }\n             })\n             .collect();\n \n@@ -918,60 +927,27 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         dup_bindings: &mut FxHashMap<DefId, Span>,\n         path_span: Span,\n     ) -> Result<(), ErrorReported> {\n-        let tcx = self.tcx();\n-\n-        if !speculative {\n-            // Given something like `U: SomeTrait<T = X>`, we want to produce a\n-            // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n-            // subtle in the event that `T` is defined in a supertrait of\n-            // `SomeTrait`, because in that case we need to upcast.\n-            //\n-            // That is, consider this case:\n-            //\n-            // ```\n-            // trait SubTrait: SuperTrait<i32> { }\n-            // trait SuperTrait<A> { type T; }\n-            //\n-            // ... B: SubTrait<T = foo> ...\n-            // ```\n-            //\n-            // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n-\n-            // Find any late-bound regions declared in `ty` that are not\n-            // declared in the trait-ref. These are not well-formed.\n-            //\n-            // Example:\n-            //\n-            //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n-            //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n-            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n-                let late_bound_in_trait_ref =\n-                    tcx.collect_constrained_late_bound_regions(&trait_ref);\n-                let late_bound_in_ty =\n-                    tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(ty));\n-                debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n-                debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+        // Given something like `U: SomeTrait<T = X>`, we want to produce a\n+        // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n+        // subtle in the event that `T` is defined in a supertrait of\n+        // `SomeTrait`, because in that case we need to upcast.\n+        //\n+        // That is, consider this case:\n+        //\n+        // ```\n+        // trait SubTrait: SuperTrait<i32> { }\n+        // trait SuperTrait<A> { type T; }\n+        //\n+        // ... B: SubTrait<T = foo> ...\n+        // ```\n+        //\n+        // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n \n-                // FIXME: point at the type params that don't have appropriate lifetimes:\n-                // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n-                //                         ----  ----     ^^^^^^^\n-                self.validate_late_bound_regions(\n-                    late_bound_in_trait_ref,\n-                    late_bound_in_ty,\n-                    |br_name| {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            binding.span,\n-                            E0582,\n-                            \"binding for associated type `{}` references {}, \\\n-                             which does not appear in the trait input types\",\n-                            binding.item_name,\n-                            br_name\n-                        )\n-                    },\n-                );\n-            }\n-        }\n+        debug!(\n+            \"add_predicates_for_ast_type_binding(hir_ref_id {:?}, trait_ref {:?}, binding {:?}, bounds {:?}\",\n+            hir_ref_id, trait_ref, binding, bounds\n+        );\n+        let tcx = self.tcx();\n \n         let candidate =\n             if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n@@ -1030,20 +1006,85 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .or_insert(binding.span);\n         }\n \n+        // Include substitutions for generic parameters of associated types\n+        let projection_ty = candidate.map_bound(|trait_ref| {\n+            let item_segment = hir::PathSegment {\n+                ident: assoc_ty.ident,\n+                hir_id: None,\n+                res: None,\n+                args: Some(binding.gen_args),\n+                infer_args: false,\n+            };\n+\n+            let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n+                tcx,\n+                path_span,\n+                assoc_ty.def_id,\n+                &item_segment,\n+                trait_ref.substs,\n+            );\n+\n+            debug!(\n+                \"add_predicates_for_ast_type_binding: substs for trait-ref and assoc_item: {:?}\",\n+                substs_trait_ref_and_assoc_item\n+            );\n+\n+            ty::ProjectionTy {\n+                item_def_id: assoc_ty.def_id,\n+                substs: substs_trait_ref_and_assoc_item,\n+            }\n+        });\n+\n+        if !speculative {\n+            // Find any late-bound regions declared in `ty` that are not\n+            // declared in the trait-ref or assoc_ty. These are not well-formed.\n+            //\n+            // Example:\n+            //\n+            //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n+            //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n+            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n+                let late_bound_in_trait_ref =\n+                    tcx.collect_constrained_late_bound_regions(&projection_ty);\n+                let late_bound_in_ty =\n+                    tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(ty));\n+                debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n+                debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+\n+                // FIXME: point at the type params that don't have appropriate lifetimes:\n+                // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n+                //                         ----  ----     ^^^^^^^\n+                self.validate_late_bound_regions(\n+                    late_bound_in_trait_ref,\n+                    late_bound_in_ty,\n+                    |br_name| {\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            binding.span,\n+                            E0582,\n+                            \"binding for associated type `{}` references {}, \\\n+                             which does not appear in the trait input types\",\n+                            binding.item_name,\n+                            br_name\n+                        )\n+                    },\n+                );\n+            }\n+        }\n+\n         match binding.kind {\n             ConvertedBindingKind::Equality(ref ty) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n                 // the \"projection predicate\" for:\n                 //\n                 // `<T as Iterator>::Item = u32`\n                 bounds.projection_bounds.push((\n-                    candidate.map_bound(|trait_ref| ty::ProjectionPredicate {\n-                        projection_ty: ty::ProjectionTy::from_ref_and_name(\n-                            tcx,\n-                            trait_ref,\n-                            binding.item_name,\n-                        ),\n-                        ty,\n+                    projection_ty.map_bound(|projection_ty| {\n+                        debug!(\n+                            \"add_predicates_for_ast_type_binding: projection_ty {:?}, substs: {:?}\",\n+                            projection_ty, projection_ty.substs\n+                        );\n+                        ty::ProjectionPredicate { projection_ty, ty }\n                     }),\n                     binding.span,\n                 ));\n@@ -1055,7 +1096,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 //\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n-                let param_ty = tcx.mk_projection(assoc_ty.def_id, candidate.skip_binder().substs);\n+                let param_ty =\n+                    tcx.mk_projection(assoc_ty.def_id, projection_ty.skip_binder().substs);\n                 self.add_bounds(param_ty, ast_bounds, bounds);\n             }\n         }"}]}