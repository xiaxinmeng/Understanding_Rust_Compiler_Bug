{"sha": "f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OWQ0YWM4MzA2ZGJlNTk3ZjBiZmVmN2NmOTJiZWEzNzJlZWNlMWQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-11-30T20:20:59Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-11-30T20:20:59Z"}, "message": "Merge pull request #4081 from graydon/iterbytes-and-workcache\n\nlibs: Remove transitionary material on iter_bytes, add workcache to buil...", "tree": {"sha": "2f40e7042228c2ce0874f972c92d82a89cf15985", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f40e7042228c2ce0874f972c92d82a89cf15985"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "html_url": "https://github.com/rust-lang/rust/commit/f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "946427b562d7ece5fc85c5067051c4aec73d5aff", "url": "https://api.github.com/repos/rust-lang/rust/commits/946427b562d7ece5fc85c5067051c4aec73d5aff", "html_url": "https://github.com/rust-lang/rust/commit/946427b562d7ece5fc85c5067051c4aec73d5aff"}, {"sha": "d783f4d7bb543f33aaf0fc8a04c6d5b2493e8268", "url": "https://api.github.com/repos/rust-lang/rust/commits/d783f4d7bb543f33aaf0fc8a04c6d5b2493e8268", "html_url": "https://github.com/rust-lang/rust/commit/d783f4d7bb543f33aaf0fc8a04c6d5b2493e8268"}], "stats": {"total": 886, "additions": 1, "deletions": 885}, "files": [{"sha": "0d409e704959f30a4af1c2a275241d6889304bca", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 0, "deletions": 335, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -19,7 +19,6 @@ pub type Cb = fn(buf: &[const u8]) -> bool;\n  * modified when default methods and trait inheritence are\n  * completed.\n  */\n-#[cfg(stage0)]\n pub trait IterBytes {\n     /**\n      * Call the provided callback `f` one or more times with\n@@ -35,27 +34,9 @@ pub trait IterBytes {\n      * left-to-right in declaration order, regardless of\n      * underlying memory endianness.\n      */\n-    pure fn iter_bytes(lsb0: bool, f: Cb);\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub trait IterBytes {\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb);\n }\n \n-#[cfg(stage0)]\n-impl bool: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n-        f([\n-            self as u8\n-        ]);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl bool: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -65,18 +46,6 @@ impl bool: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl u8: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n-        f([\n-            self\n-        ]);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl u8: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -86,26 +55,6 @@ impl u8: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl u16: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        if lsb0 {\n-            f([\n-                self as u8,\n-                (self >> 8) as u8\n-            ]);\n-        } else {\n-            f([\n-                (self >> 8) as u8,\n-                self as u8\n-            ]);\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl u16: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -123,30 +72,6 @@ impl u16: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl u32: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        if lsb0 {\n-            f([\n-                self as u8,\n-                (self >> 8) as u8,\n-                (self >> 16) as u8,\n-                (self >> 24) as u8,\n-            ]);\n-        } else {\n-            f([\n-                (self >> 24) as u8,\n-                (self >> 16) as u8,\n-                (self >> 8) as u8,\n-                self as u8\n-            ]);\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl u32: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -168,38 +93,6 @@ impl u32: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl u64: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        if lsb0 {\n-            f([\n-                self as u8,\n-                (self >> 8) as u8,\n-                (self >> 16) as u8,\n-                (self >> 24) as u8,\n-                (self >> 32) as u8,\n-                (self >> 40) as u8,\n-                (self >> 48) as u8,\n-                (self >> 56) as u8\n-            ]);\n-        } else {\n-            f([\n-                (self >> 56) as u8,\n-                (self >> 48) as u8,\n-                (self >> 40) as u8,\n-                (self >> 32) as u8,\n-                (self >> 24) as u8,\n-                (self >> 16) as u8,\n-                (self >> 8) as u8,\n-                self as u8\n-            ]);\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl u64: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -229,84 +122,34 @@ impl u64: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl i8: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl i8: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl i16: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as u16).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl i16: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl i32: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl i32: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl i64: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as u64).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl i64: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl char: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl char: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -316,16 +159,6 @@ impl char: IterBytes {\n \n #[cfg(target_word_size = \"32\")]\n pub mod x32 {\n-    #[cfg(stage0)]\n-    pub impl uint: IterBytes {\n-        #[inline(always)]\n-        pure fn iter_bytes(lsb0: bool, f: Cb) {\n-            (self as u32).iter_bytes(lsb0, f)\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub impl uint: IterBytes {\n         #[inline(always)]\n         pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -336,16 +169,6 @@ pub mod x32 {\n \n #[cfg(target_word_size = \"64\")]\n pub mod x64 {\n-    #[cfg(stage0)]\n-    pub impl uint: IterBytes {\n-        #[inline(always)]\n-        pure fn iter_bytes(lsb0: bool, f: Cb) {\n-            (self as u64).iter_bytes(lsb0, f)\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub impl uint: IterBytes {\n         #[inline(always)]\n         pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -354,37 +177,13 @@ pub mod x64 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl int: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl int: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes> &[A]: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        for self.each |elt| {\n-            do elt.iter_bytes(lsb0) |bytes| {\n-                f(bytes)\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes> &[A]: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -396,18 +195,6 @@ impl<A: IterBytes> &[A]: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes, B: IterBytes> (A,B): IterBytes {\n-  #[inline(always)]\n-  pure fn iter_bytes(lsb0: bool, f: Cb) {\n-    let &(ref a, ref b) = &self;\n-    a.iter_bytes(lsb0, f);\n-    b.iter_bytes(lsb0, f);\n-  }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes, B: IterBytes> (A,B): IterBytes {\n   #[inline(always)]\n   pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -417,19 +204,6 @@ impl<A: IterBytes, B: IterBytes> (A,B): IterBytes {\n   }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes, B: IterBytes, C: IterBytes> (A,B,C): IterBytes {\n-  #[inline(always)]\n-  pure fn iter_bytes(lsb0: bool, f: Cb) {\n-    let &(ref a, ref b, ref c) = &self;\n-    a.iter_bytes(lsb0, f);\n-    b.iter_bytes(lsb0, f);\n-    c.iter_bytes(lsb0, f);\n-  }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes, B: IterBytes, C: IterBytes> (A,B,C): IterBytes {\n   #[inline(always)]\n   pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -445,33 +219,13 @@ pure fn borrow<A>(a: &x/[A]) -> &x/[A] {\n     a\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes> ~[A]: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        borrow(self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes> ~[A]: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes> @[A]: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        borrow(self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes> @[A]: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -582,18 +336,6 @@ pub pure fn iter_bytes_7<A: IterBytes,\n     g.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-#[cfg(stage0)]\n-impl &str: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n-        do str::byte_slice(self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl &str: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -603,18 +345,6 @@ impl &str: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ~str: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n-        do str::byte_slice(self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ~str: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -624,18 +354,6 @@ impl ~str: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl @str: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n-        do str::byte_slice(self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl @str: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -645,19 +363,6 @@ impl @str: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes> Option<A>: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        match self {\n-          Some(ref a) => iter_bytes_2(&0u8, a, lsb0, f),\n-          None => 1u8.iter_bytes(lsb0, f)\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes> Option<A>: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -668,69 +373,29 @@ impl<A: IterBytes> Option<A>: IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes> &A: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (*self).iter_bytes(lsb0, f);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes> &A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes> @A: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (*self).iter_bytes(lsb0, f);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes> @A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: IterBytes> ~A: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (*self).iter_bytes(lsb0, f);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: IterBytes> ~A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A> *const A: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as uint).iter_bytes(lsb0, f);\n-    }\n-}\n-\n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A> *const A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {"}, {"sha": "880e8f40483b31641eb97e2ffa77bbca6c076e35", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -424,14 +424,6 @@ impl root_map_key : cmp::Eq {\n     }\n }\n \n-#[cfg(stage0)]\n-impl root_map_key : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl root_map_key : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);"}, {"sha": "99241efe9d10d210b17758c0c4bbfec72b47eb96", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -1170,22 +1170,6 @@ impl mono_id_ : cmp::Eq {\n     pure fn ne(&self, other: &mono_id_) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl mono_param_id : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          mono_precise(t, mids) =>\n-          to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), &mids, lsb0, f),\n-\n-          mono_any => 1u8.iter_bytes(lsb0, f),\n-\n-          mono_repr(ref a, ref b, ref c, ref d) =>\n-          to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mono_param_id : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -1200,14 +1184,6 @@ impl mono_param_id : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl mono_id_ : core::to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mono_id_ : core::to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);"}, {"sha": "e18b5e03446e8be53d3b6f06fe68b0be291c53dd", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -145,14 +145,6 @@ impl DatumMode: cmp::Eq {\n     pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl DatumMode: to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl DatumMode: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)"}, {"sha": "8660f1a5165b2f53d2e686a3bc11163768eb2326", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 300, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -258,14 +258,6 @@ impl creader_cache_key : cmp::Eq {\n     }\n }\n \n-#[cfg(stage0)]\n-impl creader_cache_key : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl creader_cache_key : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n@@ -281,14 +273,6 @@ impl intern_key : cmp::Eq {\n     pure fn ne(&self, other: &intern_key) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl intern_key : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.sty, &self.o_def_id, lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl intern_key : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.sty, &self.o_def_id, lsb0, f);\n@@ -531,14 +515,6 @@ impl param_ty : cmp::Eq {\n     pure fn ne(&self, other: &param_ty) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl param_ty : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl param_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n@@ -725,18 +701,6 @@ enum InferTy {\n     FloatVar(FloatVid)\n }\n \n-#[cfg(stage0)]\n-impl InferTy : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n-          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n-          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl InferTy : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -754,17 +718,6 @@ enum InferRegion {\n     ReSkolemized(uint, bound_region)\n }\n \n-#[cfg(stage0)]\n-impl InferRegion : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-            ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n-            ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl InferRegion : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -791,21 +744,6 @@ impl InferRegion : cmp::Eq {\n     }\n }\n \n-#[cfg(stage0)]\n-impl param_bound : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          bound_copy => 0u8.iter_bytes(lsb0, f),\n-          bound_owned => 1u8.iter_bytes(lsb0, f),\n-          bound_send => 2u8.iter_bytes(lsb0, f),\n-          bound_const => 3u8.iter_bytes(lsb0, f),\n-          bound_trait(ref t) =>\n-          to_bytes::iter_bytes_2(&4u8, t, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl param_bound : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -877,70 +815,30 @@ impl purity: purity_to_str {\n     }\n }\n \n-#[cfg(stage0)]\n-impl RegionVid : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl RegionVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl TyVid : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TyVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl IntVid : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl IntVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl FloatVid : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FloatVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl FnVid : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FnVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n@@ -2756,25 +2654,6 @@ fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl bound_region : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          ty::br_self => 0u8.iter_bytes(lsb0, f),\n-\n-          ty::br_anon(ref idx) =>\n-          to_bytes::iter_bytes_2(&1u8, idx, lsb0, f),\n-\n-          ty::br_named(ref ident) =>\n-          to_bytes::iter_bytes_2(&2u8, ident, lsb0, f),\n-\n-          ty::br_cap_avoid(ref id, ref br) =>\n-          to_bytes::iter_bytes_3(&3u8, id, br, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl bound_region : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -2792,28 +2671,6 @@ impl bound_region : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Region : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          re_bound(ref br) =>\n-          to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n-\n-          re_free(ref id, ref br) =>\n-          to_bytes::iter_bytes_3(&1u8, id, br, lsb0, f),\n-\n-          re_scope(ref id) =>\n-          to_bytes::iter_bytes_2(&2u8, id, lsb0, f),\n-\n-          re_infer(ref id) =>\n-          to_bytes::iter_bytes_2(&3u8, id, lsb0, f),\n-\n-          re_static => 4u8.iter_bytes(lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Region : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -2834,23 +2691,6 @@ impl Region : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl vstore : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          vstore_fixed(ref u) =>\n-          to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n-\n-          vstore_uniq => 1u8.iter_bytes(lsb0, f),\n-          vstore_box => 2u8.iter_bytes(lsb0, f),\n-\n-          vstore_slice(ref r) =>\n-          to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl vstore : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -2866,16 +2706,6 @@ impl vstore : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl substs : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-          to_bytes::iter_bytes_3(&self.self_r,\n-                                 &self.self_ty,\n-                                 &self.tps, lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl substs : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n@@ -2884,67 +2714,27 @@ impl substs : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl mt : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-          to_bytes::iter_bytes_2(&self.ty,\n-                                 &self.mutbl, lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mt : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl field : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-          to_bytes::iter_bytes_2(&self.ident,\n-                                 &self.mt, lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl field : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl arg : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.mode,\n-                               &self.ty, lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl arg : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.mode,\n                                &self.ty, lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl FnMeta : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_5(&self.purity,\n-                               &self.proto,\n-                               &self.region,\n-                               &self.bounds,\n-                               &self.ret_style,\n-                               lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FnMeta : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity,\n@@ -2956,16 +2746,6 @@ impl FnMeta : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl FnSig : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.inputs,\n-                               &self.output,\n-                               lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FnSig : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n@@ -2974,86 +2754,6 @@ impl FnSig : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl sty : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          ty_nil => 0u8.iter_bytes(lsb0, f),\n-          ty_bool => 1u8.iter_bytes(lsb0, f),\n-\n-          ty_int(ref t) =>\n-          to_bytes::iter_bytes_2(&2u8, t, lsb0, f),\n-\n-          ty_uint(ref t) =>\n-          to_bytes::iter_bytes_2(&3u8, t, lsb0, f),\n-\n-          ty_float(ref t) =>\n-          to_bytes::iter_bytes_2(&4u8, t, lsb0, f),\n-\n-          ty_estr(ref v) =>\n-          to_bytes::iter_bytes_2(&5u8, v, lsb0, f),\n-\n-          ty_enum(ref did, ref substs) =>\n-          to_bytes::iter_bytes_3(&6u8, did, substs, lsb0, f),\n-\n-          ty_box(ref mt) =>\n-          to_bytes::iter_bytes_2(&7u8, mt, lsb0, f),\n-\n-          ty_evec(ref mt, ref v) =>\n-          to_bytes::iter_bytes_3(&8u8, mt, v, lsb0, f),\n-\n-          ty_unboxed_vec(ref mt) =>\n-          to_bytes::iter_bytes_2(&9u8, mt, lsb0, f),\n-\n-          ty_tup(ref ts) =>\n-          to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n-\n-          ty_rec(ref fs) =>\n-          to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n-\n-          ty_fn(ref ft) =>\n-          to_bytes::iter_bytes_3(&12u8,\n-                                 &ft.meta,\n-                                 &ft.sig,\n-                                 lsb0, f),\n-\n-          ty_self => 13u8.iter_bytes(lsb0, f),\n-\n-          ty_infer(ref v) =>\n-          to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n-\n-          ty_param(ref p) =>\n-          to_bytes::iter_bytes_2(&15u8, p, lsb0, f),\n-\n-          ty_type => 16u8.iter_bytes(lsb0, f),\n-          ty_bot => 17u8.iter_bytes(lsb0, f),\n-\n-          ty_ptr(ref mt) =>\n-          to_bytes::iter_bytes_2(&18u8, mt, lsb0, f),\n-\n-          ty_uniq(ref mt) =>\n-          to_bytes::iter_bytes_2(&19u8, mt, lsb0, f),\n-\n-          ty_trait(ref did, ref substs, ref v) =>\n-          to_bytes::iter_bytes_4(&20u8, did, substs, v, lsb0, f),\n-\n-          ty_opaque_closure_ptr(ref ck) =>\n-          to_bytes::iter_bytes_2(&21u8, ck, lsb0, f),\n-\n-          ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n-\n-          ty_class(ref did, ref substs) =>\n-          to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n-\n-          ty_rptr(ref r, ref mt) =>\n-          to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n-\n-          ty_err => 25u8.iter_bytes(lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl sty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {"}, {"sha": "a334977819b2b6862b9893206d2e675ac711bc3f", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -488,23 +488,6 @@ impl Constraint : cmp::Eq {\n     pure fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl Constraint : to_bytes::IterBytes {\n-   pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          ConstrainVarSubVar(ref v0, ref v1) =>\n-          to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n-\n-          ConstrainRegSubVar(ref ra, ref va) =>\n-          to_bytes::iter_bytes_3(&1u8, ra, va, lsb0, f),\n-\n-          ConstrainVarSubReg(ref va, ref ra) =>\n-          to_bytes::iter_bytes_3(&2u8, va, ra, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Constraint : to_bytes::IterBytes {\n    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -532,14 +515,6 @@ impl TwoRegions : cmp::Eq {\n     pure fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl TwoRegions : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TwoRegions : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)"}, {"sha": "136df3a4193fd91c88edc5f1534e81ad7f37748d", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -737,15 +737,6 @@ impl Url : Eq {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Url: IterBytes {\n-    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n-        unsafe { self.to_str() }.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Url: IterBytes {\n     pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         unsafe { self.to_str() }.iter_bytes(lsb0, f)"}, {"sha": "af2977634e95f5a185e19e971d963925702072d5", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -85,7 +85,7 @@ pub mod par;\n pub mod cmp;\n pub mod base64;\n pub mod rl;\n-// pub mod workcache;\n+pub mod workcache;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "08f3d21be47ad57fb871279fd5b5ff92f721e3a6", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -74,19 +74,6 @@ struct WorkKey {\n     name: ~str\n }\n \n-#[cfg(stage0)]\n-impl WorkKey: to_bytes::IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        let mut flag = true;\n-        self.kind.iter_bytes(lsb0, |bytes| {flag = f(bytes); flag});\n-        if !flag { return; }\n-        self.name.iter_bytes(lsb0, f);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl WorkKey: to_bytes::IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {"}, {"sha": "1ffe741d255fdef0f1794b9209b0364c0c5b90b6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -54,15 +54,6 @@ impl ident: cmp::Eq {\n     pure fn ne(&self, other: &ident) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl ident: to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        self.repr.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ident: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n@@ -311,25 +302,6 @@ enum binding_mode {\n     bind_by_implicit_ref\n }\n \n-#[cfg(stage0)]\n-impl binding_mode : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          bind_by_value => 0u8.iter_bytes(lsb0, f),\n-\n-          bind_by_move => 1u8.iter_bytes(lsb0, f),\n-\n-          bind_by_ref(ref m) =>\n-          to_bytes::iter_bytes_2(&2u8, m, lsb0, f),\n-\n-          bind_by_implicit_ref =>\n-          3u8.iter_bytes(lsb0, f),\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl binding_mode : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -406,15 +378,6 @@ enum pat_ {\n #[auto_deserialize]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n-#[cfg(stage0)]\n-impl mutability : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mutability : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -444,15 +407,6 @@ impl Proto : cmp::Eq {\n     pure fn ne(&self, other: &Proto) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl Proto : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as uint).iter_bytes(lsb0, f);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Proto : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n@@ -576,21 +530,6 @@ enum inferable<T> {\n     infer(node_id)\n }\n \n-#[cfg(stage0)]\n-impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          expl(ref t) =>\n-          to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n-\n-          infer(ref n) =>\n-          to_bytes::iter_bytes_2(&1u8, n, lsb0, f),\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -628,14 +567,6 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n #[auto_deserialize]\n enum rmode { by_ref, by_val, by_move, by_copy }\n \n-#[cfg(stage0)]\n-impl rmode : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl rmode : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -985,14 +916,6 @@ enum trait_method {\n #[auto_deserialize]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n-#[cfg(stage0)]\n-impl int_ty : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl int_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -1023,14 +946,6 @@ impl int_ty : cmp::Eq {\n #[auto_deserialize]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n-#[cfg(stage0)]\n-impl uint_ty : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl uint_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -1059,14 +974,6 @@ impl uint_ty : cmp::Eq {\n #[auto_deserialize]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n-#[cfg(stage0)]\n-impl float_ty : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl float_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -1212,15 +1119,6 @@ impl Ty : cmp::Eq {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Ty : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n@@ -1248,15 +1146,6 @@ enum purity {\n     extern_fn, // declared with \"extern fn\"\n }\n \n-#[cfg(stage0)]\n-impl purity : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl purity : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -1278,14 +1167,6 @@ enum ret_style {\n     return_val, // everything else\n }\n \n-#[cfg(stage0)]\n-impl ret_style : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ret_style : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -1635,14 +1516,6 @@ enum item_ {\n #[auto_deserialize]\n enum class_mutability { class_mutable, class_immutable }\n \n-#[cfg(stage0)]\n-impl class_mutability : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl class_mutability : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)"}, {"sha": "0b066b5716815da0d83c21dfe0b9a08fcbd57dd6", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -252,15 +252,6 @@ pure fn is_call_expr(e: @expr) -> bool {\n }\n \n // This makes def_id hashable\n-#[cfg(stage0)]\n-impl def_id : core::to_bytes::IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(+lsb0: bool, f: core::to_bytes::Cb) {\n-        core::to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl def_id : core::to_bytes::IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, +lsb0: bool, f: core::to_bytes::Cb) {"}, {"sha": "693597eb8405e7a536f5984530e75c3dec88718f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -72,15 +72,6 @@ impl BytePos: Num {\n     static pure fn from_int(+n: int) -> BytePos { BytePos(n as uint) }\n }\n \n-#[cfg(stage0)]\n-impl BytePos: to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (*self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl BytePos: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n@@ -127,14 +118,6 @@ impl CharPos: Num {\n     static pure fn from_int(+n: int) -> CharPos { CharPos(n as uint) }\n }\n \n-#[cfg(stage0)]\n-impl CharPos: to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl CharPos: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)"}, {"sha": "afa87c261f1bb297b978fe863f324a7f42015e66", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89d4ac8306dbe597f0bfef7cf92bea372eece1d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=f89d4ac8306dbe597f0bfef7cf92bea372eece1d", "patch": "@@ -36,15 +36,6 @@ impl ObsoleteSyntax : cmp::Eq {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ObsoleteSyntax: to_bytes::IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as uint).iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ObsoleteSyntax: to_bytes::IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {"}]}