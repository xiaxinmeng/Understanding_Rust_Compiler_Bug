{"sha": "d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "node_id": "C_kwDOAAsO6NoAKGQ2MGM2NGEwYzVkMWJjYTE1MjdhYzZkZGU5NTI1NGU4YWE0N2QwZTU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-24T05:53:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-24T05:53:24Z"}, "message": "Rollup merge of #110514 - compiler-errors:remove-find_map_relevant_impl, r=b-naber\n\nRemove `find_map_relevant_impl`\n\nFixes #108895", "tree": {"sha": "69b152313689250a35f87b304dd41e66a7caf800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69b152313689250a35f87b304dd41e66a7caf800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkRhlUCRBK7hj4Ov3rIwAApwMIADTkXL+giFPU5ORBJ+tRh8ut\nxpwqD4T+9FtsL60upJOmdLZ3KaIicwd6yqS3h0pB9HW30480Q7vHScwKVm7r4e7Z\n+IeNWidOtkx04qiwaAsHPM7o0zNkFWOYNegD370Omko4OlCHmtNfLEm9X2AUIc9y\nuIDj7oiKdGgzbrUUc7yIq8lB9DkYQ25klfm+P4ln/U7Rq8SPl63xuxGfND5czDWC\nanxGo80dwcXjYNd4Fmag/80TQUbJLnLc7XuMniAlpJbOWsBczTkYLEA+8BriMQVh\nUptgtTV6nPkfkGVQCIpGRswrOdi5yePRLmZBGlOAk4qgYKloF5HuxF+32zQWtNo=\n=Drzz\n-----END PGP SIGNATURE-----\n", "payload": "tree 69b152313689250a35f87b304dd41e66a7caf800\nparent 0f271619e457ce8a2e32d822cce4c219bad58aa1\nparent 14678778dc50ce5886856826f8cd35dc080ead7e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682315604 +0200\ncommitter GitHub <noreply@github.com> 1682315604 +0200\n\nRollup merge of #110514 - compiler-errors:remove-find_map_relevant_impl, r=b-naber\n\nRemove `find_map_relevant_impl`\n\nFixes #108895\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "html_url": "https://github.com/rust-lang/rust/commit/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f271619e457ce8a2e32d822cce4c219bad58aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f271619e457ce8a2e32d822cce4c219bad58aa1", "html_url": "https://github.com/rust-lang/rust/commit/0f271619e457ce8a2e32d822cce4c219bad58aa1"}, {"sha": "14678778dc50ce5886856826f8cd35dc080ead7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/14678778dc50ce5886856826f8cd35dc080ead7e", "html_url": "https://github.com/rust-lang/rust/commit/14678778dc50ce5886856826f8cd35dc080ead7e"}], "stats": {"total": 296, "additions": 154, "deletions": 142}, "files": [{"sha": "e61037e5ea86fbbf2d30b021f9982bd61070f21d", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 18, "deletions": 44, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "patch": "@@ -139,40 +139,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         treat_projections: TreatProjections,\n         mut f: impl FnMut(DefId),\n     ) {\n-        let _: Option<()> =\n-            self.find_map_relevant_impl(trait_def_id, self_ty, treat_projections, |did| {\n-                f(did);\n-                None\n-            });\n-    }\n-\n-    /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn non_blanket_impls_for_ty(\n-        self,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-    ) -> impl Iterator<Item = DefId> + 'tcx {\n-        let impls = self.trait_impls_of(trait_def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsCandidateKey) {\n-            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n-                return impls.iter().copied();\n-            }\n-        }\n-\n-        [].iter().copied()\n-    }\n-\n-    /// Applies function to every impl that could possibly match the self type `self_ty` and returns\n-    /// the first non-none value.\n-    ///\n-    /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn find_map_relevant_impl<T>(\n-        self,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        treat_projections: TreatProjections,\n-        mut f: impl FnMut(DefId) -> Option<T>,\n-    ) -> Option<T> {\n         // FIXME: This depends on the set of all impls for the trait. That is\n         // unfortunate wrt. incremental compilation.\n         //\n@@ -181,9 +147,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let impls = self.trait_impls_of(trait_def_id);\n \n         for &impl_def_id in impls.blanket_impls.iter() {\n-            if let result @ Some(_) = f(impl_def_id) {\n-                return result;\n-            }\n+            f(impl_def_id);\n         }\n \n         // Note that we're using `TreatParams::ForLookup` to query `non_blanket_impls` while using\n@@ -199,20 +163,30 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(simp) = fast_reject::simplify_type(self, self_ty, treat_params) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n-                    if let result @ Some(_) = f(impl_def_id) {\n-                        return result;\n-                    }\n+                    f(impl_def_id);\n                 }\n             }\n         } else {\n             for &impl_def_id in impls.non_blanket_impls.values().flatten() {\n-                if let result @ Some(_) = f(impl_def_id) {\n-                    return result;\n-                }\n+                f(impl_def_id);\n             }\n         }\n+    }\n \n-        None\n+    /// `trait_def_id` MUST BE the `DefId` of a trait.\n+    pub fn non_blanket_impls_for_ty(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+    ) -> impl Iterator<Item = DefId> + 'tcx {\n+        let impls = self.trait_impls_of(trait_def_id);\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsCandidateKey) {\n+            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n+                return impls.iter().copied();\n+            }\n+        }\n+\n+        [].iter().copied()\n     }\n \n     /// Returns an iterator containing all impls for `trait_def_id`."}, {"sha": "9dbd9fbbb5bb3d23029eceaa27262428b4a91416", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "patch": "@@ -2,7 +2,6 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n-use crate::ty::fast_reject::TreatProjections;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -359,21 +358,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ensure().coherent_trait(drop_trait);\n \n         let ty = self.type_of(adt_did).subst_identity();\n-        let (did, constness) = self.find_map_relevant_impl(\n-            drop_trait,\n-            ty,\n-            // FIXME: This could also be some other mode, like \"unexpected\"\n-            TreatProjections::ForLookup,\n-            |impl_did| {\n-                if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n-                    if validate(self, impl_did).is_ok() {\n-                        return Some((*item_id, self.constness(impl_did)));\n-                    }\n-                }\n-                None\n-            },\n-        )?;\n+        let mut dtor_candidate = None;\n+        self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n+            let Some(item_id) = self.associated_item_def_ids(impl_did).first() else {\n+                self.sess.delay_span_bug(self.def_span(impl_did), \"Drop impl without drop function\");\n+                return;\n+            };\n+\n+            if validate(self, impl_did).is_err() {\n+                // Already `ErrorGuaranteed`, no need to delay a span bug here.\n+                return;\n+            }\n+\n+            if let Some((old_item_id, _)) = dtor_candidate {\n+                self.sess\n+                    .struct_span_err(self.def_span(item_id), \"multiple drop impls found\")\n+                    .span_note(self.def_span(old_item_id), \"other impl here\")\n+                    .delay_as_bug();\n+            }\n+\n+            dtor_candidate = Some((*item_id, self.constness(impl_did)));\n+        });\n \n+        let (did, constness) = dtor_candidate?;\n         Some(ty::Destructor { did, constness })\n     }\n "}, {"sha": "8e7097ce4a7791edffb7e545a47798285570385b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "patch": "@@ -645,12 +645,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // FIXME: Handling opaques here is kinda sus. Especially because we\n             // simplify them to PlaceholderSimplifiedType.\n             | ty::Alias(ty::Opaque, _) => {\n-                if let Some(def_id) = self.tcx().find_map_relevant_impl(\n+                let mut disqualifying_impl = None;\n+                self.tcx().for_each_relevant_impl_treating_projections(\n                     goal.predicate.def_id(),\n                     goal.predicate.self_ty(),\n                     TreatProjections::NextSolverLookup,\n-                    Some,\n-                ) {\n+                    |impl_def_id| {\n+                        disqualifying_impl = Some(impl_def_id);\n+                    },\n+                );\n+                if let Some(def_id) = disqualifying_impl {\n                     debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");\n                     // No need to actually consider the candidate here,\n                     // since we do that in `consider_impl_candidate`."}, {"sha": "61e382bbe49d6b0a3fdce40c9b5ad6c7777d0ee1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 79, "deletions": 66, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "patch": "@@ -32,7 +32,6 @@ use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n@@ -1836,57 +1835,61 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 });\n             let mut diag = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271, \"{msg}\");\n \n-            let secondary_span = match predicate.kind().skip_binder() {\n-                ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => self\n-                    .tcx\n-                    .opt_associated_item(proj.projection_ty.def_id)\n-                    .and_then(|trait_assoc_item| {\n-                        self.tcx\n-                            .trait_of_item(proj.projection_ty.def_id)\n-                            .map(|id| (trait_assoc_item, id))\n-                    })\n-                    .and_then(|(trait_assoc_item, id)| {\n-                        let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n-                        self.tcx.find_map_relevant_impl(\n-                            id,\n-                            proj.projection_ty.self_ty(),\n-                            TreatProjections::ForLookup,\n-                            |did| {\n-                                self.tcx\n-                                    .associated_items(did)\n-                                    .in_definition_order()\n-                                    .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n-                            },\n-                        )\n-                    })\n-                    .and_then(|item| match self.tcx.hir().get_if_local(item.def_id) {\n-                        Some(\n-                            hir::Node::TraitItem(hir::TraitItem {\n-                                kind: hir::TraitItemKind::Type(_, Some(ty)),\n-                                ..\n-                            })\n-                            | hir::Node::ImplItem(hir::ImplItem {\n-                                kind: hir::ImplItemKind::Type(ty),\n-                                ..\n-                            }),\n-                        ) => Some((\n-                            ty.span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"type mismatch resolving `{}`\",\n-                                self.resolve_vars_if_possible(predicate)\n-                                    .print(FmtPrinter::new_with_limit(\n-                                        self.tcx,\n-                                        Namespace::TypeNS,\n-                                        rustc_session::Limit(5),\n-                                    ))\n-                                    .unwrap()\n-                                    .into_buffer()\n-                            )),\n+            let secondary_span = (|| {\n+                let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) =\n+                    predicate.kind().skip_binder()\n+                else {\n+                    return None;\n+                };\n+\n+                let trait_assoc_item = self.tcx.opt_associated_item(proj.projection_ty.def_id)?;\n+                let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n+\n+                let mut associated_items = vec![];\n+                self.tcx.for_each_relevant_impl(\n+                    self.tcx.trait_of_item(proj.projection_ty.def_id)?,\n+                    proj.projection_ty.self_ty(),\n+                    |impl_def_id| {\n+                        associated_items.extend(\n+                            self.tcx\n+                                .associated_items(impl_def_id)\n+                                .in_definition_order()\n+                                .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident),\n+                        );\n+                    },\n+                );\n+\n+                let [associated_item]: &[ty::AssocItem] = &associated_items[..] else {\n+                    return None;\n+                };\n+                match self.tcx.hir().get_if_local(associated_item.def_id) {\n+                    Some(\n+                        hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Type(_, Some(ty)),\n+                            ..\n+                        })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Type(ty),\n+                            ..\n+                        }),\n+                    ) => Some((\n+                        ty.span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"type mismatch resolving `{}`\",\n+                            self.resolve_vars_if_possible(predicate)\n+                                .print(FmtPrinter::new_with_limit(\n+                                    self.tcx,\n+                                    Namespace::TypeNS,\n+                                    rustc_session::Limit(5),\n+                                ))\n+                                .unwrap()\n+                                .into_buffer()\n                         )),\n-                        _ => None,\n-                    }),\n-                _ => None,\n-            };\n+                    )),\n+                    _ => None,\n+                }\n+            })();\n+\n             self.note_type_err(\n                 &mut diag,\n                 &obligation.cause,\n@@ -2228,14 +2231,18 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        let get_trait_impl = |trait_def_id| {\n-            self.tcx.find_map_relevant_impl(\n+        let get_trait_impls = |trait_def_id| {\n+            let mut trait_impls = vec![];\n+            self.tcx.for_each_relevant_impl(\n                 trait_def_id,\n                 trait_ref.skip_binder().self_ty(),\n-                TreatProjections::ForLookup,\n-                Some,\n-            )\n+                |impl_def_id| {\n+                    trait_impls.push(impl_def_id);\n+                },\n+            );\n+            trait_impls\n         };\n+\n         let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n         let traits_with_same_path: std::collections::BTreeSet<_> = self\n             .tcx\n@@ -2245,17 +2252,23 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .collect();\n         let mut suggested = false;\n         for trait_with_same_path in traits_with_same_path {\n-            if let Some(impl_def_id) = get_trait_impl(trait_with_same_path) {\n-                let impl_span = self.tcx.def_span(impl_def_id);\n-                err.span_help(impl_span, \"trait impl with same name found\");\n-                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n-                let crate_msg = format!(\n-                    \"perhaps two different versions of crate `{}` are being used?\",\n-                    trait_crate\n-                );\n-                err.note(&crate_msg);\n-                suggested = true;\n+            let trait_impls = get_trait_impls(trait_with_same_path);\n+            if trait_impls.is_empty() {\n+                continue;\n             }\n+            let impl_spans: Vec<_> =\n+                trait_impls.iter().map(|impl_def_id| self.tcx.def_span(*impl_def_id)).collect();\n+            err.span_help(\n+                impl_spans,\n+                format!(\"trait impl{} with same name found\", pluralize!(trait_impls.len())),\n+            );\n+            let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n+            let crate_msg = format!(\n+                \"perhaps two different versions of crate `{}` are being used?\",\n+                trait_crate\n+            );\n+            err.note(&crate_msg);\n+            suggested = true;\n         }\n         suggested\n     }"}, {"sha": "1db9b8ce92e4fe9aee34355fc58c67444ace136f", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "patch": "@@ -11,7 +11,7 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n-use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n \n use crate::traits;\n@@ -875,12 +875,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Adt(..) => {\n-                // Find a custom `impl Drop` impl, if it exists\n-                let relevant_impl = self.tcx().find_map_relevant_impl(\n+                let mut relevant_impl = None;\n+                self.tcx().for_each_relevant_impl(\n                     self.tcx().require_lang_item(LangItem::Drop, None),\n                     obligation.predicate.skip_binder().trait_ref.self_ty(),\n-                    TreatProjections::ForLookup,\n-                    Some,\n+                    |impl_def_id| {\n+                        if let Some(old_impl_def_id) = relevant_impl {\n+                            self.tcx()\n+                                .sess\n+                                .struct_span_err(\n+                                    self.tcx().def_span(impl_def_id),\n+                                    \"multiple drop impls found\",\n+                                )\n+                                .span_note(self.tcx().def_span(old_impl_def_id), \"other impl here\")\n+                                .delay_as_bug();\n+                        }\n+\n+                        relevant_impl = Some(impl_def_id);\n+                    },\n                 );\n \n                 if let Some(impl_def_id) = relevant_impl {"}, {"sha": "f2486abaaa77eec089db98341303ee157c6ff48e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d60c64a0c5d1bca1527ac6dde95254e8aa47d0e5", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n-use rustc_middle::ty::{fast_reject::TreatProjections, Ty, TyCtxt};\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_middle::{bug, ty};\n use rustc_resolve::rustdoc::{has_primitive_or_keyword_docs, prepare_to_doc_link_resolution};\n use rustc_resolve::rustdoc::{strip_generics_from_path, MalformedGenerics};\n@@ -772,11 +772,10 @@ fn trait_impls_for<'a>(\n     module: DefId,\n ) -> FxHashSet<(DefId, DefId)> {\n     let tcx = cx.tcx;\n-    let iter = tcx.doc_link_traits_in_scope(module).iter().flat_map(|&trait_| {\n-        trace!(\"considering explicit impl for trait {:?}\", trait_);\n+    let mut impls = FxHashSet::default();\n \n-        // Look at each trait implementation to see if it's an impl for `did`\n-        tcx.find_map_relevant_impl(trait_, ty, TreatProjections::ForLookup, |impl_| {\n+    for &trait_ in tcx.doc_link_traits_in_scope(module) {\n+        tcx.for_each_relevant_impl(trait_, ty, |impl_| {\n             let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.skip_binder().self_ty();\n@@ -800,10 +799,13 @@ fn trait_impls_for<'a>(\n                     _ => false,\n                 };\n \n-            if saw_impl { Some((impl_, trait_)) } else { None }\n-        })\n-    });\n-    iter.collect()\n+            if saw_impl {\n+                impls.insert((impl_, trait_));\n+            }\n+        });\n+    }\n+\n+    impls\n }\n \n /// Check for resolve collisions between a trait and its derive."}]}