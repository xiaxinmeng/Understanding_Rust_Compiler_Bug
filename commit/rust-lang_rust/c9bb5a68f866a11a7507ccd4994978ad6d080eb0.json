{"sha": "c9bb5a68f866a11a7507ccd4994978ad6d080eb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YmI1YTY4Zjg2NmExMWE3NTA3Y2NkNDk5NDk3OGFkNmQwODBlYjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-14T08:56:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-15T00:16:31Z"}, "message": "convert tydecode to use a closure for def-id conversion and\nto store the closure in the PSState struct", "tree": {"sha": "2c8027d528429f85805a53d800afa6d83b4b50c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c8027d528429f85805a53d800afa6d83b4b50c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9bb5a68f866a11a7507ccd4994978ad6d080eb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bb5a68f866a11a7507ccd4994978ad6d080eb0", "html_url": "https://github.com/rust-lang/rust/commit/c9bb5a68f866a11a7507ccd4994978ad6d080eb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9bb5a68f866a11a7507ccd4994978ad6d080eb0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a6118b74840727e17ec42b0aa6d7a215d57d2df", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6118b74840727e17ec42b0aa6d7a215d57d2df", "html_url": "https://github.com/rust-lang/rust/commit/8a6118b74840727e17ec42b0aa6d7a215d57d2df"}], "stats": {"total": 401, "additions": 142, "deletions": 259}, "files": [{"sha": "bdeae1c4bc96cf4daa46d79936c0958c4e90e846", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 142, "deletions": 259, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/c9bb5a68f866a11a7507ccd4994978ad6d080eb0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bb5a68f866a11a7507ccd4994978ad6d080eb0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=c9bb5a68f866a11a7507ccd4994978ad6d080eb0", "patch": "@@ -57,13 +57,14 @@ pub enum DefIdSource {\n     ClosureSource\n }\n \n-// type conv_did = impl FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n+pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n \n pub struct PState<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: usize,\n-    tcx: &'a ty::ctxt<'tcx>\n+    tcx: &'a ty::ctxt<'tcx>,\n+    conv_def_id: DefIdConvert<'a>,\n }\n \n fn peek(st: &PState) -> char {\n@@ -82,9 +83,8 @@ fn next_byte(st: &mut PState) -> u8 {\n     return b;\n }\n \n-fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n+fn scan<'a, 'tcx, F>(st: &mut PState<'a,'tcx>, mut is_last: F) -> &'a [u8] where\n     F: FnMut(char) -> bool,\n-    G: FnOnce(&[u8]) -> R,\n {\n     let start_pos = st.pos;\n     debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n@@ -94,30 +94,27 @@ fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(&st.data[start_pos..end_pos]);\n+    return &st.data[start_pos..end_pos];\n }\n \n pub fn parse_name(st: &mut PState, last: char) -> ast::Name {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n-    parse_name_(st, |a| is_last(last, a) )\n+    let bytes = scan(st, |a| is_last(last, a));\n+    token::intern(str::from_utf8(bytes).unwrap())\n }\n \n-fn parse_name_<F>(st: &mut PState, is_last: F) -> ast::Name where\n-    F: FnMut(char) -> bool,\n-{\n-    scan(st, is_last, |bytes| {\n-        token::intern(str::from_utf8(bytes).unwrap())\n-    })\n-}\n-\n-pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n-                                       pos: usize, tcx: &'a ty::ctxt<'tcx>)\n+pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8],\n+                                       crate_num: ast::CrateNum,\n+                                       pos: usize,\n+                                       tcx: &'a ty::ctxt<'tcx>,\n+                                       conv: DefIdConvert<'a>)\n                                        -> PState<'a, 'tcx> {\n     PState {\n         data: data,\n         krate: crate_num,\n         pos: pos,\n-        tcx: tcx\n+        tcx: tcx,\n+        conv_def_id: conv,\n     }\n }\n \n@@ -140,77 +137,77 @@ pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n                                       crate_num: ast::CrateNum,\n                                       pos: usize,\n                                       tcx: &ty::ctxt<'tcx>,\n-                                      conv: F)\n+                                      mut conv: F)\n                                       -> ty::ClosureTy<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_closure_ty(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_closure_ty(&mut st)\n }\n \n pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                              tcx: &ty::ctxt<'tcx>, conv: F) -> Ty<'tcx> where\n+                              tcx: &ty::ctxt<'tcx>, mut conv: F) -> Ty<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_ty(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_ty(&mut st)\n }\n \n pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: usize, tcx: &ty::ctxt,\n-                            conv: F) -> ty::Region where\n+                            mut conv: F) -> ty::Region where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_region_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_region(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_region(&mut st)\n }\n \n pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                                      tcx: &ty::ctxt<'tcx>, conv: F)\n+                                      tcx: &ty::ctxt<'tcx>, mut conv: F)\n                                       -> ty::BareFnTy<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_bare_fn_ty(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_bare_fn_ty(&mut st)\n }\n \n pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                                     tcx: &ty::ctxt<'tcx>, conv: F)\n+                                     tcx: &ty::ctxt<'tcx>, mut conv: F)\n                                      -> ty::TraitRef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_trait_ref(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_trait_ref(&mut st)\n }\n \n pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                                  tcx: &ty::ctxt<'tcx>, conv: F) -> subst::Substs<'tcx> where\n+                                  tcx: &ty::ctxt<'tcx>, mut conv: F) -> subst::Substs<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_substs_data{}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_substs(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_substs(&mut st)\n }\n \n pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n-                                              pos: usize, tcx: &ty::ctxt<'tcx>, conv: F)\n+                                              pos: usize, tcx: &ty::ctxt<'tcx>, mut conv: F)\n                                               -> ty::ExistentialBounds<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_existential_bounds(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_existential_bounds(&mut st)\n }\n \n pub fn parse_builtin_bounds_data<F>(data: &[u8], crate_num: ast::CrateNum,\n-                                    pos: usize, tcx: &ty::ctxt, conv: F)\n+                                    pos: usize, tcx: &ty::ctxt, mut conv: F)\n                                     -> ty::BuiltinBounds where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_builtin_bounds(&mut st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n+    parse_builtin_bounds(&mut st)\n }\n \n fn parse_size(st: &mut PState) -> Option<usize> {\n@@ -242,52 +239,33 @@ fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n     r\n }\n \n-fn parse_substs<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                             mut conv: F) -> subst::Substs<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_substs_(st, &mut conv)\n+fn parse_substs<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> subst::Substs<'tcx> {\n+    let regions = parse_region_substs(st);\n+    let types = parse_vec_per_param_space(st, |st| parse_ty(st));\n+    subst::Substs { types: types, regions: regions }\n }\n \n-fn parse_substs_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                              conv: &mut F) -> subst::Substs<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let regions =\n-        parse_region_substs_(st, conv);\n-\n-    let types =\n-        parse_vec_per_param_space(st, |st| parse_ty_(st, conv));\n-\n-    subst::Substs { types: types,\n-                    regions: regions }\n-}\n-\n-fn parse_region_substs_<F>(st: &mut PState, conv: &mut F) -> subst::RegionSubsts where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_region_substs(st: &mut PState) -> subst::RegionSubsts {\n     match next(st) {\n         'e' => subst::ErasedRegions,\n         'n' => {\n             subst::NonerasedRegions(\n                 parse_vec_per_param_space(\n-                    st, |st| parse_region_(st, conv)))\n+                    st, |st| parse_region(st)))\n         }\n         _ => panic!(\"parse_bound_region: bad input\")\n     }\n }\n \n-fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_bound_region(st: &mut PState) -> ty::BoundRegion {\n     match next(st) {\n         'a' => {\n             let id = parse_u32(st);\n             assert_eq!(next(st), '|');\n             ty::BrAnon(id)\n         }\n         '[' => {\n-            let def = parse_def_(st, RegionParameter, conv);\n+            let def = parse_def(st, RegionParameter);\n             let ident = token::str_to_ident(&parse_str(st, ']'));\n             ty::BrNamed(def, ident.name)\n         }\n@@ -301,21 +279,13 @@ fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion wher\n     }\n }\n \n-fn parse_region<F>(st: &mut PState, mut conv: F) -> ty::Region where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_region_(st, &mut conv)\n-}\n-\n-fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_region(st: &mut PState) -> ty::Region {\n     match next(st) {\n       'b' => {\n         assert_eq!(next(st), '[');\n         let id = ty::DebruijnIndex::new(parse_u32(st));\n         assert_eq!(next(st), '|');\n-        let br = parse_bound_region_(st, conv);\n+        let br = parse_bound_region(st);\n         assert_eq!(next(st), ']');\n         ty::ReLateBound(id, br)\n       }\n@@ -339,7 +309,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         assert_eq!(next(st), '[');\n         let scope = parse_destruction_scope_data(st);\n         assert_eq!(next(st), '|');\n-        let br = parse_bound_region_(st, conv);\n+        let br = parse_bound_region(st);\n         assert_eq!(next(st), ']');\n         ty::ReFree(ty::FreeRegion { scope: scope,\n                                     bound_region: br})\n@@ -420,31 +390,13 @@ fn parse_str(st: &mut PState, term: char) -> String {\n     result\n }\n \n-fn parse_trait_ref<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n-                                -> ty::TraitRef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_trait_ref_(st, &mut conv)\n-}\n-\n-fn parse_trait_ref_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n-                              -> ty::TraitRef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let def = parse_def_(st, NominalType, conv);\n-    let substs = st.tcx.mk_substs(parse_substs_(st, conv));\n+fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::TraitRef<'tcx> {\n+    let def = parse_def(st, NominalType);\n+    let substs = st.tcx.mk_substs(parse_substs(st));\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n-fn parse_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F) -> Ty<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_ty_(st, &mut conv)\n-}\n-\n-fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> Ty<'tcx> {\n     let tcx = st.tcx;\n     match next(st) {\n       'b' => return tcx.types.bool,\n@@ -468,16 +420,16 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       'c' => return tcx.types.char,\n       't' => {\n         assert_eq!(next(st), '[');\n-        let did = parse_def_(st, NominalType, conv);\n-        let substs = parse_substs_(st, conv);\n+        let did = parse_def(st, NominalType);\n+        let substs = parse_substs(st);\n         assert_eq!(next(st), ']');\n         let def = st.tcx.lookup_adt_def(did);\n         return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let trait_ref = ty::Binder(parse_trait_ref_(st, conv));\n-        let bounds = parse_existential_bounds_(st, conv);\n+        let trait_ref = ty::Binder(parse_trait_ref(st));\n+        let bounds = parse_existential_bounds(st);\n         assert_eq!(next(st), ']');\n         return tcx.mk_trait(trait_ref, bounds);\n       }\n@@ -490,15 +442,15 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         let name = token::intern(&parse_str(st, ']'));\n         return tcx.mk_param(space, index, name);\n       }\n-      '~' => return tcx.mk_box(parse_ty_(st, conv)),\n-      '*' => return tcx.mk_ptr(parse_mt_(st, conv)),\n+      '~' => return tcx.mk_box(parse_ty(st)),\n+      '*' => return tcx.mk_ptr(parse_mt(st)),\n       '&' => {\n-        let r = parse_region_(st, conv);\n-        let mt = parse_mt_(st, conv);\n+        let r = parse_region(st);\n+        let mt = parse_mt(st);\n         return tcx.mk_ref(tcx.mk_region(r), mt);\n       }\n       'V' => {\n-        let t = parse_ty_(st, conv);\n+        let t = parse_ty(st);\n         return match parse_size(st) {\n             Some(n) => tcx.mk_array(t, n),\n             None => tcx.mk_slice(t)\n@@ -510,26 +462,31 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n-        while peek(st) != ']' { params.push(parse_ty_(st, conv)); }\n+        while peek(st) != ']' { params.push(parse_ty(st)); }\n         st.pos = st.pos + 1;\n         return tcx.mk_tup(params);\n       }\n       'F' => {\n-          let def_id = parse_def_(st, NominalType, conv);\n-          return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          let def_id = parse_def(st, NominalType);\n+          return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(parse_bare_fn_ty(st)));\n       }\n       'G' => {\n-          return tcx.mk_fn(None, tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          return tcx.mk_fn(None, tcx.mk_bare_fn(parse_bare_fn_ty(st)));\n       }\n       '#' => {\n+        // This is a hacky little caching scheme. The idea is that if we encode\n+        // the same type twice, the second (and third, and fourth...) time we will\n+        // just write `#123`, where `123` is the offset in the metadata of the\n+        // first appearance. Now when we are *decoding*, if we see a `#123`, we\n+        // can first check a cache (`tcx.rcache`) for that offset. If we find something,\n+        // we return it (modulo closure types, see below). But if not, then we\n+        // jump to offset 123 and read the type from there.\n+\n         let pos = parse_hex(st);\n         assert_eq!(next(st), ':');\n         let len = parse_hex(st);\n         assert_eq!(next(st), '#');\n-        let key = ty::CReaderCacheKey {cnum: st.krate,\n-                                         pos: pos,\n-                                         len: len };\n-\n+        let key = ty::CReaderCacheKey {cnum: st.krate, pos: pos, len: len };\n         match tcx.rcache.borrow().get(&key).cloned() {\n           Some(tt) => {\n             // If there is a closure buried in the type some where, then we\n@@ -541,42 +498,47 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n           }\n           None => {}\n         }\n+\n         let mut ps = PState {\n             pos: pos,\n-            .. *st\n+            conv_def_id: st.conv_def_id, // -+ Have to call out these fields specifically,\n+            tcx: st.tcx,                 //  | rather than writing `..*st`, so that we\n+            data: st.data,               //  | trigger reborrow coercions. Suboptimal,\n+            krate: st.krate,             // -+ I suppose.\n         };\n-        let tt = parse_ty_(&mut ps, conv);\n+\n+        let tt = parse_ty(&mut ps);\n         tcx.rcache.borrow_mut().insert(key, tt);\n         return tt;\n       }\n       '\\\"' => {\n-        let _ = parse_def_(st, TypeWithId, conv);\n-        let inner = parse_ty_(st, conv);\n+        let _ = parse_def(st, TypeWithId);\n+        let inner = parse_ty(st);\n         inner\n       }\n       'a' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def_(st, NominalType, conv);\n-          let substs = parse_substs_(st, conv);\n+          let did = parse_def(st, NominalType);\n+          let substs = parse_substs(st);\n           assert_eq!(next(st), ']');\n           let def = st.tcx.lookup_adt_def(did);\n           return st.tcx.mk_struct(def, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def_(st, ClosureSource, conv);\n-          let substs = parse_substs_(st, conv);\n+          let did = parse_def(st, ClosureSource);\n+          let substs = parse_substs(st);\n           let mut tys = vec![];\n           while peek(st) != '.' {\n-              tys.push(parse_ty_(st, conv));\n+              tys.push(parse_ty(st));\n           }\n           assert_eq!(next(st), '.');\n           assert_eq!(next(st), ']');\n           return st.tcx.mk_closure(did, st.tcx.mk_substs(substs), tys);\n       }\n       'P' => {\n           assert_eq!(next(st), '[');\n-          let trait_ref = parse_trait_ref_(st, conv);\n+          let trait_ref = parse_trait_ref(st);\n           let name = token::intern(&parse_str(st, ']'));\n           return tcx.mk_projection(trait_ref, name);\n       }\n@@ -594,17 +556,14 @@ fn parse_mutability(st: &mut PState) -> ast::Mutability {\n     }\n }\n \n-fn parse_mt_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::TypeAndMut<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_mt<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::TypeAndMut<'tcx> {\n     let m = parse_mutability(st);\n-    ty::TypeAndMut { ty: parse_ty_(st, conv), mutbl: m }\n+    ty::TypeAndMut { ty: parse_ty(st), mutbl: m }\n }\n \n-fn parse_def_<F>(st: &mut PState, source: DefIdSource, conv: &mut F) -> ast::DefId where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    return (*conv)(source, scan(st, |c| { c == '|' }, parse_def_id));\n+fn parse_def(st: &mut PState, source: DefIdSource) -> ast::DefId {\n+    let def_id = parse_defid(scan(st, |c| c == '|'));\n+    return (st.conv_def_id)(source, def_id);\n }\n \n fn parse_uint(st: &mut PState) -> usize {\n@@ -652,25 +611,14 @@ fn parse_unsafety(c: char) -> ast::Unsafety {\n \n fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n-    scan(st, |c| c == ']', |bytes| {\n-        let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(&abi_str[..]).expect(abi_str)\n-    })\n+    let bytes = scan(st, |c| c == ']');\n+    let abi_str = str::from_utf8(bytes).unwrap();\n+    abi::lookup(&abi_str[..]).expect(abi_str)\n }\n \n-fn parse_closure_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 mut conv: F) -> ty::ClosureTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_closure_ty_(st, &mut conv)\n-}\n-\n-fn parse_closure_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 conv: &mut F) -> ty::ClosureTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_closure_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::ClosureTy<'tcx> {\n     let unsafety = parse_unsafety(next(st));\n-    let sig = parse_sig_(st, conv);\n+    let sig = parse_sig(st);\n     let abi = parse_abi_set(st);\n     ty::ClosureTy {\n         unsafety: unsafety,\n@@ -679,34 +627,22 @@ fn parse_closure_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n     }\n }\n \n-fn parse_bare_fn_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 mut conv: F) -> ty::BareFnTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_bare_fn_ty_(st, &mut conv)\n-}\n-\n-fn parse_bare_fn_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 conv: &mut F) -> ty::BareFnTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_bare_fn_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::BareFnTy<'tcx> {\n     let unsafety = parse_unsafety(next(st));\n     let abi = parse_abi_set(st);\n-    let sig = parse_sig_(st, conv);\n+    let sig = parse_sig(st);\n     ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n         sig: sig\n     }\n }\n \n-fn parse_sig_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::PolyFnSig<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::PolyFnSig<'tcx> {\n     assert_eq!(next(st), '[');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n-        inputs.push(parse_ty_(st, conv));\n+        inputs.push(parse_ty(st));\n     }\n     st.pos += 1; // eat the ']'\n     let variadic = match next(st) {\n@@ -719,15 +655,15 @@ fn parse_sig_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::PolyF\n           st.pos += 1;\n           ty::FnDiverging\n         }\n-        _ => ty::FnConverging(parse_ty_(st, conv))\n+        _ => ty::FnConverging(parse_ty(st))\n     };\n     ty::Binder(ty::FnSig {inputs: inputs,\n-                        output: output,\n-                        variadic: variadic})\n+                          output: output,\n+                          variadic: variadic})\n }\n \n // Rust metadata parsing\n-pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n+pub fn parse_defid(buf: &[u8]) -> ast::DefId {\n     let mut colon_idx = 0;\n     let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1; }\n@@ -743,14 +679,14 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         s.parse::<usize>().ok()\n     }) {\n        Some(cn) => cn as ast::CrateNum,\n-       None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n+       None => panic!(\"internal error: parse_defid: crate number expected, found {:?}\",\n                      crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n        Some(dn) => dn as ast::NodeId,\n-       None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n+       None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n                      def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }\n@@ -760,90 +696,63 @@ pub fn parse_predicate_data<'tcx, F>(data: &[u8],\n                                      start: usize,\n                                      crate_num: ast::CrateNum,\n                                      tcx: &ty::ctxt<'tcx>,\n-                                     conv: F)\n+                                     mut conv: F)\n                                      -> ty::Predicate<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n-    parse_predicate(&mut st, conv)\n-}\n-\n-pub fn parse_predicate<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                   mut conv: F)\n-                                   -> ty::Predicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_predicate_(st, &mut conv)\n+    let mut st = parse_state_from_data(data, crate_num, start, tcx, &mut conv);\n+    parse_predicate(&mut st)\n }\n \n-fn parse_predicate_<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                conv: &mut F)\n-                                -> ty::Predicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>) -> ty::Predicate<'tcx> {\n     match next(st) {\n-        't' => ty::Binder(parse_trait_ref_(st, conv)).to_predicate(),\n-        'e' => ty::Binder(ty::EquatePredicate(parse_ty_(st, conv),\n-                                              parse_ty_(st, conv))).to_predicate(),\n-        'r' => ty::Binder(ty::OutlivesPredicate(parse_region_(st, conv),\n-                                                parse_region_(st, conv))).to_predicate(),\n-        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty_(st, conv),\n-                                                parse_region_(st, conv))).to_predicate(),\n-        'p' => ty::Binder(parse_projection_predicate_(st, conv)).to_predicate(),\n-        'w' => ty::Predicate::WellFormed(parse_ty_(st, conv)),\n+        't' => ty::Binder(parse_trait_ref(st)).to_predicate(),\n+        'e' => ty::Binder(ty::EquatePredicate(parse_ty(st),\n+                                              parse_ty(st))).to_predicate(),\n+        'r' => ty::Binder(ty::OutlivesPredicate(parse_region(st),\n+                                                parse_region(st))).to_predicate(),\n+        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty(st),\n+                                                parse_region(st))).to_predicate(),\n+        'p' => ty::Binder(parse_projection_predicate(st)).to_predicate(),\n+        'w' => ty::Predicate::WellFormed(parse_ty(st)),\n         'O' => {\n-            let def_id = parse_def_(st, NominalType, conv);\n+            let def_id = parse_def(st, NominalType);\n             assert_eq!(next(st), '|');\n             ty::Predicate::ObjectSafe(def_id)\n         }\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }\n \n-fn parse_projection_predicate_<'a,'tcx, F>(\n-    st: &mut PState<'a, 'tcx>,\n-    conv: &mut F,\n-) -> ty::ProjectionPredicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_projection_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>) -> ty::ProjectionPredicate<'tcx> {\n     ty::ProjectionPredicate {\n         projection_ty: ty::ProjectionTy {\n-            trait_ref: parse_trait_ref_(st, conv),\n+            trait_ref: parse_trait_ref(st),\n             item_name: token::str_to_ident(&parse_str(st, '|')).name,\n         },\n-        ty: parse_ty_(st, conv),\n+        ty: parse_ty(st),\n     }\n }\n \n pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: usize,\n                                           crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n-                                          conv: F) -> ty::TypeParameterDef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n-    parse_type_param_def(&mut st, conv)\n-}\n-\n-fn parse_type_param_def<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n-                                     -> ty::TypeParameterDef<'tcx> where\n+                                          mut conv: F) -> ty::TypeParameterDef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    parse_type_param_def_(st, &mut conv)\n+    let mut st = parse_state_from_data(data, crate_num, start, tcx, &mut conv);\n+    parse_type_param_def(&mut st)\n }\n \n-fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n-                                      -> ty::TypeParameterDef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::TypeParameterDef<'tcx> {\n     let name = parse_name(st, ':');\n-    let def_id = parse_def_(st, NominalType, conv);\n+    let def_id = parse_def(st, NominalType);\n     let space = parse_param_space(st);\n     assert_eq!(next(st), '|');\n     let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n-    let default_def_id = parse_def_(st, NominalType, conv);\n-    let default = parse_opt(st, |st| parse_ty_(st, conv));\n-    let object_lifetime_default = parse_object_lifetime_default(st, conv);\n+    let default_def_id = parse_def(st, NominalType);\n+    let default = parse_opt(st, |st| parse_ty(st));\n+    let object_lifetime_default = parse_object_lifetime_default(st);\n \n     ty::TypeParameterDef {\n         name: name,\n@@ -856,44 +765,27 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n     }\n }\n \n-fn parse_object_lifetime_default<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n-                                             conv: &mut F)\n-                                             -> ty::ObjectLifetimeDefault\n-    where F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_object_lifetime_default<'a,'tcx>(st: &mut PState<'a,'tcx>) -> ty::ObjectLifetimeDefault {\n     match next(st) {\n         'a' => ty::ObjectLifetimeDefault::Ambiguous,\n         'b' => ty::ObjectLifetimeDefault::BaseDefault,\n         's' => {\n-            let region = parse_region_(st, conv);\n+            let region = parse_region(st);\n             ty::ObjectLifetimeDefault::Specific(region)\n         }\n         _ => panic!(\"parse_object_lifetime_default: bad input\")\n     }\n }\n \n-fn parse_existential_bounds<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n-                                        mut conv: F)\n-                                        -> ty::ExistentialBounds<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_existential_bounds_(st, &mut conv)\n-}\n-\n-fn parse_existential_bounds_<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n-                                        conv: &mut F)\n-                                        -> ty::ExistentialBounds<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let builtin_bounds = parse_builtin_bounds_(st, conv);\n-    let region_bound = parse_region_(st, conv);\n+fn parse_existential_bounds<'a,'tcx>(st: &mut PState<'a,'tcx>) -> ty::ExistentialBounds<'tcx> {\n+    let builtin_bounds = parse_builtin_bounds(st);\n+    let region_bound = parse_region(st);\n     let mut projection_bounds = Vec::new();\n \n     loop {\n         match next(st) {\n             'P' => {\n-                projection_bounds.push(\n-                    ty::Binder(parse_projection_predicate_(st, conv)));\n+                projection_bounds.push(ty::Binder(parse_projection_predicate(st)));\n                 }\n             '.' => { break; }\n             c => {\n@@ -907,17 +799,8 @@ fn parse_existential_bounds_<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n                                    projection_bounds: projection_bounds };\n }\n \n-fn parse_builtin_bounds<F>(st: &mut PState, mut _conv: F) -> ty::BuiltinBounds where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_builtin_bounds_(st, &mut _conv)\n-}\n-\n-fn parse_builtin_bounds_<F>(st: &mut PState, _conv: &mut F) -> ty::BuiltinBounds where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n+fn parse_builtin_bounds(st: &mut PState) -> ty::BuiltinBounds {\n     let mut builtin_bounds = ty::BuiltinBounds::empty();\n-\n     loop {\n         match next(st) {\n             'S' => {"}]}