{"sha": "cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOTc0M2I0ZDQ5YmJjOWM4ZDg0ZjQxOWVjZjM3YzkzMDQ3ZDdlYzM=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-18T09:46:38Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-27T19:08:14Z"}, "message": "directly contain `PredicateAtom` in `PredicateKind::ForAll`", "tree": {"sha": "e4a80deb85fa7126696b27b6399907a641f7f943", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4a80deb85fa7126696b27b6399907a641f7f943"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "html_url": "https://github.com/rust-lang/rust/commit/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "html_url": "https://github.com/rust-lang/rust/commit/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906"}], "stats": {"total": 343, "additions": 163, "deletions": 180}, "files": [{"sha": "0dbebac7e36c68578c578b734c08fddf7a6593f5", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -531,11 +531,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             let predicate = match k1.unpack() {\n                 GenericArgKind::Lifetime(r1) => {\n                     ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n-                        .to_predicate(self.tcx)\n                 }\n                 GenericArgKind::Type(t1) => {\n                     ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n-                        .to_predicate(self.tcx)\n                 }\n                 GenericArgKind::Const(..) => {\n                     // Consts cannot outlive one another, so we don't expect to"}, {"sha": "27f50c240db67e61233673ff82d45584b0cbe9e3", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -201,55 +201,54 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_predicate(&mut self, pred: ty::Predicate<'_>) {\n-        self.add_flags(pred.inner.flags);\n-        self.add_exclusive_binder(pred.inner.outer_exclusive_binder);\n-    }\n-\n     fn add_predicate_kind(&mut self, kind: &ty::PredicateKind<'_>) {\n         match kind {\n             ty::PredicateKind::ForAll(binder) => {\n                 let mut computation = FlagComputation::new();\n \n-                computation.add_predicate(binder.skip_binder());\n+                computation.add_predicate_atom(binder.skip_binder());\n \n                 self.add_bound_computation(computation);\n             }\n-            &ty::PredicateKind::Atom(atom) => match atom {\n-                ty::PredicateAtom::Trait(trait_pred, _constness) => {\n-                    self.add_substs(trait_pred.trait_ref.substs);\n-                }\n-                ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    self.add_region(a);\n-                    self.add_region(b);\n-                }\n-                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n-                    self.add_ty(ty);\n-                    self.add_region(region);\n-                }\n-                ty::PredicateAtom::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n-                    self.add_ty(a);\n-                    self.add_ty(b);\n-                }\n-                ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n-                    self.add_projection_ty(projection_ty);\n-                    self.add_ty(ty);\n-                }\n-                ty::PredicateAtom::WellFormed(arg) => {\n-                    self.add_substs(slice::from_ref(&arg));\n-                }\n-                ty::PredicateAtom::ObjectSafe(_def_id) => {}\n-                ty::PredicateAtom::ClosureKind(_def_id, substs, _kind) => {\n-                    self.add_substs(substs);\n-                }\n-                ty::PredicateAtom::ConstEvaluatable(_def_id, substs) => {\n-                    self.add_substs(substs);\n-                }\n-                ty::PredicateAtom::ConstEquate(expected, found) => {\n-                    self.add_const(expected);\n-                    self.add_const(found);\n-                }\n-            },\n+            &ty::PredicateKind::Atom(atom) => self.add_predicate_atom(atom),\n+        }\n+    }\n+\n+    fn add_predicate_atom(&mut self, atom: ty::PredicateAtom<'_>) {\n+        match atom {\n+            ty::PredicateAtom::Trait(trait_pred, _constness) => {\n+                self.add_substs(trait_pred.trait_ref.substs);\n+            }\n+            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                self.add_region(a);\n+                self.add_region(b);\n+            }\n+            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n+                self.add_ty(ty);\n+                self.add_region(region);\n+            }\n+            ty::PredicateAtom::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n+                self.add_ty(a);\n+                self.add_ty(b);\n+            }\n+            ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+                self.add_projection_ty(projection_ty);\n+                self.add_ty(ty);\n+            }\n+            ty::PredicateAtom::WellFormed(arg) => {\n+                self.add_substs(slice::from_ref(&arg));\n+            }\n+            ty::PredicateAtom::ObjectSafe(_def_id) => {}\n+            ty::PredicateAtom::ClosureKind(_def_id, substs, _kind) => {\n+                self.add_substs(substs);\n+            }\n+            ty::PredicateAtom::ConstEvaluatable(_def_id, substs) => {\n+                self.add_substs(substs);\n+            }\n+            ty::PredicateAtom::ConstEquate(expected, found) => {\n+                self.add_const(expected);\n+                self.add_const(found);\n+            }\n         }\n     }\n "}, {"sha": "15210c5b21bc23c3345dc847952f971bc095cb54", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -1053,8 +1053,9 @@ impl<'tcx> Predicate<'tcx> {\n     ///\n     /// Note that this method panics in case this predicate has unbound variables.\n     pub fn skip_binders(self) -> PredicateAtom<'tcx> {\n+        // TODO no_escaping_vars\n         match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder.skip_binder().skip_binders(),\n+            &PredicateKind::ForAll(binder) => binder.skip_binder(),\n             &ty::PredicateKind::Atom(atom) => atom,\n         }\n     }\n@@ -1066,33 +1067,17 @@ impl<'tcx> Predicate<'tcx> {\n     /// to end up at the wrong binding level.\n     pub fn skip_binders_unchecked(self) -> PredicateAtom<'tcx> {\n         match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder.skip_binder().skip_binders(),\n+            &PredicateKind::ForAll(binder) => binder.skip_binder(),\n             &ty::PredicateKind::Atom(atom) => atom,\n         }\n     }\n \n     pub fn bound_atom(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n         match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder.map_bound(|inner| match inner.kind() {\n-                ty::PredicateKind::ForAll(_) => bug!(\"unexpect forall\"),\n-                &ty::PredicateKind::Atom(atom) => atom,\n-            }),\n+            &PredicateKind::ForAll(binder) => binder,\n             &ty::PredicateKind::Atom(atom) => Binder::wrap_nonbinding(tcx, atom),\n         }\n     }\n-\n-    /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n-    pub fn potentially_quantified(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        qualifier: impl FnOnce(Binder<Predicate<'tcx>>) -> PredicateKind<'tcx>,\n-    ) -> Predicate<'tcx> {\n-        if self.has_escaping_bound_vars() {\n-            qualifier(Binder::bind(self)).to_predicate(tcx)\n-        } else {\n-            self\n-        }\n-    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n@@ -1114,7 +1099,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateKind<'tcx> {\n     /// `for<'a>: ...`\n-    ForAll(Binder<Predicate<'tcx>>),\n+    ForAll(Binder<PredicateAtom<'tcx>>),\n \n     Atom(PredicateAtom<'tcx>),\n }\n@@ -1162,6 +1147,22 @@ pub enum PredicateAtom<'tcx> {\n     ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n }\n \n+impl<'tcx> PredicateAtom<'tcx> {\n+    /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n+    pub fn potentially_quantified(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        qualifier: impl FnOnce(Binder<PredicateAtom<'tcx>>) -> PredicateKind<'tcx>,\n+    ) -> Predicate<'tcx> {\n+        if self.has_escaping_bound_vars() {\n+            qualifier(Binder::bind(self))\n+        } else {\n+            PredicateKind::Atom(self)\n+        }\n+        .to_predicate(tcx)\n+    }\n+}\n+\n /// The crate outlives map is computed during typeck and contains the\n /// outlives of every item in the local crate. You should not use it\n /// directly, because to do so will make your pass dependent on the\n@@ -1249,11 +1250,7 @@ impl<'tcx> Predicate<'tcx> {\n         let substs = trait_ref.skip_binder().substs;\n         let pred = self.skip_binders();\n         let new = pred.subst(tcx, substs);\n-        if new != pred {\n-            new.to_predicate(tcx).potentially_quantified(tcx, PredicateKind::ForAll)\n-        } else {\n-            self\n-        }\n+        if new != pred { new.potentially_quantified(tcx, PredicateKind::ForAll) } else { self }\n     }\n }\n \n@@ -1381,6 +1378,7 @@ impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n impl ToPredicate<'tcx> for PredicateAtom<'tcx> {\n     #[inline(always)]\n     fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        debug_assert!(!self.has_escaping_bound_vars(), \"excaping bound vars for {:?}\", self);\n         tcx.mk_predicate(ty::PredicateKind::Atom(*self))\n     }\n }\n@@ -1408,9 +1406,7 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n             ty::PredicateAtom::Trait(pred, self.constness).to_predicate(tcx)\n         } else {\n             ty::PredicateKind::ForAll(\n-                self.value.map_bound(|pred| {\n-                    ty::PredicateAtom::Trait(pred, self.constness).to_predicate(tcx)\n-                }),\n+                self.value.map_bound(|pred| ty::PredicateAtom::Trait(pred, self.constness)),\n             )\n             .to_predicate(tcx)\n         }\n@@ -1423,9 +1419,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n             PredicateAtom::RegionOutlives(outlives).to_predicate(tcx)\n         } else {\n             ty::PredicateKind::ForAll(\n-                self.map_bound(|outlives| {\n-                    PredicateAtom::RegionOutlives(outlives).to_predicate(tcx)\n-                }),\n+                self.map_bound(|outlives| PredicateAtom::RegionOutlives(outlives)),\n             )\n             .to_predicate(tcx)\n         }\n@@ -1438,7 +1432,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n             PredicateAtom::TypeOutlives(outlives).to_predicate(tcx)\n         } else {\n             ty::PredicateKind::ForAll(\n-                self.map_bound(|outlives| PredicateAtom::TypeOutlives(outlives).to_predicate(tcx)),\n+                self.map_bound(|outlives| PredicateAtom::TypeOutlives(outlives)),\n             )\n             .to_predicate(tcx)\n         }\n@@ -1450,10 +1444,8 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n         if let Some(proj) = self.no_bound_vars() {\n             PredicateAtom::Projection(proj).to_predicate(tcx)\n         } else {\n-            ty::PredicateKind::ForAll(\n-                self.map_bound(|proj| PredicateAtom::Projection(proj).to_predicate(tcx)),\n-            )\n-            .to_predicate(tcx)\n+            ty::PredicateKind::ForAll(self.map_bound(|proj| PredicateAtom::Projection(proj)))\n+                .to_predicate(tcx)\n         }\n     }\n }"}, {"sha": "3bb9c20370e8c9e1e7d0eb87276088cfe1ce5fdd", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -2013,43 +2013,45 @@ define_print_and_forward_display! {\n \n     ty::Predicate<'tcx> {\n         match self.kind() {\n-            &ty::PredicateKind::Atom(atom) => match atom {\n-                ty::PredicateAtom::Trait(ref data, constness) => {\n-                    if let hir::Constness::Const = constness {\n-                        p!(write(\"const \"));\n-                    }\n-                    p!(print(data))\n-                }\n-                ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n-                ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n-                ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n-                ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n-                ty::PredicateAtom::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n-                ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n-                    p!(write(\"the trait `\"),\n-                    print_def_path(trait_def_id, &[]),\n-                    write(\"` is object-safe\"))\n-                }\n-                ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                    p!(write(\"the closure `\"),\n-                    print_value_path(closure_def_id, &[]),\n-                    write(\"` implements the trait `{}`\", kind))\n-                }\n-                ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n-                    p!(write(\"the constant `\"),\n-                    print_value_path(def.did, substs),\n-                    write(\"` can be evaluated\"))\n-                }\n-                ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                    p!(write(\"the constant `\"),\n-                    print(c1),\n-                    write(\"` equals `\"),\n-                    print(c2),\n-                    write(\"`\"))\n+            &ty::PredicateKind::Atom(atom) => p!(print(atom)),\n+            ty::PredicateKind::ForAll(binder) => p!(print(binder)),\n+        }\n+    }\n+\n+    ty::PredicateAtom<'tcx> {\n+        match *self {\n+            ty::PredicateAtom::Trait(ref data, constness) => {\n+                if let hir::Constness::Const = constness {\n+                    p!(write(\"const \"));\n                 }\n-            }\n-            ty::PredicateKind::ForAll(binder) => {\n-                p!(print(binder))\n+                p!(print(data))\n+            }\n+            ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                p!(write(\"the trait `\"),\n+                print_def_path(trait_def_id, &[]),\n+                write(\"` is object-safe\"))\n+            }\n+            ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+                p!(write(\"the closure `\"),\n+                print_value_path(closure_def_id, &[]),\n+                write(\"` implements the trait `{}`\", kind))\n+            }\n+            ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n+                p!(write(\"the constant `\"),\n+                print_value_path(def.did, substs),\n+                write(\"` can be evaluated\"))\n+            }\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                p!(write(\"the constant `\"),\n+                print(c1),\n+                write(\"` equals `\"),\n+                print(c2),\n+                write(\"`\"))\n             }\n         }\n     }"}, {"sha": "c73ed986317c9a7ea551d0c3782ea1b0963ecfd5", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::ErrorReported;\n use rustc_infer::traits::{PolyTraitObligation, TraitEngine, TraitEngineExt as _};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{self, Binder, Const, Ty, TypeFoldable};\n use std::marker::PhantomData;\n "}, {"sha": "d225b10834a6b33e3744690733743c5cc385c78f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -93,45 +93,40 @@ pub fn predicate_obligations<'a, 'tcx>(\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n \n-    match predicate.kind() {\n-        ty::PredicateKind::ForAll(binder) => {\n-            // It's ok to skip the binder here because wf code is prepared for it\n-            return predicate_obligations(infcx, param_env, body_id, binder.skip_binder(), span);\n+    // It's ok to skip the binder here because wf code is prepared for it\n+    match predicate.skip_binders() {\n+        ty::PredicateAtom::Trait(t, _) => {\n+            wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n         }\n-        &ty::PredicateKind::Atom(atom) => match atom {\n-            ty::PredicateAtom::Trait(t, _) => {\n-                wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n-            }\n-            ty::PredicateAtom::RegionOutlives(..) => {}\n-            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n-                wf.compute(ty.into());\n-            }\n-            ty::PredicateAtom::Projection(t) => {\n-                wf.compute_projection(t.projection_ty);\n-                wf.compute(t.ty.into());\n-            }\n-            ty::PredicateAtom::WellFormed(arg) => {\n-                wf.compute(arg);\n-            }\n-            ty::PredicateAtom::ObjectSafe(_) => {}\n-            ty::PredicateAtom::ClosureKind(..) => {}\n-            ty::PredicateAtom::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n-                wf.compute(a.into());\n-                wf.compute(b.into());\n-            }\n-            ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n-                let obligations = wf.nominal_obligations(def.did, substs);\n-                wf.out.extend(obligations);\n+        ty::PredicateAtom::RegionOutlives(..) => {}\n+        ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+            wf.compute(ty.into());\n+        }\n+        ty::PredicateAtom::Projection(t) => {\n+            wf.compute_projection(t.projection_ty);\n+            wf.compute(t.ty.into());\n+        }\n+        ty::PredicateAtom::WellFormed(arg) => {\n+            wf.compute(arg);\n+        }\n+        ty::PredicateAtom::ObjectSafe(_) => {}\n+        ty::PredicateAtom::ClosureKind(..) => {}\n+        ty::PredicateAtom::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n+            wf.compute(a.into());\n+            wf.compute(b.into());\n+        }\n+        ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n+            let obligations = wf.nominal_obligations(def.did, substs);\n+            wf.out.extend(obligations);\n \n-                for arg in substs.iter() {\n-                    wf.compute(arg);\n-                }\n-            }\n-            ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                wf.compute(c1.into());\n-                wf.compute(c2.into());\n+            for arg in substs.iter() {\n+                wf.compute(arg);\n             }\n-        },\n+        }\n+        ty::PredicateAtom::ConstEquate(c1, c2) => {\n+            wf.compute(c1.into());\n+            wf.compute(c2.into());\n+        }\n     }\n \n     wf.normalize()"}, {"sha": "106df847a05cff8ed93e835827a5c11a61fb5ec0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -798,24 +798,28 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n-        let bounds = self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(|predicate| match predicate\n-        {\n-            ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                match trait_predicate.trait_ref.self_ty().kind {\n-                    ty::Param(ref p) if *p == param_ty => Some(ty::Binder::bind(trait_predicate.trait_ref)),\n-                    _ => None,\n-                }\n-            }\n-            ty::PredicateAtom::Subtype(..)\n-            | ty::PredicateAtom::Projection(..)\n-            | ty::PredicateAtom::RegionOutlives(..)\n-            | ty::PredicateAtom::WellFormed(..)\n-            | ty::PredicateAtom::ObjectSafe(..)\n-            | ty::PredicateAtom::ClosureKind(..)\n-            | ty::PredicateAtom::TypeOutlives(..)\n-            | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..) => None,\n-        });\n+        let bounds =\n+            self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(\n+                |predicate| match predicate {\n+                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                        match trait_predicate.trait_ref.self_ty().kind {\n+                            ty::Param(ref p) if *p == param_ty => {\n+                                Some(ty::Binder::bind(trait_predicate.trait_ref))\n+                            }\n+                            _ => None,\n+                        }\n+                    }\n+                    ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::Projection(..)\n+                    | ty::PredicateAtom::RegionOutlives(..)\n+                    | ty::PredicateAtom::WellFormed(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::TypeOutlives(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => None,\n+                },\n+            );\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);"}, {"sha": "6cefc99f7b1718a46a94158022c66a60e95fac7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -2939,9 +2939,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             predicates: tcx.arena.alloc_from_iter(\n                 self.param_env.caller_bounds().iter().filter_map(|predicate| {\n                     match predicate.skip_binders() {\n-                        ty::PredicateAtom::Trait(data, _)\n-                            if data.self_ty().is_param(index) =>\n-                        {\n+                        ty::PredicateAtom::Trait(data, _) if data.self_ty().is_param(index) => {\n                             // HACK(eddyb) should get the original `Span`.\n                             let span = tcx.def_span(def_id);\n                             Some((predicate, span))\n@@ -5373,7 +5371,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     projection_ty,\n                     ty: expected,\n                 })\n-                .to_predicate(self.tcx)\n                 .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n "}, {"sha": "a733ad4fccdc6b114cf57355ffe541d04ad12476", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -1961,7 +1961,6 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             predicates.push((\n                                 ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region))\n-                                    .to_predicate(tcx)\n                                     .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                                 lifetime.span,\n                             ))\n@@ -1979,8 +1978,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n-                        .to_predicate(icx.tcx);\n+                    let pred = ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2));\n \n                     (pred.potentially_quantified(icx.tcx, ty::PredicateKind::ForAll), span)\n                 }))\n@@ -2111,7 +2109,6 @@ fn predicates_from_bound<'tcx>(\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n-                .to_predicate(astconv.tcx())\n                 .potentially_quantified(astconv.tcx(), ty::PredicateKind::ForAll);\n             vec![(pred, lifetime.span)]\n         }"}, {"sha": "5dc7ac9fa0d4e9a9b4e6339ecb8adaed9fc2859d", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=cd9743b4d49bbc9c8d84f419ecf37c93047d7ec3", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, CratePredicatesMap, ToPredicate, TyCtxt};\n+use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -90,15 +90,13 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n                             ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n-                                .to_predicate(tcx)\n                                 .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n                             ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n                                 region1, region2,\n                             ))\n-                            .to_predicate(tcx)\n                             .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         )),"}]}