{"sha": "7c46c6c59dbee8d6385f8924fe27cc5a7893841f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNDZjNmM1OWRiZWU4ZDYzODVmODkyNGZlMjdjYzVhNzg5Mzg0MWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-25T00:48:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-25T00:48:14Z"}, "message": "Auto merge of #43248 - llogiq:num-try-from, r=nagisa\n\nimprove the TryFrom implementations\n\nThis removes the need for a 128 bit storage by making use of the fact that there can be either no over/underflow, either one or both, and each time the target type suffices to hold the limit for comparison. This also means that the implementation will work in targets without 128bit support (unless it's for 128bit types, of course).\n\nThe downside is that the code looks a bit more complex.", "tree": {"sha": "0c4c008bb35ab5747b97f982471456378d81957d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c4c008bb35ab5747b97f982471456378d81957d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c46c6c59dbee8d6385f8924fe27cc5a7893841f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c46c6c59dbee8d6385f8924fe27cc5a7893841f", "html_url": "https://github.com/rust-lang/rust/commit/7c46c6c59dbee8d6385f8924fe27cc5a7893841f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c46c6c59dbee8d6385f8924fe27cc5a7893841f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "598eddf4f785df12e79fba5a996f153dc6fdb7e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/598eddf4f785df12e79fba5a996f153dc6fdb7e0", "html_url": "https://github.com/rust-lang/rust/commit/598eddf4f785df12e79fba5a996f153dc6fdb7e0"}, {"sha": "72ef15e0df7cc1a794d79559a3da79321eec7bfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ef15e0df7cc1a794d79559a3da79321eec7bfb", "html_url": "https://github.com/rust-lang/rust/commit/72ef15e0df7cc1a794d79559a3da79321eec7bfb"}], "stats": {"total": 429, "additions": 391, "deletions": 38}, "files": [{"sha": "0ebac027c39acd1046cbf4abf58251e6bedef3ae", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 177, "deletions": 38, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/7c46c6c59dbee8d6385f8924fe27cc5a7893841f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c46c6c59dbee8d6385f8924fe27cc5a7893841f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=7c46c6c59dbee8d6385f8924fe27cc5a7893841f", "patch": "@@ -2504,76 +2504,209 @@ impl fmt::Display for TryFromIntError {\n     }\n }\n \n-macro_rules! same_sign_try_from_int_impl {\n-    ($storage:ty, $target:ty, $($source:ty),*) => {$(\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($source:ty, $($target:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n+            #[inline]\n             fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                let min = <$target as FromStrRadixHelper>::min_value() as $storage;\n-                let max = <$target as FromStrRadixHelper>::max_value() as $storage;\n-                if u as $storage < min || u as $storage > max {\n-                    Err(TryFromIntError(()))\n-                } else {\n+                Ok(u as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// only negative bounds\n+macro_rules! try_from_lower_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u >= 0 {\n                     Ok(u as $target)\n+                } else {\n+                    Err(TryFromIntError(()))\n                 }\n             }\n         }\n     )*}\n }\n \n-same_sign_try_from_int_impl!(u128, u8, u8, u16, u32, u64, u128, usize);\n-same_sign_try_from_int_impl!(i128, i8, i8, i16, i32, i64, i128, isize);\n-same_sign_try_from_int_impl!(u128, u16, u8, u16, u32, u64, u128, usize);\n-same_sign_try_from_int_impl!(i128, i16, i8, i16, i32, i64, i128, isize);\n-same_sign_try_from_int_impl!(u128, u32, u8, u16, u32, u64, u128, usize);\n-same_sign_try_from_int_impl!(i128, i32, i8, i16, i32, i64, i128, isize);\n-same_sign_try_from_int_impl!(u128, u64, u8, u16, u32, u64, u128, usize);\n-same_sign_try_from_int_impl!(i128, i64, i8, i16, i32, i64, i128, isize);\n-same_sign_try_from_int_impl!(u128, u128, u8, u16, u32, u64, u128, usize);\n-same_sign_try_from_int_impl!(i128, i128, i8, i16, i32, i64, i128, isize);\n-same_sign_try_from_int_impl!(u128, usize, u8, u16, u32, u64, u128, usize);\n-same_sign_try_from_int_impl!(i128, isize, i8, i16, i32, i64, i128, isize);\n-\n-macro_rules! cross_sign_from_int_impl {\n-    ($unsigned:ty, $($signed:ty),*) => {$(\n+// unsigned to signed (only positive bound)\n+macro_rules! try_from_upper_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n-        impl TryFrom<$unsigned> for $signed {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n-            fn try_from(u: $unsigned) -> Result<$signed, TryFromIntError> {\n-                let max = <$signed as FromStrRadixHelper>::max_value() as u128;\n-                if u as u128 > max {\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u > (<$target>::max_value() as $source) {\n                     Err(TryFromIntError(()))\n                 } else {\n-                    Ok(u as $signed)\n+                    Ok(u as $target)\n                 }\n             }\n         }\n+    )*}\n+}\n \n+// all other cases\n+macro_rules! try_from_both_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n-        impl TryFrom<$signed> for $unsigned {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n-            fn try_from(u: $signed) -> Result<$unsigned, TryFromIntError> {\n-                let max = <$unsigned as FromStrRadixHelper>::max_value() as u128;\n-                if u < 0 || u as u128 > max {\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target>::min_value() as $source;\n+                let max = <$target>::max_value() as $source;\n+                if u < min || u > max {\n                     Err(TryFromIntError(()))\n                 } else {\n-                    Ok(u as $unsigned)\n+                    Ok(u as $target)\n                 }\n             }\n         }\n     )*}\n }\n \n-cross_sign_from_int_impl!(u8, i8, i16, i32, i64, i128, isize);\n-cross_sign_from_int_impl!(u16, i8, i16, i32, i64, i128, isize);\n-cross_sign_from_int_impl!(u32, i8, i16, i32, i64, i128, isize);\n-cross_sign_from_int_impl!(u64, i8, i16, i32, i64, i128, isize);\n-cross_sign_from_int_impl!(u128, i8, i16, i32, i64, i128, isize);\n-cross_sign_from_int_impl!(usize, i8, i16, i32, i64, i128, isize);\n+macro_rules! rev {\n+    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n+        $mac!($target, $source);\n+    )*}\n+}\n+\n+/// intra-sign conversions\n+try_from_unbounded!(u8, u8, u16, u32, u64, u128);\n+try_from_unbounded!(u16, u16, u32, u64, u128);\n+try_from_unbounded!(u32, u32, u64, u128);\n+try_from_unbounded!(u64, u64, u128);\n+try_from_unbounded!(u128, u128);\n+try_from_upper_bounded!(u16, u8);\n+try_from_upper_bounded!(u32, u16, u8);\n+try_from_upper_bounded!(u64, u32, u16, u8);\n+try_from_upper_bounded!(u128, u64, u32, u16, u8);\n+\n+try_from_unbounded!(i8, i8, i16, i32, i64, i128);\n+try_from_unbounded!(i16, i16, i32, i64, i128);\n+try_from_unbounded!(i32, i32, i64, i128);\n+try_from_unbounded!(i64, i64, i128);\n+try_from_unbounded!(i128, i128);\n+try_from_both_bounded!(i16, i8);\n+try_from_both_bounded!(i32, i16, i8);\n+try_from_both_bounded!(i64, i32, i16, i8);\n+try_from_both_bounded!(i128, i64, i32, i16, i8);\n+\n+// unsigned-to-signed\n+try_from_unbounded!(u8, i16, i32, i64, i128);\n+try_from_unbounded!(u16, i32, i64, i128);\n+try_from_unbounded!(u32, i64, i128);\n+try_from_unbounded!(u64, i128);\n+try_from_upper_bounded!(u8, i8);\n+try_from_upper_bounded!(u16, i8, i16);\n+try_from_upper_bounded!(u32, i8, i16, i32);\n+try_from_upper_bounded!(u64, i8, i16, i32, i64);\n+try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n+\n+// signed-to-unsigned\n+try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n+try_from_lower_bounded!(i16, u16, u32, u64, u128);\n+try_from_lower_bounded!(i32, u32, u64, u128);\n+try_from_lower_bounded!(i64, u64, u128);\n+try_from_lower_bounded!(i128, u128);\n+try_from_both_bounded!(i16, u8);\n+try_from_both_bounded!(i32, u16, u8);\n+try_from_both_bounded!(i64, u32, u16, u8);\n+try_from_both_bounded!(i128, u64, u32, u16, u8);\n+\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+pub use self::ptr_try_from_impls::*;\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8);\n+    try_from_unbounded!(usize, usize, u16, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, isize);\n+    try_from_unbounded!(usize, i32, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8);\n+    try_from_lower_bounded!(isize, usize, u16, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8);\n+    try_from_unbounded!(isize, i16, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u8, u16);\n+    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16);\n+    rev!(try_from_both_bounded, usize, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, isize, u8);\n+    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n+    rev!(try_from_unbounded, isize, i8, i16);\n+    rev!(try_from_both_bounded, isize, i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16);\n+    try_from_unbounded!(usize, usize, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, isize);\n+    try_from_unbounded!(usize, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16);\n+    try_from_lower_bounded!(isize, usize, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16);\n+    try_from_unbounded!(isize, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u8, u16, u32);\n+    rev!(try_from_upper_bounded, usize, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n+    rev!(try_from_both_bounded, usize, i64, i128);\n+\n+    rev!(try_from_unbounded, isize, u8, u16);\n+    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n+    rev!(try_from_unbounded, isize, i8, i16, i32);\n+    rev!(try_from_both_bounded, isize, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16, u32);\n+    try_from_unbounded!(usize, usize, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, i64, isize);\n+    try_from_unbounded!(usize, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16, u32);\n+    try_from_lower_bounded!(isize, usize, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16, i32);\n+    try_from_unbounded!(isize, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u8, u16, u32, u64);\n+    rev!(try_from_upper_bounded, usize, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n+    rev!(try_from_both_bounded, usize, i128);\n+\n+    rev!(try_from_unbounded, isize, u8, u16, u32);\n+    rev!(try_from_upper_bounded, isize, u64, u128);\n+    rev!(try_from_unbounded, isize, i8, i16, i32, i64);\n+    rev!(try_from_both_bounded, isize, i128);\n+}\n \n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n@@ -2587,15 +2720,21 @@ trait FromStrRadixHelper: PartialOrd + Copy {\n \n macro_rules! doit {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n+        #[inline]\n         fn min_value() -> Self { Self::min_value() }\n+        #[inline]\n         fn max_value() -> Self { Self::max_value() }\n+        #[inline]\n         fn from_u32(u: u32) -> Self { u as Self }\n+        #[inline]\n         fn checked_mul(&self, other: u32) -> Option<Self> {\n             Self::checked_mul(*self, other as Self)\n         }\n+        #[inline]\n         fn checked_sub(&self, other: u32) -> Option<Self> {\n             Self::checked_sub(*self, other as Self)\n         }\n+        #[inline]\n         fn checked_add(&self, other: u32) -> Option<Self> {\n             Self::checked_add(*self, other as Self)\n         }"}, {"sha": "3e872b34e433dfd18b3b9465ff50839db53b2507", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/7c46c6c59dbee8d6385f8924fe27cc5a7893841f/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c46c6c59dbee8d6385f8924fe27cc5a7893841f/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=7c46c6c59dbee8d6385f8924fe27cc5a7893841f", "patch": "@@ -36,6 +36,26 @@ mod flt2dec;\n mod dec2flt;\n mod bignum;\n \n+\n+/// Adds the attribute to all items in the block.\n+macro_rules! cfg_block {\n+    ($(#[$attr:meta]{$($it:item)*})*) => {$($(\n+        #[$attr]\n+        $it\n+    )*)*}\n+}\n+\n+/// Groups items that assume the pointer width is either 16/32/64, and has to be altered if\n+/// support for larger/smaller pointer widths are added in the future.\n+macro_rules! assume_usize_width {\n+    {$($it:item)*} => {#[cfg(not(any(\n+        target_pointer_width = \"16\", target_pointer_width = \"32\", target_pointer_width = \"64\")))]\n+           compile_error!(\"The current tests of try_from on usize/isize assume that \\\n+                           the pointer width is either 16, 32, or 64\");\n+                    $($it)*\n+    }\n+}\n+\n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq\n@@ -212,6 +232,8 @@ fn test_f32f64() {\n     assert!(nan.is_nan());\n }\n \n+\n+/// Conversions where the full width of $source can be represented as $target\n macro_rules! test_impl_try_from_always_ok {\n     ($fn_name:ident, $source:ty, $target: ty) => {\n         #[test]\n@@ -233,36 +255,89 @@ test_impl_try_from_always_ok! { test_try_u8u8, u8, u8 }\n test_impl_try_from_always_ok! { test_try_u8u16, u8, u16 }\n test_impl_try_from_always_ok! { test_try_u8u32, u8, u32 }\n test_impl_try_from_always_ok! { test_try_u8u64, u8, u64 }\n+test_impl_try_from_always_ok! { test_try_u8u128, u8, u128 }\n test_impl_try_from_always_ok! { test_try_u8i16, u8, i16 }\n test_impl_try_from_always_ok! { test_try_u8i32, u8, i32 }\n test_impl_try_from_always_ok! { test_try_u8i64, u8, i64 }\n+test_impl_try_from_always_ok! { test_try_u8i128, u8, i128 }\n \n test_impl_try_from_always_ok! { test_try_u16u16, u16, u16 }\n test_impl_try_from_always_ok! { test_try_u16u32, u16, u32 }\n test_impl_try_from_always_ok! { test_try_u16u64, u16, u64 }\n+test_impl_try_from_always_ok! { test_try_u16u128, u16, u128 }\n test_impl_try_from_always_ok! { test_try_u16i32, u16, i32 }\n test_impl_try_from_always_ok! { test_try_u16i64, u16, i64 }\n+test_impl_try_from_always_ok! { test_try_u16i128, u16, i128 }\n \n test_impl_try_from_always_ok! { test_try_u32u32, u32, u32 }\n test_impl_try_from_always_ok! { test_try_u32u64, u32, u64 }\n+test_impl_try_from_always_ok! { test_try_u32u128, u32, u128 }\n test_impl_try_from_always_ok! { test_try_u32i64, u32, i64 }\n+test_impl_try_from_always_ok! { test_try_u32i128, u32, i128 }\n \n test_impl_try_from_always_ok! { test_try_u64u64, u64, u64 }\n+test_impl_try_from_always_ok! { test_try_u64u128, u64, u128 }\n+test_impl_try_from_always_ok! { test_try_u64i128, u64, i128 }\n+\n+test_impl_try_from_always_ok! { test_try_u128, u128, u128 }\n \n test_impl_try_from_always_ok! { test_try_i8i8, i8, i8 }\n test_impl_try_from_always_ok! { test_try_i8i16, i8, i16 }\n test_impl_try_from_always_ok! { test_try_i8i32, i8, i32 }\n test_impl_try_from_always_ok! { test_try_i8i64, i8, i64 }\n+test_impl_try_from_always_ok! { test_try_i8i128, i8, i128 }\n \n test_impl_try_from_always_ok! { test_try_i16i16, i16, i16 }\n test_impl_try_from_always_ok! { test_try_i16i32, i16, i32 }\n test_impl_try_from_always_ok! { test_try_i16i64, i16, i64 }\n+test_impl_try_from_always_ok! { test_try_i16i128, i16, i128 }\n \n test_impl_try_from_always_ok! { test_try_i32i32, i32, i32 }\n test_impl_try_from_always_ok! { test_try_i32i64, i32, i64 }\n+test_impl_try_from_always_ok! { test_try_i32i128, i32, i128 }\n \n test_impl_try_from_always_ok! { test_try_i64i64, i64, i64 }\n+test_impl_try_from_always_ok! { test_try_i64i128, i64, i128 }\n+\n+test_impl_try_from_always_ok! { test_try_i128i128, i128, i128 }\n+\n+assume_usize_width! {\n+    test_impl_try_from_always_ok! { test_try_u8usize, u8, usize }\n+    test_impl_try_from_always_ok! { test_try_i8isize, i8, isize }\n+\n+    test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n+    test_impl_try_from_always_ok! { test_try_i16isize, i16, isize }\n+\n+    test_impl_try_from_always_ok! { test_try_usizeu64, usize, u64 }\n+    test_impl_try_from_always_ok! { test_try_usizeu128, usize, u128 }\n+    test_impl_try_from_always_ok! { test_try_usizei128, usize, i128 }\n+\n+    test_impl_try_from_always_ok! { test_try_isizei64, isize, i64 }\n+    test_impl_try_from_always_ok! { test_try_isizei128, isize, i128 }\n+\n+    cfg_block!(\n+        #[cfg(target_pointer_width = \"16\")] {\n+            test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n+            test_impl_try_from_always_ok! { test_try_i16isize, i16, isize }\n+        }\n+\n+        #[cfg(target_pointer_width = \"32\")] {\n+            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n+            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n+            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n+            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n+        }\n+\n+        #[cfg(target_pointer_width = \"64\")] {\n+            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n+            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n+            test_impl_try_from_always_ok! { test_try_u64usize, u64, usize }\n+            test_impl_try_from_always_ok! { test_try_i64isize, i64, isize }\n+        }\n+    );\n+}\n \n+/// Conversions where max of $source can be represented as $target,\n macro_rules! test_impl_try_from_signed_to_unsigned_upper_ok {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n@@ -285,16 +360,51 @@ test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u8, i8, u8 }\n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u16, i8, u16 }\n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u32, i8, u32 }\n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u64, i8, u64 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u128, i8, u128 }\n \n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u16, i16, u16 }\n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u32, i16, u32 }\n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u64, i16, u64 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u128, i16, u128 }\n \n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u32, i32, u32 }\n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u64, i32, u64 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u128, i32, u128 }\n \n test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64u64, i64, u64 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64u128, i64, u128 }\n+\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i128u128, i128, u128 }\n+\n+assume_usize_width! {\n+    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8usize, i8, usize }\n+    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16usize, i16, usize }\n+\n+    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu64, isize, u64 }\n+    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu128, isize, u128 }\n+    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeusize, isize, usize }\n+\n+    cfg_block!(\n+        #[cfg(target_pointer_width = \"16\")] {\n+            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu16, isize, u16 }\n+            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n+        }\n+\n+        #[cfg(target_pointer_width = \"32\")] {\n+            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n+\n+            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n+        }\n \n+        #[cfg(target_pointer_width = \"64\")] {\n+            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n+            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64usize, i64, usize }\n+        }\n+    );\n+}\n+\n+/// Conversions where max of $source can not be represented as $target,\n+/// but min can.\n macro_rules! test_impl_try_from_unsigned_to_signed_upper_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n@@ -325,6 +435,39 @@ test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i16, u64, i16 }\n test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i32, u64, i32 }\n test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i64, u64, i64 }\n \n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i8, u128, i8 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i16, u128, i16 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i32, u128, i32 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i64, u128, i64 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i128, u128, i128 }\n+\n+assume_usize_width! {\n+    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64isize, u64, isize }\n+    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128isize, u128, isize }\n+\n+    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei8, usize, i8 }\n+    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei16, usize, i16 }\n+    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizeisize, usize, isize }\n+\n+    cfg_block!(\n+        #[cfg(target_pointer_width = \"16\")] {\n+            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n+            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u64, isize }\n+        }\n+\n+        #[cfg(target_pointer_width = \"32\")] {\n+            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n+            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n+        }\n+\n+        #[cfg(target_pointer_width = \"64\")] {\n+            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n+            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei64, usize, i64 }\n+        }\n+    );\n+}\n+\n+/// Conversions where min/max of $source can not be represented as $target.\n macro_rules! test_impl_try_from_same_sign_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n@@ -359,7 +502,13 @@ test_impl_try_from_same_sign_err! { test_try_u64u8, u64, u8 }\n test_impl_try_from_same_sign_err! { test_try_u64u16, u64, u16 }\n test_impl_try_from_same_sign_err! { test_try_u64u32, u64, u32 }\n \n+test_impl_try_from_same_sign_err! { test_try_u128u8, u128, u8 }\n+test_impl_try_from_same_sign_err! { test_try_u128u16, u128, u16 }\n+test_impl_try_from_same_sign_err! { test_try_u128u32, u128, u32 }\n+test_impl_try_from_same_sign_err! { test_try_u128u64, u128, u64 }\n+\n test_impl_try_from_same_sign_err! { test_try_i16i8, i16, i8 }\n+test_impl_try_from_same_sign_err! { test_try_isizei8, isize, i8 }\n \n test_impl_try_from_same_sign_err! { test_try_i32i8, i32, i8 }\n test_impl_try_from_same_sign_err! { test_try_i32i16, i32, i16 }\n@@ -368,6 +517,45 @@ test_impl_try_from_same_sign_err! { test_try_i64i8, i64, i8 }\n test_impl_try_from_same_sign_err! { test_try_i64i16, i64, i16 }\n test_impl_try_from_same_sign_err! { test_try_i64i32, i64, i32 }\n \n+test_impl_try_from_same_sign_err! { test_try_i128i8, i128, i8 }\n+test_impl_try_from_same_sign_err! { test_try_i128i16, i128, i16 }\n+test_impl_try_from_same_sign_err! { test_try_i128i32, i128, i32 }\n+test_impl_try_from_same_sign_err! { test_try_i128i64, i128, i64 }\n+\n+assume_usize_width! {\n+    test_impl_try_from_same_sign_err! { test_try_usizeu8, usize, u8 }\n+    test_impl_try_from_same_sign_err! { test_try_u128usize, u128, usize }\n+    test_impl_try_from_same_sign_err! { test_try_i128isize, i128, isize }\n+\n+    cfg_block!(\n+        #[cfg(target_pointer_width = \"16\")] {\n+            test_impl_try_from_same_sign_err! { test_try_u32usize, u32, usize }\n+            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n+\n+            test_impl_try_from_same_sign_err! { test_try_i32isize, i32, isize }\n+            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n+        }\n+\n+        #[cfg(target_pointer_width = \"32\")] {\n+            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n+            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n+\n+            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n+            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n+        }\n+\n+        #[cfg(target_pointer_width = \"64\")] {\n+            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n+            test_impl_try_from_same_sign_err! { test_try_usizeu32, usize, u32 }\n+\n+            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n+            test_impl_try_from_same_sign_err! { test_try_isizei32, isize, i32 }\n+        }\n+    );\n+}\n+\n+/// Conversinos where neither the min nor the max of $source can be represented by\n+/// $target, but max/min of the target can be represented by the source.\n macro_rules! test_impl_try_from_signed_to_unsigned_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n@@ -400,6 +588,32 @@ test_impl_try_from_signed_to_unsigned_err! { test_try_i64u8, i64, u8 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u16, i64, u16 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u32, i64, u32 }\n \n+test_impl_try_from_signed_to_unsigned_err! { test_try_i128u8, i128, u8 }\n+test_impl_try_from_signed_to_unsigned_err! { test_try_i128u16, i128, u16 }\n+test_impl_try_from_signed_to_unsigned_err! { test_try_i128u32, i128, u32 }\n+test_impl_try_from_signed_to_unsigned_err! { test_try_i128u64, i128, u64 }\n+\n+assume_usize_width! {\n+    test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu8, isize, u8 }\n+    test_impl_try_from_signed_to_unsigned_err! { test_try_i128usize, i128, usize }\n+\n+    cfg_block! {\n+        #[cfg(target_pointer_width = \"16\")] {\n+            test_impl_try_from_signed_to_unsigned_err! { test_try_i32usize, i32, usize }\n+            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n+        }\n+        #[cfg(target_pointer_width = \"32\")] {\n+            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n+\n+            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n+        }\n+        #[cfg(target_pointer_width = \"64\")] {\n+            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n+            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu32, isize, u32 }\n+        }\n+    }\n+}\n+\n macro_rules! test_float {\n     ($modname: ident, $fty: ty, $inf: expr, $neginf: expr, $nan: expr) => { mod $modname {\n         use core::num::Float;"}]}