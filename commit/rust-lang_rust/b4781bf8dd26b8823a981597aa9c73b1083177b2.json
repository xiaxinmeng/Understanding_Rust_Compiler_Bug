{"sha": "b4781bf8dd26b8823a981597aa9c73b1083177b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NzgxYmY4ZGQyNmI4ODIzYTk4MTU5N2FhOWM3M2IxMDgzMTc3YjI=", "commit": {"author": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-07-10T23:00:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-11T00:05:25Z"}, "message": "Type-parameterize ivec_fuzz", "tree": {"sha": "f47511f1dafd49b2b262c7500e6d92feedddefd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f47511f1dafd49b2b262c7500e6d92feedddefd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4781bf8dd26b8823a981597aa9c73b1083177b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4781bf8dd26b8823a981597aa9c73b1083177b2", "html_url": "https://github.com/rust-lang/rust/commit/b4781bf8dd26b8823a981597aa9c73b1083177b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4781bf8dd26b8823a981597aa9c73b1083177b2/comments", "author": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3671cddcba6384973e276d14a1699e641c8eb0bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3671cddcba6384973e276d14a1699e641c8eb0bc", "html_url": "https://github.com/rust-lang/rust/commit/3671cddcba6384973e276d14a1699e641c8eb0bc"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "4d52e73e56b7fa121660b3e228c643b428708cff", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b4781bf8dd26b8823a981597aa9c73b1083177b2/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4781bf8dd26b8823a981597aa9c73b1083177b2/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=b4781bf8dd26b8823a981597aa9c73b1083177b2", "patch": "@@ -7,7 +7,7 @@ Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n   two functions, \"return the number of possible edits\" and \"return edit #n\"\n \n It would be nice if this could be data-driven, so the two functions could share information:\n-  type vec_modifier = rec(fn (&int[] v, uint i) -> int[] fun, uint lo, uint di);\n+  type vec_modifier = rec(fn (&T[] v, uint i) -> T[] fun, uint lo, uint di);\n   const vec_modifier[] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...];\n But that gives me \"error: internal compiler error unimplemented consts that's not a plain literal\".\n https://github.com/graydon/rust/issues/570\n@@ -26,23 +26,23 @@ import std::ivec::slice;\n import std::ivec::len;\n import std::int;\n \n-//fn vec_reverse(&int[] v) -> int[] { ... }\n+//fn vec_reverse(&T[] v) -> T[] { ... }\n \n-fn vec_omit   (&int[] v, uint i) -> int[] { slice(v, 0u, i) +                      slice(v, i+1u, len(v)) }\n-fn vec_dup    (&int[] v, uint i) -> int[] { slice(v, 0u, i) + ~[v.(i)]           + slice(v, i,    len(v)) }\n-fn vec_swadj  (&int[] v, uint i) -> int[] { slice(v, 0u, i) + ~[v.(i+1u), v.(i)] + slice(v, i+2u, len(v)) }\n-fn vec_prefix (&int[] v, uint i) -> int[] { slice(v, 0u, i) }\n-fn vec_suffix (&int[] v, uint i) -> int[] { slice(v, i, len(v)) }\n+fn vec_omit   [T] (&T[] v, uint i) -> T[] { slice(v, 0u, i) +                      slice(v, i+1u, len(v)) }\n+fn vec_dup    [T] (&T[] v, uint i) -> T[] { slice(v, 0u, i) + ~[v.(i)]           + slice(v, i,    len(v)) }\n+fn vec_swadj  [T] (&T[] v, uint i) -> T[] { slice(v, 0u, i) + ~[v.(i+1u), v.(i)] + slice(v, i+2u, len(v)) }\n+fn vec_prefix [T] (&T[] v, uint i) -> T[] { slice(v, 0u, i) }\n+fn vec_suffix [T] (&T[] v, uint i) -> T[] { slice(v, i, len(v)) }\n \n-fn vec_poke   (&int[] v, uint i, int x) -> int[] { slice(v, 0u, i) + ~[x] + slice(v, i+1u, len(v)) }\n-fn vec_insert (&int[] v, uint i, int x) -> int[] { slice(v, 0u, i) + ~[x] + slice(v, i, len(v)) }\n+fn vec_poke   [T] (&T[] v, uint i, &T x) -> T[] { slice(v, 0u, i) + ~[x] + slice(v, i+1u, len(v)) }\n+fn vec_insert [T] (&T[] v, uint i, &T x) -> T[] { slice(v, 0u, i) + ~[x] + slice(v, i, len(v)) }\n \n // Iterates over 0...length, skipping the specified number on each side.\n iter ix(uint skip_low, uint skip_high, uint length) -> uint { let uint i = skip_low; while (i + skip_high <= length) { put i; i += 1u; } }\n \n // Returns a bunch of modified versions of v, some of which introduce new elements (borrowed from xs).\n-fn vec_edits(&int[] v, &int[] xs) -> int[][] {\n-    let int[][] edits = ~[];\n+fn vec_edits[T](&T[] v, &T[] xs) -> T[][] {\n+    let T[][] edits = ~[];\n     let uint Lv = len(v);\n \n     if (Lv != 1u) { edits += ~[~[]]; } // When Lv == 1u, this is redundant with omit\n@@ -55,8 +55,8 @@ fn vec_edits(&int[] v, &int[] xs) -> int[][] {\n     for each (uint i in ix(2u, 1u, Lv)) { edits += ~[vec_suffix(v, i)]; }\n \n     for each (uint j in ix(0u, 1u, len(xs))) {\n-      for each (uint i in ix(0u, 1u, Lv)) { edits += ~[vec_poke  (v, i, xs.(j))]; }\n-      for each (uint i in ix(0u, 0u, Lv)) { edits += ~[vec_insert(v, i, xs.(j))]; }\n+        for each (uint i in ix(0u, 1u, Lv)) { edits += ~[vec_poke  (v, i, xs.(j))]; }\n+        for each (uint i in ix(0u, 0u, Lv)) { edits += ~[vec_insert(v, i, xs.(j))]; }\n     }\n \n     edits"}]}