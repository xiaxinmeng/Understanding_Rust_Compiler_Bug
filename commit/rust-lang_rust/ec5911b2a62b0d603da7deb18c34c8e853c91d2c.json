{"sha": "ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNTkxMWIyYTYyYjBkNjAzZGE3ZGViMThjMzRjOGU4NTNjOTFkMmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-13T04:12:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-15T01:29:12Z"}, "message": "libregex: Remove all uses of `~str` from `libregex`", "tree": {"sha": "d48a4ce419feae936d3001b1bbec93b7fc97e8f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48a4ce419feae936d3001b1bbec93b7fc97e8f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "html_url": "https://github.com/rust-lang/rust/commit/ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62cf95f67482c0ee7c70a984ce4edb6f6cd9f716", "url": "https://api.github.com/repos/rust-lang/rust/commits/62cf95f67482c0ee7c70a984ce4edb6f6cd9f716", "html_url": "https://github.com/rust-lang/rust/commit/62cf95f67482c0ee7c70a984ce4edb6f6cd9f716"}], "stats": {"total": 95, "additions": 50, "deletions": 45}, "files": [{"sha": "1ba691044463d38213d1dfe67934290b283f5693", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "patch": "@@ -83,12 +83,12 @@ pub struct Program {\n     /// If the regular expression requires a literal prefix in order to have a\n     /// match, that prefix is stored here. (It's used in the VM to implement\n     /// an optimization.)\n-    pub prefix: ~str,\n+    pub prefix: StrBuf,\n }\n \n impl Program {\n     /// Compiles a Regex given its AST.\n-    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<~str>>) {\n+    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<StrBuf>>) {\n         let mut c = Compiler {\n             insts: Vec::with_capacity(100),\n             names: Vec::with_capacity(10),\n@@ -113,7 +113,7 @@ impl Program {\n         let Compiler { insts, names } = c;\n         let prog = Program {\n             insts: insts,\n-            prefix: pre.into_owned(),\n+            prefix: pre,\n         };\n         (prog, names)\n     }\n@@ -135,7 +135,7 @@ impl Program {\n \n struct Compiler<'r> {\n     insts: Vec<Inst>,\n-    names: Vec<Option<~str>>,\n+    names: Vec<Option<StrBuf>>,\n }\n \n // The compiler implemented here is extremely simple. Most of the complexity"}, {"sha": "d1a01cc974f8b3afbe2a3d17dddebfe0cfa6b19f", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "patch": "@@ -32,7 +32,7 @@ pub struct Error {\n     /// The *approximate* character index of where the error occurred.\n     pub pos: uint,\n     /// A message describing the error.\n-    pub msg: ~str,\n+    pub msg: StrBuf,\n }\n \n impl fmt::Show for Error {\n@@ -59,7 +59,7 @@ pub enum Ast {\n     Begin(Flags),\n     End(Flags),\n     WordBoundary(Flags),\n-    Capture(uint, Option<~str>, Box<Ast>),\n+    Capture(uint, Option<StrBuf>, Box<Ast>),\n     // Represent concatenation as a flat vector to avoid blowing the\n     // stack in the compiler.\n     Cat(Vec<Ast>),\n@@ -104,7 +104,7 @@ impl Greed {\n #[deriving(Show)]\n enum BuildAst {\n     Ast(Ast),\n-    Paren(Flags, uint, ~str), // '('\n+    Paren(Flags, uint, StrBuf), // '('\n     Bar, // '|'\n }\n \n@@ -131,7 +131,7 @@ impl BuildAst {\n         }\n     }\n \n-    fn capture_name(&self) -> Option<~str> {\n+    fn capture_name(&self) -> Option<StrBuf> {\n         match *self {\n             Paren(_, 0, _) => None,\n             Paren(_, _, ref name) => {\n@@ -185,7 +185,7 @@ struct Parser<'a> {\n     // opening a capture group).\n     caps: uint,\n     // A set of all capture group names used only to detect duplicates.\n-    names: Vec<~str>,\n+    names: Vec<StrBuf>,\n }\n \n pub fn parse(s: &str) -> Result<Ast, Error> {\n@@ -222,7 +222,7 @@ impl<'a> Parser<'a> {\n                         self.caps += 1;\n                         self.stack.push(Paren(self.flags,\n                                               self.caps,\n-                                              \"\".to_owned()))\n+                                              \"\".to_strbuf()))\n                     }\n                 }\n                 ')' => {\n@@ -470,7 +470,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name) {\n+        match find_class(ASCII_CLASSES, name.as_slice()) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -611,7 +611,7 @@ impl<'a> Parser<'a> {\n     // character).\n     fn parse_unicode_name(&mut self) -> Result<Ast, Error> {\n         let negated = if self.cur() == 'P' { FLAG_NEGATED } else { FLAG_EMPTY };\n-        let mut name: ~str;\n+        let mut name: StrBuf;\n         if self.peek_is(1, '{') {\n             try!(self.expect('{'))\n             let closer =\n@@ -633,7 +633,7 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name) {\n+        match find_class(UNICODE_CLASSES, name.as_slice()) {\n             None => return self.err(format!(\n                 \"Could not find Unicode class '{}'\", name)),\n             Some(ranges) => {\n@@ -657,7 +657,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s, 8) {\n+        match num::from_str_radix::<u32>(s.as_slice(), 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => self.err(format!(\n                 \"Could not parse '{}' as octal number.\", s)),\n@@ -679,7 +679,7 @@ impl<'a> Parser<'a> {\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer))\n+        self.parse_hex_digits(self.slice(start, closer).as_slice())\n     }\n \n     // Parses a two-digit hex number.\n@@ -690,7 +690,7 @@ impl<'a> Parser<'a> {\n         let (start, end) = (self.chari, self.chari + 2);\n         let bad = self.slice(start - 2, self.chars.len());\n         try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\", bad)))\n-        self.parse_hex_digits(self.slice(start, end))\n+        self.parse_hex_digits(self.slice(start, end).as_slice())\n     }\n \n     // Parses `s` as a hexadecimal number.\n@@ -717,7 +717,7 @@ impl<'a> Parser<'a> {\n             return self.err(\"Capture names must have at least 1 character.\")\n         }\n         let name = self.slice(self.chari, closer);\n-        if !name.chars().all(is_valid_cap) {\n+        if !name.as_slice().chars().all(is_valid_cap) {\n             return self.err(\n                 \"Capture names can only have underscores, letters and digits.\")\n         }\n@@ -771,7 +771,7 @@ impl<'a> Parser<'a> {\n                     }\n                     if self.cur() == ':' {\n                         // Save the old flags with the opening paren.\n-                        self.stack.push(Paren(self.flags, 0, \"\".to_owned()));\n+                        self.stack.push(Paren(self.flags, 0, \"\".to_strbuf()));\n                     }\n                     self.flags = flags;\n                     return Ok(())\n@@ -892,7 +892,7 @@ impl<'a> Parser<'a> {\n     fn err<T>(&self, msg: &str) -> Result<T, Error> {\n         Err(Error {\n             pos: self.chari,\n-            msg: msg.to_owned(),\n+            msg: msg.to_strbuf(),\n         })\n     }\n \n@@ -911,8 +911,8 @@ impl<'a> Parser<'a> {\n         *self.chars.get(self.chari)\n     }\n \n-    fn slice(&self, start: uint, end: uint) -> ~str {\n-        str::from_chars(self.chars.as_slice().slice(start, end))\n+    fn slice(&self, start: uint, end: uint) -> StrBuf {\n+        str::from_chars(self.chars.as_slice().slice(start, end)).to_strbuf()\n     }\n }\n "}, {"sha": "f22889b22a324b56cf27a5ec561ee109a781d0c7", "filename": "src/libregex/re.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "patch": "@@ -20,15 +20,15 @@ use vm::{CaptureLocs, MatchKind, Exists, Location, Submatches};\n \n /// Escapes all regular expression meta characters in `text` so that it may be\n /// safely used in a regular expression as a literal string.\n-pub fn quote(text: &str) -> ~str {\n+pub fn quote(text: &str) -> StrBuf {\n     let mut quoted = StrBuf::with_capacity(text.len());\n     for c in text.chars() {\n         if parse::is_punct(c) {\n             quoted.push_char('\\\\')\n         }\n         quoted.push_char(c);\n     }\n-    quoted.into_owned()\n+    quoted\n }\n \n /// Tests if the given regular expression matches somewhere in the text given.\n@@ -107,9 +107,9 @@ pub struct Regex {\n     /// See the comments for the `program` module in `lib.rs` for a more\n     /// detailed explanation for what `regex!` requires.\n     #[doc(hidden)]\n-    pub original: ~str,\n+    pub original: StrBuf,\n     #[doc(hidden)]\n-    pub names: Vec<Option<~str>>,\n+    pub names: Vec<Option<StrBuf>>,\n     #[doc(hidden)]\n     pub p: MaybeNative,\n }\n@@ -146,7 +146,10 @@ impl Regex {\n     pub fn new(re: &str) -> Result<Regex, parse::Error> {\n         let ast = try!(parse::parse(re));\n         let (prog, names) = Program::new(ast);\n-        Ok(Regex { original: re.to_owned(), names: names, p: Dynamic(prog) })\n+        Ok(Regex {\n+            original: re.to_strbuf(),\n+            names: names, p: Dynamic(prog),\n+        })\n     }\n \n     /// Returns true if and only if the regex matches the string given.\n@@ -404,7 +407,7 @@ impl Regex {\n     /// ```\n     ///\n     /// But anything satisfying the `Replacer` trait will work. For example,\n-    /// a closure of type `|&Captures| -> ~str` provides direct access to the\n+    /// a closure of type `|&Captures| -> StrBuf` provides direct access to the\n     /// captures corresponding to a match. This allows one to access\n     /// submatches easily:\n     ///\n@@ -414,7 +417,7 @@ impl Regex {\n     /// # use regex::Captures; fn main() {\n     /// let re = regex!(r\"([^,\\s]+),\\s+(\\S+)\");\n     /// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n-    ///     format!(\"{} {}\", caps.at(2), caps.at(1))\n+    ///     format_strbuf!(\"{} {}\", caps.at(2), caps.at(1))\n     /// });\n     /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n     /// # }\n@@ -526,7 +529,7 @@ impl<'t> Replacer for &'t str {\n     }\n }\n \n-impl<'a> Replacer for |&Captures|: 'a -> ~str {\n+impl<'a> Replacer for |&Captures|: 'a -> StrBuf {\n     fn reg_replace<'r>(&'r mut self, caps: &Captures) -> MaybeOwned<'r> {\n         Owned((*self)(caps).into_owned())\n     }\n@@ -605,7 +608,7 @@ impl<'r, 't> Iterator<&'t str> for RegexSplitsN<'r, 't> {\n pub struct Captures<'t> {\n     text: &'t str,\n     locs: CaptureLocs,\n-    named: Option<HashMap<~str, uint>>,\n+    named: Option<HashMap<StrBuf, uint>>,\n }\n \n impl<'t> Captures<'t> {\n@@ -624,7 +627,7 @@ impl<'t> Captures<'t> {\n                     match name {\n                         &None => {},\n                         &Some(ref name) => {\n-                            named.insert(name.to_owned(), i);\n+                            named.insert(name.to_strbuf(), i);\n                         }\n                     }\n                 }\n@@ -707,12 +710,14 @@ impl<'t> Captures<'t> {\n         // How evil can you get?\n         // FIXME: Don't use regexes for this. It's completely unnecessary.\n         let re = Regex::new(r\"(^|[^$]|\\b)\\$(\\w+)\").unwrap();\n-        let text = re.replace_all(text, |refs: &Captures| -> ~str {\n+        let text = re.replace_all(text, |refs: &Captures| -> StrBuf {\n             let (pre, name) = (refs.at(1), refs.at(2));\n-            pre + match from_str::<uint>(name) {\n-                None => self.name(name).to_owned(),\n-                Some(i) => self.at(i).to_owned(),\n-            }\n+            format_strbuf!(\"{}{}\",\n+                           pre,\n+                           match from_str::<uint>(name.as_slice()) {\n+                None => self.name(name).to_strbuf(),\n+                Some(i) => self.at(i).to_strbuf(),\n+            })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n         re.replace_all(text.as_slice(), NoExpand(\"$\"))"}, {"sha": "3630e0ebb5c8e5b666cdbe2a167b094d823350ae", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "patch": "@@ -140,7 +140,7 @@ macro_rules! throughput(\n         fn $name(b: &mut Bencher) {\n             let text = gen_text($size);\n             b.bytes = $size;\n-            b.iter(|| if $regex.is_match(text) { fail!(\"match\") });\n+            b.iter(|| if $regex.is_match(text.as_slice()) { fail!(\"match\") });\n         }\n     );\n )\n@@ -151,15 +151,15 @@ fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n #[allow(deprecated_owned_vector)]\n-fn gen_text(n: uint) -> ~str {\n+fn gen_text(n: uint) -> StrBuf {\n     let mut rng = task_rng();\n     let mut bytes = rng.gen_ascii_str(n).into_bytes();\n     for (i, b) in bytes.mut_iter().enumerate() {\n         if i % 20 == 0 {\n             *b = '\\n' as u8\n         }\n     }\n-    str::from_utf8(bytes).unwrap().to_owned()\n+    str::from_utf8(bytes).unwrap().to_strbuf()\n }\n \n throughput!(easy0_32, easy0(), 32)"}, {"sha": "b85a1592eff02ae439fb1895b3909f068e5767c8", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5911b2a62b0d603da7deb18c34c8e853c91d2c/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=ec5911b2a62b0d603da7deb18c34c8e853c91d2c", "patch": "@@ -105,8 +105,8 @@ struct NfaGen<'a> {\n     cx: &'a ExtCtxt<'a>,\n     sp: codemap::Span,\n     prog: Program,\n-    names: Vec<Option<~str>>,\n-    original: ~str,\n+    names: Vec<Option<StrBuf>>,\n+    original: StrBuf,\n }\n \n impl<'a> NfaGen<'a> {\n@@ -119,7 +119,7 @@ impl<'a> NfaGen<'a> {\n             |cx, name| match *name {\n                 Some(ref name) => {\n                     let name = name.as_slice();\n-                    quote_expr!(cx, Some($name.to_owned()))\n+                    quote_expr!(cx, Some($name.to_strbuf()))\n                 }\n                 None => cx.expr_none(self.sp),\n             }\n@@ -311,7 +311,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n }\n \n ::regex::Regex {\n-    original: $regex.to_owned(),\n+    original: $regex.to_strbuf(),\n     names: vec!$cap_names,\n     p: ::regex::native::Native(exec),\n }\n@@ -601,14 +601,14 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n /// Looks for a single string literal and returns it.\n /// Otherwise, logs an error with cx.span_err and returns None.\n-fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<~str> {\n+fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<StrBuf> {\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(),\n                                                 Vec::from_slice(tts));\n     let entry = cx.expand_expr(parser.parse_expr());\n     let regex = match entry.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => s.to_str(),\n+                ast::LitStr(ref s, _) => s.to_str().to_strbuf(),\n                 _ => {\n                     cx.span_err(entry.span, format!(\n                         \"expected string literal but got `{}`\","}]}