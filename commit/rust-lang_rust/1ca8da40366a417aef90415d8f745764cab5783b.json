{"sha": "1ca8da40366a417aef90415d8f745764cab5783b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYThkYTQwMzY2YTQxN2FlZjkwNDE1ZDhmNzQ1NzY0Y2FiNTc4M2I=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-19T00:45:16Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-24T17:06:37Z"}, "message": "rustc_typeck: compute better spans for inferred_outlives.", "tree": {"sha": "27c808626e6f61e4667a512ed3ea4046df804e40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27c808626e6f61e4667a512ed3ea4046df804e40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ca8da40366a417aef90415d8f745764cab5783b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca8da40366a417aef90415d8f745764cab5783b", "html_url": "https://github.com/rust-lang/rust/commit/1ca8da40366a417aef90415d8f745764cab5783b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ca8da40366a417aef90415d8f745764cab5783b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "html_url": "https://github.com/rust-lang/rust/commit/93cac9c3da06e1fbbdee10df7525234ffc7c76cd"}], "stats": {"total": 68, "additions": 39, "deletions": 29}, "files": [{"sha": "08554c83ed5bf0e325e7727c1a5ad2c01eafb8d7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1ca8da40366a417aef90415d8f745764cab5783b", "patch": "@@ -197,6 +197,13 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n             return TAG_INVALID_SPAN.encode(self)\n         }\n \n+        // HACK(eddyb) there's no way to indicate which crate a Span is coming\n+        // from right now, so decoding would fail to find the SourceFile if\n+        // it's not local to the crate the Span is found in.\n+        if self.source_file_cache.is_imported() {\n+            return TAG_INVALID_SPAN.encode(self)\n+        }\n+\n         TAG_VALID_SPAN.encode(self)?;\n         span.lo.encode(self)?;\n \n@@ -379,6 +386,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             .filter(|source_file| {\n                 // No need to re-export imported source_files, as any downstream\n                 // crate will import them from their original source.\n+                // FIXME(eddyb) the `Span` encoding should take that into account.\n                 !source_file.is_imported()\n             })\n             .map(|source_file| {"}, {"sha": "21e529f33cfd00e36cc2609b47854b6b9bd11a2b", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=1ca8da40366a417aef90415d8f745764cab5783b", "patch": "@@ -30,11 +30,17 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             let mut required_predicates = RequiredPredicates::default();\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n-            for (pred, _) in predicates.predicates {\n-                match pred {\n+            for &(predicate, span) in predicates.predicates {\n+                match predicate {\n                     ty::Predicate::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n-                        insert_outlives_predicate(tcx, (*ty).into(), reg, &mut required_predicates)\n+                        insert_outlives_predicate(\n+                            tcx,\n+                            (*ty).into(),\n+                            reg,\n+                            span,\n+                            &mut required_predicates,\n+                        )\n                     }\n \n                     ty::Predicate::RegionOutlives(predicate) => {\n@@ -43,6 +49,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                             tcx,\n                             (*reg1).into(),\n                             reg2,\n+                            span,\n                             &mut required_predicates,\n                         )\n                     }"}, {"sha": "74048b8d20c825ad23ba9ffab0208d10a34af188", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=1ca8da40366a417aef90415d8f745764cab5783b", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{GenericArg, Subst, GenericArgKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n+use syntax_pos::Span;\n \n use super::explicit::ExplicitPredicatesMap;\n use super::utils::*;\n@@ -79,9 +80,11 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n                     // (struct/enum/union) there will be outlive\n                     // requirements for adt_def.\n                     let field_ty = self.tcx.type_of(field_def.did);\n+                    let field_span = self.tcx.def_span(field_def.did);\n                     insert_required_predicates_to_be_wf(\n                         self.tcx,\n                         field_ty,\n+                        field_span,\n                         self.global_inferred_outlives,\n                         &mut item_required_predicates,\n                         &mut self.explicit_map,\n@@ -118,6 +121,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n fn insert_required_predicates_to_be_wf<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     field_ty: Ty<'tcx>,\n+    field_span: Span,\n     global_inferred_outlives: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n@@ -130,7 +134,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             // We also want to calculate potential predicates for the T\n             ty::Ref(region, rty, _) => {\n                 debug!(\"Ref\");\n-                insert_outlives_predicate(tcx, rty.into(), region, required_predicates);\n+                insert_outlives_predicate(tcx, rty.into(), region, field_span, required_predicates);\n             }\n \n             // For each Adt (struct/enum/union) type `Foo<'a, T>`, we\n@@ -158,7 +162,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // 'a` holds for `Foo`.\n                 debug!(\"Adt\");\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did) {\n-                    for unsubstituted_predicate in unsubstituted_predicates {\n+                    for (unsubstituted_predicate, &span) in unsubstituted_predicates {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n                         // example above.  So apply the substitution to\n                         // get `T: 'a` (or `predicate`):\n@@ -167,6 +171,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                             tcx,\n                             predicate.0,\n                             predicate.1,\n+                            span,\n                             required_predicates,\n                         );\n                     }\n@@ -272,7 +277,7 @@ pub fn check_explicit_predicates<'tcx>(\n     );\n     let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n-    for outlives_predicate in explicit_predicates.iter() {\n+    for (outlives_predicate, &span) in explicit_predicates {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n \n         // Careful: If we are inferring the effects of a `dyn Trait<..>`\n@@ -320,6 +325,6 @@ pub fn check_explicit_predicates<'tcx>(\n \n         let predicate = outlives_predicate.subst(tcx, substs);\n         debug!(\"predicate = {:?}\", &predicate);\n-        insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, required_predicates);\n+        insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, span, required_predicates);\n     }\n }"}, {"sha": "6b861656d7e2dce0188d4803f75c0935fa6e9e6c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=1ca8da40366a417aef90415d8f745764cab5783b", "patch": "@@ -97,32 +97,16 @@ fn inferred_outlives_crate(\n     let predicates = global_inferred_outlives\n         .iter()\n         .map(|(&def_id, set)| {\n-            let def_span = tcx.def_span(def_id);\n-            let generics = tcx.generics_of(def_id);\n             let predicates = &*tcx.arena.alloc_from_iter(set\n                 .iter()\n                 .filter_map(\n-                    |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n+                    |(ty::OutlivesPredicate(kind1, region2), &span)| match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => {\n-                            // FIXME(eddyb) compute `Span`s in `implicit_infer`.\n-                            let span = match &ty1.kind {\n-                                ty::Param(p) => {\n-                                    tcx.def_span(generics.type_param(p, tcx).def_id)\n-                                }\n-                                _ => def_span,\n-                            };\n                             Some((ty::Predicate::TypeOutlives(ty::Binder::bind(\n                                 ty::OutlivesPredicate(ty1, region2)\n                             )), span))\n                         }\n                         GenericArgKind::Lifetime(region1) => {\n-                            // FIXME(eddyb) compute `Span`s in `implicit_infer`.\n-                            let span = match region1 {\n-                                ty::RegionKind::ReEarlyBound(p) => {\n-                                    tcx.def_span(generics.region_param(p, tcx).def_id)\n-                                }\n-                                _ => def_span,\n-                            };\n                             Some((ty::Predicate::RegionOutlives(\n                                 ty::Binder::bind(ty::OutlivesPredicate(region1, region2))\n                             ), span))"}, {"sha": "361116e96d0bfc9f53d8103bbde23d60850b8336", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca8da40366a417aef90415d8f745764cab5783b/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=1ca8da40366a417aef90415d8f745764cab5783b", "patch": "@@ -2,19 +2,21 @@ use rustc::ty::outlives::Component;\n use rustc::ty::subst::{GenericArg, GenericArgKind};\n use rustc::ty::{self, Region, RegionKind, Ty, TyCtxt};\n use smallvec::smallvec;\n-use std::collections::BTreeSet;\n+use std::collections::BTreeMap;\n+use syntax_pos::Span;\n \n /// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n /// must be added to the struct header.\n pub type RequiredPredicates<'tcx> =\n-    BTreeSet<ty::OutlivesPredicate<GenericArg<'tcx>, ty::Region<'tcx>>>;\n+    BTreeMap<ty::OutlivesPredicate<GenericArg<'tcx>, ty::Region<'tcx>>, Span>;\n \n /// Given a requirement `T: 'a` or `'b: 'a`, deduce the\n /// outlives_component and add it to `required_predicates`\n pub fn insert_outlives_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     kind: GenericArg<'tcx>,\n     outlived_region: Region<'tcx>,\n+    span: Span,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n ) {\n     // If the `'a` region is bound within the field type itself, we\n@@ -53,6 +55,7 @@ pub fn insert_outlives_predicate<'tcx>(\n                             tcx,\n                             r.into(),\n                             outlived_region,\n+                            span,\n                             required_predicates,\n                         );\n                     }\n@@ -73,7 +76,8 @@ pub fn insert_outlives_predicate<'tcx>(\n                         // where clause that `U: 'a`.\n                         let ty: Ty<'tcx> = param_ty.to_ty(tcx);\n                         required_predicates\n-                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                            .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                            .or_insert(span);\n                     }\n \n                     Component::Projection(proj_ty) => {\n@@ -88,7 +92,8 @@ pub fn insert_outlives_predicate<'tcx>(\n                         // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n                         let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.item_def_id, proj_ty.substs);\n                         required_predicates\n-                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                            .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                            .or_insert(span);\n                     }\n \n                     Component::EscapingProjection(_) => {\n@@ -117,7 +122,8 @@ pub fn insert_outlives_predicate<'tcx>(\n             if !is_free_region(tcx, r) {\n                 return;\n             }\n-            required_predicates.insert(ty::OutlivesPredicate(kind, outlived_region));\n+            required_predicates.entry(ty::OutlivesPredicate(kind, outlived_region))\n+                .or_insert(span);\n         }\n \n         GenericArgKind::Const(_) => {"}]}