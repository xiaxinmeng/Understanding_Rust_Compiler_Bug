{"sha": "db8fbb99ce6e60c072250bada004de9645431a43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiOGZiYjk5Y2U2ZTYwYzA3MjI1MGJhZGEwMDRkZTk2NDU0MzFhNDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-17T08:40:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-17T08:40:34Z"}, "message": "minor: extract fix to file", "tree": {"sha": "73249d5fd442574c7e91a20db33b7da55c7914e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73249d5fd442574c7e91a20db33b7da55c7914e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db8fbb99ce6e60c072250bada004de9645431a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db8fbb99ce6e60c072250bada004de9645431a43", "html_url": "https://github.com/rust-lang/rust/commit/db8fbb99ce6e60c072250bada004de9645431a43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db8fbb99ce6e60c072250bada004de9645431a43/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e22b21e1bb5580a816f085879f9acdb3183a15cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e22b21e1bb5580a816f085879f9acdb3183a15cb", "html_url": "https://github.com/rust-lang/rust/commit/e22b21e1bb5580a816f085879f9acdb3183a15cb"}], "stats": {"total": 240, "additions": 196, "deletions": 44}, "files": [{"sha": "5330449f9b5519eb4183dc3149b5e31fe41a82ca", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/db8fbb99ce6e60c072250bada004de9645431a43/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db8fbb99ce6e60c072250bada004de9645431a43/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=db8fbb99ce6e60c072250bada004de9645431a43", "patch": "@@ -1,10 +1,12 @@\n //! Provides a way to attach fixes to the diagnostics.\n //! The same module also has all curret custom fixes for the diagnostics implemented.\n+mod fill_missing_fields;\n+\n use hir::{\n     db::AstDatabase,\n     diagnostics::{\n-        Diagnostic, IncorrectCase, MissingFields, MissingOkOrSomeInTailExpr, NoSuchField,\n-        RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnresolvedModule,\n+        Diagnostic, IncorrectCase, MissingOkOrSomeInTailExpr, NoSuchField, RemoveThisSemicolon,\n+        ReplaceFilterMapNextWithFindMap, UnresolvedModule,\n     },\n     HasSource, HirDisplay, InFile, Semantics, VariantDef,\n };\n@@ -15,7 +17,6 @@ use ide_db::{\n     RootDatabase,\n };\n use syntax::{\n-    algo,\n     ast::{self, edit::IndentLevel, make, ArgListOwner},\n     AstNode, TextRange,\n };\n@@ -82,47 +83,6 @@ impl DiagnosticWithFix for NoSuchField {\n     }\n }\n \n-impl DiagnosticWithFix for MissingFields {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        // Note that although we could add a diagnostics to\n-        // fill the missing tuple field, e.g :\n-        // `struct A(usize);`\n-        // `let a = A { 0: () }`\n-        // but it is uncommon usage and it should not be encouraged.\n-        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n-            return None;\n-        }\n-\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let field_list_parent = self.field_list_parent.to_node(&root);\n-        let old_field_list = field_list_parent.record_expr_field_list()?;\n-        let new_field_list = old_field_list.clone_for_update();\n-        for f in self.missed_fields.iter() {\n-            let field =\n-                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n-                    .clone_for_update();\n-            new_field_list.add_field(field);\n-        }\n-\n-        let edit = {\n-            let mut builder = TextEdit::builder();\n-            algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n-                .into_text_edit(&mut builder);\n-            builder.finish()\n-        };\n-        Some(fix(\n-            \"fill_missing_fields\",\n-            \"Fill struct fields\",\n-            SourceChange::from_text_edit(self.file.original_file(sema.db), edit),\n-            sema.original_range(&field_list_parent.syntax()).range,\n-        ))\n-    }\n-}\n-\n impl DiagnosticWithFix for MissingOkOrSomeInTailExpr {\n     fn fix(\n         &self,"}, {"sha": "123c2f0af0762d1b4f1ac0c64e865b53c7a4e65e", "filename": "crates/ide/src/diagnostics/fixes/fill_missing_fields.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/db8fbb99ce6e60c072250bada004de9645431a43/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db8fbb99ce6e60c072250bada004de9645431a43/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs?ref=db8fbb99ce6e60c072250bada004de9645431a43", "patch": "@@ -0,0 +1,192 @@\n+use hir::{db::AstDatabase, diagnostics::MissingFields, Semantics};\n+use ide_assists::AssistResolveStrategy;\n+use ide_db::{source_change::SourceChange, RootDatabase};\n+use syntax::{algo, ast::make, AstNode};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, fixes::DiagnosticWithFix},\n+    Assist,\n+};\n+\n+impl DiagnosticWithFix for MissingFields {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        // Note that although we could add a diagnostics to\n+        // fill the missing tuple field, e.g :\n+        // `struct A(usize);`\n+        // `let a = A { 0: () }`\n+        // but it is uncommon usage and it should not be encouraged.\n+        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n+            return None;\n+        }\n+\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let field_list_parent = self.field_list_parent.to_node(&root);\n+        let old_field_list = field_list_parent.record_expr_field_list()?;\n+        let new_field_list = old_field_list.clone_for_update();\n+        for f in self.missed_fields.iter() {\n+            let field =\n+                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n+                    .clone_for_update();\n+            new_field_list.add_field(field);\n+        }\n+\n+        let edit = {\n+            let mut builder = TextEdit::builder();\n+            algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n+                .into_text_edit(&mut builder);\n+            builder.finish()\n+        };\n+        Some(fix(\n+            \"fill_missing_fields\",\n+            \"Fill struct fields\",\n+            SourceChange::from_text_edit(self.file.original_file(sema.db), edit),\n+            sema.original_range(&field_list_parent.syntax()).range,\n+        ))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_fix, check_no_diagnostics};\n+\n+    #[test]\n+    fn test_fill_struct_fields_empty() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct {$0};\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct { one: (), two: () };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_self() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32 }\n+\n+impl TestStruct {\n+    fn test_fn() { let s = Self {$0}; }\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32 }\n+\n+impl TestStruct {\n+    fn test_fn() { let s = Self { one: () }; }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_enum() {\n+        check_fix(\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n+\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin {$0 }\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n+\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin { lhs: (), rhs: () }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_partial() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct{ two: 2$0 };\n+}\n+\"#,\n+            r\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct{ two: 2, one: () };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_raw_ident() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { r#type: u8 }\n+\n+fn test_fn() {\n+    TestStruct { $0 };\n+}\n+\"#,\n+            r\"\n+struct TestStruct { r#type: u8 }\n+\n+fn test_fn() {\n+    TestStruct { r#type: ()  };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic() {\n+        check_no_diagnostics(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let one = 1;\n+    let s = TestStruct{ one, two: 2 };\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic_on_spread() {\n+        check_no_diagnostics(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let one = 1;\n+    let s = TestStruct{ ..a };\n+}\n+\"#,\n+        );\n+    }\n+}"}]}