{"sha": "10d99a973498c5a1be6ba318210751efc1c2cf61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZDk5YTk3MzQ5OGM1YTFiZTZiYTMxODIxMDc1MWVmYzFjMmNmNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-31T21:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-31T21:01:42Z"}, "message": "auto merge of #20360 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "7f6c86aebf4ac2cf41fadaeef8d1548147ab70d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f6c86aebf4ac2cf41fadaeef8d1548147ab70d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10d99a973498c5a1be6ba318210751efc1c2cf61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10d99a973498c5a1be6ba318210751efc1c2cf61", "html_url": "https://github.com/rust-lang/rust/commit/10d99a973498c5a1be6ba318210751efc1c2cf61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10d99a973498c5a1be6ba318210751efc1c2cf61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84f5ad8679c7fc454473ffbf389030f3e5fee379", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f5ad8679c7fc454473ffbf389030f3e5fee379", "html_url": "https://github.com/rust-lang/rust/commit/84f5ad8679c7fc454473ffbf389030f3e5fee379"}, {"sha": "139f44bae82a7c74bcda9cb2b16dd2ab93f18b17", "url": "https://api.github.com/repos/rust-lang/rust/commits/139f44bae82a7c74bcda9cb2b16dd2ab93f18b17", "html_url": "https://github.com/rust-lang/rust/commit/139f44bae82a7c74bcda9cb2b16dd2ab93f18b17"}], "stats": {"total": 9832, "additions": 4885, "deletions": 4947}, "files": [{"sha": "5b90d41ceeceb85c5e1ed457f054032149d39bc1", "filename": "mk/clean.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -64,6 +64,7 @@ clean-generic-$(2)-$(1):\n          -name '*.dll' -o \\\n          -name '*.def' -o \\\n          -name '*.py' -o \\\n+         -name '*.pyc' -o \\\n          -name '*.bc' \\\n          \\) \\\n          | xargs rm -f\n@@ -79,7 +80,7 @@ define CLEAN_HOST_STAGE_N\n \n clean$(1)_H_$(2): \\\n \t    $$(foreach crate,$$(CRATES),clean$(1)_H_$(2)-lib-$$(crate)) \\\n-\t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS),clean$(1)_H_$(2)-tool-$$(tool))\n+\t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS_ALL),clean$(1)_H_$(2)-tool-$$(tool))\n \t$$(Q)rm -fr $(2)/rt/libbacktrace\n \n clean$(1)_H_$(2)-tool-%:\n@@ -99,7 +100,7 @@ define CLEAN_TARGET_STAGE_N\n \n clean$(1)_T_$(2)_H_$(3): \\\n \t    $$(foreach crate,$$(CRATES),clean$(1)_T_$(2)_H_$(3)-lib-$$(crate)) \\\n-\t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS),clean$(1)_T_$(2)_H_$(3)-tool-$$(tool))\n+\t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS_ALL),clean$(1)_T_$(2)_H_$(3)-tool-$$(tool))\n \t$$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a\n \t$$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/librun_pass_stage* # For unix"}, {"sha": "899cc42d066e4a2032a37a5646925fecb7e913d2", "filename": "mk/debuggers.mk", "status": "modified", "additions": 88, "deletions": 13, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fdebuggers.mk", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fdebuggers.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdebuggers.mk?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -12,26 +12,77 @@\n # Copy debugger related scripts\n ######################################################################\n \n-DEBUGGER_RUSTLIB_ETC_SCRIPTS=lldb_rust_formatters.py\n-DEBUGGER_BIN_SCRIPTS=rust-lldb\n \n-DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS=$(foreach script,$(DEBUGGER_RUSTLIB_ETC_SCRIPTS), \\\n-                                     $(CFG_SRC_DIR)src/etc/$(script))\n-DEBUGGER_BIN_SCRIPTS_ABS=$(foreach script,$(DEBUGGER_BIN_SCRIPTS), \\\n-                             $(CFG_SRC_DIR)src/etc/$(script))\n+## GDB ##\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB=gdb_load_rust_pretty_printers.py \\\n+                                 gdb_rust_pretty_printing.py\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS=\\\n+    $(foreach script,$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB), \\\n+        $(CFG_SRC_DIR)src/etc/$(script))\n+\n+DEBUGGER_BIN_SCRIPTS_GDB=rust-gdb\n+DEBUGGER_BIN_SCRIPTS_GDB_ABS=\\\n+    $(foreach script,$(DEBUGGER_BIN_SCRIPTS_GDB), \\\n+        $(CFG_SRC_DIR)src/etc/$(script))\n+\n+\n+## LLDB ##\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB=lldb_rust_formatters.py\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS=\\\n+    $(foreach script,$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB), \\\n+        $(CFG_SRC_DIR)src/etc/$(script))\n+\n+DEBUGGER_BIN_SCRIPTS_LLDB=rust-lldb\n+DEBUGGER_BIN_SCRIPTS_LLDB_ABS=\\\n+    $(foreach script,$(DEBUGGER_BIN_SCRIPTS_LLDB), \\\n+        $(CFG_SRC_DIR)src/etc/$(script))\n+\n+\n+## ALL ##\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_ALL=$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB) \\\n+                                 $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB)\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_ALL_ABS=$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS) \\\n+                                     $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS)\n+DEBUGGER_BIN_SCRIPTS_ALL=$(DEBUGGER_BIN_SCRIPTS_GDB) \\\n+                         $(DEBUGGER_BIN_SCRIPTS_LLDB)\n+DEBUGGER_BIN_SCRIPTS_ALL_ABS=$(DEBUGGER_BIN_SCRIPTS_GDB_ABS) \\\n+                             $(DEBUGGER_BIN_SCRIPTS_LLDB_ABS)\n \n-DEBUGGER_SCRIPTS_ALL=$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $(DEBUGGER_BIN_SCRIPTS_ABS)\n \n # $(1) - the stage to copy to\n # $(2) - the host triple\n define DEF_INSTALL_DEBUGGER_SCRIPTS_HOST\n \n-tmp/install-debugger-scripts$(1)_H_$(2).done: $$(DEBUGGER_SCRIPTS_ALL)\n+tmp/install-debugger-scripts$(1)_H_$(2)-gdb.done: \\\n+  $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS) \\\n+  $$(DEBUGGER_BIN_SCRIPTS_GDB_ABS)\n+\t$(Q)mkdir -p $$(HBIN$(1)_H_$(2))\n+\t$(Q)mkdir -p $$(HLIB$(1)_H_$(2))/rustlib/etc\n+\t$(Q)install $$(DEBUGGER_BIN_SCRIPTS_GDB_ABS) $$(HBIN$(1)_H_$(2))\n+\t$(Q)install $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS) $$(HLIB$(1)_H_$(2))/rustlib/etc\n+\t$(Q)touch $$@\n+\n+tmp/install-debugger-scripts$(1)_H_$(2)-lldb.done: \\\n+  $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS) \\\n+  $$(DEBUGGER_BIN_SCRIPTS_LLDB_ABS)\n+\t$(Q)mkdir -p $$(HBIN$(1)_H_$(2))\n+\t$(Q)mkdir -p $$(HLIB$(1)_H_$(2))/rustlib/etc\n+\t$(Q)install $$(DEBUGGER_BIN_SCRIPTS_LLDB_ABS) $$(HBIN$(1)_H_$(2))\n+\t$(Q)install $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS) $$(HLIB$(1)_H_$(2))/rustlib/etc\n+\t$(Q)touch $$@\n+\n+tmp/install-debugger-scripts$(1)_H_$(2)-all.done: \\\n+  $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ALL_ABS) \\\n+  $$(DEBUGGER_BIN_SCRIPTS_ALL_ABS)\n \t$(Q)mkdir -p $$(HBIN$(1)_H_$(2))\n \t$(Q)mkdir -p $$(HLIB$(1)_H_$(2))/rustlib/etc\n-\t$(Q)install $(DEBUGGER_BIN_SCRIPTS_ABS) $$(HBIN$(1)_H_$(2))\n-\t$(Q)install $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $$(HLIB$(1)_H_$(2))/rustlib/etc\n+\t$(Q)install $$(DEBUGGER_BIN_SCRIPTS_ALL_ABS) $$(HBIN$(1)_H_$(2))\n+\t$(Q)install $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ALL_ABS) $$(HLIB$(1)_H_$(2))/rustlib/etc\n \t$(Q)touch $$@\n+\n+tmp/install-debugger-scripts$(1)_H_$(2)-none.done:\n+\t$(Q)touch $$@\n+\n endef\n \n # Expand host make-targets for all stages\n@@ -44,12 +95,36 @@ $(foreach stage,$(STAGES), \\\n # $(3) is the host triple\n define DEF_INSTALL_DEBUGGER_SCRIPTS_TARGET\n \n-tmp/install-debugger-scripts$(1)_T_$(2)_H_$(3).done: $$(DEBUGGER_SCRIPTS_ALL)\n+tmp/install-debugger-scripts$(1)_T_$(2)_H_$(3)-gdb.done: \\\n+  $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS) \\\n+  $$(DEBUGGER_BIN_SCRIPTS_GDB_ABS)\n+\t$(Q)mkdir -p $$(TBIN$(1)_T_$(2)_H_$(3))\n+\t$(Q)mkdir -p $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n+\t$(Q)install $(DEBUGGER_BIN_SCRIPTS_GDB_ABS) $$(TBIN$(1)_T_$(2)_H_$(3))\n+\t$(Q)install $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS) $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n+\t$(Q)touch $$@\n+\n+tmp/install-debugger-scripts$(1)_T_$(2)_H_$(3)-lldb.done: \\\n+  $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS) \\\n+  $$(DEBUGGER_BIN_SCRIPTS_LLDB_ABS)\n \t$(Q)mkdir -p $$(TBIN$(1)_T_$(2)_H_$(3))\n \t$(Q)mkdir -p $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n-\t$(Q)install $(DEBUGGER_BIN_SCRIPTS_ABS) $$(TBIN$(1)_T_$(2)_H_$(3))\n-\t$(Q)install $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n+\t$(Q)install $(DEBUGGER_BIN_SCRIPTS_LLDB_ABS) $$(TBIN$(1)_T_$(2)_H_$(3))\n+\t$(Q)install $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS) $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n \t$(Q)touch $$@\n+\n+tmp/install-debugger-scripts$(1)_T_$(2)_H_$(3)-all.done: \\\n+  $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ALL_ABS) \\\n+  $$(DEBUGGER_BIN_SCRIPTS_ALL_ABS)\n+\t$(Q)mkdir -p $$(TBIN$(1)_T_$(2)_H_$(3))\n+\t$(Q)mkdir -p $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n+\t$(Q)install $(DEBUGGER_BIN_SCRIPTS_ALL_ABS) $$(TBIN$(1)_T_$(2)_H_$(3))\n+\t$(Q)install $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ALL_ABS) $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n+\t$(Q)touch $$@\n+\n+tmp/install-debugger-scripts$(1)_T_$(2)_H_$(3)-none.done:\n+\t$(Q)touch $$@\n+\n endef\n \n # Expand target make-targets for all stages"}, {"sha": "a8b331c6cc2399c7f5011c9dba02232e1dd76220", "filename": "mk/dist.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -35,7 +35,7 @@ LICENSE.txt: $(S)COPYRIGHT $(S)LICENSE-APACHE $(S)LICENSE-MIT\n # Source tarball\n ######################################################################\n \n-PKG_TAR = dist/$(PKG_NAME).tar.gz\n+PKG_TAR = dist/$(PKG_NAME)-src.tar.gz\n \n PKG_GITMODULES := $(S)src/llvm $(S)src/compiler-rt \\\n \t\t  $(S)src/rt/hoedown $(S)src/jemalloc\n@@ -241,8 +241,8 @@ dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n \t@$(call E, build: $$@)\n # Copy essential gcc components into installer\n ifdef CFG_WINDOWSY_$(1)\n-\t$$(Q)rm -Rf dist/win-rust-gcc-$(1)\n-\t$$(Q)$$(CFG_PYTHON) $$(S)src/etc/make-win-dist.py tmp/dist/$$(PKG_NAME)-$(1)-image dist/win-rust-gcc-$(1) $(1)\n+\t$$(Q)rm -Rf tmp/dist/win-rust-gcc-$(1)\n+\t$$(Q)$$(CFG_PYTHON) $$(S)src/etc/make-win-dist.py tmp/dist/$$(PKG_NAME)-$(1)-image tmp/dist/win-rust-gcc-$(1) $(1)\n \t$$(Q)cp -r $$(S)src/etc/third-party tmp/dist/$$(PKG_NAME)-$(1)-image/share/doc/\n endif\n \t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\"}, {"sha": "32167dfd8999019c5b5ee13bd23611ce8e0b6587", "filename": "mk/main.mk", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -15,6 +15,9 @@\n # The version number\n CFG_RELEASE_NUM=0.13.0\n \n+# An optional number to put after the label, e.g. '2' -> '-beta2'\n+CFG_BETA_CYCLE=\n+\n CFG_FILENAME_EXTRA=4e7c5e5c\n \n ifeq ($(CFG_RELEASE_CHANNEL),stable)\n@@ -24,12 +27,13 @@ CFG_RELEASE=$(CFG_RELEASE_NUM)\n CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),beta)\n-CFG_RELEASE=$(CFG_RELEASE_NUM)-beta\n+# The beta channel is temporarily called 'alpha'\n+CFG_RELEASE=$(CFG_RELEASE_NUM)-alpha$(CFG_BETA_CYCLE)\n # When building beta/nightly distributables just reuse the same \"beta\"\n # name so when we upload we'll always override the previous\n # nighly. This doesn't actually impact the version reported by rustc -\n # it's just for file naming.\n-CFG_PACKAGE_VERS=beta\n+CFG_PACKAGE_VERS=alpha\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),nightly)\n CFG_RELEASE=$(CFG_RELEASE_NUM)-nightly\n@@ -325,6 +329,12 @@ export CFG_DISABLE_INJECT_STD_VERSION\n # Per-stage targets and runner\n ######################################################################\n \n+# Valid setting-strings are 'all', 'none', 'gdb', 'lldb'\n+# This 'function' will determine which debugger scripts to copy based on a\n+# target triple. See debuggers.mk for more information.\n+TRIPLE_TO_DEBUGGER_SCRIPT_SETTING=\\\n+ $(if $(findstring windows,$(1)),none,$(if $(findstring darwin,$(1)),lldb,gdb))\n+\n STAGES = 0 1 2 3\n \n define SREQ\n@@ -357,7 +367,7 @@ else\n HSREQ$(1)_H_$(3) = \\\n \t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n \t$$(MKFILE_DEPS) \\\n-\ttmp/install-debugger-scripts$(1)_H_$(3).done\n+\ttmp/install-debugger-scripts$(1)_H_$(3)-$$(call TRIPLE_TO_DEBUGGER_SCRIPT_SETTING,$(3)).done\n endif\n \n # Prerequisites for using the stageN compiler to build target artifacts\n@@ -372,7 +382,7 @@ SREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(foreach dep,$$(TARGET_CRATES), \\\n \t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n-\ttmp/install-debugger-scripts$(1)_T_$(2)_H_$(3).done\n+\ttmp/install-debugger-scripts$(1)_T_$(2)_H_$(3)-$$(call TRIPLE_TO_DEBUGGER_SCRIPT_SETTING,$(2)).done\n \n # Prerequisites for a working stageN compiler and complete set of target\n # libraries"}, {"sha": "52fbbef81bd78e4098fd9ecafd1b3981f1ea70c6", "filename": "mk/prepare.mk", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -144,6 +144,27 @@ prepare-target-$(2)-host-$(3)-$(1)-$(4): prepare-maybe-clean-$(4) \\\n           $$(call PREPARE_LIB,libcompiler-rt.a),),),)\n endef\n \n+define INSTALL_GDB_DEBUGGER_SCRIPTS_COMMANDS\n+\t$(Q)$(PREPARE_BIN_CMD) $(DEBUGGER_BIN_SCRIPTS_GDB_ABS) $(PREPARE_DEST_BIN_DIR)\n+\t$(Q)$(PREPARE_LIB_CMD) $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS) $(PREPARE_DEST_LIB_DIR)/rustlib/etc\n+endef\n+\n+define INSTALL_LLDB_DEBUGGER_SCRIPTS_COMMANDS\n+\t$(Q)$(PREPARE_BIN_CMD) $(DEBUGGER_BIN_SCRIPTS_LLDB_ABS) $(PREPARE_DEST_BIN_DIR)\n+\t$(Q)$(PREPARE_LIB_CMD) $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS) $(PREPARE_DEST_LIB_DIR)/rustlib/etc\n+endef\n+\n+define INSTALL_NO_DEBUGGER_SCRIPTS_COMMANDS\n+\t$(Q)echo \"No debugger scripts will be installed for host $(PREPARE_HOST)\"\n+endef\n+\n+# $(1) is PREPARE_HOST\n+INSTALL_DEBUGGER_SCRIPT_COMMANDS=$(if $(findstring windows,$(1)),\\\n+                                   $(INSTALL_NO_DEBUGGER_SCRIPTS_COMMANDS),\\\n+                                   $(if $(findstring darwin,$(1)),\\\n+                                     $(INSTALL_LLDB_DEBUGGER_SCRIPTS_COMMANDS),\\\n+                                     $(INSTALL_GDB_DEBUGGER_SCRIPTS_COMMANDS)))\n+\n define DEF_PREPARE\n \n prepare-base-$(1): PREPARE_SOURCE_DIR=$$(PREPARE_HOST)/stage$$(PREPARE_STAGE)\n@@ -170,9 +191,10 @@ prepare-host-dirs-$(1): prepare-maybe-clean-$(1)\n \t$$(call PREPARE_DIR,$$(PREPARE_DEST_LIB_DIR)/rustlib/etc)\n \t$$(call PREPARE_DIR,$$(PREPARE_DEST_MAN_DIR))\n \n-prepare-debugger-scripts-$(1): prepare-host-dirs-$(1) $(DEBUGGER_SCRIPTS_ALL)\n-\t$$(Q)$$(PREPARE_BIN_CMD) $(DEBUGGER_BIN_SCRIPTS_ABS) $$(PREPARE_DEST_BIN_DIR)\n-\t$$(Q)$$(PREPARE_LIB_CMD) $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $$(PREPARE_DEST_LIB_DIR)/rustlib/etc\n+prepare-debugger-scripts-$(1): prepare-host-dirs-$(1) \\\n+                               $$(DEBUGGER_BIN_SCRIPTS_ALL_ABS) \\\n+                               $$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ALL_ABS)\n+\t$$(call INSTALL_DEBUGGER_SCRIPT_COMMANDS,$$(PREPARE_HOST))\n \n $$(foreach tool,$$(PREPARE_TOOLS), \\\n   $$(foreach host,$$(CFG_HOST), \\"}, {"sha": "c513aec0b843a9ac793fc7276b46718ceb4b0dab", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -32,6 +32,7 @@ use std::io::process;\n use std::io::timer;\n use std::io;\n use std::os;\n+use std::iter::repeat;\n use std::str;\n use std::string::String;\n use std::thread::Thread;\n@@ -367,7 +368,6 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let DebuggerCommands {\n         commands,\n         check_lines,\n-        use_gdb_pretty_printer,\n         breakpoint_lines\n     } = parse_debugger_commands(testfile, \"gdb\");\n     let mut cmds = commands.connect(\"\\n\");\n@@ -521,16 +521,11 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                     if header::gdb_version_to_int(version.as_slice()) >\n                         header::gdb_version_to_int(\"7.4\") {\n                         // Add the directory containing the pretty printers to\n-                        // GDB's script auto loading safe path ...\n+                        // GDB's script auto loading safe path\n                         script_str.push_str(\n                             format!(\"add-auto-load-safe-path {}\\n\",\n                                     rust_pp_module_abs_path.replace(\"\\\\\", \"\\\\\\\\\").as_slice())\n                                 .as_slice());\n-                        // ... and also the test directory\n-                        script_str.push_str(\n-                            format!(\"add-auto-load-safe-path {}\\n\",\n-                                    config.build_base.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))\n-                                .as_slice());\n                     }\n                 }\n                 _ => {\n@@ -543,6 +538,9 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             // pretty printing, it just tells GDB to print values on one line:\n             script_str.push_str(\"set print pretty off\\n\");\n \n+            // Add the pretty printer directory to GDB's source-file search path\n+            script_str.push_str(format!(\"directory {}\\n\", rust_pp_module_abs_path)[]);\n+\n             // Load the target executable\n             script_str.push_str(format!(\"file {}\\n\",\n                                         exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))\n@@ -564,12 +562,6 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                              script_str.as_slice(),\n                              \"debugger.script\");\n \n-            if use_gdb_pretty_printer {\n-                // Only emit the gdb auto-loading script if pretty printers\n-                // should actually be loaded\n-                dump_gdb_autoload_script(config, testfile);\n-            }\n-\n             // run debugger script with gdb\n             #[cfg(windows)]\n             fn debugger() -> String {\n@@ -611,19 +603,6 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     }\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n-\n-    fn dump_gdb_autoload_script(config: &Config, testfile: &Path) {\n-        let mut script_path = output_base_name(config, testfile);\n-        let mut script_file_name = script_path.filename().unwrap().to_vec();\n-        script_file_name.push_all(\"-gdb.py\".as_bytes());\n-        script_path.set_filename(script_file_name.as_slice());\n-\n-        let script_content = \"import gdb_rust_pretty_printing\\n\\\n-                              gdb_rust_pretty_printing.register_printers(gdb.current_objfile())\\n\"\n-                             .as_bytes();\n-\n-        File::create(&script_path).write(script_content).unwrap();\n-    }\n }\n \n fn find_rust_src_root(config: &Config) -> Option<Path> {\n@@ -781,7 +760,6 @@ struct DebuggerCommands {\n     commands: Vec<String>,\n     check_lines: Vec<String>,\n     breakpoint_lines: Vec<uint>,\n-    use_gdb_pretty_printer: bool\n }\n \n fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n@@ -794,7 +772,6 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n     let mut breakpoint_lines = vec!();\n     let mut commands = vec!();\n     let mut check_lines = vec!();\n-    let mut use_gdb_pretty_printer = false;\n     let mut counter = 1;\n     let mut reader = BufferedReader::new(File::open(file_path).unwrap());\n     for line in reader.lines() {\n@@ -804,10 +781,6 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n                     breakpoint_lines.push(counter);\n                 }\n \n-                if line.as_slice().contains(\"gdb-use-pretty-printer\") {\n-                    use_gdb_pretty_printer = true;\n-                }\n-\n                 header::parse_name_value_directive(\n                         line.as_slice(),\n                         command_directive.as_slice()).map(|cmd| {\n@@ -832,7 +805,6 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n         commands: commands,\n         check_lines: check_lines,\n         breakpoint_lines: breakpoint_lines,\n-        use_gdb_pretty_printer: use_gdb_pretty_printer,\n     }\n }\n \n@@ -976,8 +948,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                          proc_res: &ProcRes) {\n \n     // true if we found the error in question\n-    let mut found_flags = Vec::from_elem(\n-        expected_errors.len(), false);\n+    let mut found_flags: Vec<_> = repeat(false).take(expected_errors.len()).collect();\n \n     if proc_res.status.success() {\n         fatal(\"process did not return an error status\");\n@@ -1337,7 +1308,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     // Add the arguments in the run_flags directive\n     args.extend(split_maybe_args(&props.run_flags).into_iter());\n \n-    let prog = args.remove(0).unwrap();\n+    let prog = args.remove(0);\n     return ProcArgs {\n         prog: prog,\n         args: args,"}, {"sha": "fe65f4bd7f53d1277223187511e06ff1ac2d6860", "filename": "src/doc/guide.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -460,7 +460,7 @@ x = 10i;\n There is no single reason that bindings are immutable by default, but we can\n think about it through one of Rust's primary focuses: safety. If you forget to\n say `mut`, the compiler will catch it, and let you know that you have mutated\n-something you may not have cared to mutate. If bindings were mutable by\n+something you may not have intended to mutate. If bindings were mutable by\n default, the compiler would not be able to tell you this. If you _did_ intend\n mutation, then the solution is quite easy: add `mut`.\n \n@@ -889,9 +889,8 @@ fn hello(name: &str) {\n When writing doc comments, adding sections for any arguments, return values,\n and providing some examples of usage is very, very helpful.\n \n-You can use the `rustdoc` tool to generate HTML documentation from these doc\n-comments. We will talk more about `rustdoc` when we get to modules, as\n-generally, you want to export documentation for a full module.\n+You can use the [`rustdoc`](rustdoc.html) tool to generate HTML documentation\n+from these doc comments.\n \n # Compound Data Types\n "}, {"sha": "755cac153d10d0f57eec3ad3cd1e841276ae8e69", "filename": "src/etc/gdb_load_rust_pretty_printers.py", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_load_rust_pretty_printers.py?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -0,0 +1,12 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import gdb_rust_pretty_printing\n+gdb_rust_pretty_printing.register_printers(gdb.current_objfile())"}, {"sha": "520a108da914cf965d6768a6d0f474fc5986f04e", "filename": "src/etc/rust-gdb", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fetc%2Frust-gdb", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fetc%2Frust-gdb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdb?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -0,0 +1,23 @@\n+#!/bin/sh\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Exit if anything fails\n+set -e\n+\n+# Find out where the pretty printer Python module is\n+RUSTC_SYSROOT=`rustc --print=sysroot`\n+GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n+\n+# Run GDB with the additional arguments that load the pretty printers\n+PYTHONPATH=\"$PYTHONPATH:$GDB_PYTHON_MODULE_DIRECTORY\" gdb \\\n+  -d \"$GDB_PYTHON_MODULE_DIRECTORY\" \\\n+  -iex \"add-auto-load-safe-path $GDB_PYTHON_MODULE_DIRECTORY\" \\\n+  \"$@\""}, {"sha": "1f7923e1caff2b81fa9e0fb9af3be99bc52249a9", "filename": "src/grammar/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fgrammar%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fgrammar%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FREADME.md?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1,7 +1,7 @@\n Reference grammar.\n \n Uses [antlr4](http://www.antlr.org/) and a custom Rust tool to compare\n-ASTs/token streams generated. You can use the `check-syntax` make target to\n+ASTs/token streams generated. You can use the `check-lexer` make target to\n run all of the available tests.\n \n To use manually:\n@@ -12,7 +12,7 @@ javac *.java\n rustc -O verify.rs\n for file in ../*/**.rs; do\n     echo $file;\n-    grun RustLexer tokens -tokens < $file | ./verify $file || break\n+    grun RustLexer tokens -tokens < $file | ./verify $file RustLexer.tokens || break\n done\n ```\n "}, {"sha": "88de5db41fe7b555369e2ff6e595e8bda6e8c650", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,8 +112,64 @@ LIT_INTEGER\n   ;\n \n LIT_FLOAT\n-  : [0-9][0-9_]* ( '.' {_input.LA(1) != '.'}?\n-                 | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n+  : [0-9][0-9_]* ('.' {\n+        /* dot followed by another dot is a range, no float */\n+        _input.LA(1) != '.' &&\n+        /* dot followed by an identifier is an integer with a function call, no float */\n+        _input.LA(1) != '_' &&\n+        _input.LA(1) != 'a' &&\n+        _input.LA(1) != 'b' &&\n+        _input.LA(1) != 'c' &&\n+        _input.LA(1) != 'd' &&\n+        _input.LA(1) != 'e' &&\n+        _input.LA(1) != 'f' &&\n+        _input.LA(1) != 'g' &&\n+        _input.LA(1) != 'h' &&\n+        _input.LA(1) != 'i' &&\n+        _input.LA(1) != 'j' &&\n+        _input.LA(1) != 'k' &&\n+        _input.LA(1) != 'l' &&\n+        _input.LA(1) != 'm' &&\n+        _input.LA(1) != 'n' &&\n+        _input.LA(1) != 'o' &&\n+        _input.LA(1) != 'p' &&\n+        _input.LA(1) != 'q' &&\n+        _input.LA(1) != 'r' &&\n+        _input.LA(1) != 's' &&\n+        _input.LA(1) != 't' &&\n+        _input.LA(1) != 'u' &&\n+        _input.LA(1) != 'v' &&\n+        _input.LA(1) != 'w' &&\n+        _input.LA(1) != 'x' &&\n+        _input.LA(1) != 'y' &&\n+        _input.LA(1) != 'z' &&\n+        _input.LA(1) != 'A' &&\n+        _input.LA(1) != 'B' &&\n+        _input.LA(1) != 'C' &&\n+        _input.LA(1) != 'D' &&\n+        _input.LA(1) != 'E' &&\n+        _input.LA(1) != 'F' &&\n+        _input.LA(1) != 'G' &&\n+        _input.LA(1) != 'H' &&\n+        _input.LA(1) != 'I' &&\n+        _input.LA(1) != 'J' &&\n+        _input.LA(1) != 'K' &&\n+        _input.LA(1) != 'L' &&\n+        _input.LA(1) != 'M' &&\n+        _input.LA(1) != 'N' &&\n+        _input.LA(1) != 'O' &&\n+        _input.LA(1) != 'P' &&\n+        _input.LA(1) != 'Q' &&\n+        _input.LA(1) != 'R' &&\n+        _input.LA(1) != 'S' &&\n+        _input.LA(1) != 'T' &&\n+        _input.LA(1) != 'U' &&\n+        _input.LA(1) != 'V' &&\n+        _input.LA(1) != 'W' &&\n+        _input.LA(1) != 'X' &&\n+        _input.LA(1) != 'Y' &&\n+        _input.LA(1) != 'Z'\n+  }? | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n   ;\n \n LIT_STR"}, {"sha": "cb269bbdb0ade0dc343bc3513bc9ce82698a0119", "filename": "src/grammar/check.sh", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fgrammar%2Fcheck.sh", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fgrammar%2Fcheck.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fcheck.sh?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -11,6 +11,10 @@ if [ \"${VERBOSE}\" == \"1\" ]; then\n     set -x\n fi\n \n+passed=0\n+failed=0\n+skipped=0\n+\n check() {\n     grep --silent \"// ignore-lexer-test\" $1;\n \n@@ -21,14 +25,27 @@ check() {\n         # seem to have anny effect.\n         if $3 RustLexer tokens -tokens < $1 | $4 $1 $5; then\n             echo \"pass: $1\"\n+            passed=`expr $passed + 1`\n         else\n             echo \"fail: $1\"\n+            failed=`expr $failed + 1`\n         fi\n     else\n         echo \"skip: $1\"\n+        skipped=`expr $skipped + 1`\n     fi\n }\n \n for file in $(find $1 -iname '*.rs' ! -path '*/test/compile-fail*'); do\n     check $file $2 $3 $4 $5\n done\n+\n+printf \"\\ntest result: \"\n+\n+if [ $failed -eq 0 ]; then\n+    printf \"ok. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n+else\n+    printf \"failed. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n+    exit 1\n+fi\n+"}, {"sha": "820a3838978c0173c43aac5fc4d31a86c06c7b49", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -68,6 +68,7 @@\n //! ```\n \n use core::atomic;\n+use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::borrow::BorrowFrom;\n use core::clone::Clone;\n use core::fmt::{mod, Show};\n@@ -95,7 +96,7 @@ use heap::deallocate;\n /// use std::thread::Thread;\n ///\n /// fn main() {\n-///     let numbers = Vec::from_fn(100, |i| i as f32);\n+///     let numbers: Vec<_> = range(0, 100u32).map(|i| i as f32).collect();\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in range(0u, 10) {\n@@ -182,7 +183,7 @@ impl<T> Arc<T> {\n     #[experimental = \"Weak pointers may not belong in this module.\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n-        self.inner().weak.fetch_add(1, atomic::Relaxed);\n+        self.inner().weak.fetch_add(1, Relaxed);\n         Weak { _ptr: self._ptr }\n     }\n }\n@@ -201,12 +202,12 @@ impl<T> Arc<T> {\n /// Get the number of weak references to this value.\n #[inline]\n #[experimental]\n-pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(atomic::SeqCst) - 1 }\n+pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[experimental]\n-pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(atomic::SeqCst) }\n+pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n #[stable]\n impl<T> Clone for Arc<T> {\n@@ -234,7 +235,7 @@ impl<T> Clone for Arc<T> {\n         // must already provide any required synchronization.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        self.inner().strong.fetch_add(1, atomic::Relaxed);\n+        self.inner().strong.fetch_add(1, Relaxed);\n         Arc { _ptr: self._ptr }\n     }\n }\n@@ -273,8 +274,8 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as a weak reference, so we only\n         // clone if there is an additional reference of either kind.\n-        if self.inner().strong.load(atomic::SeqCst) != 1 ||\n-           self.inner().weak.load(atomic::SeqCst) != 1 {\n+        if self.inner().strong.load(SeqCst) != 1 ||\n+           self.inner().weak.load(SeqCst) != 1 {\n             *self = Arc::new((**self).clone())\n         }\n         // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n@@ -322,7 +323,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n         // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n         // unless we are going to delete the object. This same logic applies to the below\n         // `fetch_sub` to the `weak` count.\n-        if self.inner().strong.fetch_sub(1, atomic::Release) != 1 { return }\n+        if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n \n         // This fence is needed to prevent reordering of use of the data and deletion of the data.\n         // Because it is marked `Release`, the decreasing of the reference count synchronizes with\n@@ -339,14 +340,14 @@ impl<T: Sync + Send> Drop for Arc<T> {\n         // > operation before deleting the object.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        atomic::fence(atomic::Acquire);\n+        atomic::fence(Acquire);\n \n         // Destroy the data at this time, even though we may not free the box allocation itself\n         // (there may still be weak pointers lying around).\n         unsafe { drop(ptr::read(&self.inner().data)); }\n \n-        if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n-            atomic::fence(atomic::Acquire);\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n@@ -377,9 +378,9 @@ impl<T: Sync + Send> Weak<T> {\n         // count hits 0 is must never be above 0.\n         let inner = self.inner();\n         loop {\n-            let n = inner.strong.load(atomic::SeqCst);\n+            let n = inner.strong.load(SeqCst);\n             if n == 0 { return None }\n-            let old = inner.strong.compare_and_swap(n, n + 1, atomic::SeqCst);\n+            let old = inner.strong.compare_and_swap(n, n + 1, SeqCst);\n             if old == n { return Some(Arc { _ptr: self._ptr }) }\n         }\n     }\n@@ -409,7 +410,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         // See comments in Arc::clone() for why this is relaxed\n-        self.inner().weak.fetch_add(1, atomic::Relaxed);\n+        self.inner().weak.fetch_add(1, Relaxed);\n         Weak { _ptr: self._ptr }\n     }\n }\n@@ -450,15 +451,15 @@ impl<T: Sync + Send> Drop for Weak<T> {\n \n         // If we find out that we were the last weak pointer, then its time to deallocate the data\n         // entirely. See the discussion in Arc::drop() about the memory orderings\n-        if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n-            atomic::fence(atomic::Acquire);\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n     }\n }\n \n-#[unstable = \"waiting on PartialEq\"]\n+#[stable]\n impl<T: PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc<T>`s.\n     ///\n@@ -490,7 +491,7 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n-#[unstable = \"waiting on PartialOrd\"]\n+#[stable]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc<T>`s.\n     ///\n@@ -569,11 +570,11 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n-#[unstable = \"waiting on Ord\"]\n+#[stable]\n impl<T: Ord> Ord for Arc<T> {\n     fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n-#[unstable = \"waiting on Eq\"]\n+#[stable]\n impl<T: Eq> Eq for Arc<T> {}\n \n impl<T: fmt::Show> fmt::Show for Arc<T> {\n@@ -599,6 +600,7 @@ mod tests {\n     use std::option::Option::{Some, None};\n     use std::str::Str;\n     use std::sync::atomic;\n+    use std::sync::atomic::Ordering::{Acquire, SeqCst};\n     use std::task;\n     use std::kinds::Send;\n     use std::vec::Vec;\n@@ -613,7 +615,7 @@ mod tests {\n             unsafe {\n                 match *self {\n                     Canary(c) => {\n-                        (*c).fetch_add(1, atomic::SeqCst);\n+                        (*c).fetch_add(1, SeqCst);\n                     }\n                 }\n             }\n@@ -732,17 +734,17 @@ mod tests {\n         let mut canary = atomic::AtomicUint::new(0);\n         let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUint));\n         drop(x);\n-        assert!(canary.load(atomic::Acquire) == 1);\n+        assert!(canary.load(Acquire) == 1);\n     }\n \n     #[test]\n     fn drop_arc_weak() {\n         let mut canary = atomic::AtomicUint::new(0);\n         let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUint));\n         let arc_weak = arc.downgrade();\n-        assert!(canary.load(atomic::Acquire) == 0);\n+        assert!(canary.load(Acquire) == 0);\n         drop(arc);\n-        assert!(canary.load(atomic::Acquire) == 1);\n+        assert!(canary.load(Acquire) == 1);\n         drop(arc_weak);\n     }\n "}, {"sha": "74f0599e486e1da696f2619ceaa6a0248db948e1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -72,12 +72,14 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n+#[stable]\n impl<Sized? T: PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n+#[stable]\n impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -92,12 +94,14 @@ impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n+#[stable]\n impl<Sized? T: Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n-}\n+\n+#[stable]}\n impl<Sized? T: Eq> Eq for Box<T> {}\n \n impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {"}, {"sha": "75d4342083b983f06505480ecf5dff78040f9dc7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -452,7 +452,7 @@ impl<T: Default> Default for Rc<T> {\n     }\n }\n \n-#[unstable = \"PartialEq is unstable.\"]\n+#[stable]\n impl<T: PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -487,10 +487,10 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n-#[unstable = \"Eq is unstable.\"]\n+#[stable]\n impl<T: Eq> Eq for Rc<T> {}\n \n-#[unstable = \"PartialOrd is unstable.\"]\n+#[stable]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -575,7 +575,7 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n-#[unstable = \"Ord is unstable.\"]\n+#[stable]\n impl<T: Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///"}, {"sha": "2427422f743208bbceb77fcc037ce299def3e0b1", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -66,7 +66,7 @@\n //! // for a simpler implementation.\n //! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n //!     // dist[node] = current shortest distance from `start` to `node`\n-//!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n+//!     let mut dist: Vec<_> = range(0, adj_list.len()).map(|_| uint::MAX).collect();\n //!\n //!     let mut heap = BinaryHeap::new();\n //!\n@@ -563,6 +563,13 @@ pub struct Iter <'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> {\n+        Iter { iter: self.iter.clone() }\n+    }\n+}\n+\n impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }"}, {"sha": "e29f19bbed3696ec7193e9b8e681a60a98124453", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -85,7 +85,7 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take};\n+use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take, repeat};\n use core::iter;\n use core::num::Int;\n use core::slice::{Iter, IterMut};\n@@ -267,7 +267,7 @@ impl Bitv {\n     pub fn from_elem(nbits: uint, bit: bool) -> Bitv {\n         let nblocks = blocks_for_bits(nbits);\n         let mut bitv = Bitv {\n-            storage: Vec::from_elem(nblocks, if bit { !0u32 } else { 0u32 }),\n+            storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n             nbits: nbits\n         };\n         bitv.fix_last_block();\n@@ -651,7 +651,7 @@ impl Bitv {\n \n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n-        Vec::from_fn(len, |i|\n+        range(0, len).map(|i|\n             bit(self, i, 0) |\n             bit(self, i, 1) |\n             bit(self, i, 2) |\n@@ -660,7 +660,7 @@ impl Bitv {\n             bit(self, i, 5) |\n             bit(self, i, 6) |\n             bit(self, i, 7)\n-        )\n+        ).collect()\n     }\n \n     /// Deprecated: Use `iter().collect()`.\n@@ -834,7 +834,7 @@ impl Bitv {\n         // Allocate new words, if needed\n         if new_nblocks > self.storage.len() {\n             let to_add = new_nblocks - self.storage.len();\n-            self.storage.grow(to_add, full_value);\n+            self.storage.extend(repeat(full_value).take(to_add));\n         }\n \n         // Adjust internal bit count\n@@ -965,13 +965,15 @@ impl Clone for Bitv {\n     }\n }\n \n+#[stable]\n impl PartialOrd for Bitv {\n     #[inline]\n     fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl Ord for Bitv {\n     #[inline]\n     fn cmp(&self, other: &Bitv) -> Ordering {\n@@ -997,6 +999,7 @@ impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     }\n }\n \n+#[stable]\n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n@@ -1007,9 +1010,11 @@ impl cmp::PartialEq for Bitv {\n     }\n }\n \n+#[stable]\n impl cmp::Eq for Bitv {}\n \n /// An iterator for `Bitv`.\n+#[deriving(Clone)]\n pub struct Bits<'a> {\n     bitv: &'a Bitv,\n     next_idx: uint,\n@@ -1129,6 +1134,7 @@ impl Extend<uint> for BitvSet {\n     }\n }\n \n+#[stable]\n impl PartialOrd for BitvSet {\n     #[inline]\n     fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n@@ -1137,6 +1143,7 @@ impl PartialOrd for BitvSet {\n     }\n }\n \n+#[stable]\n impl Ord for BitvSet {\n     #[inline]\n     fn cmp(&self, other: &BitvSet) -> Ordering {\n@@ -1145,6 +1152,7 @@ impl Ord for BitvSet {\n     }\n }\n \n+#[stable]\n impl cmp::PartialEq for BitvSet {\n     #[inline]\n     fn eq(&self, other: &BitvSet) -> bool {\n@@ -1153,6 +1161,7 @@ impl cmp::PartialEq for BitvSet {\n     }\n }\n \n+#[stable]\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n@@ -1739,12 +1748,14 @@ impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n }\n \n /// An iterator for `BitvSet`.\n+#[deriving(Clone)]\n pub struct BitPositions<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n }\n \n /// An iterator combining two `BitvSet` iterators.\n+#[deriving(Clone)]\n pub struct TwoBitPositions<'a> {\n     set: &'a BitvSet,\n     other: &'a BitvSet,"}, {"sha": "a3dff3e870658d54dfbc6c5add62e59f03e666e5", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -843,22 +843,26 @@ impl<K: Ord, V> Default for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n+#[stable]\n impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n+#[stable]\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {"}, {"sha": "3907f28092a379ebf7bf5a4204e479106ab1779b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -21,6 +21,7 @@ use core::prelude::*;\n use core::{slice, mem, ptr, cmp, num, raw};\n use core::iter::Zip;\n use core::borrow::BorrowFrom;\n+use core::ptr::Unique;\n use alloc::heap;\n \n /// Represents the result of an Insertion: either the item fit, or the node had to split\n@@ -51,11 +52,11 @@ pub struct Node<K, V> {\n     // These will never be null during normal usage of a `Node`. However, to avoid the need for a\n     // drop flag, `Node::drop` zeroes `keys`, signaling that the `Node` has already been cleaned\n     // up.\n-    keys: *mut K,\n-    vals: *mut V,\n+    keys: Unique<K>,\n+    vals: Unique<V>,\n \n     // In leaf nodes, this will be null, and no space will be allocated for edges.\n-    edges: *mut Node<K, V>,\n+    edges: Unique<Node<K, V>>,\n \n     // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n     // `_len + 1` edges. In a leaf node, there will never be any edges.\n@@ -255,7 +256,7 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.is_null() {\n+        if self.keys.0.is_null() {\n             // We have already cleaned up this node.\n             return;\n         }\n@@ -269,7 +270,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys = ptr::null_mut();\n+        self.keys.0 = ptr::null_mut();\n     }\n }\n \n@@ -285,9 +286,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n \n         Node {\n-            keys: buffer as *mut K,\n-            vals: buffer.offset(vals_offset as int) as *mut V,\n-            edges: buffer.offset(edges_offset as int) as *mut Node<K, V>,\n+            keys: Unique(buffer as *mut K),\n+            vals: Unique(buffer.offset(vals_offset as int) as *mut V),\n+            edges: Unique(buffer.offset(edges_offset as int) as *mut Node<K, V>),\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -303,9 +304,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n \n         Node {\n-            keys: buffer as *mut K,\n-            vals: unsafe { buffer.offset(vals_offset as int) as *mut V },\n-            edges: ptr::null_mut(),\n+            keys: Unique(buffer as *mut K),\n+            vals: Unique(unsafe { buffer.offset(vals_offset as int) as *mut V }),\n+            edges: Unique(ptr::null_mut()),\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -314,18 +315,18 @@ impl<K, V> Node<K, V> {\n     unsafe fn destroy(&mut self) {\n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n-        heap::deallocate(self.keys as *mut u8, size, alignment);\n+        heap::deallocate(self.keys.0 as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n         unsafe {(\n             mem::transmute(raw::Slice {\n-                data: self.keys as *const K,\n+                data: self.keys.0 as *const K,\n                 len: self.len()\n             }),\n             mem::transmute(raw::Slice {\n-                data: self.vals as *const V,\n+                data: self.vals.0 as *const V,\n                 len: self.len()\n             })\n         )}\n@@ -344,7 +345,7 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 mem::transmute(raw::Slice {\n-                    data: self.edges as *const Node<K, V>,\n+                    data: self.edges.0 as *const Node<K, V>,\n                     len: self.len() + 1\n                 })\n             }\n@@ -554,10 +555,10 @@ impl <K, V> Node<K, V> {\n         let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n         left_and_out._len = 1;\n         unsafe {\n-            ptr::write(left_and_out.keys_mut().unsafe_mut(0), key);\n-            ptr::write(left_and_out.vals_mut().unsafe_mut(0), value);\n-            ptr::write(left_and_out.edges_mut().unsafe_mut(0), node);\n-            ptr::write(left_and_out.edges_mut().unsafe_mut(1), right);\n+            ptr::write(left_and_out.keys_mut().get_unchecked_mut(0), key);\n+            ptr::write(left_and_out.vals_mut().get_unchecked_mut(0), value);\n+            ptr::write(left_and_out.edges_mut().get_unchecked_mut(0), node);\n+            ptr::write(left_and_out.edges_mut().get_unchecked_mut(1), right);\n         }\n     }\n \n@@ -573,7 +574,7 @@ impl <K, V> Node<K, V> {\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.is_null()\n+        self.edges.0.is_null()\n     }\n \n     /// if the node has too few elements\n@@ -636,7 +637,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n     /// making it more suitable for moving down a chain of nodes.\n     pub fn into_edge(self) -> &'a Node<K, V> {\n         unsafe {\n-            self.node.edges().unsafe_get(self.index)\n+            self.node.edges().get_unchecked(self.index)\n         }\n     }\n }\n@@ -647,7 +648,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n     /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n     pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n         unsafe {\n-            self.node.edges_mut().unsafe_mut(self.index)\n+            self.node.edges_mut().get_unchecked_mut(self.index)\n         }\n     }\n }\n@@ -721,7 +722,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n         unsafe {\n-            self.node.edges_mut().unsafe_mut(self.index)\n+            self.node.edges_mut().get_unchecked_mut(self.index)\n         }\n     }\n \n@@ -829,8 +830,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n         let (keys, vals) = self.node.as_slices();\n         unsafe {\n             (\n-                keys.unsafe_get(self.index),\n-                vals.unsafe_get(self.index)\n+                keys.get_unchecked(self.index),\n+                vals.get_unchecked(self.index)\n             )\n         }\n     }\n@@ -844,8 +845,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n         let (keys, vals) = self.node.as_slices_mut();\n         unsafe {\n             (\n-                keys.unsafe_mut(self.index),\n-                vals.unsafe_mut(self.index)\n+                keys.get_unchecked_mut(self.index),\n+                vals.get_unchecked_mut(self.index)\n             )\n         }\n     }\n@@ -869,14 +870,14 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef\n     // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     // /// handle.\n     // pub fn key(&'a self) -> &'a K {\n-    //     unsafe { self.node.keys().unsafe_get(self.index) }\n+    //     unsafe { self.node.keys().get_unchecked(self.index) }\n     // }\n     //\n     // /// Returns a reference to the value pointed-to by this handle. This doesn't return a\n     // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     // /// handle.\n     // pub fn val(&'a self) -> &'a V {\n-    //     unsafe { self.node.vals().unsafe_get(self.index) }\n+    //     unsafe { self.node.vals().get_unchecked(self.index) }\n     // }\n }\n \n@@ -886,14 +887,14 @@ impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<Node\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n     pub fn key_mut(&'a mut self) -> &'a mut K {\n-        unsafe { self.node.keys_mut().unsafe_mut(self.index) }\n+        unsafe { self.node.keys_mut().get_unchecked_mut(self.index) }\n     }\n \n     /// Returns a mutable reference to the value pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n     pub fn val_mut(&'a mut self) -> &'a mut V {\n-        unsafe { self.node.vals_mut().unsafe_mut(self.index) }\n+        unsafe { self.node.vals_mut().get_unchecked_mut(self.index) }\n     }\n }\n \n@@ -1057,7 +1058,7 @@ impl<K, V> Node<K, V> {\n                     vals: RawItems::from_slice(self.vals()),\n                     edges: RawItems::from_slice(self.edges()),\n \n-                    ptr: self.keys as *mut u8,\n+                    ptr: self.keys.0 as *mut u8,\n                     capacity: self.capacity(),\n                     is_leaf: self.is_leaf()\n                 },\n@@ -1077,7 +1078,7 @@ impl<K, V> Node<K, V> {\n         debug_assert!(!self.is_leaf());\n \n         unsafe {\n-            let ret = ptr::read(self.edges().unsafe_get(0));\n+            let ret = ptr::read(self.edges().get_unchecked(0));\n             self.destroy();\n             ptr::write(self, ret);\n         }\n@@ -1091,8 +1092,8 @@ impl<K, V> Node<K, V> {\n     unsafe fn push_kv(&mut self, key: K, val: V) {\n         let len = self.len();\n \n-        ptr::write(self.keys_mut().unsafe_mut(len), key);\n-        ptr::write(self.vals_mut().unsafe_mut(len), val);\n+        ptr::write(self.keys_mut().get_unchecked_mut(len), key);\n+        ptr::write(self.vals_mut().get_unchecked_mut(len), val);\n \n         self._len += 1;\n     }\n@@ -1102,7 +1103,7 @@ impl<K, V> Node<K, V> {\n     unsafe fn push_edge(&mut self, edge: Node<K, V>) {\n         let len = self.len();\n \n-        ptr::write(self.edges_mut().unsafe_mut(len), edge);\n+        ptr::write(self.edges_mut().get_unchecked_mut(len), edge);\n     }\n \n     // This must be followed by insert_edge on an internal node.\n@@ -1119,12 +1120,12 @@ impl<K, V> Node<K, V> {\n             self.len() - index\n         );\n \n-        ptr::write(self.keys_mut().unsafe_mut(index), key);\n-        ptr::write(self.vals_mut().unsafe_mut(index), val);\n+        ptr::write(self.keys_mut().get_unchecked_mut(index), key);\n+        ptr::write(self.vals_mut().get_unchecked_mut(index), val);\n \n         self._len += 1;\n \n-        self.vals_mut().unsafe_mut(index)\n+        self.vals_mut().get_unchecked_mut(index)\n     }\n \n     // This can only be called immediately after a call to insert_kv.\n@@ -1135,14 +1136,14 @@ impl<K, V> Node<K, V> {\n             self.edges().as_ptr().offset(index as int),\n             self.len() - index\n         );\n-        ptr::write(self.edges_mut().unsafe_mut(index), edge);\n+        ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n     }\n \n     // This must be followed by pop_edge on an internal node.\n     #[inline]\n     unsafe fn pop_kv(&mut self) -> (K, V) {\n-        let key = ptr::read(self.keys().unsafe_get(self.len() - 1));\n-        let val = ptr::read(self.vals().unsafe_get(self.len() - 1));\n+        let key = ptr::read(self.keys().get_unchecked(self.len() - 1));\n+        let val = ptr::read(self.vals().get_unchecked(self.len() - 1));\n \n         self._len -= 1;\n \n@@ -1152,16 +1153,16 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to pop_kv.\n     #[inline]\n     unsafe fn pop_edge(&mut self) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().unsafe_get(self.len() + 1));\n+        let edge = ptr::read(self.edges().get_unchecked(self.len() + 1));\n \n         edge\n     }\n \n     // This must be followed by remove_edge on an internal node.\n     #[inline]\n     unsafe fn remove_kv(&mut self, index: uint) -> (K, V) {\n-        let key = ptr::read(self.keys().unsafe_get(index));\n-        let val = ptr::read(self.vals().unsafe_get(index));\n+        let key = ptr::read(self.keys().get_unchecked(index));\n+        let val = ptr::read(self.vals().get_unchecked(index));\n \n         ptr::copy_memory(\n             self.keys_mut().as_mut_ptr().offset(index as int),\n@@ -1182,7 +1183,7 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to remove_kv.\n     #[inline]\n     unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().unsafe_get(index));\n+        let edge = ptr::read(self.edges().get_unchecked(index));\n \n         ptr::copy_memory(\n             self.edges_mut().as_mut_ptr().offset(index as int),\n@@ -1229,8 +1230,8 @@ impl<K, V> Node<K, V> {\n                 );\n             }\n \n-            let key = ptr::read(self.keys().unsafe_get(right_offset - 1));\n-            let val = ptr::read(self.vals().unsafe_get(right_offset - 1));\n+            let key = ptr::read(self.keys().get_unchecked(right_offset - 1));\n+            let val = ptr::read(self.vals().get_unchecked(right_offset - 1));\n \n             self._len = right_offset - 1;\n \n@@ -1249,8 +1250,8 @@ impl<K, V> Node<K, V> {\n             let old_len = self.len();\n             self._len += right.len() + 1;\n \n-            ptr::write(self.keys_mut().unsafe_mut(old_len), key);\n-            ptr::write(self.vals_mut().unsafe_mut(old_len), val);\n+            ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n+            ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n             ptr::copy_nonoverlapping_memory(\n                 self.keys_mut().as_mut_ptr().offset(old_len as int + 1),"}, {"sha": "82dabedd871a4c9648f9fd07b0f4ee08a9b99b45", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -770,6 +770,7 @@ impl<A> Extend<A> for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A: PartialEq> PartialEq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n@@ -782,14 +783,17 @@ impl<A: PartialEq> PartialEq for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A: Eq> Eq for DList<A> {}\n \n+#[stable]\n impl<A: PartialOrd> PartialOrd for DList<A> {\n     fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<A: Ord> Ord for DList<A> {\n     #[inline]\n     fn cmp(&self, other: &DList<A>) -> Ordering {\n@@ -1290,8 +1294,10 @@ mod tests {\n                     v.pop();\n                 }\n                 1 => {\n-                    m.pop_front();\n-                    v.remove(0);\n+                    if !v.is_empty() {\n+                        m.pop_front();\n+                        v.remove(0);\n+                    }\n                 }\n                 2 | 4 =>  {\n                     m.push_front(-i);"}, {"sha": "b484fc41ff6e5bed9e43cbdc8783749e66a949de", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -213,6 +213,16 @@ pub struct Iter<E> {\n     bits: uint,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<E> Clone for Iter<E> {\n+    fn clone(&self) -> Iter<E> {\n+        Iter {\n+            index: self.index,\n+            bits: self.bits,\n+        }\n+    }\n+}\n+\n impl<E:CLike> Iter<E> {\n     fn new(bits: uint) -> Iter<E> {\n         Iter { index: 0, bits: bits }"}, {"sha": "688214140c1be1ec999bd24dc1b9ca3d6a0e8e50", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -128,8 +128,8 @@ mod prelude {\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n-    pub use slice::{CloneSliceExt, VectorVector};\n-    pub use str::{IntoMaybeOwned, StrVector};\n+    pub use slice::{CloneSliceExt, SliceConcatExt};\n+    pub use str::IntoMaybeOwned;\n     pub use string::{String, ToString};\n     pub use vec::Vec;\n }"}, {"sha": "aeda7309064f723c99d19e70a263b1063ccd9888", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -48,6 +48,12 @@ pub struct RingBuf<T> {\n     ptr: *mut T\n }\n \n+#[stable]\n+unsafe impl<T: Send> Send for RingBuf<T> {}\n+\n+#[stable]\n+unsafe impl<T: Sync> Sync for RingBuf<T> {}\n+\n #[stable]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n@@ -1129,6 +1135,17 @@ pub struct Iter<'a, T:'a> {\n     head: uint\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> {\n+        Iter {\n+            ring: self.ring,\n+            tail: self.tail,\n+            head: self.head\n+        }\n+    }\n+}\n+\n impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n@@ -1137,7 +1154,7 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n         }\n         let tail = self.tail;\n         self.tail = wrap_index(self.tail + 1, self.ring.len());\n-        unsafe { Some(self.ring.unsafe_get(tail)) }\n+        unsafe { Some(self.ring.get_unchecked(tail)) }\n     }\n \n     #[inline]\n@@ -1154,7 +1171,7 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n             return None;\n         }\n         self.head = wrap_index(self.head - 1, self.ring.len());\n-        unsafe { Some(self.ring.unsafe_get(self.head)) }\n+        unsafe { Some(self.ring.get_unchecked(self.head)) }\n     }\n }\n \n@@ -1173,7 +1190,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n             None\n         } else {\n             let idx = wrap_index(self.tail + j, self.ring.len());\n-            unsafe { Some(self.ring.unsafe_get(idx)) }\n+            unsafe { Some(self.ring.get_unchecked(idx)) }\n         }\n     }\n }\n@@ -1290,21 +1307,25 @@ impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n \n impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n \n+#[stable]\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n+#[stable]\n impl<A: Eq> Eq for RingBuf<A> {}\n \n+#[stable]\n impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n     fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<A: Ord> Ord for RingBuf<A> {\n     #[inline]\n     fn cmp(&self, other: &RingBuf<A>) -> Ordering {"}, {"sha": "02b70c0f169d88e9fdc39ea7e85f828b773c5d11", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1145, "deletions": 1064, "changes": 2209, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -96,1245 +96,1318 @@ use core::mem::size_of;\n use core::mem;\n use core::ops::{FnMut,SliceMut};\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n-use core::prelude::{Ord, Ordering, PtrExt, Some, range};\n+use core::prelude::{Ord, Ordering, PtrExt, Some, range, IteratorCloneExt, Result};\n use core::ptr;\n use core::slice as core_slice;\n use self::Direction::*;\n \n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n+pub use core::slice::{Chunks, AsSlice, Windows};\n pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n-pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n-pub use core::slice::{MutSplits, MutChunks, Splits};\n+pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n+pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n-pub use core::slice::{from_raw_buf, from_raw_mut_buf, BinarySearchResult};\n+pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n-// Functional utilities\n+#[deprecated = \"use Iter instead\"]\n+pub type Items<'a, T:'a> = Iter<'a, T>;\n \n-#[allow(missing_docs)]\n-pub trait VectorVector<T> for Sized? {\n-    // FIXME #5898: calling these .concat and .connect conflicts with\n-    // StrVector::con{cat,nect}, since they have generic contents.\n-    /// Flattens a vector of vectors of `T` into a single `Vec<T>`.\n-    fn concat_vec(&self) -> Vec<T>;\n+#[deprecated = \"use IterMut instead\"]\n+pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n \n-    /// Concatenate a vector of vectors, placing a given separator between each.\n-    fn connect_vec(&self, sep: &T) -> Vec<T>;\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Basic slice extension methods\n+////////////////////////////////////////////////////////////////////////////////\n \n-impl<'a, T: Clone, V: AsSlice<T>> VectorVector<T> for [V] {\n-    fn concat_vec(&self) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = Vec::with_capacity(size);\n-        for v in self.iter() {\n-            result.push_all(v.as_slice())\n-        }\n-        result\n-    }\n+/// Allocating extension methods for slices.\n+#[unstable = \"needs associated types, may merge with other traits\"]\n+pub trait SliceExt<T> for Sized? {\n+    /// Sorts the slice, in place, using `compare` to compare\n+    /// elements.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [5i, 4, 1, 3, 2];\n+    /// v.sort_by(|a, b| a.cmp(b));\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_by(|a, b| b.cmp(a));\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n+    #[stable]\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n \n-    fn connect_vec(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = Vec::with_capacity(size + self.len());\n-        let mut first = true;\n-        for v in self.iter() {\n-            if first { first = false } else { result.push(sep.clone()) }\n-            result.push_all(v.as_slice())\n-        }\n-        result\n-    }\n-}\n+    /// Consumes `src` and moves as many elements as it can into `self`\n+    /// from the range [start,end).\n+    ///\n+    /// Returns the number of elements copied (the shorter of `self.len()`\n+    /// and `end - start`).\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A mutable vector of `T`\n+    /// * start - The index into `src` to start copying from\n+    /// * end - The index into `src` to stop copying from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut a = [1i, 2, 3, 4, 5];\n+    /// let b = vec![6i, 7, 8];\n+    /// let num_moved = a.move_from(b, 0, 3);\n+    /// assert_eq!(num_moved, 3);\n+    /// assert!(a == [6i, 7, 8, 4, 5]);\n+    /// ```\n+    #[experimental = \"uncertain about this API approach\"]\n+    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n \n-/// An iterator that yields the element swaps needed to produce\n-/// a sequence of all possible permutations for an indexed sequence of\n-/// elements. Each permutation is only a single swap apart.\n-///\n-/// The Steinhaus-Johnson-Trotter algorithm is used.\n-///\n-/// Generates even and odd permutations alternately.\n-///\n-/// The last generated swap is always (0, 1), and it returns the\n-/// sequence to its initial order.\n-pub struct ElementSwaps {\n-    sdir: Vec<SizeDirection>,\n-    /// If `true`, emit the last swap that returns the sequence to initial\n-    /// state.\n-    emit_reset: bool,\n-    swaps_made : uint,\n-}\n+    /// Returns a subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice(&self, start: uint, end: uint) -> &[T];\n \n-impl ElementSwaps {\n-    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    pub fn new(length: uint) -> ElementSwaps {\n-        // Initialize `sdir` with a direction that position should move in\n-        // (all negative at the beginning) and the `size` of the\n-        // element (equal to the original index).\n-        ElementSwaps{\n-            emit_reset: true,\n-            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n-            swaps_made: 0\n-        }\n-    }\n-}\n+    /// Returns a subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_from(&self, start: uint) -> &[T];\n \n-#[deriving(Copy)]\n-enum Direction { Pos, Neg }\n+    /// Returns a subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_to(&self, end: uint) -> &[T];\n \n-/// An `Index` and `Direction` together.\n-#[deriving(Copy)]\n-struct SizeDirection {\n-    size: uint,\n-    dir: Direction,\n-}\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    #[stable]\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n \n-impl Iterator<(uint, uint)> for ElementSwaps {\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        fn new_pos(i: uint, s: Direction) -> uint {\n-            i + match s { Pos => 1, Neg => -1 }\n-        }\n+    /// Returns an iterator over the slice\n+    #[stable]\n+    fn iter(&self) -> Iter<T>;\n \n-        // Find the index of the largest mobile element:\n-        // The direction should point into the vector, and the\n-        // swap should be with a smaller `size` element.\n-        let max = self.sdir.iter().map(|&x| x).enumerate()\n-                           .filter(|&(i, sd)|\n-                                new_pos(i, sd.dir) < self.sdir.len() &&\n-                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n-                           .max_by(|&(_, sd)| sd.size);\n-        match max {\n-            Some((i, sd)) => {\n-                let j = new_pos(i, sd.dir);\n-                self.sdir.swap(i, j);\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    #[stable]\n+    fn split<F>(&self, pred: F) -> Split<T, F>\n+                where F: FnMut(&T) -> bool;\n \n-                // Swap the direction of each larger SizeDirection\n-                for x in self.sdir.iter_mut() {\n-                    if x.size > sd.size {\n-                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n-                    }\n-                }\n-                self.swaps_made += 1;\n-                Some((i, j))\n-            },\n-            None => if self.emit_reset {\n-                self.emit_reset = false;\n-                if self.sdir.len() > 1 {\n-                    // The last swap\n-                    self.swaps_made += 1;\n-                    Some((0, 1))\n-                } else {\n-                    // Vector is of the form [] or [x], and the only permutation is itself\n-                    self.swaps_made += 1;\n-                    Some((0,0))\n-                }\n-            } else { None }\n-        }\n-    }\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[stable]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+                 where F: FnMut(&T) -> bool;\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        // For a vector of size n, there are exactly n! permutations.\n-        let n = range(2, self.sdir.len() + 1).product();\n-        (n - self.swaps_made, Some(n - self.swaps_made))\n-    }\n-}\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[stable]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+                  where F: FnMut(&T) -> bool;\n \n-/// An iterator that uses `ElementSwaps` to iterate through\n-/// all possible permutations of a vector.\n-///\n-/// The first iteration yields a clone of the vector as it is,\n-/// then each successive element is the vector with one\n-/// swap applied.\n-///\n-/// Generates even and odd permutations alternately.\n-pub struct Permutations<T> {\n-    swaps: ElementSwaps,\n-    v: Vec<T>,\n-}\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn windows(&self, size: uint) -> Windows<T>;\n \n-impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<Vec<T>> {\n-        match self.swaps.next() {\n-            None => None,\n-            Some((0,0)) => Some(self.v.clone()),\n-            Some((a, b)) => {\n-                let elt = self.v.clone();\n-                self.v.swap(a, b);\n-                Some(elt)\n-            }\n-        }\n-    }\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn chunks(&self, size: uint) -> Chunks<T>;\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.swaps.size_hint()\n-    }\n-}\n+    /// Returns the element of a slice at the given index, or `None` if the\n+    /// index is out of bounds.\n+    #[stable]\n+    fn get(&self, index: uint) -> Option<&T>;\n \n-/// Extension methods for boxed slices.\n-pub trait BoxedSliceExt<T> {\n-    /// Convert `self` into a vector without clones or allocation.\n-    fn into_vec(self) -> Vec<T>;\n-}\n+    /// Returns the first element of a slice, or `None` if it is empty.\n+    #[stable]\n+    fn first(&self) -> Option<&T>;\n+\n+    /// Deprecated: renamed to `first`.\n+    #[deprecated = \"renamed to `first`\"]\n+    fn head(&self) -> Option<&T> { self.first() }\n+\n+    /// Returns all but the first element of a slice.\n+    #[experimental = \"likely to be renamed\"]\n+    fn tail(&self) -> &[T];\n+\n+    /// Returns all but the last element of a slice.\n+    #[experimental = \"likely to be renamed\"]\n+    fn init(&self) -> &[T];\n+\n+    /// Returns the last element of a slice, or `None` if it is empty.\n+    #[stable]\n+    fn last(&self) -> Option<&T>;\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[stable]\n+    unsafe fn get_unchecked(&self, index: uint) -> &T;\n \n-impl<T> BoxedSliceExt<T> for Box<[T]> {\n-    #[experimental]\n-    fn into_vec(mut self) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n+    /// Deprecated: renamed to `get_unchecked`.\n+    #[deprecated = \"renamed to get_unchecked\"]\n+    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+        self.get_unchecked(index)\n     }\n-}\n-\n-/// Allocating extension methods for slices containing `Clone` elements.\n-pub trait CloneSliceExt<T> for Sized? {\n-    /// Copies `self` into a new `Vec`.\n-    fn to_vec(&self) -> Vec<T>;\n \n-    /// Partitions the vector into two vectors `(a, b)`, where all\n-    /// elements of `a` satisfy `f` and all elements of `b` do not.\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n+    /// Returns an unsafe pointer to the slice's buffer\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[stable]\n+    fn as_ptr(&self) -> *const T;\n \n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n+    /// Binary search a sorted slice with a comparator function.\n     ///\n-    /// # Examples\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n     ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n+    /// If a matching value is found then returns `Ok`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n     ///\n-    /// for p in perms {\n-    ///   println!(\"{}\", p);\n-    /// }\n-    /// ```\n+    /// # Example\n     ///\n-    /// Iterating through permutations one by one.\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n     ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    fn permutations(&self) -> Permutations<T>;\n+    #[stable]\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering;\n \n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n+    /// Return the number of elements in the slice\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[stable]\n+    fn len(&self) -> uint;\n+\n+    /// Returns true if the slice has a length of 0\n     ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n+    /// # Example\n     ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n-    /// Returns a copy of `v`.\n+    /// let a = [1i, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> {\n-        let mut vector = Vec::with_capacity(self.len());\n-        vector.push_all(self);\n-        vector\n-    }\n+    #[stable]\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    #[stable]\n+    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n \n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    #[stable]\n+    fn as_mut_slice(&mut self) -> &mut [T];\n \n-    #[inline]\n-    fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push((*elt).clone());\n-            } else {\n-                rights.push((*elt).clone());\n-            }\n-        }\n+    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n \n-        (lefts, rights)\n-    }\n+    /// Returns a mutable subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n \n-    /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> {\n-        Permutations{\n-            swaps: ElementSwaps::new(self.len()),\n-            v: self.to_vec(),\n-        }\n-    }\n+    /// Returns a mutable subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n-        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    /// Returns an iterator that allows modifying each value\n+    #[stable]\n+    fn iter_mut(&mut self) -> IterMut<T>;\n+\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    #[stable]\n+    fn first_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Depreated: renamed to `first_mut`.\n+    #[deprecated = \"renamed to first_mut\"]\n+    fn head_mut(&mut self) -> Option<&mut T> {\n+        self.first_mut()\n     }\n-}\n \n-fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    let len = v.len() as int;\n-    let buf_v = v.as_mut_ptr();\n+    /// Returns all but the first element of a mutable slice\n+    #[experimental = \"likely to be renamed or removed\"]\n+    fn tail_mut(&mut self) -> &mut [T];\n \n-    // 1 <= i < len;\n-    for i in range(1, len) {\n-        // j satisfies: 0 <= j <= i;\n-        let mut j = i;\n-        unsafe {\n-            // `i` is in bounds.\n-            let read_ptr = buf_v.offset(i) as *const T;\n+    /// Returns all but the last element of a mutable slice\n+    #[experimental = \"likely to be renamed or removed\"]\n+    fn init_mut(&mut self) -> &mut [T];\n \n-            // find where to insert, we need to do strict <,\n-            // rather than <=, to maintain stability.\n+    /// Returns a mutable pointer to the last item in the slice.\n+    #[stable]\n+    fn last_mut(&mut self) -> Option<&mut T>;\n \n-            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n-            while j > 0 &&\n-                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n-                j -= 1;\n-            }\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`.  The matched element is not contained in the subslices.\n+    #[stable]\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+                    where F: FnMut(&T) -> bool;\n \n-            // shift everything to the right, to make space to\n-            // insert this value.\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[stable]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+                     where F: FnMut(&T) -> bool;\n \n-            // j + 1 could be `len` (for the last `i`), but in\n-            // that case, `i == j` so we don't copy. The\n-            // `.offset(j)` is always in bounds.\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[stable]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool;\n \n-            if i != j {\n-                let tmp = ptr::read(read_ptr);\n-                ptr::copy_memory(buf_v.offset(j + 1),\n-                                 &*buf_v.offset(j),\n-                                 (i - j) as uint);\n-                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n-                                                &tmp as *const T,\n-                                                1);\n-                mem::forget(tmp);\n-            }\n-        }\n-    }\n-}\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    #[stable]\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T>;\n \n-fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    // warning: this wildly uses unsafe.\n-    static BASE_INSERTION: uint = 32;\n-    static LARGE_INSERTION: uint = 16;\n+    /// Swaps two elements in a slice.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[stable]\n+    fn swap(&mut self, a: uint, b: uint);\n \n-    // FIXME #12092: smaller insertion runs seems to make sorting\n-    // vectors of large elements a little faster on some platforms,\n-    // but hasn't been tested/tuned extensively\n-    let insertion = if size_of::<T>() <= 16 {\n-        BASE_INSERTION\n-    } else {\n-        LARGE_INSERTION\n-    };\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.split_at_mut(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1i, 2]);\n+    ///     assert!(right == [3i, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(6);\n+    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n \n-    let len = v.len();\n+    /// Reverse the order of elements in a slice, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3i, 2, 1]);\n+    /// ```\n+    #[stable]\n+    fn reverse(&mut self);\n \n-    // short vectors get sorted in-place via insertion sort to avoid allocations\n-    if len <= insertion {\n-        insertion_sort(v, compare);\n-        return;\n-    }\n+    /// Returns an unsafe mutable pointer to the element in index\n+    #[stable]\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T;\n \n-    // allocate some memory to use as scratch memory, we keep the\n-    // length 0 so we can keep shallow copies of the contents of `v`\n-    // without risking the dtors running on an object twice if\n-    // `compare` panics.\n-    let mut working_space = Vec::with_capacity(2 * len);\n-    // these both are buffers of length `len`.\n-    let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n+    /// Deprecated: renamed to `get_unchecked_mut`.\n+    #[deprecated = \"renamed to get_unchecked_mut\"]\n+    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut T {\n+        self.get_unchecked_mut(index)\n+    }\n \n-    // length `len`.\n-    let buf_v = v.as_ptr();\n+    /// Return an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    #[stable]\n+    fn as_mut_ptr(&mut self) -> *mut T;\n+}\n \n-    // step 1. sort short runs with insertion sort. This takes the\n-    // values from `v` and sorts them into `buf_dat`, leaving that\n-    // with sorted runs of length INSERTION.\n+#[unstable = \"trait is unstable\"]\n+impl<T> SliceExt<T> for [T] {\n+    #[inline]\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n+        merge_sort(self, compare)\n+    }\n \n-    // We could hardcode the sorting comparisons here, and we could\n-    // manipulate/step the pointers themselves, rather than repeatedly\n-    // .offset-ing.\n-    for start in range_step(0, len, insertion) {\n-        // start <= i < len;\n-        for i in range(start, cmp::min(start + insertion, len)) {\n-            // j satisfies: start <= j <= i;\n-            let mut j = i as int;\n-            unsafe {\n-                // `i` is in bounds.\n-                let read_ptr = buf_v.offset(i as int);\n+    #[inline]\n+    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n+        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+            mem::swap(a, b);\n+        }\n+        cmp::min(self.len(), end-start)\n+    }\n \n-                // find where to insert, we need to do strict <,\n-                // rather than <=, to maintain stability.\n+    #[inline]\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice(self, start, end)\n+    }\n \n-                // start <= j - 1 < len, so .offset(j - 1) is in\n-                // bounds.\n-                while j > start as int &&\n-                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n-                    j -= 1;\n-                }\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_from(self, start)\n+    }\n \n-                // shift everything to the right, to make space to\n-                // insert this value.\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_to(self, end)\n+    }\n \n-                // j + 1 could be `len` (for the last `i`), but in\n-                // that case, `i == j` so we don't copy. The\n-                // `.offset(j)` is always in bounds.\n-                ptr::copy_memory(buf_dat.offset(j + 1),\n-                                 &*buf_dat.offset(j),\n-                                 i - j as uint);\n-                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n-            }\n-        }\n+    #[inline]\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n+        core_slice::SliceExt::split_at(self, mid)\n     }\n \n-    // step 2. merge the sorted runs.\n-    let mut width = insertion;\n-    while width < len {\n-        // merge the sorted runs of length `width` in `buf_dat` two at\n-        // a time, placing the result in `buf_tmp`.\n+    #[inline]\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        core_slice::SliceExt::iter(self)\n+    }\n \n-        // 0 <= start <= len.\n-        for start in range_step(0, len, 2 * width) {\n-            // manipulate pointers directly for speed (rather than\n-            // using a `for` loop with `range` and `.offset` inside\n-            // that loop).\n-            unsafe {\n-                // the end of the first run & start of the\n-                // second. Offset of `len` is defined, since this is\n-                // precisely one byte past the end of the object.\n-                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n-                // end of the second. Similar reasoning to the above re safety.\n-                let right_end_idx = cmp::min(start + 2 * width, len);\n-                let right_end = buf_dat.offset(right_end_idx as int);\n+    #[inline]\n+    fn split<F>(&self, pred: F) -> Split<T, F>\n+                where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split(self, pred)\n+    }\n \n-                // the pointers to the elements under consideration\n-                // from the two runs.\n+    #[inline]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+                 where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn(self, n, pred)\n+    }\n \n-                // both of these are in bounds.\n-                let mut left = buf_dat.offset(start as int);\n-                let mut right = right_start;\n+    #[inline]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+                  where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn(self, n, pred)\n+    }\n \n-                // where we're putting the results, it is a run of\n-                // length `2*width`, so we step it once for each step\n-                // of either `left` or `right`.  `buf_tmp` has length\n-                // `len`, so these are in bounds.\n-                let mut out = buf_tmp.offset(start as int);\n-                let out_end = buf_tmp.offset(right_end_idx as int);\n+    #[inline]\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n+        core_slice::SliceExt::windows(self, size)\n+    }\n \n-                while out < out_end {\n-                    // Either the left or the right run are exhausted,\n-                    // so just copy the remainder from the other run\n-                    // and move on; this gives a huge speed-up (order\n-                    // of 25%) for mostly sorted vectors (the best\n-                    // case).\n-                    if left == right_start {\n-                        // the number remaining in this run.\n-                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n-                        break;\n-                    } else if right == right_end {\n-                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n-                        break;\n-                    }\n+    #[inline]\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n+        core_slice::SliceExt::chunks(self, size)\n+    }\n \n-                    // check which side is smaller, and that's the\n-                    // next element for the new run.\n+    #[inline]\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+        core_slice::SliceExt::get(self, index)\n+    }\n \n-                    // `left < right_start` and `right < right_end`,\n-                    // so these are valid.\n-                    let to_copy = if compare(&*left, &*right) == Greater {\n-                        step(&mut right)\n-                    } else {\n-                        step(&mut left)\n-                    };\n-                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n-                    step(&mut out);\n-                }\n-            }\n-        }\n+    #[inline]\n+    fn first<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::first(self)\n+    }\n \n-        mem::swap(&mut buf_dat, &mut buf_tmp);\n+    #[inline]\n+    fn tail<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::tail(self)\n+    }\n \n-        width *= 2;\n+    #[inline]\n+    fn init<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::init(self)\n     }\n \n-    // write the result to `v` in one go, so that there are never two copies\n-    // of the same object in `v`.\n-    unsafe {\n-        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n+    #[inline]\n+    fn last<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::last(self)\n     }\n \n-    // increment the pointer, returning the old pointer.\n-    #[inline(always)]\n-    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-        *ptr = ptr.offset(1);\n-        old\n+    #[inline]\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T {\n+        core_slice::SliceExt::get_unchecked(self, index)\n     }\n-}\n \n-/// Allocating extension methods for slices on Ord values.\n-#[experimental = \"likely to merge with other traits\"]\n-pub trait OrdSliceExt<T> for Sized? {\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    #[experimental]\n-    fn sort(&mut self);\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        core_slice::SliceExt::as_ptr(self)\n+    }\n \n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Found` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search_elem(&13),  Found(9));\n-    /// assert_eq!(s.binary_search_elem(&4),   NotFound(7));\n-    /// assert_eq!(s.binary_search_elem(&100), NotFound(13));\n-    /// let r = s.binary_search_elem(&1);\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n-    /// ```\n-    #[unstable = \"name likely to change\"]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n+    #[inline]\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint>\n+                        where F: FnMut(&T) -> Ordering {\n+        core_slice::SliceExt::binary_search_by(self, f)\n+    }\n \n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[experimental]\n-    fn next_permutation(&mut self) -> bool;\n+    #[inline]\n+    fn len(&self) -> uint {\n+        core_slice::SliceExt::len(self)\n+    }\n \n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[experimental]\n-    fn prev_permutation(&mut self) -> bool;\n-}\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        core_slice::SliceExt::is_empty(self)\n+    }\n \n-impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n-    fn sort(&mut self) {\n-        self.sort_by(|a, b| a.cmp(b))\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+        core_slice::SliceExt::get_mut(self, index)\n     }\n \n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n-        core_slice::OrdSliceExt::binary_search_elem(self, x)\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::as_mut_slice(self)\n     }\n \n-    fn next_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::next_permutation(self)\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_mut(self, start, end)\n     }\n \n-    fn prev_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::prev_permutation(self)\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_from_mut(self, start)\n     }\n-}\n \n-/// Allocating extension methods for slices.\n-#[experimental = \"likely to merge with other traits\"]\n-pub trait SliceExt<T> for Sized? {\n-    /// Sorts the slice, in place, using `compare` to compare\n-    /// elements.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [5i, 4, 1, 3, 2];\n-    /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert!(v == [1, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert!(v == [5, 4, 3, 2, 1]);\n-    /// ```\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_to_mut(self, end)\n+    }\n \n-    /// Consumes `src` and moves as many elements as it can into `self`\n-    /// from the range [start,end).\n-    ///\n-    /// Returns the number of elements copied (the shorter of `self.len()`\n-    /// and `end - start`).\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A mutable vector of `T`\n-    /// * start - The index into `src` to start copying from\n-    /// * end - The index into `src` to stop copying from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut a = [1i, 2, 3, 4, 5];\n-    /// let b = vec![6i, 7, 8];\n-    /// let num_moved = a.move_from(b, 0, 3);\n-    /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6i, 7, 8, 4, 5]);\n-    /// ```\n-    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+    #[inline]\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        core_slice::SliceExt::iter_mut(self)\n+    }\n \n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &[T];\n+    #[inline]\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::first_mut(self)\n+    }\n \n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_from(&self, start: uint) -> &[T];\n+    #[inline]\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::tail_mut(self)\n+    }\n \n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_to(&self, end: uint) -> &[T];\n+    #[inline]\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::init_mut(self)\n+    }\n \n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Panics if `mid > len`.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+    #[inline]\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::last_mut(self)\n+    }\n \n-    /// Returns an iterator over the slice\n-    #[unstable = \"iterator type may change\"]\n-    fn iter(&self) -> Iter<T>;\n+    #[inline]\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+                    where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split_mut(self, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n-    fn split<F>(&self, pred: F) -> Splits<T, F>\n-                where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+                     where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn_mut(self, n, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                 where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                  where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T> {\n+        core_slice::SliceExt::chunks_mut(self, chunk_size)\n+    }\n \n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n-    /// `[3,4]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4];\n-    /// for win in v.windows(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n-    fn windows(&self, size: uint) -> Windows<T>;\n+    #[inline]\n+    fn swap(&mut self, a: uint, b: uint) {\n+        core_slice::SliceExt::swap(self, a, b)\n+    }\n \n-    /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the slice two elements at a time (i.e. `[1,2]`,\n-    /// `[3,4]`, `[5]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4, 5];\n-    /// for win in v.chunks(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n-    fn chunks(&self, size: uint) -> Chunks<T>;\n+    #[inline]\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        core_slice::SliceExt::split_at_mut(self, mid)\n+    }\n \n-    /// Returns the element of a slice at the given index, or `None` if the\n-    /// index is out of bounds.\n-    #[unstable = \"waiting on final collection conventions\"]\n-    fn get(&self, index: uint) -> Option<&T>;\n+    #[inline]\n+    fn reverse(&mut self) {\n+        core_slice::SliceExt::reverse(self)\n+    }\n \n-    /// Returns the first element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n-    fn head(&self) -> Option<&T>;\n+    #[inline]\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        core_slice::SliceExt::get_unchecked_mut(self, index)\n+    }\n \n-    /// Returns all but the first element of a slice.\n-    #[unstable = \"name may change\"]\n-    fn tail(&self) -> &[T];\n+    #[inline]\n+    fn as_mut_ptr(&mut self) -> *mut T {\n+        core_slice::SliceExt::as_mut_ptr(self)\n+    }\n+}\n \n-    /// Returns all but the last element of a slice.\n-    #[unstable = \"name may change\"]\n-    fn init(&self) -> &[T];\n+////////////////////////////////////////////////////////////////////////////////\n+// Extension traits for slices over specifc kinds of data\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Extension methods for boxed slices.\n+#[experimental = \"likely to merge into SliceExt if it survives\"]\n+pub trait BoxedSliceExt<T> {\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[experimental]\n+    fn into_vec(self) -> Vec<T>;\n+}\n \n-    /// Returns the last element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n-    fn last(&self) -> Option<&T>;\n+#[experimental = \"trait is experimental\"]\n+impl<T> BoxedSliceExt<T> for Box<[T]> {\n+    fn into_vec(mut self) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n+    }\n+}\n \n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[unstable]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T;\n+/// Allocating extension methods for slices containing `Clone` elements.\n+#[unstable = \"likely to be merged into SliceExt\"]\n+pub trait CloneSliceExt<T> for Sized? {\n+    /// Copies `self` into a new `Vec`.\n+    #[stable]\n+    fn to_vec(&self) -> Vec<T>;\n \n-    /// Returns an unsafe pointer to the slice's buffer\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[unstable]\n-    fn as_ptr(&self) -> *const T;\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n \n-    /// Binary search a sorted slice with a comparator function.\n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n     ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n+    /// # Examples\n     ///\n-    /// If a matching value is found then returns `Found`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n     ///\n-    /// # Example\n+    /// for p in perms {\n+    ///   println!(\"{}\", p);\n+    /// }\n+    /// ```\n     ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// Iterating through permutations one by one.\n     ///\n     /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n     ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), Found(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n+    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    #[unstable = \"waiting on unboxed closures\"]\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering;\n+    #[unstable]\n+    fn permutations(&self) -> Permutations<T>;\n \n-    /// Return the number of elements in the slice\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n     ///\n     /// # Example\n     ///\n-    /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    #[experimental = \"not triaged yet\"]\n-    fn len(&self) -> uint;\n-\n-    /// Returns true if the slice has a length of 0\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n     ///\n-    /// # Example\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n     ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[experimental = \"not triaged yet\"]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n-\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(&mut self) -> &mut [T];\n-\n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n-\n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n-\n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n-\n-    /// Returns an iterator that allows modifying each value\n-    #[unstable = \"waiting on iterator type name conventions\"]\n-    fn iter_mut(&mut self) -> IterMut<T>;\n-\n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[unstable = \"name may change\"]\n-    fn head_mut(&mut self) -> Option<&mut T>;\n-\n-    /// Returns all but the first element of a mutable slice\n-    #[unstable = \"name may change\"]\n-    fn tail_mut(&mut self) -> &mut [T];\n-\n-    /// Returns all but the last element of a mutable slice\n-    #[unstable = \"name may change\"]\n-    fn init_mut(&mut self) -> &mut [T];\n+    #[experimental]\n+    fn clone_from_slice(&mut self, &[T]) -> uint;\n+}\n \n-    /// Returns a mutable pointer to the last item in the slice.\n-    #[unstable = \"name may change\"]\n-    fn last_mut(&mut self) -> Option<&mut T>;\n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> CloneSliceExt<T> for [T] {\n+    /// Returns a copy of `v`.\n+    #[inline]\n+    fn to_vec(&self) -> Vec<T> {\n+        let mut vector = Vec::with_capacity(self.len());\n+        vector.push_all(self);\n+        vector\n+    }\n \n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n-                    where F: FnMut(&T) -> bool;\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                     where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.iter().cloned().partition(f)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                      where F: FnMut(&T) -> bool;\n+    /// Returns an iterator over all permutations of a vector.\n+    fn permutations(&self) -> Permutations<T> {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_vec(),\n+        }\n+    }\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    #[unstable = \"waiting on iterator type name conventions\"]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T>;\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    }\n+}\n \n-    /// Swaps two elements in a slice.\n-    ///\n-    /// Panics if `a` or `b` are out of bounds.\n-    ///\n-    /// # Arguments\n+/// Allocating extension methods for slices on Ord values.\n+#[unstable = \"likely to merge with SliceExt\"]\n+pub trait OrdSliceExt<T> for Sized? {\n+    /// Sorts the slice, in place.\n     ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn swap(&mut self, a: uint, b: uint);\n+    #[stable]\n+    fn sort(&mut self);\n \n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    /// Binary search a sorted slice for a given element.\n     ///\n-    /// Panics if `mid > len`.\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n-    /// }\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n     ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1i, 2]);\n-    ///     assert!(right == [3i, 4, 5, 6]);\n-    /// }\n+    /// ```rust\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n     ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+    #[stable]\n+    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n \n-    /// Reverse the order of elements in a slice, in place.\n+    /// Deprecated: use `binary_search` instead.\n+    #[deprecated = \"use binary_search instead\"]\n+    fn binary_search_elem(&self, x: &T) -> Result<uint, uint> {\n+        self.binary_search(x)\n+    }\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n     /// ```\n-    #[experimental = \"may be moved to iterators instead\"]\n-    fn reverse(&mut self);\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    #[experimental = \"waiting on unsafe conventions\"]\n-    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T;\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn next_permutation(&mut self) -> bool;\n \n-    /// Return an unsafe mutable pointer to the slice's buffer.\n+    /// Mutates the slice to the previous lexicographic permutation.\n     ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n     ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    #[unstable]\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn prev_permutation(&mut self) -> bool;\n }\n \n-impl<T> SliceExt<T> for [T] {\n+#[unstable = \"trait is unstable\"]\n+impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n-        merge_sort(self, compare)\n+    fn sort(&mut self) {\n+        self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    #[inline]\n-    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n-            mem::swap(a, b);\n-        }\n-        cmp::min(self.len(), end-start)\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+        core_slice::OrdSliceExt::binary_search(self, x)\n     }\n \n-    #[inline]\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice(self, start, end)\n+    fn next_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::next_permutation(self)\n     }\n \n-    #[inline]\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_from(self, start)\n+    fn prev_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::prev_permutation(self)\n     }\n+}\n \n-    #[inline]\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_to(self, end)\n-    }\n+#[unstable = \"U should be an associated type\"]\n+/// An extension trait for concatenating slices\n+pub trait SliceConcatExt<Sized? T, U> for Sized? {\n+    /// Flattens a slice of `T` into a single value `U`.\n+    #[stable]\n+    fn concat(&self) -> U;\n \n-    #[inline]\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n-        core_slice::SliceExt::split_at(self, mid)\n+    #[deprecated = \"renamed to concat\"]\n+    fn concat_vec(&self) -> U {\n+        self.concat()\n     }\n \n-    #[inline]\n-    fn iter<'a>(&'a self) -> Iter<'a, T> {\n-        core_slice::SliceExt::iter(self)\n-    }\n+    /// Flattens a slice of `T` into a single value `U`, placing a\n+    /// given seperator between each.\n+    #[stable]\n+    fn connect(&self, sep: &T) -> U;\n \n-    #[inline]\n-    fn split<F>(&self, pred: F) -> Splits<T, F>\n-                where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split(self, pred)\n+    #[deprecated = \"renamed to connect\"]\n+    fn connect_vec(&self, sep: &T) -> U {\n+        self.connect(sep)\n     }\n+}\n \n-    #[inline]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                 where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn(self, n, pred)\n+impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n+    fn concat(&self) -> Vec<T> {\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = Vec::with_capacity(size);\n+        for v in self.iter() {\n+            result.push_all(v.as_slice())\n+        }\n+        result\n     }\n \n-    #[inline]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                  where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn(self, n, pred)\n+    fn connect(&self, sep: &T) -> Vec<T> {\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = Vec::with_capacity(size + self.len());\n+        let mut first = true;\n+        for v in self.iter() {\n+            if first { first = false } else { result.push(sep.clone()) }\n+            result.push_all(v.as_slice())\n+        }\n+        result\n     }\n+}\n \n-    #[inline]\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n-        core_slice::SliceExt::windows(self, size)\n-    }\n+/// An iterator that yields the element swaps needed to produce\n+/// a sequence of all possible permutations for an indexed sequence of\n+/// elements. Each permutation is only a single swap apart.\n+///\n+/// The Steinhaus-Johnson-Trotter algorithm is used.\n+///\n+/// Generates even and odd permutations alternately.\n+///\n+/// The last generated swap is always (0, 1), and it returns the\n+/// sequence to its initial order.\n+#[experimental]\n+#[deriving(Clone)]\n+pub struct ElementSwaps {\n+    sdir: Vec<SizeDirection>,\n+    /// If `true`, emit the last swap that returns the sequence to initial\n+    /// state.\n+    emit_reset: bool,\n+    swaps_made : uint,\n+}\n \n-    #[inline]\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n-        core_slice::SliceExt::chunks(self, size)\n+impl ElementSwaps {\n+    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n+    #[experimental]\n+    pub fn new(length: uint) -> ElementSwaps {\n+        // Initialize `sdir` with a direction that position should move in\n+        // (all negative at the beginning) and the `size` of the\n+        // element (equal to the original index).\n+        ElementSwaps{\n+            emit_reset: true,\n+            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n+            swaps_made: 0\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n-        core_slice::SliceExt::get(self, index)\n-    }\n+////////////////////////////////////////////////////////////////////////////////\n+// Standard trait implementations for slices\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFrom<Vec<T>> for [T] {\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFromMut<Vec<T>> for [T] {\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> ToOwned<Vec<T>> for [T] {\n+    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[deriving(Copy, Clone)]\n+enum Direction { Pos, Neg }\n+\n+/// An `Index` and `Direction` together.\n+#[deriving(Copy, Clone)]\n+struct SizeDirection {\n+    size: uint,\n+    dir: Direction,\n+}\n \n+impl Iterator<(uint, uint)> for ElementSwaps {\n     #[inline]\n-    fn head<'a>(&'a self) -> Option<&'a T> {\n-        core_slice::SliceExt::head(self)\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        fn new_pos(i: uint, s: Direction) -> uint {\n+            i + match s { Pos => 1, Neg => -1 }\n+        }\n+\n+        // Find the index of the largest mobile element:\n+        // The direction should point into the vector, and the\n+        // swap should be with a smaller `size` element.\n+        let max = self.sdir.iter().map(|&x| x).enumerate()\n+                           .filter(|&(i, sd)|\n+                                new_pos(i, sd.dir) < self.sdir.len() &&\n+                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n+                           .max_by(|&(_, sd)| sd.size);\n+        match max {\n+            Some((i, sd)) => {\n+                let j = new_pos(i, sd.dir);\n+                self.sdir.swap(i, j);\n+\n+                // Swap the direction of each larger SizeDirection\n+                for x in self.sdir.iter_mut() {\n+                    if x.size > sd.size {\n+                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n+                    }\n+                }\n+                self.swaps_made += 1;\n+                Some((i, j))\n+            },\n+            None => if self.emit_reset {\n+                self.emit_reset = false;\n+                if self.sdir.len() > 1 {\n+                    // The last swap\n+                    self.swaps_made += 1;\n+                    Some((0, 1))\n+                } else {\n+                    // Vector is of the form [] or [x], and the only permutation is itself\n+                    self.swaps_made += 1;\n+                    Some((0,0))\n+                }\n+            } else { None }\n+        }\n     }\n \n     #[inline]\n-    fn tail<'a>(&'a self) -> &'a [T] {\n-        core_slice::SliceExt::tail(self)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        // For a vector of size n, there are exactly n! permutations.\n+        let n = range(2, self.sdir.len() + 1).product();\n+        (n - self.swaps_made, Some(n - self.swaps_made))\n     }\n+}\n+\n+/// An iterator that uses `ElementSwaps` to iterate through\n+/// all possible permutations of a vector.\n+///\n+/// The first iteration yields a clone of the vector as it is,\n+/// then each successive element is the vector with one\n+/// swap applied.\n+///\n+/// Generates even and odd permutations alternately.\n+#[unstable]\n+pub struct Permutations<T> {\n+    swaps: ElementSwaps,\n+    v: Vec<T>,\n+}\n \n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n     #[inline]\n-    fn init<'a>(&'a self) -> &'a [T] {\n-        core_slice::SliceExt::init(self)\n+    fn next(&mut self) -> Option<Vec<T>> {\n+        match self.swaps.next() {\n+            None => None,\n+            Some((0,0)) => Some(self.v.clone()),\n+            Some((a, b)) => {\n+                let elt = self.v.clone();\n+                self.v.swap(a, b);\n+                Some(elt)\n+            }\n+        }\n     }\n \n     #[inline]\n-    fn last<'a>(&'a self) -> Option<&'a T> {\n-        core_slice::SliceExt::last(self)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.swaps.size_hint()\n     }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Sorting\n+////////////////////////////////////////////////////////////////////////////////\n+\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    let len = v.len() as int;\n+    let buf_v = v.as_mut_ptr();\n+\n+    // 1 <= i < len;\n+    for i in range(1, len) {\n+        // j satisfies: 0 <= j <= i;\n+        let mut j = i;\n+        unsafe {\n+            // `i` is in bounds.\n+            let read_ptr = buf_v.offset(i) as *const T;\n+\n+            // find where to insert, we need to do strict <,\n+            // rather than <=, to maintain stability.\n+\n+            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n+            while j > 0 &&\n+                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n+                j -= 1;\n+            }\n+\n+            // shift everything to the right, to make space to\n+            // insert this value.\n+\n+            // j + 1 could be `len` (for the last `i`), but in\n+            // that case, `i == j` so we don't copy. The\n+            // `.offset(j)` is always in bounds.\n \n-    #[inline]\n-    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T {\n-        core_slice::SliceExt::unsafe_get(self, index)\n+            if i != j {\n+                let tmp = ptr::read(read_ptr);\n+                ptr::copy_memory(buf_v.offset(j + 1),\n+                                 &*buf_v.offset(j),\n+                                 (i - j) as uint);\n+                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n+                                                &tmp as *const T,\n+                                                1);\n+                mem::forget(tmp);\n+            }\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn as_ptr(&self) -> *const T {\n-        core_slice::SliceExt::as_ptr(self)\n-    }\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    // warning: this wildly uses unsafe.\n+    static BASE_INSERTION: uint = 32;\n+    static LARGE_INSERTION: uint = 16;\n \n-    #[inline]\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering {\n-        core_slice::SliceExt::binary_search(self, f)\n-    }\n+    // FIXME #12092: smaller insertion runs seems to make sorting\n+    // vectors of large elements a little faster on some platforms,\n+    // but hasn't been tested/tuned extensively\n+    let insertion = if size_of::<T>() <= 16 {\n+        BASE_INSERTION\n+    } else {\n+        LARGE_INSERTION\n+    };\n \n-    #[inline]\n-    fn len(&self) -> uint {\n-        core_slice::SliceExt::len(self)\n-    }\n+    let len = v.len();\n \n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        core_slice::SliceExt::is_empty(self)\n+    // short vectors get sorted in-place via insertion sort to avoid allocations\n+    if len <= insertion {\n+        insertion_sort(v, compare);\n+        return;\n     }\n \n-    #[inline]\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n-        core_slice::SliceExt::get_mut(self, index)\n-    }\n+    // allocate some memory to use as scratch memory, we keep the\n+    // length 0 so we can keep shallow copies of the contents of `v`\n+    // without risking the dtors running on an object twice if\n+    // `compare` panics.\n+    let mut working_space = Vec::with_capacity(2 * len);\n+    // these both are buffers of length `len`.\n+    let mut buf_dat = working_space.as_mut_ptr();\n+    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n \n-    #[inline]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::as_mut_slice(self)\n-    }\n+    // length `len`.\n+    let buf_v = v.as_ptr();\n \n-    #[inline]\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_mut(self, start, end)\n-    }\n+    // step 1. sort short runs with insertion sort. This takes the\n+    // values from `v` and sorts them into `buf_dat`, leaving that\n+    // with sorted runs of length INSERTION.\n \n-    #[inline]\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_from_mut(self, start)\n-    }\n+    // We could hardcode the sorting comparisons here, and we could\n+    // manipulate/step the pointers themselves, rather than repeatedly\n+    // .offset-ing.\n+    for start in range_step(0, len, insertion) {\n+        // start <= i < len;\n+        for i in range(start, cmp::min(start + insertion, len)) {\n+            // j satisfies: start <= j <= i;\n+            let mut j = i as int;\n+            unsafe {\n+                // `i` is in bounds.\n+                let read_ptr = buf_v.offset(i as int);\n \n-    #[inline]\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_to_mut(self, end)\n-    }\n+                // find where to insert, we need to do strict <,\n+                // rather than <=, to maintain stability.\n \n-    #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n-        core_slice::SliceExt::iter_mut(self)\n-    }\n+                // start <= j - 1 < len, so .offset(j - 1) is in\n+                // bounds.\n+                while j > start as int &&\n+                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n+                    j -= 1;\n+                }\n \n-    #[inline]\n-    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        core_slice::SliceExt::head_mut(self)\n-    }\n+                // shift everything to the right, to make space to\n+                // insert this value.\n \n-    #[inline]\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::tail_mut(self)\n+                // j + 1 could be `len` (for the last `i`), but in\n+                // that case, `i == j` so we don't copy. The\n+                // `.offset(j)` is always in bounds.\n+                ptr::copy_memory(buf_dat.offset(j + 1),\n+                                 &*buf_dat.offset(j),\n+                                 i - j as uint);\n+                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n+            }\n+        }\n     }\n \n-    #[inline]\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::init_mut(self)\n-    }\n+    // step 2. merge the sorted runs.\n+    let mut width = insertion;\n+    while width < len {\n+        // merge the sorted runs of length `width` in `buf_dat` two at\n+        // a time, placing the result in `buf_tmp`.\n \n-    #[inline]\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        core_slice::SliceExt::last_mut(self)\n-    }\n+        // 0 <= start <= len.\n+        for start in range_step(0, len, 2 * width) {\n+            // manipulate pointers directly for speed (rather than\n+            // using a `for` loop with `range` and `.offset` inside\n+            // that loop).\n+            unsafe {\n+                // the end of the first run & start of the\n+                // second. Offset of `len` is defined, since this is\n+                // precisely one byte past the end of the object.\n+                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n+                // end of the second. Similar reasoning to the above re safety.\n+                let right_end_idx = cmp::min(start + 2 * width, len);\n+                let right_end = buf_dat.offset(right_end_idx as int);\n \n-    #[inline]\n-    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n-                    where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split_mut(self, pred)\n-    }\n+                // the pointers to the elements under consideration\n+                // from the two runs.\n \n-    #[inline]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                     where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn_mut(self, n, pred)\n-    }\n+                // both of these are in bounds.\n+                let mut left = buf_dat.offset(start as int);\n+                let mut right = right_start;\n \n-    #[inline]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                      where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n-    }\n+                // where we're putting the results, it is a run of\n+                // length `2*width`, so we step it once for each step\n+                // of either `left` or `right`.  `buf_tmp` has length\n+                // `len`, so these are in bounds.\n+                let mut out = buf_tmp.offset(start as int);\n+                let out_end = buf_tmp.offset(right_end_idx as int);\n \n-    #[inline]\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T> {\n-        core_slice::SliceExt::chunks_mut(self, chunk_size)\n-    }\n+                while out < out_end {\n+                    // Either the left or the right run are exhausted,\n+                    // so just copy the remainder from the other run\n+                    // and move on; this gives a huge speed-up (order\n+                    // of 25%) for mostly sorted vectors (the best\n+                    // case).\n+                    if left == right_start {\n+                        // the number remaining in this run.\n+                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n+                        break;\n+                    } else if right == right_end {\n+                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n+                        break;\n+                    }\n \n-    #[inline]\n-    fn swap(&mut self, a: uint, b: uint) {\n-        core_slice::SliceExt::swap(self, a, b)\n-    }\n+                    // check which side is smaller, and that's the\n+                    // next element for the new run.\n \n-    #[inline]\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        core_slice::SliceExt::split_at_mut(self, mid)\n-    }\n+                    // `left < right_start` and `right < right_end`,\n+                    // so these are valid.\n+                    let to_copy = if compare(&*left, &*right) == Greater {\n+                        step(&mut right)\n+                    } else {\n+                        step(&mut left)\n+                    };\n+                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n+                    step(&mut out);\n+                }\n+            }\n+        }\n \n-    #[inline]\n-    fn reverse(&mut self) {\n-        core_slice::SliceExt::reverse(self)\n-    }\n+        mem::swap(&mut buf_dat, &mut buf_tmp);\n \n-    #[inline]\n-    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n-        core_slice::SliceExt::unsafe_mut(self, index)\n+        width *= 2;\n     }\n \n-    #[inline]\n-    fn as_mut_ptr(&mut self) -> *mut T {\n-        core_slice::SliceExt::as_mut_ptr(self)\n+    // write the result to `v` in one go, so that there are never two copies\n+    // of the same object in `v`.\n+    unsafe {\n+        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n     }\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> ToOwned<Vec<T>> for [T] {\n-    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+    // increment the pointer, returning the old pointer.\n+    #[inline(always)]\n+    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+        *ptr = ptr.offset(1);\n+        old\n+    }\n }\n \n-/// Unsafe operations\n+/// Deprecated, unsafe operations\n+#[deprecated]\n pub mod raw {\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n     pub use core::slice::raw::{shift_ptr, pop_ptr};\n@@ -1346,7 +1419,7 @@ mod tests {\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n     use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n     use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n-    use prelude::{RandomAccessIterator, Ord, VectorVector};\n+    use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n     use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;\n@@ -1612,15 +1685,19 @@ mod tests {\n     fn test_swap_remove() {\n         let mut v = vec![1i, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        assert_eq!(e, Some(1));\n+        assert_eq!(e, 1);\n         assert_eq!(v, vec![5i, 2, 3, 4]);\n         e = v.swap_remove(3);\n-        assert_eq!(e, Some(4));\n+        assert_eq!(e, 4);\n         assert_eq!(v, vec![5i, 2, 3]);\n+    }\n \n-        e = v.swap_remove(3);\n-        assert_eq!(e, None);\n-        assert_eq!(v, vec![5i, 2, 3]);\n+    #[test]\n+    #[should_fail]\n+    fn test_swap_remove_fail() {\n+        let mut v = vec![1i];\n+        let _ = v.swap_remove(0);\n+        let _ = v.swap_remove(0);\n     }\n \n     #[test]\n@@ -1904,48 +1981,48 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_binary_search_elem() {\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&5).found(), Some(4));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&4).found(), Some(3));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&3).found(), Some(2));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&2).found(), Some(1));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&1).found(), Some(0));\n+    fn test_binary_search() {\n+        assert_eq!([1i,2,3,4,5].binary_search(&5).ok(), Some(4));\n+        assert_eq!([1i,2,3,4,5].binary_search(&4).ok(), Some(3));\n+        assert_eq!([1i,2,3,4,5].binary_search(&3).ok(), Some(2));\n+        assert_eq!([1i,2,3,4,5].binary_search(&2).ok(), Some(1));\n+        assert_eq!([1i,2,3,4,5].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&10).found(), Some(4));\n+        assert_eq!([2i,4,6,8,10].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6,8,10].binary_search(&10).ok(), Some(4));\n \n-        assert_eq!([2i,4,6,8].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6,8].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6,8].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6,8].binary_search_elem(&8).found(), Some(3));\n+        assert_eq!([2i,4,6,8].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6,8].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6,8].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6,8].binary_search(&8).ok(), Some(3));\n \n-        assert_eq!([2i,4,6].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6].binary_search_elem(&6).found(), Some(2));\n+        assert_eq!([2i,4,6].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6].binary_search(&6).ok(), Some(2));\n \n-        assert_eq!([2i,4].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4].binary_search_elem(&2).found(), Some(0));\n-        assert_eq!([2i,4].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4].binary_search(&2).ok(), Some(0));\n+        assert_eq!([2i,4].binary_search(&4).ok(), Some(1));\n \n-        assert_eq!([2i].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i].binary_search_elem(&2).found(), Some(0));\n+        assert_eq!([2i].binary_search(&1).ok(), None);\n+        assert_eq!([2i].binary_search(&5).ok(), None);\n+        assert_eq!([2i].binary_search(&2).ok(), Some(0));\n \n-        assert_eq!([].binary_search_elem(&1i).found(), None);\n-        assert_eq!([].binary_search_elem(&5i).found(), None);\n+        assert_eq!([].binary_search(&1i).ok(), None);\n+        assert_eq!([].binary_search(&5i).ok(), None);\n \n-        assert!([1i,1,1,1,1].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,1,1,2].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,1,2,2].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,2,2,2].binary_search_elem(&1).found() != None);\n-        assert_eq!([1i,2,2,2,2].binary_search_elem(&1).found(), Some(0));\n+        assert!([1i,1,1,1,1].binary_search(&1).ok() != None);\n+        assert!([1i,1,1,1,2].binary_search(&1).ok() != None);\n+        assert!([1i,1,1,2,2].binary_search(&1).ok() != None);\n+        assert!([1i,1,2,2,2].binary_search(&1).ok() != None);\n+        assert_eq!([1i,2,2,2,2].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&6).found(), None);\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&0).found(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search(&6).ok(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search(&0).ok(), None);\n     }\n \n     #[test]\n@@ -2040,13 +2117,15 @@ mod tests {\n     #[test]\n     fn test_concat() {\n         let v: [Vec<int>, ..0] = [];\n-        assert_eq!(v.concat_vec(), vec![]);\n-        assert_eq!([vec![1i], vec![2i,3i]].concat_vec(), vec![1, 2, 3]);\n+        let c: Vec<int> = v.concat();\n+        assert_eq!(c, []);\n+        let d: Vec<int> = [vec![1i], vec![2i,3i]].concat();\n+        assert_eq!(d, vec![1i, 2, 3]);\n \n         let v: [&[int], ..2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n-        let v: [&[int], ..3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), vec![1i, 0, 2, 3]);\n+        let v: [&[int], ..3] = [&[1i], &[2], &[3]];\n+        assert_eq!(v.connect(&0), vec![1i, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -2092,23 +2171,25 @@ mod tests {\n     fn test_remove() {\n         let mut a = vec![1i,2,3,4];\n \n-        assert_eq!(a.remove(2), Some(3));\n+        assert_eq!(a.remove(2), 3);\n         assert_eq!(a, vec![1i,2,4]);\n \n-        assert_eq!(a.remove(2), Some(4));\n-        assert_eq!(a, vec![1i,2]);\n-\n-        assert_eq!(a.remove(2), None);\n+        assert_eq!(a.remove(2), 4);\n         assert_eq!(a, vec![1i,2]);\n \n-        assert_eq!(a.remove(0), Some(1));\n+        assert_eq!(a.remove(0), 1);\n         assert_eq!(a, vec![2i]);\n \n-        assert_eq!(a.remove(0), Some(2));\n+        assert_eq!(a.remove(0), 2);\n         assert_eq!(a, vec![]);\n+    }\n \n-        assert_eq!(a.remove(0), None);\n-        assert_eq!(a.remove(10), None);\n+    #[test]\n+    #[should_fail]\n+    fn test_remove_fail() {\n+        let mut a = vec![1i];\n+        let _ = a.remove(0);\n+        let _ = a.remove(0);\n     }\n \n     #[test]\n@@ -2804,7 +2885,7 @@ mod bench {\n         let xss: Vec<Vec<uint>> =\n             Vec::from_fn(100, |i| range(0u, i).collect());\n         b.iter(|| {\n-            xss.as_slice().concat_vec()\n+            xss.as_slice().concat();\n         });\n     }\n "}, {"sha": "8d5d76f9598f4a400b0a482399222cf78539b8e2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 30, "deletions": 97, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -77,6 +77,7 @@ use slice::SliceExt;\n use string::String;\n use unicode;\n use vec::Vec;\n+use slice::SliceConcatExt;\n \n pub use core::str::{from_utf8, CharEq, Chars, CharIndices};\n pub use core::str::{Bytes, CharSplits, is_utf8};\n@@ -93,71 +94,45 @@ pub use core::str::{SplitN, RSplitN};\n Section: Creating a string\n */\n \n-/// Methods for vectors of strings.\n-#[unstable = \"functionality may be replaced with iterators\"]\n-pub trait StrVector for Sized? {\n-    /// Concatenates a vector of strings.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let first = \"Restaurant at the End of the\".to_string();\n-    /// let second = \" Universe\".to_string();\n-    /// let string_vec = vec![first, second];\n-    /// assert_eq!(string_vec.concat(), \"Restaurant at the End of the Universe\".to_string());\n-    /// ```\n-    fn concat(&self) -> String;\n-\n-    /// Concatenates a vector of strings, placing a given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let first = \"Roast\".to_string();\n-    /// let second = \"Sirloin Steak\".to_string();\n-    /// let string_vec = vec![first, second];\n-    /// assert_eq!(string_vec.connect(\", \"), \"Roast, Sirloin Steak\".to_string());\n-    /// ```\n-    fn connect(&self, sep: &str) -> String;\n-}\n-\n-#[allow(deprecated)]\n-impl<S: Str> StrVector for [S] {\n+impl<S: Str> SliceConcatExt<str, String> for [S] {\n     fn concat(&self) -> String {\n-        if self.is_empty() {\n+        let s = self.as_slice();\n+\n+        if s.is_empty() {\n             return String::new();\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.as_slice().len()).sum();\n-\n+        let len = s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n \n-        for s in self.iter() {\n-            result.push_str(s.as_slice());\n+        for s in s.iter() {\n+            result.push_str(s.as_slice())\n         }\n \n         result\n     }\n \n     fn connect(&self, sep: &str) -> String {\n-        if self.is_empty() {\n+        let s = self.as_slice();\n+\n+        if s.is_empty() {\n             return String::new();\n         }\n \n         // concat is faster\n         if sep.is_empty() {\n-            return self.concat();\n+            return s.concat();\n         }\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.as_slice().len()).sum();\n+        let len = sep.len() * (s.len() - 1)\n+            + s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n-        for s in self.iter() {\n+        for s in s.iter() {\n             if first {\n                 first = false;\n             } else {\n@@ -169,18 +144,6 @@ impl<S: Str> StrVector for [S] {\n     }\n }\n \n-impl<S: Str, T: AsSlice<S>> StrVector for T {\n-    #[inline]\n-    fn concat(&self) -> String {\n-        self.as_slice().concat()\n-    }\n-\n-    #[inline]\n-    fn connect(&self, sep: &str) -> String {\n-        self.as_slice().connect(sep)\n-    }\n-}\n-\n /*\n Section: Iterators\n */\n@@ -221,7 +184,7 @@ pub struct Decompositions<'a> {\n impl<'a> Iterator<char> for Decompositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        match self.buffer.head() {\n+        match self.buffer.first() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.remove(0);\n@@ -268,13 +231,16 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n             self.sorted = true;\n         }\n \n-        match self.buffer.remove(0) {\n-            Some((c, 0)) => {\n-                self.sorted = false;\n-                Some(c)\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            match self.buffer.remove(0) {\n+                (c, 0) => {\n+                    self.sorted = false;\n+                    Some(c)\n+                }\n+                (c, _) => Some(c),\n             }\n-            Some((c, _)) => Some(c),\n-            None => None\n         }\n     }\n \n@@ -747,7 +713,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         if me.is_empty() { return t.chars().count(); }\n         if t.is_empty() { return me.chars().count(); }\n \n-        let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+        let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n         let mut t_last = 0;\n \n         for (i, sc) in me.chars().enumerate() {\n@@ -1892,45 +1858,23 @@ mod tests {\n         assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n-    struct S {\n-        x: [String, .. 2]\n-    }\n-\n-    impl AsSlice<String> for S {\n-        fn as_slice<'a> (&'a self) -> &'a [String] {\n-            &self.x\n-        }\n-    }\n-\n     fn s(x: &str) -> String { x.into_string() }\n \n     macro_rules! test_concat {\n         ($expected: expr, $string: expr) => {\n             {\n-                let s = $string.concat();\n+                let s: String = $string.concat();\n                 assert_eq!($expected, s);\n             }\n         }\n     }\n \n     #[test]\n     fn test_concat_for_different_types() {\n-        test_concat!(\"ab\", [\"a\", \"b\"]);\n-        test_concat!(\"ab\", [s(\"a\"), s(\"b\")]);\n+        test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n         test_concat!(\"ab\", vec![\"a\", \"b\"]);\n         test_concat!(\"ab\", vec![\"a\", \"b\"].as_slice());\n         test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n-\n-        let mut v0 = [\"a\", \"b\"];\n-        let mut v1 = [s(\"a\"), s(\"b\")];\n-        unsafe {\n-            use std::c_vec::CVec;\n-\n-            test_concat!(\"ab\", CVec::new(v0.as_mut_ptr(), v0.len()));\n-            test_concat!(\"ab\", CVec::new(v1.as_mut_ptr(), v1.len()));\n-        }\n-\n-        test_concat!(\"ab\", S { x: [s(\"a\"), s(\"b\")] });\n     }\n \n     #[test]\n@@ -1959,17 +1903,6 @@ mod tests {\n         test_connect!(\"a-b\", vec![\"a\", \"b\"], hyphen.as_slice());\n         test_connect!(\"a-b\", vec![\"a\", \"b\"].as_slice(), \"-\");\n         test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n-\n-        let mut v0 = [\"a\", \"b\"];\n-        let mut v1 = [s(\"a\"), s(\"b\")];\n-        unsafe {\n-            use std::c_vec::CVec;\n-\n-            test_connect!(\"a-b\", CVec::new(v0.as_mut_ptr(), v0.len()), \"-\");\n-            test_connect!(\"a-b\", CVec::new(v1.as_mut_ptr(), v1.len()), hyphen.as_slice());\n-        }\n-\n-        test_connect!(\"a-b\", S { x: [s(\"a\"), s(\"b\")] }, \"-\");\n     }\n \n     #[test]\n@@ -3339,7 +3272,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use super::*;\n-    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt, SliceConcatExt};\n     use test::Bencher;\n     use test::black_box;\n \n@@ -3502,7 +3435,7 @@ mod bench {\n     fn bench_connect(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let sep = \"\u2192\";\n-        let v = [s, s, s, s, s, s, s, s, s, s];\n+        let v = vec![s, s, s, s, s, s, s, s, s, s];\n         b.iter(|| {\n             assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n         })"}, {"sha": "f703ff99660c6ae4691119ad4d830d8b530f0300", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -151,7 +151,7 @@ impl String {\n         let mut i = 0;\n         let total = v.len();\n         fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n-            unsafe { *xs.unsafe_get(i) }\n+            unsafe { *xs.get_unchecked(i) }\n         }\n         fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n             if i >= total {\n@@ -815,6 +815,7 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n+#[stable]\n impl PartialEq for String {\n     #[inline]\n     fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -824,13 +825,15 @@ impl PartialEq for String {\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n+        #[stable]\n         impl<'a> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n+        #[stable]\n         impl<'a> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -844,13 +847,15 @@ macro_rules! impl_eq {\n impl_eq! { String, &'a str }\n impl_eq! { CowString<'a>, String }\n \n+#[stable]\n impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n+#[stable]\n impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     #[inline]\n     fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -989,20 +994,11 @@ pub trait ToString {\n }\n \n impl<T: fmt::Show> ToString for T {\n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     fn to_string(&self) -> String {\n         let mut buf = Vec::<u8>::new();\n         let _ = fmt::write(&mut buf, format_args!(\"{}\", *self));\n         String::from_utf8(buf).unwrap()\n     }\n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    fn to_string(&self) -> String {\n-        let mut buf = Vec::<u8>::new();\n-        let _ = format_args!(|args| fmt::write(&mut buf, args), \"{}\", self);\n-        String::from_utf8(buf).unwrap()\n-    }\n }\n \n impl IntoCow<'static, String, str> for String {"}, {"sha": "a1952352badfaa28115cfad197b07a9840bd463a", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 916, "deletions": 1001, "changes": 1917, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -142,26 +142,9 @@ pub struct Vec<T> {\n unsafe impl<T: Send> Send for Vec<T> { }\n unsafe impl<T: Sync> Sync for Vec<T> { }\n \n-/// A clone-on-write vector\n-pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n-\n-impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n-    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n-        Cow::Owned(FromIterator::from_iter(it))\n-    }\n-}\n-\n-impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n-        Cow::Owned(self)\n-    }\n-}\n-\n-impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n-        Cow::Borrowed(self)\n-    }\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Inherent methods\n+////////////////////////////////////////////////////////////////////////////////\n \n impl<T> Vec<T> {\n     /// Constructs a new, empty `Vec<T>`.\n@@ -190,8 +173,7 @@ impl<T> Vec<T> {\n     ///\n     /// It is important to note that this function does not specify the *length* of the returned\n     /// vector, but only the *capacity*. (For an explanation of the difference between length and\n-    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.) To create a\n-    /// vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n+    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.)\n     ///\n     /// # Examples\n     ///\n@@ -225,30 +207,11 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates and initializes a `Vec<T>`.\n-    ///\n-    /// Creates a `Vec<T>` of size `length` and initializes the elements to the value returned by\n-    /// the closure `op`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = Vec::from_fn(3, |idx| idx * 2);\n-    /// assert_eq!(vec, vec![0, 2, 4]);\n-    /// ```\n+    /// Deprecated: use `iter::range(0, length).map(op).collect()` instead\n     #[inline]\n-    #[unstable = \"the naming is uncertain as well as this migrating to unboxed \\\n-                  closures in the future\"]\n-    pub fn from_fn<F>(length: uint, mut op: F) -> Vec<T> where F: FnMut(uint) -> T {\n-        unsafe {\n-            let mut xs = Vec::with_capacity(length);\n-            while xs.len < length {\n-                let len = xs.len;\n-                ptr::write(xs.unsafe_mut(len), op(len));\n-                xs.len += 1;\n-            }\n-            xs\n-        }\n+    #[deprecated = \"use iter::range(0, length).map(op).collect() instead\"]\n+    pub fn from_fn<F>(length: uint, op: F) -> Vec<T> where F: FnMut(uint) -> T {\n+        range(0, length).map(op).collect()\n     }\n \n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n@@ -285,7 +248,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable = \"needs finalization\"]\n+    #[stable]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n@@ -297,953 +260,802 @@ impl<T> Vec<T> {\n     /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n     /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable = \"just renamed from raw::from_buf\"]\n+    #[unstable = \"may be better expressed via composition\"]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n         dst\n     }\n \n-    /// Consumes the `Vec<T>`, partitioning it based on a predicate.\n-    ///\n-    /// Partitions the `Vec<T>` into two `Vec<T>`s `(A,B)`, where all elements of `A` satisfy `f`\n-    /// and all elements of `B` do not. The order of elements is preserved.\n+    /// Deprecated: use `into_iter().partition(f)` instead.\n+    #[inline]\n+    #[deprecated = \"use into_iter().partition(f) instead\"]\n+    pub fn partition<F>(self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.into_iter().partition(f)\n+    }\n+\n+    /// Returns the number of elements the vector can hold without\n+    /// reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2i, 3i, 4i];\n-    /// let (even, odd) = vec.partition(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2, 4]);\n-    /// assert_eq!(odd, vec![1, 3]);\n+    /// let vec: Vec<int> = Vec::with_capacity(10);\n+    /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n-    #[experimental]\n-    pub fn partition<F>(self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.into_iter() {\n-            if f(&elt) {\n-                lefts.push(elt);\n-            } else {\n-                rights.push(elt);\n-            }\n-        }\n+    #[stable]\n+    pub fn capacity(&self) -> uint {\n+        self.cap\n+    }\n \n-        (lefts, rights)\n+    /// Deprecated: Renamed to `reserve`.\n+    #[deprecated = \"Renamed to `reserve`\"]\n+    pub fn reserve_additional(&mut self, extra: uint) {\n+        self.reserve(extra)\n     }\n-}\n \n-impl<T: Clone> Vec<T> {\n-    /// Constructs a `Vec<T>` with copies of a value.\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n+    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n     ///\n-    /// Creates a `Vec<T>` with `length` copies of `value`.\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = Vec::from_elem(3, \"hi\");\n-    /// println!(\"{}\", vec); // prints [hi, hi, hi]\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[inline]\n-    #[unstable = \"this functionality may become more generic over all collections\"]\n-    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n-        unsafe {\n-            let mut xs = Vec::with_capacity(length);\n-            while xs.len < length {\n-                let len = xs.len;\n-                ptr::write(xs.unsafe_mut(len),\n-                           value.clone());\n-                xs.len += 1;\n-            }\n-            xs\n+    #[stable]\n+    pub fn reserve(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            let err_msg = \"Vec::reserve: `uint` overflow\";\n+            let new_cap = self.len.checked_add(additional).expect(err_msg)\n+                .checked_next_power_of_two().expect(err_msg);\n+            self.grow_capacity(new_cap);\n         }\n     }\n \n-    /// Appends all elements in a slice to the `Vec<T>`.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `Vec<T>`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n-    /// Iterates over the slice `other`, clones each element, and then appends\n-    /// it to this `Vec<T>`. The `other` vector is traversed in-order.\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i];\n-    /// vec.push_all(&[2i, 3, 4]);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve_exact(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[inline]\n-    #[experimental]\n-    pub fn push_all(&mut self, other: &[T]) {\n-        self.reserve(other.len());\n-\n-        for i in range(0, other.len()) {\n-            let len = self.len();\n-\n-            // Unsafe code so this can be optimised to a memcpy (or something similarly\n-            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n-            // during the loop can prevent this optimisation.\n-            unsafe {\n-                ptr::write(\n-                    self.unsafe_mut(len),\n-                    other.unsafe_get(i).clone());\n-                self.set_len(len + 1);\n+    #[stable]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            match self.len.checked_add(additional) {\n+                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                Some(new_cap) => self.grow_capacity(new_cap)\n             }\n         }\n     }\n \n-    /// Grows the `Vec<T>` in-place.\n+    /// Shrinks the capacity of the vector as much as possible.\n     ///\n-    /// Adds `n` copies of `value` to the `Vec<T>`.\n+    /// It will drop down as close as possible to the length but the allocator\n+    /// may still inform the vector that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![\"hello\"];\n-    /// vec.grow(2, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n+    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    /// vec.push_all(&[1, 2, 3]);\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// vec.shrink_to_fit();\n+    /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n-    pub fn grow(&mut self, n: uint, value: T) {\n-        self.reserve(n);\n-        let mut i: uint = 0u;\n+    pub fn shrink_to_fit(&mut self) {\n+        if mem::size_of::<T>() == 0 { return }\n+\n+        if self.len == 0 {\n+            if self.cap != 0 {\n+                unsafe {\n+                    dealloc(*self.ptr, self.cap)\n+                }\n+                self.cap = 0;\n+            }\n+        } else {\n+            unsafe {\n+                // Overflow check is unnecessary as the vector is already at\n+                // least this large.\n+                let ptr = reallocate(*self.ptr as *mut u8,\n+                                     self.cap * mem::size_of::<T>(),\n+                                     self.len * mem::size_of::<T>(),\n+                                     mem::min_align_of::<T>()) as *mut T;\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n+            }\n+            self.cap = self.len;\n+        }\n+    }\n \n-        while i < n {\n-            self.push(value.clone());\n-            i += 1u;\n+    /// Convert the vector into Box<[T]>.\n+    ///\n+    /// Note that this will drop any excess capacity. Calling this and\n+    /// converting back to a vector with `into_vec()` is equivalent to calling\n+    /// `shrink_to_fit()`.\n+    #[experimental]\n+    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n+        self.shrink_to_fit();\n+        unsafe {\n+            let xs: Box<[T]> = mem::transmute(self.as_mut_slice());\n+            mem::forget(self);\n+            xs\n         }\n     }\n \n-    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n+    /// Shorten a vector, dropping excess elements.\n     ///\n-    /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n-    /// is larger than the current value of `len()` or not.\n+    /// If `len` is greater than the vector's current length, this has no\n+    /// effect.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![\"hello\"];\n-    /// vec.resize(3, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n-    ///\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.resize(2, 0);\n+    /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n-    pub fn resize(&mut self, new_len: uint, value: T) {\n-        let len = self.len();\n-\n-        if new_len > len {\n-            self.extend(repeat(value).take(new_len - len));\n-        } else {\n-            self.truncate(new_len);\n+    #[stable]\n+    pub fn truncate(&mut self, len: uint) {\n+        unsafe {\n+            // drop any extra elements\n+            while len < self.len {\n+                // decrement len before the read(), so a panic on Drop doesn't\n+                // re-drop the just-failed value.\n+                self.len -= 1;\n+                ptr::read(self.get_unchecked(self.len));\n+            }\n         }\n     }\n \n-    /// Partitions a vector based on a predicate.\n-    ///\n-    /// Clones the elements of the vector, partitioning them into two `Vec<T>`s\n-    /// `(a, b)`, where all elements of `a` satisfy `f` and all elements of `b`\n-    /// do not. The order of elements is preserved.\n+    /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// let (even, odd) = vec.partitioned(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2i, 4]);\n-    /// assert_eq!(odd, vec![1i, 3]);\n+    /// fn foo(slice: &mut [int]) {}\n+    ///\n+    /// let mut vec = vec![1i, 2];\n+    /// foo(vec.as_mut_slice());\n     /// ```\n-    #[experimental]\n-    pub fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push(elt.clone());\n-            } else {\n-                rights.push(elt.clone());\n-            }\n+    #[inline]\n+    #[stable]\n+    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        unsafe {\n+            mem::transmute(RawSlice {\n+                data: *self.ptr as *const T,\n+                len: self.len,\n+            })\n         }\n-\n-        (lefts, rights)\n     }\n-}\n-\n-#[stable]\n-impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n-\n-    fn clone_from(&mut self, other: &Vec<T>) {\n-        // drop anything in self that will not be overwritten\n-        if self.len() > other.len() {\n-            self.truncate(other.len())\n-        }\n \n-        // reuse the contained values' allocations/resources.\n-        for (place, thing) in self.iter_mut().zip(other.iter()) {\n-            place.clone_from(thing)\n+    /// Creates a consuming iterator, that is, one that moves each value out of\n+    /// the vector (from start to end). The vector cannot be used after calling\n+    /// this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.into_iter() {\n+    ///     // s has type String, not &String\n+    ///     println!(\"{}\", s);\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            let ptr = *self.ptr;\n+            let cap = self.cap;\n+            let begin = ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as uint + self.len()) as *const T\n+            } else {\n+                ptr.offset(self.len() as int) as *const T\n+            };\n+            mem::forget(self);\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n         }\n-\n-        // self.len <= other.len due to the truncate above, so the\n-        // slice here is always in-bounds.\n-        let slice = other[self.len()..];\n-        self.push_all(slice);\n     }\n-}\n \n-#[experimental = \"waiting on Index stability\"]\n-impl<T> Index<uint,T> for Vec<T> {\n+    /// Sets the length of a vector.\n+    ///\n+    /// This will explicitly set the size of the vector, without actually\n+    /// modifying its buffers, so it is up to the caller to ensure that the\n+    /// vector is actually the specified size.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = vec![1u, 2, 3, 4];\n+    /// unsafe {\n+    ///     v.set_len(1);\n+    /// }\n+    /// ```\n     #[inline]\n-    fn index<'a>(&'a self, index: &uint) -> &'a T {\n-        &self.as_slice()[*index]\n+    #[stable]\n+    pub unsafe fn set_len(&mut self, len: uint) {\n+        self.len = len;\n     }\n-}\n \n-impl<T> IndexMut<uint,T> for Vec<T> {\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n-        &mut self.as_mut_slice()[*index]\n-    }\n-}\n-\n-impl<T> ops::Slice<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self.as_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.as_slice().slice_from_or_fail(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_to_or_fail(end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_or_fail(start, end)\n-    }\n-}\n-\n-impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self.as_mut_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_or_fail_mut(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_or_fail_mut(end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_or_fail_mut(start, end)\n-    }\n-}\n-\n-#[experimental = \"waiting on Deref stability\"]\n-impl<T> ops::Deref<[T]> for Vec<T> {\n-    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n-}\n-\n-#[experimental = \"waiting on DerefMut stability\"]\n-impl<T> ops::DerefMut<[T]> for Vec<T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n-}\n-\n-#[experimental = \"waiting on FromIterator stability\"]\n-impl<T> FromIterator<T> for Vec<T> {\n-    #[inline]\n-    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n-        let (lower, _) = iterator.size_hint();\n-        let mut vector = Vec::with_capacity(lower);\n-        for element in iterator {\n-            vector.push(element)\n-        }\n-        vector\n-    }\n-}\n-\n-#[experimental = \"waiting on Extend stability\"]\n-impl<T> Extend<T> for Vec<T> {\n-    #[inline]\n-    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n-        let (lower, _) = iterator.size_hint();\n-        self.reserve(lower);\n-        for element in iterator {\n-            self.push(element)\n-        }\n-    }\n-}\n-\n-impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq {\n-    ($lhs:ty, $rhs:ty) => {\n-        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq! { Vec<A>, &'b [B] }\n-impl_eq! { Vec<A>, &'b mut [B] }\n-\n-impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n-    #[inline]\n-    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq_for_cowvec {\n-    ($rhs:ty) => {\n-        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq_for_cowvec! { &'b [B] }\n-impl_eq_for_cowvec! { &'b mut [B] }\n-\n-#[unstable = \"waiting on PartialOrd stability\"]\n-impl<T: PartialOrd> PartialOrd for Vec<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n-        self.as_slice().partial_cmp(other.as_slice())\n-    }\n-}\n-\n-#[unstable = \"waiting on Eq stability\"]\n-impl<T: Eq> Eq for Vec<T> {}\n-\n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n-    #[inline]\n-    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-}\n-\n-#[unstable = \"waiting on Ord stability\"]\n-impl<T: Ord> Ord for Vec<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Vec<T>) -> Ordering {\n-        self.as_slice().cmp(other.as_slice())\n-    }\n-}\n-\n-impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n-// FIXME: #13996: need a way to mark the return value as `noalias`\n-#[inline(never)]\n-unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n-    if old_size == 0 {\n-        allocate(size, mem::min_align_of::<T>()) as *mut T\n-    } else {\n-        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n-    }\n-}\n-\n-#[inline]\n-unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n-    if mem::size_of::<T>() != 0 {\n-        deallocate(ptr as *mut u8,\n-                   len * mem::size_of::<T>(),\n-                   mem::min_align_of::<T>())\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    /// Returns the number of elements the vector can hold without reallocating.\n+    /// Removes an element from anywhere in the vector and return it, replacing\n+    /// it with the last element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec: Vec<int> = Vec::with_capacity(10);\n-    /// assert_eq!(vec.capacity(), 10);\n+    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n+    ///\n+    /// assert_eq!(v.swap_remove(1), \"bar\");\n+    /// assert_eq!(v, vec![\"foo\", \"qux\", \"baz\"]);\n+    ///\n+    /// assert_eq!(v.swap_remove(0), \"foo\");\n+    /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn capacity(&self) -> uint {\n-        self.cap\n-    }\n-\n-    /// Deprecated: Renamed to `reserve`.\n-    #[deprecated = \"Renamed to `reserve`\"]\n-    pub fn reserve_additional(&mut self, extra: uint) {\n-        self.reserve(extra)\n+    pub fn swap_remove(&mut self, index: uint) -> T {\n+        let length = self.len();\n+        self.swap(index, length - 1);\n+        self.pop().unwrap()\n     }\n \n-    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Inserts an element at position `index` within the vector, shifting all\n+    /// elements after position `i` one position to the right.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if `index` is not between `0` and the vector's length (both\n+    /// bounds inclusive).\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n-    /// vec.reserve(10);\n-    /// assert!(vec.capacity() >= 11);\n+    /// let mut vec = vec![1i, 2, 3];\n+    /// vec.insert(1, 4);\n+    /// assert_eq!(vec, vec![1, 4, 2, 3]);\n+    /// vec.insert(4, 5);\n+    /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve(&mut self, additional: uint) {\n-        if self.cap - self.len < additional {\n-            let err_msg = \"Vec::reserve: `uint` overflow\";\n-            let new_cap = self.len.checked_add(additional).expect(err_msg)\n-                                  .checked_next_power_of_two().expect(err_msg);\n-            self.grow_capacity(new_cap);\n+    #[stable]\n+    pub fn insert(&mut self, index: uint, element: T) {\n+        let len = self.len();\n+        assert!(index <= len);\n+        // space for the new element\n+        self.reserve(1);\n+\n+        unsafe { // infallible\n+            // The spot to put the new value\n+            {\n+                let p = self.as_mut_ptr().offset(index as int);\n+                // Shift everything over to make space. (Duplicating the\n+                // `index`th element into two consecutive places.)\n+                ptr::copy_memory(p.offset(1), &*p, len - index);\n+                // Write it in, overwriting the first copy of the `index`th\n+                // element.\n+                ptr::write(&mut *p, element);\n+            }\n+            self.set_len(len + 1);\n         }\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `Vec<T>`. Does nothing if the capacity is already sufficient.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n-    /// insertions are expected.\n+    /// Removes and returns the element at position `index` within the vector,\n+    /// shifting all elements after position `index` one position to the left.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if `i` is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n-    /// vec.reserve_exact(10);\n-    /// assert!(vec.capacity() >= 11);\n+    /// let mut v = vec![1i, 2, 3];\n+    /// assert_eq!(v.remove(1), 2);\n+    /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n-        if self.cap - self.len < additional {\n-            match self.len.checked_add(additional) {\n-                None => panic!(\"Vec::reserve: `uint` overflow\"),\n-                Some(new_cap) => self.grow_capacity(new_cap)\n+    #[stable]\n+    pub fn remove(&mut self, index: uint) -> T {\n+        let len = self.len();\n+        assert!(index < len);\n+        unsafe { // infallible\n+            let ret;\n+            {\n+                // the place we are taking from.\n+                let ptr = self.as_mut_ptr().offset(index as int);\n+                // copy it out, unsafely having a copy of the value on\n+                // the stack and in the vector at the same time.\n+                ret = ptr::read(ptr as *const T);\n+\n+                // Shift everything down to fill in that spot.\n+                ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n             }\n+            self.set_len(len - 1);\n+            ret\n         }\n     }\n \n-    /// Shrinks the capacity of the vector as much as possible.\n+    /// Retains only the elements specified by the predicate.\n     ///\n-    /// It will drop down as close as possible to the length but the allocator may still inform the\n-    /// vector that there is space for a few more elements.\n+    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n+    /// This method operates in place and preserves the order of the retained\n+    /// elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n-    ///\n-    /// vec.push_all(&[1, 2, 3]);\n-    /// assert_eq!(vec.capacity(), 10);\n-    ///\n-    /// vec.shrink_to_fit();\n-    /// assert!(vec.capacity() >= 3);\n+    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// vec.retain(|&x| x%2 == 0);\n+    /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n     #[stable]\n-    pub fn shrink_to_fit(&mut self) {\n-        if mem::size_of::<T>() == 0 { return }\n+    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n+        let len = self.len();\n+        let mut del = 0u;\n+        {\n+            let v = self.as_mut_slice();\n \n-        if self.len == 0 {\n-            if self.cap != 0 {\n-                unsafe {\n-                    dealloc(*self.ptr, self.cap)\n+            for i in range(0u, len) {\n+                if !f(&v[i]) {\n+                    del += 1;\n+                } else if del > 0 {\n+                    v.swap(i-del, i);\n                 }\n-                self.cap = 0;\n-            }\n-        } else {\n-            unsafe {\n-                // Overflow check is unnecessary as the vector is already at\n-                // least this large.\n-                let ptr = reallocate(*self.ptr as *mut u8,\n-                                     self.cap * mem::size_of::<T>(),\n-                                     self.len * mem::size_of::<T>(),\n-                                     mem::min_align_of::<T>()) as *mut T;\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n             }\n-            self.cap = self.len;\n+        }\n+        if del > 0 {\n+            self.truncate(len - del);\n         }\n     }\n \n-    /// Convert the vector into Box<[T]>.\n-    ///\n-    /// Note that this will drop any excess capacity. Calling this and converting back to a vector\n-    /// with `into_vec()` is equivalent to calling `shrink_to_fit()`.\n-    #[experimental]\n-    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n-        self.shrink_to_fit();\n-        unsafe {\n-            let xs: Box<[T]> = mem::transmute(self.as_mut_slice());\n-            mem::forget(self);\n-            xs\n-        }\n+    /// Deprecated: use `extend(range(0, n).map(f))` instead.\n+    #[deprecated = \"use extend(range(0, n).map(f)) instead\"]\n+    pub fn grow_fn<F>(&mut self, n: uint, f: F) where F: FnMut(uint) -> T {\n+        self.extend(range(0, n).map(f));\n     }\n \n-    /// Shorten a vector, dropping excess elements.\n+    /// Appends an element to the back of a collection.\n     ///\n-    /// If `len` is greater than the vector's current length, this has no\n-    /// effect.\n+    /// # Panics\n+    ///\n+    /// Panics if the number of elements in the vector overflows a `uint`.\n     ///\n     /// # Examples\n     ///\n+    /// ```rust\n+    /// let mut vec = vec!(1i, 2);\n+    /// vec.push(3);\n+    /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.truncate(2);\n-    /// assert_eq!(vec, vec![1, 2]);\n-    /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n-    pub fn truncate(&mut self, len: uint) {\n-        unsafe {\n-            // drop any extra elements\n-            while len < self.len {\n-                // decrement len before the read(), so a panic on Drop doesn't\n-                // re-drop the just-failed value.\n-                self.len -= 1;\n-                ptr::read(self.unsafe_get(self.len));\n+    #[inline]\n+    #[stable]\n+    pub fn push(&mut self, value: T) {\n+        if mem::size_of::<T>() == 0 {\n+            // zero-size types consume no memory, so we can't rely on the\n+            // address space running out\n+            self.len = self.len.checked_add(1).expect(\"length overflow\");\n+            unsafe { mem::forget(value); }\n+            return\n+        }\n+        if self.len == self.cap {\n+            let old_size = self.cap * mem::size_of::<T>();\n+            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n+            if old_size > size { panic!(\"capacity overflow\") }\n+            unsafe {\n+                let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n             }\n+            self.cap = max(self.cap, 2) * 2;\n+        }\n+\n+        unsafe {\n+            let end = (*self.ptr).offset(self.len as int);\n+            ptr::write(&mut *end, value);\n+            self.len += 1;\n         }\n     }\n \n-    /// Returns a mutable slice of the elements of `self`.\n+    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n-    /// ```\n-    /// fn foo(slice: &mut [int]) {}\n-    ///\n-    /// let mut vec = vec![1i, 2];\n-    /// foo(vec.as_mut_slice());\n+    /// ```rust\n+    /// let mut vec = vec![1i, 2, 3];\n+    /// assert_eq!(vec.pop(), Some(3));\n+    /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        unsafe {\n-            mem::transmute(RawSlice {\n-                data: *self.ptr as *const T,\n-                len: self.len,\n-            })\n+    pub fn pop(&mut self) -> Option<T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            unsafe {\n+                self.len -= 1;\n+                Some(ptr::read(self.get_unchecked(self.len())))\n+            }\n         }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each value out of the vector (from\n-    /// start to end). The vector cannot be used after calling this.\n+    /// Creates a draining iterator that clears the `Vec` and iterates over\n+    /// the removed items from start to end.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n-    ///\n-    /// for s in v.into_iter() {\n+    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.drain() {\n     ///     // s has type String, not &String\n     ///     println!(\"{}\", s);\n     /// }\n+    /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> IntoIter<T> {\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n-            let ptr = *self.ptr;\n-            let cap = self.cap;\n-            let begin = ptr as *const T;\n+            let begin = *self.ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as uint + self.len()) as *const T\n+                (*self.ptr as uint + self.len()) as *const T\n             } else {\n-                ptr.offset(self.len() as int) as *const T\n+                (*self.ptr).offset(self.len() as int) as *const T\n             };\n-            mem::forget(self);\n-            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n+            self.set_len(0);\n+            Drain {\n+                ptr: begin,\n+                end: end,\n+                marker: ContravariantLifetime,\n+            }\n         }\n     }\n \n-    /// Sets the length of a vector.\n-    ///\n-    /// This will explicitly set the size of the vector, without actually modifying its buffers, so\n-    /// it is up to the caller to ensure that the vector is actually the specified size.\n+    /// Clears the vector, removing all values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1u, 2, 3, 4];\n-    /// unsafe {\n-    ///     v.set_len(1);\n-    /// }\n+    /// let mut v = vec![1i, 2, 3];\n+    ///\n+    /// v.clear();\n+    ///\n+    /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n     #[stable]\n-    pub unsafe fn set_len(&mut self, len: uint) {\n-        self.len = len;\n+    pub fn clear(&mut self) {\n+        self.truncate(0)\n     }\n \n-    /// Removes an element from anywhere in the vector and return it, replacing it with the last\n-    /// element.\n-    ///\n-    /// This does not preserve ordering, but is O(1).\n-    ///\n-    /// Returns `None` if `index` is out of bounds.\n+    /// Returns the number of elements in the vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n-    ///\n-    /// assert_eq!(v.swap_remove(1), Some(\"bar\"));\n-    /// assert_eq!(v, vec![\"foo\", \"qux\", \"baz\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(0), Some(\"foo\"));\n-    /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(2), None);\n+    /// let a = vec![1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[unstable = \"the naming of this function may be altered\"]\n-    pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n-        let length = self.len();\n-        if length > 0 && index < length - 1 {\n-            self.swap(index, length - 1);\n-        } else if index >= length {\n-            return None\n-        }\n-        self.pop()\n-    }\n+    #[stable]\n+    pub fn len(&self) -> uint { self.len }\n \n-    /// Inserts an element at position `index` within the vector, shifting all elements after\n-    /// position `i` one position to the right.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `index` is not between `0` and the vector's length (both bounds inclusive).\n+    /// Returns `true` if the vector contains no elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// vec.insert(1, 4);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3]);\n-    /// vec.insert(4, 5);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n+    /// let mut v = Vec::new();\n+    /// assert!(v.is_empty());\n+    ///\n+    /// v.push(1i);\n+    /// assert!(!v.is_empty());\n     /// ```\n-    #[unstable = \"panic semantics need settling\"]\n-    pub fn insert(&mut self, index: uint, element: T) {\n-        let len = self.len();\n-        assert!(index <= len);\n-        // space for the new element\n-        self.reserve(1);\n-\n-        unsafe { // infallible\n-            // The spot to put the new value\n-            {\n-                let p = self.as_mut_ptr().offset(index as int);\n-                // Shift everything over to make space. (Duplicating the\n-                // `index`th element into two consecutive places.)\n-                ptr::copy_memory(p.offset(1), &*p, len - index);\n-                // Write it in, overwriting the first copy of the `index`th\n-                // element.\n-                ptr::write(&mut *p, element);\n-            }\n-            self.set_len(len + 1);\n-        }\n-    }\n+    #[stable]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Removes and returns the element at position `index` within the vector, shifting all\n-    /// elements after position `index` one position to the left. Returns `None` if `i` is out of\n-    /// bounds.\n+    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n+    /// size and in case they are not zero-sized the same minimal alignment.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n+    /// have differing minimal alignments.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1i, 2, 3];\n-    /// assert_eq!(v.remove(1), Some(2));\n-    /// assert_eq!(v, vec![1, 3]);\n+    /// let v = vec![0u, 1, 2];\n+    /// let w = v.map_in_place(|i| i + 3);\n+    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n     ///\n-    /// assert_eq!(v.remove(4), None);\n-    /// // v is unchanged:\n-    /// assert_eq!(v, vec![1, 3]);\n+    /// #[deriving(PartialEq, Show)]\n+    /// struct Newtype(u8);\n+    /// let bytes = vec![0x11, 0x22];\n+    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n+    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    #[unstable = \"panic semantics need settling\"]\n-    pub fn remove(&mut self, index: uint) -> Option<T> {\n-        let len = self.len();\n-        if index < len {\n-            unsafe { // infallible\n-                let ret;\n-                {\n-                    // the place we are taking from.\n-                    let ptr = self.as_mut_ptr().offset(index as int);\n-                    // copy it out, unsafely having a copy of the value on\n-                    // the stack and in the vector at the same time.\n-                    ret = Some(ptr::read(ptr as *const T));\n-\n-                    // Shift everything down to fill in that spot.\n-                    ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n+    #[experimental = \"API may change to provide stronger guarantees\"]\n+    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n+        // FIXME: Assert statically that the types `T` and `U` have the same\n+        // size.\n+        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n+\n+        let mut vec = self;\n+\n+        if mem::size_of::<T>() != 0 {\n+            // FIXME: Assert statically that the types `T` and `U` have the\n+            // same minimal alignment in case they are not zero-sized.\n+\n+            // These asserts are necessary because the `min_align_of` of the\n+            // types are passed to the allocator by `Vec`.\n+            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n+\n+            // This `as int` cast is safe, because the size of the elements of the\n+            // vector is not 0, and:\n+            //\n+            // 1) If the size of the elements in the vector is 1, the `int` may\n+            //    overflow, but it has the correct bit pattern so that the\n+            //    `.offset()` function will work.\n+            //\n+            //    Example:\n+            //        Address space 0x0-0xF.\n+            //        `u8` array at: 0x1.\n+            //        Size of `u8` array: 0x8.\n+            //        Calculated `offset`: -0x8.\n+            //        After `array.offset(offset)`: 0x9.\n+            //        (0x1 + 0x8 = 0x1 - 0x8)\n+            //\n+            // 2) If the size of the elements in the vector is >1, the `uint` ->\n+            //    `int` conversion can't overflow.\n+            let offset = vec.len() as int;\n+            let start = vec.as_mut_ptr();\n+\n+            let mut pv = PartialVecNonZeroSized {\n+                vec: vec,\n+\n+                start_t: start,\n+                // This points inside the vector, as the vector has length\n+                // `offset`.\n+                end_t: unsafe { start.offset(offset) },\n+                start_u: start as *mut U,\n+                end_u: start as *mut U,\n+            };\n+            //  start_t\n+            //  start_u\n+            //  |\n+            // +-+-+-+-+-+-+\n+            // |T|T|T|...|T|\n+            // +-+-+-+-+-+-+\n+            //  |           |\n+            //  end_u       end_t\n+\n+            while pv.end_u as *mut T != pv.end_t {\n+                unsafe {\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|T|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+\n+                    let t = ptr::read(pv.start_t as *const T);\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We must not panic here, one cell is marked as `T`\n+                    // although it is not `T`.\n+\n+                    pv.start_t = pv.start_t.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We may panic again.\n+\n+                    // The function given by the user might panic.\n+                    let u = f(t);\n+\n+                    ptr::write(pv.end_u, u);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We should not panic here, because that would leak the `U`\n+                    // pointed to by `end_u`.\n+\n+                    pv.end_u = pv.end_u.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //            |       |\n+                    //            end_u   end_t\n+                    // We may panic again.\n                 }\n-                self.set_len(len - 1);\n-                ret\n+            }\n+\n+            //  start_u     start_t\n+            //  |           |\n+            // +-+-+-+-+-+-+\n+            // |U|...|U|U|U|\n+            // +-+-+-+-+-+-+\n+            //              |\n+            //              end_t\n+            //              end_u\n+            // Extract `vec` and prevent the destructor of\n+            // `PartialVecNonZeroSized` from running. Note that none of the\n+            // function calls can panic, thus no resources can be leaked (as the\n+            // `vec` member of `PartialVec` is the only one which holds\n+            // allocations -- and it is returned from this function. None of\n+            // this can panic.\n+            unsafe {\n+                let vec_len = pv.vec.len();\n+                let vec_cap = pv.vec.capacity();\n+                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n+                mem::forget(pv);\n+                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n             }\n         } else {\n-            None\n-        }\n-    }\n+            // Put the `Vec` into the `PartialVecZeroSized` structure and\n+            // prevent the destructor of the `Vec` from running. Since the\n+            // `Vec` contained zero-sized objects, it did not allocate, so we\n+            // are not leaking memory here.\n+            let mut pv = PartialVecZeroSized::<T,U> {\n+                num_t: vec.len(),\n+                num_u: 0,\n+                marker_t: InvariantType,\n+                marker_u: InvariantType,\n+            };\n+            unsafe { mem::forget(vec); }\n \n-    /// Retains only the elements specified by the predicate.\n-    ///\n-    /// In other words, remove all elements `e` such that `f(&e)` returns false. This method\n-    /// operates in place and preserves the order of the retained elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.retain(|&x| x%2 == 0);\n-    /// assert_eq!(vec, vec![2, 4]);\n-    /// ```\n-    #[unstable = \"the closure argument may become an unboxed closure\"]\n-    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n-        let len = self.len();\n-        let mut del = 0u;\n-        {\n-            let v = self.as_mut_slice();\n+            while pv.num_t != 0 {\n+                unsafe {\n+                    // Create a `T` out of thin air and decrement `num_t`. This\n+                    // must not panic between these steps, as otherwise a\n+                    // destructor of `T` which doesn't exist runs.\n+                    let t = mem::uninitialized();\n+                    pv.num_t -= 1;\n \n-            for i in range(0u, len) {\n-                if !f(&v[i]) {\n-                    del += 1;\n-                } else if del > 0 {\n-                    v.swap(i-del, i);\n+                    // The function given by the user might panic.\n+                    let u = f(t);\n+\n+                    // Forget the `U` and increment `num_u`. This increment\n+                    // cannot overflow the `uint` as we only do this for a\n+                    // number of times that fits into a `uint` (and start with\n+                    // `0`). Again, we should not panic between these steps.\n+                    mem::forget(u);\n+                    pv.num_u += 1;\n                 }\n             }\n-        }\n-        if del > 0 {\n-            self.truncate(len - del);\n+            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n+            // destructor of the latter will not run. None of this can panic.\n+            let mut result = Vec::new();\n+            unsafe {\n+                result.set_len(pv.num_u);\n+                mem::forget(pv);\n+            }\n+            result\n         }\n     }\n+}\n \n-    /// Expands a vector in place, initializing the new elements to the result of a function.\n-    ///\n-    /// The vector is grown by `n` elements. The i-th new element are initialized to the value\n-    /// returned by `f(i)` where `i` is in the range [0, n).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec![0u, 1];\n-    /// vec.grow_fn(3, |i| i);\n-    /// assert_eq!(vec, vec![0, 1, 0, 1, 2]);\n-    /// ```\n-    #[unstable = \"this function may be renamed or change to unboxed closures\"]\n-    pub fn grow_fn<F>(&mut self, n: uint, mut f: F) where F: FnMut(uint) -> T {\n-        self.reserve(n);\n-        for i in range(0u, n) {\n-            self.push(f(i));\n-        }\n+impl<T: Clone> Vec<T> {\n+    /// Deprecated: use `repeat(value).take(length).collect()` instead.\n+    #[inline]\n+    #[deprecated = \"use repeat(value).take(length).collect() instead\"]\n+    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n+        repeat(value).take(length).collect()\n     }\n \n-    /// Appends an element to the back of a collection.\n-    ///\n-    /// # Panics\n+    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n     ///\n-    /// Panics if the number of elements in the vector overflows a `uint`.\n+    /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n+    /// is larger than the current value of `len()` or not.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n-    /// let mut vec = vec!(1i, 2);\n-    /// vec.push(3);\n-    /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn push(&mut self, value: T) {\n-        if mem::size_of::<T>() == 0 {\n-            // zero-size types consume no memory, so we can't rely on the address space running out\n-            self.len = self.len.checked_add(1).expect(\"length overflow\");\n-            unsafe { mem::forget(value); }\n-            return\n-        }\n-        if self.len == self.cap {\n-            let old_size = self.cap * mem::size_of::<T>();\n-            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n-            if old_size > size { panic!(\"capacity overflow\") }\n-            unsafe {\n-                let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n-            }\n-            self.cap = max(self.cap, 2) * 2;\n-        }\n-\n-        unsafe {\n-            let end = (*self.ptr).offset(self.len as int);\n-            ptr::write(&mut *end, value);\n-            self.len += 1;\n-        }\n-    }\n-\n-    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n-    ///\n-    /// # Examples\n+    /// let mut vec = vec![\"hello\"];\n+    /// vec.resize(3, \"world\");\n+    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n     ///\n-    /// ```rust\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// assert_eq!(vec.pop(), Some(3));\n+    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn pop(&mut self) -> Option<T> {\n-        if self.len == 0 {\n-            None\n-        } else {\n-            unsafe {\n-                self.len -= 1;\n-                Some(ptr::read(self.unsafe_get(self.len())))\n-            }\n-        }\n-    }\n+    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n+    pub fn resize(&mut self, new_len: uint, value: T) {\n+        let len = self.len();\n \n-    /// Creates a draining iterator that clears the `Vec` and iterates over\n-    /// the removed items from start to end.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n-    /// for s in v.drain() {\n-    ///     // s has type String, not &String\n-    ///     println!(\"{}\", s);\n-    /// }\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n-        unsafe {\n-            let begin = *self.ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (*self.ptr as uint + self.len()) as *const T\n-            } else {\n-                (*self.ptr).offset(self.len() as int) as *const T\n-            };\n-            self.set_len(0);\n-            Drain {\n-                ptr: begin,\n-                end: end,\n-                marker: ContravariantLifetime,\n-            }\n+        if new_len > len {\n+            self.extend(repeat(value).take(new_len - len));\n+        } else {\n+            self.truncate(new_len);\n         }\n     }\n \n-    /// Clears the vector, removing all values.\n-    ///\n-    /// # Examples\n+    /// Appends all elements in a slice to the `Vec`.\n     ///\n-    /// ```\n-    /// let mut v = vec![1i, 2, 3];\n-    ///\n-    /// v.clear();\n-    ///\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn clear(&mut self) {\n-        self.truncate(0)\n-    }\n-\n-    /// Returns the number of elements in the vector.\n+    /// Iterates over the slice `other`, clones each element, and then appends\n+    /// it to this `Vec`. The `other` vector is traversed in-order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let a = vec![1i, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n+    /// let mut vec = vec![1i];\n+    /// vec.push_all(&[2i, 3, 4]);\n+    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[stable]\n-    pub fn len(&self) -> uint { self.len }\n-\n-    /// Returns `true` if the vector contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = Vec::new();\n-    /// assert!(v.is_empty());\n-    ///\n-    /// v.push(1i);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    #[experimental = \"likely to be replaced by a more optimized extend\"]\n+    pub fn push_all(&mut self, other: &[T]) {\n+        self.reserve(other.len());\n \n-    /// Reserves capacity for exactly `capacity` elements in the given vector.\n-    ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n-    fn grow_capacity(&mut self, capacity: uint) {\n-        if mem::size_of::<T>() == 0 { return }\n+        for i in range(0, other.len()) {\n+            let len = self.len();\n \n-        if capacity > self.cap {\n-            let size = capacity.checked_mul(mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n+            // Unsafe code so this can be optimised to a memcpy (or something similarly\n+            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n+            // during the loop can prevent this optimisation.\n             unsafe {\n-                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                ptr::write(\n+                    self.get_unchecked_mut(len),\n+                    other.get_unchecked(i).clone());\n+                self.set_len(len + 1);\n             }\n-            self.cap = capacity;\n         }\n     }\n+\n+    /// Deprecated: use `extend(repeat(value).take(n))` instead\n+    #[deprecated = \"use extend(repeat(value).take(n)) instead\"]\n+    pub fn grow(&mut self, n: uint, value: T) {\n+        self.extend(repeat(value).take(n))\n+    }\n+\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    pub fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.iter().cloned().partition(f)\n+    }\n }\n \n impl<T: PartialEq> Vec<T> {\n@@ -1260,7 +1072,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n-    #[unstable = \"this function may be renamed\"]\n+    #[stable]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1341,8 +1153,276 @@ impl<T: PartialEq> Vec<T> {\n                 r += 1;\n             }\n \n-            self.truncate(w);\n-        }\n+            self.truncate(w);\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Public free fns\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Deprecated: use `unzip` directly on the iterator instead.\n+#[deprecated = \"use unzip directly on the iterator instead\"]\n+pub fn unzip<T, U, V: Iterator<(T, U)>>(iter: V) -> (Vec<T>, Vec<U>) {\n+    iter.unzip()\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Internal methods and functions\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> Vec<T> {\n+    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    ///\n+    /// If the capacity for `self` is already equal to or greater than the\n+    /// requested capacity, then no action is taken.\n+    fn grow_capacity(&mut self, capacity: uint) {\n+        if mem::size_of::<T>() == 0 { return }\n+\n+        if capacity > self.cap {\n+            let size = capacity.checked_mul(mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+            unsafe {\n+                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n+            }\n+            self.cap = capacity;\n+        }\n+    }\n+}\n+\n+// FIXME: #13996: need a way to mark the return value as `noalias`\n+#[inline(never)]\n+unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n+    if old_size == 0 {\n+        allocate(size, mem::min_align_of::<T>()) as *mut T\n+    } else {\n+        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n+    }\n+}\n+\n+#[inline]\n+unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n+    if mem::size_of::<T>() != 0 {\n+        deallocate(ptr as *mut u8,\n+                   len * mem::size_of::<T>(),\n+                   mem::min_align_of::<T>())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Common trait implementations for Vec\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[unstable]\n+impl<T:Clone> Clone for Vec<T> {\n+    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n+\n+    fn clone_from(&mut self, other: &Vec<T>) {\n+        // drop anything in self that will not be overwritten\n+        if self.len() > other.len() {\n+            self.truncate(other.len())\n+        }\n+\n+        // reuse the contained values' allocations/resources.\n+        for (place, thing) in self.iter_mut().zip(other.iter()) {\n+            place.clone_from(thing)\n+        }\n+\n+        // self.len <= other.len due to the truncate above, so the\n+        // slice here is always in-bounds.\n+        let slice = other[self.len()..];\n+        self.push_all(slice);\n+    }\n+}\n+\n+impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n+#[experimental = \"waiting on Index stability\"]\n+impl<T> Index<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index<'a>(&'a self, index: &uint) -> &'a T {\n+        &self.as_slice()[*index]\n+    }\n+}\n+\n+impl<T> IndexMut<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+        &mut self.as_mut_slice()[*index]\n+    }\n+}\n+\n+impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self.as_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.as_slice().slice_from_or_fail(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_to_or_fail(end)\n+    }\n+    #[inline]\n+    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_or_fail(start, end)\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self.as_mut_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_from_or_fail_mut(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_to_or_fail_mut(end)\n+    }\n+    #[inline]\n+    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_or_fail_mut(start, end)\n+    }\n+}\n+\n+#[experimental = \"waiting on Deref stability\"]\n+impl<T> ops::Deref<[T]> for Vec<T> {\n+    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n+}\n+\n+#[experimental = \"waiting on DerefMut stability\"]\n+impl<T> ops::DerefMut<[T]> for Vec<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n+}\n+\n+#[experimental = \"waiting on FromIterator stability\"]\n+impl<T> FromIterator<T> for Vec<T> {\n+    #[inline]\n+    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n+        let (lower, _) = iterator.size_hint();\n+        let mut vector = Vec::with_capacity(lower);\n+        for element in iterator {\n+            vector.push(element)\n+        }\n+        vector\n+    }\n+}\n+\n+#[experimental = \"waiting on Extend stability\"]\n+impl<T> Extend<T> for Vec<T> {\n+    #[inline]\n+    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n+        let (lower, _) = iterator.size_hint();\n+        self.reserve(lower);\n+        for element in iterator {\n+            self.push(element)\n+        }\n+    }\n+}\n+\n+impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs:ty) => {\n+        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq! { Vec<A>, &'b [B] }\n+impl_eq! { Vec<A>, &'b mut [B] }\n+\n+impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n+    #[inline]\n+    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq_for_cowvec {\n+    ($rhs:ty) => {\n+        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq_for_cowvec! { &'b [B] }\n+impl_eq_for_cowvec! { &'b mut [B] }\n+\n+#[unstable = \"waiting on PartialOrd stability\"]\n+impl<T: PartialOrd> PartialOrd for Vec<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(other.as_slice())\n+    }\n+}\n+\n+#[unstable = \"waiting on Eq stability\"]\n+impl<T: Eq> Eq for Vec<T> {}\n+\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n+impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n+    #[inline]\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n+\n+#[unstable = \"waiting on Ord stability\"]\n+impl<T: Ord> Ord for Vec<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Vec<T>) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n     }\n }\n \n@@ -1408,17 +1488,58 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n+impl<'a> fmt::FormatWriter for Vec<u8> {\n+    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+        self.push_all(buf);\n+        Ok(())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Clone-on-write\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[experimental = \"unclear how valuable this alias is\"]\n+/// A clone-on-write vector\n+pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n+\n+impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n+    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n+        Cow::Owned(FromIterator::from_iter(it))\n+    }\n+}\n+\n+impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// An iterator that moves out of a vector.\n+#[stable]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n \n+#[deprecated = \"use IntoIter instead\"]\n+pub type MoveItems<T> = IntoIter<T>;\n+\n impl<T> IntoIter<T> {\n-    /// Drops all items that have not yet been moved and returns the empty vector.\n     #[inline]\n+    /// Drops all items that have not yet been moved and returns the empty vector.\n     #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n@@ -1508,6 +1629,7 @@ impl<T> Drop for IntoIter<T> {\n \n /// An iterator that drains a vector.\n #[unsafe_no_drop_flag]\n+#[unstable = \"recently added as part of collections reform 2\"]\n pub struct Drain<'a, T> {\n     ptr: *const T,\n     end: *const T,\n@@ -1584,22 +1706,9 @@ impl<'a, T> Drop for Drain<'a, T> {\n     }\n }\n \n-/// Converts an iterator of pairs into a pair of vectors.\n-///\n-/// Returns a tuple containing two vectors where the i-th element of the first vector contains the\n-/// first element of the i-th tuple of the input iterator, and the i-th element of the second\n-/// vector contains the second element of the i-th tuple of the input iterator.\n-#[unstable = \"this functionality may become more generic over time\"]\n-pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n-    let (lo, _) = iter.size_hint();\n-    let mut ts = Vec::with_capacity(lo);\n-    let mut us = Vec::with_capacity(lo);\n-    for (t, u) in iter {\n-        ts.push(t);\n-        us.push(u);\n-    }\n-    (ts, us)\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Conversion from &[T] to &Vec<T>\n+////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n #[experimental]\n@@ -1608,6 +1717,7 @@ pub struct DerefVec<'a, T> {\n     l: ContravariantLifetime<'a>\n }\n \n+#[experimental]\n impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n     fn deref<'b>(&'b self) -> &'b Vec<T> {\n         &self.x\n@@ -1616,6 +1726,7 @@ impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n+#[experimental]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1634,6 +1745,10 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Raw module (deprecated)\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Unsafe vector operations.\n #[deprecated]\n pub mod raw {\n@@ -1650,6 +1765,10 @@ pub mod raw {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Partial vec, used for map_in_place\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// An owned, partially type-converted vector of elements with non-zero size.\n ///\n /// `T` and `U` must have the same, non-zero size. They must also have the same\n@@ -1721,211 +1840,6 @@ impl<T,U> Drop for PartialVecZeroSized<T,U> {\n     }\n }\n \n-impl<T> Vec<T> {\n-    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n-    /// size and in case they are not zero-sized the same minimal alignment.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n-    /// have differing minimal alignments.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = vec![0u, 1, 2];\n-    /// let w = v.map_in_place(|i| i + 3);\n-    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n-    ///\n-    /// #[deriving(PartialEq, Show)]\n-    /// struct Newtype(u8);\n-    /// let bytes = vec![0x11, 0x22];\n-    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n-    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n-    /// ```\n-    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n-        // FIXME: Assert statically that the types `T` and `U` have the same\n-        // size.\n-        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n-\n-        let mut vec = self;\n-\n-        if mem::size_of::<T>() != 0 {\n-            // FIXME: Assert statically that the types `T` and `U` have the\n-            // same minimal alignment in case they are not zero-sized.\n-\n-            // These asserts are necessary because the `min_align_of` of the\n-            // types are passed to the allocator by `Vec`.\n-            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n-\n-            // This `as int` cast is safe, because the size of the elements of the\n-            // vector is not 0, and:\n-            //\n-            // 1) If the size of the elements in the vector is 1, the `int` may\n-            //    overflow, but it has the correct bit pattern so that the\n-            //    `.offset()` function will work.\n-            //\n-            //    Example:\n-            //        Address space 0x0-0xF.\n-            //        `u8` array at: 0x1.\n-            //        Size of `u8` array: 0x8.\n-            //        Calculated `offset`: -0x8.\n-            //        After `array.offset(offset)`: 0x9.\n-            //        (0x1 + 0x8 = 0x1 - 0x8)\n-            //\n-            // 2) If the size of the elements in the vector is >1, the `uint` ->\n-            //    `int` conversion can't overflow.\n-            let offset = vec.len() as int;\n-            let start = vec.as_mut_ptr();\n-\n-            let mut pv = PartialVecNonZeroSized {\n-                vec: vec,\n-\n-                start_t: start,\n-                // This points inside the vector, as the vector has length\n-                // `offset`.\n-                end_t: unsafe { start.offset(offset) },\n-                start_u: start as *mut U,\n-                end_u: start as *mut U,\n-            };\n-            //  start_t\n-            //  start_u\n-            //  |\n-            // +-+-+-+-+-+-+\n-            // |T|T|T|...|T|\n-            // +-+-+-+-+-+-+\n-            //  |           |\n-            //  end_u       end_t\n-\n-            while pv.end_u as *mut T != pv.end_t {\n-                unsafe {\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|T|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-\n-                    let t = ptr::read(pv.start_t as *const T);\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We must not panic here, one cell is marked as `T`\n-                    // although it is not `T`.\n-\n-                    pv.start_t = pv.start_t.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We may panic again.\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    ptr::write(pv.end_u, u);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We should not panic here, because that would leak the `U`\n-                    // pointed to by `end_u`.\n-\n-                    pv.end_u = pv.end_u.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //            |       |\n-                    //            end_u   end_t\n-                    // We may panic again.\n-                }\n-            }\n-\n-            //  start_u     start_t\n-            //  |           |\n-            // +-+-+-+-+-+-+\n-            // |U|...|U|U|U|\n-            // +-+-+-+-+-+-+\n-            //              |\n-            //              end_t\n-            //              end_u\n-            // Extract `vec` and prevent the destructor of\n-            // `PartialVecNonZeroSized` from running. Note that none of the\n-            // function calls can panic, thus no resources can be leaked (as the\n-            // `vec` member of `PartialVec` is the only one which holds\n-            // allocations -- and it is returned from this function. None of\n-            // this can panic.\n-            unsafe {\n-                let vec_len = pv.vec.len();\n-                let vec_cap = pv.vec.capacity();\n-                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n-                mem::forget(pv);\n-                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n-            }\n-        } else {\n-            // Put the `Vec` into the `PartialVecZeroSized` structure and\n-            // prevent the destructor of the `Vec` from running. Since the\n-            // `Vec` contained zero-sized objects, it did not allocate, so we\n-            // are not leaking memory here.\n-            let mut pv = PartialVecZeroSized::<T,U> {\n-                num_t: vec.len(),\n-                num_u: 0,\n-                marker_t: InvariantType,\n-                marker_u: InvariantType,\n-            };\n-            unsafe { mem::forget(vec); }\n-\n-            while pv.num_t != 0 {\n-                unsafe {\n-                    // Create a `T` out of thin air and decrement `num_t`. This\n-                    // must not panic between these steps, as otherwise a\n-                    // destructor of `T` which doesn't exist runs.\n-                    let t = mem::uninitialized();\n-                    pv.num_t -= 1;\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    // Forget the `U` and increment `num_u`. This increment\n-                    // cannot overflow the `uint` as we only do this for a\n-                    // number of times that fits into a `uint` (and start with\n-                    // `0`). Again, we should not panic between these steps.\n-                    mem::forget(u);\n-                    pv.num_u += 1;\n-                }\n-            }\n-            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n-            // destructor of the latter will not run. None of this can panic.\n-            let mut result = Vec::new();\n-            unsafe {\n-                result.set_len(pv.num_u);\n-                mem::forget(pv);\n-            }\n-            result\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::FormatWriter for Vec<u8> {\n-    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-        self.push_all(buf);\n-        Ok(())\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -2293,9 +2207,10 @@ mod tests {\n     }\n \n     #[test]\n+    #[should_fail]\n     fn test_swap_remove_empty() {\n         let mut vec: Vec<uint> = vec!();\n-        assert_eq!(vec.swap_remove(0), None);\n+        vec.swap_remove(0);\n     }\n \n     #[test]"}, {"sha": "3a7168094fff43db9ce5bb71642e72c397aeb2e3", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -448,7 +448,7 @@ impl<V> VecMap<V> {\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n-            self.v.grow_fn(key - len + 1, |_| None);\n+            self.v.extend(range(0, key - len + 1).map(|_| None));\n         }\n         replace(&mut self.v[key], Some(value))\n     }\n@@ -537,21 +537,26 @@ impl<V:Clone> VecMap<V> {\n     }\n }\n \n+\n+#[stable]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n         iter::order::eq(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<V: Eq> Eq for VecMap<V> {}\n \n+#[stable]\n impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n     fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n     fn cmp(&self, other: &VecMap<V>) -> Ordering {\n@@ -667,6 +672,17 @@ pub struct Iter<'a, V:'a> {\n     iter: slice::Iter<'a, Option<V>>\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, V> Clone for Iter<'a, V> {\n+    fn clone(&self) -> Iter<'a, V> {\n+        Iter {\n+            front: self.front,\n+            back: self.back,\n+            iter: self.iter.clone()\n+        }\n+    }\n+}\n+\n iterator! { impl Iter -> (uint, &'a V), as_ref }\n double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n@@ -686,11 +702,29 @@ pub struct Keys<'a, V: 'a> {\n     iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, V> Clone for Keys<'a, V> {\n+    fn clone(&self) -> Keys<'a, V> {\n+        Keys {\n+            iter: self.iter.clone()\n+        }\n+    }\n+}\n+\n /// An iterator over the values of a map.\n pub struct Values<'a, V: 'a> {\n     iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, V> Clone for Values<'a, V> {\n+    fn clone(&self) -> Values<'a, V> {\n+        Values {\n+            iter: self.iter.clone()\n+        }\n+    }\n+}\n+\n /// A consuming iterator over the key-value pairs of a map.\n pub struct IntoIter<V> {\n     iter: FilterMap<"}, {"sha": "88e23377046f12419cfd1c93c52f4f7600fc4ad4", "filename": "src/libcore/array.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -39,7 +39,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for PartialEq to stabilize\"]\n+            #[stable]\n             impl<A, B> PartialEq<[B, ..$N]> for [A, ..$N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B, ..$N]) -> bool {\n@@ -51,6 +51,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[stable]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A, ..$N] where\n                 A: PartialEq<B>,\n                 Rhs: Deref<[B]>,\n@@ -61,6 +62,7 @@ macro_rules! array_impls {\n                 fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self[], &**other) }\n             }\n \n+            #[stable]\n             impl<'a, A, B, Lhs> PartialEq<[B, ..$N]> for Lhs where\n                 A: PartialEq<B>,\n                 Lhs: Deref<[A]>\n@@ -71,10 +73,10 @@ macro_rules! array_impls {\n                 fn ne(&self, other: &[B, ..$N]) -> bool { PartialEq::ne(&**self, other[]) }\n             }\n \n-            #[unstable = \"waiting for Eq to stabilize\"]\n+            #[stable]\n             impl<T:Eq> Eq for [T, ..$N] { }\n \n-            #[unstable = \"waiting for PartialOrd to stabilize\"]\n+            #[stable]\n             impl<T:PartialOrd> PartialOrd for [T, ..$N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T, ..$N]) -> Option<Ordering> {\n@@ -98,7 +100,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Ord to stabilize\"]\n+            #[stable]\n             impl<T:Ord> Ord for [T, ..$N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T, ..$N]) -> Ordering {"}, {"sha": "6a40915f4dd829970102bf1a557827c5a9ff0957", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -12,7 +12,7 @@\n \n #![stable]\n \n-pub use self::Ordering::*;\n+use self::Ordering::*;\n \n use kinds::Sync;\n "}, {"sha": "3a2cb8ea7d9848e0f1bdb5cafa51b7f84b4287c1", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -200,15 +200,18 @@ impl<'a, T, Sized? B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n     }\n }\n \n+#[stable]\n impl<'a, T, Sized? B> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n+#[stable]\n impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n+#[stable]\n impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n@@ -219,6 +222,7 @@ impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B\n     }\n }\n \n+#[stable]\n impl<'a, T, Sized? B> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {"}, {"sha": "6249f7600cd22ac34d733272caacde357dfa3728", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -224,7 +224,7 @@ impl<T:Default + Copy> Default for Cell<T> {\n     }\n }\n \n-#[unstable = \"waiting for `PartialEq` trait to become stable\"]\n+#[stable]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n@@ -358,7 +358,7 @@ impl<T:Default> Default for RefCell<T> {\n     }\n }\n \n-#[unstable = \"waiting for `PartialEq` to become stable\"]\n+#[stable]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()"}, {"sha": "f0151dda8d71e57c12700a27c22a6d53efeee573", "filename": "src/libcore/char.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -430,11 +430,13 @@ impl Char for char {\n \n /// An iterator over the characters that represent a `char`, as escaped by\n /// Rust's unicode escaping rules.\n+#[deriving(Clone)]\n pub struct EscapeUnicode {\n     c: char,\n     state: EscapeUnicodeState\n }\n \n+#[deriving(Clone)]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -486,10 +488,12 @@ impl Iterator<char> for EscapeUnicode {\n \n /// An iterator over the characters that represent a `char`, escaped\n /// for maximum portability.\n+#[deriving(Clone)]\n pub struct EscapeDefault {\n     state: EscapeDefaultState\n }\n \n+#[deriving(Clone)]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),\n@@ -513,4 +517,3 @@ impl Iterator<char> for EscapeDefault {\n         }\n     }\n }\n-"}, {"sha": "367c794e84bb647b9687c05bbc41b339c9f73561", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 91, "deletions": 57, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -46,27 +46,37 @@ use self::Ordering::*;\n use kinds::Sized;\n use option::Option::{mod, Some, None};\n \n-/// Trait for values that can be compared for equality and inequality.\n+/// Trait for equality comparisons which are [partial equivalence relations](\n+/// http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n-/// This trait allows for partial equality, for types that do not have an\n+/// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not `Eq`.\n ///\n+/// Formally, the equality must be (for all `a`, `b` and `c`):\n+///\n+/// - symmetric: `a == b` implies `b == a`; and\n+/// - transitive: `a == b` and `b == c` implies `a == c`.\n+///\n+/// Note that these requirements mean that the trait itself must be\n+/// implemented symmetrically and transitively: if `T: PartialEq<U>`\n+/// and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n+/// PartialEq<V>`.\n+///\n /// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n /// in terms of it by default. Any manual implementation of `ne` *must* respect\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n-///\n-/// Eventually, this will be implemented by default for types that implement\n-/// `Eq`.\n #[lang=\"eq\"]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n+#[stable]\n pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n+    #[stable]\n     fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n+    #[stable]\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n@@ -79,8 +89,8 @@ pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Eq<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n+#[stable]\n+pub trait Eq for Sized?: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n     // itself, the current deriving infrastructure means doing this\n@@ -97,12 +107,15 @@ pub trait Eq<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n #[deriving(Clone, Copy, PartialEq, Show)]\n #[stable]\n pub enum Ordering {\n-   /// An ordering where a compared value is less [than another].\n-   Less = -1i,\n-   /// An ordering where a compared value is equal [to another].\n-   Equal = 0i,\n-   /// An ordering where a compared value is greater [than another].\n-   Greater = 1i,\n+    /// An ordering where a compared value is less [than another].\n+    #[stable]\n+    Less = -1i,\n+    /// An ordering where a compared value is equal [to another].\n+    #[stable]\n+    Equal = 0i,\n+    /// An ordering where a compared value is greater [than another].\n+    #[stable]\n+    Greater = 1i,\n }\n \n impl Ordering {\n@@ -126,7 +139,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n-    #[experimental]\n+    #[stable]\n     pub fn reverse(self) -> Ordering {\n         unsafe {\n             // this compiles really nicely (to a single instruction);\n@@ -149,8 +162,8 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Ord<Sized? Rhs = Self> for Sized?: Eq<Rhs> + PartialOrd<Rhs> {\n+#[stable]\n+pub trait Ord for Sized?: Eq + PartialOrd<Self> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching\n@@ -161,30 +174,44 @@ pub trait Ord<Sized? Rhs = Self> for Sized?: Eq<Rhs> + PartialOrd<Rhs> {\n     /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n-    fn cmp(&self, other: &Rhs) -> Ordering;\n+    #[stable]\n+    fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-#[unstable = \"Trait is unstable.\"]\n+#[stable]\n impl Eq for Ordering {}\n \n-#[unstable = \"Trait is unstable.\"]\n+#[stable]\n impl Ord for Ordering {\n     #[inline]\n+    #[stable]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n-#[unstable = \"Trait is unstable.\"]\n+#[stable]\n impl PartialOrd for Ordering {\n     #[inline]\n+    #[stable]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n         (*self as int).partial_cmp(&(*other as int))\n     }\n }\n \n /// Trait for values that can be compared for a sort-order.\n ///\n+/// The comparison must satisfy, for all `a`, `b` and `c`:\n+///\n+/// - antisymmetry: if `a < b` then `!(a > b)` and vice versa; and\n+/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for\n+///   both `==` and `>`.\n+///\n+/// Note that these requirements mean that the trait itself must be\n+/// implemented symmetrically and transitively: if `T: PartialOrd<U>`\n+/// and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n+/// PartialOrd<V>`.\n+///\n /// PartialOrd only requires implementation of the `partial_cmp` method,\n /// with the others generated from default implementations.\n ///\n@@ -193,14 +220,16 @@ impl PartialOrd for Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n+#[stable]\n pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n+    #[stable]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     #[inline]\n+    #[stable]\n     fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) => true,\n@@ -210,6 +239,7 @@ pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n+    #[stable]\n     fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) | Some(Equal) => true,\n@@ -219,6 +249,7 @@ pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n \n     /// This method tests greater than (`>`).\n     #[inline]\n+    #[stable]\n     fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) => true,\n@@ -228,6 +259,7 @@ pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n+    #[stable]\n     fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) | Some(Equal) => true,\n@@ -296,7 +328,7 @@ mod impls {\n \n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -306,7 +338,7 @@ mod impls {\n         )*)\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -320,7 +352,7 @@ mod impls {\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl Eq for $t {}\n         )*)\n     }\n@@ -329,7 +361,7 @@ mod impls {\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -352,15 +384,15 @@ mod impls {\n         )*)\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -372,7 +404,7 @@ mod impls {\n \n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -384,13 +416,13 @@ mod impls {\n         )*)\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -402,75 +434,77 @@ mod impls {\n \n     // & pointers\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a T {\n+    #[stable]\n+    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: & &'a T) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: & &'a T) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: & &'a T) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: & &'a T) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Ord> Ord for &'a T {\n+    #[stable]\n+    impl<'a, Sized? A> Ord for &'a A where A: Ord {\n         #[inline]\n-        fn cmp(&self, other: & &'a T) -> Ordering { Ord::cmp(*self, *other) }\n+        fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Eq> Eq for &'a T {}\n+    #[stable]\n+    impl<'a, Sized? A> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a mut T {\n+    #[stable]\n+    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: &&'a mut T) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: &&'a mut T) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: &&'a mut T) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: &&'a mut T) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Ord> Ord for &'a mut T {\n+    #[stable]\n+    impl<'a, Sized? A> Ord for &'a mut A where A: Ord {\n         #[inline]\n-        fn cmp(&self, other: &&'a mut T) -> Ordering { Ord::cmp(*self, *other) }\n+        fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Eq> Eq for &'a mut T {}\n+    #[stable]\n+    impl<'a, Sized? A> Eq for &'a mut A where A: Eq {}\n \n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }"}, {"sha": "3787ae33fdaad39d448e241bbf2f39aa87e104be", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -325,18 +325,9 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             let mut filler = Filler { buf: &mut buf, end: &mut end };\n             match sign {\n-                // NOTE(stage0): Remove cfg after a snapshot\n-                #[cfg(not(stage0))]\n                 SignNeg => {\n                     let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n                 }\n-                // NOTE(stage0): Remove match arm after a snapshot\n-                #[cfg(stage0)]\n-                SignNeg => {\n-                    let _ = format_args!(|args| {\n-                        fmt::write(&mut filler, args)\n-                    }, \"{:-}\", exp);\n-                }\n             }\n         }\n     }"}, {"sha": "9d275c9da9cb377c3e986a5371bd5ee80201c437", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -70,21 +70,11 @@ pub trait FormatWriter {\n     /// This function will return an instance of `FormatError` on error.\n     fn write(&mut self, bytes: &[u8]) -> Result;\n \n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n     fn write_fmt(&mut self, args: Arguments) -> Result { write(self, args) }\n-\n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    /// Glue for usage of the `write!` macro with implementers of this trait.\n-    ///\n-    /// This method should generally not be invoked manually, but rather through\n-    /// the `write!` macro itself.\n-    fn write_fmt(&mut self, args: &Arguments) -> Result { write(self, args) }\n }\n \n /// A struct to represent both where to emit formatting strings to and how they\n@@ -204,17 +194,9 @@ pub struct Arguments<'a> {\n }\n \n impl<'a> Show for Arguments<'a> {\n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n     }\n-\n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    fn fmt(&self, fmt: &mut Formatter) -> Result {\n-        write(fmt.buf, self)\n-    }\n }\n \n /// When a format is not otherwise specified, types are formatted by ascribing\n@@ -287,8 +269,6 @@ static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n     }\n };\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -342,61 +322,6 @@ pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n     Ok(())\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// The `write` function takes an output stream, a precompiled format string,\n-/// and a list of arguments. The arguments will be formatted according to the\n-/// specified format string into the output stream provided.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * args - the precompiled arguments generated by `format_args!`\n-#[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n-                  implementation detail which should not otherwise be exported\"]\n-pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n-    let mut formatter = Formatter {\n-        flags: 0,\n-        width: None,\n-        precision: None,\n-        buf: output,\n-        align: rt::AlignUnknown,\n-        fill: ' ',\n-        args: args.args,\n-        curarg: args.args.iter(),\n-    };\n-\n-    let mut pieces = args.pieces.iter();\n-\n-    match args.fmt {\n-        None => {\n-            // We can use default formatting parameters for all arguments.\n-            for _ in range(0, args.args.len()) {\n-                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n-                try!(formatter.run(&DEFAULT_ARGUMENT));\n-            }\n-        }\n-        Some(fmt) => {\n-            // Every spec has a corresponding argument that is preceded by\n-            // a string piece.\n-            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n-                try!(formatter.buf.write(piece.as_bytes()));\n-                try!(formatter.run(arg));\n-            }\n-        }\n-    }\n-\n-    // There can be only one trailing string piece left.\n-    match pieces.next() {\n-        Some(piece) => {\n-            try!(formatter.buf.write(piece.as_bytes()));\n-        }\n-        None => {}\n-    }\n-\n-    Ok(())\n-}\n-\n impl<'a> Formatter<'a> {\n \n     // First up is the collection of functions used to execute a format string\n@@ -603,22 +528,12 @@ impl<'a> Formatter<'a> {\n         self.buf.write(data)\n     }\n \n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     /// Writes some formatted information into this instance\n     #[unstable = \"reconciling core and I/O may alter this definition\"]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    /// Writes some formatted information into this instance\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n-    pub fn write_fmt(&mut self, fmt: &Arguments) -> Result {\n-        write(self.buf, fmt)\n-    }\n-\n     /// Flags for formatting (packed version of rt::Flag)\n     #[experimental = \"return type may change and method was just created\"]\n     pub fn flags(&self) -> uint { self.flags }"}, {"sha": "b0fd52896fe5726b078dba2e63b0162e454fa348", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -59,6 +59,7 @@ pub use self::MinMaxResult::*;\n use clone::Clone;\n use cmp;\n use cmp::Ord;\n+use default::Default;\n use mem;\n use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n@@ -68,20 +69,6 @@ use uint;\n \n #[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n \n-/// Conversion from an `Iterator`\n-#[unstable = \"may be replaced by a more general conversion trait\"]\n-pub trait FromIterator<A> {\n-    /// Build a container with elements from an external iterator.\n-    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;\n-}\n-\n-/// A type growable from an `Iterator` implementation\n-#[unstable = \"just renamed as part of collections reform\"]\n-pub trait Extend<A> {\n-    /// Extend a container with the elements yielded by an arbitrary iterator\n-    fn extend<T: Iterator<A>>(&mut self, iterator: T);\n-}\n-\n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to\n /// being located on the call stack.\n@@ -106,6 +93,20 @@ pub trait Iterator<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n+/// Conversion from an `Iterator`\n+#[unstable = \"may be replaced by a more general conversion trait\"]\n+pub trait FromIterator<A> {\n+    /// Build a container with elements from an external iterator.\n+    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;\n+}\n+\n+/// A type growable from an `Iterator` implementation\n+#[unstable = \"just renamed as part of collections reform\"]\n+pub trait Extend<A> {\n+    /// Extend a container with the elements yielded by an arbitrary iterator\n+    fn extend<T: Iterator<A>>(&mut self, iterator: T);\n+}\n+\n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n pub trait IteratorExt<A>: Iterator<A> {\n@@ -223,7 +224,6 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Enumerate{iter: self, count: 0}\n     }\n \n-\n     /// Creates an iterator that has a `.peek()` method\n     /// that returns an optional reference to the next element.\n     ///\n@@ -471,6 +471,35 @@ pub trait IteratorExt<A>: Iterator<A> {\n         FromIterator::from_iter(self)\n     }\n \n+    /// Loops through the entire iterator, collecting all of the elements into\n+    /// one of two containers, depending on a predicate. The elements of the\n+    /// first container satisfy the predicate, while the elements of the second\n+    /// do not.\n+    ///\n+    /// ```\n+    /// let vec = vec![1i, 2i, 3i, 4i];\n+    /// let (even, odd): (Vec<int>, Vec<int>) = vec.into_iter().partition(|&n| n % 2 == 0);\n+    /// assert_eq!(even, vec![2, 4]);\n+    /// assert_eq!(odd, vec![1, 3]);\n+    /// ```\n+    #[unstable = \"recently added as part of collections reform\"]\n+    fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n+        B: Default + Extend<A>, F: FnMut(&A) -> bool\n+    {\n+        let mut left: B = Default::default();\n+        let mut right: B = Default::default();\n+\n+        for x in self {\n+            if f(&x) {\n+                left.extend(Some(x).into_iter())\n+            } else {\n+                right.extend(Some(x).into_iter())\n+            }\n+        }\n+\n+        (left, right)\n+    }\n+\n     /// Loops through `n` iterations, returning the `n`th element of the\n     /// iterator.\n     ///\n@@ -661,6 +690,42 @@ pub trait IteratorExt<A>: Iterator<A> {\n #[unstable = \"trait is unstable\"]\n impl<A, I> IteratorExt<A> for I where I: Iterator<A> {}\n \n+/// Extention trait for iterators of pairs.\n+#[unstable = \"newly added trait, likely to be merged with IteratorExt\"]\n+pub trait IteratorPairExt<A, B>: Iterator<(A, B)> {\n+    /// Converts an iterator of pairs into a pair of containers.\n+    ///\n+    /// Loops through the entire iterator, collecting the first component of\n+    /// each item into one new container, and the second component into another.\n+    fn unzip<FromA, FromB>(mut self) -> (FromA, FromB) where\n+        FromA: Default + Extend<A>, FromB: Default + Extend<B>\n+    {\n+        struct SizeHint<A>(uint, Option<uint>);\n+        impl<A> Iterator<A> for SizeHint<A> {\n+            fn next(&mut self) -> Option<A> { None }\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                (self.0, self.1)\n+            }\n+        }\n+\n+        let (lo, hi) = self.size_hint();\n+        let mut ts: FromA = Default::default();\n+        let mut us: FromB = Default::default();\n+\n+        ts.extend(SizeHint(lo, hi));\n+        us.extend(SizeHint(lo, hi));\n+\n+        for (t, u) in self {\n+            ts.extend(Some(t).into_iter());\n+            us.extend(Some(u).into_iter());\n+        }\n+\n+        (ts, us)\n+    }\n+}\n+\n+impl<A, B, I> IteratorPairExt<A, B> for I where I: Iterator<(A, B)> {}\n+\n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust"}, {"sha": "e8fbd9d930f3388c8c4b3622cc2bad7affc865ca", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -10,8 +10,6 @@\n \n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Entry point of task panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n@@ -32,44 +30,6 @@ macro_rules! panic {\n     });\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Entry point of task panic, for details, see std::macros\n-#[macro_export]\n-macro_rules! panic {\n-    () => (\n-        panic!(\"{}\", \"explicit panic\")\n-    );\n-    ($msg:expr) => ({\n-        static _MSG_FILE_LINE: (&'static str, &'static str, uint) = ($msg, file!(), line!());\n-        ::core::panicking::panic(&_MSG_FILE_LINE)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        // a closure can't have return type !, so we need a full\n-        // function to pass to format_args!, *and* we need the\n-        // file and line numbers right here; so an inner bare fn\n-        // is our only choice.\n-        //\n-        // LLVM doesn't tend to inline this, presumably because begin_unwind_fmt\n-        // is #[cold] and #[inline(never)] and because this is flagged as cold\n-        // as returning !. We really do want this to be inlined, however,\n-        // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n-        // were seen when forcing this to be inlined, and that number just goes\n-        // up with the number of calls to panic!()\n-        //\n-        // The leading _'s are to avoid dead code warnings if this is\n-        // used inside a dead function. Just `#[allow(dead_code)]` is\n-        // insufficient, since the user may have\n-        // `#[forbid(dead_code)]` and which cannot be overridden.\n-        #[inline(always)]\n-        fn _run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n-            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-            ::core::panicking::panic_fmt(fmt, &_FILE_LINE)\n-        }\n-        format_args!(_run_fmt, $fmt, $($arg)*)\n-    });\n-}\n-\n /// Runtime assertion, for details see std::macros\n #[macro_export]\n macro_rules! assert {\n@@ -119,25 +79,12 @@ macro_rules! try {\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Writing a formatted string into a writer\n #[macro_export]\n macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Writing a formatted string into a writer\n-#[macro_export]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ({\n-        let dst = &mut *$dst;\n-        format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n-    })\n-}\n-\n /// Writing a formatted string plus a newline into a writer\n #[macro_export]\n macro_rules! writeln {"}, {"sha": "af07869e95feb291c707b46634adfc97b33469ed", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -292,58 +292,6 @@ rem_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n rem_float_impl! { f32, fmodf }\n rem_float_impl! { f64, fmod }\n \n-/// The `Neg` trait is used to specify the functionality of unary `-`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Neg`. When `-Foo` happens, it ends up calling\n-/// `neg`, and therefore, `main` prints `Negating!`.\n-///\n-/// ```\n-/// #[deriving(Copy)]\n-/// struct Foo;\n-///\n-/// impl Neg<Foo> for Foo {\n-///     fn neg(&self) -> Foo {\n-///         println!(\"Negating!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     -Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"neg\"]\n-pub trait Neg<Result> for Sized? {\n-    /// The method for the unary `-` operator\n-    fn neg(&self) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! neg_impl {\n-    ($($t:ty)*) => ($(\n-        impl Neg<$t> for $t {\n-            #[inline]\n-            fn neg(&self) -> $t { -*self }\n-        }\n-    )*)\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! neg_uint_impl {\n-    ($t:ty, $t_signed:ty) => {\n-        impl Neg<$t> for $t {\n-            #[inline]\n-            fn neg(&self) -> $t { -(*self as $t_signed) as $t }\n-        }\n-    }\n-}\n-\n /// The `Neg` trait is used to specify the functionality of unary `-`.\n ///\n /// # Example\n@@ -367,14 +315,12 @@ macro_rules! neg_uint_impl {\n ///     -Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"neg\"]\n pub trait Neg<Result> {\n     /// The method for the unary `-` operator\n     fn neg(self) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n         impl Neg<$t> for $t {\n@@ -384,7 +330,6 @@ macro_rules! neg_impl {\n     )*)\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n         impl Neg<$t> for $t {\n@@ -403,48 +348,6 @@ neg_uint_impl! { u32, i32 }\n neg_uint_impl! { u64, i64 }\n \n \n-/// The `Not` trait is used to specify the functionality of unary `!`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n-/// `not`, and therefore, `main` prints `Not-ing!`.\n-///\n-/// ```\n-/// #[deriving(Copy)]\n-/// struct Foo;\n-///\n-/// impl Not<Foo> for Foo {\n-///     fn not(&self) -> Foo {\n-///         println!(\"Not-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     !Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"not\"]\n-pub trait Not<Result> for Sized? {\n-    /// The method for the unary `!` operator\n-    fn not(&self) -> Result;\n-}\n-\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! not_impl {\n-    ($($t:ty)*) => ($(\n-        impl Not<$t> for $t {\n-            #[inline]\n-            fn not(&self) -> $t { !*self }\n-        }\n-    )*)\n-}\n-\n /// The `Not` trait is used to specify the functionality of unary `!`.\n ///\n /// # Example\n@@ -468,14 +371,12 @@ macro_rules! not_impl {\n ///     !Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"not\"]\n pub trait Not<Result> {\n     /// The method for the unary `!` operator\n     fn not(self) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n         impl Not<$t> for $t {"}, {"sha": "61b4284e1dd9c08aa617571da9e4d08356846ed0", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -31,34 +31,14 @@\n #![allow(dead_code, missing_docs)]\n \n use fmt;\n-// NOTE(stage0): Remove import after a snapshot\n-#[cfg(stage0)] use intrinsics;\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"panic\"]\n pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n     let (expr, file, line) = *expr_file_line;\n     panic_fmt(format_args!(\"{}\", expr), &(file, line))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cold] #[inline(never)] // this is the slow path, always\n-#[lang=\"panic\"]\n-pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n-    let (expr, file, line) = *expr_file_line;\n-    let ref file_line = (file, line);\n-    format_args!(|args| -> () {\n-        panic_fmt(args, file_line);\n-    }, \"{}\", expr);\n-\n-    unsafe { intrinsics::abort() }\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cold] #[inline(never)]\n #[lang=\"panic_bounds_check\"]\n fn panic_bounds_check(file_line: &(&'static str, uint),\n@@ -67,20 +47,6 @@ fn panic_bounds_check(file_line: &(&'static str, uint),\n                            len, index), file_line)\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cold] #[inline(never)]\n-#[lang=\"panic_bounds_check\"]\n-fn panic_bounds_check(file_line: &(&'static str, uint),\n-                     index: uint, len: uint) -> ! {\n-    format_args!(|args| -> () {\n-        panic_fmt(args, file_line);\n-    }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n-    unsafe { intrinsics::abort() }\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cold] #[inline(never)]\n pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     #[allow(improper_ctypes)]\n@@ -91,18 +57,3 @@ pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     let (file, line) = *file_line;\n     unsafe { panic_impl(fmt, file, line) }\n }\n-\n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cold] #[inline(never)]\n-pub fn panic_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    #[allow(improper_ctypes)]\n-    extern {\n-        #[lang = \"panic_fmt\"]\n-        fn panic_impl(fmt: &fmt::Arguments, file: &'static str,\n-                        line: uint) -> !;\n-\n-    }\n-    let (file, line) = *file_line;\n-    unsafe { panic_impl(fmt, file, line) }\n-}"}, {"sha": "cecb49381538035f4c309205994f5e193e082129", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -52,7 +52,7 @@ pub use cmp::{Ordering, Equiv};\n pub use cmp::Ordering::{Less, Equal, Greater};\n pub use iter::{FromIterator, Extend, IteratorExt};\n pub use iter::{Iterator, DoubleEndedIterator, DoubleEndedIteratorExt, RandomAccessIterator};\n-pub use iter::{IteratorCloneExt, CloneIteratorExt};\n+pub use iter::{IteratorCloneExt, CloneIteratorExt, IteratorPairExt};\n pub use iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n pub use num::{ToPrimitive, FromPrimitive};\n pub use option::Option;"}, {"sha": "faf1d781465c76457b4d08ef731a0cd58fcec2c3", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -379,6 +379,7 @@ impl<T> MutPtrExt<T> for *mut T {\n }\n \n // Equality for pointers\n+#[stable]\n impl<T> PartialEq for *const T {\n     #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n@@ -388,8 +389,10 @@ impl<T> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n+#[stable]\n impl<T> Eq for *const T {}\n \n+#[stable]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -399,6 +402,7 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n+#[stable]\n impl<T> Eq for *mut T {}\n \n // Equivalence for pointers\n@@ -439,6 +443,7 @@ mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n \n+    #[stable]\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n@@ -449,6 +454,7 @@ mod externfnpointers {\n     }\n     macro_rules! fnptreq {\n         ($($p:ident),*) => {\n+            #[stable]\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n@@ -468,6 +474,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n+#[stable]\n impl<T> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n@@ -481,6 +488,7 @@ impl<T> Ord for *const T {\n     }\n }\n \n+#[stable]\n impl<T> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n@@ -500,6 +508,7 @@ impl<T> PartialOrd for *const T {\n     fn ge(&self, other: &*const T) -> bool { *self >= *other }\n }\n \n+#[stable]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n@@ -513,6 +522,7 @@ impl<T> Ord for *mut T {\n     }\n }\n \n+#[stable]\n impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {"}, {"sha": "7d894ac697be280f339a7e1454967a460280d66d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 175, "deletions": 163, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -46,6 +46,8 @@ use num::Int;\n use ops::{FnMut, mod};\n use option::Option;\n use option::Option::{None, Some};\n+use result::Result;\n+use result::Result::{Ok, Err};\n use ptr;\n use ptr::PtrExt;\n use mem;\n@@ -68,23 +70,23 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n     fn iter<'a>(&'a self) -> Iter<'a, T>;\n-    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P>\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P>\n                     where P: FnMut(&T) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P>\n                      where P: FnMut(&T) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, T, P>\n                       where P: FnMut(&T) -> bool;\n     fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n     fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n     fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn head<'a>(&'a self) -> Option<&'a T>;\n+    fn first<'a>(&'a self) -> Option<&'a T>;\n     fn tail<'a>(&'a self) -> &'a [T];\n     fn init<'a>(&'a self) -> &'a [T];\n     fn last<'a>(&'a self) -> Option<&'a T>;\n-    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T;\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T;\n     fn as_ptr(&self) -> *const T;\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering;\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n@@ -93,21 +95,21 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n-    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P>\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P>\n                         where P: FnMut(&T) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<T, P>\n                      where P: FnMut(&T) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<T, P>\n                       where P: FnMut(&T) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T>;\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T>;\n     fn swap(&mut self, a: uint, b: uint);\n     fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n     fn reverse(&mut self);\n-    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n     fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n@@ -145,45 +147,49 @@ impl<T> SliceExt<T> for [T] {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n-                Iter{ptr: p,\n+                Iter {ptr: p,\n                       end: (p as uint + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                Iter{ptr: p,\n+                Iter {ptr: p,\n                       end: p.offset(self.len() as int),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n \n     #[inline]\n-    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where P: FnMut(&T) -> bool {\n-        Splits {\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P> where P: FnMut(&T) -> bool {\n+        Split {\n             v: self,\n             pred: pred,\n             finished: false\n         }\n     }\n \n     #[inline]\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n+        SplitN {\n+            inner: GenericSplitN {\n+                iter: self.split(pred),\n+                count: n,\n+                invert: false\n+            }\n         }\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> RSplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n+        RSplitN {\n+            inner: GenericSplitN {\n+                iter: self.split(pred),\n+                count: n,\n+                invert: true\n+            }\n         }\n     }\n \n@@ -205,7 +211,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn head(&self) -> Option<&T> {\n+    fn first(&self) -> Option<&T> {\n         if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n \n@@ -223,7 +229,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+    unsafe fn get_unchecked(&self, index: uint) -> &T {\n         transmute(self.repr().data.offset(index as int))\n     }\n \n@@ -233,14 +239,16 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[unstable]\n-    fn binary_search<F>(&self, mut f: F) -> BinarySearchResult where F: FnMut(&T) -> Ordering {\n+    fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering\n+    {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n \n         while lim != 0 {\n             let ix = base + (lim >> 1);\n             match f(&self[ix]) {\n-                Equal => return BinarySearchResult::Found(ix),\n+                Equal => return Ok(ix),\n                 Less => {\n                     base = ix + 1;\n                     lim -= 1;\n@@ -249,7 +257,7 @@ impl<T> SliceExt<T> for [T] {\n             }\n             lim >>= 1;\n         }\n-        return BinarySearchResult::NotFound(base);\n+        Err(base)\n     }\n \n     #[inline]\n@@ -292,11 +300,11 @@ impl<T> SliceExt<T> for [T] {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n-                IterMut{ptr: p,\n+                IterMut {ptr: p,\n                          end: (p as uint + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                IterMut{ptr: p,\n+                IterMut {ptr: p,\n                          end: p.offset(self.len() as int),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -311,7 +319,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn head_mut(&mut self) -> Option<&mut T> {\n+    fn first_mut(&mut self) -> Option<&mut T> {\n         if self.len() == 0 { None } else { Some(&mut self[0]) }\n     }\n \n@@ -327,36 +335,40 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n-        MutSplits { v: self, pred: pred, finished: false }\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+        SplitMut { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool\n     {\n-        SplitsN {\n-            iter: self.split_mut(pred),\n-            count: n,\n-            invert: false\n+        SplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.split_mut(pred),\n+                count: n,\n+                invert: false\n+            }\n         }\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> RSplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split_mut(pred),\n-            count: n,\n-            invert: true\n+        RSplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.split_mut(pred),\n+                count: n,\n+                invert: true\n+            }\n         }\n    }\n \n     #[inline]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T> {\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T> {\n         assert!(chunk_size > 0);\n-        MutChunks { v: self, chunk_size: chunk_size }\n+        ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n     fn swap(&mut self, a: uint, b: uint) {\n@@ -375,16 +387,16 @@ impl<T> SliceExt<T> for [T] {\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n             unsafe {\n-                let pa: *mut T = self.unsafe_mut(i);\n-                let pb: *mut T = self.unsafe_mut(ln - i - 1);\n+                let pa: *mut T = self.get_unchecked_mut(i);\n+                let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                 ptr::swap(pa, pb);\n             }\n             i += 1;\n         }\n     }\n \n     #[inline]\n-    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T {\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T {\n         transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n@@ -468,21 +480,26 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n }\n \n /// Extension methods for slices containing `PartialEq` elements.\n-#[unstable = \"may merge with other traits\"]\n+#[unstable = \"may merge with SliceExt\"]\n pub trait PartialEqSliceExt<T: PartialEq> for Sized? {\n     /// Find the first index containing a matching value.\n+    #[experimental]\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n     /// Find the last index containing a matching value.\n+    #[experimental]\n     fn rposition_elem(&self, t: &T) -> Option<uint>;\n \n     /// Return true if the slice contains an element with the given value.\n+    #[stable]\n     fn contains(&self, x: &T) -> bool;\n \n     /// Returns true if `needle` is a prefix of the slice.\n+    #[stable]\n     fn starts_with(&self, needle: &[T]) -> bool;\n \n     /// Returns true if `needle` is a suffix of the slice.\n+    #[stable]\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n@@ -520,19 +537,16 @@ impl<T: PartialEq> PartialEqSliceExt<T> for [T] {\n #[unstable = \"may merge with other traits\"]\n #[allow(missing_docs)] // docs in libcollections\n pub trait OrdSliceExt<T: Ord> for Sized? {\n-    #[unstable = \"name likely to change\"]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n-    #[experimental]\n+    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n     fn next_permutation(&mut self) -> bool;\n-    #[experimental]\n     fn prev_permutation(&mut self) -> bool;\n }\n \n #[unstable = \"trait is unstable\"]\n impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[unstable]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n-        self.binary_search(|p| p.cmp(x))\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+        self.binary_search_by(|p| p.cmp(x))\n     }\n \n     #[experimental]\n@@ -619,28 +633,30 @@ impl<T: Clone> CloneSliceExt<T> for [T] {\n     }\n }\n \n-//\n+////////////////////////////////////////////////////////////////////////////////\n // Common traits\n-//\n+////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[unstable = \"may merge with other traits\"]\n+#[experimental = \"will be replaced by slice syntax\"]\n pub trait AsSlice<T> for Sized? {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[experimental = \"trait is experimental\"]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n@@ -656,7 +672,7 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n-// The shared definition of the `Item` and `IterMut` iterators\n+// The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n@@ -736,9 +752,8 @@ macro_rules! make_slice {\n     }}\n }\n \n-\n /// Immutable slice iterator\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n@@ -813,7 +828,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n@@ -876,28 +891,28 @@ iterator!{struct IterMut -> *mut T, &'a mut T}\n #[experimental = \"needs review\"]\n impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n-/// An abstraction over the splitting iterators, so that splitn, splitn_mut etc\n-/// can be implemented once.\n-trait SplitsIter<E>: DoubleEndedIterator<E> {\n+/// An internal abstraction over the splitting iterators, so that\n+/// splitn, splitn_mut etc can be implemented once.\n+trait SplitIter<E>: DoubleEndedIterator<E> {\n     /// Mark the underlying iterator as complete, extracting the remaining\n     /// portion of the slice.\n     fn finish(&mut self) -> Option<E>;\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n-#[experimental = \"needs review\"]\n-pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[stable]\n+pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n     pred: P,\n     finished: bool\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n-impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n-    fn clone(&self) -> Splits<'a, T, P> {\n-        Splits {\n+impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n+    fn clone(&self) -> Split<'a, T, P> {\n+        Split {\n             v: self.v,\n             pred: self.pred.clone(),\n             finished: self.finished,\n@@ -906,7 +921,7 @@ impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -932,7 +947,7 @@ impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -948,7 +963,7 @@ impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(\n     }\n }\n \n-impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a [T]> {\n         if self.finished { None } else { self.finished = true; Some(self.v) }\n@@ -957,14 +972,14 @@ impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bo\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-#[experimental = \"needs review\"]\n-pub struct MutSplits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[stable]\n+pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n     pred: P,\n     finished: bool\n }\n \n-impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n         if self.finished {\n@@ -977,7 +992,7 @@ impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -1010,7 +1025,7 @@ impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T)\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n+impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n     #[inline]\n@@ -1033,17 +1048,17 @@ impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n     }\n }\n \n-/// An iterator over subslices separated by elements that match a predicate\n-/// function, splitting at most a fixed number of times.\n-#[experimental = \"needs review\"]\n-pub struct SplitsN<I> {\n+/// An private iterator over subslices separated by elements that\n+/// match a predicate function, splitting at most a fixed number of\n+/// times.\n+struct GenericSplitN<I> {\n     iter: I,\n     count: uint,\n     invert: bool\n }\n \n #[experimental = \"needs review\"]\n-impl<E, I: SplitsIter<E>> Iterator<E> for SplitsN<I> {\n+impl<E, I: SplitIter<E>> Iterator<E> for GenericSplitN<I> {\n     #[inline]\n     fn next(&mut self) -> Option<E> {\n         if self.count == 0 {\n@@ -1061,6 +1076,55 @@ impl<E, I: SplitsIter<E>> Iterator<E> for SplitsN<I> {\n     }\n }\n \n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<Split<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<Split<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<SplitMut<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<SplitMut<'a, T, P>>\n+}\n+\n+macro_rules! forward_iterator {\n+    ($name:ident: $elem:ident, $iter_of:ty) => {\n+        impl<'a, $elem, P> Iterator<$iter_of> for $name<'a, $elem, P> where\n+            P: FnMut(&T) -> bool\n+        {\n+            #[inline]\n+            fn next(&mut self) -> Option<$iter_of> {\n+                self.inner.next()\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.inner.size_hint()\n+            }\n+        }\n+    }\n+}\n+\n+forward_iterator! { SplitN: T, &'a [T] }\n+forward_iterator! { RSplitN: T, &'a [T] }\n+forward_iterator! { SplitNMut: T, &'a mut [T] }\n+forward_iterator! { RSplitNMut: T, &'a mut [T] }\n+\n /// An iterator over overlapping subslices of length `size`.\n #[deriving(Clone)]\n #[experimental = \"needs review\"]\n@@ -1172,13 +1236,13 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n #[experimental = \"needs review\"]\n-pub struct MutChunks<'a, T:'a> {\n+pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n+impl<'a, T> Iterator<&'a mut [T]> for ChunksMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1206,7 +1270,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1224,59 +1288,20 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n }\n \n \n-\n-/// The result of calling `binary_search`.\n-///\n-/// `Found` means the search succeeded, and the contained value is the\n-/// index of the matching element. `NotFound` means the search\n-/// succeeded, and the contained value is an index where a matching\n-/// value could be inserted while maintaining sort order.\n-#[deriving(Copy, PartialEq, Show)]\n-#[experimental = \"needs review\"]\n-pub enum BinarySearchResult {\n-    /// The index of the found value.\n-    Found(uint),\n-    /// The index where the value should have been found.\n-    NotFound(uint)\n-}\n-\n-#[experimental = \"needs review\"]\n-impl BinarySearchResult {\n-    /// Converts a `Found` to `Some`, `NotFound` to `None`.\n-    /// Similar to `Result::ok`.\n-    pub fn found(&self) -> Option<uint> {\n-        match *self {\n-            BinarySearchResult::Found(i) => Some(i),\n-            BinarySearchResult::NotFound(_) => None\n-        }\n-    }\n-\n-    /// Convert a `Found` to `None`, `NotFound` to `Some`.\n-    /// Similar to `Result::err`.\n-    pub fn not_found(&self) -> Option<uint> {\n-        match *self {\n-            BinarySearchResult::Found(_) => None,\n-            BinarySearchResult::NotFound(i) => Some(i)\n-        }\n-    }\n-}\n-\n-\n-\n //\n // Free functions\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable = \"waiting for DST\"]\n+#[unstable]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable = \"waiting for DST\"]\n+#[unstable]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1310,7 +1335,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"just renamed from `mod raw`\"]\n+#[unstable = \"should be renamed to from_raw_parts\"]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1322,7 +1347,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"just renamed from `mod raw`\"]\n+#[unstable = \"jshould be renamed to from_raw_parts_mut\"]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p as *const T, len: len })\n }\n@@ -1437,7 +1462,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n@@ -1449,7 +1474,7 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<T: Eq> Eq for [T] {}\n \n #[allow(deprecated)]\n@@ -1466,14 +1491,14 @@ impl<'a,T:PartialEq, Sized? V: AsSlice<T>> Equiv<V> for &'a mut [T] {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n@@ -1497,39 +1522,28 @@ impl<T: PartialOrd> PartialOrd for [T] {\n     }\n }\n \n-/// Extension methods for immutable slices containing integers.\n+/// Extension methods for slices containing integers.\n #[experimental]\n-pub trait ImmutableIntSlice<U, S> for Sized? {\n+pub trait IntSliceExt<U, S> for Sized? {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n     /// Converts the slice to an immutable slice of signed integers with the same width.\n     fn as_signed<'a>(&'a self) -> &'a [S];\n-}\n \n-/// Extension methods for mutable slices containing integers.\n-#[experimental]\n-pub trait MutableIntSlice<U, S> for Sized?: ImmutableIntSlice<U, S> {\n     /// Converts the slice to a mutable slice of unsigned integers with the same width.\n     fn as_unsigned_mut<'a>(&'a mut self) -> &'a mut [U];\n     /// Converts the slice to a mutable slice of signed integers with the same width.\n     fn as_signed_mut<'a>(&'a mut self) -> &'a mut [S];\n }\n \n-macro_rules! impl_immut_int_slice {\n+macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n         #[experimental]\n-        impl ImmutableIntSlice<$u, $s> for [$t] {\n+        impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }\n             #[inline]\n             fn as_signed(&self) -> &[$s] { unsafe { transmute(self) } }\n-        }\n-    }\n-}\n-macro_rules! impl_mut_int_slice {\n-    ($u:ty, $s:ty, $t:ty) => {\n-        #[experimental]\n-        impl MutableIntSlice<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned_mut(&mut self) -> &mut [$u] { unsafe { transmute(self) } }\n             #[inline]\n@@ -1538,17 +1552,15 @@ macro_rules! impl_mut_int_slice {\n     }\n }\n \n-macro_rules! impl_int_slice {\n+macro_rules! impl_int_slices {\n     ($u:ty, $s:ty) => {\n-        impl_immut_int_slice! { $u, $s, $u }\n-        impl_immut_int_slice! { $u, $s, $s }\n-        impl_mut_int_slice! { $u, $s, $u }\n-        impl_mut_int_slice! { $u, $s, $s }\n+        impl_int_slice! { $u, $s, $u }\n+        impl_int_slice! { $u, $s, $s }\n     }\n }\n \n-impl_int_slice! { u8,   i8 }\n-impl_int_slice! { u16,  i16 }\n-impl_int_slice! { u32,  i32 }\n-impl_int_slice! { u64,  i64 }\n-impl_int_slice! { uint, int }\n+impl_int_slices! { u8,   i8  }\n+impl_int_slices! { u16,  i16 }\n+impl_int_slices! { u32,  i32 }\n+impl_int_slices! { u64,  i64 }\n+impl_int_slices! { uint, int }"}, {"sha": "59cf79408b100acb837ee39cae95012a366d0250", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1143,6 +1143,7 @@ pub mod traits {\n     use ops;\n     use str::{Str, StrExt, eq_slice};\n \n+    #[stable]\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n@@ -1158,6 +1159,7 @@ pub mod traits {\n         }\n     }\n \n+    #[stable]\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n@@ -1167,8 +1169,10 @@ pub mod traits {\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n     }\n \n+    #[stable]\n     impl Eq for str {}\n \n+    #[stable]\n     impl PartialOrd for str {\n         #[inline]\n         fn partial_cmp(&self, other: &str) -> Option<Ordering> {"}, {"sha": "576989fabe77c92a573e6d348b5ff411c3ee6e31", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -132,7 +132,7 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for PartialEq to stabilize\"]\n+            #[stable]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -144,10 +144,10 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Eq to stabilize\"]\n+            #[stable]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[unstable = \"waiting for PartialOrd to stabilize\"]\n+            #[stable]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n@@ -171,7 +171,7 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Ord to stabilize\"]\n+            #[stable]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {"}, {"sha": "1fee304a9764890281b6bf7ce4f3c2864a1aebed", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::atomic::*;\n+use core::atomic::Ordering::SeqCst;\n \n #[test]\n fn bool_() {"}, {"sha": "9ef7d6030593a008f24a6d22fb1477afcdcd5ead", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -8,30 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice::BinarySearchResult::{Found, NotFound};\n+use core::result::Result::{Ok, Err};\n \n #[test]\n fn binary_search_not_found() {\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&8)) == Found(4));\n+    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(4));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(4));\n+    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(4));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&8)) == Found(5));\n+    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(5));\n     let b = [1i, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(5));\n+    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(5));\n     let b = [1i, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&0)) == NotFound(0));\n+    assert!(b.binary_search_by(|v| v.cmp(&0)) == Err(0));\n     let b = [1i, 2, 4, 5, 6, 8];\n-    assert!(b.binary_search(|v| v.cmp(&9)) == NotFound(6));\n+    assert!(b.binary_search_by(|v| v.cmp(&9)) == Err(6));\n }\n \n #[test]"}, {"sha": "0184222b9e0b660fea87cf2d43eaae35818d03d0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -578,7 +578,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n-    let mut vals = Vec::from_fn(n_opts, f);\n+    let mut vals: Vec<_> = range(0, n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n     let l = args.len();\n     let mut i = 0;"}, {"sha": "b30938ae7f57770e1ca517e52a6314052c250ce5", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -268,8 +268,6 @@ impl Drop for DefaultLogger {\n     }\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// This function is called directly by the compiler when using the logging\n /// macros. This function does not take into account whether the log level\n /// specified is active or not, it will always log something if this method is\n@@ -304,42 +302,6 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     set_logger(logger);\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// This function is called directly by the compiler when using the logging\n-/// macros. This function does not take into account whether the log level\n-/// specified is active or not, it will always log something if this method is\n-/// called.\n-///\n-/// It is not recommended to call this function directly, rather it should be\n-/// invoked through the logging family of macros.\n-#[doc(hidden)]\n-pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n-    // Test the literal string from args against the current filter, if there\n-    // is one.\n-    match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string().as_slice()) => return,\n-        _ => {}\n-    }\n-\n-    // Completely remove the local logger from TLS in case anyone attempts to\n-    // frob the slot while we're doing the logging. This will destroy any logger\n-    // set during logging.\n-    let mut logger = LOCAL_LOGGER.with(|s| {\n-        s.borrow_mut().take()\n-    }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n-    });\n-    logger.log(&LogRecord {\n-        level: LogLevel(level),\n-        args: *args,\n-        file: loc.file,\n-        module_path: loc.module_path,\n-        line: loc.line,\n-    });\n-    set_logger(logger);\n-}\n-\n /// Getter for the global log level. This is a function so that it can be called\n /// safely\n #[doc(hidden)]"}, {"sha": "233d1c049f4e5e2bcdc69327f0c014a2e4069b98", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -12,8 +12,6 @@\n \n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The standard logging macro\n ///\n /// This macro will generically log over a provided level (of type u32) with a\n@@ -67,61 +65,6 @@ macro_rules! log {\n     })\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// The standard logging macro\n-///\n-/// This macro will generically log over a provided level (of type u32) with a\n-/// format!-based argument list. See documentation in `std::fmt` for details on\n-/// how to use the syntax.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n-///\n-/// fn main() {\n-///     log!(log::WARN, \"this is a warning {}\", \"message\");\n-///     log!(log::DEBUG, \"this is a debug message\");\n-///     log!(6, \"this is a custom logging level: {level}\", level=6u);\n-/// }\n-/// ```\n-///\n-/// Assumes the binary is `main`:\n-///\n-/// ```{.bash}\n-/// $ RUST_LOG=warn ./main\n-/// WARN:main: this is a warning message\n-/// ```\n-///\n-/// ```{.bash}\n-/// $ RUST_LOG=debug ./main\n-/// DEBUG:main: this is a debug message\n-/// WARN:main: this is a warning message\n-/// ```\n-///\n-/// ```{.bash}\n-/// $ RUST_LOG=6 ./main\n-/// DEBUG:main: this is a debug message\n-/// WARN:main: this is a warning message\n-/// 6:main: this is a custom logging level: 6\n-/// ```\n-#[macro_export]\n-macro_rules! log {\n-    ($lvl:expr, $($arg:tt)+) => ({\n-        static LOC: ::log::LogLocation = ::log::LogLocation {\n-            line: line!(),\n-            file: file!(),\n-            module_path: module_path!(),\n-        };\n-        let lvl = $lvl;\n-        if log_enabled!(lvl) {\n-            format_args!(|args| { ::log::log(lvl, &LOC, args) }, $($arg)+)\n-        }\n-    })\n-}\n-\n /// A convenience macro for logging at the error log level.\n ///\n /// # Example"}, {"sha": "a76e5ebd08a8493ae4ff217f9863193350515e16", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -361,7 +361,7 @@ impl Isaac64Rng {\n         const MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind (\n             ($x:expr) => {\n-                *self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+                *self.mem.get_unchecked(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n         );\n \n@@ -375,13 +375,13 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_get(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n+                                let x = *self.mem.get_unchecked(base + mr_offset);\n+                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                *self.mem.unsafe_mut(base + mr_offset) = y;\n+                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n+                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );\n@@ -392,13 +392,13 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_get(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n+                                let x = *self.mem.get_unchecked(base + mr_offset);\n+                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                *self.mem.unsafe_mut(base + mr_offset) = y;\n+                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n+                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );"}, {"sha": "fd0c54e8ed3a8fce98cb8b2a7d525463a005b167", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -11,6 +11,7 @@\n use std::io::{IoError, IoResult, SeekStyle};\n use std::io;\n use std::slice;\n+use std::iter::repeat;\n \n static BUF_CAPACITY: uint = 128;\n \n@@ -87,7 +88,7 @@ impl Writer for SeekableMemWriter {\n             // currently are\n             let difference = self.pos as i64 - self.buf.len() as i64;\n             if difference > 0 {\n-                self.buf.grow(difference as uint, 0);\n+                self.buf.extend(repeat(0).take(difference as uint));\n             }\n \n             // Figure out what bytes will be used to overwrite what's currently"}, {"sha": "1476e6ab8a7068669c5e8b81edc13cb0e1bb2660", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -14,6 +14,7 @@\n pub use self::Inst::*;\n \n use std::cmp;\n+use std::iter::repeat;\n use parse;\n use parse::{\n     Flags, FLAG_EMPTY,\n@@ -157,7 +158,7 @@ impl<'r> Compiler<'r> {\n             Capture(cap, name, x) => {\n                 let len = self.names.len();\n                 if cap >= len {\n-                    self.names.grow(10 + cap - len, None)\n+                    self.names.extend(repeat(None).take(10 + cap - len))\n                 }\n                 self.names[cap] = name;\n "}, {"sha": "692a065299ca2b25a21d39c6f515a760c7fc87b9", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -18,7 +18,6 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n-use std::slice::BinarySearchResult;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -1028,9 +1027,9 @@ fn is_valid_cap(c: char) -> bool {\n }\n \n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n-    match classes.binary_search(|&(s, _)| s.cmp(name)) {\n-        BinarySearchResult::Found(i) => Some(classes[i].1.to_vec()),\n-        BinarySearchResult::NotFound(_) => None,\n+    match classes.binary_search_by(|&(s, _)| s.cmp(name)) {\n+        Ok(i) => Some(classes[i].1.to_vec()),\n+        Err(_) => None,\n     }\n }\n "}, {"sha": "51c234631550cf9c1e57c78398421614dff5cb70", "filename": "src/libregex/re.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -539,6 +539,7 @@ impl Regex {\n \n }\n \n+#[deriving(Clone)]\n pub enum NamesIter<'a> {\n     NamesIterNative(::std::slice::Iter<'a, Option<&'static str>>),\n     NamesIterDynamic(::std::slice::Iter<'a, Option<String>>)\n@@ -595,6 +596,7 @@ impl<F> Replacer for F where F: FnMut(&Captures) -> String {\n ///\n /// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n /// of the string being split.\n+#[deriving(Clone)]\n pub struct RegexSplits<'r, 't> {\n     finder: FindMatches<'r, 't>,\n     last: uint,\n@@ -628,6 +630,7 @@ impl<'r, 't> Iterator<&'t str> for RegexSplits<'r, 't> {\n ///\n /// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n /// of the string being split.\n+#[deriving(Clone)]\n pub struct RegexSplitsN<'r, 't> {\n     splits: RegexSplits<'r, 't>,\n     cur: uint,\n@@ -791,6 +794,7 @@ impl<'t> Captures<'t> {\n /// expression.\n ///\n /// `'t` is the lifetime of the matched text.\n+#[deriving(Clone)]\n pub struct SubCaptures<'t> {\n     idx: uint,\n     caps: &'t Captures<'t>,\n@@ -813,6 +817,7 @@ impl<'t> Iterator<&'t str> for SubCaptures<'t> {\n /// Positions are byte indices in terms of the original string matched.\n ///\n /// `'t` is the lifetime of the matched text.\n+#[deriving(Clone)]\n pub struct SubCapturesPos<'t> {\n     idx: uint,\n     caps: &'t Captures<'t>,\n@@ -836,6 +841,7 @@ impl<'t> Iterator<Option<(uint, uint)>> for SubCapturesPos<'t> {\n ///\n /// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n /// of the matched string.\n+#[deriving(Clone)]\n pub struct FindCaptures<'r, 't> {\n     re: &'r Regex,\n     search: &'t str,\n@@ -878,6 +884,7 @@ impl<'r, 't> Iterator<Captures<'t>> for FindCaptures<'r, 't> {\n ///\n /// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n /// of the matched string.\n+#[deriving(Clone)]\n pub struct FindMatches<'r, 't> {\n     re: &'r Regex,\n     search: &'t str,"}, {"sha": "72e0e559c805bb7f0192088050576b7e29d648f2", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -38,6 +38,7 @@ pub use self::StepState::*;\n \n use std::cmp;\n use std::mem;\n+use std::iter::repeat;\n use std::slice::SliceExt;\n use compile::{\n     Program,\n@@ -121,7 +122,7 @@ impl<'r, 't> Nfa<'r, 't> {\n         let mut clist = &mut Threads::new(self.which, ninsts, ncaps);\n         let mut nlist = &mut Threads::new(self.which, ninsts, ncaps);\n \n-        let mut groups = Vec::from_elem(ncaps * 2, None);\n+        let mut groups: Vec<_> = repeat(None).take(ncaps * 2).collect();\n \n         // Determine if the expression starts with a '^' so we can avoid\n         // simulating .*?\n@@ -227,8 +228,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                     let negate = flags & FLAG_NEGATED > 0;\n                     let casei = flags & FLAG_NOCASE > 0;\n                     let found = ranges.as_slice();\n-                    let found = found.binary_search(|&rc| class_cmp(casei, c, rc))\n-                        .found().is_some();\n+                    let found = found.binary_search_by(|&rc| class_cmp(casei, c, rc)).is_ok();\n                     if found ^ negate {\n                         self.add(nlist, pc+1, caps);\n                     }\n@@ -457,10 +457,10 @@ impl Threads {\n     fn new(which: MatchKind, num_insts: uint, ncaps: uint) -> Threads {\n         Threads {\n             which: which,\n-            queue: Vec::from_fn(num_insts, |_| {\n-                Thread { pc: 0, groups: Vec::from_elem(ncaps * 2, None) }\n-            }),\n-            sparse: Vec::from_elem(num_insts, 0u),\n+            queue: range(0, num_insts).map(|_| {\n+                Thread { pc: 0, groups: repeat(None).take(ncaps * 2).collect() }\n+            }).collect(),\n+            sparse: repeat(0u).take(num_insts).collect(),\n             size: 0,\n         }\n     }\n@@ -518,15 +518,15 @@ pub fn is_word(c: Option<char>) -> bool {\n     // Try the common ASCII case before invoking binary search.\n     match c {\n         '_' | '0' ... '9' | 'a' ... 'z' | 'A' ... 'Z' => true,\n-        _ => PERLW.binary_search(|&(start, end)| {\n+        _ => PERLW.binary_search_by(|&(start, end)| {\n             if c >= start && c <= end {\n                 Equal\n             } else if start > c {\n                 Greater\n             } else {\n                 Less\n             }\n-        }).found().is_some()\n+        }).is_ok()\n     }\n }\n "}, {"sha": "7c496623d62d2da9236db4117d33f32155f9241d", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -654,6 +654,7 @@ impl LintPass for UnusedAttributes {\n             \"static_assert\",\n             \"thread_local\",\n             \"no_debug\",\n+            \"omit_gdb_pretty_printer_section\",\n             \"unsafe_no_drop_flag\",\n \n             // used in resolve"}, {"sha": "5d0532a621022eb6723685784600bb62014c8e37", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1599,7 +1599,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash,\n {\n-    let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n+    let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n         buckets[h % 256].push(elt);"}, {"sha": "522e1d4d3b284a571ca9e952e408264dfcff1d43", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -611,9 +611,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = pats[];\n-                                let subpats = Vec::from_fn(arity, |i| {\n+                                let subpats: Vec<_> = range(0, arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                                });\n+                                }).collect();\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n                             result.extend(pats.into_iter().skip(arity));\n@@ -635,7 +635,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, DUMMY_WILD_PAT);\n+                        let wild_pats: Vec<_> = repeat(DUMMY_WILD_PAT).take(arity).collect();\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats.into_iter());\n@@ -788,7 +788,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n         ast::PatWild(_) =>\n-            Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n+            Some(repeat(DUMMY_WILD_PAT).take(arity).collect()),\n \n         ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n@@ -801,7 +801,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, DUMMY_WILD_PAT))\n+                _ => Some(repeat(DUMMY_WILD_PAT).take(arity).collect())\n             }\n         }\n \n@@ -815,7 +815,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => Vec::from_elem(arity, DUMMY_WILD_PAT)\n+                        &None => repeat(DUMMY_WILD_PAT).take(arity).collect(),\n                     })\n                 }\n                 _ => None\n@@ -894,13 +894,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 // Fixed-length vectors.\n                 Single => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n+                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n+                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },"}, {"sha": "6cf6065de19f0ee90e6942ac161cd4e88d5e91a4", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -21,6 +21,7 @@ use middle::cfg::CFGIndex;\n use middle::ty;\n use std::io;\n use std::uint;\n+use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n use syntax::visit;\n@@ -203,9 +204,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let entry = if oper.initial_value() { uint::MAX } else {0};\n \n-        let gens = Vec::from_elem(num_nodes * words_per_id, 0);\n-        let kills = Vec::from_elem(num_nodes * words_per_id, 0);\n-        let on_entry = Vec::from_elem(num_nodes * words_per_id, entry);\n+        let gens: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let kills: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let on_entry: Vec<_> = repeat(entry).take(num_nodes * words_per_id).collect();\n \n         let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n \n@@ -446,7 +447,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                 changed: true\n             };\n \n-            let mut temp = Vec::from_elem(words_per_id, 0u);\n+            let mut temp: Vec<_> = repeat(0u).take(words_per_id).collect();\n             while propcx.changed {\n                 propcx.changed = false;\n                 propcx.reset(temp.as_mut_slice());"}, {"sha": "6f1c7af5b8628671494ec222c0bd538d91769c36", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1187,7 +1187,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n         while !ty_queue.is_empty() {\n-            let cur_ty = ty_queue.remove(0).unwrap();\n+            let cur_ty = ty_queue.remove(0);\n             match cur_ty.node {\n                 ast::TyRptr(lt_opt, ref mut_ty) => {\n                     let rebuild = match lt_opt {"}, {"sha": "91fbaca26d113fdc67f0a5e0b04c34d33a7f4ef8", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -799,7 +799,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n-        Vec::from_fn(n, |_i| self.next_ty_var())\n+        range(0, n).map(|_i| self.next_ty_var()).collect()\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {"}, {"sha": "7372bb267b06c853de1e77c1fe5e327af1cfb67f", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -34,6 +34,7 @@ use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n use std::u32;\n+use std::iter::repeat;\n use syntax::ast;\n \n mod doc;\n@@ -975,7 +976,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        Vec::from_fn(self.num_vars() as uint, |_| {\n+        range(0, self.num_vars() as uint).map(|_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -984,7 +985,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 classification: Contracting,\n                 value: NoValue,\n             }\n-        })\n+        }).collect()\n     }\n \n     fn dump_constraints(&self) {\n@@ -1247,7 +1248,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = Vec::from_elem(self.num_vars() as uint, u32::MAX);\n+        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as uint).collect();\n \n         let mut opt_graph = None;\n \n@@ -1308,7 +1309,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        Vec::from_fn(self.num_vars() as uint, |idx| var_data[idx].value)\n+        range(0, self.num_vars() as uint).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {"}, {"sha": "5be8d03e74359306afe6012ecda7e15ea5fb7abd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -117,6 +117,7 @@ use util::nodemap::NodeMap;\n \n use std::{fmt, io, uint};\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::ast::{mod, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::{mod, special_idents};\n@@ -575,8 +576,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         Liveness {\n             ir: ir,\n             s: specials,\n-            successors: Vec::from_elem(num_live_nodes, invalid_node()),\n-            users: Vec::from_elem(num_live_nodes * num_vars, invalid_users()),\n+            successors: repeat(invalid_node()).take(num_live_nodes).collect(),\n+            users: repeat(invalid_users()).take(num_live_nodes * num_vars).collect(),\n             loop_scope: Vec::new(),\n             break_ln: NodeMap::new(),\n             cont_ln: NodeMap::new(),\n@@ -1068,7 +1069,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // the same bindings, and we also consider the first pattern to be\n                 // the \"authoritative\" set of ids\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.head().map(|p| &**p),\n+                    self.define_bindings_in_arm_pats(arm.pats.first().map(|p| &**p),\n                                                      guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n@@ -1436,7 +1437,7 @@ fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n-    this.arm_pats_bindings(arm.pats.head().map(|p| &**p), |this, ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.first().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm);\n@@ -1542,7 +1543,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 } else {\n                     let ends_with_stmt = match body.expr {\n                         None if body.stmts.len() > 0 =>\n-                            match body.stmts.last().unwrap().node {\n+                            match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n                                     ty::expr_ty(self.ir.tcx, &**e) == t_ret\n                                 },\n@@ -1553,7 +1554,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.ir.tcx.sess.span_err(\n                         sp, \"not all control paths return a value\");\n                     if ends_with_stmt {\n-                        let last_stmt = body.stmts.last().unwrap();\n+                        let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n                                                         last_stmt.span, sp);\n                         let span_semicolon = Span {"}, {"sha": "edba2839f37eabc9476b5c8a85df7aae6e9d74de", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -751,10 +751,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n-                let name = token::get_ident(path.segments\n-                                                .last()\n-                                                .unwrap()\n-                                                .identifier);\n+                let name = token::get_ident(path.segments.last().unwrap().identifier);\n                 let origdid = orig_def.def_id();\n                 self.ensure_public(span,\n                                    def,"}, {"sha": "e9504a92f7b460ef714c3d9f24faef02dc88e8da", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -296,7 +296,7 @@ impl<'a> LifetimeContext<'a> {\n         debug!(\"visit_early_late: referenced_idents={}\",\n                referenced_idents);\n \n-        let (early, late) = generics.lifetimes.clone().partition(\n+        let (early, late): (Vec<_>, _) = generics.lifetimes.iter().cloned().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n         self.with(EarlyScope(early_space, &early, self.scope), move |old_scope, this| {"}, {"sha": "07da9853e558525d280845190bd51a345730bac9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -323,7 +323,11 @@ impl<T> VecPerParamSpace<T> {\n                 SelfSpace => { self.self_limit -= 1; }\n                 FnSpace => {}\n             }\n-            self.content.remove(limit - 1)\n+            if self.content.is_empty() {\n+                None\n+            } else {\n+                Some(self.content.remove(limit - 1))\n+            }\n         }\n     }\n "}, {"sha": "e7c77b12499274360e9f3ce7bacbe6a75b87c836", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -14,7 +14,7 @@ pub fn lev_distance(me: &str, t: &str) -> uint {\n     if me.is_empty() { return t.chars().count(); }\n     if t.is_empty() { return me.chars().count(); }\n \n-    let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+    let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n     let mut t_last = 0;\n \n     for (i, sc) in me.chars().enumerate() {"}, {"sha": "366e33d6384ba0888d805dae10cf8d7726c5021e", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -14,7 +14,7 @@\n \n #![allow(deprecated)] // to_be32\n \n-use std::iter::range_step;\n+use std::iter::{range_step, repeat};\n use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n@@ -258,7 +258,7 @@ pub trait Digest {\n     /// Convenience function that retrieves the result of a digest as a\n     /// newly allocated vec of bytes.\n     fn result_bytes(&mut self) -> Vec<u8> {\n-        let mut buf = Vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        let mut buf: Vec<u8> = repeat(0u8).take((self.output_bits()+7)/8).collect();\n         self.result(buf.as_mut_slice());\n         buf\n     }\n@@ -530,11 +530,12 @@ static H256: [u32, ..8] = [\n mod tests {\n     extern crate rand;\n \n-    use super::{Digest, Sha256, FixedBuffer};\n-    use self::rand::isaac::IsaacRng;\n     use self::rand::Rng;\n+    use self::rand::isaac::IsaacRng;\n     use serialize::hex::FromHex;\n+    use std::iter::repeat;\n     use std::num::Int;\n+    use super::{Digest, Sha256, FixedBuffer};\n \n     // A normal addition - no overflow occurs\n     #[test]\n@@ -612,7 +613,7 @@ mod tests {\n     /// correct.\n     fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n         let total_size = 1000000;\n-        let buffer = Vec::from_elem(blocksize * 2, 'a' as u8);\n+        let buffer: Vec<u8> = repeat('a' as u8).take(blocksize * 2).collect();\n         let mut rng = IsaacRng::new_unseeded();\n         let mut count = 0;\n "}, {"sha": "070ae1151aa6d4701e305057cd84bdb4471b9662", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -25,7 +25,6 @@ use rustc::middle::mem_categorization as mc;\n use rustc::util::ppaux::{Repr, UserString};\n use std::mem;\n use std::rc::Rc;\n-use std::slice;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n@@ -268,9 +267,9 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     return;\n \n     fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n-        match set.binary_search_elem(&elem) {\n-            slice::BinarySearchResult::Found(_) => false,\n-            slice::BinarySearchResult::NotFound(_) => true,\n+        match set.binary_search(&elem) {\n+            Ok(_) => false,\n+            Err(_) => true,\n         }\n     }\n }"}, {"sha": "664d470b11bd1c46ad6a228946272b712f8ad6f5", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -37,4 +37,3 @@ pub use borrowck::FnPartsWithCFG;\n mod borrowck;\n \n pub mod graphviz;\n-"}, {"sha": "0d98434d042ba91f672d6f6a172925ec1ead6f02", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -265,11 +265,13 @@ Available lint options:\n         lints\n     }\n \n-    let (plugin, builtin) = lint_store.get_lints().partitioned(|&(_, p)| p);\n+    let (plugin, builtin): (Vec<_>, _) = lint_store.get_lints()\n+        .iter().cloned().partition(|&(_, p)| p);\n     let plugin = sort_lints(plugin);\n     let builtin = sort_lints(builtin);\n \n-    let (plugin_groups, builtin_groups) = lint_store.get_lint_groups().partitioned(|&(_, _, p)| p);\n+    let (plugin_groups, builtin_groups): (Vec<_>, _) = lint_store.get_lint_groups()\n+        .iter().cloned().partition(|&(_, _, p)| p);\n     let plugin_groups = sort_lint_groups(plugin_groups);\n     let builtin_groups = sort_lint_groups(builtin_groups);\n \n@@ -377,7 +379,7 @@ fn describe_codegen_flags() {\n /// returns None.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n-    let _binary = args.remove(0).unwrap();\n+    let _binary = args.remove(0);\n \n     if args.is_empty() {\n         // user did not write `-v` nor `-Z unstable-options`, so do not"}, {"sha": "296ebcf9cfd8f7b946bef5d6e0bf2700654f2d57", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1743,7 +1743,8 @@ extern {\n                                           isOptimized: bool,\n                                           Flags: *const c_char,\n                                           RuntimeVer: c_uint,\n-                                          SplitName: *const c_char);\n+                                          SplitName: *const c_char)\n+                                          -> DIDescriptor;\n \n     pub fn LLVMDIBuilderCreateFile(Builder: DIBuilderRef,\n                                    Filename: *const c_char,"}, {"sha": "7dbcc810b571b521a0b1435ea109eef9df387e25", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "added", "additions": 1282, "deletions": 0, "changes": 1282, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -0,0 +1,1282 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Reduced graph building\n+//!\n+//! Here we build the \"reduced graph\": the graph of the module tree without\n+//! any imports resolved.\n+\n+use {DefModifiers, PUBLIC, IMPORTABLE};\n+use ImportDirective;\n+use ImportDirectiveSubclass::{mod, SingleImport, GlobImport};\n+use ImportResolution;\n+use Module;\n+use ModuleKind::*;\n+use Namespace::{TypeNS, ValueNS};\n+use NameBindings;\n+use ParentLink::{mod, ModuleParentLink, BlockParentLink};\n+use Resolver;\n+use RibKind::*;\n+use Shadowable;\n+use TypeNsDef;\n+use TypeParameters::HasTypeParameters;\n+\n+use self::DuplicateCheckingMode::*;\n+use self::NamespaceError::*;\n+\n+use rustc::metadata::csearch;\n+use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n+use rustc::middle::def::*;\n+use rustc::middle::subst::FnSpace;\n+\n+use syntax::ast::{Block, Crate};\n+use syntax::ast::{DeclItem, DefId};\n+use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n+use syntax::ast::{Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy};\n+use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n+use syntax::ast::{PathListIdent, PathListMod};\n+use syntax::ast::{Public, SelfStatic};\n+use syntax::ast::StmtDecl;\n+use syntax::ast::StructVariantKind;\n+use syntax::ast::TupleVariantKind;\n+use syntax::ast::TyObjectSum;\n+use syntax::ast::{TypeImplItem, UnnamedField};\n+use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n+use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Visibility};\n+use syntax::ast::TyPath;\n+use syntax::ast;\n+use syntax::ast_util::{mod, PostExpansionMethod, local_def};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token::{mod, special_idents};\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::visit::{mod, Visitor};\n+\n+use std::rc::Rc;\n+use std::mem::replace;\n+\n+// Specifies how duplicates should be handled when adding a child item if\n+// another item exists with the same name in some namespace.\n+#[deriving(Copy, PartialEq)]\n+enum DuplicateCheckingMode {\n+    ForbidDuplicateModules,\n+    ForbidDuplicateTypesAndModules,\n+    ForbidDuplicateValues,\n+    ForbidDuplicateTypesAndValues,\n+    OverwriteDuplicates\n+}\n+\n+#[deriving(Copy, PartialEq)]\n+enum NamespaceError {\n+    NoError,\n+    ModuleError,\n+    TypeError,\n+    ValueError\n+}\n+\n+fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n+    match ns {\n+        NoError                 => \"\",\n+        ModuleError | TypeError => \"type or module\",\n+        ValueError              => \"value\",\n+    }\n+}\n+\n+struct GraphBuilder<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+    fn deref(&self) -> &Resolver<'b, 'tcx> {\n+        &*self.resolver\n+    }\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Resolver<'b, 'tcx> {\n+        &mut *self.resolver\n+    }\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n+    /// Constructs the reduced graph for the entire crate.\n+    fn build_reduced_graph(self, krate: &ast::Crate) {\n+        let parent = self.graph_root.get_module();\n+        let mut visitor = BuildReducedGraphVisitor {\n+            builder: self,\n+            parent: parent\n+        };\n+        visit::walk_crate(&mut visitor, krate);\n+    }\n+\n+    /// Adds a new child item to the module definition of the parent node and\n+    /// returns its corresponding name bindings as well as the current parent.\n+    /// Or, if we're inside a block, creates (or reuses) an anonymous module\n+    /// corresponding to the innermost block ID and returns the name bindings\n+    /// as well as the newly-created parent.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if this node does not have a module definition and we are not inside\n+    /// a block.\n+    fn add_child(&self,\n+                 name: Name,\n+                 parent: &Rc<Module>,\n+                 duplicate_checking_mode: DuplicateCheckingMode,\n+                 // For printing errors\n+                 sp: Span)\n+                 -> Rc<NameBindings> {\n+        // If this is the immediate descendant of a module, then we add the\n+        // child name directly. Otherwise, we create or reuse an anonymous\n+        // module and add the child to that.\n+\n+        self.check_for_conflicts_between_external_crates_and_items(&**parent,\n+                                                                   name,\n+                                                                   sp);\n+\n+        // Add or reuse the child.\n+        let child = parent.children.borrow().get(&name).cloned();\n+        match child {\n+            None => {\n+                let child = Rc::new(NameBindings::new());\n+                parent.children.borrow_mut().insert(name, child.clone());\n+                child\n+            }\n+            Some(child) => {\n+                // Enforce the duplicate checking mode:\n+                //\n+                // * If we're requesting duplicate module checking, check that\n+                //   there isn't a module in the module with the same name.\n+                //\n+                // * If we're requesting duplicate type checking, check that\n+                //   there isn't a type in the module with the same name.\n+                //\n+                // * If we're requesting duplicate value checking, check that\n+                //   there isn't a value in the module with the same name.\n+                //\n+                // * If we're requesting duplicate type checking and duplicate\n+                //   value checking, check that there isn't a duplicate type\n+                //   and a duplicate value with the same name.\n+                //\n+                // * If no duplicate checking was requested at all, do\n+                //   nothing.\n+\n+                let mut duplicate_type = NoError;\n+                let ns = match duplicate_checking_mode {\n+                    ForbidDuplicateModules => {\n+                        if child.get_module_if_available().is_some() {\n+                            duplicate_type = ModuleError;\n+                        }\n+                        Some(TypeNS)\n+                    }\n+                    ForbidDuplicateTypesAndModules => {\n+                        match child.def_for_namespace(TypeNS) {\n+                            None => {}\n+                            Some(_) if child.get_module_if_available()\n+                                            .map(|m| m.kind.get()) ==\n+                                       Some(ImplModuleKind) => {}\n+                            Some(_) => duplicate_type = TypeError\n+                        }\n+                        Some(TypeNS)\n+                    }\n+                    ForbidDuplicateValues => {\n+                        if child.defined_in_namespace(ValueNS) {\n+                            duplicate_type = ValueError;\n+                        }\n+                        Some(ValueNS)\n+                    }\n+                    ForbidDuplicateTypesAndValues => {\n+                        let mut n = None;\n+                        match child.def_for_namespace(TypeNS) {\n+                            Some(DefMod(_)) | None => {}\n+                            Some(_) => {\n+                                n = Some(TypeNS);\n+                                duplicate_type = TypeError;\n+                            }\n+                        };\n+                        if child.defined_in_namespace(ValueNS) {\n+                            duplicate_type = ValueError;\n+                            n = Some(ValueNS);\n+                        }\n+                        n\n+                    }\n+                    OverwriteDuplicates => None\n+                };\n+                if duplicate_type != NoError {\n+                    // Return an error here by looking up the namespace that\n+                    // had the duplicate.\n+                    let ns = ns.unwrap();\n+                    self.resolve_error(sp,\n+                        format!(\"duplicate definition of {} `{}`\",\n+                             namespace_error_to_string(duplicate_type),\n+                             token::get_name(name))[]);\n+                    {\n+                        let r = child.span_for_namespace(ns);\n+                        for sp in r.iter() {\n+                            self.session.span_note(*sp,\n+                                 format!(\"first definition of {} `{}` here\",\n+                                      namespace_error_to_string(duplicate_type),\n+                                      token::get_name(name))[]);\n+                        }\n+                    }\n+                }\n+                child\n+            }\n+        }\n+    }\n+\n+    fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n+        // If the block has view items, we need an anonymous module.\n+        if block.view_items.len() > 0 {\n+            return true;\n+        }\n+\n+        // Check each statement.\n+        for statement in block.stmts.iter() {\n+            match statement.node {\n+                StmtDecl(ref declaration, _) => {\n+                    match declaration.node {\n+                        DeclItem(_) => {\n+                            return true;\n+                        }\n+                        _ => {\n+                            // Keep searching.\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // Keep searching.\n+                }\n+            }\n+        }\n+\n+        // If we found neither view items nor items, we don't need to create\n+        // an anonymous module.\n+\n+        return false;\n+    }\n+\n+    fn get_parent_link(&mut self, parent: &Rc<Module>, name: Name) -> ParentLink {\n+        ModuleParentLink(parent.downgrade(), name)\n+    }\n+\n+    /// Constructs the reduced graph for one item.\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent: &Rc<Module>) -> Rc<Module> {\n+        let name = item.ident.name;\n+        let sp = item.span;\n+        let is_public = item.vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+\n+        match item.node {\n+            ItemMod(..) => {\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n+\n+                let parent_link = self.get_parent_link(parent, name);\n+                let def_id = DefId { krate: 0, node: item.id };\n+                name_bindings.define_module(parent_link,\n+                                            Some(def_id),\n+                                            NormalModuleKind,\n+                                            false,\n+                                            item.vis == ast::Public,\n+                                            sp);\n+\n+                name_bindings.get_module()\n+            }\n+\n+            ItemForeignMod(..) => parent.clone(),\n+\n+            // These items live in the value namespace.\n+            ItemStatic(_, m, _) => {\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n+                let mutbl = m == ast::MutMutable;\n+\n+                name_bindings.define_value(DefStatic(local_def(item.id), mutbl), sp, modifiers);\n+                parent.clone()\n+            }\n+            ItemConst(_, _) => {\n+                self.add_child(name, parent, ForbidDuplicateValues, sp)\n+                    .define_value(DefConst(local_def(item.id)), sp, modifiers);\n+                parent.clone()\n+            }\n+            ItemFn(_, _, _, _, _) => {\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n+\n+                let def = DefFn(local_def(item.id), false);\n+                name_bindings.define_value(def, sp, modifiers);\n+                parent.clone()\n+            }\n+\n+            // These items live in the type namespace.\n+            ItemTy(..) => {\n+                let name_bindings =\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+\n+                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n+                parent.clone()\n+            }\n+\n+            ItemEnum(ref enum_definition, _) => {\n+                let name_bindings =\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+\n+                name_bindings.define_type(DefTy(local_def(item.id), true), sp, modifiers);\n+\n+                let parent_link = self.get_parent_link(parent, name);\n+                // We want to make sure the module type is EnumModuleKind\n+                // even if there's already an ImplModuleKind module defined,\n+                // since that's how we prevent duplicate enum definitions\n+                name_bindings.set_module_kind(parent_link,\n+                                              Some(local_def(item.id)),\n+                                              EnumModuleKind,\n+                                              false,\n+                                              is_public,\n+                                              sp);\n+\n+                let module = name_bindings.get_module();\n+\n+                for variant in (*enum_definition).variants.iter() {\n+                    self.build_reduced_graph_for_variant(\n+                        &**variant,\n+                        local_def(item.id),\n+                        &module);\n+                }\n+                parent.clone()\n+            }\n+\n+            // These items live in both the type and value namespaces.\n+            ItemStruct(ref struct_def, _) => {\n+                // Adding to both Type and Value namespaces or just Type?\n+                let (forbid, ctor_id) = match struct_def.ctor_id {\n+                    Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n+                    None            => (ForbidDuplicateTypesAndModules, None)\n+                };\n+\n+                let name_bindings = self.add_child(name, parent, forbid, sp);\n+\n+                // Define a name in the type namespace.\n+                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n+\n+                // If this is a newtype or unit-like struct, define a name\n+                // in the value namespace as well\n+                if let Some(cid) = ctor_id {\n+                    name_bindings.define_value(DefStruct(local_def(cid)), sp, modifiers);\n+                }\n+\n+                // Record the def ID and fields of this struct.\n+                let named_fields = struct_def.fields.iter().filter_map(|f| {\n+                    match f.node.kind {\n+                        NamedField(ident, _) => Some(ident.name),\n+                        UnnamedField(_) => None\n+                    }\n+                }).collect();\n+                self.structs.insert(local_def(item.id), named_fields);\n+\n+                parent.clone()\n+            }\n+\n+            ItemImpl(_, _, None, ref ty, ref impl_items) => {\n+                // If this implements an anonymous trait, then add all the\n+                // methods within to a new module, if the type was defined\n+                // within this module.\n+\n+                let mod_name = match ty.node {\n+                    TyPath(ref path, _) if path.segments.len() == 1 => {\n+                        // FIXME(18446) we should distinguish between the name of\n+                        // a trait and the name of an impl of that trait.\n+                        Some(path.segments.last().unwrap().identifier.name)\n+                    }\n+                    TyObjectSum(ref lhs_ty, _) => {\n+                        match lhs_ty.node {\n+                            TyPath(ref path, _) if path.segments.len() == 1 => {\n+                                Some(path.segments.last().unwrap().identifier.name)\n+                            }\n+                            _ => {\n+                                None\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        None\n+                    }\n+                };\n+\n+                match mod_name {\n+                    None => {\n+                        self.resolve_error(ty.span,\n+                                           \"inherent implementations may \\\n+                                            only be implemented in the same \\\n+                                            module as the type they are \\\n+                                            implemented for\")\n+                    }\n+                    Some(mod_name) => {\n+                        // Create the module and add all methods.\n+                        let parent_opt = parent.children.borrow().get(&mod_name).cloned();\n+                        let new_parent = match parent_opt {\n+                            // It already exists\n+                            Some(ref child) if child.get_module_if_available()\n+                                .is_some() &&\n+                                (child.get_module().kind.get() == ImplModuleKind ||\n+                                 child.get_module().kind.get() == TraitModuleKind) => {\n+                                    child.get_module()\n+                                }\n+                            Some(ref child) if child.get_module_if_available()\n+                                .is_some() &&\n+                                child.get_module().kind.get() ==\n+                                EnumModuleKind => child.get_module(),\n+                            // Create the module\n+                            _ => {\n+                                let name_bindings =\n+                                    self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n+\n+                                let parent_link = self.get_parent_link(parent, name);\n+                                let def_id = local_def(item.id);\n+                                let ns = TypeNS;\n+                                let is_public =\n+                                    !name_bindings.defined_in_namespace(ns) ||\n+                                    name_bindings.defined_in_public_namespace(ns);\n+\n+                                name_bindings.define_module(parent_link,\n+                                                            Some(def_id),\n+                                                            ImplModuleKind,\n+                                                            false,\n+                                                            is_public,\n+                                                            sp);\n+\n+                                name_bindings.get_module()\n+                            }\n+                        };\n+\n+                        // For each implementation item...\n+                        for impl_item in impl_items.iter() {\n+                            match *impl_item {\n+                                MethodImplItem(ref method) => {\n+                                    // Add the method to the module.\n+                                    let name = method.pe_ident().name;\n+                                    let method_name_bindings =\n+                                        self.add_child(name,\n+                                                       &new_parent,\n+                                                       ForbidDuplicateValues,\n+                                                       method.span);\n+                                    let def = match method.pe_explicit_self()\n+                                        .node {\n+                                            SelfStatic => {\n+                                                // Static methods become\n+                                                // `DefStaticMethod`s.\n+                                                DefStaticMethod(local_def(method.id),\n+                                                                FromImpl(local_def(item.id)))\n+                                            }\n+                                            _ => {\n+                                                // Non-static methods become\n+                                                // `DefMethod`s.\n+                                                DefMethod(local_def(method.id),\n+                                                          None,\n+                                                          FromImpl(local_def(item.id)))\n+                                            }\n+                                        };\n+\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if method.pe_vis() == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n+                                    method_name_bindings.define_value(\n+                                        def,\n+                                        method.span,\n+                                        modifiers);\n+                                }\n+                                TypeImplItem(ref typedef) => {\n+                                    // Add the typedef to the module.\n+                                    let name = typedef.ident.name;\n+                                    let typedef_name_bindings =\n+                                        self.add_child(\n+                                            name,\n+                                            &new_parent,\n+                                            ForbidDuplicateTypesAndModules,\n+                                            typedef.span);\n+                                    let def = DefAssociatedTy(local_def(\n+                                        typedef.id));\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if typedef.vis == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n+                                    typedef_name_bindings.define_type(\n+                                        def,\n+                                        typedef.span,\n+                                        modifiers);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                parent.clone()\n+            }\n+\n+            ItemImpl(_, _, Some(_), _, _) => parent.clone(),\n+\n+            ItemTrait(_, _, _, ref items) => {\n+                let name_bindings =\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+\n+                // Add all the items within to a new module.\n+                let parent_link = self.get_parent_link(parent, name);\n+                name_bindings.define_module(parent_link,\n+                                            Some(local_def(item.id)),\n+                                            TraitModuleKind,\n+                                            false,\n+                                            item.vis == ast::Public,\n+                                            sp);\n+                let module_parent = name_bindings.get_module();\n+\n+                let def_id = local_def(item.id);\n+\n+                // Add the names of all the items to the trait info.\n+                for trait_item in items.iter() {\n+                    let (name, kind) = match *trait_item {\n+                        ast::RequiredMethod(_) |\n+                        ast::ProvidedMethod(_) => {\n+                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n+\n+                            let name = ty_m.ident.name;\n+\n+                            // Add it as a name in the trait module.\n+                            let (def, static_flag) = match ty_m.explicit_self\n+                                                               .node {\n+                                SelfStatic => {\n+                                    // Static methods become `DefStaticMethod`s.\n+                                    (DefStaticMethod(\n+                                            local_def(ty_m.id),\n+                                            FromTrait(local_def(item.id))),\n+                                     StaticMethodTraitItemKind)\n+                                }\n+                                _ => {\n+                                    // Non-static methods become `DefMethod`s.\n+                                    (DefMethod(local_def(ty_m.id),\n+                                               Some(local_def(item.id)),\n+                                               FromTrait(local_def(item.id))),\n+                                     NonstaticMethodTraitItemKind)\n+                                }\n+                            };\n+\n+                            let method_name_bindings =\n+                                self.add_child(name,\n+                                               &module_parent,\n+                                               ForbidDuplicateTypesAndValues,\n+                                               ty_m.span);\n+                            // NB: not IMPORTABLE\n+                            method_name_bindings.define_value(def,\n+                                                              ty_m.span,\n+                                                              PUBLIC);\n+\n+                            (name, static_flag)\n+                        }\n+                        ast::TypeTraitItem(ref associated_type) => {\n+                            let def = DefAssociatedTy(local_def(\n+                                    associated_type.ty_param.id));\n+\n+                            let name_bindings =\n+                                self.add_child(associated_type.ty_param.ident.name,\n+                                               &module_parent,\n+                                               ForbidDuplicateTypesAndValues,\n+                                               associated_type.ty_param.span);\n+                            // NB: not IMPORTABLE\n+                            name_bindings.define_type(def,\n+                                                      associated_type.ty_param.span,\n+                                                      PUBLIC);\n+\n+                            (associated_type.ty_param.ident.name, TypeTraitItemKind)\n+                        }\n+                    };\n+\n+                    self.trait_item_map.insert((name, def_id), kind);\n+                }\n+\n+                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n+                parent.clone()\n+            }\n+            ItemMac(..) => parent.clone()\n+        }\n+    }\n+\n+    // Constructs the reduced graph for one variant. Variants exist in the\n+    // type and value namespaces.\n+    fn build_reduced_graph_for_variant(&mut self,\n+                                       variant: &Variant,\n+                                       item_id: DefId,\n+                                       parent: &Rc<Module>) {\n+        let name = variant.node.name.name;\n+        let is_exported = match variant.node.kind {\n+            TupleVariantKind(_) => false,\n+            StructVariantKind(_) => {\n+                // Not adding fields for variants as they are not accessed with a self receiver\n+                self.structs.insert(local_def(variant.node.id), Vec::new());\n+                true\n+            }\n+        };\n+\n+        let child = self.add_child(name, parent,\n+                                   ForbidDuplicateTypesAndValues,\n+                                   variant.span);\n+        // variants are always treated as importable to allow them to be glob\n+        // used\n+        child.define_value(DefVariant(item_id,\n+                                      local_def(variant.node.id), is_exported),\n+                           variant.span, PUBLIC | IMPORTABLE);\n+        child.define_type(DefVariant(item_id,\n+                                     local_def(variant.node.id), is_exported),\n+                          variant.span, PUBLIC | IMPORTABLE);\n+    }\n+\n+    /// Constructs the reduced graph for one 'view item'. View items consist\n+    /// of imports and use directives.\n+    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem, parent: &Rc<Module>) {\n+        match view_item.node {\n+            ViewItemUse(ref view_path) => {\n+                // Extract and intern the module part of the path. For\n+                // globs and lists, the path is found directly in the AST;\n+                // for simple paths we have to munge the path a little.\n+                let module_path = match view_path.node {\n+                    ViewPathSimple(_, ref full_path, _) => {\n+                        full_path.segments\n+                            .init()\n+                            .iter().map(|ident| ident.identifier.name)\n+                            .collect()\n+                    }\n+\n+                    ViewPathGlob(ref module_ident_path, _) |\n+                    ViewPathList(ref module_ident_path, _, _) => {\n+                        module_ident_path.segments\n+                            .iter().map(|ident| ident.identifier.name).collect()\n+                    }\n+                };\n+\n+                // Build up the import directives.\n+                let is_public = view_item.vis == ast::Public;\n+                let shadowable =\n+                    view_item.attrs\n+                             .iter()\n+                             .any(|attr| {\n+                                 attr.name() == token::get_name(\n+                                    special_idents::prelude_import.name)\n+                             });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n+\n+                match view_path.node {\n+                    ViewPathSimple(binding, ref full_path, id) => {\n+                        let source_name =\n+                            full_path.segments.last().unwrap().identifier.name;\n+                        if token::get_name(source_name).get() == \"mod\" {\n+                            self.resolve_error(view_path.span,\n+                                \"`mod` imports are only allowed within a { } list\");\n+                        }\n+\n+                        let subclass = SingleImport(binding.name,\n+                                                    source_name);\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    subclass,\n+                                                    view_path.span,\n+                                                    id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                    ViewPathList(_, ref source_items, _) => {\n+                        // Make sure there's at most one `mod` import in the list.\n+                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n+                            PathListMod { .. } => Some(item.span),\n+                            _ => None\n+                        }).collect::<Vec<Span>>();\n+                        if mod_spans.len() > 1 {\n+                            self.resolve_error(mod_spans[0],\n+                                \"`mod` import can only appear once in the list\");\n+                            for other_span in mod_spans.iter().skip(1) {\n+                                self.session.span_note(*other_span,\n+                                    \"another `mod` import appears here\");\n+                            }\n+                        }\n+\n+                        for source_item in source_items.iter() {\n+                            let (module_path, name) = match source_item.node {\n+                                PathListIdent { name, .. } =>\n+                                    (module_path.clone(), name.name),\n+                                PathListMod { .. } => {\n+                                    let name = match module_path.last() {\n+                                        Some(name) => *name,\n+                                        None => {\n+                                            self.resolve_error(source_item.span,\n+                                                \"`mod` import can only appear in an import list \\\n+                                                 with a non-empty prefix\");\n+                                            continue;\n+                                        }\n+                                    };\n+                                    let module_path = module_path.init();\n+                                    (module_path.to_vec(), name)\n+                                }\n+                            };\n+                            self.build_import_directive(\n+                                &**parent,\n+                                module_path,\n+                                SingleImport(name, name),\n+                                source_item.span,\n+                                source_item.node.id(),\n+                                is_public,\n+                                shadowable);\n+                        }\n+                    }\n+                    ViewPathGlob(_, id) => {\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    GlobImport,\n+                                                    view_path.span,\n+                                                    id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                }\n+            }\n+\n+            ViewItemExternCrate(name, _, node_id) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n+                for &crate_id in self.session.cstore\n+                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n+                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    self.external_exports.insert(def_id);\n+                    let parent_link = ModuleParentLink(parent.downgrade(), name.name);\n+                    let external_module = Rc::new(Module::new(parent_link,\n+                                                              Some(def_id),\n+                                                              NormalModuleKind,\n+                                                              false,\n+                                                              true));\n+                    debug!(\"(build reduced graph for item) found extern `{}`\",\n+                            self.module_to_string(&*external_module));\n+                    self.check_for_conflicts_between_external_crates(\n+                        &**parent,\n+                        name.name,\n+                        view_item.span);\n+                    parent.external_module_children.borrow_mut()\n+                          .insert(name.name, external_module.clone());\n+                    self.build_reduced_graph_for_external_crate(&external_module);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Constructs the reduced graph for one foreign item.\n+    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n+                                               foreign_item: &ForeignItem,\n+                                               parent: &Rc<Module>,\n+                                               f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n+        let name = foreign_item.ident.name;\n+        let is_public = foreign_item.vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let name_bindings =\n+            self.add_child(name, parent, ForbidDuplicateValues,\n+                           foreign_item.span);\n+\n+        match foreign_item.node {\n+            ForeignItemFn(_, ref generics) => {\n+                let def = DefFn(local_def(foreign_item.id), false);\n+                name_bindings.define_value(def, foreign_item.span, modifiers);\n+\n+                self.with_type_parameter_rib(\n+                    HasTypeParameters(generics,\n+                                      FnSpace,\n+                                      foreign_item.id,\n+                                      NormalRibKind),\n+                    f);\n+            }\n+            ForeignItemStatic(_, m) => {\n+                let def = DefStatic(local_def(foreign_item.id), m);\n+                name_bindings.define_value(def, foreign_item.span, modifiers);\n+\n+                f(self.resolver)\n+            }\n+        }\n+    }\n+\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &Rc<Module>) -> Rc<Module> {\n+        if self.block_needs_anonymous_module(block) {\n+            let block_id = block.id;\n+\n+            debug!(\"(building reduced graph for block) creating a new \\\n+                    anonymous module for block {}\",\n+                   block_id);\n+\n+            let new_module = Rc::new(Module::new(\n+                BlockParentLink(parent.downgrade(), block_id),\n+                None,\n+                AnonymousModuleKind,\n+                false,\n+                false));\n+            parent.anonymous_children.borrow_mut().insert(block_id, new_module.clone());\n+            new_module\n+        } else {\n+            parent.clone()\n+        }\n+    }\n+\n+    fn handle_external_def(&mut self,\n+                           def: Def,\n+                           vis: Visibility,\n+                           child_name_bindings: &NameBindings,\n+                           final_ident: &str,\n+                           name: Name,\n+                           new_parent: &Rc<Module>) {\n+        debug!(\"(building reduced graph for \\\n+                external crate) building external def, priv {}\",\n+               vis);\n+        let is_public = vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let is_exported = is_public && match new_parent.def_id.get() {\n+            None => true,\n+            Some(did) => self.external_exports.contains(&did)\n+        };\n+        if is_exported {\n+            self.external_exports.insert(def.def_id());\n+        }\n+\n+        let kind = match def {\n+            DefTy(_, true) => EnumModuleKind,\n+            DefStruct(..) | DefTy(..) => ImplModuleKind,\n+            _ => NormalModuleKind\n+        };\n+\n+        match def {\n+          DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n+          DefTy(def_id, _) => {\n+            let type_def = child_name_bindings.type_def.borrow().clone();\n+            match type_def {\n+              Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        already created module\");\n+                module_def.def_id.set(Some(def_id));\n+              }\n+              Some(_) | None => {\n+                debug!(\"(building reduced graph for \\\n+                        external crate) building module \\\n+                        {}\", final_ident);\n+                let parent_link = self.get_parent_link(new_parent, name);\n+\n+                child_name_bindings.define_module(parent_link,\n+                                                  Some(def_id),\n+                                                  kind,\n+                                                  true,\n+                                                  is_public,\n+                                                  DUMMY_SP);\n+              }\n+            }\n+          }\n+          _ => {}\n+        }\n+\n+        match def {\n+          DefMod(_) | DefForeignMod(_) => {}\n+          DefVariant(_, variant_id, is_struct) => {\n+              debug!(\"(building reduced graph for external crate) building \\\n+                      variant {}\",\n+                      final_ident);\n+              // variants are always treated as importable to allow them to be\n+              // glob used\n+              let modifiers = PUBLIC | IMPORTABLE;\n+              if is_struct {\n+                  child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                  // Not adding fields for variants as they are not accessed with a self receiver\n+                  self.structs.insert(variant_id, Vec::new());\n+              } else {\n+                  child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+              }\n+          }\n+          DefFn(ctor_id, true) => {\n+            child_name_bindings.define_value(\n+                csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n+                    .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n+          }\n+          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n+            debug!(\"(building reduced graph for external \\\n+                    crate) building value (fn/static) {}\", final_ident);\n+            // impl methods have already been defined with the correct importability modifier\n+            let mut modifiers = match *child_name_bindings.value_def.borrow() {\n+                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n+                None => modifiers\n+            };\n+            if new_parent.kind.get() != NormalModuleKind {\n+                modifiers = modifiers & !IMPORTABLE;\n+            }\n+            child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+          }\n+          DefTrait(def_id) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n+\n+              // If this is a trait, add all the trait item names to the trait\n+              // info.\n+\n+              let trait_item_def_ids =\n+                csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n+              for trait_item_def_id in trait_item_def_ids.iter() {\n+                  let (trait_item_name, trait_item_kind) =\n+                      csearch::get_trait_item_name_and_kind(\n+                          &self.session.cstore,\n+                          trait_item_def_id.def_id());\n+\n+                  debug!(\"(building reduced graph for external crate) ... \\\n+                          adding trait item '{}'\",\n+                         token::get_name(trait_item_name));\n+\n+                  self.trait_item_map.insert((trait_item_name, def_id), trait_item_kind);\n+\n+                  if is_exported {\n+                      self.external_exports\n+                          .insert(trait_item_def_id.def_id());\n+                  }\n+              }\n+\n+              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+\n+              // Define a module if necessary.\n+              let parent_link = self.get_parent_link(new_parent, name);\n+              child_name_bindings.set_module_kind(parent_link,\n+                                                  Some(def_id),\n+                                                  TraitModuleKind,\n+                                                  true,\n+                                                  is_public,\n+                                                  DUMMY_SP)\n+          }\n+          DefTy(..) | DefAssociatedTy(..) | DefAssociatedPath(..) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n+\n+              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+          }\n+          DefStruct(def_id) => {\n+            debug!(\"(building reduced graph for external \\\n+                    crate) building type and value for {}\",\n+                   final_ident);\n+            child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+            let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n+                f.name\n+            }).collect::<Vec<_>>();\n+\n+            if fields.len() == 0 {\n+                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+            }\n+\n+            // Record the def ID and fields of this struct.\n+            self.structs.insert(def_id, fields);\n+          }\n+          DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n+          DefUse(..) | DefUpvar(..) | DefRegion(..) |\n+          DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n+            panic!(\"didn't expect `{}`\", def);\n+          }\n+        }\n+    }\n+\n+    /// Builds the reduced graph for a single item in an external crate.\n+    fn build_reduced_graph_for_external_crate_def(&mut self,\n+                                                  root: &Rc<Module>,\n+                                                  def_like: DefLike,\n+                                                  name: Name,\n+                                                  visibility: Visibility) {\n+        match def_like {\n+            DlDef(def) => {\n+                // Add the new child item, if necessary.\n+                match def {\n+                    DefForeignMod(def_id) => {\n+                        // Foreign modules have no names. Recur and populate\n+                        // eagerly.\n+                        csearch::each_child_of_item(&self.session.cstore,\n+                                                    def_id,\n+                                                    |def_like,\n+                                                     child_name,\n+                                                     vis| {\n+                            self.build_reduced_graph_for_external_crate_def(\n+                                root,\n+                                def_like,\n+                                child_name,\n+                                vis)\n+                        });\n+                    }\n+                    _ => {\n+                        let child_name_bindings =\n+                            self.add_child(name,\n+                                           root,\n+                                           OverwriteDuplicates,\n+                                           DUMMY_SP);\n+\n+                        self.handle_external_def(def,\n+                                                 visibility,\n+                                                 &*child_name_bindings,\n+                                                 token::get_name(name).get(),\n+                                                 name,\n+                                                 root);\n+                    }\n+                }\n+            }\n+            DlImpl(def) => {\n+                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n+                    None => {}\n+                    Some(final_name) => {\n+                        let methods_opt =\n+                            csearch::get_methods_if_impl(&self.session.cstore, def);\n+                        match methods_opt {\n+                            Some(ref methods) if\n+                                methods.len() >= 1 => {\n+                                debug!(\"(building reduced graph for \\\n+                                        external crate) processing \\\n+                                        static methods for type name {}\",\n+                                        token::get_name(final_name));\n+\n+                                let child_name_bindings =\n+                                    self.add_child(\n+                                        final_name,\n+                                        root,\n+                                        OverwriteDuplicates,\n+                                        DUMMY_SP);\n+\n+                                // Process the static methods. First,\n+                                // create the module.\n+                                let type_module;\n+                                let type_def = child_name_bindings.type_def.borrow().clone();\n+                                match type_def {\n+                                    Some(TypeNsDef {\n+                                        module_def: Some(module_def),\n+                                        ..\n+                                    }) => {\n+                                        // We already have a module. This\n+                                        // is OK.\n+                                        type_module = module_def;\n+\n+                                        // Mark it as an impl module if\n+                                        // necessary.\n+                                        type_module.kind.set(ImplModuleKind);\n+                                    }\n+                                    Some(_) | None => {\n+                                        let parent_link =\n+                                            self.get_parent_link(root, final_name);\n+                                        child_name_bindings.define_module(\n+                                            parent_link,\n+                                            Some(def),\n+                                            ImplModuleKind,\n+                                            true,\n+                                            true,\n+                                            DUMMY_SP);\n+                                        type_module =\n+                                            child_name_bindings.\n+                                                get_module();\n+                                    }\n+                                }\n+\n+                                // Add each static method to the module.\n+                                let new_parent = type_module;\n+                                for method_info in methods.iter() {\n+                                    let name = method_info.name;\n+                                    debug!(\"(building reduced graph for \\\n+                                             external crate) creating \\\n+                                             static method '{}'\",\n+                                           token::get_name(name));\n+\n+                                    let method_name_bindings =\n+                                        self.add_child(name,\n+                                                       &new_parent,\n+                                                       OverwriteDuplicates,\n+                                                       DUMMY_SP);\n+                                    let def = DefFn(method_info.def_id, false);\n+\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if visibility == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n+                                    method_name_bindings.define_value(\n+                                        def, DUMMY_SP, modifiers);\n+                                }\n+                            }\n+\n+                            // Otherwise, do nothing.\n+                            Some(_) | None => {}\n+                        }\n+                    }\n+                }\n+            }\n+            DlField => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        ignoring field\");\n+            }\n+        }\n+    }\n+\n+    /// Builds the reduced graph rooted at the given external module.\n+    fn populate_external_module(&mut self, module: &Rc<Module>) {\n+        debug!(\"(populating external module) attempting to populate {}\",\n+               self.module_to_string(&**module));\n+\n+        let def_id = match module.def_id.get() {\n+            None => {\n+                debug!(\"(populating external module) ... no def ID!\");\n+                return\n+            }\n+            Some(def_id) => def_id,\n+        };\n+\n+        csearch::each_child_of_item(&self.session.cstore,\n+                                    def_id,\n+                                    |def_like, child_name, visibility| {\n+            debug!(\"(populating external module) ... found ident: {}\",\n+                   token::get_name(child_name));\n+            self.build_reduced_graph_for_external_crate_def(module,\n+                                                            def_like,\n+                                                            child_name,\n+                                                            visibility)\n+        });\n+        module.populated.set(true)\n+    }\n+\n+    /// Ensures that the reduced graph rooted at the given external module\n+    /// is built, building it if it is not.\n+    fn populate_module_if_necessary(&mut self, module: &Rc<Module>) {\n+        if !module.populated.get() {\n+            self.populate_external_module(module)\n+        }\n+        assert!(module.populated.get())\n+    }\n+\n+    /// Builds the reduced graph rooted at the 'use' directive for an external\n+    /// crate.\n+    fn build_reduced_graph_for_external_crate(&mut self, root: &Rc<Module>) {\n+        csearch::each_top_level_item_of_crate(&self.session.cstore,\n+                                              root.def_id\n+                                                  .get()\n+                                                  .unwrap()\n+                                                  .krate,\n+                                              |def_like, name, visibility| {\n+            self.build_reduced_graph_for_external_crate_def(root, def_like, name, visibility)\n+        });\n+    }\n+\n+    /// Creates and adds an import directive to the given module.\n+    fn build_import_directive(&mut self,\n+                              module_: &Module,\n+                              module_path: Vec<Name>,\n+                              subclass: ImportDirectiveSubclass,\n+                              span: Span,\n+                              id: NodeId,\n+                              is_public: bool,\n+                              shadowable: Shadowable) {\n+        module_.imports.borrow_mut().push(ImportDirective::new(module_path,\n+                                                               subclass,\n+                                                               span,\n+                                                               id,\n+                                                               is_public,\n+                                                               shadowable));\n+        self.unresolved_imports += 1;\n+        // Bump the reference count on the name. Or, if this is a glob, set\n+        // the appropriate flag.\n+\n+        match subclass {\n+            SingleImport(target, _) => {\n+                debug!(\"(building import directive) building import \\\n+                        directive: {}::{}\",\n+                       self.names_to_string(module_.imports.borrow().last().unwrap()\n+                                                 .module_path[]),\n+                       token::get_name(target));\n+\n+                let mut import_resolutions = module_.import_resolutions\n+                                                    .borrow_mut();\n+                match import_resolutions.get_mut(&target) {\n+                    Some(resolution) => {\n+                        debug!(\"(building import directive) bumping \\\n+                                reference\");\n+                        resolution.outstanding_references += 1;\n+\n+                        // the source of this name is different now\n+                        resolution.type_id = id;\n+                        resolution.value_id = id;\n+                        resolution.is_public = is_public;\n+                        return;\n+                    }\n+                    None => {}\n+                }\n+                debug!(\"(building import directive) creating new\");\n+                let mut resolution = ImportResolution::new(id, is_public);\n+                resolution.outstanding_references = 1;\n+                import_resolutions.insert(target, resolution);\n+            }\n+            GlobImport => {\n+                // Set the glob flag. This tells us that we don't know the\n+                // module's exports ahead of time.\n+\n+                module_.glob_count.set(module_.glob_count.get() + 1);\n+            }\n+        }\n+    }\n+}\n+\n+struct BuildReducedGraphVisitor<'a, 'b:'a, 'tcx:'b> {\n+    builder: GraphBuilder<'a, 'b, 'tcx>,\n+    parent: Rc<Module>\n+}\n+\n+impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n+        let p = self.builder.build_reduced_graph_for_item(item, &self.parent);\n+        let old_parent = replace(&mut self.parent, p);\n+        visit::walk_item(self, item);\n+        self.parent = old_parent;\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+        let parent = &self.parent;\n+        self.builder.build_reduced_graph_for_foreign_item(foreign_item,\n+                                                          parent,\n+                                                          |r| {\n+            let mut v = BuildReducedGraphVisitor {\n+                builder: GraphBuilder { resolver: r },\n+                parent: parent.clone()\n+            };\n+            visit::walk_foreign_item(&mut v, foreign_item);\n+        })\n+    }\n+\n+    fn visit_view_item(&mut self, view_item: &ViewItem) {\n+        self.builder.build_reduced_graph_for_view_item(view_item, &self.parent);\n+    }\n+\n+    fn visit_block(&mut self, block: &Block) {\n+        let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n+        let old_parent = replace(&mut self.parent, np);\n+        visit::walk_block(self, block);\n+        self.parent = old_parent;\n+    }\n+}\n+\n+pub fn build_reduced_graph(resolver: &mut Resolver, krate: &ast::Crate) {\n+    GraphBuilder {\n+        resolver: resolver\n+    }.build_reduced_graph(krate);\n+}\n+\n+pub fn populate_module_if_necessary(resolver: &mut Resolver, module: &Rc<Module>) {\n+    GraphBuilder {\n+        resolver: resolver\n+    }.populate_module_if_necessary(module);\n+}"}, {"sha": "e371046a9b21d34073d0dbfa6737ced88b9b707d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 1311, "changes": 1338, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -26,11 +26,9 @@ extern crate rustc;\n \n use self::PatternBindingMode::*;\n use self::Namespace::*;\n-use self::NamespaceError::*;\n use self::NamespaceResult::*;\n use self::NameDefinition::*;\n use self::ImportDirectiveSubclass::*;\n-use self::ReducedGraphParent::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n@@ -40,7 +38,6 @@ use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n-use self::DuplicateCheckingMode::*;\n use self::ParentLink::*;\n use self::ModuleKind::*;\n use self::TraitReferenceType::*;\n@@ -60,34 +57,31 @@ use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n-use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n+use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n-use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n+use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local, LOCAL_CRATE};\n-use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n+use syntax::ast::{MethodImplItem, Mod, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n-use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n-use syntax::ast::{PolyTraitRef, PrimTy, Public, SelfExplicit, SelfStatic};\n-use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n-use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n-use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n+use syntax::ast::{PatRange, PatStruct, Path};\n+use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n+use syntax::ast::{RegionTyParamBound, StructField};\n+use syntax::ast::{TraitRef, TraitTyParamBound};\n+use syntax::ast::{Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt, TyObjectSum};\n use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n-use syntax::ast::{TypeImplItem, UnnamedField};\n-use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n-use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ast::{Visibility};\n+use syntax::ast::{TypeImplItem};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{mod, PostExpansionMethod, local_def, walk_pat};\n+use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{mod, special_names, special_idents};\n-use syntax::codemap::{Span, DUMMY_SP, Pos};\n+use syntax::codemap::{Span, Pos};\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{mod, Visitor};\n \n@@ -100,6 +94,7 @@ use std::uint;\n \n mod check_unused;\n mod record_exports;\n+mod build_reduced_graph;\n \n #[deriving(Copy)]\n struct BindingInfo {\n@@ -123,14 +118,6 @@ enum Namespace {\n     ValueNS\n }\n \n-#[deriving(Copy, PartialEq)]\n-enum NamespaceError {\n-    NoError,\n-    ModuleError,\n-    TypeError,\n-    ValueError\n-}\n-\n /// A NamespaceResult represents the result of resolving an import in\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n@@ -197,22 +184,6 @@ enum ImportDirectiveSubclass {\n     GlobImport\n }\n \n-/// The context that we thread through while building the reduced graph.\n-#[deriving(Clone)]\n-enum ReducedGraphParent {\n-    ModuleReducedGraphParent(Rc<Module>)\n-}\n-\n-impl ReducedGraphParent {\n-    fn module(&self) -> Rc<Module> {\n-        match *self {\n-            ModuleReducedGraphParent(ref m) => {\n-                m.clone()\n-            }\n-        }\n-    }\n-}\n-\n type ErrorMessage = Option<(Span, String)>;\n \n enum ResolveResult<T> {\n@@ -314,17 +285,6 @@ enum BareIdentifierPatternResolution {\n     BareIdentifierPatternUnresolved\n }\n \n-// Specifies how duplicates should be handled when adding a child item if\n-// another item exists with the same name in some namespace.\n-#[deriving(Copy, PartialEq)]\n-enum DuplicateCheckingMode {\n-    ForbidDuplicateModules,\n-    ForbidDuplicateTypesAndModules,\n-    ForbidDuplicateValues,\n-    ForbidDuplicateTypesAndValues,\n-    OverwriteDuplicates\n-}\n-\n /// One local scope.\n #[deriving(Show)]\n struct Rib {\n@@ -865,15 +825,6 @@ impl PrimitiveTypeTable {\n     }\n }\n \n-\n-fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n-    match ns {\n-        NoError                 => \"\",\n-        ModuleError | TypeError => \"type or module\",\n-        ValueError              => \"value\",\n-    }\n-}\n-\n /// The main resolver class.\n struct Resolver<'a, 'tcx:'a> {\n     session: &'a Session,\n@@ -939,46 +890,6 @@ struct Resolver<'a, 'tcx:'a> {\n     used_crates: HashSet<CrateNum>,\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b:'a, 'tcx:'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n-    parent: ReducedGraphParent\n-}\n-\n-impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n-\n-    fn visit_item(&mut self, item: &Item) {\n-        let p = self.resolver.build_reduced_graph_for_item(item, self.parent.clone());\n-        let old_parent = replace(&mut self.parent, p);\n-        visit::walk_item(self, item);\n-        self.parent = old_parent;\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        let parent = self.parent.clone();\n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                           parent.clone(),\n-                                                           |r| {\n-            let mut v = BuildReducedGraphVisitor {\n-                resolver: r,\n-                parent: parent.clone()\n-            };\n-            visit::walk_foreign_item(&mut v, foreign_item);\n-        })\n-    }\n-\n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        self.resolver.build_reduced_graph_for_view_item(view_item, self.parent.clone());\n-    }\n-\n-    fn visit_block(&mut self, block: &Block) {\n-        let np = self.resolver.build_reduced_graph_for_block(block, self.parent.clone());\n-        let old_parent = replace(&mut self.parent, np);\n-        visit::walk_block(self, block);\n-        self.parent = old_parent;\n-    }\n-\n-}\n-\n #[deriving(PartialEq)]\n enum FallbackChecks {\n     Everything,\n@@ -1047,1191 +958,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    //\n-    // Reduced graph building\n-    //\n-    // Here we build the \"reduced graph\": the graph of the module tree without\n-    // any imports resolved.\n-    //\n-\n-    /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(&mut self, krate: &ast::Crate) {\n-        let parent = ModuleReducedGraphParent(self.graph_root.get_module());\n-        let mut visitor = BuildReducedGraphVisitor {\n-            resolver: self,\n-            parent: parent\n-        };\n-        visit::walk_crate(&mut visitor, krate);\n-    }\n-\n-    /// Adds a new child item to the module definition of the parent node and\n-    /// returns its corresponding name bindings as well as the current parent.\n-    /// Or, if we're inside a block, creates (or reuses) an anonymous module\n-    /// corresponding to the innermost block ID and returns the name bindings\n-    /// as well as the newly-created parent.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if this node does not have a module definition and we are not inside\n-    /// a block.\n-    fn add_child(&self,\n-                 name: Name,\n-                 reduced_graph_parent: ReducedGraphParent,\n-                 duplicate_checking_mode: DuplicateCheckingMode,\n-                 // For printing errors\n-                 sp: Span)\n-                 -> Rc<NameBindings> {\n-        // If this is the immediate descendant of a module, then we add the\n-        // child name directly. Otherwise, we create or reuse an anonymous\n-        // module and add the child to that.\n-\n-        let module_ = reduced_graph_parent.module();\n-\n-        self.check_for_conflicts_between_external_crates_and_items(&*module_,\n-                                                                   name,\n-                                                                   sp);\n-\n-        // Add or reuse the child.\n-        let child = module_.children.borrow().get(&name).cloned();\n-        match child {\n-            None => {\n-                let child = Rc::new(NameBindings::new());\n-                module_.children.borrow_mut().insert(name, child.clone());\n-                child\n-            }\n-            Some(child) => {\n-                // Enforce the duplicate checking mode:\n-                //\n-                // * If we're requesting duplicate module checking, check that\n-                //   there isn't a module in the module with the same name.\n-                //\n-                // * If we're requesting duplicate type checking, check that\n-                //   there isn't a type in the module with the same name.\n-                //\n-                // * If we're requesting duplicate value checking, check that\n-                //   there isn't a value in the module with the same name.\n-                //\n-                // * If we're requesting duplicate type checking and duplicate\n-                //   value checking, check that there isn't a duplicate type\n-                //   and a duplicate value with the same name.\n-                //\n-                // * If no duplicate checking was requested at all, do\n-                //   nothing.\n-\n-                let mut duplicate_type = NoError;\n-                let ns = match duplicate_checking_mode {\n-                    ForbidDuplicateModules => {\n-                        if child.get_module_if_available().is_some() {\n-                            duplicate_type = ModuleError;\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateTypesAndModules => {\n-                        match child.def_for_namespace(TypeNS) {\n-                            None => {}\n-                            Some(_) if child.get_module_if_available()\n-                                            .map(|m| m.kind.get()) ==\n-                                       Some(ImplModuleKind) => {}\n-                            Some(_) => duplicate_type = TypeError\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateValues => {\n-                        if child.defined_in_namespace(ValueNS) {\n-                            duplicate_type = ValueError;\n-                        }\n-                        Some(ValueNS)\n-                    }\n-                    ForbidDuplicateTypesAndValues => {\n-                        let mut n = None;\n-                        match child.def_for_namespace(TypeNS) {\n-                            Some(DefMod(_)) | None => {}\n-                            Some(_) => {\n-                                n = Some(TypeNS);\n-                                duplicate_type = TypeError;\n-                            }\n-                        };\n-                        if child.defined_in_namespace(ValueNS) {\n-                            duplicate_type = ValueError;\n-                            n = Some(ValueNS);\n-                        }\n-                        n\n-                    }\n-                    OverwriteDuplicates => None\n-                };\n-                if duplicate_type != NoError {\n-                    // Return an error here by looking up the namespace that\n-                    // had the duplicate.\n-                    let ns = ns.unwrap();\n-                    self.resolve_error(sp,\n-                        format!(\"duplicate definition of {} `{}`\",\n-                             namespace_error_to_string(duplicate_type),\n-                             token::get_name(name))[]);\n-                    {\n-                        let r = child.span_for_namespace(ns);\n-                        for sp in r.iter() {\n-                            self.session.span_note(*sp,\n-                                 format!(\"first definition of {} `{}` here\",\n-                                      namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name))[]);\n-                        }\n-                    }\n-                }\n-                child\n-            }\n-        }\n-    }\n-\n-    fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        // If the block has view items, we need an anonymous module.\n-        if block.view_items.len() > 0 {\n-            return true;\n-        }\n-\n-        // Check each statement.\n-        for statement in block.stmts.iter() {\n-            match statement.node {\n-                StmtDecl(ref declaration, _) => {\n-                    match declaration.node {\n-                        DeclItem(_) => {\n-                            return true;\n-                        }\n-                        _ => {\n-                            // Keep searching.\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // Keep searching.\n-                }\n-            }\n-        }\n-\n-        // If we found neither view items nor items, we don't need to create\n-        // an anonymous module.\n-\n-        return false;\n-    }\n-\n-    fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Name)\n-                       -> ParentLink {\n-        match parent {\n-            ModuleReducedGraphParent(module_) => {\n-                return ModuleParentLink(module_.downgrade(), name);\n-            }\n-        }\n-    }\n-\n-    /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self,\n-                                    item: &Item,\n-                                    parent: ReducedGraphParent)\n-                                    -> ReducedGraphParent\n-    {\n-        let name = item.ident.name;\n-        let sp = item.span;\n-        let is_public = item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n-\n-        match item.node {\n-            ItemMod(..) => {\n-                let name_bindings =\n-                    self.add_child(name, parent.clone(), ForbidDuplicateModules, sp);\n-\n-                let parent_link = self.get_parent_link(parent, name);\n-                let def_id = DefId { krate: 0, node: item.id };\n-                name_bindings.define_module(parent_link,\n-                                            Some(def_id),\n-                                            NormalModuleKind,\n-                                            false,\n-                                            item.vis == ast::Public,\n-                                            sp);\n-\n-                ModuleReducedGraphParent(name_bindings.get_module())\n-            }\n-\n-            ItemForeignMod(..) => parent,\n-\n-            // These items live in the value namespace.\n-            ItemStatic(_, m, _) => {\n-                let name_bindings =\n-                    self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n-                let mutbl = m == ast::MutMutable;\n-\n-                name_bindings.define_value\n-                    (DefStatic(local_def(item.id), mutbl), sp, modifiers);\n-                parent\n-            }\n-            ItemConst(_, _) => {\n-                self.add_child(name, parent.clone(), ForbidDuplicateValues, sp)\n-                    .define_value(DefConst(local_def(item.id)),\n-                                  sp, modifiers);\n-                parent\n-            }\n-            ItemFn(_, _, _, _, _) => {\n-                let name_bindings =\n-                    self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n-\n-                let def = DefFn(local_def(item.id), false);\n-                name_bindings.define_value(def, sp, modifiers);\n-                parent\n-            }\n-\n-            // These items live in the type namespace.\n-            ItemTy(..) => {\n-                let name_bindings =\n-                    self.add_child(name,\n-                                   parent.clone(),\n-                                   ForbidDuplicateTypesAndModules,\n-                                   sp);\n-\n-                name_bindings.define_type\n-                    (DefTy(local_def(item.id), false), sp, modifiers);\n-                parent\n-            }\n-\n-            ItemEnum(ref enum_definition, _) => {\n-                let name_bindings =\n-                    self.add_child(name,\n-                                   parent.clone(),\n-                                   ForbidDuplicateTypesAndModules,\n-                                   sp);\n-\n-                name_bindings.define_type\n-                    (DefTy(local_def(item.id), true), sp, modifiers);\n-\n-                let parent_link = self.get_parent_link(parent.clone(), name);\n-                // We want to make sure the module type is EnumModuleKind\n-                // even if there's already an ImplModuleKind module defined,\n-                // since that's how we prevent duplicate enum definitions\n-                name_bindings.set_module_kind(parent_link,\n-                                              Some(local_def(item.id)),\n-                                              EnumModuleKind,\n-                                              false,\n-                                              is_public,\n-                                              sp);\n-\n-                for variant in (*enum_definition).variants.iter() {\n-                    self.build_reduced_graph_for_variant(\n-                        &**variant,\n-                        local_def(item.id),\n-                        ModuleReducedGraphParent(name_bindings.get_module()));\n-                }\n-                parent\n-            }\n-\n-            // These items live in both the type and value namespaces.\n-            ItemStruct(ref struct_def, _) => {\n-                // Adding to both Type and Value namespaces or just Type?\n-                let (forbid, ctor_id) = match struct_def.ctor_id {\n-                    Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n-                    None            => (ForbidDuplicateTypesAndModules, None)\n-                };\n-\n-                let name_bindings = self.add_child(name, parent.clone(), forbid, sp);\n-\n-                // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n-\n-                // If this is a newtype or unit-like struct, define a name\n-                // in the value namespace as well\n-                match ctor_id {\n-                    Some(cid) => {\n-                        name_bindings.define_value(DefStruct(local_def(cid)),\n-                                                   sp, modifiers);\n-                    }\n-                    None => {}\n-                }\n-\n-                // Record the def ID and fields of this struct.\n-                let named_fields = struct_def.fields.iter().filter_map(|f| {\n-                    match f.node.kind {\n-                        NamedField(ident, _) => Some(ident.name),\n-                        UnnamedField(_) => None\n-                    }\n-                }).collect();\n-                self.structs.insert(local_def(item.id), named_fields);\n-\n-                parent\n-            }\n-\n-            ItemImpl(_, _, None, ref ty, ref impl_items) => {\n-                // If this implements an anonymous trait, then add all the\n-                // methods within to a new module, if the type was defined\n-                // within this module.\n-\n-                let mod_name = match ty.node {\n-                    TyPath(ref path, _) if path.segments.len() == 1 => {\n-                        // FIXME(18446) we should distinguish between the name of\n-                        // a trait and the name of an impl of that trait.\n-                        Some(path.segments.last().unwrap().identifier.name)\n-                    }\n-                    TyObjectSum(ref lhs_ty, _) => {\n-                        match lhs_ty.node {\n-                            TyPath(ref path, _) if path.segments.len() == 1 => {\n-                                Some(path.segments.last().unwrap().identifier.name)\n-                            }\n-                            _ => {\n-                                None\n-                            }\n-                        }\n-                    }\n-                    _ => {\n-                        None\n-                    }\n-                };\n-\n-                match mod_name {\n-                    None => {\n-                        self.resolve_error(ty.span,\n-                                           \"inherent implementations may \\\n-                                            only be implemented in the same \\\n-                                            module as the type they are \\\n-                                            implemented for\")\n-                    }\n-                    Some(mod_name) => {\n-                        // Create the module and add all methods.\n-                        let parent_opt = parent.module().children.borrow()\n-                            .get(&mod_name).cloned();\n-                        let new_parent = match parent_opt {\n-                            // It already exists\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                (child.get_module().kind.get() == ImplModuleKind ||\n-                                 child.get_module().kind.get() == TraitModuleKind) => {\n-                                    ModuleReducedGraphParent(child.get_module())\n-                                }\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                child.get_module().kind.get() ==\n-                                EnumModuleKind => {\n-                                    ModuleReducedGraphParent(child.get_module())\n-                                }\n-                            // Create the module\n-                            _ => {\n-                                let name_bindings =\n-                                    self.add_child(mod_name,\n-                                                   parent.clone(),\n-                                                   ForbidDuplicateModules,\n-                                                   sp);\n-\n-                                let parent_link =\n-                                    self.get_parent_link(parent.clone(), name);\n-                                let def_id = local_def(item.id);\n-                                let ns = TypeNS;\n-                                let is_public =\n-                                    !name_bindings.defined_in_namespace(ns) ||\n-                                    name_bindings.defined_in_public_namespace(ns);\n-\n-                                name_bindings.define_module(parent_link,\n-                                                            Some(def_id),\n-                                                            ImplModuleKind,\n-                                                            false,\n-                                                            is_public,\n-                                                            sp);\n-\n-                                ModuleReducedGraphParent(\n-                                    name_bindings.get_module())\n-                            }\n-                        };\n-\n-                        // For each implementation item...\n-                        for impl_item in impl_items.iter() {\n-                            match *impl_item {\n-                                MethodImplItem(ref method) => {\n-                                    // Add the method to the module.\n-                                    let name = method.pe_ident().name;\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       new_parent.clone(),\n-                                                       ForbidDuplicateValues,\n-                                                       method.span);\n-                                    let def = match method.pe_explicit_self()\n-                                        .node {\n-                                            SelfStatic => {\n-                                                // Static methods become\n-                                                // `DefStaticMethod`s.\n-                                                DefStaticMethod(local_def(method.id),\n-                                                                FromImpl(local_def(item.id)))\n-                                            }\n-                                            _ => {\n-                                                // Non-static methods become\n-                                                // `DefMethod`s.\n-                                                DefMethod(local_def(method.id),\n-                                                          None,\n-                                                          FromImpl(local_def(item.id)))\n-                                            }\n-                                        };\n-\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if method.pe_vis() == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def,\n-                                        method.span,\n-                                        modifiers);\n-                                }\n-                                TypeImplItem(ref typedef) => {\n-                                    // Add the typedef to the module.\n-                                    let name = typedef.ident.name;\n-                                    let typedef_name_bindings =\n-                                        self.add_child(\n-                                            name,\n-                                            new_parent.clone(),\n-                                            ForbidDuplicateTypesAndModules,\n-                                            typedef.span);\n-                                    let def = DefAssociatedTy(local_def(\n-                                        typedef.id));\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if typedef.vis == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    typedef_name_bindings.define_type(\n-                                        def,\n-                                        typedef.span,\n-                                        modifiers);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                parent\n-            }\n-\n-            ItemImpl(_, _, Some(_), _, _) => parent,\n-\n-            ItemTrait(_, _, _, ref items) => {\n-                let name_bindings =\n-                    self.add_child(name,\n-                                   parent.clone(),\n-                                   ForbidDuplicateTypesAndModules,\n-                                   sp);\n-\n-                // Add all the items within to a new module.\n-                let parent_link = self.get_parent_link(parent.clone(), name);\n-                name_bindings.define_module(parent_link,\n-                                            Some(local_def(item.id)),\n-                                            TraitModuleKind,\n-                                            false,\n-                                            item.vis == ast::Public,\n-                                            sp);\n-                let module_parent = ModuleReducedGraphParent(name_bindings.\n-                                                             get_module());\n-\n-                let def_id = local_def(item.id);\n-\n-                // Add the names of all the items to the trait info.\n-                for trait_item in items.iter() {\n-                    let (name, kind) = match *trait_item {\n-                        ast::RequiredMethod(_) |\n-                        ast::ProvidedMethod(_) => {\n-                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n-\n-                            let name = ty_m.ident.name;\n-\n-                            // Add it as a name in the trait module.\n-                            let (def, static_flag) = match ty_m.explicit_self\n-                                                               .node {\n-                                SelfStatic => {\n-                                    // Static methods become `DefStaticMethod`s.\n-                                    (DefStaticMethod(\n-                                            local_def(ty_m.id),\n-                                            FromTrait(local_def(item.id))),\n-                                     StaticMethodTraitItemKind)\n-                                }\n-                                _ => {\n-                                    // Non-static methods become `DefMethod`s.\n-                                    (DefMethod(local_def(ty_m.id),\n-                                               Some(local_def(item.id)),\n-                                               FromTrait(local_def(item.id))),\n-                                     NonstaticMethodTraitItemKind)\n-                                }\n-                            };\n-\n-                            let method_name_bindings =\n-                                self.add_child(name,\n-                                               module_parent.clone(),\n-                                               ForbidDuplicateTypesAndValues,\n-                                               ty_m.span);\n-                            // NB: not IMPORTABLE\n-                            method_name_bindings.define_value(def,\n-                                                              ty_m.span,\n-                                                              PUBLIC);\n-\n-                            (name, static_flag)\n-                        }\n-                        ast::TypeTraitItem(ref associated_type) => {\n-                            let def = DefAssociatedTy(local_def(\n-                                    associated_type.ty_param.id));\n-\n-                            let name_bindings =\n-                                self.add_child(associated_type.ty_param.ident.name,\n-                                               module_parent.clone(),\n-                                               ForbidDuplicateTypesAndValues,\n-                                               associated_type.ty_param.span);\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_type(def,\n-                                                      associated_type.ty_param.span,\n-                                                      PUBLIC);\n-\n-                            (associated_type.ty_param.ident.name, TypeTraitItemKind)\n-                        }\n-                    };\n-\n-                    self.trait_item_map.insert((name, def_id), kind);\n-                }\n-\n-                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n-                parent\n-            }\n-            ItemMac(..) => parent\n-        }\n-    }\n-\n-    // Constructs the reduced graph for one variant. Variants exist in the\n-    // type and value namespaces.\n-    fn build_reduced_graph_for_variant(&mut self,\n-                                       variant: &Variant,\n-                                       item_id: DefId,\n-                                       parent: ReducedGraphParent) {\n-        let name = variant.node.name.name;\n-        let is_exported = match variant.node.kind {\n-            TupleVariantKind(_) => false,\n-            StructVariantKind(_) => {\n-                // Not adding fields for variants as they are not accessed with a self receiver\n-                self.structs.insert(local_def(variant.node.id), Vec::new());\n-                true\n-            }\n-        };\n-\n-        let child = self.add_child(name, parent,\n-                                   ForbidDuplicateTypesAndValues,\n-                                   variant.span);\n-        // variants are always treated as importable to allow them to be glob\n-        // used\n-        child.define_value(DefVariant(item_id,\n-                                      local_def(variant.node.id), is_exported),\n-                           variant.span, PUBLIC | IMPORTABLE);\n-        child.define_type(DefVariant(item_id,\n-                                     local_def(variant.node.id), is_exported),\n-                          variant.span, PUBLIC | IMPORTABLE);\n-    }\n-\n-    /// Constructs the reduced graph for one 'view item'. View items consist\n-    /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem,\n-                                         parent: ReducedGraphParent) {\n-        match view_item.node {\n-            ViewItemUse(ref view_path) => {\n-                // Extract and intern the module part of the path. For\n-                // globs and lists, the path is found directly in the AST;\n-                // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n-                    ViewPathSimple(_, ref full_path, _) => {\n-                        full_path.segments\n-                            .init()\n-                            .iter().map(|ident| ident.identifier.name)\n-                            .collect()\n-                    }\n-\n-                    ViewPathGlob(ref module_ident_path, _) |\n-                    ViewPathList(ref module_ident_path, _, _) => {\n-                        module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier.name).collect()\n-                    }\n-                };\n-\n-                // Build up the import directives.\n-                let module_ = parent.module();\n-                let is_public = view_item.vis == ast::Public;\n-                let shadowable =\n-                    view_item.attrs\n-                             .iter()\n-                             .any(|attr| {\n-                                 attr.name() == token::get_name(\n-                                    special_idents::prelude_import.name)\n-                             });\n-                let shadowable = if shadowable {\n-                    Shadowable::Always\n-                } else {\n-                    Shadowable::Never\n-                };\n-\n-                match view_path.node {\n-                    ViewPathSimple(binding, ref full_path, id) => {\n-                        let source_name =\n-                            full_path.segments.last().unwrap().identifier.name;\n-                        if token::get_name(source_name).get() == \"mod\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`mod` imports are only allowed within a { } list\");\n-                        }\n-\n-                        let subclass = SingleImport(binding.name,\n-                                                    source_name);\n-                        self.build_import_directive(&*module_,\n-                                                    module_path,\n-                                                    subclass,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                    ViewPathList(_, ref source_items, _) => {\n-                        // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n-                            PathListMod { .. } => Some(item.span),\n-                            _ => None\n-                        }).collect::<Vec<Span>>();\n-                        if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`mod` import can only appear once in the list\");\n-                            for other_span in mod_spans.iter().skip(1) {\n-                                self.session.span_note(*other_span,\n-                                    \"another `mod` import appears here\");\n-                            }\n-                        }\n-\n-                        for source_item in source_items.iter() {\n-                            let (module_path, name) = match source_item.node {\n-                                PathListIdent { name, .. } =>\n-                                    (module_path.clone(), name.name),\n-                                PathListMod { .. } => {\n-                                    let name = match module_path.last() {\n-                                        Some(name) => *name,\n-                                        None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`mod` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n-                                            continue;\n-                                        }\n-                                    };\n-                                    let module_path = module_path.init();\n-                                    (module_path.to_vec(), name)\n-                                }\n-                            };\n-                            self.build_import_directive(\n-                                &*module_,\n-                                module_path,\n-                                SingleImport(name, name),\n-                                source_item.span,\n-                                source_item.node.id(),\n-                                is_public,\n-                                shadowable);\n-                        }\n-                    }\n-                    ViewPathGlob(_, id) => {\n-                        self.build_import_directive(&*module_,\n-                                                    module_path,\n-                                                    GlobImport,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                }\n-            }\n-\n-            ViewItemExternCrate(name, _, node_id) => {\n-                // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n-                    self.external_exports.insert(def_id);\n-                    let parent_link =\n-                        ModuleParentLink(parent.module().downgrade(), name.name);\n-                    let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n-                                                              false,\n-                                                              true));\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n-                    self.check_for_conflicts_between_external_crates(\n-                        &*parent.module(),\n-                        name.name,\n-                        view_item.span);\n-                    parent.module().external_module_children.borrow_mut()\n-                                   .insert(name.name, external_module.clone());\n-                    self.build_reduced_graph_for_external_crate(external_module);\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n-                                               foreign_item: &ForeignItem,\n-                                               parent: ReducedGraphParent,\n-                                               f: F) where\n-        F: FnOnce(&mut Resolver),\n-    {\n-        let name = foreign_item.ident.name;\n-        let is_public = foreign_item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n-        let name_bindings =\n-            self.add_child(name, parent, ForbidDuplicateValues,\n-                           foreign_item.span);\n-\n-        match foreign_item.node {\n-            ForeignItemFn(_, ref generics) => {\n-                let def = DefFn(local_def(foreign_item.id), false);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                self.with_type_parameter_rib(\n-                    HasTypeParameters(generics,\n-                                      FnSpace,\n-                                      foreign_item.id,\n-                                      NormalRibKind),\n-                    f);\n-            }\n-            ForeignItemStatic(_, m) => {\n-                let def = DefStatic(local_def(foreign_item.id), m);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                f(self)\n-            }\n-        }\n-    }\n-\n-    fn build_reduced_graph_for_block(&mut self,\n-                                         block: &Block,\n-                                         parent: ReducedGraphParent)\n-                                            -> ReducedGraphParent\n-    {\n-        if self.block_needs_anonymous_module(block) {\n-            let block_id = block.id;\n-\n-            debug!(\"(building reduced graph for block) creating a new \\\n-                    anonymous module for block {}\",\n-                   block_id);\n-\n-            let parent_module = parent.module();\n-            let new_module = Rc::new(Module::new(\n-                BlockParentLink(parent_module.downgrade(), block_id),\n-                None,\n-                AnonymousModuleKind,\n-                false,\n-                false));\n-            parent_module.anonymous_children.borrow_mut()\n-                         .insert(block_id, new_module.clone());\n-            ModuleReducedGraphParent(new_module)\n-        } else {\n-            parent\n-        }\n-    }\n-\n-    fn handle_external_def(&mut self,\n-                           def: Def,\n-                           vis: Visibility,\n-                           child_name_bindings: &NameBindings,\n-                           final_ident: &str,\n-                           name: Name,\n-                           new_parent: ReducedGraphParent) {\n-        debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {}\",\n-               vis);\n-        let is_public = vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n-        let is_exported = is_public && match new_parent {\n-            ModuleReducedGraphParent(ref module) => {\n-                match module.def_id.get() {\n-                    None => true,\n-                    Some(did) => self.external_exports.contains(&did)\n-                }\n-            }\n-        };\n-        if is_exported {\n-            self.external_exports.insert(def.def_id());\n-        }\n-\n-        let kind = match def {\n-            DefTy(_, true) => EnumModuleKind,\n-            DefStruct(..) | DefTy(..) => ImplModuleKind,\n-            _ => NormalModuleKind\n-        };\n-\n-        match def {\n-          DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n-          DefTy(def_id, _) => {\n-            let type_def = child_name_bindings.type_def.borrow().clone();\n-            match type_def {\n-              Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n-                debug!(\"(building reduced graph for external crate) \\\n-                        already created module\");\n-                module_def.def_id.set(Some(def_id));\n-              }\n-              Some(_) | None => {\n-                debug!(\"(building reduced graph for \\\n-                        external crate) building module \\\n-                        {}\", final_ident);\n-                let parent_link = self.get_parent_link(new_parent.clone(), name);\n-\n-                child_name_bindings.define_module(parent_link,\n-                                                  Some(def_id),\n-                                                  kind,\n-                                                  true,\n-                                                  is_public,\n-                                                  DUMMY_SP);\n-              }\n-            }\n-          }\n-          _ => {}\n-        }\n-\n-        match def {\n-          DefMod(_) | DefForeignMod(_) => {}\n-          DefVariant(_, variant_id, is_struct) => {\n-              debug!(\"(building reduced graph for external crate) building \\\n-                      variant {}\",\n-                      final_ident);\n-              // variants are always treated as importable to allow them to be\n-              // glob used\n-              let modifiers = PUBLIC | IMPORTABLE;\n-              if is_struct {\n-                  child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-                  // Not adding fields for variants as they are not accessed with a self receiver\n-                  self.structs.insert(variant_id, Vec::new());\n-              } else {\n-                  child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-              }\n-          }\n-          DefFn(ctor_id, true) => {\n-            child_name_bindings.define_value(\n-                csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n-                    .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n-          }\n-          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building value (fn/static) {}\", final_ident);\n-            // impl methods have already been defined with the correct importability modifier\n-            let mut modifiers = match *child_name_bindings.value_def.borrow() {\n-                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n-                None => modifiers\n-            };\n-            if new_parent.module().kind.get() != NormalModuleKind {\n-                modifiers = modifiers & !IMPORTABLE;\n-            }\n-            child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-          }\n-          DefTrait(def_id) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type {}\", final_ident);\n-\n-              // If this is a trait, add all the trait item names to the trait\n-              // info.\n-\n-              let trait_item_def_ids =\n-                csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n-              for trait_item_def_id in trait_item_def_ids.iter() {\n-                  let (trait_item_name, trait_item_kind) =\n-                      csearch::get_trait_item_name_and_kind(\n-                          &self.session.cstore,\n-                          trait_item_def_id.def_id());\n-\n-                  debug!(\"(building reduced graph for external crate) ... \\\n-                          adding trait item '{}'\",\n-                         token::get_name(trait_item_name));\n-\n-                  self.trait_item_map.insert((trait_item_name, def_id), trait_item_kind);\n-\n-                  if is_exported {\n-                      self.external_exports\n-                          .insert(trait_item_def_id.def_id());\n-                  }\n-              }\n-\n-              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-\n-              // Define a module if necessary.\n-              let parent_link = self.get_parent_link(new_parent, name);\n-              child_name_bindings.set_module_kind(parent_link,\n-                                                  Some(def_id),\n-                                                  TraitModuleKind,\n-                                                  true,\n-                                                  is_public,\n-                                                  DUMMY_SP)\n-          }\n-          DefTy(..) | DefAssociatedTy(..) | DefAssociatedPath(..) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type {}\", final_ident);\n-\n-              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-          }\n-          DefStruct(def_id) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building type and value for {}\",\n-                   final_ident);\n-            child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-            let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n-                f.name\n-            }).collect::<Vec<_>>();\n-\n-            if fields.len() == 0 {\n-                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-            }\n-\n-            // Record the def ID and fields of this struct.\n-            self.structs.insert(def_id, fields);\n-          }\n-          DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n-          DefUse(..) | DefUpvar(..) | DefRegion(..) |\n-          DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n-            panic!(\"didn't expect `{}`\", def);\n-          }\n-        }\n-    }\n-\n-    /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self,\n-                                                  root: Rc<Module>,\n-                                                  def_like: DefLike,\n-                                                  name: Name,\n-                                                  visibility: Visibility) {\n-        match def_like {\n-            DlDef(def) => {\n-                // Add the new child item, if necessary.\n-                match def {\n-                    DefForeignMod(def_id) => {\n-                        // Foreign modules have no names. Recur and populate\n-                        // eagerly.\n-                        csearch::each_child_of_item(&self.session.cstore,\n-                                                    def_id,\n-                                                    |def_like,\n-                                                     child_name,\n-                                                     vis| {\n-                            self.build_reduced_graph_for_external_crate_def(\n-                                root.clone(),\n-                                def_like,\n-                                child_name,\n-                                vis)\n-                        });\n-                    }\n-                    _ => {\n-                        let child_name_bindings =\n-                            self.add_child(name,\n-                                           ModuleReducedGraphParent(root.clone()),\n-                                           OverwriteDuplicates,\n-                                           DUMMY_SP);\n-\n-                        self.handle_external_def(def,\n-                                                 visibility,\n-                                                 &*child_name_bindings,\n-                                                 token::get_name(name).get(),\n-                                                 name,\n-                                                 ModuleReducedGraphParent(root));\n-                    }\n-                }\n-            }\n-            DlImpl(def) => {\n-                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n-                    None => {}\n-                    Some(final_name) => {\n-                        let methods_opt =\n-                            csearch::get_methods_if_impl(&self.session.cstore, def);\n-                        match methods_opt {\n-                            Some(ref methods) if\n-                                methods.len() >= 1 => {\n-                                debug!(\"(building reduced graph for \\\n-                                        external crate) processing \\\n-                                        static methods for type name {}\",\n-                                        token::get_name(final_name));\n-\n-                                let child_name_bindings =\n-                                    self.add_child(\n-                                        final_name,\n-                                        ModuleReducedGraphParent(root.clone()),\n-                                        OverwriteDuplicates,\n-                                        DUMMY_SP);\n-\n-                                // Process the static methods. First,\n-                                // create the module.\n-                                let type_module;\n-                                let type_def = child_name_bindings.type_def.borrow().clone();\n-                                match type_def {\n-                                    Some(TypeNsDef {\n-                                        module_def: Some(module_def),\n-                                        ..\n-                                    }) => {\n-                                        // We already have a module. This\n-                                        // is OK.\n-                                        type_module = module_def;\n-\n-                                        // Mark it as an impl module if\n-                                        // necessary.\n-                                        type_module.kind.set(ImplModuleKind);\n-                                    }\n-                                    Some(_) | None => {\n-                                        let parent_link =\n-                                            self.get_parent_link(ModuleReducedGraphParent(root),\n-                                                                 final_name);\n-                                        child_name_bindings.define_module(\n-                                            parent_link,\n-                                            Some(def),\n-                                            ImplModuleKind,\n-                                            true,\n-                                            true,\n-                                            DUMMY_SP);\n-                                        type_module =\n-                                            child_name_bindings.\n-                                                get_module();\n-                                    }\n-                                }\n-\n-                                // Add each static method to the module.\n-                                let new_parent =\n-                                    ModuleReducedGraphParent(type_module);\n-                                for method_info in methods.iter() {\n-                                    let name = method_info.name;\n-                                    debug!(\"(building reduced graph for \\\n-                                             external crate) creating \\\n-                                             static method '{}'\",\n-                                           token::get_name(name));\n-\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       new_parent.clone(),\n-                                                       OverwriteDuplicates,\n-                                                       DUMMY_SP);\n-                                    let def = DefFn(method_info.def_id, false);\n-\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if visibility == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def, DUMMY_SP, modifiers);\n-                                }\n-                            }\n-\n-                            // Otherwise, do nothing.\n-                            Some(_) | None => {}\n-                        }\n-                    }\n-                }\n-            }\n-            DlField => {\n-                debug!(\"(building reduced graph for external crate) \\\n-                        ignoring field\");\n-            }\n-        }\n-    }\n-\n-    /// Builds the reduced graph rooted at the given external module.\n-    fn populate_external_module(&mut self, module: Rc<Module>) {\n-        debug!(\"(populating external module) attempting to populate {}\",\n-               self.module_to_string(&*module));\n-\n-        let def_id = match module.def_id.get() {\n-            None => {\n-                debug!(\"(populating external module) ... no def ID!\");\n-                return\n-            }\n-            Some(def_id) => def_id,\n-        };\n-\n-        csearch::each_child_of_item(&self.session.cstore,\n-                                    def_id,\n-                                    |def_like, child_name, visibility| {\n-            debug!(\"(populating external module) ... found ident: {}\",\n-                   token::get_name(child_name));\n-            self.build_reduced_graph_for_external_crate_def(module.clone(),\n-                                                            def_like,\n-                                                            child_name,\n-                                                            visibility)\n-        });\n-        module.populated.set(true)\n-    }\n-\n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    fn populate_module_if_necessary(&mut self, module: &Rc<Module>) {\n-        if !module.populated.get() {\n-            self.populate_external_module(module.clone())\n-        }\n-        assert!(module.populated.get())\n-    }\n-\n-    /// Builds the reduced graph rooted at the 'use' directive for an external\n-    /// crate.\n-    fn build_reduced_graph_for_external_crate(&mut self, root: Rc<Module>) {\n-        csearch::each_top_level_item_of_crate(&self.session.cstore,\n-                                              root.def_id\n-                                                  .get()\n-                                                  .unwrap()\n-                                                  .krate,\n-                                              |def_like, name, visibility| {\n-            self.build_reduced_graph_for_external_crate_def(root.clone(),\n-                                                            def_like,\n-                                                            name,\n-                                                            visibility)\n-        });\n-    }\n-\n-    /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(&mut self,\n-                              module_: &Module,\n-                              module_path: Vec<Name>,\n-                              subclass: ImportDirectiveSubclass,\n-                              span: Span,\n-                              id: NodeId,\n-                              is_public: bool,\n-                              shadowable: Shadowable) {\n-        module_.imports.borrow_mut().push(ImportDirective::new(module_path,\n-                                                               subclass,\n-                                                               span,\n-                                                               id,\n-                                                               is_public,\n-                                                               shadowable));\n-        self.unresolved_imports += 1;\n-        // Bump the reference count on the name. Or, if this is a glob, set\n-        // the appropriate flag.\n-\n-        match subclass {\n-            SingleImport(target, _) => {\n-                debug!(\"(building import directive) building import \\\n-                        directive: {}::{}\",\n-                       self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path[]),\n-                       token::get_name(target));\n-\n-                let mut import_resolutions = module_.import_resolutions\n-                                                    .borrow_mut();\n-                match import_resolutions.get_mut(&target) {\n-                    Some(resolution) => {\n-                        debug!(\"(building import directive) bumping \\\n-                                reference\");\n-                        resolution.outstanding_references += 1;\n-\n-                        // the source of this name is different now\n-                        resolution.type_id = id;\n-                        resolution.value_id = id;\n-                        resolution.is_public = is_public;\n-                        return;\n-                    }\n-                    None => {}\n-                }\n-                debug!(\"(building import directive) creating new\");\n-                let mut resolution = ImportResolution::new(id, is_public);\n-                resolution.outstanding_references = 1;\n-                import_resolutions.insert(target, resolution);\n-            }\n-            GlobImport => {\n-                // Set the glob flag. This tells us that we don't know the\n-                // module's exports ahead of time.\n-\n-                module_.glob_count.set(module_.glob_count.get() + 1);\n-            }\n-        }\n-    }\n-\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts\n@@ -2276,7 +1002,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.resolve_imports_for_module(module_.clone());\n         self.current_module = orig_module;\n \n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n         for (_, child_node) in module_.children.borrow().iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n@@ -2542,7 +1268,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut type_result = UnknownResult;\n \n         // Search for direct children of the containing module.\n-        self.populate_module_if_necessary(&containing_module);\n+        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n         match containing_module.children.borrow().get(&source) {\n             None => {\n@@ -2902,7 +1628,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add all children from the containing module.\n-        self.populate_module_if_necessary(&containing_module);\n+        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n         for (&name, name_bindings) in containing_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n@@ -3422,7 +2148,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n@@ -3687,7 +2413,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                self.module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n@@ -3783,7 +2509,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into children and anonymous children.\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         for (_, child_node) in module_.children.borrow().iter() {\n             match child_node.get_module_if_available() {\n@@ -3830,7 +2556,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // Nothing to do.\n             }\n             Some(name) => {\n-                self.populate_module_if_necessary(&orig_module);\n+                build_reduced_graph::populate_module_if_necessary(self, &orig_module);\n \n                 match orig_module.children.borrow().get(&name) {\n                     None => {\n@@ -4828,9 +3554,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n                                         type {}\",\n-                                       token::get_ident(path.segments\n-                                                            .last().unwrap()\n-                                                            .identifier),\n+                                       token::get_ident(path.segments.last().unwrap() .identifier),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -5021,19 +3745,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                     token::get_ident(\n-                                        path.segments\n-                                            .last()\n-                                            .unwrap()\n-                                            .identifier))[]);\n+                                        path.segments.last().unwrap().identifier))[]);\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n                                 format!(\"unresolved enum variant, struct or const `{}`\",\n                                     token::get_ident(\n-                                        path.segments\n-                                            .last()\n-                                            .unwrap()\n-                                            .identifier))[]);\n+                                        path.segments.last().unwrap().identifier))[]);\n                         }\n                     }\n \n@@ -5187,9 +3905,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Try to find a path to an item in a module.\n         let unqualified_def =\n-                self.resolve_identifier(path.segments\n-                                            .last().unwrap()\n-                                            .identifier,\n+                self.resolve_identifier(path.segments.last().unwrap().identifier,\n                                         namespace,\n                                         check_ribs,\n                                         path.span);\n@@ -5243,7 +3959,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             namespace: Namespace)\n                                             -> NameDefinition {\n         // First, search children.\n-        self.populate_module_if_necessary(&containing_module);\n+        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n         match containing_module.children.borrow().get(&name) {\n             Some(child_name_bindings) => {\n@@ -5931,7 +4647,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Look for trait children.\n-            self.populate_module_if_necessary(&search_module);\n+            build_reduced_graph::populate_module_if_necessary(self, &search_module);\n \n             {\n                 for (_, child_names) in search_module.children.borrow().iter() {\n@@ -6059,7 +4775,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"Dump of module `{}`:\", self.module_to_string(&*module_));\n \n         debug!(\"Children:\");\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n         for (&name, _) in module_.children.borrow().iter() {\n             debug!(\"* {}\", token::get_name(name));\n         }\n@@ -6116,7 +4832,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                                -> CrateMap {\n     let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n \n-    resolver.build_reduced_graph(krate);\n+    build_reduced_graph::build_reduced_graph(&mut resolver, krate);\n     session.abort_if_errors();\n \n     resolver.resolve_imports();"}, {"sha": "9c2437c376ddd20592d3c8ab1e83ab7297900487", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -21,6 +21,8 @@\n use {Module, NameBindings, Resolver};\n use Namespace::{mod, TypeNS, ValueNS};\n \n+use build_reduced_graph;\n+\n use rustc::middle::def::Export;\n use syntax::ast;\n use syntax::parse::token;\n@@ -73,7 +75,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n \n         self.record_exports_for_module(&*module_);\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n \n         for (_, child_name_bindings) in module_.children.borrow().iter() {\n             match child_name_bindings.get_module_if_available() {"}, {"sha": "c6e4ce9457b533ba764480a276163ee6bfbf5bb9", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -606,9 +606,9 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: ValueRef)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = Vec::from_fn(adt::num_args(repr, disr_val), |i| {\n+    let args = range(0, adt::num_args(repr, disr_val)).map(|i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n-    });\n+    }).collect();\n \n     ExtractedBlock { vals: args, bcx: bcx }\n }"}, {"sha": "fb4ae21478bc271258717a5811bc1cc2b4065d6f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -55,7 +55,7 @@ use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n-use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_uint, C_undef};\n+use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n use trans::common::{NodeInfo, Result};\n use trans::common::{node_id_type, return_type_is_void};\n@@ -73,7 +73,7 @@ use trans::glue;\n use trans::inline;\n use trans::intrinsic;\n use trans::machine;\n-use trans::machine::{llsize_of, llsize_of_real, llalign_of_min};\n+use trans::machine::{llsize_of, llsize_of_real};\n use trans::meth;\n use trans::monomorphize;\n use trans::tvec;\n@@ -396,30 +396,6 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>)\n-                                       -> Result<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n-    let ccx = bcx.ccx();\n-\n-    // Grab the TypeRef type of ptr_ty.\n-    let ptr_ty = ty::mk_uniq(bcx.tcx(), t);\n-    let ptr_llty = type_of(ccx, ptr_ty);\n-\n-    let llty = type_of(bcx.ccx(), t);\n-    let size = llsize_of(bcx.ccx(), llty);\n-    let llalign = C_uint(ccx, llalign_of_min(bcx.ccx(), llty));\n-\n-    // Allocate space and store the destructor pointer:\n-    let Result {bcx, val: llbox} = malloc_raw_dyn(bcx, ptr_llty, t, size, llalign);\n-    let dtor_ptr = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_DROP_GLUE]);\n-    let drop_glue_field_ty = type_of(ccx, ty::mk_nil_ptr(bcx.tcx()));\n-    let drop_glue = PointerCast(bcx, glue::get_drop_glue(ccx, ty::mk_uniq(bcx.tcx(), t)),\n-                                drop_glue_field_ty);\n-    Store(bcx, drop_glue, dtor_ptr);\n-\n-    Result::new(bcx, llbox)\n-}\n-\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2676,6 +2652,8 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n+            debuginfo::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n+\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,"}, {"sha": "fffdc9c97ab97e41fa73be0b562b865664efe755", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -23,6 +23,7 @@ use trans::context::CrateContext;\n use trans::type_::Type;\n \n use std::cmp;\n+use std::iter::repeat;\n \n #[deriving(Clone, Copy, PartialEq)]\n enum RegClass {\n@@ -286,7 +287,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = Vec::from_elem(words, NoClass);\n+    let mut cls: Vec<_> = repeat(NoClass).take(words).collect();\n     if words > 4 {\n         all_mem(cls.as_mut_slice());\n         return cls;"}, {"sha": "3723ad07a36ec89d3288285f17a44bcd12fd2d60", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -137,26 +137,6 @@ fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n     ty::mk_tup(tcx, vec!(tcx.types.uint, ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n-fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             store: ty::TraitStore,\n-                             cdata_ty: Ty<'tcx>)\n-                             -> Result<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::allocate_cbox\");\n-    let tcx = bcx.tcx();\n-\n-    // Allocate and initialize the box:\n-    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    match store {\n-        ty::UniqTraitStore => {\n-            malloc_raw_dyn_proc(bcx, cbox_ty)\n-        }\n-        ty::RegionTraitStore(..) => {\n-            let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n-            Result::new(bcx, llbox)\n-        }\n-    }\n-}\n-\n pub struct ClosureResult<'blk, 'tcx: 'blk> {\n     llbox: ValueRef,        // llvalue of ptr to closure\n     cdata_ty: Ty<'tcx>,     // type of the closure data\n@@ -168,8 +148,7 @@ pub struct ClosureResult<'blk, 'tcx: 'blk> {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     bound_values: Vec<EnvValue<'tcx>> ,\n-                                     store: ty::TraitStore)\n+                                     bound_values: Vec<EnvValue<'tcx>>)\n                                      -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n@@ -193,7 +172,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     // allocate closure in the heap\n-    let Result {bcx, val: llbox} = allocate_cbox(bcx, store, cdata_ty);\n+    let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n \n     let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n     debug!(\"tuplify_box_ty = {}\", ty_to_string(tcx, cbox_ty));\n@@ -227,8 +206,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // collects the upvars and packages them up for store_environment.\n fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n                              freevar_mode: ast::CaptureClause,\n-                             freevars: &Vec<ty::Freevar>,\n-                             store: ty::TraitStore)\n+                             freevars: &Vec<ty::Freevar>)\n                              -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n \n@@ -242,7 +220,7 @@ fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n         env_vals.push(EnvValue {action: freevar_mode, datum: datum});\n     }\n \n-    store_environment(bcx, env_vals, store)\n+    store_environment(bcx, env_vals)\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -456,7 +434,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         llbox,\n         cdata_ty,\n         bcx\n-    } = build_closure(bcx, freevar_mode, &freevars, store);\n+    } = build_closure(bcx, freevar_mode, &freevars);\n \n     trans_closure(ccx,\n                   decl,"}, {"sha": "1f01da8a124b3c7309e82460b2012c7964d19fdf", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -25,6 +25,7 @@ use middle::ty::{mod, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n+use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -608,7 +609,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, &**elem).0);\n+            let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs[], false)\n             } else {"}, {"sha": "589250430cd71b778028d331f3b2a123745837cc", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 88, "deletions": 9, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -213,7 +213,7 @@ use std::ptr;\n use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n-use syntax::{ast, codemap, ast_util, ast_map};\n+use syntax::{ast, codemap, ast_util, ast_map, attr};\n use syntax::ast_util::PostExpansionMethod;\n use syntax::parse::token::{mod, special_idents};\n \n@@ -741,7 +741,16 @@ pub fn finalize(cx: &CrateContext) {\n     }\n \n     debug!(\"finalize\");\n-    compile_unit_metadata(cx);\n+    let _ = compile_unit_metadata(cx);\n+\n+    if needs_gdb_debug_scripts_section(cx) {\n+        // Add a .debug_gdb_scripts section to this compile-unit. This will\n+        // cause GDB to try and load the gdb_load_rust_pretty_printers.py file,\n+        // which activates the Rust pretty printers for binary this section is\n+        // contained in.\n+        get_or_insert_gdb_debug_scripts_section_global(cx);\n+    }\n+\n     unsafe {\n         llvm::LLVMDIBuilderFinalize(DIB(cx));\n         llvm::LLVMDIBuilderDispose(DIB(cx));\n@@ -1586,7 +1595,7 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-fn compile_unit_metadata(cx: &CrateContext) {\n+fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n     let work_dir = &cx.sess().working_dir;\n     let compile_unit_name = match cx.sess().local_crate_source_file {\n         None => fallback_path(cx),\n@@ -1621,7 +1630,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    work_dir.as_vec().with_c_str(|work_dir| {\n+    return work_dir.as_vec().with_c_str(|work_dir| {\n         producer.with_c_str(|producer| {\n             \"\".with_c_str(|flags| {\n                 \"\".with_c_str(|split_name| {\n@@ -1635,7 +1644,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                             cx.sess().opts.optimize != config::No,\n                             flags,\n                             0,\n-                            split_name);\n+                            split_name)\n                     }\n                 })\n             })\n@@ -3396,10 +3405,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx,\n-                                                          loc.file\n-                                                             .name\n-                                                             []);\n+                        let file_metadata = file_metadata(cx, loc.file.name[]);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -4112,3 +4118,76 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n         }\n     })\n }\n+\n+\n+//=-----------------------------------------------------------------------------\n+// .debug_gdb_scripts binary section\n+//=-----------------------------------------------------------------------------\n+\n+/// Inserts a side-effect free instruction sequence that makes sure that the\n+/// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n+    if needs_gdb_debug_scripts_section(ccx) {\n+        let empty = b\"\".to_c_str();\n+        let gdb_debug_scripts_section_global =\n+            get_or_insert_gdb_debug_scripts_section_global(ccx);\n+        unsafe {\n+            let volative_load_instruction =\n+                llvm::LLVMBuildLoad(ccx.raw_builder(),\n+                                    gdb_debug_scripts_section_global,\n+                                    empty.as_ptr());\n+            llvm::LLVMSetVolatile(volative_load_instruction, llvm::True);\n+        }\n+    }\n+}\n+\n+/// Allocates the global variable responsible for the .debug_gdb_scripts binary\n+/// section.\n+fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n+                                                  -> llvm::ValueRef {\n+    let section_var_name = b\"__rustc_debug_gdb_scripts_section__\".to_c_str();\n+\n+    let section_var = unsafe {\n+        llvm::LLVMGetNamedGlobal(ccx.llmod(), section_var_name.as_ptr())\n+    };\n+\n+    if section_var == ptr::null_mut() {\n+        let section_name = b\".debug_gdb_scripts\".to_c_str();\n+        let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n+\n+        unsafe {\n+            let llvm_type = Type::array(&Type::i8(ccx),\n+                                        section_contents.len() as u64);\n+            let section_var = llvm::LLVMAddGlobal(ccx.llmod(),\n+                                                  llvm_type.to_ref(),\n+                                                  section_var_name.as_ptr());\n+            llvm::LLVMSetSection(section_var, section_name.as_ptr());\n+            llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n+            llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n+            llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n+            llvm::SetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n+            // This should make sure that the whole section is not larger than\n+            // the string it contains. Otherwise we get a warning from GDB.\n+            llvm::LLVMSetAlignment(section_var, 1);\n+            section_var\n+        }\n+    } else {\n+        section_var\n+    }\n+}\n+\n+fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n+    let omit_gdb_pretty_printer_section =\n+        attr::contains_name(ccx.tcx()\n+                               .map\n+                               .krate()\n+                               .attrs\n+                               .as_slice(),\n+                            \"omit_gdb_pretty_printer_section\");\n+\n+    !omit_gdb_pretty_printer_section &&\n+    !ccx.sess().target.target.options.is_like_osx &&\n+    !ccx.sess().target.target.options.is_like_windows &&\n+    ccx.sess().opts.debuginfo != NoDebugInfo\n+}\n+"}, {"sha": "7587adae5b7ef68b3a30908c8c9e9fc834ba6d9a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -68,6 +68,7 @@ use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::rc::Rc;\n+use std::iter::repeat;\n \n // Destinations\n \n@@ -1413,7 +1414,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n-        let mut need_base = Vec::from_elem(field_tys.len(), true);\n+        let mut need_base: Vec<_> = repeat(true).take(field_tys.len()).collect();\n \n         let numbered_fields = fields.iter().map(|field| {\n             let opt_pos ="}, {"sha": "2cc40a617950843affa2364d296169b9e6039195", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -22,6 +22,7 @@ use syntax::ast;\n use std::c_str::ToCStr;\n use std::mem;\n use std::cell::RefCell;\n+use std::iter::repeat;\n \n use libc::c_uint;\n \n@@ -282,7 +283,7 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts = Vec::from_elem(n_elts, Type { rf: 0 as TypeRef });\n+            let mut elts: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_elts).collect();\n             llvm::LLVMGetStructElementTypes(self.to_ref(),\n                                             elts.as_mut_ptr() as *mut TypeRef);\n             elts\n@@ -296,7 +297,7 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let mut args = Vec::from_elem(n_args, Type { rf: 0 as TypeRef });\n+            let mut args: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_args).collect();\n             llvm::LLVMGetParamTypes(self.to_ref(),\n                                     args.as_mut_ptr() as *mut TypeRef);\n             args"}, {"sha": "dee9aafd06d7bfc561420daf53b0eee36aa61c59", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -62,7 +62,7 @@ use util::nodemap::DefIdMap;\n use util::ppaux::{mod, Repr, UserString};\n \n use std::rc::Rc;\n-use std::iter::AdditiveIterator;\n+use std::iter::{repeat, AdditiveIterator};\n use syntax::{abi, ast, ast_util};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -317,8 +317,8 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n-            Err(_) => Vec::from_fn(expected_num_region_params,\n-                                   |_| ty::ReStatic) // hokey\n+            Err(_) => range(0, expected_num_region_params)\n+                          .map(|_| ty::ReStatic).collect() // hokey\n         }\n     };\n \n@@ -500,7 +500,7 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                             .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n                             .collect::<Vec<Ty<'tcx>>>();\n \n-    let input_params = Vec::from_elem(inputs.len(), String::new());\n+    let input_params: Vec<_> = repeat(String::new()).take(inputs.len()).collect();\n     let (implied_output_region,\n          params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n \n@@ -734,8 +734,8 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         path.segments.iter().all(|s| s.parameters.is_empty());\n \n     let substs = if needs_defaults {\n-        let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n-                                       |_| this.ty_infer(path.span));\n+        let type_params: Vec<_> = range(0, generics.types.len(TypeSpace))\n+                                      .map(|_| this.ty_infer(path.span)).collect();\n         let region_params =\n             rscope.anon_regions(path.span, generics.regions.len(TypeSpace))\n                   .unwrap();\n@@ -1528,21 +1528,18 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n     let mut projection_bounds = Vec::new();\n-    let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n-        Some(trait_bound) => {\n-            let ptr = instantiate_poly_trait_ref(this,\n-                                                 rscope,\n-                                                 trait_bound,\n-                                                 None,\n-                                                 &mut projection_bounds);\n-            Some(ptr)\n-        }\n-        None => {\n-            this.tcx().sess.span_err(\n-                span,\n-                \"at least one non-builtin trait is required for an object type\");\n-            None\n-        }\n+    let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n+        let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n+        Some(instantiate_poly_trait_ref(this,\n+                                        rscope,\n+                                        trait_bound,\n+                                        None,\n+                                        &mut projection_bounds))\n+    } else {\n+        this.tcx().sess.span_err(\n+            span,\n+            \"at least one non-builtin trait is required for an object type\");\n+        None\n     };\n \n     let bounds ="}, {"sha": "7c431b4fc0bd065279edc29078605de20e4a70c8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -124,7 +124,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_struct(pcx, pat, path, fields.as_slice(), etc, expected);\n         }\n         ast::PatTup(ref elements) => {\n-            let element_tys = Vec::from_fn(elements.len(), |_| fcx.infcx().next_ty_var());\n+            let element_tys: Vec<_> = range(0, elements.len()).map(|_| fcx.infcx()\n+                .next_ty_var()).collect();\n             let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "a751b65a0f8c58233cacd91266082958ded4b931", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -24,6 +24,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n use std::mem;\n+use std::iter::repeat;\n use util::ppaux::Repr;\n \n struct ConfirmContext<'a, 'tcx:'a> {\n@@ -339,7 +340,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             } else if num_supplied_types != num_method_types {\n                 span_err!(self.tcx().sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");\n-                Vec::from_elem(num_method_types, self.tcx().types.err)\n+                repeat(self.tcx().types.err).take(num_method_types).collect()\n             } else {\n                 supplied_method_types\n             }"}, {"sha": "f3a4a8d177e233b1153f1423b4ed7ebcb2b5c55a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -110,6 +110,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::{mod, abi, attr};\n use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{mod, local_def, PostExpansionMethod};\n@@ -2130,9 +2131,9 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n \n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n-        Ok(Vec::from_fn(count, |_| {\n+        Ok(range(0, count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n-        }))\n+        }).collect())\n     }\n }\n \n@@ -2810,7 +2811,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n-    Vec::from_fn(len, |_| tcx.types.err)\n+    range(0, len).map(|_| tcx.types.err).collect()\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -5166,7 +5167,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // The first step then is to categorize the segments appropriately.\n \n     assert!(path.segments.len() >= 1);\n-    let mut segment_spaces;\n+    let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n         def::DefSelfTy(..) |\n@@ -5181,15 +5182,15 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefTyParam(..) => {\n             // Everything but the final segment should have no\n             // parameters at all.\n-            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n         }\n \n         // Case 2. Reference to a top-level value.\n         def::DefFn(..) |\n         def::DefConst(..) |\n         def::DefStatic(..) => {\n-            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n \n@@ -5205,7 +5206,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 def::FromImpl(_) => {}\n             }\n \n-            segment_spaces = Vec::from_elem(path.segments.len() - 2, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 2).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n@@ -5220,7 +5221,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefRegion(..) |\n         def::DefLabel(..) |\n         def::DefUpvar(..) => {\n-            segment_spaces = Vec::from_elem(path.segments.len(), None);\n+            segment_spaces = repeat(None).take(path.segments.len()).collect();\n         }\n     }\n     assert_eq!(segment_spaces.len(), path.segments.len());\n@@ -5489,8 +5490,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 \"too few type parameters provided: expected {}{} parameter(s) \\\n                 , found {} parameter(s)\",\n                 qualifier, required_len, provided_len);\n-            substs.types.replace(space,\n-                                 Vec::from_elem(desired.len(), fcx.tcx().types.err));\n+            substs.types.replace(space, repeat(fcx.tcx().types.err).take(desired.len()).collect());\n             return;\n         }\n \n@@ -5614,7 +5614,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n-    let mut tps_used = Vec::from_elem(tps.len(), false);\n+    let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n     ty::walk_ty(ty, |t| {\n             match t.sty {"}, {"sha": "42ffe2d5327bc4eb85a520c942dba6252b968d99", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -409,4 +409,3 @@ impl<'tcx> Repr<'tcx> for WfConstraint<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "f153b51c5df7798f175bb3eec8b0f4725696dae0", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -190,11 +190,13 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n     }\n \n-    /// Returns a vec of error messages. If hte vec is empty - no errors!\n+    /// Returns a vec of error messages. If the vec is empty - no errors!\n     ///\n     /// There are some limitations to calling functions through an object, because (a) the self\n     /// type is not known (that's the whole point of a trait instance, after all, to obscure the\n-    /// self type) and (b) the call must go through a vtable and hence cannot be monomorphized.\n+    /// self type), (b) the call must go through a vtable and hence cannot be monomorphized and\n+    /// (c) the trait contains static methods which can't be called because we don't know the\n+    /// concrete type.\n     fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            object_trait: &ty::PolyTraitRef<'tcx>,\n                                            method: &ty::Method<'tcx>)\n@@ -210,9 +212,11 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n \n             ty::StaticExplicitSelfCategory => {\n-                // Static methods are always object-safe since they\n-                // can't be called through a trait object\n-                return msgs\n+                // Static methods are never object safe (reason (c)).\n+                msgs.push(format!(\"cannot call a static method (`{}`) \\\n+                                   through a trait object\",\n+                                  method_name));\n+                return msgs;\n             }\n             ty::ByReferenceExplicitSelfCategory(..) |\n             ty::ByBoxExplicitSelfCategory => {}"}, {"sha": "c62218313f4e810142640a3d8a15feaa897dded5", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -13,6 +13,7 @@ use middle::ty;\n use middle::ty_fold;\n \n use std::cell::Cell;\n+use std::iter::repeat;\n use syntax::codemap::Span;\n \n /// Defines strategies for handling regions that are omitted.  For\n@@ -99,7 +100,7 @@ impl RegionScope for SpecificRscope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n-        Ok(Vec::from_elem(count, self.default))\n+        Ok(repeat(self.default).take(count).collect())\n     }\n }\n \n@@ -134,7 +135,7 @@ impl RegionScope for BindingRscope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n-        Ok(Vec::from_fn(count, |_| self.next_region()))\n+        Ok(range(0, count).map(|_| self.next_region()).collect())\n     }\n }\n "}, {"sha": "de0b0a7ad3548e75c444d457c0b7944e15711cb0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -199,6 +199,7 @@ use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace}\n use middle::ty::{mod, Ty};\n use std::fmt;\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -971,7 +972,7 @@ struct SolveContext<'a, 'tcx: 'a> {\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions = Vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n+    let solutions: Vec<_> = repeat(ty::Bivariant).take(terms_cx.num_inferred()).collect();\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,"}, {"sha": "3c09a10f3d98ed651dd4447540d0bf6c25b4df0c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -398,7 +398,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 Some(root) => {\n                     try!(write!(f, \"<a href='{}{}/primitive.{}.html'>\",\n                                 root,\n-                                path.0.head().unwrap(),\n+                                path.0.first().unwrap(),\n                                 prim.to_url_str()));\n                     needs_termination = true;\n                 }"}, {"sha": "f8a0b88b4088d99ac4ffcf7fbf56771f3d7d359a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1799,7 +1799,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     try!(write!(w, r#\"<script type=\"text/javascript\" async\n                               src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n                       </script>\"#,\n-                root_path = Vec::from_elem(cx.current.len(), \"..\").connect(\"/\"),\n+                root_path = repeat(\"..\").take(cx.current.len()).collect::<Vec<_>>().connect(\"/\"),\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n@@ -2055,7 +2055,8 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache().impls.get(&it.def_id) {\n         Some(v) => {\n-            let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n+            let (non_trait, traits): (Vec<_>, _) = v.iter().cloned()\n+                .partition(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                 for i in non_trait.iter() {\n@@ -2065,7 +2066,8 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n             if traits.len() > 0 {\n                 try!(write!(w, \"<h2 id='implementations'>Trait \\\n                                   Implementations</h2>\"));\n-                let (derived, manual) = traits.partition(|i| i.impl_.derived);\n+                let (derived, manual): (Vec<_>, _) = traits.into_iter()\n+                    .partition(|i| i.impl_.derived);\n                 for i in manual.iter() {\n                     try!(render_impl(w, i));\n                 }"}, {"sha": "ccdc816425503d95a0b6c4139f9a60e7f8ecf165", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -116,7 +116,8 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n     use getopts::*;\n     vec!(\n         optflag(\"h\", \"help\", \"show this help message\"),\n-        optflagopt(\"\", \"version\", \"print rustdoc's version\", \"verbose\"),\n+        optflag(\"V\", \"version\", \"print rustdoc's version\"),\n+        optflag(\"v\", \"verbose\", \"use verbose output\"),\n         optopt(\"r\", \"input-format\", \"the input type of the specified file\",\n                \"[rust|json]\"),\n         optopt(\"w\", \"output-format\", \"the output type to write\","}, {"sha": "aeb4df402a2cff3ffa96169caac74a237dc00dee", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -241,17 +241,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl Not<$BitFlags> for $BitFlags {\n-            /// Returns the complement of this set of flags.\n-            #[inline]\n-            fn not(&self) -> $BitFlags {\n-                $BitFlags { bits: !self.bits } & $BitFlags::all()\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl Not<$BitFlags> for $BitFlags {\n             /// Returns the complement of this set of flags.\n             #[inline]"}, {"sha": "4e22fc6008037cc41cd50ce77218e57954e06834", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -74,7 +74,7 @@ use fmt;\n use hash;\n use mem;\n use ptr;\n-use slice::{mod, ImmutableIntSlice};\n+use slice::{mod, IntSliceExt};\n use str;\n use string::String;\n use core::kinds::marker;\n@@ -486,6 +486,8 @@ fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n /// External iterator for a CString's bytes.\n ///\n /// Use with the `std::iter` module.\n+#[allow(raw_pointer_deriving)]\n+#[deriving(Clone)]\n pub struct CChars<'a> {\n     ptr: *const libc::c_char,\n     marker: marker::ContravariantLifetime<'a>,"}, {"sha": "3bfe2009f8b4b5fb250f72c0afaab66f71510cd2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1261,6 +1261,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n+#[stable]\n impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -1271,6 +1272,7 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n     }\n }\n \n+#[stable]\n impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {}\n \n impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n@@ -1317,6 +1319,15 @@ pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: table::Iter<'a, K, V>\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, K, V> Clone for Iter<'a, K, V> {\n+    fn clone(&self) -> Iter<'a, K, V> {\n+        Iter {\n+            inner: self.inner.clone()\n+        }\n+    }\n+}\n+\n /// HashMap mutable values iterator\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: table::IterMut<'a, K, V>\n@@ -1337,11 +1348,29 @@ pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, K, V> Clone for Keys<'a, K, V> {\n+    fn clone(&self) -> Keys<'a, K, V> {\n+        Keys {\n+            inner: self.inner.clone()\n+        }\n+    }\n+}\n+\n /// HashMap values iterator\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, K, V> Clone for Values<'a, K, V> {\n+    fn clone(&self) -> Values<'a, K, V> {\n+        Values {\n+            inner: self.inner.clone()\n+        }\n+    }\n+}\n+\n /// HashMap drain iterator\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<"}, {"sha": "93f6895f6885b519dc8311076cd6c986e9f7cf23", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -572,6 +572,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     }\n }\n \n+#[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n     fn eq(&self, other: &HashSet<T, H>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -580,6 +581,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n     }\n }\n \n+#[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n \n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {"}, {"sha": "6938ab9b0b6d7defb94ade8b0239e1c7c5463e10", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -718,6 +718,18 @@ struct RawBuckets<'a, K, V> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, K, V> Clone for RawBuckets<'a, K, V> {\n+    fn clone(&self) -> RawBuckets<'a, K, V> {\n+        RawBuckets {\n+            raw: self.raw,\n+            hashes_end: self.hashes_end,\n+            marker: marker::ContravariantLifetime,\n+        }\n+    }\n+}\n+\n+\n impl<'a, K, V> Iterator<RawBucket<K, V>> for RawBuckets<'a, K, V> {\n     fn next(&mut self) -> Option<RawBucket<K, V>> {\n         while self.raw.hash != self.hashes_end {\n@@ -775,6 +787,17 @@ pub struct Iter<'a, K: 'a, V: 'a> {\n     elems_left: uint,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, K, V> Clone for Iter<'a, K, V> {\n+    fn clone(&self) -> Iter<'a, K, V> {\n+        Iter {\n+            iter: self.iter.clone(),\n+            elems_left: self.elems_left\n+        }\n+    }\n+}\n+\n+\n /// Iterator over mutable references to entries in a table.\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,"}, {"sha": "a8004155af06d7bde0a02a57ac9b1b3af2223d24", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -148,7 +148,7 @@ impl<T: Send> Packet<T> {\n                     tail: 0 as *mut Node,\n                 },\n                 buf: Buffer {\n-                    buf: Vec::from_fn(cap + if cap == 0 {1} else {0}, |_| None),\n+                    buf: range(0, cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },"}, {"sha": "957dd54a037cf86376dd462d6996434e33c77791", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -406,8 +406,6 @@ pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n #[doc(hidden)]\n pub use core::fmt::{argument, argumentuint};\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n@@ -431,31 +429,6 @@ pub fn format(args: Arguments) -> string::String {\n     string::String::from_utf8(output).unwrap()\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// The format function takes a precompiled format string and a list of\n-/// arguments, to return the resulting formatted string.\n-///\n-/// # Arguments\n-///\n-///   * args - a structure of arguments generated via the `format_args!` macro.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::fmt;\n-///\n-/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, \"Hello, world!\".to_string());\n-/// ```\n-#[experimental = \"this is an implementation detail of format! and should not \\\n-                  be called directly\"]\n-pub fn format(args: &Arguments) -> string::String {\n-    let mut output = Vec::new();\n-    let _ = write!(&mut output as &mut Writer, \"{}\", args);\n-    string::String::from_utf8(output).unwrap()\n-}\n-\n impl<'a> Writer for Formatter<'a> {\n     fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n         match (*self).write(b) {"}, {"sha": "0fba0f6704be4bac990c9f2dbd06c632f5904b33", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -439,9 +439,10 @@ mod test {\n \n     impl Reader for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            match self.lengths.remove(0) {\n-                Some(i) => Ok(i),\n-                None => Err(io::standard_error(io::EndOfFile))\n+            if self.lengths.is_empty() {\n+                Err(io::standard_error(io::EndOfFile))\n+            } else {\n+                Ok(self.lengths.remove(0))\n             }\n         }\n     }"}, {"sha": "e4c31ff8dd321a5f1c515721547667bb6dbf978f", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -558,6 +558,7 @@ pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n }\n \n /// An iterator that walks over a directory\n+#[deriving(Clone)]\n pub struct Directories {\n     stack: Vec<Path>,\n }"}, {"sha": "8d5b125bb081fc268f93ffc03854ddfbb083c078", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1017,8 +1017,6 @@ pub trait Writer {\n     /// decide whether their stream needs to be buffered or not.\n     fn flush(&mut self) -> IoResult<()> { Ok(()) }\n \n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///\n@@ -1057,45 +1055,6 @@ pub trait Writer {\n     }\n \n \n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    /// Writes a formatted string into this writer, returning any error\n-    /// encountered.\n-    ///\n-    /// This method is primarily used to interface with the `format_args!`\n-    /// macro, but it is rare that this should explicitly be called. The\n-    /// `write!` macro should be favored to invoke this method instead.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will return any I/O error reported while formatting.\n-    fn write_fmt(&mut self, fmt: &fmt::Arguments) -> IoResult<()> {\n-        // Create a shim which translates a Writer to a FormatWriter and saves\n-        // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, T:'a> {\n-            inner: &'a mut T,\n-            error: IoResult<()>,\n-        }\n-\n-        impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n-            fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                match self.inner.write(bytes) {\n-                    Ok(()) => Ok(()),\n-                    Err(e) => {\n-                        self.error = Err(e);\n-                        Err(fmt::Error)\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut output = Adaptor { inner: self, error: Ok(()) };\n-        match fmt::write(&mut output, fmt) {\n-            Ok(()) => Ok(()),\n-            Err(..) => output.error\n-        }\n-    }\n-\n     /// Write a rust string into this sink.\n     ///\n     /// The bytes written will be the UTF-8 encoded version of the input string."}, {"sha": "e8fbb12118199f9912c291ea409c6dd2dcaa1dc7", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -10,8 +10,8 @@\n \n //! Synchronous DNS Resolution\n //!\n-//! Contains the functionality to perform DNS resolution in a style related to\n-//! `getaddrinfo()`\n+//! Contains the functionality to perform DNS resolution or reverse lookup,\n+//! in a style related to `getaddrinfo()` and `getnameinfo()`, respectively.\n \n #![allow(missing_docs)]\n \n@@ -24,6 +24,7 @@ use io::{IoResult};\n use io::net::ip::{SocketAddr, IpAddr};\n use option::Option;\n use option::Option::{Some, None};\n+use string::String;\n use sys;\n use vec::Vec;\n \n@@ -83,6 +84,12 @@ pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n     lookup(Some(host), None, None).map(|a| a.into_iter().map(|i| i.address.ip).collect())\n }\n \n+/// Reverse name resolution. Given an address, returns the corresponding\n+/// hostname.\n+pub fn get_address_name(addr: IpAddr) -> IoResult<String> {\n+    sys::addrinfo::get_address_name(addr)\n+}\n+\n /// Full-fledged resolution. This function will perform a synchronous call to\n /// getaddrinfo, controlled by the parameters\n ///"}, {"sha": "43d2e078035a6ef83c60982d836b7e17e261b8bd", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -378,38 +378,18 @@ pub fn println(s: &str) {\n     })\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n-/// with the `format_args!` macro.\n-pub fn print_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| write!(io, \"{}\", fmt))\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// Similar to `println`, but takes a `fmt::Arguments` structure to be\n-/// compatible with the `format_args!` macro.\n-pub fn println_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n-}\n-\n /// Representation of a reader of a standard input stream\n pub struct StdReader {\n     inner: StdSource"}, {"sha": "2a98067c970804ad265491a94bb29cfd55967999", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -163,6 +163,7 @@ impl Writer for MultiWriter {\n \n /// A `Reader` which chains input from multiple `Reader`s, reading each to\n /// completion before moving onto the next.\n+#[deriving(Clone)]\n pub struct ChainedReader<I, R> {\n     readers: I,\n     cur_reader: Option<R>,\n@@ -246,6 +247,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n }\n \n /// An adaptor converting an `Iterator<u8>` to a `Reader`.\n+#[deriving(Clone)]\n pub struct IterReader<T> {\n     iter: T,\n }"}, {"sha": "74c387c5eeaf1aafe95b437b12be97ac58f07ba7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -158,6 +158,7 @@ pub use alloc::rc;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n+#[stable]\n pub use core_collections::vec;\n \n pub use unicode::char;"}, {"sha": "ebb64bc2f2d518a8081fe3b79ed1de3742ff9a17", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -17,8 +17,6 @@\n #![experimental]\n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The entry point for panic of Rust tasks.\n ///\n /// This macro is used to inject panic into a Rust task, causing the task to\n@@ -59,63 +57,6 @@ macro_rules! panic {\n     });\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// The entry point for panic of Rust tasks.\n-///\n-/// This macro is used to inject panic into a Rust task, causing the task to\n-/// unwind and panic entirely. Each task's panic can be reaped as the\n-/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n-/// the value which is transmitted.\n-///\n-/// The multi-argument form of this macro panics with a string and has the\n-/// `format!` syntax for building a string.\n-///\n-/// # Example\n-///\n-/// ```should_fail\n-/// # #![allow(unreachable_code)]\n-/// panic!();\n-/// panic!(\"this is a terrible mistake!\");\n-/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n-/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n-/// ```\n-#[macro_export]\n-macro_rules! panic {\n-    () => ({\n-        panic!(\"explicit panic\")\n-    });\n-    ($msg:expr) => ({\n-        // static requires less code at runtime, more constant data\n-        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        // a closure can't have return type !, so we need a full\n-        // function to pass to format_args!, *and* we need the\n-        // file and line numbers right here; so an inner bare fn\n-        // is our only choice.\n-        //\n-        // LLVM doesn't tend to inline this, presumably because begin_unwind_fmt\n-        // is #[cold] and #[inline(never)] and because this is flagged as cold\n-        // as returning !. We really do want this to be inlined, however,\n-        // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n-        // were seen when forcing this to be inlined, and that number just goes\n-        // up with the number of calls to panic!()\n-        //\n-        // The leading _'s are to avoid dead code warnings if this is\n-        // used inside a dead function. Just `#[allow(dead_code)]` is\n-        // insufficient, since the user may have\n-        // `#[forbid(dead_code)]` and which cannot be overridden.\n-        #[inline(always)]\n-        fn _run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n-            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-            ::std::rt::begin_unwind_fmt(fmt, &_FILE_LINE)\n-        }\n-        format_args!(_run_fmt, $fmt, $($arg)*)\n-    });\n-}\n-\n /// Ensure that a boolean expression is `true` at runtime.\n ///\n /// This will invoke the `panic!` macro if the provided expression cannot be\n@@ -289,8 +230,6 @@ macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///\n@@ -307,28 +246,6 @@ macro_rules! format {\n     ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// format!(\"test\");\n-/// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! format {\n-    ($($arg:tt)*) => (\n-        format_args!(::std::fmt::format, $($arg)*)\n-    )\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n /// See `std::fmt` for more information.\n ///\n@@ -347,29 +264,6 @@ macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// # #![allow(unused_must_use)]\n-///\n-/// let mut w = Vec::new();\n-/// write!(&mut w, \"test\");\n-/// write!(&mut w, \"formatted {}\", \"arguments\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ({\n-        let dst = &mut *$dst;\n-        format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n-    })\n-}\n-\n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n@@ -380,8 +274,6 @@ macro_rules! writeln {\n     )\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -390,18 +282,6 @@ macro_rules! print {\n     ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Equivalent to the `println!` macro except that a newline is not printed at\n-/// the end of the message.\n-#[macro_export]\n-#[stable]\n-macro_rules! print {\n-    ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Macro for printing to a task's stdout handle.\n ///\n /// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n@@ -420,26 +300,6 @@ macro_rules! println {\n     ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Macro for printing to a task's stdout handle.\n-///\n-/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n-/// The syntax of this macro is the same as that used for `format!`. For more\n-/// information, see `std::fmt` and `std::io::stdio`.\n-///\n-/// # Example\n-///\n-/// ```\n-/// println!(\"hello there!\");\n-/// println!(\"format {} arguments\", \"some\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! println {\n-    ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n-}\n-\n /// Helper macro for unwrapping `Result` values while returning early with an\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`."}, {"sha": "df50b7f81afcf24d4c61c399cb90090d63a687d6", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -620,10 +620,11 @@ pub fn get_exit_status() -> int {\n unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use c_str::CString;\n+    use iter::range;\n \n-    Vec::from_fn(argc as uint, |i| {\n+    range(0, argc as uint).map(|i| {\n         CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_vec()\n-    })\n+    }).collect()\n }\n \n /// Returns the command line arguments\n@@ -715,13 +716,14 @@ fn real_args() -> Vec<String> {\n #[cfg(windows)]\n fn real_args() -> Vec<String> {\n     use slice;\n+    use iter::range;\n \n     let mut nArgs: c_int = 0;\n     let lpArgCount: *mut c_int = &mut nArgs;\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let args = Vec::from_fn(nArgs as uint, |i| unsafe {\n+    let args: Vec<_> = range(0, nArgs as uint).map(|i| unsafe {\n         // Determine the length of this argument.\n         let ptr = *szArgList.offset(i as int);\n         let mut len = 0;\n@@ -732,7 +734,7 @@ fn real_args() -> Vec<String> {\n         let buf = slice::from_raw_buf(&ptr, len);\n         let opt_s = String::from_utf16(sys::os::truncate_utf16_at_nul(buf));\n         opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n-    });\n+    }).collect();\n \n     unsafe {\n         LocalFree(szArgList as *mut c_void);"}, {"sha": "bd4031e623085ee0c1263833ba9eef187918c109", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -22,14 +22,14 @@ use option::Option::{None, Some};\n use kinds::Sized;\n use str::{FromStr, Str};\n use str;\n-use slice::{CloneSliceExt, Splits, AsSlice, VectorVector,\n+use slice::{CloneSliceExt, Split, AsSlice, SliceConcatExt,\n             PartialEqSliceExt, SliceExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type Components<'a> = Splits<'a, u8, fn(&u8) -> bool>;\n+pub type Components<'a> = Split<'a, u8, fn(&u8) -> bool>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> =\n@@ -306,7 +306,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect_vec(&SEP_BYTE)))\n+            Some(Path::new(comps.as_slice().connect(&SEP_BYTE)))\n         }\n     }\n "}, {"sha": "751ed4b70fb38fa1646c49a1b5ae47217d45d0ea", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -25,8 +25,8 @@ use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use slice::SliceExt;\n-use str::{SplitTerminator, FromStr, StrVector, StrExt};\n+use slice::{SliceExt, SliceConcatExt};\n+use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n use unicode::char::UnicodeChar;\n use vec::Vec;"}, {"sha": "f016683e3d0a99991cf5f07db5befa71e6edb27e", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -66,7 +66,7 @@\n #[doc(no_inline)] pub use iter::{FromIterator, Extend, ExactSizeIterator};\n #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, DoubleEndedIterator};\n #[doc(no_inline)] pub use iter::{DoubleEndedIteratorExt, CloneIteratorExt};\n-#[doc(no_inline)] pub use iter::{RandomAccessIterator, IteratorCloneExt};\n+#[doc(no_inline)] pub use iter::{RandomAccessIterator, IteratorCloneExt, IteratorPairExt};\n #[doc(no_inline)] pub use iter::{IteratorOrdExt, MutableDoubleEndedIterator};\n #[doc(no_inline)] pub use num::{ToPrimitive, FromPrimitive};\n #[doc(no_inline)] pub use boxed::Box;\n@@ -80,10 +80,9 @@\n #[doc(no_inline)] pub use core::prelude::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use core::prelude::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use core::prelude::{Tuple9, Tuple10, Tuple11, Tuple12};\n-#[doc(no_inline)] pub use str::{Str, StrVector};\n-#[doc(no_inline)] pub use str::StrExt;\n+#[doc(no_inline)] pub use str::{Str, StrExt};\n #[doc(no_inline)] pub use slice::AsSlice;\n-#[doc(no_inline)] pub use slice::{VectorVector, PartialEqSliceExt};\n+#[doc(no_inline)] pub use slice::{SliceConcatExt, PartialEqSliceExt};\n #[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt, SliceExt};\n #[doc(no_inline)] pub use slice::{BoxedSliceExt};\n #[doc(no_inline)] pub use string::{IntoString, String, ToString};"}, {"sha": "91b6a1f0ce0ce8a8e176634c642693e8cafbf1ab", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -170,6 +170,7 @@ mod imp {\n     extern crate libc;\n \n     use io::{IoResult};\n+    use kinds::Sync;\n     use mem;\n     use os;\n     use rand::Rng;\n@@ -196,6 +197,8 @@ mod imp {\n     #[repr(C)]\n     struct SecRandom;\n \n+    unsafe impl Sync for *const SecRandom {}\n+\n     #[allow(non_upper_case_globals)]\n     static kSecRandomDefault: *const SecRandom = 0 as *const SecRandom;\n "}, {"sha": "98eff621ce0f3c95c3c28552ff007b2e5b29a7ae", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -95,14 +95,14 @@ mod imp {\n     }\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n-        Vec::from_fn(argc as uint, |i| {\n+        range(0, argc as uint).map(|i| {\n             let arg = *argv.offset(i as int);\n             let mut len = 0u;\n             while *arg.offset(len as int) != 0 {\n                 len += 1u;\n             }\n             slice::from_raw_buf(&arg, len).to_vec()\n-        })\n+        }).collect()\n     }\n \n     #[cfg(test)]"}, {"sha": "0f35500a04a737469e510e52e7e7212b1c56881c", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -15,22 +15,12 @@\n \n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n         ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\") $($arg)*))\n     } )\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rterrln {\n-    ($fmt:expr $($arg:tt)*) => ( {\n-        format_args!(::rt::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n-    } )\n-}\n-\n // Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n macro_rules! rtdebug {\n     ($($arg:tt)*) => ( {\n@@ -50,14 +40,6 @@ macro_rules! rtassert {\n     } )\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n macro_rules! rtabort {\n     ($($arg:tt)*) => (::rt::util::abort(format_args!($($arg)*)))\n }\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rtabort {\n-    ($($arg:tt)*) => (format_args!(::rt::util::abort, $($arg)*))\n-}"}, {"sha": "c273c52daccadbb5551cbea9a79d6955685271de", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -477,8 +477,6 @@ pub mod eabi {\n     }\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cfg(not(test))]\n /// Entry point of panic from the libcore crate.\n #[lang = \"panic_fmt\"]\n@@ -487,18 +485,6 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n     begin_unwind_fmt(msg, &(file, line))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cfg(not(test))]\n-/// Entry point of panic from the libcore crate.\n-#[lang = \"panic_fmt\"]\n-pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n-                                file: &'static str, line: uint) -> ! {\n-    begin_unwind_fmt(msg, &(file, line))\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The entry point for unwinding with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call\n@@ -530,39 +516,6 @@ pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -\n     begin_unwind_inner(msg, file_line)\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// The entry point for unwinding with a formatted message.\n-///\n-/// This is designed to reduce the amount of code required at the call\n-/// site as much as possible (so that `panic!()` has as low an impact\n-/// on (e.g.) the inlining of other functions as possible), by moving\n-/// the actual formatting into this shared place.\n-#[inline(never)] #[cold]\n-pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    use fmt::FormatWriter;\n-\n-    // We do two allocations here, unfortunately. But (a) they're\n-    // required with the current scheme, and (b) we don't handle\n-    // panic + OOM properly anyway (see comment in begin_unwind\n-    // below).\n-\n-    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n-\n-    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n-        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-            self.v.push_all(buf);\n-            Ok(())\n-        }\n-    }\n-\n-    let mut v = Vec::new();\n-    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n-\n-    let msg = box String::from_utf8_lossy(v.as_slice()).into_owned();\n-    begin_unwind_inner(msg, file_line)\n-}\n-\n /// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {"}, {"sha": "5448af3f753b33eeb7e415a99c181241e45e4be8", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,25 +112,11 @@ impl fmt::FormatWriter for Stdio {\n     }\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr.write_fmt(args);\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-pub fn dumb_print(args: &fmt::Arguments) {\n-    let mut w = Stderr;\n-    let _ = write!(&mut w, \"{}\", args);\n-}\n-\n-// NOTE(stage0): Remove wrappers after a snapshot\n-#[cfg(not(stage0))] pub fn abort(args: fmt::Arguments) -> ! { abort_(&args) }\n-#[cfg(stage0)] pub fn abort(args: &fmt::Arguments) -> ! { abort_(args) }\n-\n-// NOTE(stage0): Change to `pub fn abort(args: fmt::Arguments) -> !` after a snapshot\n-fn abort_(args: &fmt::Arguments) -> ! {\n+pub fn abort(args: fmt::Arguments) -> ! {\n     use fmt::FormatWriter;\n \n     struct BufWriter<'a> {"}, {"sha": "18c917aca8a4aba2102adb4f7785fadee4f3786d", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -101,9 +101,9 @@ use core::mem;\n use core::prelude::{Send, Drop, None, Option, Some};\n \n pub use core::atomic::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n-pub use core::atomic::{Ordering, Relaxed, Release, Acquire, AcqRel, SeqCst};\n pub use core::atomic::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n pub use core::atomic::fence;\n+pub use core::atomic::Ordering::{mod, Relaxed, Release, Acquire, AcqRel, SeqCst};\n \n /// An atomic, nullable unique pointer\n ///"}, {"sha": "87ec20fbef872268df84480ea187a18b70229fc3", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -13,6 +13,7 @@ use self::InAddr::*;\n \n use alloc::arc::Arc;\n use libc::{mod, c_char, c_int};\n+use c_str::CString;\n use mem;\n use num::Int;\n use ptr::{mod, null, null_mut};\n@@ -290,6 +291,43 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n     Ok(addrs)\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// get_address_name\n+////////////////////////////////////////////////////////////////////////////////\n+\n+extern \"system\" {\n+    fn getnameinfo(sa: *const libc::sockaddr, salen: libc::socklen_t,\n+        host: *mut c_char, hostlen: libc::size_t,\n+        serv: *mut c_char, servlen: libc::size_t,\n+        flags: c_int) -> c_int;\n+}\n+\n+const NI_MAXHOST: uint = 1025;\n+\n+pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n+    let addr = SocketAddr{ip: addr, port: 0};\n+\n+    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+    let len = addr_to_sockaddr(addr, &mut storage);\n+\n+    let mut hostbuf = [0 as c_char, ..NI_MAXHOST];\n+\n+    let res = unsafe {\n+        getnameinfo(&storage as *const _ as *const libc::sockaddr, len,\n+            hostbuf.as_mut_ptr(), NI_MAXHOST as libc::size_t,\n+            ptr::null_mut(), 0,\n+            0)\n+    };\n+\n+    if res != 0 {\n+        return Err(last_gai_error(res));\n+    }\n+\n+    unsafe {\n+        Ok(CString::new(hostbuf.as_ptr(), false).as_str().unwrap().to_string())\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Timeout helpers\n //"}, {"sha": "208dc60e405dcb87d109b7c82f6273dd55c83069", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -214,8 +214,8 @@ mod signal {\n         sa_resv: [libc::c_int, ..1],\n     }\n \n-    impl ::kinds::Send for sigaction { }\n-    impl ::kinds::Sync for sigaction { }\n+    unsafe impl ::kinds::Send for sigaction { }\n+    unsafe impl ::kinds::Sync for sigaction { }\n \n     #[repr(C)]\n     pub struct sigset_t {"}, {"sha": "c82dacf1e44e9e9b2487497c11f27ae73931b93e", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -56,6 +56,7 @@ pub mod udp;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;\n+    pub use sys_common::net::get_address_name;\n }\n \n // FIXME: move these to c module"}, {"sha": "c0ef89666c0f59b16885ee4a1ce6369ace8af752", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -120,9 +120,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     // signals the first requests in the queue, possible re-enqueueing it.\n     fn signal(active: &mut Vec<Box<Inner>>,\n               dead: &mut Vec<(uint, Box<Inner>)>) {\n-        let mut timer = match active.remove(0) {\n-            Some(timer) => timer, None => return\n-        };\n+        if active.is_empty() { return }\n+\n+        let mut timer = active.remove(0);\n         let mut cb = timer.cb.take().unwrap();\n         cb.call();\n         if timer.repeat {\n@@ -178,15 +178,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n                         Ok(RemoveTimer(id, ack)) => {\n                             match dead.iter().position(|&(i, _)| id == i) {\n                                 Some(i) => {\n-                                    let (_, i) = dead.remove(i).unwrap();\n+                                    let (_, i) = dead.remove(i);\n                                     ack.send(i);\n                                     continue\n                                 }\n                                 None => {}\n                             }\n                             let i = active.iter().position(|i| i.id == id);\n                             let i = i.expect(\"no timer found\");\n-                            let t = active.remove(i).unwrap();\n+                            let t = active.remove(i);\n                             ack.send(t);\n                         }\n                         Err(..) => break"}, {"sha": "57c284ed6a32699fc9ef11b1a09c196957e8337c", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -57,6 +57,7 @@ pub mod udp;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;\n+    pub use sys_common::net::get_address_name;\n }\n \n // FIXME: move these to c module"}, {"sha": "e7194df7ac3cb5513b1672d6410ff59b5ccc504b", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -17,14 +17,14 @@ use prelude::*;\n \n use fmt;\n use io::{IoResult, IoError};\n-use libc::{c_int, c_char, c_void};\n+use iter::repeat;\n+use libc::{c_int, c_void};\n use libc;\n use os;\n use path::BytesContainer;\n use ptr;\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n-use sys::fs::FileDesc;\n use slice;\n+use sys::fs::FileDesc;\n \n use os::TMPBUF_SZ;\n use libc::types::os::arch::extra::DWORD;\n@@ -130,7 +130,7 @@ pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String\n         let mut res = None;\n         let mut done = false;\n         while !done {\n-            let mut buf = Vec::from_elem(n as uint, 0u16);\n+            let mut buf: Vec<u16> = repeat(0u16).take(n as uint).collect();\n             let k = f(buf.as_mut_ptr(), n);\n             if k == (0 as DWORD) {\n                 done = true;"}, {"sha": "a88d11eed22bd254645039b56629578c12489620", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -34,6 +34,7 @@ use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n use libc::{get_osfhandle, CloseHandle};\n use libc::types::os::arch::extra::LPCVOID;\n use io::{mod, IoError, IoResult, MemReader};\n+use iter::repeat;\n use prelude::*;\n use ptr;\n use str::from_utf8;\n@@ -89,7 +90,7 @@ impl TTY {\n     pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         // Read more if the buffer is empty\n         if self.utf8.eof() {\n-            let mut utf16 = Vec::from_elem(0x1000, 0u16);\n+            let mut utf16: Vec<u16> = repeat(0u16).take(0x1000).collect();\n             let mut num: DWORD = 0;\n             match unsafe { ReadConsoleW(self.handle,\n                                          utf16.as_mut_ptr() as LPVOID,"}, {"sha": "14dd2a1ac9b587208c3426338331c8c498808f72", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -189,22 +189,7 @@ macro_rules! __thread_local_inner {\n             }\n         };\n \n-        #[cfg(all(stage0, not(any(target_os = \"macos\", target_os = \"linux\"))))]\n-        const INIT: ::std::thread_local::KeyInner<$t> = {\n-            unsafe extern fn __destroy(ptr: *mut u8) {\n-                ::std::thread_local::destroy_value::<$t>(ptr);\n-            }\n-\n-            ::std::thread_local::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread_local::OsStaticKey {\n-                    inner: ::std::thread_local::OS_INIT_INNER,\n-                    dtor: ::std::option::Option::Some(__destroy),\n-                },\n-            }\n-        };\n-\n-        #[cfg(all(not(stage0), not(any(target_os = \"macos\", target_os = \"linux\"))))]\n+        #[cfg(all(not(any(target_os = \"macos\", target_os = \"linux\"))))]\n         const INIT: ::std::thread_local::KeyInner<$t> = {\n             unsafe extern fn __destroy(ptr: *mut u8) {\n                 ::std::thread_local::destroy_value::<$t>(ptr);\n@@ -346,16 +331,10 @@ mod imp {\n         // *should* be the case that this loop always terminates because we\n         // provide the guarantee that a TLS key cannot be set after it is\n         // flagged for destruction.\n-        #[cfg(not(stage0))]\n         static DTORS: os::StaticKey = os::StaticKey {\n             inner: os::INIT_INNER,\n             dtor: Some(run_dtors as unsafe extern \"C\" fn(*mut u8)),\n         };\n-        #[cfg(stage0)]\n-        static DTORS: os::StaticKey = os::StaticKey {\n-            inner: os::INIT_INNER,\n-            dtor: Some(run_dtors),\n-        };\n         type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n         if DTORS.get().is_null() {\n             let v: Box<List> = box Vec::new();"}, {"sha": "51564b539768d81fd063cf23c6258b0ec77b35af", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -262,20 +262,6 @@ impl Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Neg<Duration> for Duration {\n-    #[inline]\n-    fn neg(&self) -> Duration {\n-        if self.nanos == 0 {\n-            Duration { secs: -self.secs, nanos: 0 }\n-        } else {\n-            Duration { secs: -self.secs - 1, nanos: NANOS_PER_SEC - self.nanos }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Neg<Duration> for Duration {\n     #[inline]\n     fn neg(self) -> Duration {"}, {"sha": "b5395d09ca7d4adb2b90a34fdae0bee7a1343615", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -26,7 +26,7 @@ use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n use std::io::IoResult;\n-use std::iter;\n+use std::iter::{mod, repeat};\n use std::mem;\n use std::slice;\n \n@@ -726,7 +726,7 @@ impl<'ast> NodeCollector<'ast> {\n         debug!(\"ast_map: {} => {}\", id, entry);\n         let len = self.map.len();\n         if id as uint >= len {\n-            self.map.grow(id as uint - len + 1, NotPresent);\n+            self.map.extend(repeat(NotPresent).take(id as uint - len + 1));\n         }\n         self.map[id as uint] = entry;\n     }"}, {"sha": "9fcaf2210c194ea74d726ccc855adca5a2eade3d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -470,7 +470,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n                          -> P<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n-    let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n+    let (modifiers, other_attrs): (Vec<_>, _) = it.attrs.iter().cloned().partition(|attr| {\n         match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n             Some(rc) => match *rc { Modifier(_) => true, _ => false },\n             _ => false"}, {"sha": "500070a14d2d9f6b7281811c2ca31b2638ac38af", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -22,6 +22,7 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n+use std::iter::repeat;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n@@ -477,7 +478,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n-        let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n+        let mut names: Vec<_> = repeat(None).take(self.name_positions.len()).collect();\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -664,7 +665,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     name_ordering: Vec<String>,\n                                     names: HashMap<String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n-    let arg_types = Vec::from_fn(args.len(), |_| None);\n+    let arg_types: Vec<_> = range(0, args.len()).map(|_| None).collect();\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,\n@@ -707,13 +708,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             None => break\n         }\n     }\n-    match parser.errors.remove(0) {\n-        Some(error) => {\n-            cx.ecx.span_err(cx.fmtsp,\n-                            format!(\"invalid format string: {}\", error)[]);\n-            return DummyResult::raw_expr(sp);\n-        }\n-        None => {}\n+    if !parser.errors.is_empty() {\n+        cx.ecx.span_err(cx.fmtsp, format!(\"invalid format string: {}\",\n+                                          parser.errors.remove(0))[]);\n+        return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {\n         let s = cx.trans_literal_string();"}, {"sha": "65ecf701e8dfcbd433041379ea3523138d8f4150", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -166,7 +166,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(ms[]);\n-    let matches = Vec::from_fn(match_idx_hi, |_i| Vec::new());\n+    let matches: Vec<_> = range(0, match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n         top_elts: TtSeq(ms),\n@@ -392,7 +392,8 @@ pub fn parse(sess: &ParseSess,\n                             cur_eis.push(new_ei);\n                         }\n \n-                        let matches = Vec::from_elem(ei.matches.len(), Vec::new());\n+                        let matches: Vec<_> = range(0, ei.matches.len())\n+                            .map(|_| Vec::new()).collect();\n                         let ei_t = ei;\n                         cur_eis.push(box MatcherPos {\n                             stack: vec![],"}, {"sha": "a15f1ca354bffd8e870483e07dd7f288a18348f9", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -65,6 +65,7 @@ pub use self::Token::*;\n \n use std::io;\n use std::string;\n+use std::iter::repeat;\n \n #[deriving(Clone, Copy, PartialEq)]\n pub enum Breaks {\n@@ -166,9 +167,9 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: Vec<Token> = Vec::from_elem(n, Eof);\n-    let size: Vec<int> = Vec::from_elem(n, 0i);\n-    let scan_stack: Vec<uint> = Vec::from_elem(n, 0u);\n+    let token: Vec<Token> = repeat(Eof).take(n).collect();\n+    let size: Vec<int> = repeat(0i).take(n).collect();\n+    let scan_stack: Vec<uint> = repeat(0u).take(n).collect();\n     Printer {\n         out: out,\n         buf_len: n,"}, {"sha": "c1823231e24f75133f609268d2092d90273048b6", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -163,7 +163,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 }),\n         };\n \n-        let (crates, uses) = view_items.partitioned(|x| {\n+        let (crates, uses): (Vec<_>, _) = view_items.iter().cloned().partition(|x| {\n             match x.node {\n                 ast::ViewItemExternCrate(..) => true,\n                 _ => false,"}, {"sha": "680ed55cd98438db54a196aec96a8f14311b8a4a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -16,6 +16,7 @@ use self::FormatState::*;\n use self::FormatOp::*;\n use std::ascii::OwnedAsciiExt;\n use std::mem::replace;\n+use std::iter::repeat;\n \n #[deriving(Copy, PartialEq)]\n enum States {\n@@ -508,7 +509,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n-                s_.grow(n, b'0');\n+                s_.extend(repeat(b'0').take(n));\n                 s_.extend(s.into_iter());\n                 s = s_;\n             }\n@@ -560,10 +561,10 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     if flags.width > s.len() {\n         let n = flags.width - s.len();\n         if flags.left {\n-            s.grow(n, b' ');\n+            s.extend(repeat(b' ').take(n));\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n-            s_.grow(n, b' ');\n+            s_.extend(repeat(b' ').take(n));\n             s_.extend(s.into_iter());\n             s = s_;\n         }"}, {"sha": "c097e9337905093b510f1d1c6f0c30519c641fe9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -990,8 +990,8 @@ fn run_tests<F>(opts: &TestOpts,\n \n     try!(callback(TeFiltered(filtered_descs)));\n \n-    let (filtered_tests, filtered_benchs_and_metrics) =\n-        filtered_tests.partition(|e| {\n+    let (filtered_tests, filtered_benchs_and_metrics): (Vec<_>, _) =\n+        filtered_tests.into_iter().partition(|e| {\n             match e.testfn {\n                 StaticTestFn(_) | DynTestFn(_) => true,\n                 _ => false"}, {"sha": "930aa0270647c1d84e46d20d981b24faa345cf21", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -24,8 +24,6 @@\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-#[cfg(stage0)]\n-extern crate serialize;\n extern crate \"serialize\" as rustc_serialize;\n extern crate libc;\n "}, {"sha": "9e4aa0712470bc6c7ebe346d0fb62f119927b7f8", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -13,21 +13,21 @@\n use core::cmp::Ordering::{Equal, Less, Greater};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::slice;\n use core::slice::SliceExt;\n+use core::result::Result::{Ok, Err};\n use tables::normalization::{canonical_table, compatibility_table, composition_table};\n \n fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {\n-    match r.binary_search(|&(val, _)| {\n+    match r.binary_search_by(|&(val, _)| {\n         if c == val { Equal }\n         else if val < c { Less }\n         else { Greater }\n     }) {\n-        slice::BinarySearchResult::Found(idx) => {\n+        Ok(idx) => {\n             let (_, result) = r[idx];\n             Some(result)\n         }\n-        slice::BinarySearchResult::NotFound(_) => None\n+        Err(_) => None\n     }\n }\n \n@@ -81,16 +81,16 @@ pub fn compose(a: char, b: char) -> Option<char> {\n         match bsearch_table(a, composition_table) {\n             None => None,\n             Some(candidates) => {\n-                match candidates.binary_search(|&(val, _)| {\n+                match candidates.binary_search_by(|&(val, _)| {\n                     if b == val { Equal }\n                     else if val < b { Less }\n                     else { Greater }\n                 }) {\n-                    slice::BinarySearchResult::Found(idx) => {\n+                    Ok(idx) => {\n                         let (_, result) = candidates[idx];\n                         Some(result)\n                     }\n-                    slice::BinarySearchResult::NotFound(_) => None\n+                    Err(_) => None\n                 }\n             }\n         }"}, {"sha": "5a8f63f207e2721be96a15bfcadf8b83c453c5a3", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -19,11 +19,11 @@ pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n     use core::slice::SliceExt;\n-    r.binary_search(|&(lo,hi)| {\n+    r.binary_search_by(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n-    }).found().is_some()\n+    }).is_ok()\n }\n \n pub mod general_category {\n@@ -6826,17 +6826,17 @@ pub mod normalization {\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n         use core::slice::SliceExt;\n-        use core::slice;\n-        match r.binary_search(|&(lo, hi, _)| {\n+        use core::result::Result::{Ok, Err};\n+        match r.binary_search_by(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            slice::BinarySearchResult::NotFound(_) => 0\n+            Err(_) => 0\n         }\n     }\n \n@@ -6961,7 +6961,7 @@ pub mod conversions {\n     use core::slice::SliceExt;\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -6978,13 +6978,13 @@ pub mod conversions {\n     }\n \n     fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n-        match table.binary_search(|&(key, _)| {\n+        match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(i) => Some(i),\n-            slice::BinarySearchResult::NotFound(_) => None,\n+            Ok(i) => Some(i),\n+            Err(_) => None,\n         }\n     }\n \n@@ -7596,20 +7596,20 @@ pub mod charwidth {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::slice::SliceExt;\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        match r.binary_search(|&(lo, hi, _, _)| {\n+        match r.binary_search_by(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            slice::BinarySearchResult::NotFound(_) => 1\n+            Err(_) => 1\n         }\n     }\n \n@@ -7804,7 +7804,7 @@ pub mod grapheme {\n     use core::kinds::Copy;\n     use core::slice::SliceExt;\n     pub use self::GraphemeCat::*;\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     #[allow(non_camel_case_types)]\n     #[deriving(Clone)]\n@@ -7825,16 +7825,16 @@ pub mod grapheme {\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        match r.binary_search(|&(lo, hi, _)| {\n+        match r.binary_search_by(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            slice::BinarySearchResult::NotFound(_) => GC_Any\n+            Err(_) => GC_Any\n         }\n     }\n "}, {"sha": "bce73a27699363db24e5f4339c7b6bbff6216396", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -257,7 +257,7 @@ extern \"C\" void LLVMDIBuilderFinalize(DIBuilderRef Builder) {\n     Builder->finalize();\n }\n \n-extern \"C\" void LLVMDIBuilderCreateCompileUnit(\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateCompileUnit(\n     DIBuilderRef Builder,\n     unsigned Lang,\n     const char* File,\n@@ -267,8 +267,14 @@ extern \"C\" void LLVMDIBuilderCreateCompileUnit(\n     const char* Flags,\n     unsigned RuntimeVer,\n     const char* SplitName) {\n-    Builder->createCompileUnit(Lang, File, Dir, Producer, isOptimized,\n-        Flags, RuntimeVer, SplitName);\n+    return wrap(Builder->createCompileUnit(Lang,\n+                                           File,\n+                                           Dir,\n+                                           Producer,\n+                                           isOptimized,\n+                                           Flags,\n+                                           RuntimeVer,\n+                                           SplitName));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateFile("}, {"sha": "6a9bfa07cf77121c11d3c450b8f389afcabcbcee", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -1,3 +1,12 @@\n+S 2014-12-30 023dfb0\n+  freebsd-x86_64 41ecd0ac557c823831c46696c7d78dc250398f25\n+  linux-i386 fe6b59bf70a397e18629cb82264f7c6a70df34d4\n+  linux-x86_64 8ab3a223f65fbf6b0aa80fcf0564a6d0fb9122e8\n+  macos-i386 d23edb1be58b8683782a473cdc249c58a959c165\n+  macos-x86_64 ab87616fa5d427978db3acd2d705042133ca3c09\n+  winnt-i386 f2c26ac1ccb9d9a00886da9b504190681de89a5f\n+  winnt-x86_64 fa2c7636bb15583ae387554b561ab09babee281a\n+\n S 2014-12-20 8443b09\n   freebsd-x86_64 004f54dce86faeebc15abf92c8742634b53987e6\n   linux-i386 3daf531aed03f5769402f2fef852377e2838db98"}, {"sha": "26d4ec25c643955f3641f0a38aaf4b81c60f62d7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -65,7 +65,7 @@ fn shift_push() {\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {\n-        v2.push(v1.remove(0).unwrap());\n+        v2.push(v1.remove(0));\n     }\n }\n "}, {"sha": "909f8afc34a9fe68f5dd1fa1c92a1f7bbc4aebca", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -181,7 +181,7 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n         unsafe {\n             copy_memory(seq.as_mut_ptr().offset((i - off + 1) as int),\n                         seq.as_ptr().offset((i - off) as int), off);\n-            *seq.unsafe_mut(i - off) = b'\\n';\n+            *seq.get_unchecked_mut(i - off) = b'\\n';\n         }\n         i += LINE_LEN + 1;\n     }"}, {"sha": "5be3b960ec635711d09cdff1ecb2623836257376", "filename": "src/test/compile-fail/issue-15756.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use std::slice::Chunks;\n-use std::slice::MutChunks;\n+use std::slice::ChunksMut;\n \n-fn dft_iter<'a, T>(arg1: Chunks<'a,T>, arg2: MutChunks<'a,T>)\n+fn dft_iter<'a, T>(arg1: Chunks<'a,T>, arg2: ChunksMut<'a,T>)\n {\n     for\n     &something"}, {"sha": "45b0314d2c01da88190a844571b87fecb337bb44", "filename": "src/test/compile-fail/resolve-conflict-type-vs-import.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -15,4 +15,3 @@ struct Iter;\n \n fn main() {\n }\n-"}, {"sha": "761bcd4968abfba2459f2d06e6f40bd9df33091a", "filename": "src/test/compile-fail/trait-object-safety.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that static methods are not object-safe.\n+\n+trait Tr {\n+    fn foo();\n+}\n+\n+struct St;\n+\n+impl Tr for St {\n+    fn foo() {}\n+}\n+\n+fn main() {\n+    let _: &Tr = &St; //~ ERROR cannot convert to a trait object because trait `Tr` is not\n+}"}, {"sha": "4251f22b291470cef15d41a0ecf391a4f5dfad59", "filename": "src/test/debuginfo/basic-types-globals-metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -45,6 +45,7 @@\n \n #![allow(unused_variables)]\n #![allow(dead_code)]\n+#![omit_gdb_pretty_printer_section]\n \n \n static B: bool = false;"}, {"sha": "a4d4ddfea531db9303ff0ab0a8748e73e07c3845", "filename": "src/test/debuginfo/basic-types-globals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -50,6 +50,7 @@\n // gdb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n static B: bool = false;\n static I: int = -1;"}, {"sha": "6aa228ec51bfce93cae3939bffa7ed31c6bfbb8f", "filename": "src/test/debuginfo/basic-types-metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -48,6 +48,7 @@\n // gdb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n     let unit: () = ();"}, {"sha": "bc8cdaf8eacc9eb41e6a9c14e9aff8f426ab48c1", "filename": "src/test/debuginfo/basic-types-mut-globals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -83,6 +83,7 @@\n // gdb-check:$28 = 9.25\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n static mut B: bool = false;\n static mut I: int = -1;"}, {"sha": "f61f49228cdebf508223b82aaaba685f8dc6f9b2", "filename": "src/test/debuginfo/basic-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -88,6 +88,7 @@\n // lldb-check:[...]$12 = 3.5\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n     let b: bool = false;"}, {"sha": "f4c31278cf63be5c83722eee42a9e8ecc004eeee", "filename": "src/test/debuginfo/borrowed-basic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -109,6 +109,7 @@\n // lldb-check:[...]$12 = 3.5\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n     let bool_val: bool = true;"}, {"sha": "c2da58f1583c0b38c239865ce51b30a43d9607f5", "filename": "src/test/debuginfo/borrowed-c-style-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -41,6 +41,7 @@\n // lldb-check:[...]$2 = TheC\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n enum ABC { TheA, TheB, TheC }\n "}, {"sha": "d54869888f182d590c235949d73ac9b4a4ea3f6d", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -40,6 +40,7 @@\n // lldb-check:[...]$2 = TheOnlyCase(4820353753753434)\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since\n // the size of the discriminant value is machine dependent, this has be taken into account when"}, {"sha": "e3cf438be439c81dd56aa33163679e41c7d0b8fb", "filename": "src/test/debuginfo/borrowed-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -64,6 +64,7 @@\n // lldb-check:[...]$6 = 26.5\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct SomeStruct {\n     x: int,"}, {"sha": "ce0930f2fbf38f71de67f153a28c1b6836ec987c", "filename": "src/test/debuginfo/borrowed-tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -42,6 +42,7 @@\n \n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n     let stack_val: (i16, f32) = (-14, -19f32);"}, {"sha": "d152775a8ed6a9514626589208f25474dfe9e4db", "filename": "src/test/debuginfo/borrowed-unique-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,7 +112,7 @@\n // lldb-check:[...]$12 = 3.5\n \n #![allow(unused_variables)]\n-\n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n     let bool_box: Box<bool> = box true;"}, {"sha": "5a70eb190412832f3a0266993297a8241e5d8ab9", "filename": "src/test/debuginfo/box.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbox.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -32,6 +32,7 @@\n // lldb-check:[...]$1 = (2, 3.5)\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n     let a = box 1i;"}, {"sha": "f9d762bf99d28a1b43c16fe5742c5f891d726b76", "filename": "src/test/debuginfo/boxed-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -35,6 +35,7 @@\n // lldb-check:[...]$1 = StructWithDestructor { x: 77, y: 777, z: 7777, w: 77777 }\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct StructWithSomePadding {\n     x: i16,"}, {"sha": "b0c5b2f21b95cf675b96e96ef95c3ded614cb853", "filename": "src/test/debuginfo/by-value-non-immediate-argument.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -71,6 +71,8 @@\n // lldb-check:[...]$6 = Case1 { x: 0, y: 8970181431921507452 }\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n #[deriving(Clone)]\n struct Struct {\n     a: int,"}, {"sha": "6907313370e1a5edf57f26e6ec3bc158dc9bea1d", "filename": "src/test/debuginfo/by-value-self-argument-in-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fby-value-self-argument-in-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fby-value-self-argument-in-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fby-value-self-argument-in-trait-impl.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -46,6 +46,8 @@\n // lldb-check:[...]$2 = (4444.5, 5555, 6666, 7777.5)\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n trait Trait {\n     fn method(self) -> Self;\n }"}, {"sha": "f2dfc63d52253edfe7f0211741c0927e4807765c", "filename": "src/test/debuginfo/c-style-enum-in-composite.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -65,6 +65,7 @@\n // lldb-check:[...]$6 = (StructWithDrop { a: OneHundred, b: Vienna }, 9)\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::AnEnum::{OneHundred, OneThousand, OneMillion};\n use self::AnotherEnum::{MountainView, Toronto, Vienna};"}, {"sha": "b62a8167eaf07f30e40a54f083888b6a29018b27", "filename": "src/test/debuginfo/c-style-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -99,6 +99,7 @@\n \n #![allow(unused_variables)]\n #![allow(dead_code)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::AutoDiscriminant::{One, Two, Three};\n use self::ManualDiscriminant::{OneHundred, OneThousand, OneMillion};"}, {"sha": "84366ae71146501ee1e25e61d44c4d67fc009f78", "filename": "src/test/debuginfo/closure-in-generic-function.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fclosure-in-generic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fclosure-in-generic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fclosure-in-generic-function.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -46,6 +46,8 @@\n // lldb-check:[...]$3 = 110\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n fn some_generic_fun<T1, T2>(a: T1, b: T2) -> (T2, T1) {\n \n     let closure = |x, y| {"}, {"sha": "b4688e4928a6bfa65644a532068c821cdd9b58e8", "filename": "src/test/debuginfo/destructured-fn-argument.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -311,6 +311,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::Univariant::Unit;\n "}, {"sha": "364720d0e4fb34d0316d8630bd29142438967371", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -152,6 +152,9 @@\n // lldb-check:[...]$23 = (34903493, 232323)\n // lldb-command:continue\n \n+#![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n+\n struct Struct {\n     x: i16,\n     y: f32,"}, {"sha": "d5a6b36f1fcf90329f69cf7d16726be3f1db3f34", "filename": "src/test/debuginfo/destructured-local.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -244,6 +244,7 @@\n \n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::Univariant::Unit;\n "}, {"sha": "f623a321922b8d7695cd4f7665cab48414a17059", "filename": "src/test/debuginfo/evec-in-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -51,6 +51,7 @@\n // lldb-check:[...]$4 = StructPaddedAtEnd { x: [22, 23], y: [24, 25] }\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct NoPadding1 {\n     x: [u32; 3],"}, {"sha": "55c5c50406416aa807d43b576cc593f075587ef6", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -222,10 +222,8 @@\n // lldb-command:continue\n \n \n-\n #![allow(unused_variables)]\n-\n-\n+#![omit_gdb_pretty_printer_section]\n \n fn immediate_args(a: int, b: bool, c: f64) {\n     ::std::io::print(\"\") // #break"}, {"sha": "01136c11014a343f8764c5ae340f10bcd7f0d1d1", "filename": "src/test/debuginfo/function-arguments.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arguments.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -45,6 +45,9 @@\n // lldb-check:[...]$3 = 3000\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n \n     fun(111102, true);"}, {"sha": "e437e35db3a991117d4c61332a295422ba3040e9", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -245,6 +245,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n #[no_stack_check]\n fn immediate_args(a: int, b: bool, c: f64) {"}, {"sha": "05ea357389bc61004678a88beb9835f47ea61329", "filename": "src/test/debuginfo/function-prologue-stepping-regular.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -126,6 +126,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn immediate_args(a: int, b: bool, c: f64) {\n     ()"}, {"sha": "092cd9edc70658e21d3a008c9048270a9aaaf6f9", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -17,7 +17,6 @@\n // ignore-lldb\n // ignore-android: FIXME(#10381)\n // compile-flags:-g\n-// gdb-use-pretty-printer\n \n // gdb-command: run\n "}, {"sha": "64c120e1ab3a9a6566f59f9830afadbf708a9969", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -13,7 +13,6 @@\n // ignore-lldb\n // ignore-android: FIXME(#10381)\n // compile-flags:-g\n-// gdb-use-pretty-printer\n \n // This test uses some GDB Python API features (e.g. accessing anonymous fields)\n // which are only available in newer GDB version. The following directive will"}, {"sha": "cefe67970e959494f291d56b4f487e64db26c4c4", "filename": "src/test/debuginfo/generic-function.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -70,6 +70,7 @@\n // lldb-check:[...]$8 = ((5, Struct { a: 6, b: 7.5 }), (Struct { a: 6, b: 7.5 }, 5))\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n #[deriving(Clone)]\n struct Struct {"}, {"sha": "0f3fd556f189a6c64f67d52cfb8f994575261537", "filename": "src/test/debuginfo/generic-functions-nested.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-functions-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-functions-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-functions-nested.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -70,6 +70,9 @@\n // lldb-check:[...]$7 = 2.5\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n fn outer<TA: Clone>(a: TA) {\n     inner(a.clone(), 1i);\n     inner(a.clone(), 2.5f64);"}, {"sha": "0e358499a3d025d0ae0e5ac4816250f241cc041c", "filename": "src/test/debuginfo/generic-method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,6 +112,7 @@\n // lldb-check:[...]$14 = -10.5\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n struct Struct<T> {\n     x: T"}, {"sha": "bf755d379a6237ffd7cc26e4c341dd65d1e97389", "filename": "src/test/debuginfo/generic-static-method-on-struct-and-enum.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -31,6 +31,9 @@\n // gdb-check:$5 = 5\n // gdb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n struct Struct {\n     x: int\n }"}, {"sha": "992e74179137bad54a4c4b7ef50fcc2f78eb6462", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -29,6 +29,9 @@\n // gdb-command:print univariant\n // gdb-check:$4 = {{a = -1}}\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n use self::Regular::{Case1, Case2, Case3};\n use self::Univariant::TheOnlyCase;\n "}, {"sha": "908968fd6b32acbd97265b9c2bd24c37195e1d0c", "filename": "src/test/debuginfo/generic-struct.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -41,6 +41,9 @@\n // lldb-command:print float_int_float\n // lldb-check:[...]$3 = AGenericStruct<f64, generic-struct::AGenericStruct<int, f64>> { key: 6.5, value: AGenericStruct<int, f64> { key: 7, value: 8.5 } }\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n struct AGenericStruct<TKey, TValue> {\n     key: TKey,\n     value: TValue"}, {"sha": "4382861fd20991af0d3e2f248fc4978e5528449c", "filename": "src/test/debuginfo/generic-trait-generic-static-default-method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-trait-generic-static-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-trait-generic-static-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-trait-generic-static-default-method.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -25,6 +25,7 @@\n // gdb-check:$4 = {3.5, {4, 5, 6}}\n // gdb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     x: int"}, {"sha": "f9dc9d1f055c82c205a3ae57ab29d2fdde507601", "filename": "src/test/debuginfo/generic-tuple-style-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -48,6 +48,8 @@\n // lldb-command:print univariant\n // lldb-check:[...]$3 = TheOnlyCase(-1)\n \n+#![omit_gdb_pretty_printer_section]\n+\n use self::Regular::{Case1, Case2, Case3};\n use self::Univariant::TheOnlyCase;\n "}, {"sha": "25719a802863d78898283b61a2e2dfa3a0fde9dc", "filename": "src/test/debuginfo/include_string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Finclude_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Finclude_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Finclude_string.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -36,6 +36,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n // This test case makes sure that debug info does not ICE when include_str is\n // used multiple times (see issue #11322)."}, {"sha": "c6acc9a31fe3c68a0c70d13ac41f48144241b818", "filename": "src/test/debuginfo/issue12886.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fissue12886.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fissue12886.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue12886.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -16,9 +16,11 @@\n \n // gdb-command:run\n // gdb-command:next\n-// gdb-check:[...]32[...]s\n+// gdb-check:[...]34[...]s\n // gdb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n // IF YOU MODIFY THIS FILE, BE CAREFUL TO ADAPT THE LINE NUMBERS IN THE DEBUGGER COMMANDS\n \n // This test makes sure that gdb does not set unwanted breakpoints in inlined functions. If a"}, {"sha": "3309ae13c9dcbc2430c9368f89517ca4cc3f0311", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -86,6 +86,8 @@\n // lldb-check:[...]$6 = 1000000\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n \n     let range = [1i, 2, 3];"}, {"sha": "bc3a69452432550aaecd01eefabade4acc1dca05", "filename": "src/test/debuginfo/lexical-scope-in-if.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -134,6 +134,7 @@\n // lldb-check:[...]$15 = -1\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n "}, {"sha": "37976ab3996ae22e18a9156dadd155f7937c4f99", "filename": "src/test/debuginfo/lexical-scope-in-match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-match.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -126,6 +126,7 @@\n // lldb-check:[...]$17 = 232\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     x: int,"}, {"sha": "d6e3a43eea0a6383f478ebf0a23243515bfcff8c", "filename": "src/test/debuginfo/lexical-scope-in-stack-closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-stack-closure.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -70,6 +70,8 @@\n // lldb-check:[...]$5 = false\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n \n     let x = false;"}, {"sha": "b295c6f37a7a16d3d5567a9c32881c1f7451894b", "filename": "src/test/debuginfo/lexical-scope-in-unconditional-loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unconditional-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unconditional-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unconditional-loop.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -132,6 +132,8 @@\n // lldb-check:[...]$12 = 2\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n \n     let mut x = 0i;"}, {"sha": "be4085b63abe51dcacd0261647af347d9aa1632b", "filename": "src/test/debuginfo/lexical-scope-in-unique-closure.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unique-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unique-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unique-closure.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -70,6 +70,9 @@\n // lldb-check:[...]$5 = false\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n \n     let x = false;"}, {"sha": "c7a36ef9b82bd07f0e69ba72d32380c11899d519", "filename": "src/test/debuginfo/lexical-scope-in-while.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-while.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -132,6 +132,7 @@\n // lldb-check:[...]$12 = 2\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n "}, {"sha": "be52ffff1b45e9aaba2df6274ea5240cfe740b80", "filename": "src/test/debuginfo/lexical-scope-with-macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,6 +112,7 @@\n \n \n #![feature(macro_rules)]\n+#![omit_gdb_pretty_printer_section]\n \n macro_rules! trivial {\n     ($e1:expr) => ($e1)"}, {"sha": "2f8b11ac283b63b884cf719c856d5075100f0441", "filename": "src/test/debuginfo/lexical-scopes-in-block-expression.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -349,6 +349,7 @@\n \n #![allow(unused_variables)]\n #![allow(unused_assignments)]\n+#![omit_gdb_pretty_printer_section]\n \n static mut MUT_INT: int = 0;\n "}, {"sha": "35889ff81335c04b9789447e487988d583d27a66", "filename": "src/test/debuginfo/limited-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -30,6 +30,7 @@\n \n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     a: i64,"}, {"sha": "b1ebb124d4e76a53a4e877590f0e33864dc9fb46", "filename": "src/test/debuginfo/method-on-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -113,6 +113,8 @@\n // lldb-check:[...]$14 = -10\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n enum Enum {\n     Variant1 { x: u16, y: u16 },\n     Variant2 (u32)"}, {"sha": "68a6ac8c1f31e9c00f8f635942981ad2f0c89bf0", "filename": "src/test/debuginfo/method-on-generic-struct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -113,6 +113,8 @@\n // lldb-command:continue\n \n \n+#![omit_gdb_pretty_printer_section]\n+\n struct Struct<T> {\n     x: T\n }"}, {"sha": "84e74d4364cfaa2cea68cdf833acda89c87a82cb", "filename": "src/test/debuginfo/method-on-struct.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,6 +112,9 @@\n // lldb-check:[...]$14 = -10\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n struct Struct {\n     x: int\n }"}, {"sha": "f53bb11eac442555e4f9786df0b8b6a626248011", "filename": "src/test/debuginfo/method-on-trait.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,6 +112,9 @@\n // lldb-check:[...]$14 = -10\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n struct Struct {\n     x: int\n }"}, {"sha": "6994c38818c1b906733db0945d942ab33ed29779", "filename": "src/test/debuginfo/method-on-tuple-struct.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,6 +112,9 @@\n // lldb-check:[...]$14 = -10\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n struct TupleStruct(int, f64);\n \n impl TupleStruct {"}, {"sha": "cb21c13426a7b63cd3977f7d86cbb8cd1cef3be4", "filename": "src/test/debuginfo/multiple-functions-equal-var-names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -45,6 +45,7 @@\n // lldb-check:[...]$2 = 30303\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn function_one() {\n     let abc = 10101i;"}, {"sha": "ef7c4ce2045c7fe02d9e6e593dadc3292ad6089a", "filename": "src/test/debuginfo/multiple-functions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -45,6 +45,7 @@\n // lldb-check:[...]$2 = 30303\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn function_one() {\n     let a = 10101i;"}, {"sha": "d248c7e98198c71b9c1264fb149ad8b5414e3da7", "filename": "src/test/debuginfo/name-shadowing-and-scope-nesting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fname-shadowing-and-scope-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fname-shadowing-and-scope-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fname-shadowing-and-scope-nesting.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -94,6 +94,8 @@\n // lldb-check:[...]$11 = 20\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n     let x = false;\n     let y = true;"}, {"sha": "f0eaf6acb6138f86ea4f7fec1fb906a0fba6bc9d", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -23,6 +23,7 @@\n // gdb-check:$2 = {<No data fields>}\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n enum ANilEnum {}\n enum AnotherNilEnum {}"}, {"sha": "dcc1928ae50c91e7ddcf86d312be5c26e816da55", "filename": "src/test/debuginfo/no-debug-attribute.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -24,6 +24,7 @@\n // gdb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn function_with_debuginfo() {\n     let abc = 10u;"}, {"sha": "333ad602cf1301a55c21082689f79007a42f15b3", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -68,6 +68,8 @@\n // lldb-check:[...]$7 = None\n \n \n+#![omit_gdb_pretty_printer_section]\n+\n // If a struct has exactly two variants, one of them is empty, and the other one\n // contains a non-nullable pointer, then this value is used as the discriminator.\n // The test cases in this file make sure that something readable is generated for"}, {"sha": "84c0b8da02c0610bdfc7d008c48399d48ce87237", "filename": "src/test/debuginfo/packed-struct-with-destructor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -74,6 +74,7 @@\n \n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n #[repr(packed)]\n struct Packed {"}, {"sha": "97e6ee79952e8078c0480e6673833f3f3762c594", "filename": "src/test/debuginfo/packed-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -60,6 +60,7 @@\n // lldb-check:[...]$5 = 40\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n #[repr(packed)]\n struct Packed {"}, {"sha": "93348e7b53e559b9732726850bae5c61fb1898ed", "filename": "src/test/debuginfo/recursive-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Frecursive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Frecursive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -18,6 +18,7 @@\n // is taken from issue #11083.\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n pub struct Window<'a> {\n     callbacks: WindowCallbacks<'a>"}, {"sha": "90c32ad8da11ffad27354715c5f94d53063cea2b", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -69,6 +69,7 @@\n // gdb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::Opt::{Empty, Val};\n "}, {"sha": "f8ef5b3d2fcf9411cfe493eaccd8c5172cf40c19", "filename": "src/test/debuginfo/self-in-default-method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,6 +112,7 @@\n // lldb-check:[...]$14 = -10\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     x: int"}, {"sha": "c2594df7d351c1da129e3e56bccad819dbbd2819", "filename": "src/test/debuginfo/self-in-generic-default-method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -112,6 +112,7 @@\n // lldb-check:[...]$14 = -10.5\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     x: int"}, {"sha": "c5c3664b07a7c307f355236ef695369129345ac2", "filename": "src/test/debuginfo/shadowed-argument.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fshadowed-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fshadowed-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fshadowed-argument.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -58,6 +58,9 @@\n // lldb-check:[...]$5 = 20\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n fn a_function(x: bool, y: bool) {\n     zzz(); // #break\n     sentinel();"}, {"sha": "f384b756da67813c9941a6562c534b157b5d2f3c", "filename": "src/test/debuginfo/shadowed-variable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fshadowed-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fshadowed-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fshadowed-variable.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -58,6 +58,8 @@\n // lldb-check:[...]$5 = 20\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n     let x = false;\n     let y = true;"}, {"sha": "288e7461dd5a0c226d5a507000dfac7fc52b97ae", "filename": "src/test/debuginfo/simd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimd.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -43,6 +43,7 @@\n \n #![allow(experimental)]\n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use std::simd::{i8x16, i16x8,i32x4,i64x2,u8x16,u16x8,u32x4,u64x2,f32x4,f64x2};\n "}, {"sha": "5981c18494d40c8b4ffe6079f0fc3437934f9917", "filename": "src/test/debuginfo/simple-lexical-scope.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimple-lexical-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimple-lexical-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-lexical-scope.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -78,6 +78,9 @@\n // lldb-check:[...]$6 = false\n // lldb-command:continue\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n fn main() {\n     let x = false;\n "}, {"sha": "3015b16a0aa99ea4ccdda9103f64f83c5aafc3b7", "filename": "src/test/debuginfo/simple-struct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -95,8 +95,9 @@\n // lldb-command:print padding_at_end\n // lldb-check:[...]$5 = PaddingAtEnd { x: -10014, y: 10015 }\n \n-#![allow(unused_variables)];\n-#![allow(dead_code)];\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![omit_gdb_pretty_printer_section]\n \n struct NoPadding16 {\n     x: u16,"}, {"sha": "78184fab7d3904971a6c4e620f75f2e81885b03a", "filename": "src/test/debuginfo/simple-tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -92,6 +92,7 @@\n \n #![allow(unused_variables)]\n #![allow(dead_code)]\n+#![omit_gdb_pretty_printer_section]\n \n static mut NO_PADDING_8: (i8, u8) = (-50, 50);\n static mut NO_PADDING_16: (i16, i16, u16) = (-1, 2, 3);"}, {"sha": "59ee300b3e3b52644a2fa1dc36ebf0c796ba6d84", "filename": "src/test/debuginfo/static-method-on-struct-and-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstatic-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstatic-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstatic-method-on-struct-and-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -54,6 +54,8 @@\n // lldb-check:[...]$4 = 5\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n struct Struct {\n     x: int\n }"}, {"sha": "6f801a7d587d378a9b4b2b5c11d121217c34cbfa", "filename": "src/test/debuginfo/struct-in-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -42,6 +42,7 @@\n // lldb-check:[...]$2 = TheOnlyCase(Struct { x: 123, y: 456, z: 789 })\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::Regular::{Case1, Case2};\n use self::Univariant::TheOnlyCase;"}, {"sha": "3f819c92e1017de50d762f9295522dec5e654e72", "filename": "src/test/debuginfo/struct-in-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -57,6 +57,7 @@\n // lldb-check:[...]$7 = Tree { x: Simple { x: 25 }, y: InternalPaddingParent { x: InternalPadding { x: 26, y: 27 }, y: InternalPadding { x: 28, y: 29 }, z: InternalPadding { x: 30, y: 31 } }, z: BagInBag { x: Bag { x: Simple { x: 32 } } } }\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct Simple {\n     x: i32"}, {"sha": "f6d4627082f0e2d37b8b6b009d19be2e936e2e12", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -49,6 +49,7 @@\n // lldb-check:[...]$3 = TheOnlyCase { a: -1 }\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::Regular::{Case1, Case2, Case3};\n use self::Univariant::TheOnlyCase;"}, {"sha": "743f5ac5ff452c82023504d02ec1e7114ffd0ac3", "filename": "src/test/debuginfo/struct-with-destructor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -45,6 +45,7 @@\n // lldb-check:[...]$3 = NestedOuter { a: NestedInner { a: WithDestructor { x: 7890, y: 9870 } } }\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct NoDestructor {\n     x: i32,"}, {"sha": "2ecafb02ae52d4e8ac4f1d1355e98d962f1162de", "filename": "src/test/debuginfo/trait-generic-static-default-method.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftrait-generic-static-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftrait-generic-static-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftrait-generic-static-default-method.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -45,6 +45,8 @@\n // lldb-check:[...]$3 = (1, 2, 3)\n // lldb-command:continue\n \n+#![omit_gdb_pretty_printer_section]\n+\n struct Struct {\n     x: int\n }"}, {"sha": "9f8c0aa06e67692f2fd118498707a31b4772f2fa", "filename": "src/test/debuginfo/trait-pointers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftrait-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftrait-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftrait-pointers.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -16,6 +16,7 @@\n // lldb-command:run\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n trait Trait {\n     fn method(&self) -> int { 0 }"}, {"sha": "3d28490c0cfd76f3f38eb38b0148d11ff44de2a7", "filename": "src/test/debuginfo/tuple-in-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -41,6 +41,7 @@\n // gdb-check:$10 = {x = {{40, 41, 42}, {43, 44}}, y = {45, 46, 47, 48}}\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct NoPadding1 {\n     x: (i32, i32),"}, {"sha": "b1228f7a8846ada1726d3a1b6156e2e3e9c10334", "filename": "src/test/debuginfo/tuple-in-tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -57,6 +57,7 @@\n // lldb-check:[...]$6 = ((21, 22), 23)\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n fn main() {\n     let no_padding1: ((u32, u32), u32, u32) = ((0, 1), 2, 3);"}, {"sha": "0960ab5834dd6693b08d8aeec56e3f202c9723e0", "filename": "src/test/debuginfo/tuple-struct.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-struct.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -62,6 +62,9 @@\n // to all fields having the name \"<unnamed_field>\"). Otherwise they are handled the same a normal\n // structs.\n \n+\n+#![omit_gdb_pretty_printer_section]\n+\n struct NoPadding16(u16, i16);\n struct NoPadding32(i32, f32, u32);\n struct NoPadding64(f64, i64, u64);"}, {"sha": "f205f484f25fb5ba1cd617560af0f293bc702799", "filename": "src/test/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -49,6 +49,7 @@\n // lldb-check:[...]$3 = TheOnlyCase(-1)\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n use self::Regular::{Case1, Case2, Case3};\n use self::Univariant::TheOnlyCase;"}, {"sha": "ddcbfdcceee01c2c8bbb36d54055a53990cd3d62", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -173,6 +173,8 @@\n // gdb-command:whatis stack_closure2\n // gdb-check:type = struct (&mut|i8, f32| -> f32, uint)\n \n+#![omit_gdb_pretty_printer_section]\n+\n use self::Enum1::{Variant1_1, Variant1_2};\n use std::ptr;\n "}, {"sha": "3d028eb1077bc70f431ae9f686f19ae7cec478fb", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -42,6 +42,7 @@\n // lldb-check:[...]$2 = TheOnlyCase(123234)\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since\n // the size of the discriminant value is machine dependent, this has be taken into account when"}, {"sha": "99d67c60516b5a6fe1e8652c6efcf6e6952b7c4a", "filename": "src/test/debuginfo/var-captured-in-nested-closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -79,6 +79,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     a: int,"}, {"sha": "b34749260f30c16816b0d04dc798998f783a47d0", "filename": "src/test/debuginfo/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -42,6 +42,7 @@\n \n #![allow(unused_variables)]\n #![feature(unboxed_closures)]\n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     a: int,"}, {"sha": "f474e8d1317993feb8647e2d2626a4fb32ab9b9f", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -72,6 +72,7 @@\n \n #![feature(unboxed_closures)]\n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n struct Struct {\n     a: int,"}, {"sha": "70211d74d885d9534bd600a8bc80b70fb7324774", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -78,6 +78,7 @@\n \n #![allow(unused_variables)]\n #![feature(slicing_syntax)]\n+#![omit_gdb_pretty_printer_section]\n \n struct AStruct {\n     x: i16,"}, {"sha": "92a490206b6243afc7855c6484b6a20d15cf9cbe", "filename": "src/test/debuginfo/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Fdebuginfo%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -29,6 +29,7 @@\n // lldb-check:[...]$0 = [1, 2, 3]\n \n #![allow(unused_variables)]\n+#![omit_gdb_pretty_printer_section]\n \n static mut VECT: [i32; 3] = [1, 2, 3];\n "}, {"sha": "856fbbd00b20b2ef6112a7bf30f0c9fd8fd2337d", "filename": "src/test/run-pass/issue-12684.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n use std::time::Duration;\n+use std::thread::Thread;\n \n fn main() {\n-    std::task::spawn(move|| customtask());\n+    Thread::spawn(move|| customtask()).join().ok().unwrap();\n }\n \n fn customtask() {"}, {"sha": "ed7284a8353651d26c1bf2fc09bbe3ae662e73b7", "filename": "src/test/run-pass/trait-object-safety.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Frun-pass%2Ftrait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d99a973498c5a1be6ba318210751efc1c2cf61/src%2Ftest%2Frun-pass%2Ftrait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-object-safety.rs?ref=10d99a973498c5a1be6ba318210751efc1c2cf61", "patch": "@@ -8,20 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that object-safe methods are identified as such.  Also\n-// acts as a regression test for #18490\n+// Check that object-safe methods are identified as such.\n \n trait Tr {\n-    // Static methods are always safe regardless of other rules\n-    fn new() -> Self;\n+    fn foo(&self);\n }\n \n struct St;\n \n impl Tr for St {\n-    fn new() -> St { St }\n+    fn foo(&self) {}\n }\n \n fn main() {\n-    &St as &Tr;\n+    let s: &Tr = &St;\n+    s.foo();\n }"}]}