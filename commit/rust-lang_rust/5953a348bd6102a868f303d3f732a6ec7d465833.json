{"sha": "5953a348bd6102a868f303d3f732a6ec7d465833", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NTNhMzQ4YmQ2MTAyYTg2OGYzMDNkM2Y3MzJhNmVjN2Q0NjU4MzM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-14T09:38:20Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-14T09:38:20Z"}, "message": "Less hackish impl structure", "tree": {"sha": "8f4ca16180f850465d871d9b2959d4ae065dcfeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f4ca16180f850465d871d9b2959d4ae065dcfeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5953a348bd6102a868f303d3f732a6ec7d465833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5953a348bd6102a868f303d3f732a6ec7d465833", "html_url": "https://github.com/rust-lang/rust/commit/5953a348bd6102a868f303d3f732a6ec7d465833", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5953a348bd6102a868f303d3f732a6ec7d465833/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de02d2891ec7f7b295e33887d49de954f677387a", "url": "https://api.github.com/repos/rust-lang/rust/commits/de02d2891ec7f7b295e33887d49de954f677387a", "html_url": "https://github.com/rust-lang/rust/commit/de02d2891ec7f7b295e33887d49de954f677387a"}], "stats": {"total": 405, "additions": 386, "deletions": 19}, "files": [{"sha": "8419f08e6d29c8991c7f0bd8a58083411cf9cf08", "filename": "crates/libeditor/src/symbols.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fsymbols.rs?ref=5953a348bd6102a868f303d3f732a6ec7d465833", "patch": "@@ -6,7 +6,6 @@ use libsyntax2::{\n         visit::{visitor, Visitor},\n         walk::{walk, WalkEvent, preorder},\n     },\n-    SyntaxKind::*,\n };\n use TextRange;\n \n@@ -104,24 +103,21 @@ fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n         .visit(decl::<ast::ConstDef<_>>)\n         .visit(decl::<ast::StaticDef<_>>)\n         .visit(|im: ast::ImplItem<_>| {\n-            let mut label = String::new();\n-            let brace = im.syntax().children()\n-                .find(|it| {\n-                    let stop = it.kind() == L_CURLY;\n-                    if !stop {\n-                        label.push_str(&it.text());\n-                    }\n-                    stop\n-                })?;\n-            let navigation_range = TextRange::from_to(\n-                im.syntax().range().start(),\n-                brace.range().start(),\n-            );\n+            let target_type = im.target_type()?;\n+            let target_trait = im.target_trait();\n+            let label = match target_trait {\n+                None => format!(\"impl {}\", target_type.syntax().text()),\n+                Some(t) => format!(\n+                    \"impl {} for {}\",\n+                    t.syntax().text(),\n+                    target_type.syntax().text(),\n+                ),\n+            };\n \n             let node = StructureNode {\n                 parent: None,\n                 label,\n-                navigation_range,\n+                navigation_range: target_type.syntax().range(),\n                 node_range: im.syntax().range(),\n                 kind: im.syntax().kind(),\n             };"}, {"sha": "91df74bd688804839e8e4e7ccad9010bee877f8c", "filename": "crates/libeditor/tests/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibeditor%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibeditor%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Ftests%2Ftest.rs?ref=5953a348bd6102a868f303d3f732a6ec7d465833", "patch": "@@ -66,7 +66,7 @@ fn test_foo() {}\n }\n \n #[test]\n-fn test_structure() {\n+fn test_file_structure() {\n     let file = file(r#\"\n struct Foo {\n     x: i32\n@@ -94,8 +94,8 @@ impl fmt::Debug for E {}\n            StructureNode { parent: None, label: \"T\", navigation_range: [81; 82), node_range: [76; 88), kind: TYPE_DEF },\n            StructureNode { parent: None, label: \"S\", navigation_range: [96; 97), node_range: [89; 108), kind: STATIC_DEF },\n            StructureNode { parent: None, label: \"C\", navigation_range: [115; 116), node_range: [109; 127), kind: CONST_DEF },\n-           StructureNode { parent: None, label: \"impl E \", navigation_range: [129; 136), node_range: [129; 138), kind: IMPL_ITEM },\n-           StructureNode { parent: None, label: \"impl fmt::Debug for E \", navigation_range: [140; 162), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n+           StructureNode { parent: None, label: \"impl E\", navigation_range: [134; 135), node_range: [129; 138), kind: IMPL_ITEM },\n+           StructureNode { parent: None, label: \"impl fmt::Debug for E\", navigation_range: [160; 161), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n         &symbols,\n     )\n }"}, {"sha": "3e6c673ab55ba0f462fd51564c920bbd10986cf2", "filename": "crates/libsyntax2/src/ast/generated.rs", "status": "modified", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs?ref=5953a348bd6102a868f303d3f732a6ec7d465833", "patch": "@@ -5,6 +5,24 @@ use {\n     SyntaxKind::*,\n };\n \n+// ArrayType\n+#[derive(Debug, Clone, Copy)]\n+pub struct ArrayType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for ArrayType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            ARRAY_TYPE => Some(ArrayType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> ArrayType<R> {}\n+\n // ConstDef\n #[derive(Debug, Clone, Copy)]\n pub struct ConstDef<R: TreeRoot = Arc<SyntaxRoot>> {\n@@ -24,6 +42,24 @@ impl<R: TreeRoot> AstNode<R> for ConstDef<R> {\n impl<R: TreeRoot> ast::NameOwner<R> for ConstDef<R> {}\n impl<R: TreeRoot> ConstDef<R> {}\n \n+// DynTraitType\n+#[derive(Debug, Clone, Copy)]\n+pub struct DynTraitType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for DynTraitType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            DYN_TRAIT_TYPE => Some(DynTraitType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> DynTraitType<R> {}\n+\n // EnumDef\n #[derive(Debug, Clone, Copy)]\n pub struct EnumDef<R: TreeRoot = Arc<SyntaxRoot>> {\n@@ -86,6 +122,42 @@ impl<R: TreeRoot> AstNode<R> for FnDef<R> {\n impl<R: TreeRoot> ast::NameOwner<R> for FnDef<R> {}\n impl<R: TreeRoot> FnDef<R> {}\n \n+// FnPointerType\n+#[derive(Debug, Clone, Copy)]\n+pub struct FnPointerType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for FnPointerType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            FN_POINTER_TYPE => Some(FnPointerType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> FnPointerType<R> {}\n+\n+// ForType\n+#[derive(Debug, Clone, Copy)]\n+pub struct ForType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for ForType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            FOR_TYPE => Some(ForType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> ForType<R> {}\n+\n // ImplItem\n #[derive(Debug, Clone, Copy)]\n pub struct ImplItem<R: TreeRoot = Arc<SyntaxRoot>> {\n@@ -104,6 +176,24 @@ impl<R: TreeRoot> AstNode<R> for ImplItem<R> {\n \n impl<R: TreeRoot> ImplItem<R> {}\n \n+// ImplTraitType\n+#[derive(Debug, Clone, Copy)]\n+pub struct ImplTraitType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for ImplTraitType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            IMPL_TRAIT_TYPE => Some(ImplTraitType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> ImplTraitType<R> {}\n+\n // Module\n #[derive(Debug, Clone, Copy)]\n pub struct Module<R: TreeRoot = Arc<SyntaxRoot>> {\n@@ -159,6 +249,132 @@ impl<R: TreeRoot> AstNode<R> for NameRef<R> {\n \n impl<R: TreeRoot> NameRef<R> {}\n \n+// NeverType\n+#[derive(Debug, Clone, Copy)]\n+pub struct NeverType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for NeverType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            NEVER_TYPE => Some(NeverType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> NeverType<R> {}\n+\n+// ParenType\n+#[derive(Debug, Clone, Copy)]\n+pub struct ParenType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for ParenType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            PAREN_TYPE => Some(ParenType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> ParenType<R> {}\n+\n+// PathType\n+#[derive(Debug, Clone, Copy)]\n+pub struct PathType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for PathType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            PATH_TYPE => Some(PathType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> PathType<R> {}\n+\n+// PlaceholderType\n+#[derive(Debug, Clone, Copy)]\n+pub struct PlaceholderType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for PlaceholderType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            PLACEHOLDER_TYPE => Some(PlaceholderType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> PlaceholderType<R> {}\n+\n+// PointerType\n+#[derive(Debug, Clone, Copy)]\n+pub struct PointerType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for PointerType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            POINTER_TYPE => Some(PointerType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> PointerType<R> {}\n+\n+// ReferenceType\n+#[derive(Debug, Clone, Copy)]\n+pub struct ReferenceType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for ReferenceType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            REFERENCE_TYPE => Some(ReferenceType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> ReferenceType<R> {}\n+\n+// SliceType\n+#[derive(Debug, Clone, Copy)]\n+pub struct SliceType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for SliceType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            SLICE_TYPE => Some(SliceType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> SliceType<R> {}\n+\n // StaticDef\n #[derive(Debug, Clone, Copy)]\n pub struct StaticDef<R: TreeRoot = Arc<SyntaxRoot>> {\n@@ -216,6 +432,24 @@ impl<R: TreeRoot> AstNode<R> for TraitDef<R> {\n impl<R: TreeRoot> ast::NameOwner<R> for TraitDef<R> {}\n impl<R: TreeRoot> TraitDef<R> {}\n \n+// TupleType\n+#[derive(Debug, Clone, Copy)]\n+pub struct TupleType<R: TreeRoot = Arc<SyntaxRoot>> {\n+    syntax: SyntaxNode<R>,\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for TupleType<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            TUPLE_TYPE => Some(TupleType { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+}\n+\n+impl<R: TreeRoot> TupleType<R> {}\n+\n // TypeDef\n #[derive(Debug, Clone, Copy)]\n pub struct TypeDef<R: TreeRoot = Arc<SyntaxRoot>> {\n@@ -235,3 +469,61 @@ impl<R: TreeRoot> AstNode<R> for TypeDef<R> {\n impl<R: TreeRoot> ast::NameOwner<R> for TypeDef<R> {}\n impl<R: TreeRoot> TypeDef<R> {}\n \n+// TypeRef\n+#[derive(Debug, Clone, Copy)]\n+pub enum TypeRef<R: TreeRoot = Arc<SyntaxRoot>> {\n+    ParenType(ParenType<R>),\n+    TupleType(TupleType<R>),\n+    NeverType(NeverType<R>),\n+    PathType(PathType<R>),\n+    PointerType(PointerType<R>),\n+    ArrayType(ArrayType<R>),\n+    SliceType(SliceType<R>),\n+    ReferenceType(ReferenceType<R>),\n+    PlaceholderType(PlaceholderType<R>),\n+    FnPointerType(FnPointerType<R>),\n+    ForType(ForType<R>),\n+    ImplTraitType(ImplTraitType<R>),\n+    DynTraitType(DynTraitType<R>),\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for TypeRef<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            PAREN_TYPE => Some(TypeRef::ParenType(ParenType { syntax })),\n+            TUPLE_TYPE => Some(TypeRef::TupleType(TupleType { syntax })),\n+            NEVER_TYPE => Some(TypeRef::NeverType(NeverType { syntax })),\n+            PATH_TYPE => Some(TypeRef::PathType(PathType { syntax })),\n+            POINTER_TYPE => Some(TypeRef::PointerType(PointerType { syntax })),\n+            ARRAY_TYPE => Some(TypeRef::ArrayType(ArrayType { syntax })),\n+            SLICE_TYPE => Some(TypeRef::SliceType(SliceType { syntax })),\n+            REFERENCE_TYPE => Some(TypeRef::ReferenceType(ReferenceType { syntax })),\n+            PLACEHOLDER_TYPE => Some(TypeRef::PlaceholderType(PlaceholderType { syntax })),\n+            FN_POINTER_TYPE => Some(TypeRef::FnPointerType(FnPointerType { syntax })),\n+            FOR_TYPE => Some(TypeRef::ForType(ForType { syntax })),\n+            IMPL_TRAIT_TYPE => Some(TypeRef::ImplTraitType(ImplTraitType { syntax })),\n+            DYN_TRAIT_TYPE => Some(TypeRef::DynTraitType(DynTraitType { syntax })),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> {\n+        match self {\n+            TypeRef::ParenType(inner) => inner.syntax(),\n+            TypeRef::TupleType(inner) => inner.syntax(),\n+            TypeRef::NeverType(inner) => inner.syntax(),\n+            TypeRef::PathType(inner) => inner.syntax(),\n+            TypeRef::PointerType(inner) => inner.syntax(),\n+            TypeRef::ArrayType(inner) => inner.syntax(),\n+            TypeRef::SliceType(inner) => inner.syntax(),\n+            TypeRef::ReferenceType(inner) => inner.syntax(),\n+            TypeRef::PlaceholderType(inner) => inner.syntax(),\n+            TypeRef::FnPointerType(inner) => inner.syntax(),\n+            TypeRef::ForType(inner) => inner.syntax(),\n+            TypeRef::ImplTraitType(inner) => inner.syntax(),\n+            TypeRef::DynTraitType(inner) => inner.syntax(),\n+        }\n+    }\n+}\n+\n+impl<R: TreeRoot> TypeRef<R> {}\n+"}, {"sha": "f83da032686a67d76868f77b91f8e6f58b7e0a2a", "filename": "crates/libsyntax2/src/ast/generated.rs.tera", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=5953a348bd6102a868f303d3f732a6ec7d465833", "patch": "@@ -6,6 +6,32 @@ use {\n };\n {% for node, methods in ast %}\n // {{ node }}\n+{%- if methods.enum %}\n+#[derive(Debug, Clone, Copy)]\n+pub enum {{ node }}<R: TreeRoot = Arc<SyntaxRoot>> {\n+{%- for kind in methods.enum %}\n+    {{ kind }}({{ kind }}<R>),\n+{%- endfor %}\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for {{ node }}<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+{%- for kind in methods.enum %}\n+            {{ kind | SCREAM }} => Some({{ node }}::{{ kind }}({{ kind }} { syntax })),\n+{%- endfor %}\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> {\n+        match self {\n+{%- for kind in methods.enum %}\n+            {{ node }}::{{ kind }}(inner) => inner.syntax(),\n+{%- endfor %}\n+        }\n+    }\n+}\n+{% else %}\n #[derive(Debug, Clone, Copy)]\n pub struct {{ node }}<R: TreeRoot = Arc<SyntaxRoot>> {\n     syntax: SyntaxNode<R>,\n@@ -20,7 +46,7 @@ impl<R: TreeRoot> AstNode<R> for {{ node }}<R> {\n     }\n     fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n }\n-\n+{% endif %}\n {% if methods.traits -%}\n {%- for t in methods.traits -%}\n impl<R: TreeRoot> ast::{{ t }}<R> for {{ node }}<R> {}"}, {"sha": "679e292a2cd1ad85344ec8eddf46eaea7da7ea38", "filename": "crates/libsyntax2/src/ast/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs?ref=5953a348bd6102a868f303d3f732a6ec7d465833", "patch": "@@ -82,3 +82,26 @@ impl<R: TreeRoot> NameRef<R> {\n         ident.leaf_text().unwrap()\n     }\n }\n+\n+impl <R: TreeRoot> ImplItem<R> {\n+    pub fn target_type(&self) -> Option<TypeRef<R>> {\n+        match self.target() {\n+            (Some(t), None) | (_, Some(t)) => Some(t),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn target_trait(&self) -> Option<TypeRef<R>> {\n+        match self.target() {\n+            (Some(t), Some(_)) => Some(t),\n+            _ => None,\n+        }\n+    }\n+\n+    fn target(&self) -> (Option<TypeRef<R>>, Option<TypeRef<R>>) {\n+        let mut types = self.syntax().children().filter_map(TypeRef::cast);\n+        let first = types.next();\n+        let second = types.next();\n+        (first, second)\n+    }\n+}"}, {"sha": "3641b65e2599922f130a6d4a715f327d6728685a", "filename": "crates/libsyntax2/src/grammar.ron", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron?ref=5953a348bd6102a868f303d3f732a6ec7d465833", "patch": "@@ -232,5 +232,35 @@ Grammar(\n         \"ImplItem\": (),\n         \"Name\": (),\n         \"NameRef\": (),\n+\n+        \"ParenType\": (),\n+        \"TupleType\": (),\n+        \"NeverType\": (),\n+        \"PathType\": (),\n+        \"PointerType\": (),\n+        \"ArrayType\": (),\n+        \"SliceType\": (),\n+        \"ReferenceType\": (),\n+        \"PlaceholderType\": (),\n+        \"FnPointerType\": (),\n+        \"ForType\": (),\n+        \"ImplTraitType\": (),\n+        \"DynTraitType\": (),\n+\n+        \"TypeRef\": ( enum: [\n+            \"ParenType\",\n+            \"TupleType\",\n+            \"NeverType\",\n+            \"PathType\",\n+            \"PointerType\",\n+            \"ArrayType\",\n+            \"SliceType\",\n+            \"ReferenceType\",\n+            \"PlaceholderType\",\n+            \"FnPointerType\",\n+            \"ForType\",\n+            \"ImplTraitType\",\n+            \"DynTraitType\",\n+        ])\n     },\n )"}]}