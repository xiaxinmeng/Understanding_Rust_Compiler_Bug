{"sha": "ccd8498afbb371939b7decdbee712f726ccbded3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZDg0OThhZmJiMzcxOTM5YjdkZWNkYmVlNzEyZjcyNmNjYmRlZDM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-13T16:06:01Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T00:39:36Z"}, "message": "syntax: fix fallout from using ptr::P.", "tree": {"sha": "8939c9dba98ee7a2f624e82c3c72dcf33576d350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8939c9dba98ee7a2f624e82c3c72dcf33576d350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccd8498afbb371939b7decdbee712f726ccbded3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd8498afbb371939b7decdbee712f726ccbded3", "html_url": "https://github.com/rust-lang/rust/commit/ccd8498afbb371939b7decdbee712f726ccbded3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccd8498afbb371939b7decdbee712f726ccbded3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6fb338d01864e3801cab9f76d608f204d11fc27", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6fb338d01864e3801cab9f76d608f204d11fc27", "html_url": "https://github.com/rust-lang/rust/commit/d6fb338d01864e3801cab9f76d608f204d11fc27"}], "stats": {"total": 3217, "additions": 1529, "deletions": 1688}, "files": [{"sha": "1400e494917f1ad13612d9a1fe0de6993b387720", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -22,7 +22,7 @@\n //! for the `Code` associated with a particular NodeId.\n \n use abi;\n-use ast::{P, Block, FnDecl, NodeId};\n+use ast::{Block, FnDecl, NodeId};\n use ast;\n use ast_map::{Node};\n use ast_map;\n@@ -39,16 +39,16 @@ use visit;\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n-pub struct FnLikeNode { node: ast_map::Node }\n+pub struct FnLikeNode<'a> { node: ast_map::Node<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object\n /// corresponds to some FnLikeNode.\n pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n-    pub decl: P<FnDecl>,\n-    pub body: P<Block>,\n+    pub decl: &'a FnDecl,\n+    pub body: &'a Block,\n     pub kind: visit::FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -78,12 +78,12 @@ impl MaybeFnLike for ast::Expr {\n /// Carries either an FnLikeNode or a Block, as these are the two\n /// constructs that correspond to \"code\" (as in, something from which\n /// we can construct a control-flow graph).\n-pub enum Code {\n-    FnLikeCode(FnLikeNode),\n-    BlockCode(P<Block>),\n+pub enum Code<'a> {\n+    FnLikeCode(FnLikeNode<'a>),\n+    BlockCode(&'a Block),\n }\n \n-impl Code {\n+impl<'a> Code<'a> {\n     pub fn id(&self) -> ast::NodeId {\n         match *self {\n             FnLikeCode(node) => node.id(),\n@@ -115,32 +115,32 @@ impl Code {\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n     ident:    ast::Ident,\n-    decl:     P<ast::FnDecl>,\n+    decl:     &'a ast::FnDecl,\n     style:    ast::FnStyle,\n     abi:      abi::Abi,\n     generics: &'a ast::Generics,\n-    body:     P<Block>,\n+    body:     &'a Block,\n     id:       ast::NodeId,\n     span:     Span\n }\n \n /// These are all the components one can extract from a closure expr\n /// for use when implementing FnLikeNode operations.\n-struct ClosureParts {\n-    decl: P<FnDecl>,\n-    body: P<Block>,\n+struct ClosureParts<'a> {\n+    decl: &'a FnDecl,\n+    body: &'a Block,\n     id: NodeId,\n     span: Span\n }\n \n-impl ClosureParts {\n-    fn new(d: P<FnDecl>, b: P<Block>, id: NodeId, s: Span) -> ClosureParts {\n+impl<'a> ClosureParts<'a> {\n+    fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span) -> ClosureParts<'a> {\n         ClosureParts { decl: d, body: b, id: id, span: s }\n     }\n }\n \n-impl FnLikeNode {\n-    pub fn to_fn_parts<'a>(&'a self) -> FnParts<'a> {\n+impl<'a> FnLikeNode<'a> {\n+    pub fn to_fn_parts(self) -> FnParts<'a> {\n         FnParts {\n             decl: self.decl(),\n             body: self.body(),\n@@ -150,31 +150,31 @@ impl FnLikeNode {\n         }\n     }\n \n-    pub fn body<'a>(&'a self) -> P<Block> {\n-        self.handle(|i: ItemFnParts|     i.body,\n-                    |m: &'a ast::Method| m.pe_body(),\n-                    |c: ClosureParts|    c.body)\n+    pub fn body(self) -> &'a Block {\n+        self.handle(|i: ItemFnParts<'a>|  &*i.body,\n+                    |m: &'a ast::Method|  m.pe_body(),\n+                    |c: ClosureParts<'a>| c.body)\n     }\n \n-    pub fn decl<'a>(&'a self) -> P<FnDecl> {\n-        self.handle(|i: ItemFnParts|     i.decl,\n-                    |m: &'a ast::Method| m.pe_fn_decl(),\n-                    |c: ClosureParts|    c.decl)\n+    pub fn decl(self) -> &'a FnDecl {\n+        self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n+                    |m: &'a ast::Method|  m.pe_fn_decl(),\n+                    |c: ClosureParts<'a>| c.decl)\n     }\n \n-    pub fn span<'a>(&'a self) -> Span {\n+    pub fn span(self) -> Span {\n         self.handle(|i: ItemFnParts|     i.span,\n                     |m: &'a ast::Method| m.span,\n                     |c: ClosureParts|    c.span)\n     }\n \n-    pub fn id<'a>(&'a self) -> NodeId {\n+    pub fn id(self) -> NodeId {\n         self.handle(|i: ItemFnParts|     i.id,\n                     |m: &'a ast::Method| m.id,\n                     |c: ClosureParts|    c.id)\n     }\n \n-    pub fn kind<'a>(&'a self) -> visit::FnKind<'a> {\n+    pub fn kind(self) -> visit::FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n             visit::FkItemFn(p.ident, p.generics, p.style, p.abi)\n         };\n@@ -187,33 +187,33 @@ impl FnLikeNode {\n         self.handle(item, method, closure)\n     }\n \n-    fn handle<'a, A>(&'a self,\n-                     item_fn: |ItemFnParts<'a>| -> A,\n-                     method: |&'a ast::Method| -> A,\n-                     closure: |ClosureParts| -> A) -> A {\n+    fn handle<A>(self,\n+                 item_fn: |ItemFnParts<'a>| -> A,\n+                 method: |&'a ast::Method| -> A,\n+                 closure: |ClosureParts<'a>| -> A) -> A {\n         match self.node {\n-            ast_map::NodeItem(ref i) => match i.node {\n-                ast::ItemFn(decl, style, abi, ref generics, block) =>\n+            ast_map::NodeItem(i) => match i.node {\n+                ast::ItemFn(ref decl, style, abi, ref generics, ref block) =>\n                     item_fn(ItemFnParts{\n-                        ident: i.ident, decl: decl, style: style, body: block,\n+                        ident: i.ident, decl: &**decl, style: style, body: &**block,\n                         generics: generics, abi: abi, id: i.id, span: i.span\n                     }),\n                 _ => fail!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeTraitItem(ref t) => match **t {\n+            ast_map::NodeTraitItem(t) => match *t {\n                 ast::ProvidedMethod(ref m) => method(&**m),\n                 _ => fail!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeImplItem(ref ii) => {\n-                match **ii {\n+            ast_map::NodeImplItem(ii) => {\n+                match *ii {\n                     ast::MethodImplItem(ref m) => method(&**m),\n                 }\n             }\n-            ast_map::NodeExpr(ref e) => match e.node {\n+            ast_map::NodeExpr(e) => match e.node {\n                 ast::ExprFnBlock(_, ref decl, ref block) =>\n-                    closure(ClosureParts::new(*decl, *block, e.id, e.span)),\n+                    closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 ast::ExprProc(ref decl, ref block) =>\n-                    closure(ClosureParts::new(*decl, *block, e.id, e.span)),\n+                    closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 _ => fail!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => fail!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "becfe715f29e2cd844014e8c86945a09b19eace6", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 101, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -19,12 +19,12 @@ use codemap::Span;\n use owned_slice::OwnedSlice;\n use parse::token;\n use print::pprust;\n+use ptr::P;\n use visit::Visitor;\n use visit;\n \n use std::cell::Cell;\n use std::cmp;\n-use std::gc::{Gc, GC};\n use std::u32;\n \n pub fn path_name_i(idents: &[Ident]) -> String {\n@@ -98,7 +98,7 @@ pub fn unop_to_string(op: UnOp) -> &'static str {\n     }\n }\n \n-pub fn is_path(e: Gc<Expr>) -> bool {\n+pub fn is_path(e: P<Expr>) -> bool {\n     return match e.node { ExprPath(_) => true, _ => false };\n }\n \n@@ -166,21 +166,6 @@ pub fn float_ty_to_string(t: FloatTy) -> String {\n     }\n }\n \n-pub fn is_call_expr(e: Gc<Expr>) -> bool {\n-    match e.node { ExprCall(..) => true, _ => false }\n-}\n-\n-pub fn block_from_expr(e: Gc<Expr>) -> P<Block> {\n-    P(Block {\n-        view_items: Vec::new(),\n-        stmts: Vec::new(),\n-        expr: Some(e),\n-        id: e.id,\n-        rules: DefaultBlock,\n-        span: e.span\n-    })\n-}\n-\n // convert a span and an identifier to the corresponding\n // 1-segment path\n pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n@@ -197,10 +182,12 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     }\n }\n \n-pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> Gc<Pat> {\n-    box(GC) ast::Pat { id: id,\n-                node: PatIdent(BindByValue(MutImmutable), codemap::Spanned{span:s, node:i}, None),\n-                span: s }\n+pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> P<Pat> {\n+    P(Pat {\n+        id: id,\n+        node: PatIdent(BindByValue(MutImmutable), codemap::Spanned{span:s, node:i}, None),\n+        span: s\n+    })\n }\n \n pub fn name_to_dummy_lifetime(name: Name) -> Lifetime {\n@@ -226,57 +213,6 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n-pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n-    match method.node {\n-        MethDecl(ident,\n-                 ref generics,\n-                 abi,\n-                 explicit_self,\n-                 fn_style,\n-                 decl,\n-                 _,\n-                 vis) => {\n-            TypeMethod {\n-                ident: ident,\n-                attrs: method.attrs.clone(),\n-                fn_style: fn_style,\n-                decl: decl,\n-                generics: generics.clone(),\n-                explicit_self: explicit_self,\n-                id: method.id,\n-                span: method.span,\n-                vis: vis,\n-                abi: abi,\n-            }\n-        },\n-        MethMac(_) => fail!(\"expected non-macro method declaration\")\n-    }\n-}\n-\n-/// extract a TypeMethod from a TraitItem. if the TraitItem is\n-/// a default, pull out the useful fields to make a TypeMethod\n-//\n-// NB: to be used only after expansion is complete, and macros are gone.\n-pub fn trait_item_to_ty_method(method: &TraitItem) -> TypeMethod {\n-    match *method {\n-        RequiredMethod(ref m) => (*m).clone(),\n-        ProvidedMethod(ref m) => trait_method_to_ty_method(&**m),\n-    }\n-}\n-\n-pub fn split_trait_methods(trait_methods: &[TraitItem])\n-    -> (Vec<TypeMethod> , Vec<Gc<Method>> ) {\n-    let mut reqd = Vec::new();\n-    let mut provd = Vec::new();\n-    for trt_method in trait_methods.iter() {\n-        match *trt_method {\n-            RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n-            ProvidedMethod(m) => provd.push(m)\n-        }\n-    };\n-    (reqd, provd)\n-}\n-\n pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     match field.node.kind {\n         ast::NamedField(_, v) | ast::UnnamedField(v) => v\n@@ -603,13 +539,6 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n     visitor.result.get()\n }\n \n-pub fn is_item_impl(item: Gc<ast::Item>) -> bool {\n-    match item.node {\n-        ItemImpl(..) => true,\n-        _            => false\n-    }\n-}\n-\n pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n     if !it(pat) {\n         return false;\n@@ -678,7 +607,7 @@ pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {\n \n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n-pub fn pat_is_ident(pat: Gc<ast::Pat>) -> bool {\n+pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n     match pat.node {\n         ast::PatIdent(..) => true,\n         _ => false,\n@@ -713,28 +642,13 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n }\n \n /// Returns true if this literal is a string and false otherwise.\n-pub fn lit_is_str(lit: Gc<Lit>) -> bool {\n+pub fn lit_is_str(lit: &Lit) -> bool {\n     match lit.node {\n         LitStr(..) => true,\n         _ => false,\n     }\n }\n \n-pub fn get_inner_tys(ty: P<Ty>) -> Vec<P<Ty>> {\n-    match ty.node {\n-        ast::TyRptr(_, mut_ty) | ast::TyPtr(mut_ty) => {\n-            vec!(mut_ty.ty)\n-        }\n-        ast::TyBox(ty)\n-        | ast::TyVec(ty)\n-        | ast::TyUniq(ty)\n-        | ast::TyFixedLengthVec(ty, _) => vec!(ty),\n-        ast::TyTup(ref tys) => tys.clone(),\n-        ast::TyParen(ty) => get_inner_tys(ty),\n-        _ => Vec::new()\n-    }\n-}\n-\n /// Returns true if the static with the given mutability and attributes\n /// has a significant address and false otherwise.\n pub fn static_has_significant_address(mutbl: ast::Mutability,\n@@ -757,13 +671,13 @@ pub trait PostExpansionMethod {\n     fn pe_abi(&self) -> Abi;\n     fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n     fn pe_fn_style(&self) -> ast::FnStyle;\n-    fn pe_fn_decl(&self) -> P<ast::FnDecl>;\n-    fn pe_body(&self) -> P<ast::Block>;\n+    fn pe_fn_decl<'a>(&'a self) -> &'a ast::FnDecl;\n+    fn pe_body<'a>(&'a self) -> &'a ast::Block;\n     fn pe_vis(&self) -> ast::Visibility;\n }\n \n macro_rules! mf_method{\n-    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n+    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:expr) => {\n         fn $meth_name<'a>(&'a self) -> $field_ty {\n             match self.node {\n                 $field_pat => $result,\n@@ -784,8 +698,8 @@ impl PostExpansionMethod for Method {\n     mf_method!(pe_explicit_self,&'a ast::ExplicitSelf,\n                MethDecl(_,_,_,ref explicit_self,_,_,_,_),explicit_self)\n     mf_method!(pe_fn_style,ast::FnStyle,MethDecl(_,_,_,_,fn_style,_,_,_),fn_style)\n-    mf_method!(pe_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,_,decl,_,_),decl)\n-    mf_method!(pe_body,P<ast::Block>,MethDecl(_,_,_,_,_,_,body,_),body)\n+    mf_method!(pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,_,ref decl,_,_),&**decl)\n+    mf_method!(pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,_,ref body,_),&**body)\n     mf_method!(pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,_,vis),vis)\n }\n "}, {"sha": "80e4d148bdec8c16171114d7deee05090411e708", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -18,10 +18,10 @@ use diagnostic::SpanHandler;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n use parse::token;\n+use ptr::P;\n \n use std::collections::HashSet;\n use std::collections::BitvSet;\n-use std::gc::{Gc, GC};\n \n local_data_key!(used_attrs: BitvSet)\n \n@@ -50,7 +50,7 @@ pub trait AttrMetaMethods {\n     /// containing a string, otherwise None.\n     fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]>;\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]>;\n }\n \n impl AttrMetaMethods for Attribute {\n@@ -65,7 +65,7 @@ impl AttrMetaMethods for Attribute {\n     fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         self.node.value.meta_item_list()\n     }\n }\n@@ -91,7 +91,7 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         match self.node {\n             MetaList(_, ref l) => Some(l.as_slice()),\n             _ => None\n@@ -100,67 +100,66 @@ impl AttrMetaMethods for MetaItem {\n }\n \n // Annoying, but required to get test_cfg to work\n-impl AttrMetaMethods for Gc<MetaItem> {\n+impl AttrMetaMethods for P<MetaItem> {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         (**self).meta_item_list()\n     }\n }\n \n \n pub trait AttributeMethods {\n-    fn meta(&self) -> Gc<MetaItem>;\n-    fn desugar_doc(&self) -> Attribute;\n+    fn meta<'a>(&'a self) -> &'a MetaItem;\n+    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T;\n }\n \n impl AttributeMethods for Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    fn meta(&self) -> Gc<MetaItem> {\n-        self.node.value\n+    fn meta<'a>(&'a self) -> &'a MetaItem {\n+        &*self.node.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n     /// comment like `///` or `/** */`. (Returns self unchanged for\n     /// non-sugared doc attributes.)\n-    fn desugar_doc(&self) -> Attribute {\n+    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T {\n         if self.node.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(strip_doc_comment_decoration(\n                         comment.get()).as_slice()));\n             if self.node.style == ast::AttrOuter {\n-                mk_attr_outer(self.node.id, meta)\n+                f(&mk_attr_outer(self.node.id, meta))\n             } else {\n-                mk_attr_inner(self.node.id, meta)\n+                f(&mk_attr_inner(self.node.id, meta))\n             }\n         } else {\n-            *self\n+            f(self)\n         }\n     }\n }\n \n /* Constructors */\n \n pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> Gc<MetaItem> {\n+                              -> P<MetaItem> {\n     let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n }\n \n pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n-                          -> Gc<MetaItem> {\n-    box(GC) dummy_spanned(MetaNameValue(name, value))\n+                          -> P<MetaItem> {\n+    P(dummy_spanned(MetaNameValue(name, value)))\n }\n \n-pub fn mk_list_item(name: InternedString,\n-                    items: Vec<Gc<MetaItem>>) -> Gc<MetaItem> {\n-    box(GC) dummy_spanned(MetaList(name, items))\n+pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n+    P(dummy_spanned(MetaList(name, items)))\n }\n \n-pub fn mk_word_item(name: InternedString) -> Gc<MetaItem> {\n-    box(GC) dummy_spanned(MetaWord(name))\n+pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n+    P(dummy_spanned(MetaWord(name)))\n }\n \n local_data_key!(next_attr_id: uint)\n@@ -172,7 +171,7 @@ pub fn mk_attr_id() -> AttrId {\n }\n \n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n+pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrInner,\n@@ -182,7 +181,7 @@ pub fn mk_attr_inner(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n }\n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n+pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrOuter,\n@@ -199,8 +198,8 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n     let attr = Attribute_ {\n         id: id,\n         style: style,\n-        value: box(GC) spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n-                                              lit)),\n+        value: P(spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n+                                               lit))),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -210,8 +209,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n /// Check if `needle` occurs in `haystack` by a structural\n /// comparison. This is slightly subtle, and relies on ignoring the\n /// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[Gc<ast::MetaItem>],\n-                needle: Gc<ast::MetaItem>) -> bool {\n+pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n     debug!(\"attr::contains (name={})\", needle.name());\n     haystack.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n@@ -234,7 +232,7 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[Gc<MetaItem>], name: &str)\n+pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n                                      -> Option<InternedString> {\n     items.iter()\n          .rev()\n@@ -244,28 +242,25 @@ pub fn last_meta_item_value_str_by_name(items: &[Gc<MetaItem>], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n+pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n-    let mut v = items.iter()\n-        .map(|&mi| (mi.name(), mi))\n-        .collect::<Vec<(InternedString, Gc<MetaItem>)> >();\n+    let mut v = items.move_iter()\n+        .map(|mi| (mi.name(), mi))\n+        .collect::<Vec<(InternedString, P<MetaItem>)>>();\n \n     v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n     // There doesn't seem to be a more optimal way to do this\n-    v.move_iter().map(|(_, m)| {\n-        match m.node {\n-            MetaList(ref n, ref mis) => {\n-                box(GC) Spanned {\n-                    node: MetaList((*n).clone(),\n-                                   sort_meta_items(mis.as_slice())),\n-                    .. /*bad*/ (*m).clone()\n-                }\n-            }\n-            _ => m\n+    v.move_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n+        Spanned {\n+            node: match node {\n+                MetaList(n, mis) => MetaList(n, sort_meta_items(mis)),\n+                _ => node\n+            },\n+            span: span\n         }\n-    }).collect()\n+    })).collect()\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n@@ -318,8 +313,8 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(not(bar))]`) == false\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"a\")]`) == true\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"b\")]`) == false\n-pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n-    (cfg: &[Gc<MetaItem>], mut metas: It) -> bool {\n+pub fn test_cfg<'a, AM: AttrMetaMethods, It: Iterator<&'a AM>>\n+    (cfg: &[P<MetaItem>], mut metas: It) -> bool {\n     // having no #[cfg(...)] attributes counts as matching.\n     let mut no_cfgs = true;\n \n@@ -344,10 +339,10 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n                                 // not match.\n                                 !not_cfgs.iter().all(|mi| {\n                                     debug!(\"cfg(not({}[...]))\", mi.name());\n-                                    contains(cfg, *mi)\n+                                    contains(cfg, &**mi)\n                                 })\n                             }\n-                            _ => contains(cfg, *cfg_mi)\n+                            _ => contains(cfg, &**cfg_mi)\n                         }\n                     })\n                 }\n@@ -397,7 +392,7 @@ pub fn find_stability_generic<'a,\n         };\n \n         return Some((Stability {\n-                level: level,\n+            level: level,\n                 text: attr.value_str()\n             }, attr));\n     }\n@@ -412,7 +407,7 @@ pub fn find_stability(attrs: &[Attribute]) -> Option<Stability> {\n     })\n }\n \n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[Gc<MetaItem>]) {\n+pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n         let name = meta.name();"}, {"sha": "faa3946b74d0f75dd6652103d25a2f9a092a78fc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -543,10 +543,9 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n     Ok(())\n }\n \n-pub fn expect<T:Clone>(diag: &SpanHandler, opt: Option<T>, msg: || -> String)\n-              -> T {\n+pub fn expect<T>(diag: &SpanHandler, opt: Option<T>, msg: || -> String) -> T {\n     match opt {\n-       Some(ref t) => (*t).clone(),\n-       None => diag.handler().bug(msg().as_slice()),\n+        Some(t) => t,\n+        None => diag.handler().bug(msg().as_slice()),\n     }\n }"}, {"sha": "132b59c89b203069bc25a182715cf3e4615c0810", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -10,13 +10,13 @@\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::gc::Gc;\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n use ext::base::{ExtCtxt, MacExpr, MacItem, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n+use ptr::P;\n \n local_data_key!(registered_diagnostics: RefCell<HashMap<Name, Option<Name>>>)\n local_data_key!(used_diagnostics: RefCell<HashMap<Name, Span>>)\n@@ -116,7 +116,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n \n     let (count, expr) = with_used_diagnostics(|diagnostics_in_use| {\n         with_registered_diagnostics(|diagnostics| {\n-            let descriptions: Vec<Gc<ast::Expr>> = diagnostics\n+            let descriptions: Vec<P<ast::Expr>> = diagnostics\n                 .iter().filter_map(|(code, description)| {\n                 if !diagnostics_in_use.contains_key(code) {\n                     ecx.span_warn(span, format!("}, {"sha": "4b8c3376cad2ec91282016d333eca2f3992d0046", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -18,8 +18,7 @@ use ext::base;\n use ext::base::*;\n use parse::token::InternedString;\n use parse::token;\n-\n-use std::gc::GC;\n+use ptr::P;\n \n enum State {\n     Asm,\n@@ -199,7 +198,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    MacExpr::new(box(GC) ast::Expr {\n+    MacExpr::new(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(asm.get()),\n@@ -212,5 +211,5 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             dialect: dialect\n         }),\n         span: sp\n-    })\n+    }))\n }"}, {"sha": "6e25b6b73ade6fa83fdfdca16bebe5ae7e0ae0cb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -18,6 +18,7 @@ use parse;\n use parse::parser;\n use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n+use ptr::P;\n use util::small_vector::SmallVector;\n use ext::mtwt;\n use fold::Folder;\n@@ -43,18 +44,18 @@ pub trait ItemDecorator {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>,\n-              push: |Gc<ast::Item>|);\n+              meta_item: &ast::MetaItem,\n+              item: &ast::Item,\n+              push: |P<ast::Item>|);\n }\n \n-impl ItemDecorator for fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>, |Gc<ast::Item>|) {\n+impl ItemDecorator for fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, |P<ast::Item>|) {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>,\n-              push: |Gc<ast::Item>|) {\n+              meta_item: &ast::MetaItem,\n+              item: &ast::Item,\n+              push: |P<ast::Item>|) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }\n }\n@@ -63,18 +64,18 @@ pub trait ItemModifier {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>)\n-              -> Gc<ast::Item>;\n+              meta_item: &ast::MetaItem,\n+              item: P<ast::Item>)\n+              -> P<ast::Item>;\n }\n \n-impl ItemModifier for fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>) -> Gc<ast::Item> {\n+impl ItemModifier for fn(&mut ExtCtxt, Span, &ast::MetaItem, P<ast::Item>) -> P<ast::Item> {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>)\n-              -> Gc<ast::Item> {\n+              meta_item: &ast::MetaItem,\n+              item: P<ast::Item>)\n+              -> P<ast::Item> {\n         (*self)(ecx, span, meta_item, item)\n     }\n }\n@@ -128,99 +129,99 @@ impl IdentMacroExpander for IdentMacroExpanderFn {\n /// methods are spliced into the AST at the callsite of the macro (or\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n-    /// Define a new macro.\n+    /// Attempt to define a new macro.\n     // this should go away; the idea that a macro might expand into\n     // either a macro definition or an expression, depending on what\n     // the context wants, is kind of silly.\n-    fn make_def(&self) -> Option<MacroDef> {\n+    fn make_def(&mut self) -> Option<MacroDef> {\n         None\n     }\n     /// Create an expression.\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n         None\n     }\n     /// Create zero or more items.\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n         None\n     }\n \n     /// Create zero or more methods.\n-    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::Method>>> {\n         None\n     }\n \n     /// Create a pattern.\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<Self>) -> Option<P<ast::Pat>> {\n         None\n     }\n \n     /// Create a statement.\n     ///\n     /// By default this attempts to create an expression statement,\n     /// returning None if that fails.\n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+    fn make_stmt(self: Box<Self>) -> Option<P<ast::Stmt>> {\n         self.make_expr()\n-            .map(|e| box(GC) codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n+            .map(|e| P(codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID))))\n     }\n }\n \n /// A convenience type for macros that return a single expression.\n pub struct MacExpr {\n-    e: Gc<ast::Expr>,\n+    e: P<ast::Expr>\n }\n impl MacExpr {\n-    pub fn new(e: Gc<ast::Expr>) -> Box<MacResult+'static> {\n+    pub fn new(e: P<ast::Expr>) -> Box<MacResult+'static> {\n         box MacExpr { e: e } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacExpr {\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<MacExpr>) -> Option<P<ast::Expr>> {\n         Some(self.e)\n     }\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<MacExpr>) -> Option<P<ast::Pat>> {\n         match self.e.node {\n-            ast::ExprLit(_) => Some(box(GC) ast::Pat {\n+            ast::ExprLit(_) => Some(P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::PatLit(self.e),\n-                span: self.e.span\n-            }),\n+                span: self.e.span,\n+                node: ast::PatLit(self.e)\n+            })),\n             _ => None\n         }\n     }\n }\n /// A convenience type for macros that return a single pattern.\n pub struct MacPat {\n-    p: Gc<ast::Pat>,\n+    p: P<ast::Pat>\n }\n impl MacPat {\n-    pub fn new(p: Gc<ast::Pat>) -> Box<MacResult+'static> {\n+    pub fn new(p: P<ast::Pat>) -> Box<MacResult+'static> {\n         box MacPat { p: p } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacPat {\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<MacPat>) -> Option<P<ast::Pat>> {\n         Some(self.p)\n     }\n }\n /// A convenience type for macros that return a single item.\n pub struct MacItem {\n-    i: Gc<ast::Item>\n+    i: P<ast::Item>\n }\n impl MacItem {\n-    pub fn new(i: Gc<ast::Item>) -> Box<MacResult+'static> {\n+    pub fn new(i: P<ast::Item>) -> Box<MacResult+'static> {\n         box MacItem { i: i } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacItem {\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<MacItem>) -> Option<SmallVector<P<ast::Item>>> {\n         Some(SmallVector::one(self.i))\n     }\n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n-        Some(box(GC) codemap::respan(\n+    fn make_stmt(self: Box<MacItem>) -> Option<P<ast::Stmt>> {\n+        Some(P(codemap::respan(\n             self.i.span,\n             ast::StmtDecl(\n-                box(GC) codemap::respan(self.i.span, ast::DeclItem(self.i)),\n-                ast::DUMMY_NODE_ID)))\n+                P(codemap::respan(self.i.span, ast::DeclItem(self.i))),\n+                ast::DUMMY_NODE_ID))))\n     }\n }\n \n@@ -250,17 +251,17 @@ impl DummyResult {\n     }\n \n     /// A plain dummy expression.\n-    pub fn raw_expr(sp: Span) -> Gc<ast::Expr> {\n-        box(GC) ast::Expr {\n+    pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n+        P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(box(GC) codemap::respan(sp, ast::LitNil)),\n+            node: ast::ExprLit(P(codemap::respan(sp, ast::LitNil))),\n             span: sp,\n-        }\n+        })\n     }\n \n     /// A plain dummy pattern.\n-    pub fn raw_pat(sp: Span) -> Gc<ast::Pat> {\n-        box(GC) ast::Pat {\n+    pub fn raw_pat(sp: Span) -> ast::Pat {\n+        ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::PatWild(ast::PatWildSingle),\n             span: sp,\n@@ -270,31 +271,31 @@ impl DummyResult {\n }\n \n impl MacResult for DummyResult {\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<DummyResult>) -> Option<P<ast::Expr>> {\n         Some(DummyResult::raw_expr(self.span))\n     }\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n-        Some(DummyResult::raw_pat(self.span))\n+    fn make_pat(self: Box<DummyResult>) -> Option<P<ast::Pat>> {\n+        Some(P(DummyResult::raw_pat(self.span)))\n     }\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Item>>> {\n         // this code needs a comment... why not always just return the Some() ?\n         if self.expr_only {\n             None\n         } else {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Method>>> {\n         if self.expr_only {\n             None\n         } else {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n-        Some(box(GC) codemap::respan(self.span,\n-                              ast::StmtExpr(DummyResult::raw_expr(self.span),\n-                                            ast::DUMMY_NODE_ID)))\n+    fn make_stmt(self: Box<DummyResult>) -> Option<P<ast::Stmt>> {\n+        Some(P(codemap::respan(self.span,\n+                               ast::StmtExpr(DummyResult::raw_expr(self.span),\n+                                             ast::DUMMY_NODE_ID))))\n     }\n }\n \n@@ -461,7 +462,7 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<Gc<ast::Item>>,\n+    pub exported_macros: Vec<P<ast::Item>>,\n \n     pub syntax_env: SyntaxEnv,\n }\n@@ -482,7 +483,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     #[deprecated = \"Replaced with `expander().fold_expr()`\"]\n-    pub fn expand_expr(&mut self, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    pub fn expand_expr(&mut self, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expander().fold_expr(e)\n     }\n \n@@ -595,12 +596,12 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_string(cx: &mut ExtCtxt, expr: Gc<ast::Expr>, err_msg: &str)\n-                   -> Option<(InternedString, ast::StrStyle)> {\n+pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                      -> Option<(InternedString, ast::StrStyle)> {\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n-        ast::ExprLit(l) => match l.node {\n+        ast::ExprLit(ref l) => match l.node {\n             ast::LitStr(ref s, style) => return Some(((*s).clone(), style)),\n             _ => cx.span_err(l.span, err_msg)\n         },\n@@ -651,7 +652,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n /// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> Option<Vec<Gc<ast::Expr>>> {\n+                          tts: &[ast::TokenTree]) -> Option<Vec<P<ast::Expr>>> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::EOF {"}, {"sha": "eda373c4fb806339c6d1f937c7728c82a26cf0bf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 236, "deletions": 291, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -9,19 +9,18 @@\n // except according to those terms.\n \n use abi;\n-use ast::{P, Ident, Generics, NodeId, Expr};\n+use ast::{Ident, Generics, Expr};\n use ast;\n use ast_util;\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n-use fold::Folder;\n use owned_slice::OwnedSlice;\n use parse::token::special_idents;\n use parse::token::InternedString;\n use parse::token;\n+use ptr::P;\n \n-use std::gc::{Gc, GC};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -64,7 +63,6 @@ pub trait AstBuilder {\n     fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n-    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self,\n                span: Span,\n@@ -83,140 +81,130 @@ pub trait AstBuilder {\n                     -> ast::LifetimeDef;\n \n     // statements\n-    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n-                ex: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n+    fn stmt_expr(&self, expr: P<ast::Expr>) -> P<ast::Stmt>;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> P<ast::Stmt>;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: Gc<ast::Expr>)\n-                      -> Gc<ast::Stmt>;\n-    fn stmt_item(&self, sp: Span, item: Gc<ast::Item>) -> Gc<ast::Stmt>;\n+                      ex: P<ast::Expr>)\n+                      -> P<ast::Stmt>;\n+    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt>;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n-             expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n-    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+             expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n+    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<Gc<ast::Stmt>> ,\n-                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n+                 view_items: Vec<ast::ViewItem>,\n+                 stmts: Vec<P<ast::Stmt>>,\n+                 expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n-    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr>;\n-    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr>;\n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr>;\n+    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n+    fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n-    fn expr_self(&self, span: Span) -> Gc<ast::Expr>;\n+    fn expr_self(&self, span: Span) -> P<ast::Expr>;\n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-\n-    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_field_access(&self, span: Span, expr: Gc<ast::Expr>,\n-                         ident: ast::Ident) -> Gc<ast::Expr>;\n-    fn expr_tup_field_access(&self, sp: Span, expr: Gc<ast::Expr>,\n-                             idx: uint) -> Gc<ast::Expr>;\n-    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n-                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident,\n-                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n-    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                        args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+                   lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;\n+\n+    fn expr_managed(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_field_access(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n+    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>,\n+                             idx: uint) -> P<ast::Expr>;\n+    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident>,\n+                        args: Vec<P<ast::Expr>> ) -> P<ast::Expr>;\n     fn expr_method_call(&self, span: Span,\n-                        expr: Gc<ast::Expr>, ident: ast::Ident,\n-                        args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n-    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr>;\n-    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>,\n-                 ty: P<ast::Ty>) -> Gc<ast::Expr>;\n-\n-    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path,\n-                   fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+                        expr: P<ast::Expr>, ident: ast::Ident,\n+                        args: Vec<P<ast::Expr>> ) -> P<ast::Expr>;\n+    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr>;\n+    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr>;\n+\n+    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field;\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr>;\n     fn expr_struct_ident(&self, span: Span, id: ast::Ident,\n-                         fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+                         fields: Vec<ast::Field>) -> P<ast::Expr>;\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr>;\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr>;\n \n-    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr>;\n-    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr>;\n-    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr>;\n-    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr>;\n+    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr>;\n+    fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr>;\n+    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;\n+    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;\n \n-    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n-    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr>;\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n-    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n+    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr>;\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr>;\n \n-    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_none(&self, sp: Span) -> Gc<ast::Expr>;\n+    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_none(&self, sp: Span) -> P<ast::Expr>;\n \n-    fn expr_tuple(&self, sp: Span, exprs: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr>;\n-    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr>;\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr>;\n+    fn expr_unreachable(&self, span: Span) -> P<ast::Expr>;\n \n-    fn expr_ok(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_err(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_try(&self, span: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_ok(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_err(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_try(&self, span: Span, head: P<ast::Expr>) -> P<ast::Expr>;\n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat>;\n-    fn pat_wild(&self, span: Span) -> Gc<ast::Pat>;\n-    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat>;\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat>;\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> P<ast::Pat>;\n+    fn pat_wild(&self, span: Span) -> P<ast::Pat>;\n+    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat>;\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat>;\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> Gc<ast::Pat>;\n-    fn pat_enum(&self, span: Span, path: ast::Path,\n-                subpats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n+                              bm: ast::BindingMode) -> P<ast::Pat>;\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>> ) -> P<ast::Pat>;\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat>;\n-    fn pat_tuple(&self, span: Span, pats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> P<ast::Pat>;\n+    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n \n-    fn pat_some(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n-    fn pat_none(&self, span: Span) -> Gc<ast::Pat>;\n+    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n+    fn pat_none(&self, span: Span) -> P<ast::Pat>;\n \n-    fn pat_ok(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n-    fn pat_err(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n+    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n+    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n \n-    fn arm(&self, span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm;\n+    fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm;\n     fn arm_unreachable(&self, span: Span) -> ast::Arm;\n \n-    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>, arms: Vec<ast::Arm> ) -> Gc<ast::Expr>;\n+    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm> ) -> P<ast::Expr>;\n     fn expr_if(&self, span: Span,\n-               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n-               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n-    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> Gc<ast::Expr>;\n+               cond: P<ast::Expr>, then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr>;\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr>;\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr>;\n \n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr>;\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr>;\n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr>;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> P<ast::Expr>;\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr>;\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr>;\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr>;\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n \n     fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n-                    blk: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n-    fn lambda_stmts_0(&self, span: Span,\n-                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n-    fn lambda_stmts_1(&self, span: Span,\n-                      stmts: Vec<Gc<ast::Stmt>>, ident: ast::Ident) -> Gc<ast::Expr>;\n+                    blk: Vec<P<ast::Stmt>>) -> P<ast::Expr>;\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<P<ast::Stmt>>) -> P<ast::Expr>;\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+                      ident: ast::Ident) -> P<ast::Expr>;\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute>,\n-            node: ast::Item_) -> Gc<ast::Item>;\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> P<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n@@ -228,67 +216,64 @@ pub trait AstBuilder {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> Gc<ast::Item>;\n+                    body: P<ast::Block>) -> P<ast::Item>;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n-               body: P<ast::Block>) -> Gc<ast::Item>;\n+               body: P<ast::Block>) -> P<ast::Item>;\n \n     fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> Gc<ast::Item>;\n-    fn item_enum(&self, span: Span, name: Ident,\n-                 enum_def: ast::EnumDef) -> Gc<ast::Item>;\n+                      generics: Generics) -> P<ast::Item>;\n+    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::EnumDef) -> P<ast::Item>;\n \n     fn item_struct_poly(&self,\n                         span: Span,\n                         name: Ident,\n                         struct_def: ast::StructDef,\n-                        generics: Generics) -> Gc<ast::Item>;\n-    fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::StructDef) -> Gc<ast::Item>;\n+                        generics: Generics) -> P<ast::Item>;\n+    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> P<ast::Item>;\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n                 name: Ident, attrs: Vec<ast::Attribute>,\n-                vi: Vec<ast::ViewItem>,\n-                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item>;\n+                vi: Vec<ast::ViewItem> , items: Vec<P<ast::Item>> ) -> P<ast::Item>;\n \n     fn item_static(&self,\n                    span: Span,\n                    name: Ident,\n                    ty: P<ast::Ty>,\n                    mutbl: ast::Mutability,\n-                   expr: Gc<ast::Expr>)\n-                   -> Gc<ast::Item>;\n+                   expr: P<ast::Expr>)\n+                   -> P<ast::Item>;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n                     ty: P<ast::Ty>,\n-                    generics: Generics) -> Gc<ast::Item>;\n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item>;\n+                    generics: Generics) -> P<ast::Item>;\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item>;\n \n-    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute;\n+    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem>;\n+    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem>;\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<Gc<ast::MetaItem>>)\n-                 -> Gc<ast::MetaItem>;\n+                 mis: Vec<P<ast::MetaItem>> )\n+                 -> P<ast::MetaItem>;\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> Gc<ast::MetaItem>;\n+                       -> P<ast::MetaItem>;\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem;\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem;\n     fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n@@ -447,16 +432,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 self.path_global(DUMMY_SP, vec!(p.ident)), None)).collect()\n     }\n \n-    fn strip_bounds(&self, generics: &Generics) -> Generics {\n-        let new_params = generics.ty_params.map(|ty_param| {\n-            ast::TyParam { bounds: OwnedSlice::empty(), unbound: None, ..*ty_param }\n-        });\n-        Generics {\n-            ty_params: new_params,\n-            .. (*generics).clone()\n-        }\n-    }\n-\n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n         ast::TraitRef {\n             path: path,\n@@ -483,74 +458,71 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n-        box(GC) respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID))\n+    fn stmt_expr(&self, expr: P<ast::Expr>) -> P<ast::Stmt> {\n+        P(respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID)))\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n-                ex: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n+                ex: P<ast::Expr>) -> P<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = box(GC) ast::Local {\n+        let local = P(ast::Local {\n             ty: self.ty_infer(sp),\n             pat: pat,\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             source: ast::LocalLet,\n-        };\n+        });\n         let decl = respan(sp, ast::DeclLocal(local));\n-        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: Gc<ast::Expr>)\n-                      -> Gc<ast::Stmt> {\n+                      ex: P<ast::Expr>)\n+                      -> P<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = box(GC) ast::Local {\n+        let local = P(ast::Local {\n             ty: typ,\n             pat: pat,\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             source: ast::LocalLet,\n-        };\n+        });\n         let decl = respan(sp, ast::DeclLocal(local));\n-        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n-    fn block(&self,\n-             span: Span,\n-             stmts: Vec<Gc<ast::Stmt>>,\n-             expr: Option<Gc<Expr>>)\n-             -> P<ast::Block> {\n+    fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+             expr: Option<P<Expr>>) -> P<ast::Block> {\n         self.block_all(span, Vec::new(), stmts, expr)\n     }\n \n-    fn stmt_item(&self, sp: Span, item: Gc<ast::Item>) -> Gc<ast::Stmt> {\n+    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt> {\n         let decl = respan(sp, ast::DeclItem(item));\n-        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n-    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block> {\n+    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n         self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<Gc<ast::Stmt>>,\n-                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block> {\n+                 view_items: Vec<ast::ViewItem>,\n+                 stmts: Vec<P<ast::Stmt>>,\n+                 expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                view_items: view_items,\n                stmts: stmts,\n@@ -561,42 +533,42 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             })\n     }\n \n-    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr> {\n-        box(GC) ast::Expr {\n+    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr> {\n+        P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n-        }\n+        })\n     }\n \n-    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr> {\n+    fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n         self.expr(path.span, ast::ExprPath(path))\n     }\n \n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr> {\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n-    fn expr_self(&self, span: Span) -> Gc<ast::Expr> {\n+    fn expr_self(&self, span: Span) -> P<ast::Expr> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+                   lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprBinary(op, lhs, rhs))\n     }\n \n-    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr_unary(sp, ast::UnDeref, e)\n     }\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprUnary(op, e))\n     }\n \n-    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_managed(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr_unary(sp, ast::UnBox, e)\n     }\n \n-    fn expr_field_access(&self, sp: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         let field_name = token::get_ident(ident);\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(field_name.get().len()),\n@@ -607,7 +579,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let id = Spanned { node: ident, span: field_span };\n         self.expr(sp, ast::ExprField(expr, id, Vec::new()))\n     }\n-    fn expr_tup_field_access(&self, sp: Span, expr: Gc<ast::Expr>, idx: uint) -> Gc<ast::Expr> {\n+    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: uint) -> P<ast::Expr> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(idx.to_string().len()),\n             hi: sp.hi,\n@@ -617,108 +589,107 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let id = Spanned { node: idx, span: field_span };\n         self.expr(sp, ast::ExprTupField(expr, id, Vec::new()))\n     }\n-    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n     }\n-    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n-                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprCall(expr, args))\n     }\n     fn expr_call_ident(&self, span: Span, id: ast::Ident,\n-                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+                       args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                      args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+                      args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n-                        expr: Gc<ast::Expr>,\n+                        expr: P<ast::Expr>,\n                         ident: ast::Ident,\n-                        mut args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+                        mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n         args.unshift(expr);\n         self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n     }\n-    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprBlock(b))\n     }\n-    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field {\n+    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprStruct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::Ident, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n+                         id: ast::Ident, fields: Vec<ast::Field>) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr> {\n-        self.expr(sp, ast::ExprLit(box(GC) respan(sp, lit)))\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr> {\n+        self.expr(sp, ast::ExprLit(P(respan(sp, lit))))\n     }\n-    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr> {\n+    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyU)))\n     }\n-    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr> {\n+    fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyI, ast::Sign::new(i))))\n     }\n-    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr> {\n+    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))\n     }\n-    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr> {\n+    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitBool(value))\n     }\n \n-    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprVec(exprs))\n     }\n-    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr> {\n+    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n         self.expr_call_global(sp,\n                               vec!(self.ident_of(\"std\"),\n                                    self.ident_of(\"vec\"),\n                                    self.ident_of(\"Vec\"),\n                                    self.ident_of(\"new\")),\n                               Vec::new())\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n-    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n+    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n \n-    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>, ty: P<ast::Ty>) -> Gc<ast::Expr> {\n+    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprCast(expr, ty))\n     }\n \n \n-    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"Some\"));\n         self.expr_call_global(sp, some, vec!(expr))\n     }\n \n-    fn expr_none(&self, sp: Span) -> Gc<ast::Expr> {\n+    fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n         let none = self.path_global(sp, vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"None\")));\n         self.expr_path(none)\n     }\n \n-    fn expr_tuple(&self, sp: Span, exprs: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprTup(exprs))\n     }\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr> {\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n                                       token::intern_and_get_ident(loc.file\n@@ -738,29 +709,29 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 expr_file_line_ptr))\n     }\n \n-    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr> {\n+    fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n         self.expr_fail(span,\n                        InternedString::new(\n                            \"internal error: entered unreachable code\"))\n     }\n \n-    fn expr_ok(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Ok\"));\n         self.expr_call_global(sp, ok, vec!(expr))\n     }\n \n-    fn expr_err(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let err = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Err\"));\n         self.expr_call_global(sp, err, vec!(expr))\n     }\n \n-    fn expr_try(&self, sp: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.ident_of(\"Ok\");\n         let ok_path = self.path_ident(sp, ok);\n         let err = self.ident_of(\"Err\");\n@@ -771,11 +742,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // Ok(__try_var) pattern\n-        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat));\n+        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat.clone()));\n \n         // Err(__try_var)  (pattern and expression resp.)\n         let err_pat = self.pat_enum(sp, err_path, vec!(binding_pat));\n-        let err_inner_expr = self.expr_call_ident(sp, err, vec!(binding_expr));\n+        let err_inner_expr = self.expr_call_ident(sp, err, vec!(binding_expr.clone()));\n         // return Err(__try_var)\n         let err_expr = self.expr(sp, ast::ExprRet(Some(err_inner_expr)));\n \n@@ -789,41 +760,41 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat> {\n-        box(GC) ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> P<ast::Pat> {\n+        P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span })\n     }\n-    fn pat_wild(&self, span: Span) -> Gc<ast::Pat> {\n+    fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n         self.pat(span, ast::PatWild(ast::PatWildSingle))\n     }\n-    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat> {\n+    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat> {\n         self.pat(span, ast::PatLit(expr))\n     }\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat> {\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n         self.pat_ident_binding_mode(span, ident, ast::BindByValue(ast::MutImmutable))\n     }\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> Gc<ast::Pat> {\n+                              bm: ast::BindingMode) -> P<ast::Pat> {\n         let pat = ast::PatIdent(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<Gc<ast::Pat>> ) -> Gc<ast::Pat> {\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         let pat = ast::PatEnum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat> {\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat>) -> P<ast::Pat> {\n         let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n-    fn pat_tuple(&self, span: Span, pats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat> {\n+    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         let pat = ast::PatTup(pats);\n         self.pat(span, pat)\n     }\n \n-    fn pat_some(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n@@ -832,7 +803,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!(pat))\n     }\n \n-    fn pat_none(&self, span: Span) -> Gc<ast::Pat> {\n+    fn pat_none(&self, span: Span) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n@@ -841,7 +812,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!())\n     }\n \n-    fn pat_ok(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n@@ -850,7 +821,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!(pat))\n     }\n \n-    fn pat_err(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n@@ -859,7 +830,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!(pat))\n     }\n \n-    fn arm(&self, _span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm {\n+    fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec!(),\n             pats: pats,\n@@ -872,64 +843,62 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.arm(span, vec!(self.pat_wild(span)), self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>,\n-                  arms: Vec<ast::Arm>) -> Gc<Expr> {\n+    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n         self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n-    fn expr_if(&self, span: Span,\n-               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n-               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+    fn expr_if(&self, span: Span, cond: P<ast::Expr>,\n+               then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr> {\n         let els = els.map(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n \n-    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprLoop(block, None))\n     }\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr> {\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n         self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n     }\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)\n     }\n \n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda(span, vec!(ident), blk)\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident>,\n+                   expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n-    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.lambda0(span, self.block_expr(expr))\n     }\n-    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n     fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n-                    stmts: Vec<Gc<ast::Stmt>>)\n-                    -> Gc<ast::Expr> {\n+                    stmts: Vec<P<ast::Stmt>>)\n+                    -> P<ast::Expr> {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span,\n-                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr> {\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<P<ast::Stmt>>) -> P<ast::Expr> {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n-                      ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+                      ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n@@ -952,17 +921,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute>,\n-            node: ast::Item_) -> Gc<ast::Item> {\n+    fn item(&self, span: Span, name: Ident,\n+            attrs: Vec<ast::Attribute>, node: ast::Item_) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n-        box(GC) ast::Item { ident: name,\n-                    attrs: attrs,\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: node,\n-                    vis: ast::Inherited,\n-                    span: span }\n+        P(ast::Item {\n+            ident: name,\n+            attrs: attrs,\n+            id: ast::DUMMY_NODE_ID,\n+            node: node,\n+            vis: ast::Inherited,\n+            span: span\n+        })\n     }\n \n     fn item_fn_poly(&self,\n@@ -971,7 +941,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> Gc<ast::Item> {\n+                    body: P<ast::Block>) -> P<ast::Item> {\n         self.item(span,\n                   name,\n                   Vec::new(),\n@@ -988,7 +958,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n-              ) -> Gc<ast::Item> {\n+              ) -> P<ast::Item> {\n         self.item_fn_poly(\n             span,\n             name,\n@@ -1016,18 +986,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> Gc<ast::Item> {\n+                      generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::EnumDef) -> Gc<ast::Item> {\n+                 enum_definition: ast::EnumDef) -> P<ast::Item> {\n         self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::StructDef) -> Gc<ast::Item> {\n+                   struct_def: ast::StructDef) -> P<ast::Item> {\n         self.item_struct_poly(\n             span,\n             name,\n@@ -1037,14 +1007,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::StructDef, generics: Generics) -> Gc<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemStruct(box(GC) struct_def, generics))\n+        struct_def: ast::StructDef, generics: Generics) -> P<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemStruct(P(struct_def), generics))\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n                 attrs: Vec<ast::Attribute> ,\n                 vi: Vec<ast::ViewItem> ,\n-                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item> {\n+                items: Vec<P<ast::Item>> ) -> P<ast::Item> {\n         self.item(\n             span,\n             name,\n@@ -1062,21 +1032,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                    name: Ident,\n                    ty: P<ast::Ty>,\n                    mutbl: ast::Mutability,\n-                   expr: Gc<ast::Expr>)\n-                   -> Gc<ast::Item> {\n+                   expr: P<ast::Expr>)\n+                   -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemStatic(ty, mutbl, expr))\n     }\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> Gc<ast::Item> {\n+                    generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item> {\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute {\n+    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute {\n         respan(sp, ast::Attribute_ {\n             id: attr::mk_attr_id(),\n             style: ast::AttrOuter,\n@@ -1085,26 +1055,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem> {\n-        box(GC) respan(sp, ast::MetaWord(w))\n+    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n+        P(respan(sp, ast::MetaWord(w)))\n     }\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<Gc<ast::MetaItem>> )\n-                 -> Gc<ast::MetaItem> {\n-        box(GC) respan(sp, ast::MetaList(name, mis))\n+                 mis: Vec<P<ast::MetaItem>> )\n+                 -> P<ast::MetaItem> {\n+        P(respan(sp, ast::MetaList(name, mis)))\n     }\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> Gc<ast::MetaItem> {\n-        box(GC) respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n+                       -> P<ast::MetaItem> {\n+        P(respan(sp, ast::MetaNameValue(name, respan(sp, value))))\n     }\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem {\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem {\n         ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n             attrs: Vec::new(),\n@@ -1121,10 +1091,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      box(GC) respan(sp,\n-                           ast::ViewPathSimple(ident,\n-                                               path,\n-                                               ast::DUMMY_NODE_ID)))\n+                      P(respan(sp,\n+                               ast::ViewPathSimple(ident,\n+                                                   path,\n+                                                   ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n@@ -1134,41 +1104,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }).collect();\n \n         self.view_use(sp, vis,\n-                      box(GC) respan(sp,\n-                           ast::ViewPathList(self.path(sp, path),\n-                                             imports,\n-                                             ast::DUMMY_NODE_ID)))\n+                      P(respan(sp,\n+                               ast::ViewPathList(self.path(sp, path),\n+                                                 imports,\n+                                                 ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_glob(&self, sp: Span,\n                      vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      box(GC) respan(sp,\n-                           ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID)))\n-    }\n-}\n-\n-struct Duplicator<'a>;\n-\n-impl<'a> Folder for Duplicator<'a> {\n-    fn new_id(&mut self, _: NodeId) -> NodeId {\n-        ast::DUMMY_NODE_ID\n-    }\n-}\n-\n-pub trait Duplicate {\n-    //\n-    // Duplication functions\n-    //\n-    // These functions just duplicate AST nodes.\n-    //\n-\n-    fn duplicate(&self, cx: &ExtCtxt) -> Self;\n-}\n-\n-impl Duplicate for Gc<ast::Expr> {\n-    fn duplicate(&self, _: &ExtCtxt) -> Gc<ast::Expr> {\n-        let mut folder = Duplicator;\n-        folder.fold_expr(*self)\n+                      P(respan(sp,\n+                               ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))))\n     }\n }"}, {"sha": "3e0f340ad7ff6138e475aca1a534c95b074de9a7", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -40,7 +40,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n     for expr in exprs.iter() {\n         match expr.node {\n             // expression is a literal\n-            ast::ExprLit(lit) => match lit.node {\n+            ast::ExprLit(ref lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::LitStr(ref s, _) => {\n                     for byte in s.get().bytes() {"}, {"sha": "79cb47fee7b45a4ef01c4c8da7261a064cfea505", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -40,10 +40,10 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n     }\n \n     // test_cfg searches for meta items looking like `cfg(foo, ...)`\n-    let in_cfg = &[cx.meta_list(sp, InternedString::new(\"cfg\"), cfgs)];\n+    let in_cfg = Some(cx.meta_list(sp, InternedString::new(\"cfg\"), cfgs));\n \n     let matches_cfg = attr::test_cfg(cx.cfg().as_slice(),\n-                                     in_cfg.iter().map(|&x| x));\n+                                     in_cfg.iter());\n     let e = cx.expr_bool(sp, matches_cfg);\n     MacExpr::new(e)\n }"}, {"sha": "455148bfedd50f9087b2b29dbde8a0aa6e84d914", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -27,7 +27,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     let mut accumulator = String::new();\n     for e in es.move_iter() {\n         match e.node {\n-            ast::ExprLit(lit) => {\n+            ast::ExprLit(ref lit) => {\n                 match lit.node {\n                     ast::LitStr(ref s, _) |\n                     ast::LitFloat(ref s, _) |"}, {"sha": "145412caa0bfe44bbac17fa10e7ac0a512181cd4", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,8 +15,7 @@ use ext::base;\n use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n-\n-use std::gc::GC;\n+use ptr::P;\n \n pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n@@ -44,7 +43,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n     }\n     let res = str_to_ident(res_str.as_slice());\n \n-    let e = box(GC) ast::Expr {\n+    let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(\n             ast::Path {\n@@ -60,6 +59,6 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n             }\n         ),\n         span: sp,\n-    };\n+    });\n     MacExpr::new(e)\n }"}, {"sha": "0595b0bc7f4409e417fcfc95fbb460c159b15ce5", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -13,14 +13,13 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_bound(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: Gc<MetaItem>,\n-                             item: Gc<Item>,\n-                             push: |Gc<Item>|) {\n+                             mitem: &MetaItem,\n+                             item: &Item,\n+                             push: |P<Item>|) {\n \n     let name = match mitem.node {\n         MetaWord(ref tname) => {"}, {"sha": "64607ffd5d4c931ca3e5b4a253be9622bf8ce3ca", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: Gc<MetaItem>,\n-                             item: Gc<Item>,\n-                             push: |Gc<Item>|) {\n+                             mitem: &MetaItem,\n+                             item: &Item,\n+                             push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -52,12 +51,12 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt, trait_span: Span,\n-    substr: &Substructure) -> Gc<Expr> {\n+    substr: &Substructure) -> P<Expr> {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;\n     let subcall = |field: &FieldInfo|\n-        cx.expr_method_call(field.span, field.self_, clone_ident, Vec::new());\n+        cx.expr_method_call(field.span, field.self_.clone(), clone_ident, Vec::new());\n \n     match *substr.fields {\n         Struct(ref af) => {"}, {"sha": "a27016fde61562c42063c3119cc7defdf4b68670", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,21 +15,20 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n-                          mitem: Gc<MetaItem>,\n-                          item: Gc<Item>,\n-                          push: |Gc<Item>|) {\n+                          mitem: &MetaItem,\n+                          item: &Item,\n+                          push: |P<Item>|) {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "7cb61d295c0d45d5aaf61f2da46054605a40f526", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -16,14 +16,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n-                           mitem: Gc<MetaItem>,\n-                           item: Gc<Item>,\n-                           push: |Gc<Item>|) {\n+                           mitem: &MetaItem,\n+                           item: &Item,\n+                           push: |P<Item>|) {\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -87,7 +86,7 @@ pub enum OrderingOp {\n pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n                                span: Span,\n                                op: OrderingOp,\n-                               self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+                               self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     let op_str = match op {\n@@ -99,7 +98,7 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> Gc<Expr> {\n+              substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n     let ordering = cx.path_global(span,\n                                   vec!(cx.ident_of(\"std\"),\n@@ -159,8 +158,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n-         substr: &Substructure) -> Gc<Expr> {\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n+         span: Span, substr: &Substructure) -> P<Expr> {\n     let op = if less {ast::BiLt} else {ast::BiGt};\n     cs_fold(\n         false, // need foldr,\n@@ -183,14 +182,14 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n             layers of pointers, if the type includes pointers.\n             */\n             let other_f = match other_fs {\n-                [o_f] => o_f,\n+                [ref o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n             };\n \n-            let cmp = cx.expr_binary(span, op, self_f, other_f);\n+            let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n \n             let not_cmp = cx.expr_unary(span, ast::UnNot,\n-                                        cx.expr_binary(span, op, other_f, self_f));\n+                                        cx.expr_binary(span, op, other_f.clone(), self_f));\n \n             let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n             cx.expr_binary(span, ast::BiOr, cmp, and)"}, {"sha": "98c8885f7fa01566740d8e89f37ced2b01bce141", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,16 +15,14 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                                span: Span,\n-                               mitem: Gc<MetaItem>,\n-                               item: Gc<Item>,\n-                               push: |Gc<Item>|) {\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span,\n-                          substr: &Substructure) -> Gc<Expr> {\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: |P<Item>|) {\n+    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_same_method(|cx, span, exprs| {\n             // create `a.<method>(); b.<method>(); c.<method>(); ...`\n             // (where method is `assert_receiver_is_total_eq`)"}, {"sha": "9ef463f9c630e0d86712425f55d78ffdbf50aba9", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -16,14 +16,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 span: Span,\n-                                mitem: Gc<MetaItem>,\n-                                item: Gc<Item>,\n-                                push: |Gc<Item>|) {\n+                                mitem: &MetaItem,\n+                                item: &Item,\n+                                push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -53,14 +52,14 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n \n pub fn ordering_collapsed(cx: &mut ExtCtxt,\n                           span: Span,\n-                          self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+                          self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> Gc<Expr> {\n+              substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = cx.path_global(span,\n                                      vec!(cx.ident_of(\"std\"),"}, {"sha": "fd24f5e35a4463616fd882d531fe034f13543629", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -21,14 +21,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use parse::token;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: Gc<MetaItem>,\n-                                 item: Gc<Item>,\n-                                 push: |Gc<Item>|) {\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: |P<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -64,15 +63,15 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> Gc<Expr> {\n-    let decoder = substr.nonself_args[0];\n+                          substr: &Substructure) -> P<Expr> {\n+    let decoder = substr.nonself_args[0].clone();\n     let recurse = vec!(cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n                     cx.ident_of(\"decode\"));\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n-    let calldecode = cx.expr_call_global(trait_span, recurse, vec!(blkdecoder));\n+    let calldecode = cx.expr_call_global(trait_span, recurse, vec!(blkdecoder.clone()));\n     let lambdadecode = cx.lambda_expr_1(trait_span, calldecode, blkarg);\n \n     return match *substr.fields {\n@@ -89,10 +88,10 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                               summary,\n                                               |cx, span, name, field| {\n                 cx.expr_try(span,\n-                    cx.expr_method_call(span, blkdecoder, read_struct_field,\n+                    cx.expr_method_call(span, blkdecoder.clone(), read_struct_field,\n                                         vec!(cx.expr_str(span, name),\n                                           cx.expr_uint(span, field),\n-                                          lambdadecode)))\n+                                          lambdadecode.clone())))\n             });\n             let result = cx.expr_ok(trait_span, result);\n             cx.expr_method_call(trait_span,\n@@ -121,8 +120,8 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                    |cx, span, _, field| {\n                     let idx = cx.expr_uint(span, field);\n                     cx.expr_try(span,\n-                        cx.expr_method_call(span, blkdecoder, rvariant_arg,\n-                                            vec!(idx, lambdadecode)))\n+                        cx.expr_method_call(span, blkdecoder.clone(), rvariant_arg,\n+                                            vec!(idx, lambdadecode.clone())))\n                 });\n \n                 arms.push(cx.arm(v_span,\n@@ -159,8 +158,8 @@ fn decode_static_fields(cx: &mut ExtCtxt,\n                         trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> Gc<Expr>)\n-                        -> Gc<Expr> {\n+                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> P<Expr>)\n+                        -> P<Expr> {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {"}, {"sha": "f4a66414d89bd664db5044a970dd6bab47125382", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -47,8 +46,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn default_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                        substr: &Substructure) -> Gc<Expr> {\n+fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let default_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),"}, {"sha": "103253560df65c3aa8d490fb9a89246b9a13c036", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -86,14 +86,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: Gc<MetaItem>,\n-                                 item: Gc<Item>,\n-                                 push: |Gc<Item>|) {\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: |P<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -131,8 +130,8 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> Gc<Expr> {\n-    let encoder = substr.nonself_args[0];\n+                          substr: &Substructure) -> P<Expr> {\n+    let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n@@ -145,7 +144,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let last = fields.len() - 1;\n             for (i, &FieldInfo {\n                     name,\n-                    self_,\n+                    ref self_,\n                     span,\n                     ..\n                 }) in fields.iter().enumerate() {\n@@ -156,9 +155,10 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                             i).as_slice())\n                     }\n                 };\n-                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n+                let enc = cx.expr_method_call(span, self_.clone(),\n+                                              encode, vec!(blkencoder.clone()));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                let call = cx.expr_method_call(span, blkencoder,\n+                let call = cx.expr_method_call(span, blkencoder.clone(),\n                                                emit_struct_field,\n                                                vec!(cx.expr_str(span, name),\n                                                  cx.expr_uint(span, i),\n@@ -202,10 +202,11 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = Vec::new();\n             let last = fields.len() - 1;\n-            for (i, &FieldInfo { self_, span, .. }) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n+            for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n+                let enc = cx.expr_method_call(span, self_.clone(),\n+                                              encode, vec!(blkencoder.clone()));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                let call = cx.expr_method_call(span, blkencoder,\n+                let call = cx.expr_method_call(span, blkencoder.clone(),\n                                                emit_variant_arg,\n                                                vec!(cx.expr_uint(span, i),\n                                                  lambda));"}, {"sha": "53af5a86ed2c6989335777f62b40465b8480b4dd", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 131, "deletions": 133, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -181,22 +181,25 @@\n //! ~~~\n \n use std::cell::RefCell;\n-use std::gc::{Gc, GC};\n+use std::gc::GC;\n+use std::vec;\n \n use abi::Abi;\n use abi;\n use ast;\n-use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n+use ast::{EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n use attr;\n use attr::AttrMetaMethods;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap;\n use codemap::Span;\n+use fold::MoveMap;\n use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n use parse::token::special_idents;\n+use ptr::P;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self, Ty};\n \n@@ -251,9 +254,9 @@ pub struct Substructure<'a> {\n     /// ident of the method\n     pub method_ident: Ident,\n     /// dereferenced access to any Self or Ptr(Self, _) arguments\n-    pub self_args: &'a [Gc<Expr>],\n+    pub self_args: &'a [P<Expr>],\n     /// verbatim access to any other arguments\n-    pub nonself_args: &'a [Gc<Expr>],\n+    pub nonself_args: &'a [P<Expr>],\n     pub fields: &'a SubstructureFields<'a>\n }\n \n@@ -265,10 +268,10 @@ pub struct FieldInfo {\n     pub name: Option<Ident>,\n     /// The expression corresponding to this field of `self`\n     /// (specifically, a reference to it).\n-    pub self_: Gc<Expr>,\n+    pub self_: P<Expr>,\n     /// The expressions corresponding to references to this field in\n     /// the other Self arguments.\n-    pub other: Vec<Gc<Expr>>,\n+    pub other: Vec<P<Expr>>,\n }\n \n /// Fields for a static method\n@@ -298,7 +301,7 @@ pub enum SubstructureFields<'a> {\n     Idents bound to the variant index values for each of the actual\n     input Self arguments.\n     */\n-    EnumNonMatchingCollapsed(Vec<Ident>, &'a [Gc<ast::Variant>], &'a [Ident]),\n+    EnumNonMatchingCollapsed(Vec<Ident>, &'a [P<ast::Variant>], &'a [Ident]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n@@ -313,7 +316,7 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'a> =\n-    |&mut ExtCtxt, Span, &Substructure|: 'a -> Gc<Expr>;\n+    |&mut ExtCtxt, Span, &Substructure|: 'a -> P<Expr>;\n \n /**\n Deal with non-matching enum variants.  The tuple is a list of\n@@ -324,10 +327,10 @@ last argument is all the non-Self args of the method being derived.\n */\n pub type EnumNonMatchCollapsedFunc<'a> =\n     |&mut ExtCtxt,\n-           Span,\n-           (&[Ident], &[Ident]),\n-           &[Gc<Expr>]|: 'a\n-           -> Gc<Expr>;\n+     Span,\n+     (&[Ident], &[Ident]),\n+     &[P<Expr>]|: 'a\n+     -> P<Expr>;\n \n pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n     -> RefCell<CombineSubstructureFunc<'a>> {\n@@ -338,9 +341,9 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   cx: &mut ExtCtxt,\n-                  _mitem: Gc<ast::MetaItem>,\n-                  item: Gc<ast::Item>,\n-                  push: |Gc<ast::Item>|) {\n+                  _mitem: &ast::MetaItem,\n+                  item: &ast::Item,\n+                  push: |P<ast::Item>|) {\n         let newitem = match item.node {\n             ast::ItemStruct(ref struct_def, ref generics) => {\n                 self.expand_struct_def(cx,\n@@ -365,10 +368,10 @@ impl<'a> TraitDef<'a> {\n                 _ => false,\n             }\n         }).map(|a| a.clone()));\n-        push(box(GC) ast::Item {\n+        push(P(ast::Item {\n             attrs: attrs,\n             ..(*newitem).clone()\n-        })\n+        }))\n     }\n \n     /**\n@@ -387,7 +390,7 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: Vec<Gc<ast::Method>> ) -> Gc<ast::Item> {\n+                           methods: Vec<P<ast::Method>>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let Generics { mut lifetimes, ty_params, where_clause: _ } =\n@@ -475,7 +478,7 @@ impl<'a> TraitDef<'a> {\n                          cx: &mut ExtCtxt,\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n-                         generics: &Generics) -> Gc<ast::Item> {\n+                         generics: &Generics) -> P<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(\n@@ -515,7 +518,7 @@ impl<'a> TraitDef<'a> {\n                        cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n-                       generics: &Generics) -> Gc<ast::Item> {\n+                       generics: &Generics) -> P<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, self,\n@@ -534,7 +537,7 @@ impl<'a> TraitDef<'a> {\n                                                    self,\n                                                    enum_def,\n                                                    type_ident,\n-                                                   self_args.as_slice(),\n+                                                   self_args,\n                                                    nonself_args.as_slice())\n             };\n \n@@ -553,7 +556,7 @@ impl<'a> TraitDef<'a> {\n }\n \n fn variant_to_pat(cx: &mut ExtCtxt, sp: Span, variant: &ast::Variant)\n-                  -> Gc<ast::Pat> {\n+                  -> P<ast::Pat> {\n     let ident = cx.path_ident(sp, variant.node.name);\n     cx.pat(sp, match variant.node.kind {\n         ast::TupleVariantKind(..) => ast::PatEnum(ident, None),\n@@ -566,10 +569,10 @@ impl<'a> MethodDef<'a> {\n                                 cx: &mut ExtCtxt,\n                                 trait_: &TraitDef,\n                                 type_ident: Ident,\n-                                self_args: &[Gc<Expr>],\n-                                nonself_args: &[Gc<Expr>],\n+                                self_args: &[P<Expr>],\n+                                nonself_args: &[P<Expr>],\n                                 fields: &SubstructureFields)\n-        -> Gc<Expr> {\n+        -> P<Expr> {\n         let substructure = Substructure {\n             type_ident: type_ident,\n             method_ident: cx.ident_of(self.name),\n@@ -600,8 +603,7 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, Vec<Gc<Expr>>, Vec<Gc<Expr>>,\n-            Vec<(Ident, P<ast::Ty>)>) {\n+        -> (ast::ExplicitSelf, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n \n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n@@ -654,8 +656,7 @@ impl<'a> MethodDef<'a> {\n                      abi: Abi,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: Gc<Expr>)\n-                     -> Gc<ast::Method> {\n+                     body: P<Expr>) -> P<ast::Method> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -678,7 +679,7 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         // Create the method.\n-        box(GC) ast::Method {\n+        P(ast::Method {\n             attrs: self.attributes.clone(),\n             id: ast::DUMMY_NODE_ID,\n             span: trait_.span,\n@@ -690,7 +691,7 @@ impl<'a> MethodDef<'a> {\n                                 fn_decl,\n                                 body_block,\n                                 ast::Inherited)\n-        }\n+        })\n     }\n \n     /**\n@@ -719,9 +720,9 @@ impl<'a> MethodDef<'a> {\n                                  trait_: &TraitDef,\n                                  struct_def: &StructDef,\n                                  type_ident: Ident,\n-                                 self_args: &[Gc<Expr>],\n-                                 nonself_args: &[Gc<Expr>])\n-        -> Gc<Expr> {\n+                                 self_args: &[P<Expr>],\n+                                 nonself_args: &[P<Expr>])\n+        -> P<Expr> {\n \n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n@@ -740,20 +741,20 @@ impl<'a> MethodDef<'a> {\n \n         // transpose raw_fields\n         let fields = if raw_fields.len() > 0 {\n-            raw_fields.get(0)\n-                      .iter()\n-                      .enumerate()\n-                      .map(|(i, &(span, opt_id, field))| {\n-                let other_fields = raw_fields.tail().iter().map(|l| {\n-                    match l.get(i) {\n-                        &(_, _, ex) => ex\n-                    }\n-                }).collect();\n+            let mut raw_fields = raw_fields.move_iter().map(|v| v.move_iter());\n+            let first_field = raw_fields.next().unwrap();\n+            let mut other_fields: Vec<vec::MoveItems<(Span, Option<Ident>, P<Expr>)>>\n+                = raw_fields.collect();\n+            first_field.map(|(span, opt_id, field)| {\n                 FieldInfo {\n                     span: span,\n                     name: opt_id,\n                     self_: field,\n-                    other: other_fields\n+                    other: other_fields.mut_iter().map(|l| {\n+                        match l.next().unwrap() {\n+                            (_, _, ex) => ex\n+                        }\n+                    }).collect()\n                 }\n             }).collect()\n         } else {\n@@ -774,9 +775,9 @@ impl<'a> MethodDef<'a> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n-        for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n-            body = cx.expr_match(trait_.span, arg_expr,\n-                                     vec!( cx.arm(trait_.span, vec!(pat), body) ))\n+        for (arg_expr, pat) in self_args.iter().zip(patterns.iter()) {\n+            body = cx.expr_match(trait_.span, arg_expr.clone(),\n+                                     vec!( cx.arm(trait_.span, vec!(pat.clone()), body) ))\n         }\n         body\n     }\n@@ -786,9 +787,9 @@ impl<'a> MethodDef<'a> {\n                                         trait_: &TraitDef,\n                                         struct_def: &StructDef,\n                                         type_ident: Ident,\n-                                        self_args: &[Gc<Expr>],\n-                                        nonself_args: &[Gc<Expr>])\n-        -> Gc<Expr> {\n+                                        self_args: &[P<Expr>],\n+                                        nonself_args: &[P<Expr>])\n+        -> P<Expr> {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(cx,\n@@ -834,9 +835,9 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                enum_def: &EnumDef,\n                                type_ident: Ident,\n-                               self_args: &[Gc<Expr>],\n-                               nonself_args: &[Gc<Expr>])\n-                               -> Gc<Expr> {\n+                               self_args: Vec<P<Expr>>,\n+                               nonself_args: &[P<Expr>])\n+                               -> P<Expr> {\n         self.build_enum_match_tuple(\n             cx, trait_, enum_def, type_ident, self_args, nonself_args)\n     }\n@@ -875,8 +876,8 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef,\n         enum_def: &EnumDef,\n         type_ident: Ident,\n-        self_args: &[Gc<Expr>],\n-        nonself_args: &[Gc<Expr>]) -> Gc<Expr> {\n+        self_args: Vec<P<Expr>>,\n+        nonself_args: &[P<Expr>]) -> P<Expr> {\n \n         let sp = trait_.span;\n         let variants = &enum_def.variants;\n@@ -898,7 +899,7 @@ impl<'a> MethodDef<'a> {\n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to a uint\n         // corresponding to its variant index.\n-        let vi_idents : Vec<ast::Ident> = self_arg_names.iter()\n+        let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n             .map(|name| { let vi_suffix = format!(\"{:s}_vi\", name.as_slice());\n                           cx.ident_of(vi_suffix.as_slice()) })\n             .collect::<Vec<ast::Ident>>();\n@@ -914,24 +915,29 @@ impl<'a> MethodDef<'a> {\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n         // where each tuple has length = self_args.len()\n-        let mut match_arms : Vec<ast::Arm> = variants.iter().enumerate()\n-            .map(|(index, &variant)| {\n-\n-                // These self_pats have form Variant1, Variant2, ...\n-                let self_pats : Vec<(Gc<ast::Pat>,\n-                                     Vec<(Span, Option<Ident>, Gc<Expr>)>)>;\n-                self_pats = self_arg_names.iter()\n-                    .map(|self_arg_name|\n-                         trait_.create_enum_variant_pattern(\n-                             cx, &*variant, self_arg_name.as_slice(),\n-                             ast::MutImmutable))\n-                    .collect();\n+        let mut match_arms: Vec<ast::Arm> = variants.iter().enumerate()\n+            .map(|(index, variant)| {\n+                let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n+                    let (p, idents) = trait_.create_enum_variant_pattern(cx, &**variant,\n+                                                                         self_arg_name,\n+                                                                         ast::MutImmutable);\n+                    (cx.pat(sp, ast::PatRegion(p)), idents)\n+                };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n-                let subpats = self_pats.iter()\n-                    .map(|&(p, ref _idents)| cx.pat(sp, ast::PatRegion(p)))\n-                    .collect::<Vec<Gc<ast::Pat>>>();\n+                let mut subpats = Vec::with_capacity(self_arg_names.len());\n+                let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n+                let first_self_pat_idents = {\n+                    let (p, idents) = mk_self_pat(cx, self_arg_names[0].as_slice());\n+                    subpats.push(p);\n+                    idents\n+                };\n+                for self_arg_name in self_arg_names.tail().iter() {\n+                    let (p, idents) = mk_self_pat(cx, self_arg_name.as_slice());\n+                    subpats.push(p);\n+                    self_pats_idents.push(idents);\n+                }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n                 let single_pat = cx.pat(sp, ast::PatTup(subpats));\n@@ -941,39 +947,33 @@ impl<'a> MethodDef<'a> {\n                 // we are in.\n \n                 // All of the Self args have the same variant in these\n-                // cases.  So we transpose the info in self_pats to\n-                // gather the getter expressions together, in the form\n-                // that EnumMatching expects.\n+                // cases.  So we transpose the info in self_pats_idents\n+                // to gather the getter expressions together, in the\n+                // form that EnumMatching expects.\n \n                 // The transposition is driven by walking across the\n                 // arg fields of the variant for the first self pat.\n-                let &(_, ref self_arg_fields) = self_pats.get(0);\n-\n-                let field_tuples : Vec<FieldInfo>;\n-\n-                field_tuples = self_arg_fields.iter().enumerate()\n+                let field_tuples = first_self_pat_idents.move_iter().enumerate()\n                     // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, &(sp, opt_ident, self_getter_expr))| {\n+                    .map(|(field_index, (sp, opt_ident, self_getter_expr))| {\n                         // ... but FieldInfo also wants getter expr\n                         // for matching other arguments of Self type;\n-                        // so walk across the *other* self_pats and\n-                        // pull out getter for same field in each of\n-                        // them (using `field_index` tracked above).\n+                        // so walk across the *other* self_pats_idents\n+                        // and pull out getter for same field in each\n+                        // of them (using `field_index` tracked above).\n                         // That is the heart of the transposition.\n-                        let others = self_pats.tail().iter()\n-                            .map(|&(_pat, ref fields)| {\n+                        let others = self_pats_idents.iter().map(|fields| {\n+                            let &(_, _opt_ident, ref other_getter_expr) =\n+                                fields.get(field_index);\n \n-                                let &(_, _opt_ident, other_getter_expr) =\n-                                    fields.get(field_index);\n+                            // All Self args have same variant, so\n+                            // opt_idents are the same.  (Assert\n+                            // here to make it self-evident that\n+                            // it is okay to ignore `_opt_ident`.)\n+                            assert!(opt_ident == _opt_ident);\n \n-                                // All Self args have same variant, so\n-                                // opt_idents are the same.  (Assert\n-                                // here to make it self-evident that\n-                                // it is okay to ignore `_opt_ident`.)\n-                                assert!(opt_ident == _opt_ident);\n-\n-                                other_getter_expr\n-                            }).collect::<Vec<Gc<Expr>>>();\n+                            other_getter_expr.clone()\n+                        }).collect::<Vec<P<Expr>>>();\n \n                         FieldInfo { span: sp,\n                                     name: opt_ident,\n@@ -987,10 +987,10 @@ impl<'a> MethodDef<'a> {\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n                 let substructure = EnumMatching(index,\n-                                                &*variant,\n+                                                &**variant,\n                                                 field_tuples);\n                 let arm_expr = self.call_substructure_method(\n-                    cx, trait_, type_ident, self_args, nonself_args,\n+                    cx, trait_, type_ident, self_args.as_slice(), nonself_args,\n                     &substructure);\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n@@ -1012,9 +1012,9 @@ impl<'a> MethodDef<'a> {\n         //   unreachable-pattern error.\n         //\n         if variants.len() > 1 && self_args.len() > 1 {\n-            let arms : Vec<ast::Arm> = variants.iter().enumerate()\n-                .map(|(index, &variant)| {\n-                    let pat = variant_to_pat(cx, sp, &*variant);\n+            let arms: Vec<ast::Arm> = variants.iter().enumerate()\n+                .map(|(index, variant)| {\n+                    let pat = variant_to_pat(cx, sp, &**variant);\n                     let lit = ast::LitInt(index as u64, ast::UnsignedIntLit(ast::TyU));\n                     cx.arm(sp, vec![pat], cx.expr_lit(sp, lit))\n                 }).collect();\n@@ -1035,15 +1035,15 @@ impl<'a> MethodDef<'a> {\n             //     A => 0u, B(..) => 1u, C(..) => 2u\n             // };\n             // ```\n-            let mut index_let_stmts : Vec<Gc<ast::Stmt>> = Vec::new();\n-            for (&ident, &self_arg) in vi_idents.iter().zip(self_args.iter()) {\n-                let variant_idx = cx.expr_match(sp, self_arg, arms.clone());\n+            let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n+            for (&ident, self_arg) in vi_idents.iter().zip(self_args.iter()) {\n+                let variant_idx = cx.expr_match(sp, self_arg.clone(), arms.clone());\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_idx);\n                 index_let_stmts.push(let_stmt);\n             }\n \n             let arm_expr = self.call_substructure_method(\n-                cx, trait_, type_ident, self_args, nonself_args,\n+                cx, trait_, type_ident, self_args.as_slice(), nonself_args,\n                 &catch_all_substructure);\n \n             // Builds the expression:\n@@ -1124,9 +1124,7 @@ impl<'a> MethodDef<'a> {\n         // them when they are fed as r-values into a tuple\n         // expression; here add a layer of borrowing, turning\n         // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-        let borrowed_self_args = self_args.iter()\n-            .map(|&self_arg| cx.expr_addr_of(sp, self_arg))\n-            .collect::<Vec<Gc<ast::Expr>>>();\n+        let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n         let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n         cx.expr_match(sp, match_arg, match_arms)\n     }\n@@ -1136,9 +1134,9 @@ impl<'a> MethodDef<'a> {\n                                       trait_: &TraitDef,\n                                       enum_def: &EnumDef,\n                                       type_ident: Ident,\n-                                      self_args: &[Gc<Expr>],\n-                                      nonself_args: &[Gc<Expr>])\n-        -> Gc<Expr> {\n+                                      self_args: &[P<Expr>],\n+                                      nonself_args: &[P<Expr>])\n+        -> P<Expr> {\n         let summary = enum_def.variants.iter().map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n@@ -1210,11 +1208,11 @@ impl<'a> TraitDef<'a> {\n                           cx: &mut ExtCtxt,\n                           field_paths: Vec<ast::SpannedIdent> ,\n                           mutbl: ast::Mutability)\n-                          -> Vec<Gc<ast::Pat>> {\n+                          -> Vec<P<ast::Pat>> {\n         field_paths.iter().map(|path| {\n             cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n-            }).collect()\n+        }).collect()\n     }\n \n     fn create_struct_pattern(&self,\n@@ -1223,7 +1221,7 @@ impl<'a> TraitDef<'a> {\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-                             -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)>) {\n+                             -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n@@ -1266,7 +1264,7 @@ impl<'a> TraitDef<'a> {\n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n         let pattern = if struct_type == Record {\n-            let field_pats = subpats.iter().zip(ident_expr.iter()).map(|(&pat, &(_, id, _))| {\n+            let field_pats = subpats.move_iter().zip(ident_expr.iter()).map(|(pat, &(_, id, _))| {\n                 // id is guaranteed to be Some\n                 ast::FieldPat { ident: id.unwrap(), pat: pat }\n             }).collect();\n@@ -1283,7 +1281,7 @@ impl<'a> TraitDef<'a> {\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n-        -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)> ) {\n+        -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n@@ -1327,29 +1325,29 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>, &[Gc<Expr>]| -> Gc<Expr>,\n-               base: Gc<Expr>,\n+               f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]| -> P<Expr>,\n+               base: P<Expr>,\n                enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n-               -> Gc<Expr> {\n+               -> P<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n                 all_fields.iter().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n-                      field.self_,\n+                      field.self_.clone(),\n                       field.other.as_slice())\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n-                      field.self_,\n+                      field.self_.clone(),\n                       field.other.as_slice())\n                 })\n             }\n@@ -1374,21 +1372,21 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n+pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n                       enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n-                      -> Gc<Expr> {\n+                      -> P<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = all_fields.iter().map(|field| {\n                 cx.expr_method_call(field.span,\n-                                    field.self_,\n+                                    field.self_.clone(),\n                                     substructure.method_ident,\n                                     field.other.iter()\n-                                               .map(|e| cx.expr_addr_of(field.span, *e))\n+                                               .map(|e| cx.expr_addr_of(field.span, e.clone()))\n                                                .collect())\n             }).collect();\n \n@@ -1410,21 +1408,21 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>| -> Gc<Expr>,\n-                           base: Gc<Expr>,\n+                           f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>| -> P<Expr>,\n+                           base: P<Expr>,\n                            enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                            cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n-                           -> Gc<Expr> {\n+                           -> P<Expr> {\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n-                vals.iter().fold(base, |old, &new| {\n+                vals.move_iter().fold(base.clone(), |old, new| {\n                     f(cx, span, old, new)\n                 })\n             } else {\n-                vals.iter().rev().fold(base, |old, &new| {\n+                vals.move_iter().rev().fold(base.clone(), |old, new| {\n                     f(cx, span, old, new)\n                 })\n             }\n@@ -1438,10 +1436,10 @@ Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n #[inline]\n-pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n+pub fn cs_binop(binop: ast::BinOp, base: P<Expr>,\n                 enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n-                substructure: &Substructure) -> Gc<Expr> {\n+                substructure: &Substructure) -> P<Expr> {\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n@@ -1459,7 +1457,7 @@ pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n              cx: &mut ExtCtxt, span: Span,\n-             substructure: &Substructure) -> Gc<Expr> {\n+             substructure: &Substructure) -> P<Expr> {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n@@ -1469,7 +1467,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n               cx: &mut ExtCtxt, span: Span,\n-              substructure: &Substructure) -> Gc<Expr> {\n+              substructure: &Substructure) -> P<Expr> {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)"}, {"sha": "a90618a30b6ebf3c7cd287018c971c24d20ef9e9", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -14,14 +14,13 @@ explicit `Self` type to use when specifying impls to be derived.\n */\n \n use ast;\n-use ast::{P,Expr,Generics,Ident};\n+use ast::{Expr,Generics,Ident};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use owned_slice::OwnedSlice;\n use parse::token::special_idents;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n /// The types of pointers\n #[deriving(Clone)]\n@@ -260,7 +259,7 @@ impl<'a> LifetimeBounds<'a> {\n }\n \n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (Gc<Expr>, ast::ExplicitSelf) {\n+    -> (P<Expr>, ast::ExplicitSelf) {\n     // this constructs a fresh `self` path, which will match the fresh `self` binding\n     // created below.\n     let self_path = cx.expr_self(span);"}, {"sha": "b7f11c2582548114d5dc091ebc5100947001aef8", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n \n     let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n         (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n@@ -64,15 +63,14 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n     hash_trait_def.expand(cx, mitem, item, push);\n }\n \n-fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let state_expr = match substr.nonself_args {\n-        [state_expr] => state_expr,\n+        [ref state_expr] => state_expr,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")\n     };\n     let hash_ident = substr.method_ident;\n     let call_hash = |span, thing_expr| {\n-        let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr));\n+        let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr.clone()));\n         cx.stmt_expr(expr)\n     };\n     let mut stmts = Vec::new();\n@@ -83,7 +81,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             // Determine the discriminant. We will feed this value to the byte\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n-                Some(d) => d,\n+                Some(ref d) => d.clone(),\n                 None => cx.expr_uint(trait_span, index)\n             };\n \n@@ -94,8 +92,8 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n         _ => cx.span_bug(trait_span, \"impossible substructure in `deriving(Hash)`\")\n     };\n \n-    for &FieldInfo { self_, span, .. } in fields.iter() {\n-        stmts.push(call_hash(span, self_));\n+    for &FieldInfo { ref self_, span, .. } in fields.iter() {\n+        stmts.push(call_hash(span, self_.clone()));\n     }\n \n     if stmts.len() == 0 {"}, {"sha": "b8cebd8ea201c74708090bd056e22f4225071738", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -21,8 +21,7 @@ library.\n use ast::{Item, MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use codemap::Span;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub mod bounds;\n pub mod clone;\n@@ -49,9 +48,9 @@ pub mod generic;\n \n pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             _span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     match mitem.node {\n         MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `deriving`\");\n@@ -63,13 +62,13 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n             cx.span_warn(mitem.span, \"empty trait list in `deriving`\");\n         }\n         MetaList(_, ref titems) => {\n-            for &titem in titems.iter().rev() {\n+            for titem in titems.iter().rev() {\n                 match titem.node {\n                     MetaNameValue(ref tname, _) |\n                     MetaList(ref tname, _) |\n                     MetaWord(ref tname) => {\n                         macro_rules! expand(($func:path) => ($func(cx, titem.span,\n-                                                                   titem, item,\n+                                                                   &**titem, item,\n                                                                    |i| push(i))));\n                         match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),"}, {"sha": "044a2812c000397f66c80a23a75fcd767f721852", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -16,14 +16,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n-                                      mitem: Gc<MetaItem>,\n-                                      item: Gc<Item>,\n-                                      push: |Gc<Item>|) {\n+                                      mitem: &MetaItem,\n+                                      item: &Item,\n+                                      push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -70,10 +69,9 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n-           substr: &Substructure) -> Gc<Expr> {\n+fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let n = match substr.nonself_args {\n-        [n] => n,\n+        [ref n] => n,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(FromPrimitive)`\")\n     };\n \n@@ -106,8 +104,8 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n                         // expr for `$n == $variant as $name`\n                         let variant = cx.expr_ident(span, variant.node.name);\n                         let ty = cx.ty_ident(span, cx.ident_of(name));\n-                        let cast = cx.expr_cast(span, variant, ty);\n-                        let guard = cx.expr_binary(span, ast::BiEq, n, cast);\n+                        let cast = cx.expr_cast(span, variant.clone(), ty);\n+                        let guard = cx.expr_binary(span, ast::BiEq, n.clone(), cast);\n \n                         // expr for `Some($variant)`\n                         let body = cx.expr_some(span, variant);\n@@ -141,7 +139,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n             };\n             arms.push(arm);\n \n-            cx.expr_match(trait_span, n, arms)\n+            cx.expr_match(trait_span, n.clone(), arms)\n         }\n         _ => cx.span_bug(trait_span, \"expected StaticEnum in deriving(FromPrimitive)\")\n     }"}, {"sha": "584645bb306394116f6563322dbfdcb6034db4aa", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,14 +15,13 @@ use ext::base::ExtCtxt;\n use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -54,10 +53,9 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let rng = match substr.nonself_args {\n-        [rng] => vec!( rng ),\n+        [ref rng] => rng,\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n     };\n     let rand_ident = vec!(\n@@ -69,7 +67,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     let rand_call = |cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n-                            vec!( *rng.get(0) ))\n+                            vec!(rng.clone()))\n     };\n \n     return match *substr.fields {\n@@ -95,7 +93,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             // ::rand::Rand::rand(rng)\n             let rv_call = cx.expr_call(trait_span,\n                                        rand_name,\n-                                       vec!( *rng.get(0) ));\n+                                       vec!(rng.clone()));\n \n             // need to specify the uint-ness of the random number\n             let uint_ty = cx.ty_ident(trait_span, cx.ident_of(\"uint\"));\n@@ -136,8 +134,8 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                   trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n-                  rand_call: |&mut ExtCtxt, Span| -> Gc<Expr>)\n-                  -> Gc<Expr> {\n+                  rand_call: |&mut ExtCtxt, Span| -> P<Expr>)\n+                  -> P<Expr> {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {"}, {"sha": "16ce264fe712d46d94003823e3b688177e59bef3", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -9,24 +9,23 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Item, Expr,};\n use codemap::Span;\n use ext::format;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n+use ptr::P;\n \n use std::collections::HashMap;\n-use std::string::String;\n-use std::gc::Gc;\n \n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(box Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));\n@@ -57,7 +56,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n /// We construct a format string and then defer to std::fmt, since that\n /// knows what's up with formatting and so on.\n fn show_substructure(cx: &mut ExtCtxt, span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+                     substr: &Substructure) -> P<Expr> {\n     // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n     // <field>: {}, ... }` based on the \"shape\".\n     //\n@@ -91,7 +90,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n                     format_string.push_str(\"{}\");\n \n-                    exprs.push(field.self_);\n+                    exprs.push(field.self_.clone());\n                 }\n \n                 format_string.push_str(\")\");\n@@ -108,7 +107,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                     format_string.push_str(name.get());\n                     format_string.push_str(\": {}\");\n \n-                    exprs.push(field.self_);\n+                    exprs.push(field.self_.clone());\n                 }\n \n                 format_string.push_str(\" }}\");\n@@ -123,7 +122,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     // format_arg_method!(fmt, write_fmt, \"<format_string>\", exprs...)\n     //\n     // but doing it directly via ext::format.\n-    let formatter = substr.nonself_args[0];\n+    let formatter = substr.nonself_args[0].clone();\n \n     let meth = cx.ident_of(\"write_fmt\");\n     let s = token::intern_and_get_ident(format_string.as_slice());"}, {"sha": "7f265b529ffea6f53b224272af94b5a11a287939", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -63,8 +62,7 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let zero_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "69574ee6696781e4ffbdfecd7d6d8a4bef572f5d", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -61,38 +61,42 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n \n pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'cx> {\n-    let exprs = match get_exprs_from_tts(cx, sp, tts) {\n+    let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.len() == 0 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }\n         None => return DummyResult::expr(sp),\n-        Some(exprs) => exprs\n+        Some(exprs) => exprs.move_iter()\n     };\n \n     let var = match expr_to_string(cx,\n-                                *exprs.get(0),\n+                                exprs.next().unwrap(),\n                                 \"expected string literal\") {\n         None => return DummyResult::expr(sp),\n         Some((v, _style)) => v\n     };\n-    let msg = match exprs.len() {\n-        1 => {\n+    let msg = match exprs.next() {\n+        None => {\n             token::intern_and_get_ident(format!(\"environment variable `{}` \\\n                                                  not defined\",\n                                                 var).as_slice())\n         }\n-        2 => {\n-            match expr_to_string(cx, *exprs.get(1), \"expected string literal\") {\n+        Some(second) => {\n+            match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n                 Some((s, _style)) => s\n             }\n         }\n-        _ => {\n+    };\n+\n+    match exprs.next() {\n+        None => {}\n+        Some(_) => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }\n-    };\n+    }\n \n     let e = match os::getenv(var.get()) {\n         None => {"}, {"sha": "db28872de379d264fe6a4dcbc18dda578726c1d7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 288, "deletions": 288, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{P, Block, Crate, DeclLocal, ExprMac, PatMac};\n+use ast::{Block, Crate, DeclLocal, ExprMac, PatMac};\n use ast::{Local, Ident, MacInvocTT};\n use ast::{ItemMac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::TokenTree;\n@@ -25,103 +25,106 @@ use fold::*;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n use parse::token;\n+use ptr::P;\n+use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n-use util::small_vector::SmallVector;\n \n-use std::gc::{Gc, GC};\n+use std::gc::Gc;\n \n enum Either<L,R> {\n     Left(L),\n     Right(R)\n }\n \n-fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n-    match e.node {\n+pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n+    e.and_then(|ast::Expr {id, node, span}| match node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n-        ExprMac(ref mac) => {\n-            let expanded_expr = match expand_mac_invoc(mac,&e.span,\n-                                                       |r|{r.make_expr()},\n-                                                       |expr,fm|{mark_expr(expr,fm)},\n-                                                       fld) {\n+        ExprMac(mac) => {\n+            let expanded_expr = match expand_mac_invoc(mac, span,\n+                                                       |r| r.make_expr(),\n+                                                       mark_expr, fld) {\n                 Some(expr) => expr,\n                 None => {\n-                    return DummyResult::raw_expr(e.span);\n+                    return DummyResult::raw_expr(span);\n                 }\n             };\n \n             // Keep going, outside-in.\n             //\n-            // FIXME(pcwalton): Is it necessary to clone the\n-            // node here?\n-            let fully_expanded =\n-                fld.fold_expr(expanded_expr).node.clone();\n+            let fully_expanded = fld.fold_expr(expanded_expr);\n             fld.cx.bt_pop();\n \n-            box(GC) ast::Expr {\n+            fully_expanded.map(|e| ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: fully_expanded,\n-                span: e.span,\n-            }\n+                node: e.node,\n+                span: span,\n+            })\n         }\n \n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(e.span, ast::ExprWhile(cond, body, opt_ident))\n+            fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(e.span, ast::ExprLoop(loop_block, opt_ident))\n+            fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n             let head = fld.fold_expr(head);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(e.span, ast::ExprForLoop(pat, head, body, opt_ident))\n+            fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n         }\n \n         ast::ExprFnBlock(capture_clause, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(&*fn_decl, block, fld);\n+                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprFnBlock(capture_clause,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n-            box(GC) ast::Expr{id:e.id, node: new_node, span: fld.new_span(e.span)}\n+            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n         }\n \n         ast::ExprProc(fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(&*fn_decl, block, fld);\n+                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprProc(rewritten_fn_decl, rewritten_block);\n-            box(GC) ast::Expr{id:e.id, node: new_node, span: fld.new_span(e.span)}\n+            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n         }\n \n-        _ => noop_fold_expr(e, fld)\n-    }\n+        _ => {\n+            P(noop_fold_expr(ast::Expr {\n+                id: id,\n+                node: node,\n+                span: span\n+            }, fld))\n+        }\n+    })\n }\n \n /// Expand a (not-ident-style) macro invocation. Returns the result\n /// of expansion and the mark which must be applied to the result.\n /// Our current interface doesn't allow us to apply the mark to the\n /// result until after calling make_expr, make_items, etc.\n-fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n+fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n                        parse_thunk: |Box<MacResult>|->Option<T>,\n                        mark_thunk: |T,Mrk|->T,\n                        fld: &mut MacroExpander)\n                        -> Option<T>\n {\n-    match (*mac).node {\n+    match mac.node {\n         // it would almost certainly be cleaner to pass the whole\n         // macro invocation in, rather than pulling it apart and\n         // marking the tts and the ctxt separately. This also goes\n         // for the other three macro invocation chunks of code\n         // in this file.\n         // Token-tree macros:\n-        MacInvocTT(ref pth, ref tts, _) => {\n+        MacInvocTT(pth, tts, _) => {\n             if pth.segments.len() > 1u {\n                 fld.cx.span_err(pth.span,\n                                 \"expected macro name without module \\\n@@ -144,7 +147,7 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n                 Some(rc) => match *rc {\n                     NormalTT(ref expandfun, exp_span) => {\n                         fld.cx.bt_push(ExpnInfo {\n-                                call_site: *span,\n+                                call_site: span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr.get().to_string(),\n                                     format: MacroBang,\n@@ -218,7 +221,7 @@ fn expand_loop_block(loop_block: P<Block>,\n             // in a block enclosed by loop head.\n             fld.cx.syntax_env.push_frame();\n             fld.cx.syntax_env.info().pending_renames.push(rename);\n-            let expanded_block = expand_block_elts(&*loop_block, fld);\n+            let expanded_block = expand_block_elts(loop_block, fld);\n             fld.cx.syntax_env.pop_frame();\n \n             (expanded_block, Some(renamed_ident))\n@@ -240,8 +243,8 @@ macro_rules! with_exts_frame (\n )\n \n // When we enter a module, record it, for the sake of `module!`\n-fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n-                   -> SmallVector<Gc<ast::Item>> {\n+pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n+                   -> SmallVector<P<ast::Item>> {\n     let it = expand_item_modifiers(it, fld);\n \n     let mut decorator_items = SmallVector::zero();\n@@ -265,8 +268,9 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n \n                     // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n                     // but that double-mut-borrows fld\n-                    let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n-                    dec.expand(fld.cx, attr.span, attr.node.value, it, |item| items.push(item));\n+                    let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n+                    dec.expand(fld.cx, attr.span, &*attr.node.value, &*it,\n+                               |item| items.push(item));\n                     decorator_items.extend(items.move_iter()\n                         .flat_map(|item| expand_item(item, fld).move_iter()));\n \n@@ -285,26 +289,25 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             let macro_escape = contains_macro_escape(new_attrs.as_slice());\n             let result = with_exts_frame!(fld.cx.syntax_env,\n                                           macro_escape,\n-                                          noop_fold_item(&*it, fld));\n+                                          noop_fold_item(it, fld));\n             fld.cx.mod_pop();\n             result\n         },\n         _ => {\n-            let it = box(GC) ast::Item {\n+            let it = P(ast::Item {\n                 attrs: new_attrs,\n                 ..(*it).clone()\n-\n-            };\n-            noop_fold_item(&*it, fld)\n+            });\n+            noop_fold_item(it, fld)\n         }\n     };\n \n     new_items.push_all(decorator_items);\n     new_items\n }\n \n-fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n-                         -> Gc<ast::Item> {\n+fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n+                         -> P<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n     let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n         match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n@@ -313,10 +316,10 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n         }\n     });\n     // update the attrs, leave everything else alone. Is this mutation really a good idea?\n-    it = box(GC) ast::Item {\n+    it = P(ast::Item {\n         attrs: other_attrs,\n         ..(*it).clone()\n-    };\n+    });\n \n     if modifiers.is_empty() {\n         return it;\n@@ -337,7 +340,7 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n                             span: None,\n                         }\n                     });\n-                    it = mac.expand(fld.cx, attr.span, attr.node.value, it);\n+                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n                     fld.cx.bt_pop();\n                 }\n                 _ => unreachable!()\n@@ -351,15 +354,15 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n }\n \n /// Expand item_underscore\n-fn expand_item_underscore(item: &ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n-    match *item {\n-        ast::ItemFn(decl, fn_style, abi, ref generics, body) => {\n+fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n+    match item {\n+        ast::ItemFn(decl, fn_style, abi, generics, body) => {\n             let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(&*decl, body, fld);\n+                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n             let expanded_generics = fold::noop_fold_generics(generics,fld);\n             ast::ItemFn(rewritten_fn_decl, fn_style, abi, expanded_generics, rewritten_body)\n         }\n-        _ => noop_fold_item_underscore(&*item, fld)\n+        _ => noop_fold_item_underscore(item, fld)\n     }\n }\n \n@@ -370,26 +373,24 @@ fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n-                   -> SmallVector<Gc<ast::Item>>\n-{\n-    let (pth, tts) = match it.node {\n+pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n+                       -> SmallVector<P<ast::Item>> {\n+    let (extname, path_span, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n             ..\n         }) => {\n-            (pth, (*tts).clone())\n+            (pth.segments.get(0).identifier, pth.span, (*tts).clone())\n         }\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n     let def_or_items = {\n-        let expanded = match fld.cx.syntax_env.find(&extname.name) {\n+        let mut expanded = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n-                fld.cx.span_err(pth.span,\n+                fld.cx.span_err(path_span,\n                                 format!(\"macro undefined: '{}!'\",\n                                         extnamestr).as_slice());\n                 // let compilation continue\n@@ -400,7 +401,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 NormalTT(ref expander, span) => {\n                     if it.ident.name != parse::token::special_idents::invalid.name {\n                         fld.cx\n-                            .span_err(pth.span,\n+                            .span_err(path_span,\n                                       format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n                                       extnamestr,\n@@ -421,7 +422,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 }\n                 IdentTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n-                        fld.cx.span_err(pth.span,\n+                        fld.cx.span_err(path_span,\n                                         format!(\"macro {}! expects an ident argument\",\n                                                 extnamestr.get()).as_slice());\n                         return SmallVector::zero();\n@@ -440,7 +441,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 }\n                 LetSyntaxTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n-                        fld.cx.span_err(pth.span,\n+                        fld.cx.span_err(path_span,\n                                         format!(\"macro {}! expects an ident argument\",\n                                                 extnamestr.get()).as_slice());\n                         return SmallVector::zero();\n@@ -490,79 +491,64 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 .collect()\n         }\n         Right(None) => {\n-            fld.cx.span_err(pth.span,\n+            fld.cx.span_err(path_span,\n                             format!(\"non-item macro in item position: {}\",\n                                     extnamestr.get()).as_slice());\n             return SmallVector::zero();\n         }\n     };\n \n     fld.cx.bt_pop();\n-    return items;\n+    items\n }\n \n /// Expand a stmt\n //\n // I don't understand why this returns a vector... it looks like we're\n // half done adding machinery to allow macros to expand into multiple statements.\n-fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n+fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let (mac, semi) = match s.node {\n-        StmtMac(ref mac, semi) => (mac, semi),\n+        StmtMac(mac, semi) => (mac, semi),\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n-    let expanded_stmt = match expand_mac_invoc(mac,&s.span,\n-                                                |r|{r.make_stmt()},\n-                                                |sts,mrk| {\n-                                                    mark_stmt(&*sts,mrk)\n-                                                },\n-                                                fld) {\n+    let expanded_stmt = match expand_mac_invoc(mac, s.span,\n+                                                |r| r.make_stmt(),\n+                                                mark_stmt, fld) {\n         Some(stmt) => stmt,\n         None => {\n             return SmallVector::zero();\n         }\n     };\n \n     // Keep going, outside-in.\n-    let fully_expanded = fld.fold_stmt(&*expanded_stmt);\n+    let fully_expanded = fld.fold_stmt(expanded_stmt);\n     fld.cx.bt_pop();\n-    let fully_expanded: SmallVector<Gc<Stmt>> = fully_expanded.move_iter()\n-            .map(|s| box(GC) Spanned { span: s.span, node: s.node.clone() })\n-            .collect();\n-\n-    fully_expanded.move_iter().map(|s| {\n-        match s.node {\n-            StmtExpr(e, stmt_id) if semi => {\n-                box(GC) Spanned {\n-                    span: s.span,\n-                    node: StmtSemi(e, stmt_id)\n-                }\n+\n+    if semi {\n+        fully_expanded.move_iter().map(|s| s.map(|Spanned {node, span}| {\n+            Spanned {\n+                node: match node {\n+                    StmtExpr(e, stmt_id) => StmtSemi(e, stmt_id),\n+                    _ => node /* might already have a semi */\n+                },\n+                span: span\n             }\n-            _ => s /* might already have a semi */\n-        }\n-    }).collect()\n+        })).collect()\n+    } else {\n+        fully_expanded\n+    }\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<Gc<Stmt>> {\n+fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroExpander)\n+                         -> SmallVector<P<Stmt>> {\n     // is it a let?\n-    match s.node {\n-        StmtDecl(decl, node_id) => {\n-            match *decl {\n-                Spanned {\n-                    node: DeclLocal(ref local),\n-                    span: stmt_span\n-                } => {\n-                    // take it apart:\n-                    let Local {\n-                        ty: ty,\n-                        pat: pat,\n-                        init: init,\n-                        id: id,\n-                        span: span,\n-                        source: source,\n-                    } = **local;\n+    match node {\n+        StmtDecl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n+            DeclLocal(local) => {\n+                // take it apart:\n+                let rewritten_local = local.map(|Local {id, pat, ty, init, source, span}| {\n                     // expand the ty since TyFixedLengthVec contains an Expr\n                     // and thus may have a macro use\n                     let expanded_ty = fld.fold_ty(ty);\n@@ -585,57 +571,66 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     };\n                     // add them to the existing pending renames:\n                     fld.cx.syntax_env.info().pending_renames.push_all_move(new_pending_renames);\n-                    // also, don't forget to expand the init:\n-                    let new_init_opt = init.map(|e| fld.fold_expr(e));\n-                    let rewritten_local =\n-                        box(GC) Local {\n-                            ty: expanded_ty,\n-                            pat: rewritten_pat,\n-                            init: new_init_opt,\n-                            id: id,\n-                            span: span,\n-                            source: source\n-                        };\n-                    SmallVector::one(box(GC) Spanned {\n-                        node: StmtDecl(box(GC) Spanned {\n-                                node: DeclLocal(rewritten_local),\n-                                span: stmt_span\n-                            },\n-                            node_id),\n+                    Local {\n+                        id: id,\n+                        ty: expanded_ty,\n+                        pat: rewritten_pat,\n+                        // also, don't forget to expand the init:\n+                        init: init.map(|e| fld.fold_expr(e)),\n+                        source: source,\n                         span: span\n-                    })\n-                }\n-                _ => noop_fold_stmt(s, fld),\n+                    }\n+                });\n+                SmallVector::one(P(Spanned {\n+                    node: StmtDecl(P(Spanned {\n+                            node: DeclLocal(rewritten_local),\n+                            span: span\n+                        }),\n+                        node_id),\n+                    span: stmt_span\n+                }))\n             }\n-        },\n-        _ => noop_fold_stmt(s, fld),\n+            _ => {\n+                noop_fold_stmt(Spanned {\n+                    node: StmtDecl(P(Spanned {\n+                            node: decl,\n+                            span: span\n+                        }),\n+                        node_id),\n+                    span: stmt_span\n+                }, fld)\n+            }\n+        }),\n+        _ => {\n+            noop_fold_stmt(Spanned {\n+                node: node,\n+                span: stmt_span\n+            }, fld)\n+        }\n     }\n }\n \n // expand the arm of a 'match', renaming for macro hygiene\n-fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n+fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // expand pats... they might contain macro uses:\n-    let expanded_pats : Vec<Gc<ast::Pat>> = arm.pats.iter().map(|pat| fld.fold_pat(*pat)).collect();\n+    let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n     if expanded_pats.len() == 0 {\n         fail!(\"encountered match arm with 0 patterns\");\n     }\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n-    let first_pat = expanded_pats.get(0);\n-    let idents = pattern_bindings(&**first_pat);\n-    let new_renames =\n-        idents.iter().map(|id| (*id,fresh_name(id))).collect();\n+    let idents = pattern_bindings(&**expanded_pats.get(0));\n+    let new_renames = idents.move_iter().map(|id| (id, fresh_name(&id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n-    let rewritten_pats =\n-        expanded_pats.iter().map(|pat| rename_pats_fld.fold_pat(*pat)).collect();\n+    let rewritten_pats = expanded_pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n     // apply renaming and then expansion to the guard and the body:\n     let mut rename_fld = IdentRenamer{renames:&new_renames};\n     let rewritten_guard =\n         arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n     let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n     ast::Arm {\n-        attrs: arm.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n+        attrs: arm.attrs.move_map(|x| fld.fold_attribute(x)),\n         pats: rewritten_pats,\n         guard: rewritten_guard,\n         body: rewritten_body,\n@@ -683,121 +678,126 @@ fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n-fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n+pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n     with_exts_frame!(fld.cx.syntax_env,false,\n                      expand_block_elts(blk, fld))\n }\n \n // expand the elements of a block.\n-fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n-    let new_view_items = b.view_items.iter().map(|x| fld.fold_view_item(x)).collect();\n-    let new_stmts =\n-        b.stmts.iter().flat_map(|x| {\n+pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n+    b.map(|Block {id, view_items, stmts, expr, rules, span}| {\n+        let new_view_items = view_items.move_iter().map(|x| fld.fold_view_item(x)).collect();\n+        let new_stmts = stmts.move_iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n                 let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n                 let mut rename_fld = IdentRenamer{renames:pending_renames};\n-                rename_fld.fold_stmt(&**x).expect_one(\"rename_fold didn't return one value\")\n+                rename_fld.fold_stmt(x).expect_one(\"rename_fold didn't return one value\")\n             };\n             // expand macros in the statement\n-            fld.fold_stmt(&*renamed_stmt).move_iter()\n+            fld.fold_stmt(renamed_stmt).move_iter()\n         }).collect();\n-    let new_expr = b.expr.map(|x| {\n-        let expr = {\n-            let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-            let mut rename_fld = IdentRenamer{renames:pending_renames};\n-            rename_fld.fold_expr(x)\n-        };\n-        fld.fold_expr(expr)\n-    });\n-    P(Block {\n-        view_items: new_view_items,\n-        stmts: new_stmts,\n-        expr: new_expr,\n-        id: fld.new_id(b.id),\n-        rules: b.rules,\n-        span: b.span,\n+        let new_expr = expr.map(|x| {\n+            let expr = {\n+                let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n+                let mut rename_fld = IdentRenamer{renames:pending_renames};\n+                rename_fld.fold_expr(x)\n+            };\n+            fld.fold_expr(expr)\n+        });\n+        Block {\n+            id: fld.new_id(id),\n+            view_items: new_view_items,\n+            stmts: new_stmts,\n+            expr: new_expr,\n+            rules: rules,\n+            span: span\n+        }\n     })\n }\n \n-fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n-    let (pth, tts) = match p.node {\n-        PatMac(ref mac) => {\n-            match mac.node {\n-                MacInvocTT(ref pth, ref tts, _) => {\n-                    (pth, (*tts).clone())\n-                }\n-            }\n-        }\n-        _ => return noop_fold_pat(p, fld),\n-    };\n-    if pth.segments.len() > 1u {\n-        fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n-        return DummyResult::raw_pat(p.span);\n+fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n+    match p.node {\n+        PatMac(_) => {}\n+        _ => return noop_fold_pat(p, fld)\n     }\n-    let extname = pth.segments.get(0).identifier;\n-    let extnamestr = token::get_ident(extname);\n-    let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n-        None => {\n-            fld.cx.span_err(pth.span,\n-                            format!(\"macro undefined: '{}!'\",\n-                                    extnamestr).as_slice());\n-            // let compilation continue\n-            return DummyResult::raw_pat(p.span);\n+    p.map(|ast::Pat {node, span, ..}| {\n+        let (pth, tts) = match node {\n+            PatMac(mac) => match mac.node {\n+                MacInvocTT(pth, tts, _) => {\n+                    (pth, tts)\n+                }\n+            },\n+            _ => unreachable!()\n+        };\n+        if pth.segments.len() > 1u {\n+            fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n+            return DummyResult::raw_pat(span);\n         }\n+        let extname = pth.segments.get(0).identifier;\n+        let extnamestr = token::get_ident(extname);\n+        let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n+            None => {\n+                fld.cx.span_err(pth.span,\n+                                format!(\"macro undefined: '{}!'\",\n+                                        extnamestr).as_slice());\n+                // let compilation continue\n+                return DummyResult::raw_pat(span);\n+            }\n \n-        Some(rc) => match *rc {\n-            NormalTT(ref expander, span) => {\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: p.span,\n-                    callee: NameAndSpan {\n-                        name: extnamestr.get().to_string(),\n-                        format: MacroBang,\n-                        span: span\n-                    }\n-                });\n+            Some(rc) => match *rc {\n+                NormalTT(ref expander, tt_span) => {\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: span,\n+                        callee: NameAndSpan {\n+                            name: extnamestr.get().to_string(),\n+                            format: MacroBang,\n+                            span: tt_span\n+                        }\n+                    });\n \n-                let fm = fresh_mark();\n-                let marked_before = mark_tts(tts.as_slice(), fm);\n-                let mac_span = original_span(fld.cx);\n-                let expanded = match expander.expand(fld.cx,\n-                                    mac_span.call_site,\n-                                    marked_before.as_slice()).make_pat() {\n-                    Some(e) => e,\n-                    None => {\n-                        fld.cx.span_err(\n-                            pth.span,\n-                            format!(\n-                                \"non-pattern macro in pattern position: {}\",\n-                                extnamestr.get()\n-                            ).as_slice()\n-                        );\n-                        return DummyResult::raw_pat(p.span);\n-                    }\n-                };\n+                    let fm = fresh_mark();\n+                    let marked_before = mark_tts(tts.as_slice(), fm);\n+                    let mac_span = original_span(fld.cx);\n+                    let expanded = match expander.expand(fld.cx,\n+                                        mac_span.call_site,\n+                                        marked_before.as_slice()).make_pat() {\n+                        Some(e) => e,\n+                        None => {\n+                            fld.cx.span_err(\n+                                pth.span,\n+                                format!(\n+                                    \"non-pattern macro in pattern position: {}\",\n+                                    extnamestr.get()\n+                                ).as_slice()\n+                            );\n+                            return DummyResult::raw_pat(span);\n+                        }\n+                    };\n \n-                // mark after:\n-                mark_pat(expanded,fm)\n-            }\n-            _ => {\n-                fld.cx.span_err(p.span,\n-                                format!(\"{}! is not legal in pattern position\",\n-                                        extnamestr.get()).as_slice());\n-                return DummyResult::raw_pat(p.span);\n+                    // mark after:\n+                    mark_pat(expanded,fm)\n+                }\n+                _ => {\n+                    fld.cx.span_err(span,\n+                                    format!(\"{}! is not legal in pattern position\",\n+                                            extnamestr.get()).as_slice());\n+                    return DummyResult::raw_pat(span);\n+                }\n             }\n-        }\n-    };\n+        };\n \n-    let fully_expanded =\n-        fld.fold_pat(marked_after).node.clone();\n-    fld.cx.bt_pop();\n+        let fully_expanded =\n+            fld.fold_pat(marked_after).node.clone();\n+        fld.cx.bt_pop();\n \n-    box(GC) ast::Pat {\n-        id: ast::DUMMY_NODE_ID,\n-        node: fully_expanded,\n-        span: p.span,\n-    }\n+        ast::Pat {\n+            id: ast::DUMMY_NODE_ID,\n+            node: fully_expanded,\n+            span: span\n+        }\n+    })\n }\n \n /// A tree-folder that applies every rename in its (mutable) list\n@@ -814,7 +814,7 @@ impl<'a> Folder for IdentRenamer<'a> {\n             ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n-    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(macro, self)\n     }\n }\n@@ -828,45 +828,50 @@ pub struct PatIdentRenamer<'a> {\n }\n \n impl<'a> Folder for PatIdentRenamer<'a> {\n-    fn fold_pat(&mut self, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n         match pat.node {\n-            ast::PatIdent(binding_mode, Spanned{span: ref sp, node: id}, ref sub) => {\n-                let new_ident = Ident{name: id.name,\n-                                      ctxt: mtwt::apply_renames(self.renames, id.ctxt)};\n+            ast::PatIdent(..) => {},\n+            _ => return noop_fold_pat(pat, self)\n+        }\n+\n+        pat.map(|ast::Pat {id, node, span}| match node {\n+            ast::PatIdent(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n+                let new_ident = Ident{name: ident.name,\n+                                      ctxt: mtwt::apply_renames(self.renames, ident.ctxt)};\n                 let new_node =\n                     ast::PatIdent(binding_mode,\n-                                  Spanned{span: self.new_span(*sp), node: new_ident},\n+                                  Spanned{span: self.new_span(sp), node: new_ident},\n                                   sub.map(|p| self.fold_pat(p)));\n-                box(GC) ast::Pat {\n-                    id: pat.id,\n-                    span: self.new_span(pat.span),\n+                ast::Pat {\n+                    id: id,\n                     node: new_node,\n+                    span: self.new_span(span)\n                 }\n             },\n-            _ => noop_fold_pat(pat, self)\n-        }\n+            _ => unreachable!()\n+        })\n     }\n-    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(macro, self)\n     }\n }\n \n // expand a method\n-fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast::Method>> {\n-    let id = fld.new_id(m.id);\n-    match m.node {\n+fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<ast::Method>> {\n+    m.and_then(|m| match m.node {\n         ast::MethDecl(ident,\n-                      ref generics,\n+                      generics,\n                       abi,\n-                      ref explicit_self,\n+                      explicit_self,\n                       fn_style,\n                       decl,\n                       body,\n                       vis) => {\n+            let id = fld.new_id(m.id);\n             let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(&*decl,body,fld);\n-            SmallVector::one(box(GC) ast::Method {\n-                    attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n+                = expand_and_rename_fn_decl_and_block(decl,body,fld);\n+            SmallVector::one(P(ast::Method {\n+                    attrs: m.attrs.move_map(|a| fld.fold_attribute(a)),\n                     id: id,\n                     span: fld.new_span(m.span),\n                     node: ast::MethDecl(fld.fold_ident(ident),\n@@ -877,15 +882,13 @@ fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast\n                                         rewritten_fn_decl,\n                                         rewritten_body,\n                                         vis)\n-                })\n+                }))\n         },\n-        ast::MethMac(ref mac) => {\n+        ast::MethMac(mac) => {\n             let maybe_new_methods =\n-                expand_mac_invoc(mac, &m.span,\n-                                 |r|{r.make_methods()},\n-                                 |meths,mark|{\n-                    meths.move_iter().map(|m|{mark_method(m,mark)})\n-                        .collect()},\n+                expand_mac_invoc(mac, m.span,\n+                                 |r| r.make_methods(),\n+                                 |meths, mark| meths.move_map(|m| mark_method(m, mark)),\n                                  fld);\n \n             let new_methods = match maybe_new_methods {\n@@ -896,22 +899,22 @@ fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast\n             // expand again if necessary\n             new_methods.move_iter().flat_map(|m| fld.fold_method(m).move_iter()).collect()\n         }\n-    }\n+    })\n }\n \n /// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n /// PatIdents in its arguments to perform renaming in the FnDecl and\n /// the block, returning both the new FnDecl and the new Block.\n-fn expand_and_rename_fn_decl_and_block(fn_decl: &ast::FnDecl, block: Gc<ast::Block>,\n+fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Block>,\n                                        fld: &mut MacroExpander)\n-    -> (Gc<ast::FnDecl>, Gc<ast::Block>) {\n+    -> (P<ast::FnDecl>, P<ast::Block>) {\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n     let idents = fn_decl_arg_bindings(&*expanded_decl);\n     let renames =\n         idents.iter().map(|id : &ast::Ident| (*id,fresh_name(id))).collect();\n     // first, a renamer for the PatIdents, for the fn_decl:\n     let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n-    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(&*expanded_decl);\n+    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n     // now, a renamer for *all* idents, for the body:\n     let mut rename_fld = IdentRenamer{renames: &renames};\n     let rewritten_body = fld.fold_block(rename_fld.fold_block(block));\n@@ -924,36 +927,36 @@ pub struct MacroExpander<'a, 'b:'a> {\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n-    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         expand_expr(expr, self)\n     }\n \n-    fn fold_pat(&mut self, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n         expand_pat(pat, self)\n     }\n \n-    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         expand_item(item, self)\n     }\n \n-    fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n+    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n         expand_item_underscore(item, self)\n     }\n \n-    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<Gc<ast::Stmt>> {\n-        expand_stmt(stmt, self)\n+    fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n+        stmt.and_then(|stmt| expand_stmt(stmt, self))\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        expand_block(&*block, self)\n+        expand_block(block, self)\n     }\n \n-    fn fold_arm(&mut self, arm: &ast::Arm) -> ast::Arm {\n+    fn fold_arm(&mut self, arm: ast::Arm) -> ast::Arm {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_method(&mut self, method: Gc<ast::Method>) -> SmallVector<Gc<ast::Method>> {\n-        expand_method(&*method, self)\n+    fn fold_method(&mut self, method: P<ast::Method>) -> SmallVector<P<ast::Method>> {\n+        expand_method(method, self)\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n@@ -1033,17 +1036,16 @@ impl Folder for Marker {\n             ctxt: mtwt::apply_mark(self.mark, id.ctxt)\n         }\n     }\n-    fn fold_mac(&mut self, m: &ast::Mac) -> ast::Mac {\n-        let macro = match m.node {\n-            MacInvocTT(ref path, ref tts, ctxt) => {\n-                MacInvocTT(self.fold_path(path),\n-                           self.fold_tts(tts.as_slice()),\n-                           mtwt::apply_mark(self.mark, ctxt))\n-            }\n-        };\n+    fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n         Spanned {\n-            node: macro,\n-            span: m.span,\n+            node: match node {\n+                MacInvocTT(path, tts, ctxt) => {\n+                    MacInvocTT(self.fold_path(path),\n+                               self.fold_tts(tts.as_slice()),\n+                               mtwt::apply_mark(self.mark, ctxt))\n+                }\n+            },\n+            span: span,\n         }\n     }\n }\n@@ -1054,29 +1056,29 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n-fn mark_expr(expr: Gc<ast::Expr>, m: Mrk) -> Gc<ast::Expr> {\n+fn mark_expr(expr: P<ast::Expr>, m: Mrk) -> P<ast::Expr> {\n     Marker{mark:m}.fold_expr(expr)\n }\n \n // apply a given mark to the given pattern. Used following the expansion of a macro.\n-fn mark_pat(pat: Gc<ast::Pat>, m: Mrk) -> Gc<ast::Pat> {\n+fn mark_pat(pat: P<ast::Pat>, m: Mrk) -> P<ast::Pat> {\n     Marker{mark:m}.fold_pat(pat)\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> Gc<ast::Stmt> {\n+fn mark_stmt(expr: P<ast::Stmt>, m: Mrk) -> P<ast::Stmt> {\n     Marker{mark:m}.fold_stmt(expr)\n         .expect_one(\"marking a stmt didn't return exactly one stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> Gc<ast::Item> {\n+fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n     Marker{mark:m}.fold_item(expr)\n         .expect_one(\"marking an item didn't return exactly one item\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_method(expr: Gc<ast::Method>, m: Mrk) -> Gc<ast::Method> {\n+fn mark_method(expr: P<ast::Method>, m: Mrk) -> P<ast::Method> {\n     Marker{mark:m}.fold_method(expr)\n         .expect_one(\"marking an item didn't return exactly one method\")\n }\n@@ -1133,8 +1135,6 @@ mod test {\n     use visit;\n     use visit::Visitor;\n \n-    use std::gc::GC;\n-\n     // a visitor that extracts the paths\n     // from a given thingy and puts them in a mutable\n     // array (passed in to the traversal)\n@@ -1252,10 +1252,10 @@ mod test {\n             node: Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: AttrOuter,\n-                value: box(GC) Spanned {\n+                value: P(Spanned {\n                     node: MetaWord(token::intern_and_get_ident(s)),\n                     span: codemap::DUMMY_SP,\n-                },\n+                }),\n                 is_sugared_doc: false,\n             }\n         }"}, {"sha": "271a5137bbf36e159455e445d62b606082bd0bc6", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 116, "deletions": 116, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -9,17 +9,16 @@\n // except according to those terms.\n \n use ast;\n-use ast::P;\n use codemap::{Span, respan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use fmt_macros as parse;\n use parse::token::InternedString;\n use parse::token;\n+use ptr::P;\n \n use std::collections::HashMap;\n-use std::gc::{Gc, GC};\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n@@ -39,37 +38,37 @@ struct Context<'a, 'b:'a> {\n \n     /// Parsed argument expressions and the types that we've found so far for\n     /// them.\n-    args: Vec<Gc<ast::Expr>>,\n+    args: Vec<P<ast::Expr>>,\n     arg_types: Vec<Option<ArgumentType>>,\n     /// Parsed named expressions and the types that we've found for them so far.\n     /// Note that we keep a side-array of the ordering of the named arguments\n     /// found to be sure that we can translate them in the same order that they\n     /// were declared in.\n-    names: HashMap<String, Gc<ast::Expr>>,\n+    names: HashMap<String, P<ast::Expr>>,\n     name_types: HashMap<String, ArgumentType>,\n     name_ordering: Vec<String>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n \n     /// Collection of the compiled `rt::Argument` structures\n-    pieces: Vec<Gc<ast::Expr>>,\n+    pieces: Vec<P<ast::Expr>>,\n     /// Collection of string literals\n-    str_pieces: Vec<Gc<ast::Expr>>,\n+    str_pieces: Vec<P<ast::Expr>>,\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n     name_positions: HashMap<String, uint>,\n-    method_statics: Vec<Gc<ast::Item>>,\n+    method_statics: Vec<P<ast::Item>>,\n \n     /// Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n     next_arg: uint,\n }\n \n pub enum Invocation {\n-    Call(Gc<ast::Expr>),\n-    MethodCall(Gc<ast::Expr>, ast::Ident),\n+    Call(P<ast::Expr>),\n+    MethodCall(P<ast::Expr>, ast::Ident),\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -82,10 +81,10 @@ pub enum Invocation {\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n               tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(Gc<ast::Expr>, Vec<Gc<ast::Expr>>, Vec<String>,\n-                            HashMap<String, Gc<ast::Expr>>)>) {\n+    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n+                            HashMap<String, P<ast::Expr>>)>) {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<String, Gc<ast::Expr>>::new();\n+    let mut names = HashMap::<String, P<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -323,44 +322,44 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// These attributes are applied to all statics that this syntax extension\n     /// will generate.\n-    fn static_attrs(&self) -> Vec<ast::Attribute> {\n+    fn static_attrs(ecx: &ExtCtxt, fmtsp: Span) -> Vec<ast::Attribute> {\n         // Flag statics as `inline` so LLVM can merge duplicate globals as much\n         // as possible (which we're generating a whole lot of).\n-        let unnamed = self.ecx.meta_word(self.fmtsp, InternedString::new(\"inline\"));\n-        let unnamed = self.ecx.attribute(self.fmtsp, unnamed);\n+        let unnamed = ecx.meta_word(fmtsp, InternedString::new(\"inline\"));\n+        let unnamed = ecx.attribute(fmtsp, unnamed);\n \n         // Do not warn format string as dead code\n-        let dead_code = self.ecx.meta_word(self.fmtsp,\n-                                           InternedString::new(\"dead_code\"));\n-        let allow_dead_code = self.ecx.meta_list(self.fmtsp,\n-                                                 InternedString::new(\"allow\"),\n-                                                 vec!(dead_code));\n-        let allow_dead_code = self.ecx.attribute(self.fmtsp, allow_dead_code);\n-        return vec!(unnamed, allow_dead_code);\n+        let dead_code = ecx.meta_word(fmtsp, InternedString::new(\"dead_code\"));\n+        let allow_dead_code = ecx.meta_list(fmtsp,\n+                                            InternedString::new(\"allow\"),\n+                                            vec![dead_code]);\n+        let allow_dead_code = ecx.attribute(fmtsp, allow_dead_code);\n+        vec![unnamed, allow_dead_code]\n     }\n \n-    fn rtpath(&self, s: &str) -> Vec<ast::Ident> {\n-        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n+    fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n+        vec![ecx.ident_of(\"std\"), ecx.ident_of(\"fmt\"), ecx.ident_of(\"rt\"), ecx.ident_of(s)]\n     }\n \n-    fn trans_count(&self, c: parse::Count) -> Gc<ast::Expr> {\n+    fn trans_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n         match c {\n             parse::CountIs(i) => {\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CountIs\"),\n+                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIs\"),\n                                           vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountIsParam(i) => {\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n+                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n                                           vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountImplied => {\n-                let path = self.ecx.path_global(sp, self.rtpath(\"CountImplied\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n+                                                                    \"CountImplied\"));\n                 self.ecx.expr_path(path)\n             }\n             parse::CountIsNextParam => {\n-                let path = self.ecx.path_global(sp, self.rtpath(\"CountIsNextParam\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n+                                                                    \"CountIsNextParam\"));\n                 self.ecx.expr_path(path)\n             }\n             parse::CountIsName(n) => {\n@@ -369,14 +368,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                     None => 0, // error already emitted elsewhere\n                 };\n                 let i = i + self.args.len();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n+                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n                                           vec!(self.ecx.expr_uint(sp, i)))\n             }\n         }\n     }\n \n     /// Translate the accumulated string literals to a literal expression\n-    fn trans_literal_string(&mut self) -> Gc<ast::Expr> {\n+    fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n         let s = token::intern_and_get_ident(self.literal.as_slice());\n         self.literal.clear();\n@@ -385,7 +384,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Translate a `parse::Piece` to a static `rt::Argument` or append\n     /// to the `literal` string.\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<Gc<ast::Expr>> {\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<P<ast::Expr>> {\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n@@ -397,12 +396,12 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos = match arg.position {\n                     // These two have a direct mapping\n                     parse::ArgumentNext => {\n-                        let path = self.ecx.path_global(sp,\n-                                                        self.rtpath(\"ArgumentNext\"));\n+                        let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n+                                                                            \"ArgumentNext\"));\n                         self.ecx.expr_path(path)\n                     }\n                     parse::ArgumentIs(i) => {\n-                        self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n+                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n                                                   vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                     // Named arguments are converted to positional arguments at\n@@ -413,7 +412,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             None => 0, // error already emitted elsewhere\n                         };\n                         let i = i + self.args.len();\n-                        self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n+                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n                                                   vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                 };\n@@ -440,72 +439,71 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignLeft\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignLeft\"))\n                     }\n                     parse::AlignRight => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignRight\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignRight\"))\n                     }\n                     parse::AlignCenter => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignCenter\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignCenter\"))\n                     }\n                     parse::AlignUnknown => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignUnknown\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignUnknown\"))\n                     }\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_uint(sp, arg.format.flags);\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, self.rtpath(\"FormatSpec\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n \n-                let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n                 Some(self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt))))\n             }\n         }\n     }\n \n-    fn item_static_array(&self,\n+    fn item_static_array(ecx: &mut ExtCtxt,\n                          name: ast::Ident,\n-                         piece_ty: Gc<ast::Ty>,\n-                         pieces: Vec<Gc<ast::Expr>>)\n-        -> ast::Stmt\n-    {\n-        let pieces_len = self.ecx.expr_uint(self.fmtsp, pieces.len());\n-        let fmt = self.ecx.expr_vec(self.fmtsp, pieces);\n+                         piece_ty: P<ast::Ty>,\n+                         pieces: Vec<P<ast::Expr>>)\n+                         -> P<ast::Stmt> {\n+        let fmtsp = piece_ty.span;\n+        let pieces_len = ecx.expr_uint(fmtsp, pieces.len());\n+        let fmt = ecx.expr_vec(fmtsp, pieces);\n         let ty = ast::TyFixedLengthVec(\n             piece_ty,\n             pieces_len\n         );\n-        let ty = self.ecx.ty(self.fmtsp, ty);\n+        let ty = ecx.ty(fmtsp, ty);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n-        let item = self.ecx.item(self.fmtsp, name,\n-                                 self.static_attrs(), st);\n-        let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        respan(self.fmtsp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        let item = ecx.item(fmtsp, name, Context::static_attrs(ecx, fmtsp), st);\n+        let decl = respan(fmtsp, ast::DeclItem(item));\n+        P(respan(fmtsp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(&self, invocation: Invocation) -> Gc<ast::Expr> {\n+    fn to_expr(mut self, invocation: Invocation) -> P<ast::Expr> {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n         // First, declare all of our methods that are statics\n-        for &method in self.method_statics.iter() {\n+        for method in self.method_statics.move_iter() {\n             let decl = respan(self.fmtsp, ast::DeclItem(method));\n-            lets.push(box(GC) respan(self.fmtsp,\n-                              ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n+            lets.push(P(respan(self.fmtsp,\n+                               ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID))));\n         }\n \n         // Next, build up the static array which will become our precompiled\n@@ -517,23 +515,25 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n                 Some(static_lifetime),\n                 ast::MutImmutable);\n-        lets.push(box(GC) self.item_static_array(static_str_name,\n-                                                 piece_ty,\n-                                                 self.str_pieces.clone()));\n+        lets.push(Context::item_static_array(self.ecx,\n+                                             static_str_name,\n+                                             piece_ty,\n+                                             self.str_pieces));\n \n         // Then, build up the static array which will store our precompiled\n         // nonstandard placeholders, if there are any.\n         let static_args_name = self.ecx.ident_of(\"__STATIC_FMTARGS\");\n         if !self.all_pieces_simple {\n             let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n                     self.fmtsp,\n-                    true, self.rtpath(\"Argument\"),\n+                    true, Context::rtpath(self.ecx, \"Argument\"),\n                     vec![static_lifetime],\n                     vec![]\n                 ), None);\n-            lets.push(box(GC) self.item_static_array(static_args_name,\n-                                                     piece_ty,\n-                                                     self.pieces.clone()));\n+            lets.push(Context::item_static_array(self.ecx,\n+                                                 static_args_name,\n+                                                 piece_ty,\n+                                                 self.pieces));\n         }\n \n         // Right now there is a bug such that for the expression:\n@@ -543,31 +543,35 @@ impl<'a, 'b> Context<'a, 'b> {\n         // format! string are shoved into locals. Furthermore, we shove the address\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n-        for (i, &e) in self.args.iter().enumerate() {\n-            if self.arg_types.get(i).is_none() {\n-                continue // error already generated\n-            }\n+        for (i, e) in self.args.move_iter().enumerate() {\n+            let arg_ty = match self.arg_types.get(i).as_ref() {\n+                Some(ty) => ty,\n+                None => continue // error already generated\n+            };\n \n             let name = self.ecx.ident_of(format!(\"__arg{}\", i).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, name));\n+            locals.push(Context::format_arg(self.ecx, e.span, arg_ty,\n+                                            self.ecx.expr_ident(e.span, name)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n-            locals.push(self.format_arg(e.span, Exact(i),\n-                                        self.ecx.expr_ident(e.span, name)));\n         }\n         for name in self.name_ordering.iter() {\n-            let e = match self.names.find(name) {\n-                Some(&e) if self.name_types.contains_key(name) => e,\n-                Some(..) | None => continue\n+            let e = match self.names.pop(name) {\n+                Some(e) => e,\n+                None => continue\n+            };\n+            let arg_ty = match self.name_types.find(name) {\n+                Some(ty) => ty,\n+                None => continue\n             };\n \n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n                                                   *name).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            heads.push(self.ecx.expr_addr_of(e.span, e));\n             *names.get_mut(*self.name_positions.get(name)) =\n-                Some(self.format_arg(e.span,\n-                                     Named((*name).clone()),\n-                                     self.ecx.expr_ident(e.span, lname)));\n+                Some(Context::format_arg(self.ecx, e.span, arg_ty,\n+                                         self.ecx.expr_ident(e.span, lname)));\n+            heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n \n         // Now create a vector containing all the arguments\n@@ -611,12 +615,14 @@ impl<'a, 'b> Context<'a, 'b> {\n         let res = self.ecx.expr_ident(self.fmtsp, resname);\n         let result = match invocation {\n             Call(e) => {\n-                self.ecx.expr_call(e.span, e,\n-                                   vec!(self.ecx.expr_addr_of(e.span, res)))\n+                let span = e.span;\n+                self.ecx.expr_call(span, e,\n+                                   vec!(self.ecx.expr_addr_of(span, res)))\n             }\n             MethodCall(e, m) => {\n-                self.ecx.expr_method_call(e.span, e, m,\n-                                          vec!(self.ecx.expr_addr_of(e.span, res)))\n+                let span = e.span;\n+                self.ecx.expr_method_call(span, e, m,\n+                                          vec!(self.ecx.expr_addr_of(span, res)))\n             }\n         };\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n@@ -655,13 +661,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n     }\n \n-    fn format_arg(&self, sp: Span, argno: Position, arg: Gc<ast::Expr>)\n-                  -> Gc<ast::Expr> {\n-        let ty = match argno {\n-            Exact(ref i) => self.arg_types.get(*i).get_ref(),\n-            Named(ref s) => self.name_types.get(s)\n-        };\n-\n+    fn format_arg(ecx: &ExtCtxt, sp: Span,\n+                  ty: &ArgumentType, arg: P<ast::Expr>)\n+                  -> P<ast::Expr> {\n         let (krate, fmt_fn) = match *ty {\n             Known(ref tyname) => {\n                 match tyname.as_slice() {\n@@ -681,36 +683,35 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"x\" => (\"std\", \"secret_lower_hex\"),\n                     \"X\" => (\"std\", \"secret_upper_hex\"),\n                     _ => {\n-                        self.ecx\n-                            .span_err(sp,\n-                                      format!(\"unknown format trait `{}`\",\n-                                              *tyname).as_slice());\n+                        ecx.span_err(sp,\n+                                     format!(\"unknown format trait `{}`\",\n+                                             *tyname).as_slice());\n                         (\"std\", \"dummy\")\n                     }\n                 }\n             }\n             String => {\n-                return self.ecx.expr_call_global(sp, vec!(\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentstr\")), vec!(arg))\n+                return ecx.expr_call_global(sp, vec![\n+                        ecx.ident_of(\"std\"),\n+                        ecx.ident_of(\"fmt\"),\n+                        ecx.ident_of(\"argumentstr\")], vec![arg])\n             }\n             Unsigned => {\n-                return self.ecx.expr_call_global(sp, vec!(\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentuint\")), vec!(arg))\n+                return ecx.expr_call_global(sp, vec![\n+                        ecx.ident_of(\"std\"),\n+                        ecx.ident_of(\"fmt\"),\n+                        ecx.ident_of(\"argumentuint\")], vec![arg])\n             }\n         };\n \n-        let format_fn = self.ecx.path_global(sp, vec!(\n-                self.ecx.ident_of(krate),\n-                self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(fmt_fn)));\n-        self.ecx.expr_call_global(sp, vec!(\n-                self.ecx.ident_of(\"std\"),\n-                self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(\"argument\")), vec!(self.ecx.expr_path(format_fn), arg))\n+        let format_fn = ecx.path_global(sp, vec![\n+                ecx.ident_of(krate),\n+                ecx.ident_of(\"fmt\"),\n+                ecx.ident_of(fmt_fn)]);\n+        ecx.expr_call_global(sp, vec![\n+                ecx.ident_of(\"std\"),\n+                ecx.ident_of(\"fmt\"),\n+                ecx.ident_of(\"argument\")], vec![ecx.expr_path(format_fn), arg])\n     }\n }\n \n@@ -744,12 +745,11 @@ pub fn expand_format_args_method<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     invocation: Invocation,\n-                                    efmt: Gc<ast::Expr>,\n-                                    args: Vec<Gc<ast::Expr>>,\n+                                    efmt: P<ast::Expr>,\n+                                    args: Vec<P<ast::Expr>>,\n                                     name_ordering: Vec<String>,\n-                                    names: HashMap<String, Gc<ast::Expr>>)\n-    -> Gc<ast::Expr>\n-{\n+                                    names: HashMap<String, P<ast::Expr>>)\n+                                    -> P<ast::Expr> {\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,\n@@ -796,7 +796,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n     match parser.errors.shift() {\n         Some(error) => {\n-            cx.ecx.span_err(efmt.span,\n+            cx.ecx.span_err(cx.fmtsp,\n                             format!(\"invalid format string: {}\",\n                                     error).as_slice());\n             return DummyResult::raw_expr(sp);"}, {"sha": "6f13a2e6a51fc8a57c9fd70b6732bd2facbbb59a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,8 +15,7 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token::*;\n use parse::token;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n /**\n *\n@@ -36,14 +35,13 @@ pub mod rt {\n     use parse::token;\n     use parse;\n     use print::pprust;\n+    use ptr::P;\n \n     use ast::{TokenTree, Generics, Expr};\n \n     pub use parse::new_parser_from_tts;\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n-    use std::gc::Gc;\n-\n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> ;\n     }\n@@ -107,13 +105,13 @@ pub mod rt {\n     }\n \n     macro_rules! impl_to_source(\n-        (Gc<$t:ty>, $pp:ident) => (\n-            impl ToSource for Gc<$t> {\n+        (P<$t:ty>, $pp:ident) => (\n+            impl ToSource for P<$t> {\n                 fn to_source(&self) -> String {\n                     pprust::$pp(&**self)\n                 }\n             }\n-            impl ToSourceWithHygiene for Gc<$t> {\n+            impl ToSourceWithHygiene for P<$t> {\n                 fn to_source_with_hygiene(&self) -> String {\n                     pprust::with_hygiene::$pp(&**self)\n                 }\n@@ -182,18 +180,18 @@ pub mod rt {\n     impl_to_source!(ast::Block, block_to_string)\n     impl_to_source!(ast::Arg, arg_to_string)\n     impl_to_source!(Generics, generics_to_string)\n-    impl_to_source!(Gc<ast::Item>, item_to_string)\n-    impl_to_source!(Gc<ast::Method>, method_to_string)\n-    impl_to_source!(Gc<ast::Stmt>, stmt_to_string)\n-    impl_to_source!(Gc<ast::Expr>, expr_to_string)\n-    impl_to_source!(Gc<ast::Pat>, pat_to_string)\n+    impl_to_source!(P<ast::Item>, item_to_string)\n+    impl_to_source!(P<ast::Method>, method_to_string)\n+    impl_to_source!(P<ast::Stmt>, stmt_to_string)\n+    impl_to_source!(P<ast::Expr>, expr_to_string)\n+    impl_to_source!(P<ast::Pat>, pat_to_string)\n     impl_to_source!(ast::Arm, arm_to_string)\n     impl_to_source_slice!(ast::Ty, \", \")\n-    impl_to_source_slice!(Gc<ast::Item>, \"\\n\\n\")\n+    impl_to_source_slice!(P<ast::Item>, \"\\n\\n\")\n \n     impl ToSource for ast::Attribute_ {\n         fn to_source(&self) -> String {\n-            pprust::attribute_to_string(&dummy_spanned(*self))\n+            pprust::attribute_to_string(&dummy_spanned(self.clone()))\n         }\n     }\n     impl ToSourceWithHygiene for ast::Attribute_ {\n@@ -315,16 +313,16 @@ pub mod rt {\n     )\n \n     impl_to_tokens!(ast::Ident)\n-    impl_to_tokens!(Gc<ast::Item>)\n-    impl_to_tokens!(Gc<ast::Pat>)\n+    impl_to_tokens!(P<ast::Item>)\n+    impl_to_tokens!(P<ast::Pat>)\n     impl_to_tokens!(ast::Arm)\n-    impl_to_tokens!(Gc<ast::Method>)\n-    impl_to_tokens_lifetime!(&'a [Gc<ast::Item>])\n+    impl_to_tokens!(P<ast::Method>)\n+    impl_to_tokens_lifetime!(&'a [P<ast::Item>])\n     impl_to_tokens!(ast::Ty)\n     impl_to_tokens_lifetime!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n-    impl_to_tokens!(Gc<ast::Stmt>)\n-    impl_to_tokens!(Gc<ast::Expr>)\n+    impl_to_tokens!(P<ast::Stmt>)\n+    impl_to_tokens!(P<ast::Expr>)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens!(ast::Arg)\n     impl_to_tokens!(ast::Attribute_)\n@@ -344,9 +342,9 @@ pub mod rt {\n     impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: String) -> Gc<ast::Item>;\n-        fn parse_expr(&self, s: String) -> Gc<ast::Expr>;\n-        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt>;\n+        fn parse_item(&self, s: String) -> P<ast::Item>;\n+        fn parse_expr(&self, s: String) -> P<ast::Expr>;\n+        fn parse_stmt(&self, s: String) -> P<ast::Stmt>;\n         fn parse_tts(&self, s: String) -> Vec<ast::TokenTree>;\n     }\n \n@@ -358,7 +356,7 @@ pub mod rt {\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n-        fn parse_item(&self, s: String) -> Gc<ast::Item> {\n+        fn parse_item(&self, s: String) -> P<ast::Item> {\n             let res = parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n@@ -373,15 +371,15 @@ pub mod rt {\n             }\n         }\n \n-        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt> {\n+        fn parse_stmt(&self, s: String) -> P<ast::Stmt> {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n                                               Vec::new(),\n                                               self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: String) -> Gc<ast::Expr> {\n+        fn parse_expr(&self, s: String) -> P<ast::Expr> {\n             parse::parse_expr_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n@@ -491,7 +489,7 @@ fn id_ext(str: &str) -> ast::Ident {\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n+fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n     let e_str = cx.expr_str(sp, token::get_ident(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n@@ -500,25 +498,25 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n }\n \n // Lift a name to the expr that evaluates to that name\n-fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n+fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n     let e_str = cx.expr_str(sp, token::get_ident(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"name_of\"),\n                         vec!(e_str))\n }\n \n-fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n+fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n+fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> Gc<ast::Expr> {\n+fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> P<ast::Expr> {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -534,7 +532,7 @@ fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> Gc<ast::Expr> {\n     mk_token_path(cx, sp, name)\n }\n \n-fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n+fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -640,7 +638,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n }\n \n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<Gc<ast::Stmt>> {\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n     match *tt {\n         ast::TTTok(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -680,7 +678,7 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<Gc<ast::Stmt>> {\n }\n \n fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> Vec<Gc<ast::Stmt>> {\n+    -> Vec<P<ast::Stmt>> {\n     let mut ss = Vec::new();\n     for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n@@ -689,7 +687,7 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-              -> (Gc<ast::Expr>, Gc<ast::Expr>) {\n+              -> (P<ast::Expr>, P<ast::Expr>) {\n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a TTNonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n@@ -757,8 +755,8 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n-                  cx_expr: Gc<ast::Expr>,\n-                  expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+                  cx_expr: P<ast::Expr>,\n+                  expr: P<ast::Expr>) -> P<ast::Expr> {\n     let uses = [\n         &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n     ].iter().map(|path| {\n@@ -776,8 +774,8 @@ fn expand_wrapper(cx: &ExtCtxt,\n fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n-                     arg_exprs: Vec<Gc<ast::Expr>>,\n-                     tts: &[ast::TokenTree]) -> Gc<ast::Expr> {\n+                     arg_exprs: Vec<P<ast::Expr>> ,\n+                     tts: &[ast::TokenTree]) -> P<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call("}, {"sha": "3006bcaf6f8764d9b50bfce703b35423b59c2383", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -87,9 +87,9 @@ use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n use parse::token::{Token, EOF, Nonterminal};\n use parse::token;\n+use ptr::P;\n \n use std::rc::Rc;\n-use std::gc::GC;\n use std::collections::HashMap;\n \n /* to avoid costly uniqueness checks, we require that `MatchSeq` always has a\n@@ -451,7 +451,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       \"tt\" => {\n         p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n-        let res = token::NtTT(box(GC) p.parse_token_tree());\n+        let res = token::NtTT(P(p.parse_token_tree()));\n         p.quote_depth -= 1u;\n         res\n       }"}, {"sha": "6c7bbb2384c12630f87ee5f5d892e017ec71a6dc", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq};\n-use ast::{TTDelim};\n+use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq, TTDelim};\n use ast;\n use codemap::{Span, Spanned, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, MacroDef};\n@@ -24,11 +23,12 @@ use parse::token::{special_idents, gensym_ident};\n use parse::token::{FAT_ARROW, SEMI, NtMatchers, NtTT, EOF};\n use parse::token;\n use print;\n+use ptr::P;\n+\n use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::gc::Gc;\n \n struct ParserAnyMacro<'a> {\n     parser: RefCell<Parser<'a>>,\n@@ -58,17 +58,17 @@ impl<'a> ParserAnyMacro<'a> {\n }\n \n impl<'a> MacResult for ParserAnyMacro<'a> {\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Expr>> {\n         let ret = self.parser.borrow_mut().parse_expr();\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Pat>> {\n         let ret = self.parser.borrow_mut().parse_pat();\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -84,7 +84,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+    fn make_methods(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Method>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -97,7 +97,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+    fn make_stmt(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Stmt>> {\n         let attrs = self.parser.borrow_mut().parse_outer_attributes();\n         let ret = self.parser.borrow_mut().parse_stmt(attrs);\n         self.ensure_complete_parse(true);\n@@ -127,11 +127,11 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n }\n \n struct MacroRulesDefiner {\n-    def: RefCell<Option<MacroDef>>\n+    def: Option<MacroDef>\n }\n impl MacResult for MacroRulesDefiner {\n-    fn make_def(&self) -> Option<MacroDef> {\n-        Some(self.def.borrow_mut().take().expect(\"MacroRulesDefiner expanded twice\"))\n+    fn make_def(&mut self) -> Option<MacroDef> {\n+        Some(self.def.take().expect(\"empty MacroRulesDefiner\"))\n     }\n }\n \n@@ -170,8 +170,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n               Success(named_matches) => {\n                 let rhs = match *rhses[i] {\n                     // okay, what's your transcriber?\n-                    MatchedNonterminal(NtTT(tt)) => {\n-                        match *tt {\n+                    MatchedNonterminal(NtTT(ref tt)) => {\n+                        match **tt {\n                             // cut off delimiters; don't parse 'em\n                             TTDelim(ref tts) => {\n                                 (*tts).slice(1u,(*tts).len()-1u)\n@@ -269,9 +269,9 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     };\n \n     box MacroRulesDefiner {\n-        def: RefCell::new(Some(MacroDef {\n+        def: Some(MacroDef {\n             name: token::get_ident(name).to_string(),\n             ext: NormalTT(exp, Some(sp))\n-        }))\n+        })\n     } as Box<MacResult+'cx>\n }"}, {"sha": "7d8a9e08ba02b9b687194017ba8702b0db20ecb8", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -11,7 +11,7 @@\n use std::fmt;\n use std::default::Default;\n use std::hash;\n-use std::{mem, raw, ptr, slice};\n+use std::{mem, raw, ptr, slice, vec};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A non-growable owned slice. This would preferably become `~[T]`\n@@ -105,6 +105,10 @@ impl<T> OwnedSlice<T> {\n         self.as_slice().iter()\n     }\n \n+    pub fn move_iter(self) -> vec::MoveItems<T> {\n+        self.into_vec().move_iter()\n+    }\n+\n     pub fn map<U>(&self, f: |&T| -> U) -> OwnedSlice<U> {\n         self.iter().map(f).collect()\n     }"}, {"sha": "74b93e75e64dd88bc54920fa4282f5813cb4cc62", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,18 +15,17 @@ use parse::common::*; //resolve bug?\n use parse::token;\n use parse::parser::Parser;\n use parse::token::INTERPOLATED;\n-\n-use std::gc::{Gc, GC};\n+use ptr::P;\n \n /// A parser that can parse attributes.\n pub trait ParserAttr {\n     fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute>;\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&mut self)\n                                   -> (Vec<ast::Attribute>, Vec<ast::Attribute>);\n-    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem>;\n-    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>>;\n-    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>>;\n+    fn parse_meta_item(&mut self) -> P<ast::MetaItem>;\n+    fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>>;\n+    fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>>;\n }\n \n impl<'a> ParserAttr for Parser<'a> {\n@@ -160,13 +159,20 @@ impl<'a> ParserAttr for Parser<'a> {\n     /// matches meta_item = IDENT\n     /// | IDENT = lit\n     /// | IDENT meta_seq\n-    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem> {\n-        match self.token {\n-            token::INTERPOLATED(token::NtMeta(e)) => {\n+    fn parse_meta_item(&mut self) -> P<ast::MetaItem> {\n+        let nt_meta = match self.token {\n+            token::INTERPOLATED(token::NtMeta(ref e)) => {\n+                Some(e.clone())\n+            }\n+            _ => None\n+        };\n+\n+        match nt_meta {\n+            Some(meta) => {\n                 self.bump();\n-                return e\n+                return meta;\n             }\n-            _ => {}\n+            None => {}\n         }\n \n         let lo = self.span.lo;\n@@ -187,29 +193,29 @@ impl<'a> ParserAttr for Parser<'a> {\n                     }\n                 }\n                 let hi = self.span.hi;\n-                box(GC) spanned(lo, hi, ast::MetaNameValue(name, lit))\n+                P(spanned(lo, hi, ast::MetaNameValue(name, lit)))\n             }\n             token::LPAREN => {\n                 let inner_items = self.parse_meta_seq();\n                 let hi = self.span.hi;\n-                box(GC) spanned(lo, hi, ast::MetaList(name, inner_items))\n+                P(spanned(lo, hi, ast::MetaList(name, inner_items)))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                box(GC) spanned(lo, hi, ast::MetaWord(name))\n+                P(spanned(lo, hi, ast::MetaWord(name)))\n             }\n         }\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>> {\n+    fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>> {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>> {\n+    fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>> {\n         match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => Vec::new()"}, {"sha": "cdd221aca7cf01b72a94b2a255379af8682f5466", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -13,7 +13,6 @@\n // Predicates on exprs and stmts that the pretty-printer and parser use\n \n use ast;\n-use std::gc::Gc;\n \n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression\n@@ -22,7 +21,7 @@ use std::gc::Gc;\n ///     if true {...} else {...}\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n-pub fn expr_requires_semi_to_be_stmt(e: Gc<ast::Expr>) -> bool {\n+pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n     match e.node {\n         ast::ExprIf(..)\n         | ast::ExprMatch(..)\n@@ -34,25 +33,25 @@ pub fn expr_requires_semi_to_be_stmt(e: Gc<ast::Expr>) -> bool {\n     }\n }\n \n-pub fn expr_is_simple_block(e: Gc<ast::Expr>) -> bool {\n+pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n     match e.node {\n-        ast::ExprBlock(block) => block.rules == ast::DefaultBlock,\n-      _ => false\n+        ast::ExprBlock(ref block) => block.rules == ast::DefaultBlock,\n+        _ => false\n     }\n }\n \n /// this statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n-pub fn stmt_ends_with_semi(stmt: &ast::Stmt) -> bool {\n-    return match stmt.node {\n-        ast::StmtDecl(d, _) => {\n+pub fn stmt_ends_with_semi(stmt: &ast::Stmt_) -> bool {\n+    match *stmt {\n+        ast::StmtDecl(ref d, _) => {\n             match d.node {\n                 ast::DeclLocal(_) => true,\n                 ast::DeclItem(_) => false\n             }\n         }\n-        ast::StmtExpr(e, _) => { expr_requires_semi_to_be_stmt(e) }\n+        ast::StmtExpr(ref e, _) => { expr_requires_semi_to_be_stmt(&**e) }\n         ast::StmtSemi(..) => { false }\n         ast::StmtMac(..) => { false }\n     }"}, {"sha": "c4ee1b60da48a46a366792857f7988075f835420", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -15,9 +15,9 @@ use codemap::{Span, CodeMap, FileMap};\n use diagnostic::{SpanHandler, mk_span_handler, default_handler, Auto};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n+use ptr::P;\n \n use std::cell::RefCell;\n-use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -106,7 +106,7 @@ pub fn parse_expr_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Gc<ast::Expr> {\n+                                  -> P<ast::Expr> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n@@ -115,7 +115,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Option<Gc<ast::Item>> {\n+                                  -> Option<P<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_item_with_outer_attributes(),p)\n }\n@@ -124,7 +124,7 @@ pub fn parse_meta_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Gc<ast::MetaItem> {\n+                                  -> P<ast::MetaItem> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n@@ -134,7 +134,7 @@ pub fn parse_stmt_from_source_str(name: String,\n                                   cfg: ast::CrateConfig,\n                                   attrs: Vec<ast::Attribute> ,\n                                   sess: &ParseSess)\n-                                  -> Gc<ast::Stmt> {\n+                                  -> P<ast::Stmt> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -722,7 +722,7 @@ mod test {\n \n     #[test] fn path_exprs_1() {\n         assert!(string_to_expr(\"a\".to_string()) ==\n-                   box(GC) ast::Expr{\n+                   P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n@@ -736,12 +736,12 @@ mod test {\n                         ),\n                     }),\n                     span: sp(0, 1)\n-                   })\n+                   }))\n     }\n \n     #[test] fn path_exprs_2 () {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n-                   box(GC) ast::Expr {\n+                   P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n@@ -760,7 +760,7 @@ mod test {\n                             )\n                         }),\n                     span: sp(0, 6)\n-                   })\n+                   }))\n     }\n \n     #[should_fail]\n@@ -953,9 +953,9 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert!(string_to_expr(\"return d\".to_string()) ==\n-                   box(GC) ast::Expr{\n+                   P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node:ast::ExprRet(Some(box(GC) ast::Expr{\n+                    node:ast::ExprRet(Some(P(ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n@@ -969,15 +969,15 @@ mod test {\n                             ),\n                         }),\n                         span:sp(7,8)\n-                    })),\n+                    }))),\n                     span:sp(0,8)\n-                   })\n+                   }))\n     }\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   box(GC) Spanned{\n-                       node: ast::StmtExpr(box(GC) ast::Expr {\n+                   P(Spanned{\n+                       node: ast::StmtExpr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n@@ -990,9 +990,9 @@ mod test {\n                                 }\n                                ),\n                             }),\n-                           span: sp(0,1)},\n+                           span: sp(0,1)}),\n                                            ast::DUMMY_NODE_ID),\n-                       span: sp(0,1)})\n+                       span: sp(0,1)}))\n \n     }\n \n@@ -1004,14 +1004,14 @@ mod test {\n         let sess = new_parse_sess();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n         assert!(parser.parse_pat()\n-                == box(GC) ast::Pat{\n+                == P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::PatIdent(ast::BindByValue(ast::MutImmutable),\n                                     Spanned{ span:sp(0, 1),\n                                              node: str_to_ident(\"b\")\n                     },\n                                     None),\n-                span: sp(0,1)});\n+                span: sp(0,1)}));\n         parser_done(parser);\n     }\n \n@@ -1020,7 +1020,7 @@ mod test {\n         // this test depends on the intern order of \"fn\" and \"int\"\n         assert!(string_to_item(\"fn a (b : int) { b; }\".to_string()) ==\n                   Some(\n-                      box(GC) ast::Item{ident:str_to_ident(\"a\"),\n+                      P(ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemFn(ast::P(ast::FnDecl {\n@@ -1040,7 +1040,7 @@ mod test {\n                                         }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n-                                    pat: box(GC) ast::Pat {\n+                                    pat: P(ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n                                             ast::BindByValue(ast::MutImmutable),\n@@ -1050,7 +1050,7 @@ mod test {\n                                                 None\n                                                     ),\n                                             span: sp(6,7)\n-                                        },\n+                                    }),\n                                         id: ast::DUMMY_NODE_ID\n                                     }),\n                                 output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n@@ -1071,8 +1071,8 @@ mod test {\n                                     },\n                                     ast::P(ast::Block {\n                                         view_items: Vec::new(),\n-                                        stmts: vec!(box(GC) Spanned{\n-                                            node: ast::StmtSemi(box(GC) ast::Expr{\n+                                        stmts: vec!(P(Spanned{\n+                                            node: ast::StmtSemi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprPath(\n                                                       ast::Path{\n@@ -1090,28 +1090,28 @@ mod test {\n                                                             }\n                                                         ),\n                                                       }),\n-                                                span: sp(17,18)},\n+                                                span: sp(17,18)}),\n                                                 ast::DUMMY_NODE_ID),\n-                                            span: sp(17,19)}),\n+                                            span: sp(17,19)})),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::DefaultBlock, // no idea\n                                         span: sp(15,21),\n                                     })),\n                             vis: ast::Inherited,\n-                            span: sp(0,21)}));\n+                            span: sp(0,21)})));\n     }\n \n \n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n         string_to_expr(\"3 + 4\".to_string());\n-        string_to_expr(\"a::z.froob(b,box(GC)(987+3))\".to_string());\n+        string_to_expr(\"a::z.froob(b,&(987+3))\".to_string());\n     }\n \n     #[test] fn attrs_fix_bug () {\n         string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<Gc<Writer>, String> {\n+                   -> Result<Box<Writer>, String> {\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int"}, {"sha": "d47231bc3e2de5ea25b6b1df8d908fa4382f6c35", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -21,8 +21,7 @@ use ast::{Expr, ExprLit, LitNil};\n use codemap::{Span, respan};\n use parse::parser;\n use parse::token;\n-\n-use std::gc::{Gc, GC};\n+use ptr::P;\n \n /// The specific types of unsupported syntax\n #[deriving(PartialEq, Eq, Hash)]\n@@ -44,7 +43,7 @@ pub trait ParserObsoleteMethods {\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);\n     /// Reports an obsolete syntax non-fatal error, and returns\n     /// a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr>;\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> P<Expr>;\n     fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n@@ -105,9 +104,9 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n \n     /// Reports an obsolete syntax non-fatal error, and returns\n     /// a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr> {\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> P<Expr> {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, ExprLit(box(GC) respan(sp, LitNil)))\n+        self.mk_expr(sp.lo, sp.hi, ExprLit(P(respan(sp, LitNil))))\n     }\n \n     fn report(&mut self,"}, {"sha": "f41362cad418513d1fab2c1f4feb1e7214767a89", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 251, "deletions": 236, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -39,9 +39,8 @@ use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitNil, LitStr, LitInt, Local, LocalLet};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n-use ast::{MethodImplItem};\n-use ast::{NamedField, UnNeg, NoReturn, UnNot, P, Pat, PatEnum};\n-use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n+use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n+use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n use ast::{BiRem, RequiredMethod};\n use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n@@ -79,12 +78,13 @@ use parse::token::{is_ident, is_ident_or_path, is_plain_ident};\n use parse::token::{keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n+use ptr::P;\n use owned_slice::OwnedSlice;\n \n use std::collections::HashSet;\n use std::mem::replace;\n+use std::mem;\n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n use std::iter;\n \n #[allow(non_camel_case_types)]\n@@ -127,8 +127,8 @@ enum ItemOrViewItem {\n     /// Indicates a failure to parse any kind of item. The attributes are\n     /// returned.\n     IoviNone(Vec<Attribute>),\n-    IoviItem(Gc<Item>),\n-    IoviForeignItem(Gc<ForeignItem>),\n+    IoviItem(P<Item>),\n+    IoviForeignItem(P<ForeignItem>),\n     IoviViewItem(ViewItem)\n }\n \n@@ -143,8 +143,8 @@ macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n         {\n             let found = match $p.token {\n-                INTERPOLATED(token::NtExpr(e)) => {\n-                    Some(e)\n+                INTERPOLATED(token::NtExpr(ref e)) => {\n+                    Some((*e).clone())\n                 }\n                 INTERPOLATED(token::NtPath(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -156,7 +156,13 @@ macro_rules! maybe_whole_expr (\n                     let span = $p.span;\n                     Some($p.mk_expr(span.lo, span.hi, ExprPath(pt)))\n                 }\n-                INTERPOLATED(token::NtBlock(b)) => {\n+                INTERPOLATED(token::NtBlock(_)) => {\n+                    // FIXME: The following avoids an issue with lexical borrowck scopes,\n+                    // but the clone is unfortunate.\n+                    let b = match $p.token {\n+                        INTERPOLATED(token::NtBlock(ref b)) => (*b).clone(),\n+                        _ => unreachable!()\n+                    };\n                     let span = $p.span;\n                     Some($p.mk_expr(span.lo, span.hi, ExprBlock(b)))\n                 }\n@@ -286,8 +292,8 @@ fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n struct ParsedItemsAndViewItems {\n     attrs_remaining: Vec<Attribute>,\n     view_items: Vec<ViewItem>,\n-    items: Vec<Gc<Item>>,\n-    foreign_items: Vec<Gc<ForeignItem>>\n+    items: Vec<P<Item>> ,\n+    foreign_items: Vec<P<ForeignItem>>\n }\n \n /* ident is handled by common.rs */\n@@ -484,8 +490,7 @@ impl<'a> Parser<'a> {\n     /// Commit to parsing a complete expression `e` expected to be\n     /// followed by some token from the set edible + inedible.  Recover\n     /// from anticipated input errors, discarding erroneous characters.\n-    pub fn commit_expr(&mut self, e: Gc<Expr>, edible: &[token::Token],\n-                       inedible: &[token::Token]) {\n+    pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token], inedible: &[token::Token]) {\n         debug!(\"commit_expr {:?}\", e);\n         match e.node {\n             ExprPath(..) => {\n@@ -500,17 +505,14 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_expr_expecting(&mut self, e: Gc<Expr>, edible: token::Token) {\n+    pub fn commit_expr_expecting(&mut self, e: &Expr, edible: token::Token) {\n         self.commit_expr(e, &[edible], &[])\n     }\n \n     /// Commit to parsing a complete statement `s`, which expects to be\n     /// followed by some token from the set edible + inedible.  Check\n     /// for recoverable input errors, discarding erroneous characters.\n-    pub fn commit_stmt(&mut self, s: Gc<Stmt>, edible: &[token::Token],\n-                       inedible: &[token::Token]) {\n-        debug!(\"commit_stmt {:?}\", s);\n-        let _s = s; // unused, but future checks might want to inspect `s`.\n+    pub fn commit_stmt(&mut self, edible: &[token::Token], inedible: &[token::Token]) {\n         if self.last_token\n                .as_ref()\n                .map_or(false, |t| is_ident_or_path(&**t)) {\n@@ -522,8 +524,8 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_stmt_expecting(&mut self, s: Gc<Stmt>, edible: token::Token) {\n-        self.commit_stmt(s, &[edible], &[])\n+    pub fn commit_stmt_expecting(&mut self, edible: token::Token) {\n+        self.commit_stmt(&[edible], &[])\n     }\n \n     pub fn parse_ident(&mut self) -> ast::Ident {\n@@ -1043,12 +1045,12 @@ impl<'a> Parser<'a> {\n \n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n-        return TyBareFn(box(GC) BareFnTy {\n+        TyBareFn(P(BareFnTy {\n             abi: abi,\n             fn_style: fn_style,\n             lifetimes: lifetimes,\n             decl: decl\n-        });\n+        }))\n     }\n \n     /// Parses a procedure type (`proc`). The initial `proc` keyword must\n@@ -1084,13 +1086,13 @@ impl<'a> Parser<'a> {\n             cf: ret_style,\n             variadic: variadic\n         });\n-        TyProc(box(GC) ClosureTy {\n+        TyProc(P(ClosureTy {\n             fn_style: NormalFn,\n             onceness: Once,\n             bounds: bounds,\n             decl: decl,\n             lifetimes: lifetime_defs,\n-        })\n+        }))\n     }\n \n     /// Parses an optional unboxed closure kind (`&:`, `&mut:`, or `:`).\n@@ -1176,19 +1178,19 @@ impl<'a> Parser<'a> {\n \n         match optional_unboxed_closure_kind {\n             Some(unboxed_closure_kind) => {\n-                TyUnboxedFn(box(GC) UnboxedFnTy {\n+                TyUnboxedFn(P(UnboxedFnTy {\n                     kind: unboxed_closure_kind,\n                     decl: decl,\n-                })\n+                }))\n             }\n             None => {\n-                TyClosure(box(GC) ClosureTy {\n+                TyClosure(P(ClosureTy {\n                     fn_style: fn_style,\n                     onceness: onceness,\n                     bounds: bounds,\n                     decl: decl,\n                     lifetimes: lifetime_defs,\n-                })\n+                }))\n             }\n         }\n     }\n@@ -1291,8 +1293,9 @@ impl<'a> Parser<'a> {\n                 debug!(\"parse_trait_methods(): parsing provided method\");\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n-                let attrs = attrs.append(inner_attrs.as_slice());\n-                ProvidedMethod(box(GC) ast::Method {\n+                let mut attrs = attrs;\n+                attrs.extend(inner_attrs.move_iter());\n+                ProvidedMethod(P(ast::Method {\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n@@ -1304,7 +1307,7 @@ impl<'a> Parser<'a> {\n                                         d,\n                                         body,\n                                         vis)\n-                })\n+                }))\n               }\n \n               _ => {\n@@ -1400,7 +1403,7 @@ impl<'a> Parser<'a> {\n \n                 if ts.len() == 1 && !one_tuple {\n                     self.expect(&token::RPAREN);\n-                    TyParen(*ts.get(0))\n+                    TyParen(ts.move_iter().nth(0).unwrap())\n                 } else {\n                     let t = TyTup(ts);\n                     self.expect(&token::RPAREN);\n@@ -1588,7 +1591,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<Gc<ast::Expr>> {\n+    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<P<ast::Expr>> {\n         if self.token == token::COMMA &&\n                 self.look_ahead(1, |t| *t == token::DOTDOT) {\n             self.bump();\n@@ -1640,12 +1643,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// matches '-' lit | lit\n-    pub fn parse_literal_maybe_minus(&mut self) -> Gc<Expr> {\n+    pub fn parse_literal_maybe_minus(&mut self) -> P<Expr> {\n         let minus_lo = self.span.lo;\n         let minus_present = self.eat(&token::BINOP(token::MINUS));\n \n         let lo = self.span.lo;\n-        let literal = box(GC) self.parse_lit();\n+        let literal = P(self.parse_lit());\n         let hi = self.span.hi;\n         let expr = self.mk_expr(lo, hi, ExprLit(literal));\n \n@@ -1894,85 +1897,84 @@ impl<'a> Parser<'a> {\n         let e = self.parse_expr();\n         ast::Field {\n             ident: spanned(lo, hi, i),\n-            expr: e,\n             span: mk_sp(lo, e.span.hi),\n+            expr: e,\n         }\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> Gc<Expr> {\n-        box(GC) Expr {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> P<Expr> {\n+        P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n-        }\n+        })\n     }\n \n-    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: Gc<Expr>) -> ast::Expr_ {\n+    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: P<Expr>) -> ast::Expr_ {\n         ExprUnary(unop, expr)\n     }\n \n-    pub fn mk_binary(&mut self, binop: ast::BinOp,\n-                     lhs: Gc<Expr>, rhs: Gc<Expr>) -> ast::Expr_ {\n+    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::Expr_ {\n         ExprBinary(binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: Gc<Expr>, args: Vec<Gc<Expr>>) -> ast::Expr_ {\n+    pub fn mk_call(&mut self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::Expr_ {\n         ExprCall(f, args)\n     }\n \n     fn mk_method_call(&mut self,\n                       ident: ast::SpannedIdent,\n                       tps: Vec<P<Ty>>,\n-                      args: Vec<Gc<Expr>>)\n+                      args: Vec<P<Expr>>)\n                       -> ast::Expr_ {\n         ExprMethodCall(ident, tps, args)\n     }\n \n-    pub fn mk_index(&mut self, expr: Gc<Expr>, idx: Gc<Expr>) -> ast::Expr_ {\n+    pub fn mk_index(&mut self, expr: P<Expr>, idx: P<Expr>) -> ast::Expr_ {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_field(&mut self, expr: Gc<Expr>, ident: ast::SpannedIdent,\n+    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent,\n                     tys: Vec<P<Ty>>) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n-    pub fn mk_tup_field(&mut self, expr: Gc<Expr>, idx: codemap::Spanned<uint>,\n+    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<uint>,\n                     tys: Vec<P<Ty>>) -> ast::Expr_ {\n         ExprTupField(expr, idx, tys)\n     }\n \n     pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n-                        lhs: Gc<Expr>, rhs: Gc<Expr>) -> ast::Expr_ {\n+                        lhs: P<Expr>, rhs: P<Expr>) -> ast::Expr_ {\n         ExprAssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> Gc<Expr> {\n-        box(GC) Expr {\n+    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> P<Expr> {\n+        P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n-        }\n+        })\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32) -> Gc<Expr> {\n+    pub fn mk_lit_u32(&mut self, i: u32) -> P<Expr> {\n         let span = &self.span;\n-        let lv_lit = box(GC) codemap::Spanned {\n+        let lv_lit = P(codemap::Spanned {\n             node: LitInt(i as u64, ast::UnsignedIntLit(TyU32)),\n             span: *span\n-        };\n+        });\n \n-        box(GC) Expr {\n+        P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprLit(lv_lit),\n             span: *span,\n-        }\n+        })\n     }\n \n     /// At the bottom (top?) of the precedence hierarchy,\n     /// parse things like parenthesized exprs,\n     /// macros, return, etc.\n-    pub fn parse_bottom_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_bottom_expr(&mut self) -> P<Expr> {\n         maybe_whole_expr!(self);\n \n         let lo = self.span.lo;\n@@ -1989,28 +1991,27 @@ impl<'a> Parser<'a> {\n                 if self.token == token::RPAREN {\n                     hi = self.span.hi;\n                     self.bump();\n-                    let lit = box(GC) spanned(lo, hi, LitNil);\n+                    let lit = P(spanned(lo, hi, LitNil));\n                     return self.mk_expr(lo, hi, ExprLit(lit));\n                 }\n                 let mut es = vec!(self.parse_expr());\n-                self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n+                self.commit_expr(&**es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n                 while self.token == token::COMMA {\n                     self.bump();\n                     if self.token != token::RPAREN {\n                         es.push(self.parse_expr());\n-                        self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n-                    }\n-                        else {\n+                        self.commit_expr(&**es.last().unwrap(), &[],\n+                                         &[token::COMMA, token::RPAREN]);\n+                    } else {\n                         trailing_comma = true;\n                     }\n                 }\n                 hi = self.span.hi;\n-                self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n+                self.commit_expr_expecting(&**es.last().unwrap(), token::RPAREN);\n \n                 return if es.len() == 1 && !trailing_comma {\n-                    self.mk_expr(lo, hi, ExprParen(*es.get(0)))\n-                }\n-                    else {\n+                   self.mk_expr(lo, hi, ExprParen(es.move_iter().nth(0).unwrap()))\n+                } else {\n                     self.mk_expr(lo, hi, ExprTup(es))\n                 }\n             },\n@@ -2079,14 +2080,14 @@ impl<'a> Parser<'a> {\n                     let decl = self.parse_proc_decl();\n                     let body = self.parse_expr();\n                     let fakeblock = P(ast::Block {\n+                            id: ast::DUMMY_NODE_ID,\n                             view_items: Vec::new(),\n                             stmts: Vec::new(),\n-                            expr: Some(body),\n-                            id: ast::DUMMY_NODE_ID,\n                             rules: DefaultBlock,\n                             span: body.span,\n+                            expr: Some(body),\n                         });\n-                    return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n+                    return self.mk_expr(lo, fakeblock.span.hi, ExprProc(decl, fakeblock));\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr();\n@@ -2200,7 +2201,7 @@ impl<'a> Parser<'a> {\n                                 }\n \n                                 fields.push(self.parse_field());\n-                                self.commit_expr(fields.last().unwrap().expr,\n+                                self.commit_expr(&*fields.last().unwrap().expr,\n                                                  &[token::COMMA],\n                                                  &[token::RBRACE]);\n                             }\n@@ -2227,7 +2228,7 @@ impl<'a> Parser<'a> {\n                     // other literal expression\n                     let lit = self.parse_lit();\n                     hi = lit.span.hi;\n-                    ex = ExprLit(box(GC) lit);\n+                    ex = ExprLit(P(lit));\n                 }\n             }\n         }\n@@ -2237,19 +2238,19 @@ impl<'a> Parser<'a> {\n \n     /// Parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode)\n-                            -> Gc<Expr> {\n+                            -> P<Expr> {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n-    pub fn parse_dot_or_call_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_dot_or_call_expr(&mut self) -> P<Expr> {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    pub fn parse_dot_or_call_expr_with(&mut self, e0: Gc<Expr>) -> Gc<Expr> {\n+    pub fn parse_dot_or_call_expr_with(&mut self, e0: P<Expr>) -> P<Expr> {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2330,7 +2331,7 @@ impl<'a> Parser<'a> {\n                 }\n                 continue;\n             }\n-            if self.expr_is_complete(e) { break; }\n+            if self.expr_is_complete(&*e) { break; }\n             match self.token {\n               // expr(...)\n               token::LPAREN => {\n@@ -2351,7 +2352,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let ix = self.parse_expr();\n                 hi = self.span.hi;\n-                self.commit_expr_expecting(ix, token::RBRACKET);\n+                self.commit_expr_expecting(&*ix, token::RBRACKET);\n                 let index = self.mk_index(e, ix);\n                 e = self.mk_expr(lo, hi, index)\n               }\n@@ -2556,7 +2557,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a prefix-operator expr\n-    pub fn parse_prefix_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_prefix_expr(&mut self) -> P<Expr> {\n         let lo = self.span.lo;\n         let hi;\n \n@@ -2638,28 +2639,23 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression of binops\n-    pub fn parse_binops(&mut self) -> Gc<Expr> {\n+    pub fn parse_binops(&mut self) -> P<Expr> {\n         let prefix_expr = self.parse_prefix_expr();\n         self.parse_more_binops(prefix_expr, 0)\n     }\n \n     /// Parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&mut self, lhs: Gc<Expr>,\n-                             min_prec: uint) -> Gc<Expr> {\n-        if self.expr_is_complete(lhs) { return lhs; }\n+    pub fn parse_more_binops(&mut self, lhs: P<Expr>, min_prec: uint) -> P<Expr> {\n+        if self.expr_is_complete(&*lhs) { return lhs; }\n \n         // Prevent dynamic borrow errors later on by limiting the\n         // scope of the borrows.\n-        {\n-            let token: &token::Token = &self.token;\n-            let restriction: &restriction = &self.restriction;\n-            match (token, restriction) {\n-                (&token::BINOP(token::OR), &RESTRICT_NO_BAR_OP) => return lhs,\n-                (&token::BINOP(token::OR),\n-                 &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n-                (&token::OROR, &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n-                _ => { }\n-            }\n+        match (&self.token, &self.restriction) {\n+            (&token::BINOP(token::OR), &RESTRICT_NO_BAR_OP) => return lhs,\n+            (&token::BINOP(token::OR),\n+                &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n+            (&token::OROR, &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n+            _ => { }\n         }\n \n         let cur_opt = token_to_binop(&self.token);\n@@ -2670,8 +2666,10 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let expr = self.parse_prefix_expr();\n                     let rhs = self.parse_more_binops(expr, cur_prec);\n+                    let lhs_span = lhs.span;\n+                    let rhs_span = rhs.span;\n                     let binary = self.mk_binary(cur_op, lhs, rhs);\n-                    let bin = self.mk_expr(lhs.span.lo, rhs.span.hi, binary);\n+                    let bin = self.mk_expr(lhs_span.lo, rhs_span.hi, binary);\n                     self.parse_more_binops(bin, min_prec)\n                 } else {\n                     lhs\n@@ -2694,7 +2692,7 @@ impl<'a> Parser<'a> {\n     /// Parse an assignment expression....\n     /// actually, this seems to be the main entry point for\n     /// parsing an arbitrary expression.\n-    pub fn parse_assign_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_assign_expr(&mut self) -> P<Expr> {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match self.token {\n@@ -2718,8 +2716,9 @@ impl<'a> Parser<'a> {\n                   token::SHL =>     BiShl,\n                   token::SHR =>     BiShr\n               };\n+              let rhs_span = rhs.span;\n               let assign_op = self.mk_assign_op(aop, lhs, rhs);\n-              self.mk_expr(lo, rhs.span.hi, assign_op)\n+              self.mk_expr(lo, rhs_span.hi, assign_op)\n           }\n           _ => {\n               lhs\n@@ -2728,54 +2727,54 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_if_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n         let thn = self.parse_block();\n-        let mut els: Option<Gc<Expr>> = None;\n+        let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n         if self.eat_keyword(keywords::Else) {\n             let elexpr = self.parse_else_expr();\n-            els = Some(elexpr);\n             hi = elexpr.span.hi;\n+            els = Some(elexpr);\n         }\n         self.mk_expr(lo, hi, ExprIf(cond, thn, els))\n     }\n \n     // `|args| expr`\n     pub fn parse_lambda_expr(&mut self, capture_clause: CaptureClause)\n-                             -> Gc<Expr> {\n+                             -> P<Expr> {\n         let lo = self.span.lo;\n         let (decl, optional_unboxed_closure_kind) =\n             self.parse_fn_block_decl();\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n+            id: ast::DUMMY_NODE_ID,\n             view_items: Vec::new(),\n             stmts: Vec::new(),\n+            span: body.span,\n             expr: Some(body),\n-            id: ast::DUMMY_NODE_ID,\n             rules: DefaultBlock,\n-            span: body.span,\n         });\n \n         match optional_unboxed_closure_kind {\n             Some(unboxed_closure_kind) => {\n                 self.mk_expr(lo,\n-                             body.span.hi,\n+                             fakeblock.span.hi,\n                              ExprUnboxedFn(capture_clause,\n                                            unboxed_closure_kind,\n                                            decl,\n                                            fakeblock))\n             }\n             None => {\n                 self.mk_expr(lo,\n-                             body.span.hi,\n+                             fakeblock.span.hi,\n                              ExprFnBlock(capture_clause, decl, fakeblock))\n             }\n         }\n     }\n \n-    pub fn parse_else_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_else_expr(&mut self) -> P<Expr> {\n         if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else {\n@@ -2785,7 +2784,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> Gc<Expr> {\n+    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let lo = self.last_span.lo;\n@@ -2798,25 +2797,25 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident))\n     }\n \n-    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> Gc<Expr> {\n+    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident));\n     }\n \n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> Gc<Expr> {\n+    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         self.mk_expr(lo, hi, ExprLoop(body, opt_ident))\n     }\n \n-    fn parse_match_expr(&mut self) -> Gc<Expr> {\n+    fn parse_match_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n-        self.commit_expr_expecting(discriminant, token::LBRACE);\n+        self.commit_expr_expecting(&*discriminant, token::LBRACE);\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n             arms.push(self.parse_arm());\n@@ -2837,11 +2836,11 @@ impl<'a> Parser<'a> {\n         let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n \n         let require_comma =\n-            !classify::expr_is_simple_block(expr)\n+            !classify::expr_is_simple_block(&*expr)\n             && self.token != token::RBRACE;\n \n         if require_comma {\n-            self.commit_expr(expr, &[token::COMMA], &[token::RBRACE]);\n+            self.commit_expr(&*expr, &[token::COMMA], &[token::RBRACE]);\n         } else {\n             self.eat(&token::COMMA);\n         }\n@@ -2855,12 +2854,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression\n-    pub fn parse_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_expr(&mut self) -> P<Expr> {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     /// Parse an expression, subject to the given restriction\n-    pub fn parse_expr_res(&mut self, r: restriction) -> Gc<Expr> {\n+    pub fn parse_expr_res(&mut self, r: restriction) -> P<Expr> {\n         let old = self.restriction;\n         self.restriction = r;\n         let e = self.parse_assign_expr();\n@@ -2869,7 +2868,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n-    fn parse_initializer(&mut self) -> Option<Gc<Expr>> {\n+    fn parse_initializer(&mut self) -> Option<P<Expr>> {\n         if self.token == token::EQ {\n             self.bump();\n             Some(self.parse_expr())\n@@ -2879,7 +2878,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse patterns, separated by '|' s\n-    fn parse_pats(&mut self) -> Vec<Gc<Pat>> {\n+    fn parse_pats(&mut self) -> Vec<P<Pat>> {\n         let mut pats = Vec::new();\n         loop {\n             pats.push(self.parse_pat());\n@@ -2890,7 +2889,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_pat_vec_elements(\n         &mut self,\n-    ) -> (Vec<Gc<Pat>> , Option<Gc<Pat>>, Vec<Gc<Pat>> ) {\n+    ) -> (Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>) {\n         let mut before = Vec::new();\n         let mut slice = None;\n         let mut after = Vec::new();\n@@ -2910,11 +2909,11 @@ impl<'a> Parser<'a> {\n \n                     if self.token == token::COMMA ||\n                             self.token == token::RBRACKET {\n-                        slice = Some(box(GC) ast::Pat {\n+                        slice = Some(P(ast::Pat {\n                             id: ast::DUMMY_NODE_ID,\n                             node: PatWild(PatWildMulti),\n                             span: self.span,\n-                        });\n+                        }));\n                         before_slice = false;\n                     } else {\n                         let _ = self.parse_pat();\n@@ -2989,19 +2988,19 @@ impl<'a> Parser<'a> {\n                 self.parse_pat()\n             } else {\n                 let fieldpath = codemap::Spanned{span:self.last_span, node: fieldname};\n-                box(GC) ast::Pat {\n+                P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatIdent(bind_type, fieldpath, None),\n                     span: self.last_span\n-                }\n+                })\n             };\n             fields.push(ast::FieldPat { ident: fieldname, pat: subpat });\n         }\n         return (fields, etc);\n     }\n \n     /// Parse a pattern.\n-    pub fn parse_pat(&mut self) -> Gc<Pat> {\n+    pub fn parse_pat(&mut self) -> P<Pat> {\n         maybe_whole!(self, NtPat);\n \n         let lo = self.span.lo;\n@@ -3013,11 +3012,11 @@ impl<'a> Parser<'a> {\n             self.bump();\n             pat = PatWild(PatWildSingle);\n             hi = self.last_span.hi;\n-            return box(GC) ast::Pat {\n+            return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n-            }\n+            })\n           }\n           token::TILDE => {\n             // parse ~pat\n@@ -3027,11 +3026,11 @@ impl<'a> Parser<'a> {\n             let last_span = self.last_span;\n             hi = last_span.hi;\n             self.obsolete(last_span, ObsoleteOwnedPattern);\n-            return box(GC) ast::Pat {\n+            return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n-            }\n+            })\n           }\n           token::BINOP(token::AND) | token::ANDAND => {\n             // parse &pat\n@@ -3040,21 +3039,21 @@ impl<'a> Parser<'a> {\n             let sub = self.parse_pat();\n             pat = PatRegion(sub);\n             hi = self.last_span.hi;\n-            return box(GC) ast::Pat {\n+            return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n-            }\n+            })\n           }\n           token::LPAREN => {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = box(GC) codemap::Spanned {\n+                let lit = P(codemap::Spanned {\n                     node: LitNil,\n-                    span: mk_sp(lo, hi)};\n+                    span: mk_sp(lo, hi)});\n                 let expr = self.mk_expr(lo, hi, ExprLit(lit));\n                 pat = PatLit(expr);\n             } else {\n@@ -3071,11 +3070,11 @@ impl<'a> Parser<'a> {\n                 pat = PatTup(fields);\n             }\n             hi = self.last_span.hi;\n-            return box(GC) ast::Pat {\n+            return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n-            }\n+            })\n           }\n           token::LBRACKET => {\n             // parse [pat,pat,...] as vector pattern\n@@ -3086,11 +3085,11 @@ impl<'a> Parser<'a> {\n             self.expect(&token::RBRACKET);\n             pat = ast::PatVec(before, slice, after);\n             hi = self.last_span.hi;\n-            return box(GC) ast::Pat {\n+            return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n-            }\n+            })\n           }\n           _ => {}\n         }\n@@ -3135,11 +3134,11 @@ impl<'a> Parser<'a> {\n             let sub = self.parse_pat();\n             pat = PatBox(sub);\n             hi = self.last_span.hi;\n-            return box(GC) ast::Pat {\n+            return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n-            }\n+            })\n         } else {\n             let can_be_enum_or_struct = self.look_ahead(1, |t| {\n                 match *t {\n@@ -3196,7 +3195,7 @@ impl<'a> Parser<'a> {\n                         pat = PatStruct(enum_path, fields, etc);\n                     }\n                     _ => {\n-                        let mut args: Vec<Gc<Pat>> = Vec::new();\n+                        let mut args: Vec<P<Pat>> = Vec::new();\n                         match self.token {\n                           token::LPAREN => {\n                             let is_dotdot = self.look_ahead(1, |t| {\n@@ -3251,11 +3250,11 @@ impl<'a> Parser<'a> {\n             }\n         }\n         hi = self.last_span.hi;\n-        box(GC) ast::Pat {\n+        P(ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: pat,\n             span: mk_sp(lo, hi),\n-        }\n+        })\n     }\n \n     /// Parse ident or ident @ pat\n@@ -3295,7 +3294,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a local variable declaration\n-    fn parse_local(&mut self) -> Gc<Local> {\n+    fn parse_local(&mut self) -> P<Local> {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n \n@@ -3308,21 +3307,21 @@ impl<'a> Parser<'a> {\n             ty = self.parse_ty(true);\n         }\n         let init = self.parse_initializer();\n-        box(GC) ast::Local {\n+        P(ast::Local {\n             ty: ty,\n             pat: pat,\n             init: init,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, self.last_span.hi),\n             source: LocalLet,\n-        }\n+        })\n     }\n \n     /// Parse a \"let\" stmt\n-    fn parse_let(&mut self) -> Gc<Decl> {\n+    fn parse_let(&mut self) -> P<Decl> {\n         let lo = self.span.lo;\n         let local = self.parse_local();\n-        box(GC) spanned(lo, self.last_span.hi, DeclLocal(local))\n+        P(spanned(lo, self.last_span.hi, DeclLocal(local)))\n     }\n \n     /// Parse a structure field\n@@ -3345,7 +3344,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a statement. may include decl.\n     /// Precondition: any attributes are parsed already\n-    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute>) -> Gc<Stmt> {\n+    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute>) -> P<Stmt> {\n         maybe_whole!(self, NtStmt);\n \n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n@@ -3361,7 +3360,7 @@ impl<'a> Parser<'a> {\n             check_expected_item(self, !item_attrs.is_empty());\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n-            return box(GC) spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n+            P(spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n         } else if is_ident(&self.token)\n             && !token::is_any_keyword(&self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n@@ -3409,26 +3408,26 @@ impl<'a> Parser<'a> {\n             let hi = self.span.hi;\n \n             if id.name == token::special_idents::invalid.name {\n-                return box(GC) spanned(lo, hi, StmtMac(\n-                    spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false));\n+                P(spanned(lo, hi, StmtMac(\n+                    spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false)))\n             } else {\n                 // if it has a special ident, it's definitely an item\n-                return box(GC) spanned(lo, hi, StmtDecl(\n-                    box(GC) spanned(lo, hi, DeclItem(\n+                P(spanned(lo, hi, StmtDecl(\n+                    P(spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n-                            Inherited, Vec::new(/*no attrs*/)))),\n-                    ast::DUMMY_NODE_ID));\n+                            Inherited, Vec::new(/*no attrs*/))))),\n+                    ast::DUMMY_NODE_ID)))\n             }\n \n         } else {\n             let found_attrs = !item_attrs.is_empty();\n             match self.parse_item_or_view_item(item_attrs, false) {\n                 IoviItem(i) => {\n                     let hi = i.span.hi;\n-                    let decl = box(GC) spanned(lo, hi, DeclItem(i));\n-                    return box(GC) spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n+                    let decl = P(spanned(lo, hi, DeclItem(i)));\n+                    P(spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n                 }\n                 IoviViewItem(vi) => {\n                     self.span_fatal(vi.span,\n@@ -3437,21 +3436,21 @@ impl<'a> Parser<'a> {\n                 IoviForeignItem(_) => {\n                     self.fatal(\"foreign items are not allowed here\");\n                 }\n-                IoviNone(_) => { /* fallthrough */ }\n-            }\n+                IoviNone(_) => {\n+                    check_expected_item(self, found_attrs);\n \n-            check_expected_item(self, found_attrs);\n-\n-            // Remainder are line-expr stmts.\n-            let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-            return box(GC) spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID));\n+                    // Remainder are line-expr stmts.\n+                    let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n+                    P(spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID)))\n+                }\n+            }\n         }\n     }\n \n     /// Is this expression a successfully-parsed statement?\n-    fn expr_is_complete(&mut self, e: Gc<Expr>) -> bool {\n-        return self.restriction == RESTRICT_STMT_EXPR &&\n-            !classify::expr_requires_semi_to_be_stmt(e);\n+    fn expr_is_complete(&mut self, e: &Expr) -> bool {\n+        self.restriction == RESTRICT_STMT_EXPR &&\n+            !classify::expr_requires_semi_to_be_stmt(e)\n     }\n \n     /// Parse a block. No inner attrs are allowed.\n@@ -3500,10 +3499,10 @@ impl<'a> Parser<'a> {\n         } = self.parse_items_and_view_items(first_item_attrs,\n                                             false, false);\n \n-        for item in items.iter() {\n-            let decl = box(GC) spanned(item.span.lo, item.span.hi, DeclItem(*item));\n-            stmts.push(box(GC) spanned(item.span.lo, item.span.hi,\n-                                StmtDecl(decl, ast::DUMMY_NODE_ID)));\n+        for item in items.move_iter() {\n+            let span = item.span;\n+            let decl = P(spanned(span.lo, span.hi, DeclItem(item)));\n+            stmts.push(P(spanned(span.lo, span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID))));\n         }\n \n         let mut attributes_box = attrs_remaining;\n@@ -3527,66 +3526,75 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     let stmt = self.parse_stmt(attributes_box);\n                     attributes_box = Vec::new();\n-                    match stmt.node {\n+                    stmt.and_then(|Spanned {node, span}| match node {\n                         StmtExpr(e, stmt_id) => {\n                             // expression without semicolon\n-                            if classify::stmt_ends_with_semi(&*stmt) {\n+                            if classify::expr_requires_semi_to_be_stmt(&*e) {\n                                 // Just check for errors and recover; do not eat semicolon yet.\n-                                self.commit_stmt(stmt, &[], &[token::SEMI, token::RBRACE]);\n+                                self.commit_stmt(&[], &[token::SEMI, token::RBRACE]);\n                             }\n \n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n                                     let span_with_semi = Span {\n-                                        lo: stmt.span.lo,\n+                                        lo: span.lo,\n                                         hi: self.last_span.hi,\n-                                        expn_info: stmt.span.expn_info,\n+                                        expn_info: span.expn_info,\n                                     };\n-                                    stmts.push(box(GC) codemap::Spanned {\n+                                    stmts.push(P(Spanned {\n                                         node: StmtSemi(e, stmt_id),\n                                         span: span_with_semi,\n-                                    });\n+                                    }));\n                                 }\n                                 token::RBRACE => {\n                                     expr = Some(e);\n                                 }\n                                 _ => {\n-                                    stmts.push(stmt);\n+                                    stmts.push(P(Spanned {\n+                                        node: StmtExpr(e, stmt_id),\n+                                        span: span\n+                                    }));\n                                 }\n                             }\n                         }\n-                        StmtMac(ref m, _) => {\n+                        StmtMac(m, semi) => {\n                             // statement macro; might be an expr\n                             match self.token {\n                                 token::SEMI => {\n+                                    stmts.push(P(Spanned {\n+                                        node: StmtMac(m, true),\n+                                        span: span,\n+                                    }));\n                                     self.bump();\n-                                    stmts.push(box(GC) codemap::Spanned {\n-                                        node: StmtMac((*m).clone(), true),\n-                                        span: stmt.span,\n-                                    });\n                                 }\n                                 token::RBRACE => {\n                                     // if a block ends in `m!(arg)` without\n                                     // a `;`, it must be an expr\n                                     expr = Some(\n-                                        self.mk_mac_expr(stmt.span.lo,\n-                                                         stmt.span.hi,\n-                                                         m.node.clone()));\n+                                        self.mk_mac_expr(span.lo,\n+                                                         span.hi,\n+                                                         m.node));\n                                 }\n                                 _ => {\n-                                    stmts.push(stmt);\n+                                    stmts.push(P(Spanned {\n+                                        node: StmtMac(m, semi),\n+                                        span: span\n+                                    }));\n                                 }\n                             }\n                         }\n                         _ => { // all other kinds of statements:\n-                            stmts.push(stmt.clone());\n-\n-                            if classify::stmt_ends_with_semi(&*stmt) {\n-                                self.commit_stmt_expecting(stmt, token::SEMI);\n+                            if classify::stmt_ends_with_semi(&node) {\n+                                self.commit_stmt_expecting(token::SEMI);\n                             }\n+\n+                            stmts.push(P(Spanned {\n+                                node: node,\n+                                span: span\n+                            }));\n                         }\n-                    }\n+                    })\n                 }\n             }\n         }\n@@ -4187,15 +4195,15 @@ impl<'a> Parser<'a> {\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n                node: Item_, vis: Visibility,\n-               attrs: Vec<Attribute>) -> Gc<Item> {\n-        box(GC) Item {\n+               attrs: Vec<Attribute>) -> P<Item> {\n+        P(Item {\n             ident: ident,\n             attrs: attrs,\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             vis: vis,\n             span: mk_sp(lo, hi)\n-        }\n+        })\n     }\n \n     /// Parse an item-position function declaration.\n@@ -4210,7 +4218,7 @@ impl<'a> Parser<'a> {\n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n     pub fn parse_method(&mut self,\n                         already_parsed_attrs: Option<Vec<Attribute>>)\n-                        -> Gc<Method> {\n+                        -> P<Method> {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -4264,6 +4272,7 @@ impl<'a> Parser<'a> {\n                     });\n                 self.parse_where_clause(&mut generics);\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n+                let body_span = body.span;\n                 let new_attrs = attrs.append(inner_attrs.as_slice());\n                 (ast::MethDecl(ident,\n                                generics,\n@@ -4273,15 +4282,15 @@ impl<'a> Parser<'a> {\n                                decl,\n                                body,\n                                visa),\n-                 body.span.hi, new_attrs)\n+                 body_span.hi, new_attrs)\n             }\n         };\n-        box(GC) ast::Method {\n+        P(ast::Method {\n             attrs: new_attrs,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             node: method_,\n-        }\n+        })\n     }\n \n     /// Parse trait Foo { ... }\n@@ -4444,12 +4453,12 @@ impl<'a> Parser<'a> {\n         let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n         let new_id = ast::DUMMY_NODE_ID;\n         (class_name,\n-         ItemStruct(box(GC) ast::StructDef {\n+         ItemStruct(P(ast::StructDef {\n              fields: fields,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None },\n              super_struct: super_struct,\n              is_virtual: is_virtual,\n-         }, generics),\n+         }), generics),\n          None)\n     }\n \n@@ -4524,7 +4533,7 @@ impl<'a> Parser<'a> {\n             items: starting_items,\n             ..\n         } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: Vec<Gc<Item>> = starting_items;\n+        let mut items: Vec<P<Item>> = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n         // don't think this other loop is even necessary....\n@@ -4574,7 +4583,7 @@ impl<'a> Parser<'a> {\n         let ty = self.parse_ty(true);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n-        self.commit_expr_expecting(e, token::SEMI);\n+        self.commit_expr_expecting(&*e, token::SEMI);\n         (id, ItemStatic(ty, m, e), None)\n     }\n \n@@ -4726,7 +4735,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility,\n-                             attrs: Vec<Attribute>) -> Gc<ForeignItem> {\n+                             attrs: Vec<Attribute>) -> P<ForeignItem> {\n         let lo = self.span.lo;\n         self.expect_keyword(keywords::Fn);\n \n@@ -4735,17 +4744,19 @@ impl<'a> Parser<'a> {\n         self.parse_where_clause(&mut generics);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        box(GC) ast::ForeignItem { ident: ident,\n-                                   attrs: attrs,\n-                                   node: ForeignItemFn(decl, generics),\n-                                   id: ast::DUMMY_NODE_ID,\n-                                   span: mk_sp(lo, hi),\n-                                   vis: vis }\n+        P(ast::ForeignItem {\n+            ident: ident,\n+            attrs: attrs,\n+            node: ForeignItemFn(decl, generics),\n+            id: ast::DUMMY_NODE_ID,\n+            span: mk_sp(lo, hi),\n+            vis: vis\n+        })\n     }\n \n     /// Parse a static item from a foreign module\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility,\n-                                 attrs: Vec<Attribute> ) -> Gc<ForeignItem> {\n+                                 attrs: Vec<Attribute>) -> P<ForeignItem> {\n         let lo = self.span.lo;\n \n         self.expect_keyword(keywords::Static);\n@@ -4756,14 +4767,14 @@ impl<'a> Parser<'a> {\n         let ty = self.parse_ty(true);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        box(GC) ast::ForeignItem {\n+        P(ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemStatic(ty, mutbl),\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n-            vis: vis,\n-        }\n+            vis: vis\n+        })\n     }\n \n     /// Parse safe/unsafe and fn\n@@ -4903,19 +4914,19 @@ impl<'a> Parser<'a> {\n \n     /// Parse a structure-like enum variant definition\n     /// this should probably be renamed or refactored...\n-    fn parse_struct_def(&mut self) -> Gc<StructDef> {\n+    fn parse_struct_def(&mut self) -> P<StructDef> {\n         let mut fields: Vec<StructField> = Vec::new();\n         while self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n         }\n         self.bump();\n \n-        return box(GC) ast::StructDef {\n+        P(StructDef {\n             fields: fields,\n             ctor_id: None,\n             super_struct: None,\n             is_virtual: false,\n-        };\n+        })\n     }\n \n     /// Parse the part of an \"enum\" decl following the '{'\n@@ -5034,16 +5045,21 @@ impl<'a> Parser<'a> {\n                                attrs: Vec<Attribute> ,\n                                macros_allowed: bool)\n                                -> ItemOrViewItem {\n-        match self.token {\n-            INTERPOLATED(token::NtItem(item)) => {\n+        let nt_item = match self.token {\n+            INTERPOLATED(token::NtItem(ref item)) => {\n+                Some((**item).clone())\n+            }\n+            _ => None\n+        };\n+        match nt_item {\n+            Some(mut item) => {\n                 self.bump();\n-                let new_attrs = attrs.append(item.attrs.as_slice());\n-                return IoviItem(box(GC) Item {\n-                    attrs: new_attrs,\n-                    ..(*item).clone()\n-                });\n+                let mut attrs = attrs;\n+                mem::swap(&mut item.attrs, &mut attrs);\n+                item.attrs.extend(attrs.move_iter());\n+                return IoviItem(P(item));\n             }\n-            _ => {}\n+            None => {}\n         }\n \n         let lo = self.span.lo;\n@@ -5328,12 +5344,12 @@ impl<'a> Parser<'a> {\n         return IoviNone(attrs);\n     }\n \n-    pub fn parse_item_with_outer_attributes(&mut self) -> Option<Gc<Item>> {\n+    pub fn parse_item_with_outer_attributes(&mut self) -> Option<P<Item>> {\n         let attrs = self.parse_outer_attributes();\n         self.parse_item(attrs)\n     }\n \n-    pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<Gc<Item>> {\n+    pub fn parse_item(&mut self, attrs: Vec<Attribute>) -> Option<P<Item>> {\n         match self.parse_item_or_view_item(attrs, true) {\n             IoviNone(_) => None,\n             IoviViewItem(_) =>\n@@ -5355,7 +5371,7 @@ impl<'a> Parser<'a> {\n     /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     /// | MOD? non_global_path MOD_SEP STAR\n     /// | MOD? non_global_path\n-    fn parse_view_path(&mut self) -> Gc<ViewPath> {\n+    fn parse_view_path(&mut self) -> P<ViewPath> {\n         let lo = self.span.lo;\n \n         if self.token == token::LBRACE {\n@@ -5369,8 +5385,8 @@ impl<'a> Parser<'a> {\n                 global: false,\n                 segments: Vec::new()\n             };\n-            return box(GC) spanned(lo, self.span.hi,\n-                            ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n+            return P(spanned(lo, self.span.hi,\n+                             ViewPathList(path, idents, ast::DUMMY_NODE_ID)));\n         }\n \n         let first_ident = self.parse_ident();\n@@ -5399,9 +5415,9 @@ impl<'a> Parser<'a> {\n                     }\n                 }).collect()\n             };\n-            return box(GC) spanned(lo, self.span.hi,\n-                            ViewPathSimple(first_ident, path,\n-                                           ast::DUMMY_NODE_ID));\n+            return P(spanned(lo, self.span.hi,\n+                             ViewPathSimple(first_ident, path,\n+                                           ast::DUMMY_NODE_ID)));\n           }\n \n           token::MOD_SEP => {\n@@ -5434,8 +5450,8 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return box(GC) spanned(lo, self.span.hi,\n-                                    ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n+                    return P(spanned(lo, self.span.hi,\n+                                     ViewPathList(path, idents, ast::DUMMY_NODE_ID)));\n                   }\n \n                   // foo::bar::*\n@@ -5452,8 +5468,8 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return box(GC) spanned(lo, self.span.hi,\n-                                    ViewPathGlob(path, ast::DUMMY_NODE_ID));\n+                    return P(spanned(lo, self.span.hi,\n+                                     ViewPathGlob(path, ast::DUMMY_NODE_ID)));\n                   }\n \n                   _ => break\n@@ -5477,9 +5493,8 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::As) {\n             rename_to = self.parse_ident()\n         }\n-        return box(GC) spanned(lo,\n-                        self.last_span.hi,\n-                        ViewPathSimple(rename_to, path, ast::DUMMY_NODE_ID));\n+        P(spanned(lo, self.last_span.hi,\n+                  ViewPathSimple(rename_to, path, ast::DUMMY_NODE_ID)))\n     }\n \n     /// Parses a sequence of items. Stops when it finds program"}, {"sha": "f113e0e6cff75714709fd0a05fdd38df77d49fae", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use ast;\n-use ast::{P, Ident, Name, Mrk};\n+use ast::{Ident, Name, Mrk};\n use ext::mtwt;\n use parse::token;\n+use ptr::P;\n use util::interner::{RcStr, StrInterner};\n use util::interner;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n-use std::gc::Gc;\n use std::mem;\n use std::path::BytesContainer;\n use std::rc::Rc;\n@@ -115,19 +115,19 @@ pub enum Token {\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n-    NtItem(Gc<ast::Item>),\n+    NtItem( P<ast::Item>),\n     NtBlock(P<ast::Block>),\n-    NtStmt(Gc<ast::Stmt>),\n-    NtPat( Gc<ast::Pat>),\n-    NtExpr(Gc<ast::Expr>),\n-    NtTy(  P<ast::Ty>),\n+    NtStmt( P<ast::Stmt>),\n+    NtPat(  P<ast::Pat>),\n+    NtExpr( P<ast::Expr>),\n+    NtTy(   P<ast::Ty>),\n     /// See IDENT, above, for meaning of bool in NtIdent:\n     NtIdent(Box<Ident>, bool),\n     /// Stuff inside brackets for attributes\n-    NtMeta(Gc<ast::MetaItem>),\n+    NtMeta( P<ast::MetaItem>),\n     NtPath(Box<ast::Path>),\n-    NtTT(  Gc<ast::TokenTree>), // needs Gc'd to break a circularity\n-    NtMatchers(Vec<ast::Matcher> )\n+    NtTT(   P<ast::TokenTree>), // needs P'ed to break a circularity\n+    NtMatchers(Vec<ast::Matcher>)\n }\n \n impl fmt::Show for Nonterminal {"}, {"sha": "4d46da8d83586e7e9053bb910197867307a00baf", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 53, "deletions": 59, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -10,7 +10,7 @@\n \n use abi;\n use ast::{FnMutUnboxedClosureKind, FnOnceUnboxedClosureKind};\n-use ast::{FnUnboxedClosureKind, MethodImplItem, P};\n+use ast::{FnUnboxedClosureKind, MethodImplItem};\n use ast::{RegionTyParamBound, TraitTyParamBound, UnboxedClosureKind};\n use ast::{UnboxedFnTyParamBound, RequiredMethod, ProvidedMethod};\n use ast;\n@@ -26,8 +26,8 @@ use parse;\n use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, Consistent, Inconsistent, eof};\n use print::pp;\n+use ptr::P;\n \n-use std::gc::Gc;\n use std::io::{IoResult, MemWriter};\n use std::io;\n use std::mem;\n@@ -246,7 +246,7 @@ pub fn ident_to_string(id: &ast::Ident) -> String {\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n-                  opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                  opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> String {\n     $to_string(|s| {\n         try!(s.print_fn(decl, Some(fn_style), abi::Rust,\n@@ -278,7 +278,7 @@ pub fn lit_to_string(l: &ast::Lit) -> String {\n     $to_string(|s| s.print_literal(l))\n }\n \n-pub fn explicit_self_to_string(explicit_self: ast::ExplicitSelf_) -> String {\n+pub fn explicit_self_to_string(explicit_self: &ast::ExplicitSelf_) -> String {\n     $to_string(|s| s.print_explicit_self(explicit_self, ast::MutImmutable).map(|_| {}))\n }\n \n@@ -502,7 +502,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks,\n-                          exprs: &[Gc<ast::Expr>]) -> IoResult<()> {\n+                          exprs: &[P<ast::Expr>]) -> IoResult<()> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n     }\n \n@@ -574,7 +574,7 @@ impl<'a> State<'a> {\n             ast::TyTup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent, elts.as_slice(),\n-                                   |s, ty| s.print_type_ref(ty)));\n+                                   |s, ty| s.print_type(&**ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n@@ -585,7 +585,7 @@ impl<'a> State<'a> {\n                 try!(self.print_type(&**typ));\n                 try!(self.pclose());\n             }\n-            ast::TyBareFn(f) => {\n+            ast::TyBareFn(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty(),\n@@ -605,7 +605,7 @@ impl<'a> State<'a> {\n                                       None,\n                                       None));\n             }\n-            ast::TyClosure(f) => {\n+            ast::TyClosure(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty(),\n@@ -645,7 +645,7 @@ impl<'a> State<'a> {\n                                       None,\n                                       None));\n             }\n-            ast::TyUnboxedFn(f) => {\n+            ast::TyUnboxedFn(ref f) => {\n                 try!(self.print_ty_fn(None,\n                                       None,\n                                       ast::NormalFn,\n@@ -679,10 +679,6 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_type_ref(&mut self, ty: &P<ast::Ty>) -> IoResult<()> {\n-        self.print_type(&**ty)\n-    }\n-\n     pub fn print_foreign_item(&mut self,\n                               item: &ast::ForeignItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n@@ -794,10 +790,8 @@ impl<'a> State<'a> {\n                 if struct_def.is_virtual {\n                     try!(self.word_space(\"virtual\"));\n                 }\n-                try!(self.head(visibility_qualified(item.vis,\n-                                                    \"struct\").as_slice()));\n-                try!(self.print_struct(&**struct_def, generics, item.ident,\n-                                       item.span));\n+                try!(self.head(visibility_qualified(item.vis,\"struct\").as_slice()));\n+                try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n             }\n \n             ast::ItemImpl(ref generics,\n@@ -828,8 +822,8 @@ impl<'a> State<'a> {\n                 try!(self.print_inner_attributes(item.attrs.as_slice()));\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n-                        ast::MethodImplItem(meth) => {\n-                            try!(self.print_method(&*meth));\n+                        ast::MethodImplItem(ref meth) => {\n+                            try!(self.print_method(&**meth));\n                         }\n                     }\n                 }\n@@ -1068,7 +1062,7 @@ impl<'a> State<'a> {\n                               Some(m.ident),\n                               &OwnedSlice::empty(),\n                               Some(&m.generics),\n-                              Some(m.explicit_self.node),\n+                              Some(&m.explicit_self.node),\n                               None));\n         word(&mut self.s, \";\")\n     }\n@@ -1097,18 +1091,18 @@ impl<'a> State<'a> {\n                           abi,\n                           ref explicit_self,\n                           fn_style,\n-                          decl,\n-                          body,\n+                          ref decl,\n+                          ref body,\n                           vis) => {\n-                try!(self.print_fn(&*decl,\n+                try!(self.print_fn(&**decl,\n                                    Some(fn_style),\n                                    abi,\n                                    ident,\n                                    generics,\n-                                   Some(explicit_self.node),\n+                                   Some(&explicit_self.node),\n                                    vis));\n                 try!(word(&mut self.s, \" \"));\n-                self.print_block_with_attrs(&*body, meth.attrs.as_slice())\n+                self.print_block_with_attrs(&**body, meth.attrs.as_slice())\n             },\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n@@ -1199,7 +1193,7 @@ impl<'a> State<'a> {\n                 }\n             }\n         }\n-        if parse::classify::stmt_ends_with_semi(st) {\n+        if parse::classify::stmt_ends_with_semi(&st.node) {\n             try!(word(&mut self.s, \";\"));\n         }\n         self.maybe_print_trailing_comment(st.span, None)\n@@ -1257,19 +1251,19 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeBlock(blk))\n     }\n \n-    fn print_else(&mut self, els: Option<Gc<ast::Expr>>) -> IoResult<()> {\n+    fn print_else(&mut self, els: Option<&ast::Expr>) -> IoResult<()> {\n         match els {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n-                    ast::ExprIf(ref i, ref t, e) => {\n+                    ast::ExprIf(ref i, ref then, ref e) => {\n                         try!(self.cbox(indent_unit - 1u));\n                         try!(self.ibox(0u));\n                         try!(word(&mut self.s, \" else if \"));\n                         try!(self.print_expr(&**i));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(&**t));\n-                        self.print_else(e)\n+                        try!(self.print_block(&**then));\n+                        self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     ast::ExprBlock(ref b) => {\n@@ -1289,7 +1283,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n-                    elseopt: Option<Gc<ast::Expr>>, chk: bool) -> IoResult<()> {\n+                    elseopt: Option<&ast::Expr>, chk: bool) -> IoResult<()> {\n         try!(self.head(\"if\"));\n         if chk { try!(self.word_nbsp(\"check\")); }\n         try!(self.print_expr(test));\n@@ -1312,7 +1306,7 @@ impl<'a> State<'a> {\n     }\n \n \n-    fn print_call_post(&mut self, args: &[Gc<ast::Expr>]) -> IoResult<()> {\n+    fn print_call_post(&mut self, args: &[P<ast::Expr>]) -> IoResult<()> {\n         try!(self.popen());\n         try!(self.commasep_exprs(Inconsistent, args));\n         self.pclose()\n@@ -1361,7 +1355,7 @@ impl<'a> State<'a> {\n                 try!(self.end());\n             }\n \n-            ast::ExprStruct(ref path, ref fields, wth) => {\n+            ast::ExprStruct(ref path, ref fields, ref wth) => {\n                 try!(self.print_path(path, true));\n                 try!(word(&mut self.s, \"{\"));\n                 try!(self.commasep_cmnt(\n@@ -1375,7 +1369,7 @@ impl<'a> State<'a> {\n                         s.end()\n                     },\n                     |f| f.span));\n-                match wth {\n+                match *wth {\n                     Some(ref expr) => {\n                         try!(self.ibox(indent_unit));\n                         if !fields.is_empty() {\n@@ -1410,7 +1404,7 @@ impl<'a> State<'a> {\n                 if tys.len() > 0u {\n                     try!(word(&mut self.s, \"::<\"));\n                     try!(self.commasep(Inconsistent, tys.as_slice(),\n-                                       |s, ty| s.print_type_ref(ty)));\n+                                       |s, ty| s.print_type(&**ty)));\n                     try!(word(&mut self.s, \">\"));\n                 }\n                 try!(self.print_call_post(base_args));\n@@ -1437,8 +1431,8 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"as\"));\n                 try!(self.print_type(&**ty));\n             }\n-            ast::ExprIf(ref test, ref blk, elseopt) => {\n-                try!(self.print_if(&**test, &**blk, elseopt, false));\n+            ast::ExprIf(ref test, ref blk, ref elseopt) => {\n+                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e), false));\n             }\n             ast::ExprWhile(ref test, ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n@@ -1500,13 +1494,13 @@ impl<'a> State<'a> {\n                     try!(self.print_block_unclosed(&**body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n-                    match body.expr.unwrap().node {\n-                        ast::ExprBlock(blk) => {\n-                            try!(self.print_block_unclosed(&*blk));\n+                    match body.expr.as_ref().unwrap().node {\n+                        ast::ExprBlock(ref blk) => {\n+                            try!(self.print_block_unclosed(&**blk));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(&*body.expr.unwrap()));\n+                            try!(self.print_expr(&**body.expr.as_ref().unwrap()));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -1532,13 +1526,13 @@ impl<'a> State<'a> {\n                     try!(self.print_block_unclosed(&**body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n-                    match body.expr.unwrap().node {\n+                    match body.expr.as_ref().unwrap().node {\n                         ast::ExprBlock(ref blk) => {\n                             try!(self.print_block_unclosed(&**blk));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(&*body.expr.unwrap()));\n+                            try!(self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap()));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -1560,13 +1554,13 @@ impl<'a> State<'a> {\n                 assert!(body.stmts.is_empty());\n                 assert!(body.expr.is_some());\n                 // we extract the block, so as not to create another set of boxes\n-                match body.expr.unwrap().node {\n+                match body.expr.as_ref().unwrap().node {\n                     ast::ExprBlock(ref blk) => {\n                         try!(self.print_block_unclosed(&**blk));\n                     }\n                     _ => {\n                         // this is a bare expression\n-                        try!(self.print_expr(&*body.expr.unwrap()));\n+                        try!(self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap()));\n                         try!(self.end()); // need to close a box\n                     }\n                 }\n@@ -1603,7 +1597,7 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \"::<\"));\n                     try!(self.commasep(\n                         Inconsistent, tys.as_slice(),\n-                        |s, ty| s.print_type_ref(ty)));\n+                        |s, ty| s.print_type(&**ty)));\n                     try!(word(&mut self.s, \">\"));\n                 }\n             }\n@@ -1615,7 +1609,7 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \"::<\"));\n                     try!(self.commasep(\n                         Inconsistent, tys.as_slice(),\n-                        |s, ty| s.print_type_ref(ty)));\n+                        |s, ty| s.print_type(&**ty)));\n                     try!(word(&mut self.s, \">\"));\n                 }\n             }\n@@ -1809,7 +1803,7 @@ impl<'a> State<'a> {\n                     try!(self.commasep(\n                         Inconsistent,\n                         segment.types.as_slice(),\n-                        |s, ty| s.print_type_ref(ty)));\n+                        |s, ty| s.print_type(&**ty)));\n                 }\n \n                 try!(word(&mut self.s, \">\"))\n@@ -1841,7 +1835,7 @@ impl<'a> State<'a> {\n         match pat.node {\n             ast::PatWild(ast::PatWildSingle) => try!(word(&mut self.s, \"_\")),\n             ast::PatWild(ast::PatWildMulti) => try!(word(&mut self.s, \"..\")),\n-            ast::PatIdent(binding_mode, ref path1, sub) => {\n+            ast::PatIdent(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     ast::BindByRef(mutbl) => {\n                         try!(self.word_nbsp(\"ref\"));\n@@ -1853,7 +1847,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 try!(self.print_ident(path1.node));\n-                match sub {\n+                match *sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n                         try!(self.print_pat(&**p));\n@@ -1921,7 +1915,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"..\"));\n                 try!(self.print_expr(&**end));\n             }\n-            ast::PatVec(ref before, slice, ref after) => {\n+            ast::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n                                    before.as_slice(),\n@@ -1994,10 +1988,10 @@ impl<'a> State<'a> {\n \n     // Returns whether it printed anything\n     fn print_explicit_self(&mut self,\n-                           explicit_self: ast::ExplicitSelf_,\n+                           explicit_self: &ast::ExplicitSelf_,\n                            mutbl: ast::Mutability) -> IoResult<bool> {\n         try!(self.print_mutability(mutbl));\n-        match explicit_self {\n+        match *explicit_self {\n             ast::SelfStatic => { return Ok(false); }\n             ast::SelfValue(_) => {\n                 try!(word(&mut self.s, \"self\"));\n@@ -2023,7 +2017,7 @@ impl<'a> State<'a> {\n                     abi: abi::Abi,\n                     name: ast::Ident,\n                     generics: &ast::Generics,\n-                    opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                    opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> IoResult<()> {\n         try!(self.head(\"\"));\n         try!(self.print_fn_header_info(opt_explicit_self, fn_style, abi, vis));\n@@ -2035,15 +2029,15 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n-                         opt_explicit_self: Option<ast::ExplicitSelf_>)\n+                         opt_explicit_self: Option<&ast::ExplicitSelf_>)\n         -> IoResult<()> {\n         // It is unfortunate to duplicate the commasep logic, but we want the\n         // self type and the args all in the same box.\n         try!(self.rbox(0u, Inconsistent));\n         let mut first = true;\n         for &explicit_self in opt_explicit_self.iter() {\n             let m = match explicit_self {\n-                ast::SelfStatic => ast::MutImmutable,\n+                &ast::SelfStatic => ast::MutImmutable,\n                 _ => match decl.inputs.get(0).pat.node {\n                     ast::PatIdent(ast::BindByValue(m), _, _) => m,\n                     _ => ast::MutImmutable\n@@ -2068,7 +2062,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl,\n-                                 opt_explicit_self: Option<ast::ExplicitSelf_>)\n+                                 opt_explicit_self: Option<&ast::ExplicitSelf_>)\n         -> IoResult<()> {\n         try!(self.popen());\n         try!(self.print_fn_args(decl, opt_explicit_self));\n@@ -2413,7 +2407,7 @@ impl<'a> State<'a> {\n                        id: Option<ast::Ident>,\n                        bounds: &OwnedSlice<ast::TyParamBound>,\n                        generics: Option<&ast::Generics>,\n-                       opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                       opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                        opt_unboxed_closure_kind:\n                         Option<ast::UnboxedClosureKind>)\n                        -> IoResult<()> {\n@@ -2754,7 +2748,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                _opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                                _opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 opt_fn_style: Option<ast::FnStyle>,\n                                 abi: abi::Abi,\n                                 vis: ast::Visibility) -> IoResult<()> {"}, {"sha": "bc5b9bc6c189055846a2386aa68624734dcbd43d", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use ast;\n+use ast::P;\n use parse::{new_parse_sess};\n use parse::{ParseSess,string_to_filemap,filemap_to_tts};\n use parse::{new_parser_from_source_str};\n@@ -48,29 +49,29 @@ pub fn string_to_crate (source_str : String) -> ast::Crate {\n }\n \n /// Parse a string, return an expr\n-pub fn string_to_expr (source_str : String) -> Gc<ast::Expr> {\n+pub fn string_to_expr (source_str : String) -> P<ast::Expr> {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_expr()\n     })\n }\n \n /// Parse a string, return an item\n-pub fn string_to_item (source_str : String) -> Option<Gc<ast::Item>> {\n+pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_item(Vec::new())\n     })\n }\n \n /// Parse a string, return a stmt\n-pub fn string_to_stmt(source_str : String) -> Gc<ast::Stmt> {\n+pub fn string_to_stmt(source_str : String) -> P<ast::Stmt> {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_stmt(Vec::new())\n     })\n }\n \n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n-pub fn string_to_pat(source_str: String) -> Gc<ast::Pat> {\n+pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n     string_to_parser(&new_parse_sess(), source_str).parse_pat()\n }\n "}, {"sha": "30a38e28729f0f6008e8adda4242b6ec2ac31709", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd8498afbb371939b7decdbee712f726ccbded3/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ccd8498afbb371939b7decdbee712f726ccbded3", "patch": "@@ -27,10 +27,9 @@ use abi::Abi;\n use ast::*;\n use ast;\n use codemap::Span;\n+use ptr::P;\n use owned_slice::OwnedSlice;\n \n-use std::gc::Gc;\n-\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n     FkItemFn(Ident, &'a Generics, FnStyle, Abi),\n@@ -121,16 +120,8 @@ pub fn walk_inlined_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v InlinedI\n     match *item {\n         IIItem(ref i) => visitor.visit_item(&**i),\n         IIForeign(ref i) => visitor.visit_foreign_item(&**i),\n-        IITraitItem(_, ref iti) => {\n-            match *iti {\n-                ProvidedInlinedTraitItem(ref m) => {\n-                    walk_method_helper(visitor, &**m)\n-                }\n-                RequiredInlinedTraitItem(ref m) => {\n-                    walk_method_helper(visitor, &**m)\n-                }\n-            }\n-        }\n+        IITraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n+        IIImplItem(_, MethodImplItem(ref m)) => walk_method_helper(visitor, &**m)\n     }\n }\n \n@@ -644,14 +635,14 @@ pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n }\n \n pub fn walk_expr_opt<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                         optional_expression: &'v Option<Gc<Expr>>) {\n+                                         optional_expression: &'v Option<P<Expr>>) {\n     match *optional_expression {\n         None => {}\n         Some(ref expression) => visitor.visit_expr(&**expression),\n     }\n }\n \n-pub fn walk_exprs<'v, V: Visitor<'v>>(visitor: &mut V, expressions: &'v [Gc<Expr>]) {\n+pub fn walk_exprs<'v, V: Visitor<'v>>(visitor: &mut V, expressions: &'v [P<Expr>]) {\n     for expression in expressions.iter() {\n         visitor.visit_expr(&**expression)\n     }"}]}