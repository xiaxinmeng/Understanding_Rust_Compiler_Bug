{"sha": "2c538e9c8c622123853d94ac4827d6a41dded447", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNTM4ZTljOGM2MjIxMjM4NTNkOTRhYzQ4MjdkNmE0MWRkZWQ0NDc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-31T13:58:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-31T13:58:16Z"}, "message": "Merge #10099\n\n10099: minor: improve readability r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "75050ad97884ddcb2d1aae8bc9d2640f1edba6b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75050ad97884ddcb2d1aae8bc9d2640f1edba6b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c538e9c8c622123853d94ac4827d6a41dded447", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhLjV4CRBK7hj4Ov3rIwAAf6cIAKW4BLgBXMGyrNdRHFzU39xm\nEv1RtTini5XFZwzCyZNzGHUqpfZLML5pRbxsV+wTiZenKzqKaNHWHEk+ZXXEEW/t\n/owjeO+SssTO/YJu6LyMq3peScBIKlWEeqmAxB2rHzfWZsBhIvXtpdSQgRRy2L7r\nbB9+FsTL1zaUVbHRoXYI7zOR+aoivbpyOdEs4Lb+cTwGYmu4oVfB9p8dsmPO9CPS\n6o1M+QHyQtkV0U9gj93W9nsEuzDRG0KOJWdVLH2+M3GjK1fmqSGp4hOXc0Aa1WSZ\nKyWqd+48qdMIYJMJ29m6aymPMrxJpdSKKPCJDm2+6DPbqd7KibeUZh8bZei+M2o=\n=PVBB\n-----END PGP SIGNATURE-----\n", "payload": "tree 75050ad97884ddcb2d1aae8bc9d2640f1edba6b1\nparent aa1cdc0cce39949389347b5e0a50d80f8f4ade66\nparent 722a2a46900461caac8ff6585f672040f6e85e4f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630418296 +0000\ncommitter GitHub <noreply@github.com> 1630418296 +0000\n\nMerge #10099\n\n10099: minor: improve readability r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c538e9c8c622123853d94ac4827d6a41dded447", "html_url": "https://github.com/rust-lang/rust/commit/2c538e9c8c622123853d94ac4827d6a41dded447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c538e9c8c622123853d94ac4827d6a41dded447/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa1cdc0cce39949389347b5e0a50d80f8f4ade66", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1cdc0cce39949389347b5e0a50d80f8f4ade66", "html_url": "https://github.com/rust-lang/rust/commit/aa1cdc0cce39949389347b5e0a50d80f8f4ade66"}, {"sha": "722a2a46900461caac8ff6585f672040f6e85e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/722a2a46900461caac8ff6585f672040f6e85e4f", "html_url": "https://github.com/rust-lang/rust/commit/722a2a46900461caac8ff6585f672040f6e85e4f"}], "stats": {"total": 134, "additions": 70, "deletions": 64}, "files": [{"sha": "55754325f6fe7bf5707bef3a59936d561ecda092", "filename": "crates/proc_macro_api/src/lib.rs", "status": "modified", "additions": 58, "deletions": 52, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Flib.rs?ref=2c538e9c8c622123853d94ac4827d6a41dded447", "patch": "@@ -26,16 +26,33 @@ pub use rpc::{\n };\n pub use version::{read_dylib_info, RustCInfo};\n \n+/// A handle to an external process which load dylibs with macros (.so or .dll)\n+/// and runs actual macro expansion functions.\n+#[derive(Debug)]\n+pub struct ProcMacroServer {\n+    /// Currently, the proc macro process expands all procedural macros sequentially.\n+    ///\n+    /// That means that concurrent salsa requests may block each other when expanding proc macros,\n+    /// which is unfortunate, but simple and good enough for the time being.\n+    ///\n+    /// Therefore, we just wrap the `ProcMacroProcessSrv` in a mutex here.\n+    process: Arc<Mutex<ProcMacroProcessSrv>>,\n+}\n+\n+/// A handle to a specific macro (a `#[proc_macro]` annotated function).\n+///\n+/// It exists withing a context of a specific [`ProcMacroProcess`] -- currently\n+/// we share a single expander process for all macros.\n #[derive(Debug, Clone)]\n-pub struct ProcMacroProcessExpander {\n+pub struct ProcMacro {\n     process: Arc<Mutex<ProcMacroProcessSrv>>,\n     dylib_path: AbsPathBuf,\n     name: SmolStr,\n     kind: ProcMacroKind,\n }\n \n-impl Eq for ProcMacroProcessExpander {}\n-impl PartialEq for ProcMacroProcessExpander {\n+impl Eq for ProcMacro {}\n+impl PartialEq for ProcMacro {\n     fn eq(&self, other: &Self) -> bool {\n         self.name == other.name\n             && self.kind == other.kind\n@@ -44,60 +61,17 @@ impl PartialEq for ProcMacroProcessExpander {\n     }\n }\n \n-impl ProcMacroProcessExpander {\n-    pub fn name(&self) -> &str {\n-        &self.name\n-    }\n-\n-    pub fn kind(&self) -> ProcMacroKind {\n-        self.kind\n-    }\n-\n-    pub fn expand(\n-        &self,\n-        subtree: &Subtree,\n-        attr: Option<&Subtree>,\n-        env: Vec<(String, String)>,\n-    ) -> Result<Subtree, tt::ExpansionError> {\n-        let task = ExpansionTask {\n-            macro_body: FlatTree::new(subtree),\n-            macro_name: self.name.to_string(),\n-            attributes: attr.map(FlatTree::new),\n-            lib: self.dylib_path.to_path_buf().into(),\n-            env,\n-        };\n-\n-        let result: ExpansionResult = self\n-            .process\n-            .lock()\n-            .unwrap_or_else(|e| e.into_inner())\n-            .send_task(msg::Request::ExpansionMacro(task))?;\n-        Ok(result.expansion.to_subtree())\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct ProcMacroClient {\n-    /// Currently, the proc macro process expands all procedural macros sequentially.\n-    ///\n-    /// That means that concurrent salsa requests may block each other when expanding proc macros,\n-    /// which is unfortunate, but simple and good enough for the time being.\n-    ///\n-    /// Therefore, we just wrap the `ProcMacroProcessSrv` in a mutex here.\n-    process: Arc<Mutex<ProcMacroProcessSrv>>,\n-}\n-\n-impl ProcMacroClient {\n+impl ProcMacroServer {\n     /// Spawns an external process as the proc macro server and returns a client connected to it.\n-    pub fn extern_process(\n+    pub fn spawn(\n         process_path: AbsPathBuf,\n         args: impl IntoIterator<Item = impl AsRef<OsStr>>,\n-    ) -> io::Result<ProcMacroClient> {\n+    ) -> io::Result<ProcMacroServer> {\n         let process = ProcMacroProcessSrv::run(process_path, args)?;\n-        Ok(ProcMacroClient { process: Arc::new(Mutex::new(process)) })\n+        Ok(ProcMacroServer { process: Arc::new(Mutex::new(process)) })\n     }\n \n-    pub fn by_dylib_path(&self, dylib_path: &AbsPath) -> Vec<ProcMacroProcessExpander> {\n+    pub fn load_dylib(&self, dylib_path: &AbsPath) -> Vec<ProcMacro> {\n         let _p = profile::span(\"ProcMacroClient::by_dylib_path\");\n         match version::read_dylib_info(dylib_path) {\n             Ok(info) => {\n@@ -129,7 +103,7 @@ impl ProcMacroClient {\n \n         macros\n             .into_iter()\n-            .map(|(name, kind)| ProcMacroProcessExpander {\n+            .map(|(name, kind)| ProcMacro {\n                 process: self.process.clone(),\n                 name: name.into(),\n                 kind,\n@@ -138,3 +112,35 @@ impl ProcMacroClient {\n             .collect()\n     }\n }\n+\n+impl ProcMacro {\n+    pub fn name(&self) -> &str {\n+        &self.name\n+    }\n+\n+    pub fn kind(&self) -> ProcMacroKind {\n+        self.kind\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        subtree: &Subtree,\n+        attr: Option<&Subtree>,\n+        env: Vec<(String, String)>,\n+    ) -> Result<Subtree, tt::ExpansionError> {\n+        let task = ExpansionTask {\n+            macro_body: FlatTree::new(subtree),\n+            macro_name: self.name.to_string(),\n+            attributes: attr.map(FlatTree::new),\n+            lib: self.dylib_path.to_path_buf().into(),\n+            env,\n+        };\n+\n+        let result: ExpansionResult = self\n+            .process\n+            .lock()\n+            .unwrap_or_else(|e| e.into_inner())\n+            .send_task(msg::Request::ExpansionMacro(task))?;\n+        Ok(result.expansion.to_subtree())\n+    }\n+}"}, {"sha": "d60861a62743ecaedb488940bea9ac19a66992ca", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=2c538e9c8c622123853d94ac4827d6a41dded447", "patch": "@@ -7,7 +7,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use hir::db::DefDatabase;\n use ide::{AnalysisHost, Change};\n use ide_db::base_db::CrateGraph;\n-use proc_macro_api::ProcMacroClient;\n+use proc_macro_api::ProcMacroServer;\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n use vfs::{loader::Handle, AbsPath, AbsPathBuf};\n \n@@ -28,7 +28,7 @@ pub fn load_workspace_at(\n     cargo_config: &CargoConfig,\n     load_config: &LoadCargoConfig,\n     progress: &dyn Fn(String),\n-) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroClient>)> {\n+) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroServer>)> {\n     let root = AbsPathBuf::assert(std::env::current_dir()?.join(root));\n     let root = ProjectManifest::discover_single(&root)?;\n     let mut workspace = ProjectWorkspace::load(root, cargo_config, progress)?;\n@@ -49,7 +49,7 @@ pub fn load_workspace_at(\n pub fn load_workspace(\n     ws: ProjectWorkspace,\n     load_config: &LoadCargoConfig,\n-) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroClient>)> {\n+) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroServer>)> {\n     let (sender, receiver) = unbounded();\n     let mut vfs = vfs::Vfs::default();\n     let mut loader = {\n@@ -60,7 +60,7 @@ pub fn load_workspace(\n \n     let proc_macro_client = if load_config.with_proc_macro {\n         let path = AbsPathBuf::assert(std::env::current_exe()?);\n-        Some(ProcMacroClient::extern_process(path, &[\"proc-macro\"]).unwrap())\n+        Some(ProcMacroServer::spawn(path, &[\"proc-macro\"]).unwrap())\n     } else {\n         None\n     };"}, {"sha": "19ddd7c717d891f2c7b95119a18313a48e90f9ba", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=2c538e9c8c622123853d94ac4827d6a41dded447", "patch": "@@ -11,7 +11,7 @@ use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n use ide_db::base_db::CrateId;\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n-use proc_macro_api::ProcMacroClient;\n+use proc_macro_api::ProcMacroServer;\n use project_model::{CargoWorkspace, ProjectWorkspace, Target, WorkspaceBuildScripts};\n use rustc_hash::FxHashMap;\n use vfs::AnchoredPathBuf;\n@@ -60,7 +60,7 @@ pub(crate) struct GlobalState {\n     pub(crate) shutdown_requested: bool,\n     pub(crate) last_reported_status: Option<lsp_ext::ServerStatusParams>,\n     pub(crate) source_root_config: SourceRootConfig,\n-    pub(crate) proc_macro_client: Option<ProcMacroClient>,\n+    pub(crate) proc_macro_client: Option<ProcMacroServer>,\n \n     pub(crate) flycheck: Vec<FlycheckHandle>,\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,"}, {"sha": "7e419ba839d9a9a30b5f001b1774f760c25e0ab1", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=2c538e9c8c622123853d94ac4827d6a41dded447", "patch": "@@ -7,7 +7,7 @@ use ide::Change;\n use ide_db::base_db::{\n     CrateGraph, Env, ProcMacro, ProcMacroExpander, ProcMacroKind, SourceRoot, VfsPath,\n };\n-use proc_macro_api::ProcMacroClient;\n+use proc_macro_api::ProcMacroServer;\n use project_model::{ProjectWorkspace, WorkspaceBuildScripts};\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n \n@@ -329,7 +329,7 @@ impl GlobalState {\n         if self.proc_macro_client.is_none() {\n             self.proc_macro_client = match self.config.proc_macro_srv() {\n                 None => None,\n-                Some((path, args)) => match ProcMacroClient::extern_process(path.clone(), args) {\n+                Some((path, args)) => match ProcMacroServer::spawn(path.clone(), args) {\n                     Ok(it) => Some(it),\n                     Err(err) => {\n                         tracing::error!(\n@@ -556,15 +556,15 @@ impl SourceRootConfig {\n     }\n }\n \n-pub(crate) fn load_proc_macro(client: Option<&ProcMacroClient>, path: &AbsPath) -> Vec<ProcMacro> {\n+pub(crate) fn load_proc_macro(client: Option<&ProcMacroServer>, path: &AbsPath) -> Vec<ProcMacro> {\n     return client\n-        .map(|it| it.by_dylib_path(path))\n+        .map(|it| it.load_dylib(path))\n         .unwrap_or_default()\n         .into_iter()\n         .map(expander_to_proc_macro)\n         .collect();\n \n-    fn expander_to_proc_macro(expander: proc_macro_api::ProcMacroProcessExpander) -> ProcMacro {\n+    fn expander_to_proc_macro(expander: proc_macro_api::ProcMacro) -> ProcMacro {\n         let name = expander.name().into();\n         let kind = match expander.kind() {\n             proc_macro_api::ProcMacroKind::CustomDerive => ProcMacroKind::CustomDerive,\n@@ -576,7 +576,7 @@ pub(crate) fn load_proc_macro(client: Option<&ProcMacroClient>, path: &AbsPath)\n     }\n \n     #[derive(Debug)]\n-    struct Expander(proc_macro_api::ProcMacroProcessExpander);\n+    struct Expander(proc_macro_api::ProcMacro);\n \n     impl ProcMacroExpander for Expander {\n         fn expand("}]}