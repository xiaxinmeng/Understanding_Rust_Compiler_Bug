{"sha": "0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZGE3YzdmZmU0NTNiOWRmODQ5OTk2ZjhkY2EwYjhkMGYyZDllNjI=", "commit": {"author": {"name": "reedlepee", "email": "reedlepee123@gmail.com", "date": "2013-10-20T00:33:09Z"}, "committer": {"name": "reedlepee", "email": "reedlepee123@gmail.com", "date": "2013-10-22T19:40:50Z"}, "message": "Making fields in std and extra : private  #4386", "tree": {"sha": "6f1dc6e0c50e81caacfcb5cef1a9543d9442e87e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f1dc6e0c50e81caacfcb5cef1a9543d9442e87e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "html_url": "https://github.com/rust-lang/rust/commit/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/comments", "author": {"login": "reedlepee123", "id": 5721031, "node_id": "MDQ6VXNlcjU3MjEwMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/5721031?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reedlepee123", "html_url": "https://github.com/reedlepee123", "followers_url": "https://api.github.com/users/reedlepee123/followers", "following_url": "https://api.github.com/users/reedlepee123/following{/other_user}", "gists_url": "https://api.github.com/users/reedlepee123/gists{/gist_id}", "starred_url": "https://api.github.com/users/reedlepee123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reedlepee123/subscriptions", "organizations_url": "https://api.github.com/users/reedlepee123/orgs", "repos_url": "https://api.github.com/users/reedlepee123/repos", "events_url": "https://api.github.com/users/reedlepee123/events{/privacy}", "received_events_url": "https://api.github.com/users/reedlepee123/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reedlepee123", "id": 5721031, "node_id": "MDQ6VXNlcjU3MjEwMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/5721031?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reedlepee123", "html_url": "https://github.com/reedlepee123", "followers_url": "https://api.github.com/users/reedlepee123/followers", "following_url": "https://api.github.com/users/reedlepee123/following{/other_user}", "gists_url": "https://api.github.com/users/reedlepee123/gists{/gist_id}", "starred_url": "https://api.github.com/users/reedlepee123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reedlepee123/subscriptions", "organizations_url": "https://api.github.com/users/reedlepee123/orgs", "repos_url": "https://api.github.com/users/reedlepee123/repos", "events_url": "https://api.github.com/users/reedlepee123/events{/privacy}", "received_events_url": "https://api.github.com/users/reedlepee123/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dadb6f0cd9fa7e4b402a0107358acb34002d4895", "url": "https://api.github.com/repos/rust-lang/rust/commits/dadb6f0cd9fa7e4b402a0107358acb34002d4895", "html_url": "https://github.com/rust-lang/rust/commit/dadb6f0cd9fa7e4b402a0107358acb34002d4895"}], "stats": {"total": 1954, "additions": 1504, "deletions": 450}, "files": [{"sha": "932dac4195c3c398071baaea44c9fd998285733a", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -50,6 +50,7 @@ use std::borrow;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signaling.\n pub struct Condvar<'self> {\n+    // all were already priv\n     priv is_mutex: bool,\n     priv failed: &'self mut bool,\n     priv cond: &'self sync::Condvar<'self>\n@@ -108,6 +109,7 @@ impl<'self> Condvar<'self> {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n+// all were already priv\n pub struct Arc<T> { priv x: UnsafeArc<T> }\n \n \n@@ -162,6 +164,7 @@ struct MutexArcInner<T> { priv lock: Mutex, priv failed: bool, priv data: T }\n \n /// An Arc with mutable data protected by a blocking mutex.\n #[no_freeze]\n+//All were already priv\n pub struct MutexArc<T> { priv x: UnsafeArc<MutexArcInner<T>> }\n \n \n@@ -344,6 +347,7 @@ struct RWArcInner<T> { priv lock: RWLock, priv failed: bool, priv data: T }\n  */\n #[no_freeze]\n pub struct RWArc<T> {\n+    // all were already priv\n     priv x: UnsafeArc<RWArcInner<T>>,\n }\n \n@@ -521,15 +525,18 @@ fn borrow_rwlock<T:Freeze + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n \n /// The \"write permission\" token used for RWArc.write_downgrade().\n pub struct RWWriteMode<'self, T> {\n-    data: &'self mut T,\n-    token: sync::RWLockWriteMode<'self>,\n-    poison: PoisonOnFail,\n+\n+/// reedlepee added priv in all the feilds below\n+    priv data: &'self mut T,\n+    priv token: sync::RWLockWriteMode<'self>,\n+    priv poison: PoisonOnFail,\n }\n \n /// The \"read permission\" token used for RWArc.write_downgrade().\n pub struct RWReadMode<'self, T> {\n-    data: &'self T,\n-    token: sync::RWLockReadMode<'self>,\n+/// reedlepee added priv in all the feilds below\n+    priv data: &'self T,\n+    priv token: sync::RWLockReadMode<'self>,\n }\n \n impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {"}, {"sha": "934217f581b13ad8cc80736236bcca3deeb7f22d", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -62,6 +62,7 @@ pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n     // access the head.\n+/// no change  by reedlepee all were already priv\n     priv head: Chunk,\n     priv pod_head: Chunk,\n     priv chunks: @mut MutList<Chunk>,"}, {"sha": "212525508c17b445a57de6c99e731d6b3e46da5b", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -21,12 +21,13 @@ pub enum CharacterSet {\n \n /// Contains configuration parameters for `to_base64`.\n pub struct Config {\n+    /// all were made priv by reedlepee\n     /// Character set to use\n-    char_set: CharacterSet,\n+    priv char_set: CharacterSet,\n     /// True to pad output with `=` characters\n-    pad: bool,\n+    priv pad: bool,\n     /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n-    line_length: Option<uint>\n+    priv line_length: Option<uint>\n }\n \n /// Configuration for RFC 4648 standard base64 encoding"}, {"sha": "39a5f1d7a6626ff0b4a030730eceb91b1fef3899", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -225,10 +225,11 @@ enum Op {Union, Intersect, Assign, Difference}\n /// The bitvector type\n #[deriving(Clone)]\n pub struct Bitv {\n+    /// all were made priv by reedlepee\n     /// Internal representation of the bit vector (small or large)\n-    rep: BitvVariant,\n+    priv rep: BitvVariant,\n     /// The number of valid bits in the internal representation\n-    nbits: uint\n+    priv nbits: uint\n }\n \n fn die() -> ! {\n@@ -573,6 +574,7 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n \n /// An iterator for `Bitv`.\n pub struct BitvIterator<'self> {\n+    /// all were already priv\n     priv bitv: &'self Bitv,\n     priv next_idx: uint,\n     priv end_idx: uint,\n@@ -634,6 +636,7 @@ impl<'self> RandomAccessIterator<bool> for BitvIterator<'self> {\n /// as a `uint`.\n #[deriving(Clone)]\n pub struct BitvSet {\n+    // all were already priv!!\n     priv size: uint,\n \n     // In theory this is a `Bitv` instead of always a `BigBitv`, but knowing that\n@@ -900,6 +903,7 @@ impl BitvSet {\n }\n \n pub struct BitvSetIterator<'self> {\n+    // all were already priv\n     priv set: &'self BitvSet,\n     priv next_idx: uint\n }"}, {"sha": "501a71fca151851507e0977a2b5858d0d4c9d83e", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -44,6 +44,7 @@ use std::util;\n  * The type representing a foreign chunk of memory\n  */\n pub struct CVec<T> {\n+    /// No change all were allready priv!!\n     priv base: *mut T,\n     priv len: uint,\n     priv rsrc: @DtorRes,"}, {"sha": "d96925bce6941d0fbda44ac68b735a6cf4c71add", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -23,6 +23,7 @@ use std::comm;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n+// all were already priv\n     priv chan: Chan<T>,\n     priv port: Port<U>,\n }\n@@ -91,8 +92,10 @@ pub fn DuplexStream<T:Send,U:Send>()\n }\n \n /// An extension of `pipes::stream` that provides synchronous message sending.\n+// all were already priv\n pub struct SyncChan<T> { priv duplex_stream: DuplexStream<T, ()> }\n /// An extension of `pipes::stream` that acknowledges each message received.\n+// all were already priv\n pub struct SyncPort<T> { priv duplex_stream: DuplexStream<(), T> }\n \n impl<T: Send> GenericChan<T> for SyncChan<T> {"}, {"sha": "d6189e33911fd423be7937fcee1c9cc53185c1b9", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -284,6 +284,7 @@ macro_rules! impl_fixed_buffer( ($name:ident, $size:expr) => (\n \n /// A fixed size buffer of 64 bytes useful for cryptographic operations.\n pub struct FixedBuffer64 {\n+    // already priv\n     priv buffer: [u8, ..64],\n     priv buffer_idx: uint,\n }\n@@ -302,6 +303,7 @@ impl_fixed_buffer!(FixedBuffer64, 64)\n \n /// A fixed size buffer of 128 bytes useful for cryptographic operations.\n pub struct FixedBuffer128 {\n+    // already priv\n     priv buffer: [u8, ..128],\n     priv buffer_idx: uint,\n }"}, {"sha": "63ee2ccf79020c0d7b0aa9535d8e9885a45bd88b", "filename": "src/libextra/crypto/md5.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fmd5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fmd5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fmd5.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -159,6 +159,7 @@ static C4: [u32, ..16] = [\n \n /// The MD5 Digest algorithm\n pub struct Md5 {\n+    // already priv\n     priv length_bytes: u64,\n     priv buffer: FixedBuffer64,\n     priv state: Md5State,"}, {"sha": "9343124e83df12e70ba7d8ea6f13f7cf31503914", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -43,6 +43,7 @@ static K3: u32 = 0xCA62C1D6u32;\n \n /// Structure representing the state of a Sha1 computation\n pub struct Sha1 {\n+    // already priv\n     priv h: [u32, ..DIGEST_BUF_LEN],\n     priv length_bits: u64,\n     priv buffer: FixedBuffer64,"}, {"sha": "529cab913370354e40b0ab9eb20078b2f79424b9", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -234,6 +234,7 @@ impl Engine512 {\n \n /// The SHA-512 hash algorithm\n pub struct Sha512 {\n+    // already priv\n     priv engine: Engine512\n }\n \n@@ -287,6 +288,7 @@ static H512: [u64, ..8] = [\n \n /// The SHA-384 hash algorithm\n pub struct Sha384 {\n+    // already priv\n     priv engine: Engine512\n }\n \n@@ -338,6 +340,7 @@ static H384: [u64, ..8] = [\n \n /// The SHA-512 hash algorithm with digest truncated to 256 bits\n pub struct Sha512Trunc256 {\n+    // already priv\n     priv engine: Engine512\n }\n \n@@ -387,6 +390,7 @@ static H512_TRUNC_256: [u64, ..8] = [\n \n /// The SHA-512 hash algorithm with digest truncated to 224 bits\n pub struct Sha512Trunc224 {\n+    // already priv\n     priv engine: Engine512\n }\n \n@@ -643,6 +647,7 @@ impl Engine256 {\n \n /// The SHA-256 hash algorithm\n pub struct Sha256 {\n+    // already priv\n     priv engine: Engine256\n }\n \n@@ -696,6 +701,7 @@ static H256: [u32, ..8] = [\n \n /// The SHA-224 hash algorithm\n pub struct Sha224 {\n+    // already priv\n     priv engine: Engine256\n }\n "}, {"sha": "102f0eac853366d978a0f8c07e134065cbf0f3b4", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -32,6 +32,7 @@ use container::Deque;\n \n /// A doubly-linked list.\n pub struct DList<T> {\n+    // all were already priv\n     priv length: uint,\n     priv list_head: Link<T>,\n     priv list_tail: Rawlink<Node<T>>,\n@@ -49,13 +50,15 @@ struct Node<T> {\n /// Double-ended DList iterator\n #[deriving(Clone)]\n pub struct DListIterator<'self, T> {\n+    // all were already priv\n     priv head: &'self Link<T>,\n     priv tail: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n /// Double-ended mutable DList iterator\n pub struct MutDListIterator<'self, T> {\n+    // all were already priv\n     priv list: &'self mut DList<T>,\n     priv head: Rawlink<Node<T>>,\n     priv tail: Rawlink<Node<T>>,\n@@ -65,6 +68,7 @@ pub struct MutDListIterator<'self, T> {\n /// DList consuming iterator\n #[deriving(Clone)]\n pub struct MoveIterator<T> {\n+    // all were already priv\n     priv list: DList<T>\n }\n "}, {"sha": "ac1edd3f116e51d49d98841f2a9b410e55aeec9b", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -30,6 +30,7 @@ struct EbmlState {\n \n #[deriving(Clone)]\n pub struct Doc {\n+    // all these should be public\n     data: @~[u8],\n     start: uint,\n     end: uint,\n@@ -50,7 +51,9 @@ impl Doc {\n }\n \n pub struct TaggedDoc {\n-    tag: uint,\n+    // was made privv by reedlepee\n+    priv tag: uint,\n+    // should be public\n     doc: Doc,\n }\n \n@@ -284,6 +287,7 @@ pub mod reader {\n     pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n     pub struct Decoder {\n+        // all were already  priv\n         priv parent: Doc,\n         priv pos: uint,\n     }\n@@ -618,8 +622,10 @@ pub mod writer {\n \n     // ebml writing\n     pub struct Encoder {\n-        writer: @io::Writer,\n-        priv size_positions: ~[uint],\n+    /// should be public!!\n+    writer: @io::Writer,\n+    /// this was already privv!!\n+    priv size_positions: ~[uint],\n     }\n \n     impl Clone for Encoder {"}, {"sha": "7908f73453ac9d85d7a2319cbddd7d79bac35f3d", "filename": "src/libextra/enum_set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fenum_set.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -18,6 +18,7 @@\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n+    // all were already priv\n     priv bits: uint\n }\n \n@@ -100,6 +101,7 @@ impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n \n /// An iterator over an EnumSet\n pub struct EnumSetIterator<E> {\n+    // all were already priv\n     priv index: uint,\n     priv bits: uint,\n }"}, {"sha": "abc3f4b98f11d0d69a44f6813d043f184e1adcc0", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -109,9 +109,10 @@ file is `stdin`.\n */\n #[deriving(Clone)]\n pub struct FileInputState {\n-    current_path: Option<Path>,\n-    line_num: uint,\n-    line_num_file: uint\n+    // all were priv made by reedlepee\n+    priv current_path: Option<Path>,\n+    priv line_num: uint,\n+    priv line_num_file: uint\n }\n \n impl FileInputState {\n@@ -155,7 +156,8 @@ struct FileInput_ {\n // \"self.fi\" -> \"self.\" and renaming FileInput_. Documentation above\n // will likely have to be updated to use `let mut in = ...`.\n pub struct FileInput  {\n-    fi: @mut FileInput_\n+/// all were made priv by reedlepee\n+    priv fi: @mut FileInput_\n }\n \n impl FileInput {"}, {"sha": "f2bedd9bc7a245d1ace3b9c349b63b0d9de9f3de", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -32,6 +32,7 @@ use std::util::replace;\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n+    // all were already privv!!\n     priv state: FutureState<A>,\n }\n "}, {"sha": "255c3fef24d7cae02d5c60a092919cfe14ac9b84", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -112,14 +112,16 @@ pub enum Occur {\n /// A description of a possible option.\n #[deriving(Clone, Eq)]\n pub struct Opt {\n+\n+    /// reedlepee added priv infront of them!!\n     /// Name of the option\n     name: Name,\n-    /// Wheter it has an argument\n+    /// Wheter it has an argument...  should be public!!\n     hasarg: HasArg,\n-    /// How often it can occur\n+    /// How often it can occur... should be private !!\n     occur: Occur,\n     /// Which options it aliases\n-    aliases: ~[Opt],\n+    priv aliases: ~[Opt],\n }\n \n /// Describes wether an option is given at all or has a value.\n@@ -133,11 +135,14 @@ enum Optval {\n /// of matches and a vector of free strings.\n #[deriving(Clone, Eq)]\n pub struct Matches {\n+\n+/// reedlepee added priv infront of all\n     /// Options that matched\n-    opts: ~[Opt],\n+    priv opts: ~[Opt],\n     /// Values of the Options that matched\n-    vals: ~[~[Optval]],\n+    priv vals: ~[~[Optval]],\n     /// Free string fragments\n+    // public\n     free: ~[~str]\n }\n "}, {"sha": "a094df4e75603a97551e643b7cc70c92b86c3884", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -33,6 +33,7 @@ use sort;\n  * pattern - see the `glob` function for more details.\n  */\n pub struct GlobIterator {\n+    /// no change by reedlepee all were priv already!!\n     priv root: Path,\n     priv dir_patterns: ~[Pattern],\n     priv options: MatchOptions,\n@@ -156,6 +157,7 @@ fn list_dir_sorted(path: &Path) -> ~[Path] {\n  */\n #[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n pub struct Pattern {\n+    // already priv\n     priv tokens: ~[PatternToken]\n }\n \n@@ -474,27 +476,28 @@ fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n  */\n #[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n pub struct MatchOptions {\n+/// all were made priv  by reedlepee\n \n     /**\n      * Whether or not patterns should be matched in a case-sensitive manner. This\n      * currently only considers upper/lower case relationships between ASCII characters,\n      * but in future this might be extended to work with Unicode.\n      */\n-    case_sensitive: bool,\n+    priv case_sensitive: bool,\n \n     /**\n      * If this is true then path-component separator characters (e.g. `/` on Posix)\n      * must be matched by a literal `/`, rather than by `*` or `?` or `[...]`\n      */\n-    require_literal_separator: bool,\n+    priv require_literal_separator: bool,\n \n     /**\n      * If this is true then paths that contain components that start with a `.` will\n      * not match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\n      * will not match. This is useful because such files are conventionally considered\n      * hidden on Unix systems and it might be desirable to skip them when listing files.\n      */\n-    require_literal_leading_dot: bool\n+    priv require_literal_leading_dot: bool\n }\n \n impl MatchOptions {"}, {"sha": "415fa590d4c76bafa19eb603c27d2e0b51c07319", "filename": "src/libextra/io_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -16,10 +16,11 @@ use std::cast;\n \n /// An implementation of the io::Reader interface which reads a buffer of bytes\n pub struct BufReader {\n+    // all were made priv by reedlepee\n     /// The buffer of bytes to read\n-    buf: ~[u8],\n+    priv buf: ~[u8],\n     /// The current position in the buffer of bytes\n-    pos: @mut uint\n+    priv pos: @mut uint\n }\n \n impl BufReader {"}, {"sha": "2ddb389398df0f565cccf94be379d2c78d0862a9", "filename": "src/libextra/json.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -48,12 +48,13 @@ pub type Object = TreeMap<~str, Json>;\n /// If an error occurs while parsing some JSON, this is the structure which is\n /// returned\n pub struct Error {\n+    // all were made privv by reedlepee\n     /// The line number at which the error occurred\n-    line: uint,\n+    priv line: uint,\n     /// The column number at which the error occurred\n-    col: uint,\n+    priv col: uint,\n     /// A message describing the type of the error\n-    msg: @~str,\n+    priv msg: @~str,\n }\n \n fn escape_str(s: &str) -> ~str {\n@@ -86,6 +87,7 @@ fn spaces(n: uint) -> ~str {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder {\n+    // all were already priv\n     priv wr: @io::Writer,\n }\n \n@@ -243,6 +245,7 @@ impl serialize::Encoder for Encoder {\n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder {\n+    // all were already priv\n     priv wr: @io::Writer,\n     priv indent: uint,\n }\n@@ -479,6 +482,7 @@ impl Json{\n }\n \n pub struct Parser<T> {\n+    // all were already priv\n     priv rdr: ~T,\n     priv ch: char,\n     priv line: uint,\n@@ -868,6 +872,7 @@ pub fn from_str(s: &str) -> Result<Json, Error> {\n \n /// A structure to decode JSON to values in rust.\n pub struct Decoder {\n+    // all were already priv\n     priv stack: ~[Json],\n }\n "}, {"sha": "33803cb5ff3eaf258711361a4740e9b41d932fe1", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -86,6 +86,7 @@ A `BigUint`-typed value `BigUint { data: @[a, b, c] }` represents a number\n */\n #[deriving(Clone)]\n pub struct BigUint {\n+    // already priv\n     priv data: ~[BigDigit]\n }\n \n@@ -893,6 +894,7 @@ impl Neg<Sign> for Sign {\n /// A big signed integer type.\n #[deriving(Clone)]\n pub struct BigInt {\n+    // already priv\n     priv sign: Sign,\n     priv data: BigUint\n }"}, {"sha": "a59a09c84e2722b65a8148b9c969027241d0b0d8", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -24,10 +24,11 @@ use std::num::{Zero,One,ToStrRadix};\n /// A complex number in Cartesian form.\n #[deriving(Eq,Clone)]\n pub struct Cmplx<T> {\n+    // all made real by reedlepee\n     /// Real portion of the complex number\n-    re: T,\n+    priv re: T,\n     /// Imaginary portion of the complex number\n-    im: T\n+    priv im: T\n }\n \n pub type Complex32 = Cmplx<f32>;"}, {"sha": "01176f7150f2398cd1a02be4db66e213205a17ab", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -20,8 +20,9 @@ use super::bigint::BigInt;\n #[deriving(Clone)]\n #[allow(missing_doc)]\n pub struct Ratio<T> {\n-    numer: T,\n-    denom: T\n+    // made priv by reedlepee\n+    priv numer: T,\n+    priv denom: T\n }\n \n /// Alias for a `Ratio` of machine-sized integers."}, {"sha": "a5851778ab3f71970e16167a95914290cf8386a2", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -20,6 +20,7 @@ use std::vec;\n /// A priority queue implemented with a binary heap\n #[deriving(Clone)]\n pub struct PriorityQueue<T> {\n+    // all were already priv\n     priv data: ~[T],\n }\n \n@@ -178,6 +179,7 @@ impl<T:Ord> PriorityQueue<T> {\n \n /// PriorityQueue iterator\n pub struct PriorityQueueIterator <'self, T> {\n+    // all were already priv\n     priv iter: vec::VecIterator<'self, T>,\n }\n "}, {"sha": "2946046485231edc4107a6f5d7419a0b2729d66d", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -25,6 +25,7 @@ static MINIMUM_CAPACITY: uint = 2u;\n /// RingBuf is a circular buffer that implements Deque.\n #[deriving(Clone)]\n pub struct RingBuf<T> {\n+    // all were already priv\n     priv nelts: uint,\n     priv lo: uint,\n     priv elts: ~[Option<T>]\n@@ -248,6 +249,7 @@ macro_rules! iterator_rev {\n \n /// RingBuf iterator\n pub struct RingBufIterator<'self, T> {\n+    // all were already priv\n     priv lo: uint,\n     priv index: uint,\n     priv rindex: uint,\n@@ -275,6 +277,7 @@ impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n \n /// RingBuf mutable iterator\n pub struct RingBufMutIterator<'self, T> {\n+    // all were already priv\n     priv lo: uint,\n     priv index: uint,\n     priv rindex: uint,"}, {"sha": "b9225e66399d1c92c1a2f3f46be8e0ae5c7bfb4e", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -70,18 +70,19 @@ impl ToStr for Identifier {\n /// Represents a version number conforming to the semantic versioning scheme.\n #[deriving(Clone, Eq)]\n pub struct Version {\n+    /// reedlepee added priv in all\n     /// The major version, to be incremented on incompatible changes.\n-    major: uint,\n+    priv major: uint,\n     /// The minor version, to be incremented when functionality is added in a\n     /// backwards-compatible manner.\n-    minor: uint,\n+    priv minor: uint,\n     /// The patch version, to be incremented when backwards-compatible bug\n     /// fixes are made.\n-    patch: uint,\n+    priv patch: uint,\n     /// The pre-release version identifier, if one exists.\n-    pre: ~[Identifier],\n+    priv pre: ~[Identifier],\n     /// The build metadata, ignored when determining version precedence.\n-    build: ~[Identifier],\n+    priv build: ~[Identifier],\n }\n \n impl ToStr for Version {"}, {"sha": "c0d40514c4ccaa1e691b62fbb8c4280e44176c85", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -22,6 +22,7 @@ use std::vec;\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n+    /// all were already priv!!\n     priv v: ~[Option<T>],\n }\n \n@@ -233,6 +234,7 @@ macro_rules! double_ended_iterator {\n }\n \n pub struct SmallIntMapIterator<'self, T> {\n+    /// all were already priv!!\n     priv front: uint,\n     priv back: uint,\n     priv iter: VecIterator<'self, Option<T>>\n@@ -243,6 +245,7 @@ double_ended_iterator!(impl SmallIntMapIterator -> (uint, &'self T), get_ref)\n pub type SmallIntMapRevIterator<'self, T> = Invert<SmallIntMapIterator<'self, T>>;\n \n pub struct SmallIntMapMutIterator<'self, T> {\n+    /// all were already priv!!\n     priv front: uint,\n     priv back: uint,\n     priv iter: VecMutIterator<'self, Option<T>>"}, {"sha": "3e252e30842dbb1eac31bdfee21c70f94f14c8cb", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -105,18 +105,24 @@ pub trait Stats {\n #[deriving(Clone, Eq)]\n #[allow(missing_doc)]\n pub struct Summary {\n-    sum: f64,\n+  /// all were made privv by reedlepee\n+    priv sum: f64,\n+    // public\n     min: f64,\n+    // public\n     max: f64,\n-    mean: f64,\n+    priv mean: f64,\n+    // public\n     median: f64,\n-    var: f64,\n-    std_dev: f64,\n-    std_dev_pct: f64,\n+    priv var: f64,\n+    priv std_dev: f64,\n+    priv std_dev_pct: f64,\n+    // public\n     median_abs_dev: f64,\n+    // public\n     median_abs_dev_pct: f64,\n-    quartiles: (f64,f64,f64),\n-    iqr: f64,\n+    priv quartiles: (f64,f64,f64),\n+    priv iqr: f64,\n }\n \n impl Summary {"}, {"sha": "cda912857d739c56611a49f4012b1f66344597f3", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -167,6 +167,9 @@ enum ReacquireOrderLock<'self> {\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n pub struct Condvar<'self> {\n+\n+    // reedlepee didnot change anything they were already priv!!!\n+\n     // The 'Sem' object associated with this condvar. This is the one that's\n     // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n     priv sem: &'self Sem<~[WaitQueue]>,\n@@ -376,8 +379,9 @@ impl Semaphore {\n  * A task which fails while holding a mutex will unlock the mutex as it\n  * unwinds.\n  */\n-pub struct Mutex { priv sem: Sem<~[WaitQueue]> }\n \n+// reedlepee did not change !!\n+pub struct Mutex { priv sem: Sem<~[WaitQueue]> }\n impl Clone for Mutex {\n     /// Create a new handle to the mutex.\n     fn clone(&self) -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n@@ -444,6 +448,7 @@ struct RWLockInner {\n  * unwinds.\n  */\n pub struct RWLock {\n+    // reedlepee did not change they were already priv!!\n     priv order_lock:  Semaphore,\n     priv access_lock: Sem<~[WaitQueue]>,\n     priv state:       UnsafeArc<RWLockInner>,\n@@ -663,9 +668,12 @@ impl RWLock {\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n+\n+// already priv\n pub struct RWLockWriteMode<'self> { priv lock: &'self RWLock, priv token: NonCopyable }\n \n /// The \"read permission\" token used for rwlock.write_downgrade().\n+// already priv\n pub struct RWLockReadMode<'self> { priv lock: &'self RWLock,\n                                    priv token: NonCopyable }\n "}, {"sha": "50ddac3f84b2dbd5c7091ee1a83e77a6b5322493", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -28,8 +28,9 @@ enum Msg<T> {\n }\n \n pub struct TaskPool<T> {\n-    channels: ~[Chan<Msg<T>>],\n-    next_index: uint,\n+    /// all were made priv by reedlepee\n+    priv channels: ~[Chan<Msg<T>>],\n+    priv next_index: uint,\n }\n \n #[unsafe_destructor]"}, {"sha": "f2a022de233c9af9558258909d00ccb88c1b3c72", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -18,6 +18,7 @@ use std::rand;\n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-pased deletion.\n pub struct TempDir {\n+    // all were already priv!!\n     priv path: Option<Path>\n }\n "}, {"sha": "095afe7f77ea6581bec6330df8a4130c0eb7e2cf", "filename": "src/libextra/term.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -95,14 +95,19 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n \n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n-    num_colors: u16,\n+\n+// this was made priv by reedlepee\n+    priv num_colors: u16,\n+    // These were already priv\n     priv out: @io::Writer,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n pub struct Terminal {\n-    num_colors: u16,\n+    // this was made priv by reedlepee\n+    priv num_colors: u16,\n+   // These were already priv\n     priv out: @io::Writer,\n }\n "}, {"sha": "618067efb326dd54f28bc268922ba9bb06d48e27", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -47,10 +47,11 @@ pub enum Param {\n \n /// Container for static and dynamic variable arrays\n pub struct Variables {\n+    // made priv by redlpee\n     /// Static variables A-Z\n-    sta: [Param, ..26],\n+    priv sta: [Param, ..26],\n     /// Dynamic variables a-z\n-    dyn: [Param, ..26]\n+    priv dyn: [Param, ..26]\n }\n \n impl Variables {"}, {"sha": "691f5420dc85cab42358be8c757379dfee774afc", "filename": "src/libextra/terminfo/terminfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fterminfo.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -14,10 +14,11 @@ use std::hashmap::HashMap;\n \n /// A parsed terminfo entry.\n pub struct TermInfo {\n+    // made priv by redlpee\n     /// Names for the terminal\n-    names: ~[~str],\n+    priv names: ~[~str],\n     /// Map of capability name to boolean value\n-    bools: HashMap<~str, bool>,\n+    priv bools: HashMap<~str, bool>,\n     /// Map of capability name to numeric value\n     numbers: HashMap<~str, u16>,\n     /// Map of capability name to raw (unexpanded) string"}, {"sha": "78ee0db399e73ab1171112c9185a81f30b016e4a", "filename": "src/libextra/test.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -102,33 +102,39 @@ impl TestFn {\n \n // Structure passed to BenchFns\n pub struct BenchHarness {\n-    iterations: u64,\n-    ns_start: u64,\n-    ns_end: u64,\n+    // all changed to priv by reedlepee\n+    priv iterations: u64,\n+    priv ns_start: u64,\n+    priv ns_end: u64,\n+    // should be public\n     bytes: u64\n }\n \n // The definition of a single test. A test runner will run a list of\n // these.\n #[deriving(Clone)]\n pub struct TestDesc {\n+    // all changed to priv by reedlepee\n     name: TestName,\n     ignore: bool,\n     should_fail: bool\n }\n \n pub struct TestDescAndFn {\n+    // all changed to priv by reedlepee\n     desc: TestDesc,\n     testfn: TestFn,\n }\n \n #[deriving(Clone, Encodable, Decodable, Eq)]\n pub struct Metric {\n-    value: f64,\n-    noise: f64\n+    // all changed to priv by reedlepee\n+    priv value: f64,\n+    priv noise: f64\n }\n \n #[deriving(Eq)]\n+/// not adding priv infront of this struct b/c its a tuple struct!! - reedlepee\n pub struct MetricMap(TreeMap<~str,Metric>);\n \n impl Clone for MetricMap {\n@@ -186,6 +192,7 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n }\n \n pub struct TestOpts {\n+    /// priv added in all by reedlepee!!\n     filter: Option<~str>,\n     run_ignored: bool,\n     run_tests: bool,\n@@ -322,8 +329,9 @@ pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n \n #[deriving(Clone, Eq)]\n pub struct BenchSamples {\n-    ns_iter_summ: stats::Summary,\n-    mb_s: uint\n+    /// priv added in all by reedlepee\n+    priv ns_iter_summ: stats::Summary,\n+    priv mb_s: uint\n }\n \n #[deriving(Clone, Eq)]"}, {"sha": "5b1754e7243f65e8532a4d2320ffaf6842103024", "filename": "src/libextra/time.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -31,9 +31,11 @@ pub mod rustrt {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-#[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n-pub struct Timespec { sec: i64, nsec: i32 }\n \n+/// all were made priv reedlepee\n+\n+#[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n+pub struct Timespec { priv sec: i64, priv nsec: i32 }\n /*\n  * Timespec assumes that pre-epoch Timespecs have negative sec and positive\n  * nsec fields. Darwin's and Linux's struct timespec functions handle pre-\n@@ -105,18 +107,19 @@ pub fn tzset() {\n \n #[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n pub struct Tm {\n-    tm_sec: i32, // seconds after the minute ~[0-60]\n-    tm_min: i32, // minutes after the hour ~[0-59]\n-    tm_hour: i32, // hours after midnight ~[0-23]\n-    tm_mday: i32, // days of the month ~[1-31]\n-    tm_mon: i32, // months since January ~[0-11]\n-    tm_year: i32, // years since 1900\n-    tm_wday: i32, // days since Sunday ~[0-6]\n-    tm_yday: i32, // days since January 1 ~[0-365]\n-    tm_isdst: i32, // Daylight Savings Time flag\n-    tm_gmtoff: i32, // offset from UTC in seconds\n-    tm_zone: ~str, // timezone abbreviation\n-    tm_nsec: i32, // nanoseconds\n+    /// all were made priv by reedlepee\n+    priv tm_sec: i32, // seconds after the minute ~[0-60]\n+    priv tm_min: i32, // minutes after the hour ~[0-59]\n+    priv tm_hour: i32, // hours after midnight ~[0-23]\n+    priv tm_mday: i32, // days of the month ~[1-31]\n+    priv tm_mon: i32, // months since January ~[0-11]\n+    priv tm_year: i32, // years since 1900\n+    priv tm_wday: i32, // days since Sunday ~[0-6]\n+    priv tm_yday: i32, // days since January 1 ~[0-365]\n+    priv tm_isdst: i32, // Daylight Savings Time flag\n+    priv tm_gmtoff: i32, // offset from UTC in seconds\n+    priv tm_zone: ~str, // timezone abbreviation\n+    priv tm_nsec: i32, // nanoseconds\n }\n \n pub fn empty_tm() -> Tm {"}, {"sha": "ebb3494b5ebb0a677abca7393c418e21d1bfd6ec", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -36,6 +36,7 @@ use std::cmp::Ordering;\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub struct TreeMap<K, V> {\n+    /// all were already priv!!\n     priv root: Option<~TreeNode<K, V>>,\n     priv length: uint\n }\n@@ -229,6 +230,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<'self, K, V> {\n+    // all were already priv\n     priv stack: ~[&'self ~TreeNode<K, V>],\n     priv node: &'self Option<~TreeNode<K, V>>,\n     priv remaining_min: uint,\n@@ -275,6 +277,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n \n /// Lazy backward iterator over a map\n pub struct TreeMapRevIterator<'self, K, V> {\n+    // all were  already priv\n     priv iter: TreeMapIterator<'self, K, V>,\n }\n \n@@ -333,6 +336,7 @@ fn iter_traverse_complete<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n \n /// Lazy forward iterator over a map that consumes the map while iterating\n pub struct TreeMapMoveIterator<K, V> {\n+    // all were laready priv!!\n     priv stack: ~[TreeNode<K, V>],\n     priv remaining: uint\n }\n@@ -401,6 +405,7 @@ impl<'self, T> Iterator<&'self T> for TreeSetRevIterator<'self, T> {\n /// only requirement is that the type of the elements contained ascribes to the\n /// `TotalOrd` trait.\n pub struct TreeSet<T> {\n+    //all were already priv\n     priv map: TreeMap<T, ()>\n }\n \n@@ -553,34 +558,40 @@ impl<T: TotalOrd> TreeSet<T> {\n \n /// Lazy forward iterator over a set\n pub struct TreeSetIterator<'self, T> {\n+    // all were already priv\n     priv iter: TreeMapIterator<'self, T, ()>\n }\n \n /// Lazy backward iterator over a set\n pub struct TreeSetRevIterator<'self, T> {\n+    // all were already priv\n     priv iter: TreeMapRevIterator<'self, T, ()>\n }\n \n /// Lazy iterator producing elements in the set difference (in-order)\n pub struct Difference<'self, T> {\n+    // all were already priv\n     priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n     priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set symmetric difference (in-order)\n pub struct SymDifference<'self, T> {\n+    // all were already priv\n     priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n     priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct Intersection<'self, T> {\n+    // all were already priv\n     priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n     priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct Union<'self, T> {\n+    // all were already priv\n     priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n     priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }"}, {"sha": "103d185aa1eac50f948596616ba7f94c82a554a5", "filename": "src/libextra/url.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -22,19 +22,21 @@ use std::uint;\n \n #[deriving(Clone, Eq)]\n pub struct Url {\n-    scheme: ~str,\n-    user: Option<UserInfo>,\n-    host: ~str,\n-    port: Option<~str>,\n-    path: ~str,\n-    query: Query,\n-    fragment: Option<~str>\n+    // all were made privv bt reedlepee\n+    priv scheme: ~str,\n+    priv user: Option<UserInfo>,\n+    priv host: ~str,\n+    priv port: Option<~str>,\n+    priv path: ~str,\n+    priv query: Query,\n+    priv fragment: Option<~str>\n }\n \n #[deriving(Clone, Eq)]\n pub struct UserInfo {\n-    user: ~str,\n-    pass: Option<~str>\n+    // all were made privv bt reedlepee\n+    priv user: ~str,\n+    priv pass: Option<~str>\n }\n \n pub type Query = ~[(~str, ~str)];"}, {"sha": "fa5c302faeec79b30a0d6ab6671de5cacb591e00", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -102,6 +102,7 @@ pub enum UuidVariant {\n /// A Universally Unique Identifier (UUID)\n pub struct Uuid {\n     /// The 128-bit number stored in 16 bytes\n+    /// should be public\n     bytes: UuidBytes\n }\n "}, {"sha": "f30fa3362c5117130a6feaa98e96a83fa5d15334", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -128,8 +128,9 @@ impl WorkMap {\n }\n \n pub struct Database {\n-    db_filename: Path,\n-    db_cache: TreeMap<~str, ~str>,\n+    /// all were made by reedlepee\n+    priv db_filename: Path,\n+    priv db_cache: TreeMap<~str, ~str>,\n     db_dirty: bool\n }\n \n@@ -209,7 +210,8 @@ impl Drop for Database {\n \n pub struct Logger {\n     // FIXME #4432: Fill in\n-    a: ()\n+    /// alll were made priv reeldepee\n+    priv a: ()\n }\n \n impl Logger {\n@@ -227,27 +229,30 @@ pub type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n \n #[deriving(Clone)]\n pub struct Context {\n+//// all were made priv by reedlepee\n     db: RWArc<Database>,\n-    logger: RWArc<Logger>,\n-    cfg: Arc<json::Object>,\n+    priv logger: RWArc<Logger>,\n+    priv cfg: Arc<json::Object>,\n     /// Map from kinds (source, exe, url, etc.) to a freshness function.\n     /// The freshness function takes a name (e.g. file path) and value\n     /// (e.g. hash of file contents) and determines whether it's up-to-date.\n     /// For example, in the file case, this would read the file off disk,\n     /// hash it, and return the result of comparing the given hash and the\n     /// read hash for equality.\n-    freshness: Arc<FreshnessMap>\n+    priv freshness: Arc<FreshnessMap>\n }\n \n pub struct Prep<'self> {\n-    ctxt: &'self Context,\n-    fn_name: &'self str,\n-    declared_inputs: WorkMap,\n+//// all were made priv by reedlepee\n+    priv ctxt: &'self Context,\n+    priv fn_name: &'self str,\n+    priv declared_inputs: WorkMap,\n }\n \n pub struct Exec {\n-    discovered_inputs: WorkMap,\n-    discovered_outputs: WorkMap\n+//// all were made priv by reedlepee\n+    priv discovered_inputs: WorkMap,\n+    priv discovered_outputs: WorkMap\n }\n \n enum Work<'self, T> {"}, {"sha": "2f1ac2c6b6b583782f92bc4aa100d96b06ace88d", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -92,6 +92,7 @@ condition! {\n /// This structure wraps a `*libc::c_char`, and will automatically free the\n /// memory it is pointing to when it goes out of scope.\n pub struct CString {\n+    // already priv\n     priv buf: *libc::c_char,\n     priv owns_buffer_: bool,\n }\n@@ -332,6 +333,7 @@ fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n ///\n /// Use with the `std::iterator` module.\n pub struct CStringIterator<'self> {\n+    // already priv\n     priv ptr: *libc::c_char,\n     priv lifetime: &'self libc::c_char, // FIXME: #5922\n }"}, {"sha": "e1ba46e8f27505c24b351233fc2010cc5bbf03b7", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -26,6 +26,7 @@ Similar to a mutable option type, but friendlier.\n #[deriving(Clone, DeepClone, Eq)]\n #[allow(missing_doc)]\n pub struct Cell<T> {\n+    // already priv\n     priv value: Option<T>\n }\n "}, {"sha": "346e8a51322a14858d60db3fca5a30812ebba07c", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -72,6 +72,7 @@ use unstable::raw::Closure;\n \n #[doc(hidden)]\n pub struct Handler<T, U> {\n+    //already priv\n     priv handle: Closure,\n     priv prev: Option<@Handler<T, U>>,\n }\n@@ -83,6 +84,7 @@ pub struct Handler<T, U> {\n /// This struct should never be created directly, but rather only through the\n /// `condition!` macro provided to all libraries using libstd.\n pub struct Condition<T, U> {\n+    // all made priv by reedlepee\n     /// Name of the condition handler\n     name: &'static str,\n     /// TLS key used to insert/remove values in TLS."}, {"sha": "b47559b6055f5b50722ecfd38c6bf18ae1aa9960", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -477,20 +477,22 @@ pub mod rt;\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n pub struct Formatter<'self> {\n+    // made by reedlepee\n     /// Flags for formatting (packed version of rt::Flag)\n-    flags: uint,\n+     flags: uint,\n     /// Character used as 'fill' whenever there is alignment\n     fill: char,\n     /// Boolean indication of whether the output should be left-aligned\n     align: parse::Alignment,\n     /// Optionally specified integer width that the output should be\n     width: Option<uint>,\n     /// Optionally specified precision for numeric types\n-    precision: Option<uint>,\n+     precision: Option<uint>,\n \n     /// Output buffer.\n     buf: &'self mut io::Writer,\n \n+    // already priv\n     priv curarg: vec::VecIterator<'self, Argument<'self>>,\n     priv args: &'self [Argument<'self>],\n }\n@@ -500,6 +502,7 @@ pub struct Formatter<'self> {\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n pub struct Argument<'self> {\n+    // already priv\n     priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter),\n     priv value: &'self util::Void,\n }\n@@ -526,6 +529,7 @@ impl<'self> Arguments<'self> {\n /// string at compile-time so usage of the `write` and `format` functions can\n /// be safely performed.\n pub struct Arguments<'self> {\n+    // already priv\n     priv fmt: &'self [rt::Piece<'self>],\n     priv args: &'self [Argument<'self>],\n }"}, {"sha": "fea512c08b4a52c2fef05da73dfb233ac9cc2fbe", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -38,17 +38,20 @@ pub enum Piece<'self> {\n /// Representation of an argument specification.\n #[deriving(Eq)]\n pub struct Argument<'self> {\n+    // made by reedlepee\n     /// Where to find this argument\n     position: Position<'self>,\n-    /// How to format the argument\n+    ///  How to format the argument\n     format: FormatSpec<'self>,\n     /// If not `None`, what method to invoke on the argument\n+    // should be public\n     method: Option<~Method<'self>>\n }\n \n /// Specification for the formatting of an argument in the format string.\n #[deriving(Eq)]\n pub struct FormatSpec<'self> {\n+    // made by reedlepee\n     /// Optionally specified character to fill alignment with\n     fill: Option<char>,\n     /// Optionally specified alignment\n@@ -125,6 +128,7 @@ pub enum Method<'self> {\n /// Structure representing one \"arm\" of the `plural` function.\n #[deriving(Eq)]\n pub struct PluralArm<'self> {\n+    // made by reedlepee\n     /// A selector can either be specified by a keyword or with an integer\n     /// literal.\n     selector: Either<PluralKeyword, uint>,\n@@ -145,6 +149,7 @@ pub enum PluralKeyword {\n /// Structure representing one \"arm\" of the `select` function.\n #[deriving(Eq)]\n pub struct SelectArm<'self> {\n+    // made by reedlepee\n     /// String selector which guards this arm\n     selector: &'self str,\n     /// Array of pieces which are the format of this arm\n@@ -158,6 +163,7 @@ pub struct SelectArm<'self> {\n /// This is a recursive-descent parser for the sake of simplicity, and if\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'self> {\n+    // already priv\n     priv input: &'self str,\n     priv cur: str::CharOffsetIterator<'self>,\n     priv depth: uint,"}, {"sha": "a623695c8a1b515c96a1ac574a18db3755c82d77", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -29,16 +29,18 @@ pub enum Piece<'self> {\n }\n \n pub struct Argument<'self> {\n+    /// should be public\n     position: Position,\n     format: FormatSpec,\n     method: Option<&'self Method<'self>>\n }\n \n pub struct FormatSpec {\n+    /// made by redlepee\n     fill: char,\n     align: parse::Alignment,\n     flags: uint,\n-    precision: Count,\n+     precision: Count,\n     width: Count,\n }\n \n@@ -56,11 +58,13 @@ pub enum Method<'self> {\n }\n \n pub struct PluralArm<'self> {\n+    /// made by redlepee\n     selector: Either<parse::PluralKeyword, uint>,\n     result: &'self [Piece<'self>],\n }\n \n pub struct SelectArm<'self> {\n+    /// made by redlepee\n     selector: &'self str,\n     result: &'self [Piece<'self>],\n }"}, {"sha": "ec792510271a5da89ece8fe1e3352c89b7151149", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -48,6 +48,7 @@ struct Bucket<K,V> {\n /// `IterBytes` traits as `Hash` is automatically implemented for types that\n /// implement `IterBytes`.\n pub struct HashMap<K,V> {\n+    // already priv\n     priv k0: u64,\n     priv k1: u64,\n     priv resize_at: uint,\n@@ -517,27 +518,32 @@ impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n /// HashMap iterator\n #[deriving(Clone)]\n pub struct HashMapIterator<'self, K, V> {\n+    // already priv\n     priv iter: vec::VecIterator<'self, Option<Bucket<K, V>>>,\n }\n \n /// HashMap mutable values iterator\n pub struct HashMapMutIterator<'self, K, V> {\n+    // already priv\n     priv iter: vec::VecMutIterator<'self, Option<Bucket<K, V>>>,\n }\n \n /// HashMap move iterator\n pub struct HashMapMoveIterator<K, V> {\n+    // already priv\n     priv iter: vec::MoveRevIterator<Option<Bucket<K, V>>>,\n }\n \n /// HashSet iterator\n #[deriving(Clone)]\n pub struct HashSetIterator<'self, K> {\n+    // already priv\n     priv iter: vec::VecIterator<'self, Option<Bucket<K, ()>>>,\n }\n \n /// HashSet move iterator\n pub struct HashSetMoveIterator<K> {\n+    // already priv\n     priv iter: vec::MoveRevIterator<Option<Bucket<K, ()>>>,\n }\n \n@@ -631,6 +637,7 @@ impl<K: Eq + Hash, V> Default for HashMap<K, V> {\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n /// requires that the elements implement the `Eq` and `Hash` traits.\n pub struct HashSet<T> {\n+    // already priv\n     priv map: HashMap<T, ()>\n }\n "}, {"sha": "297ba84fbf9fb356857bd9b5a76201d1416660ad", "filename": "src/libstd/io.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -1009,7 +1009,8 @@ impl<R:Reader,C> Reader for Wrapper<R, C> {\n }\n \n pub struct FILERes {\n-    f: *libc::FILE,\n+    // all by reedlepee\n+    priv f: *libc::FILE,\n }\n \n impl FILERes {\n@@ -1080,6 +1081,7 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n \n // Byte readers\n pub struct BytesReader {\n+    // all by reedlepee\n     // FIXME(#5723) see other FIXME below\n     // FIXME(#7268) this should also be parameterized over <'self>\n     bytes: &'static [u8],\n@@ -1282,7 +1284,8 @@ impl Writer for fd_t {\n }\n \n pub struct FdRes {\n-    fd: fd_t,\n+    // all by reedlepee\n+    priv fd: fd_t,\n }\n \n impl FdRes {\n@@ -1674,6 +1677,7 @@ pub fn println(s: &str) {\n }\n \n pub struct BytesWriter {\n+    // all by reedlepee\n     bytes: @mut ~[u8],\n     pos: @mut uint,\n }\n@@ -1792,7 +1796,8 @@ pub mod fsync {\n \n     // Artifacts that need to fsync on destruction\n     pub struct Res<t> {\n-        arg: Arg<t>,\n+        // all by reedlepee\n+        priv arg: Arg<t>,\n     }\n \n     impl <t> Res<t> {\n@@ -1815,9 +1820,10 @@ pub mod fsync {\n     }\n \n     pub struct Arg<t> {\n-        val: t,\n-        opt_level: Option<Level>,\n-        fsync_fn: extern \"Rust\" fn(f: &t, Level) -> int,\n+       // all by reedlepee\n+       priv val: t,\n+       priv opt_level: Option<Level>,\n+       priv fsync_fn: extern \"Rust\" fn(f: &t, Level) -> int,\n     }\n \n     // fsync file after executing blk"}, {"sha": "4985557dff7879db2f6d4a09abc846a46fa774b6", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -765,6 +765,8 @@ impl<A, B, T: ExactSize<A>, U: ExactSize<B>> ExactSize<(A, B)> for Zip<T, U> {}\n /// An double-ended iterator with the direction inverted\n #[deriving(Clone)]\n pub struct Invert<T> {\n+    // already priv\n+    // already priv\n     priv iter: T\n }\n \n@@ -792,6 +794,7 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n \n /// A mutable reference to an iterator\n pub struct ByRef<'self, T> {\n+    // already priv\n     priv iter: &'self mut T\n }\n \n@@ -927,6 +930,7 @@ impl<A, T: Clone + Iterator<A>> ClonableIterator for T {\n /// An iterator that repeats endlessly\n #[deriving(Clone)]\n pub struct Cycle<T> {\n+    // already priv\n     priv orig: T,\n     priv iter: T,\n }\n@@ -978,6 +982,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n /// An iterator which strings two iterators together\n #[deriving(Clone)]\n pub struct Chain<T, U> {\n+    // already priv\n     priv a: T,\n     priv b: U,\n     priv flag: bool\n@@ -1047,6 +1052,7 @@ for Chain<T, U> {\n /// An iterator which iterates two other iterators simultaneously\n #[deriving(Clone)]\n pub struct Zip<T, U> {\n+    // already priv\n     priv a: T,\n     priv b: U\n }\n@@ -1125,6 +1131,7 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n \n /// An iterator which maps the values of `iter` with `f`\n pub struct Map<'self, A, B, T> {\n+    // already priv\n     priv iter: T,\n     priv f: &'self fn(A) -> B\n }\n@@ -1174,6 +1181,7 @@ impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'s\n \n /// An iterator which filters the elements of `iter` with `predicate`\n pub struct Filter<'self, A, T> {\n+    // already priv\n     priv iter: T,\n     priv predicate: &'self fn(&A) -> bool\n }\n@@ -1218,6 +1226,7 @@ impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'sel\n \n /// An iterator which uses `f` to both filter and map elements from `iter`\n pub struct FilterMap<'self, A, B, T> {\n+    // already priv\n     priv iter: T,\n     priv f: &'self fn(A) -> Option<B>\n }\n@@ -1262,6 +1271,7 @@ for FilterMap<'self, A, B, T> {\n /// An iterator which yields the current count and the element during iteration\n #[deriving(Clone)]\n pub struct Enumerate<T> {\n+    // already priv\n     priv iter: T,\n     priv count: uint\n }\n@@ -1316,6 +1326,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n pub struct Peekable<A, T> {\n+    // already priv\n     priv iter: T,\n     priv peeked: Option<A>,\n }\n@@ -1360,6 +1371,7 @@ impl<'self, A, T: Iterator<A>> Peekable<A, T> {\n \n /// An iterator which rejects elements while `predicate` is true\n pub struct SkipWhile<'self, A, T> {\n+    // already priv\n     priv iter: T,\n     priv flag: bool,\n     priv predicate: &'self fn(&A) -> bool\n@@ -1398,6 +1410,7 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhile<'self, A, T> {\n \n /// An iterator which only accepts elements while `predicate` is true\n pub struct TakeWhile<'self, A, T> {\n+    // already priv\n     priv iter: T,\n     priv flag: bool,\n     priv predicate: &'self fn(&A) -> bool\n@@ -1433,6 +1446,7 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhile<'self, A, T> {\n /// An iterator which skips over `n` elements of `iter`.\n #[deriving(Clone)]\n pub struct Skip<T> {\n+    // already priv\n     priv iter: T,\n     priv n: uint\n }\n@@ -1497,6 +1511,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n /// An iterator which only iterates over the first `n` iterations of `iter`.\n #[deriving(Clone)]\n pub struct Take<T> {\n+    // already priv\n     priv iter: T,\n     priv n: uint\n }\n@@ -1546,11 +1561,13 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n \n /// An iterator to maintain state while iterating another iterator\n pub struct Scan<'self, A, B, T, St> {\n+    // already priv\n     priv iter: T,\n     priv f: &'self fn(&mut St, A) -> Option<B>,\n \n     /// The current internal state to be passed to the closure next.\n-    state: St\n+    // priv by reedlepee\n+    priv state: St\n }\n \n impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n@@ -1570,6 +1587,7 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n /// and yields the elements of the produced iterators\n ///\n pub struct FlatMap<'self, A, T, U> {\n+    // already priv\n     priv iter: T,\n     priv f: &'self fn(A) -> U,\n     priv frontiter: Option<U>,\n@@ -1629,6 +1647,7 @@ impl<'self,\n /// yields `None` once.\n #[deriving(Clone, DeepClone)]\n pub struct Fuse<T> {\n+    // already priv\n     priv iter: T,\n     priv done: bool\n }\n@@ -1701,6 +1720,7 @@ impl<T> Fuse<T> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n pub struct Inspect<'self, A, T> {\n+    // already priv\n     priv iter: T,\n     priv f: &'self fn(&A)\n }\n@@ -1754,8 +1774,10 @@ for Inspect<'self, A, T> {\n \n /// An iterator which just modifies the contained state throughout iteration.\n pub struct Unfold<'self, A, St> {\n+    // already priv\n     priv f: &'self fn(&mut St) -> Option<A>,\n     /// Internal state that will be yielded on the next iteration\n+    /// priv reedlepee\n     state: St\n }\n \n@@ -1789,10 +1811,11 @@ impl<'self, A, St> Iterator<A> for Unfold<'self, A, St> {\n /// iteration\n #[deriving(Clone)]\n pub struct Counter<A> {\n+    // by reedlepee\n     /// The current state the counter is at (next value to be yielded)\n-    state: A,\n+    priv state: A,\n     /// The amount that this iterator is stepping by\n-    step: A\n+    priv step: A\n }\n \n /// Creates a new counter with the specified start/step\n@@ -1818,6 +1841,7 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n /// An iterator over the range [start, stop)\n #[deriving(Clone, DeepClone)]\n pub struct Range<A> {\n+    // already priv\n     priv state: A,\n     priv stop: A,\n     priv one: A\n@@ -1862,6 +1886,7 @@ impl<A: Integer + Ord + Clone> DoubleEndedIterator<A> for Range<A> {\n /// An iterator over the range [start, stop]\n #[deriving(Clone, DeepClone)]\n pub struct RangeInclusive<A> {\n+    // already priv\n     priv range: Range<A>,\n     priv done: bool\n }\n@@ -1923,6 +1948,7 @@ impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for RangeInclu\n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[deriving(Clone, DeepClone)]\n pub struct RangeStep<A> {\n+    // already priv\n     priv state: A,\n     priv stop: A,\n     priv step: A,\n@@ -1955,6 +1981,7 @@ impl<A: CheckedAdd + Ord + Clone> Iterator<A> for RangeStep<A> {\n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[deriving(Clone, DeepClone)]\n pub struct RangeStepInclusive<A> {\n+    // already priv\n     priv state: A,\n     priv stop: A,\n     priv step: A,\n@@ -1990,6 +2017,7 @@ impl<A: CheckedAdd + Ord + Clone + Eq> Iterator<A> for RangeStepInclusive<A> {\n /// An iterator that repeats an element endlessly\n #[deriving(Clone, DeepClone)]\n pub struct Repeat<A> {\n+    // already priv\n     priv element: A\n }\n "}, {"sha": "67d64596460f4613e9c9fd7b4959fb8101676b45", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 197, "deletions": 179, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -226,15 +226,16 @@ pub mod types {\n                 use libc::types::common::c95::{c_void};\n                 use libc::types::os::arch::c95::{c_char, size_t};\n                 pub struct glob_t {\n-                    gl_pathc: size_t,\n-                    gl_pathv: **c_char,\n-                    gl_offs:  size_t,\n-\n-                    __unused1: *c_void,\n-                    __unused2: *c_void,\n-                    __unused3: *c_void,\n-                    __unused4: *c_void,\n-                    __unused5: *c_void,\n+                    // all made by reedlepee\n+                    priv gl_pathc: size_t,\n+                    priv gl_pathv: **c_char,\n+                    priv gl_offs:  size_t,\n+\n+                    priv __unused1: *c_void,\n+                    priv __unused2: *c_void,\n+                    priv __unused3: *c_void,\n+                     __unused4: *c_void,\n+                     __unused5: *c_void,\n                 }\n             }\n         }\n@@ -304,15 +305,16 @@ pub mod types {\n                 pub type blkcnt_t = i32;\n \n                 pub struct stat {\n+                    // all made by reedlepee\n                     st_dev: dev_t,\n-                    __pad1: c_short,\n+                     __pad1: c_short,\n                     st_ino: ino_t,\n                     st_mode: mode_t,\n                     st_nlink: nlink_t,\n-                    st_uid: uid_t,\n+                     st_uid: uid_t,\n                     st_gid: gid_t,\n-                    st_rdev: dev_t,\n-                    __pad2: c_short,\n+                     st_rdev: dev_t,\n+                     __pad2: c_short,\n                     st_size: off_t,\n                     st_blksize: blksize_t,\n                     st_blocks: blkcnt_t,\n@@ -323,7 +325,7 @@ pub mod types {\n                     st_ctime: time_t,\n                     st_ctime_nsec: c_long,\n                     __unused4: c_long,\n-                    __unused5: c_long,\n+                     __unused5: c_long,\n                 }\n             }\n             #[cfg(target_arch = \"arm\")]\n@@ -337,24 +339,25 @@ pub mod types {\n                 pub type blkcnt_t = u32;\n \n                 pub struct stat {\n+                    // all made priv by reedlepee\n                     st_dev: c_ulonglong,\n-                    __pad0: [c_uchar, ..4],\n-                    __st_ino: ino_t,\n+                    priv __pad0: [c_uchar, ..4],\n+                    priv __st_ino: ino_t,\n                     st_mode: c_uint,\n                     st_nlink: c_uint,\n-                    st_uid: uid_t,\n-                    st_gid: gid_t,\n-                    st_rdev: c_ulonglong,\n-                    __pad3: [c_uchar, ..4],\n+                     st_uid: uid_t,\n+                     st_gid: gid_t,\n+                     st_rdev: c_ulonglong,\n+                    priv __pad3: [c_uchar, ..4],\n                     st_size: c_longlong,\n                     st_blksize: blksize_t,\n                     st_blocks: c_ulonglong,\n                     st_atime: time_t,\n                     st_atime_nsec: c_ulong,\n                     st_mtime: time_t,\n                     st_mtime_nsec: c_ulong,\n-                    st_ctime: time_t,\n-                    st_ctime_nsec: c_ulong,\n+                     st_ctime: time_t,\n+                     st_ctime_nsec: c_ulong,\n                     st_ino: c_ulonglong\n                 }\n             }\n@@ -370,17 +373,18 @@ pub mod types {\n                 pub type blkcnt_t = i32;\n \n                 pub struct stat {\n+                    /// all made priv by reedlepee\n                     st_dev: c_ulong,\n-                    st_pad1: [c_long, ..3],\n+                    priv st_pad1: [c_long, ..3],\n                     st_ino: ino_t,\n                     st_mode: mode_t,\n                     st_nlink: nlink_t,\n                     st_uid: uid_t,\n                     st_gid: gid_t,\n                     st_rdev: c_ulong,\n-                    st_pad2: [c_long, ..2],\n+                    priv st_pad2: [c_long, ..2],\n                     st_size: off_t,\n-                    st_pad3: c_long,\n+                    priv st_pad3: c_long,\n                     st_atime: time_t,\n                     st_atime_nsec: c_long,\n                     st_mtime: time_t,\n@@ -389,7 +393,7 @@ pub mod types {\n                     st_ctime_nsec: c_long,\n                     st_blksize: blksize_t,\n                     st_blocks: blkcnt_t,\n-                    st_pad5: [c_long, ..14],\n+                    priv st_pad5: [c_long, ..14],\n                 }\n             }\n             pub mod posix08 {}\n@@ -444,24 +448,25 @@ pub mod types {\n                 pub type blksize_t = i64;\n                 pub type blkcnt_t = i64;\n                 pub struct stat {\n+                    // all made by reedlepee\n                     st_dev: dev_t,\n                     st_ino: ino_t,\n                     st_nlink: nlink_t,\n                     st_mode: mode_t,\n                     st_uid: uid_t,\n                     st_gid: gid_t,\n-                    __pad0: c_int,\n-                    st_rdev: dev_t,\n+                    priv __pad0: c_int,\n+                     st_rdev: dev_t,\n                     st_size: off_t,\n                     st_blksize: blksize_t,\n                     st_blocks: blkcnt_t,\n-                    st_atime: time_t,\n+                     st_atime: time_t,\n                     st_atime_nsec: c_long,\n                     st_mtime: time_t,\n                     st_mtime_nsec: c_long,\n                     st_ctime: time_t,\n                     st_ctime_nsec: c_long,\n-                    __unused: [c_long, ..3],\n+                    priv __unused: [c_long, ..3],\n                 }\n             }\n             pub mod posix08 {\n@@ -480,19 +485,20 @@ pub mod types {\n                 use libc::types::common::c95::{c_void};\n                 use libc::types::os::arch::c95::{c_char, c_int, size_t};\n                 pub struct glob_t {\n-                    gl_pathc:  size_t,\n-                    __unused1: size_t,\n-                    gl_offs:   size_t,\n-                    __unused2: c_int,\n-                    gl_pathv:  **c_char,\n-\n-                    __unused3: *c_void,\n-\n-                    __unused4: *c_void,\n-                    __unused5: *c_void,\n-                    __unused6: *c_void,\n-                    __unused7: *c_void,\n-                    __unused8: *c_void,\n+                    // all made priv by reedlepee\n+                    priv gl_pathc:  size_t,\n+                    priv __unused1: size_t,\n+                    priv gl_offs:   size_t,\n+                    priv __unused2: c_int,\n+                    priv gl_pathv:  **c_char,\n+\n+                    priv __unused3: *c_void,\n+\n+                     __unused4: *c_void,\n+                     __unused5: *c_void,\n+                    priv __unused6: *c_void,\n+                    priv __unused7: *c_void,\n+                    priv __unused8: *c_void,\n                 }\n             }\n         }\n@@ -546,13 +552,14 @@ pub mod types {\n                 pub type blkcnt_t = i64;\n                 pub type fflags_t = u32;\n                 pub struct stat {\n+                    // all made by reedlepee\n                     st_dev: dev_t,\n                     st_ino: ino_t,\n                     st_mode: mode_t,\n                     st_nlink: nlink_t,\n-                    st_uid: uid_t,\n-                    st_gid: gid_t,\n-                    st_rdev: dev_t,\n+                     st_uid: uid_t,\n+                     st_gid: gid_t,\n+                     st_rdev: dev_t,\n                     st_atime: time_t,\n                     st_atime_nsec: c_long,\n                     st_mtime: time_t,\n@@ -562,12 +569,12 @@ pub mod types {\n                     st_size: off_t,\n                     st_blocks: blkcnt_t,\n                     st_blksize: blksize_t,\n-                    st_flags: fflags_t,\n-                    st_gen: uint32_t,\n-                    st_lspare: int32_t,\n-                    st_birthtime: time_t,\n-                    st_birthtime_nsec: c_long,\n-                    __unused: [uint8_t, ..2],\n+                    priv st_flags: fflags_t,\n+                    priv st_gen: uint32_t,\n+                    priv st_lspare: int32_t,\n+                    priv st_birthtime: time_t,\n+                    priv st_birthtime_nsec: c_long,\n+                    priv __unused: [uint8_t, ..2],\n                 }\n             }\n             pub mod posix08 {\n@@ -591,13 +598,14 @@ pub mod types {\n                 // Note: this is the struct called stat64 in win32. Not stat,\n                 // nor stati64.\n                 pub struct stat {\n+                    // all made privv by reedlepee\n                     st_dev: dev_t,\n                     st_ino: ino_t,\n                     st_mode: mode_t,\n                     st_nlink: c_short,\n-                    st_uid: c_short,\n+                     st_uid: c_short,\n                     st_gid: c_short,\n-                    st_rdev: dev_t,\n+                     st_rdev: dev_t,\n                     st_size: int64,\n                     st_atime: time64_t,\n                     st_mtime: time64_t,\n@@ -697,47 +705,49 @@ pub mod types {\n                 pub type int64 = i64;\n \n                 pub struct STARTUPINFO {\n-                    cb: DWORD,\n-                    lpReserved: LPTSTR,\n-                    lpDesktop: LPTSTR,\n-                    lpTitle: LPTSTR,\n-                    dwX: DWORD,\n-                    dwY: DWORD,\n-                    dwXSize: DWORD,\n-                    dwYSize: DWORD,\n-                    dwXCountChars: DWORD,\n-                    dwYCountCharts: DWORD,\n-                    dwFillAttribute: DWORD,\n-                    dwFlags: DWORD,\n-                    wShowWindow: WORD,\n-                    cbReserved2: WORD,\n-                    lpReserved2: LPBYTE,\n-                    hStdInput: HANDLE,\n-                    hStdOutput: HANDLE,\n-                    hStdError: HANDLE\n+                    // all made by reedlepee\n+                    priv cb: DWORD,\n+                    priv lpReserved: LPTSTR,\n+                    priv lpDesktop: LPTSTR,\n+                    priv lpTitle: LPTSTR,\n+                    priv dwX: DWORD,\n+                    priv dwY: DWORD,\n+                    priv dwXSize: DWORD,\n+                    priv dwYSize: DWORD,\n+                    priv dwXCountChars: DWORD,\n+                    priv dwYCountCharts: DWORD,\n+                    priv dwFillAttribute: DWORD,\n+                    priv dwFlags: DWORD,\n+                    priv wShowWindow: WORD,\n+                    priv cbReserved2: WORD,\n+                    priv lpReserved2: LPBYTE,\n+                    priv hStdInput: HANDLE,\n+                    priv hStdOutput: HANDLE,\n+                    priv hStdError: HANDLE\n                 }\n                 pub type LPSTARTUPINFO = *mut STARTUPINFO;\n-\n                 pub struct PROCESS_INFORMATION {\n-                    hProcess: HANDLE,\n-                    hThread: HANDLE,\n-                    dwProcessId: DWORD,\n-                    dwThreadId: DWORD\n+                    // all made by reedlepee\n+                    priv hProcess: HANDLE,\n+                    priv hThread: HANDLE,\n+                    priv dwProcessId: DWORD,\n+                    priv dwThreadId: DWORD\n                 }\n                 pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n \n                 pub struct SYSTEM_INFO {\n-                    wProcessorArchitecture: WORD,\n-                    wReserved: WORD,\n-                    dwPageSize: DWORD,\n-                    lpMinimumApplicationAddress: LPVOID,\n-                    lpMaximumApplicationAddress: LPVOID,\n-                    dwActiveProcessorMask: DWORD,\n-                    dwNumberOfProcessors: DWORD,\n-                    dwProcessorType: DWORD,\n-                    dwAllocationGranularity: DWORD,\n-                    wProcessorLevel: WORD,\n-                    wProcessorRevision: WORD\n+                    // all made by reedlepee\n+                    priv wProcessorArchitecture: WORD,\n+                    priv wReserved: WORD,\n+                    priv dwPageSize: DWORD,\n+                    priv lpMinimumApplicationAddress: LPVOID,\n+                    priv lpMaximumApplicationAddress: LPVOID,\n+                    priv dwActiveProcessorMask: DWORD,\n+                    priv dwNumberOfProcessors: DWORD,\n+                    priv dwProcessorType: DWORD,\n+                    priv dwAllocationGranularity: DWORD,\n+                    priv wProcessorLevel: WORD,\n+                    priv wProcessorRevision: WORD\n                 }\n                 pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n \n@@ -760,13 +770,14 @@ pub mod types {\n                 }\n \n                 pub struct MEMORY_BASIC_INFORMATION {\n-                    BaseAddress: LPVOID,\n-                    AllocationBase: LPVOID,\n-                    AllocationProtect: DWORD,\n-                    RegionSize: SIZE_T,\n-                    State: DWORD,\n-                    Protect: DWORD,\n-                    Type: DWORD\n+                    // all made by reedlepee\n+                    priv BaseAddress: LPVOID,\n+                    priv AllocationBase: LPVOID,\n+                    priv AllocationProtect: DWORD,\n+                    priv RegionSize: SIZE_T,\n+                    priv State: DWORD,\n+                    priv Protect: DWORD,\n+                    priv Type: DWORD\n                 }\n                 pub type LPMEMORY_BASIC_INFORMATION = *mut MEMORY_BASIC_INFORMATION;\n             }\n@@ -863,47 +874,50 @@ pub mod types {\n                 pub type int64 = i64;\n \n                 pub struct STARTUPINFO {\n-                    cb: DWORD,\n-                    lpReserved: LPTSTR,\n-                    lpDesktop: LPTSTR,\n-                    lpTitle: LPTSTR,\n-                    dwX: DWORD,\n-                    dwY: DWORD,\n-                    dwXSize: DWORD,\n-                    dwYSize: DWORD,\n-                    dwXCountChars: DWORD,\n-                    dwYCountCharts: DWORD,\n-                    dwFillAttribute: DWORD,\n-                    dwFlags: DWORD,\n-                    wShowWindow: WORD,\n-                    cbReserved2: WORD,\n-                    lpReserved2: LPBYTE,\n-                    hStdInput: HANDLE,\n-                    hStdOutput: HANDLE,\n-                    hStdError: HANDLE\n+                     // all made by reedlepee\n+                     priv cb: DWORD,\n+                     priv lpReserved: LPTSTR,\n+                     priv lpDesktop: LPTSTR,\n+                     priv lpTitle: LPTSTR,\n+                     priv dwX: DWORD,\n+                     priv dwY: DWORD,\n+                     priv dwXSize: DWORD,\n+                     priv dwYSize: DWORD,\n+                     priv dwXCountChars: DWORD,\n+                     priv dwYCountCharts: DWORD,\n+                     priv dwFillAttribute: DWORD,\n+                     priv dwFlags: DWORD,\n+                     priv wShowWindow: WORD,\n+                     priv cbReserved2: WORD,\n+                     priv lpReserved2: LPBYTE,\n+                     priv hStdInput: HANDLE,\n+                     priv hStdOutput: HANDLE,\n+                     priv hStdError: HANDLE\n                 }\n                 pub type LPSTARTUPINFO = *mut STARTUPINFO;\n \n                 pub struct PROCESS_INFORMATION {\n-                    hProcess: HANDLE,\n-                    hThread: HANDLE,\n-                    dwProcessId: DWORD,\n-                    dwThreadId: DWORD\n+                    // all made by reedlepee\n+                    priv hProcess: HANDLE,\n+                    priv hThread: HANDLE,\n+                    priv dwProcessId: DWORD,\n+                    priv dwThreadId: DWORD\n                 }\n                 pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n \n                 pub struct SYSTEM_INFO {\n-                    wProcessorArchitecture: WORD,\n-                    wReserved: WORD,\n-                    dwPageSize: DWORD,\n-                    lpMinimumApplicationAddress: LPVOID,\n-                    lpMaximumApplicationAddress: LPVOID,\n-                    dwActiveProcessorMask: DWORD,\n-                    dwNumberOfProcessors: DWORD,\n-                    dwProcessorType: DWORD,\n-                    dwAllocationGranularity: DWORD,\n-                    wProcessorLevel: WORD,\n-                    wProcessorRevision: WORD\n+                     // all made by reedlepee\n+                     priv wProcessorArchitecture: WORD,\n+                     priv wReserved: WORD,\n+                     priv dwPageSize: DWORD,\n+                     priv lpMinimumApplicationAddress: LPVOID,\n+                     priv lpMaximumApplicationAddress: LPVOID,\n+                     priv dwActiveProcessorMask: DWORD,\n+                     priv dwNumberOfProcessors: DWORD,\n+                     priv dwProcessorType: DWORD,\n+                     priv dwAllocationGranularity: DWORD,\n+                     priv wProcessorLevel: WORD,\n+                     priv wProcessorRevision: WORD\n                 }\n                 pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n \n@@ -926,13 +940,14 @@ pub mod types {\n                 }\n \n                 pub struct MEMORY_BASIC_INFORMATION {\n-                    BaseAddress: LPVOID,\n-                    AllocationBase: LPVOID,\n-                    AllocationProtect: DWORD,\n-                    RegionSize: SIZE_T,\n-                    State: DWORD,\n-                    Protect: DWORD,\n-                    Type: DWORD\n+                     // all made by reedlepee\n+                     priv BaseAddress: LPVOID,\n+                     priv AllocationBase: LPVOID,\n+                     priv AllocationProtect: DWORD,\n+                     priv RegionSize: SIZE_T,\n+                     priv State: DWORD,\n+                     priv Protect: DWORD,\n+                     priv Type: DWORD\n                 }\n                 pub type LPMEMORY_BASIC_INFORMATION = *mut MEMORY_BASIC_INFORMATION;\n             }\n@@ -946,19 +961,20 @@ pub mod types {\n                 use libc::types::common::c95::{c_void};\n                 use libc::types::os::arch::c95::{c_char, c_int, size_t};\n                 pub struct glob_t {\n-                    gl_pathc:  size_t,\n-                    __unused1: c_int,\n-                    gl_offs:   size_t,\n-                    __unused2: c_int,\n-                    gl_pathv:  **c_char,\n-\n-                    __unused3: *c_void,\n-\n-                    __unused4: *c_void,\n-                    __unused5: *c_void,\n-                    __unused6: *c_void,\n-                    __unused7: *c_void,\n-                    __unused8: *c_void,\n+                    // all made by reedlepee\n+                    priv gl_pathc:  size_t,\n+                    priv __unused1: c_int,\n+                    priv gl_offs:   size_t,\n+                    priv __unused2: c_int,\n+                    priv gl_pathv:  **c_char,\n+\n+                    priv __unused3: *c_void,\n+\n+                     __unused4: *c_void,\n+                     __unused5: *c_void,\n+                    priv __unused6: *c_void,\n+                    priv __unused7: *c_void,\n+                    priv __unused8: *c_void,\n                 }\n             }\n         }\n@@ -1011,28 +1027,29 @@ pub mod types {\n                 pub type blkcnt_t = i32;\n \n                 pub struct stat {\n+                    // all made by reedlepee\n                     st_dev: dev_t,\n                     st_mode: mode_t,\n                     st_nlink: nlink_t,\n                     st_ino: ino_t,\n-                    st_uid: uid_t,\n-                    st_gid: gid_t,\n-                    st_rdev: dev_t,\n+                     st_uid: uid_t,\n+                     st_gid: gid_t,\n+                     st_rdev: dev_t,\n                     st_atime: time_t,\n                     st_atime_nsec: c_long,\n                     st_mtime: time_t,\n                     st_mtime_nsec: c_long,\n                     st_ctime: time_t,\n                     st_ctime_nsec: c_long,\n-                    st_birthtime: time_t,\n-                    st_birthtime_nsec: c_long,\n+                    priv st_birthtime: time_t,\n+                    priv st_birthtime_nsec: c_long,\n                     st_size: off_t,\n                     st_blocks: blkcnt_t,\n                     st_blksize: blksize_t,\n-                    st_flags: uint32_t,\n-                    st_gen: uint32_t,\n-                    st_lspare: int32_t,\n-                    st_qspare: [int64_t, ..2],\n+                    priv st_flags: uint32_t,\n+                    priv st_gen: uint32_t,\n+                    priv st_lspare: int32_t,\n+                    priv st_qspare: [int64_t, ..2],\n                 }\n             }\n             pub mod posix08 {\n@@ -1092,28 +1109,29 @@ pub mod types {\n                 pub type blkcnt_t = i32;\n \n                 pub struct stat {\n-                    st_dev: dev_t,\n-                    st_mode: mode_t,\n-                    st_nlink: nlink_t,\n-                    st_ino: ino_t,\n-                    st_uid: uid_t,\n-                    st_gid: gid_t,\n-                    st_rdev: dev_t,\n-                    st_atime: time_t,\n-                    st_atime_nsec: c_long,\n-                    st_mtime: time_t,\n-                    st_mtime_nsec: c_long,\n-                    st_ctime: time_t,\n-                    st_ctime_nsec: c_long,\n-                    st_birthtime: time_t,\n-                    st_birthtime_nsec: c_long,\n-                    st_size: off_t,\n-                    st_blocks: blkcnt_t,\n-                    st_blksize: blksize_t,\n-                    st_flags: uint32_t,\n-                    st_gen: uint32_t,\n-                    st_lspare: int32_t,\n-                    st_qspare: [int64_t, ..2],\n+                     // all made by reedlepee\n+                     st_dev: dev_t,\n+                     st_mode: mode_t,\n+                     st_nlink: nlink_t,\n+                     st_ino: ino_t,\n+                     st_uid: uid_t,\n+                     st_gid: gid_t,\n+                     st_rdev: dev_t,\n+                     st_atime: time_t,\n+                     st_atime_nsec: c_long,\n+                     st_mtime: time_t,\n+                     st_mtime_nsec: c_long,\n+                     st_ctime: time_t,\n+                     st_ctime_nsec: c_long,\n+                     priv st_birthtime: time_t,\n+                     priv st_birthtime_nsec: c_long,\n+                     st_size: off_t,\n+                     st_blocks: blkcnt_t,\n+                     st_blksize: blksize_t,\n+                     priv st_flags: uint32_t,\n+                     priv st_gen: uint32_t,\n+                     priv st_lspare: int32_t,\n+                     priv st_qspare: [int64_t, ..2],\n                 }\n             }\n             pub mod posix08 {"}, {"sha": "95e61eca38ca1472adf66349089f6fc165057af6", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -454,6 +454,7 @@ impl<T: Zero> Option<T> {\n /// An iterator that yields either one or zero elements\n #[deriving(Clone, DeepClone)]\n pub struct OptionIterator<A> {\n+    // already priv\n     priv opt: Option<A>\n }\n "}, {"sha": "16035327da62c005d0eefafc06879b441a61ca5b", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -412,6 +412,7 @@ pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n }\n \n pub struct Pipe {\n+    // made priv by reedlepee\n     input: c_int,\n     out: c_int\n }\n@@ -1380,6 +1381,7 @@ pub fn page_size() -> uint {\n }\n \n pub struct MemoryMap {\n+    // made priv by reedlepee\n     data: *mut u8,\n     len: size_t,\n     kind: MemoryMapKind"}, {"sha": "113641ffe3e9c548a8348e3e65ec22692467baea", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -524,6 +524,7 @@ pub trait GenericPathUnsafe {\n \n /// Helper struct for printing paths with format!()\n pub struct Display<'self, P> {\n+    /// already priv\n     priv path: &'self P,\n     priv filename: bool\n }"}, {"sha": "207b23ab5e8fe7b48babdcad7550e29e5749fce4", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -42,6 +42,7 @@ pub type RevStrComponentIter<'self> = Map<'self, &'self [u8], Option<&'self str>\n /// Represents a POSIX file path\n #[deriving(Clone, DeepClone)]\n pub struct Path {\n+    /// already priv\n     priv repr: ~[u8], // assumed to never be empty or contain NULs\n     priv sepidx: Option<uint> // index of the final separator in repr\n }"}, {"sha": "230b03c6554f037d1e6e28fdd1421188be397453", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -82,6 +82,7 @@ pub type RevComponentIter<'self> = Map<'self, Option<&'self str>, &'self [u8],\n // preserved by the data structure; let the Windows API error out on them.\n #[deriving(Clone, DeepClone)]\n pub struct Path {\n+    /// already priv\n     priv repr: ~str, // assumed to never be empty\n     priv prefix: Option<PathPrefix>,\n     priv sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr"}, {"sha": "8c25a2f7971e7e22b6bc7ed690d2a564b8b0ad53", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -23,6 +23,7 @@ static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n ///\n /// The ISAAC algorithm is suitable for cryptographic purposes.\n pub struct IsaacRng {\n+    /// already priv\n     priv cnt: u32,\n     priv rsl: [u32, .. RAND_SIZE],\n     priv mem: [u32, .. RAND_SIZE],\n@@ -218,6 +219,7 @@ static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n ///\n /// The ISAAC algorithm is suitable for cryptographic purposes.\n pub struct Isaac64Rng {\n+    /// already priv\n     priv cnt: uint,\n     priv rsl: [u64, .. RAND_SIZE_64],\n     priv mem: [u64, .. RAND_SIZE_64],"}, {"sha": "1397a32632fec7ce9b3ddf9ea7d879b527f168d9", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -82,10 +82,11 @@ pub trait Rand {\n \n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n+    /// made priv by reedlepee\n     /// The numerical weight of this item\n-    weight: uint,\n+    priv weight: uint,\n     /// The actual item which is being weighted\n-    item: T,\n+    priv item: T,\n }\n \n /// A random number generator\n@@ -537,11 +538,13 @@ pub fn rng() -> StdRng {\n /// The standard RNG. This is designed to be efficient on the current\n /// platform.\n #[cfg(not(target_word_size=\"64\"))]\n+// already priv\n pub struct StdRng { priv rng: IsaacRng }\n \n /// The standard RNG. This is designed to be efficient on the current\n /// platform.\n #[cfg(target_word_size=\"64\")]\n+// already priv\n pub struct StdRng { priv rng: Isaac64Rng }\n \n impl StdRng {\n@@ -603,6 +606,7 @@ pub fn weak_rng() -> XorShiftRng {\n /// but is very fast. If you do not know for sure that it fits your\n /// requirements, use a more secure one such as `IsaacRng`.\n pub struct XorShiftRng {\n+    // already priv\n     priv x: u32,\n     priv y: u32,\n     priv z: u32,"}, {"sha": "a240c8bb873cd805c76c74d2aa9e63d6ea211052", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -36,6 +36,7 @@ type HCRYPTPROV = c_long;\n /// This does not block.\n #[cfg(unix)]\n pub struct OSRng {\n+    // already priv\n     priv inner: ReaderRng<file::FileStream>\n }\n /// A random number generator that retrieves randomness straight from\n@@ -45,6 +46,7 @@ pub struct OSRng {\n /// This does not block.\n #[cfg(windows)]\n pub struct OSRng {\n+    // already priv\n     priv hcryptprov: HCRYPTPROV\n }\n "}, {"sha": "ca2284f69bb40989acd79dbc848d62238552edc7", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -33,6 +33,7 @@ use rand::Rng;\n /// }\n /// ```\n pub struct ReaderRng<R> {\n+    // already priv\n     priv reader: R\n }\n "}, {"sha": "65e10f6f01f8084dc0cd55610772fae65b3fb0a5", "filename": "src/libstd/rand/reseeding.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freseeding.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -21,11 +21,13 @@ static DEFAULT_GENERATION_THRESHOLD: uint = 32 * 1024;\n /// A wrapper around any RNG which reseeds the underlying RNG after it\n /// has generated a certain number of random bytes.\n pub struct ReseedingRng<R, Rsdr> {\n+    // already priv\n     priv rng: R,\n     priv generation_threshold: uint,\n     priv bytes_generated: uint,\n     /// Controls the behaviour when reseeding the RNG.\n-    reseeder: Rsdr\n+    // made by reedlepee\n+    priv reseeder: Rsdr\n }\n \n impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {"}, {"sha": "388683dc029d67bcc79f493d7c77bb4b18d098fb", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -35,6 +35,7 @@ struct RcBox<T> {\n #[unsafe_no_drop_flag]\n #[no_send]\n pub struct Rc<T> {\n+    // already priv\n     priv ptr: *mut RcBox<T>\n }\n \n@@ -167,6 +168,7 @@ struct RcMutBox<T> {\n #[no_freeze]\n #[unsafe_no_drop_flag]\n pub struct RcMut<T> {\n+    // already priv\n     priv ptr: *mut RcMutBox<T>,\n }\n "}, {"sha": "9e13d20e9710ddd4957a2c8aa39e5366d2fe4b45", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -41,7 +41,8 @@ pub fn align(size: uint, align: uint) -> uint {\n \n /// Adaptor to wrap around visitors implementing MovePtr.\n pub struct MovePtrAdaptor<V> {\n-    inner: V\n+    // all by reedlepee\n+    priv inner: V\n }\n pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n     MovePtrAdaptor { inner: v }"}, {"sha": "0a8d2374218b7b55072a806f32103411de7ed5b3", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -98,10 +98,11 @@ enum VariantState {\n }\n \n pub struct ReprVisitor<'self> {\n-    ptr: *c_void,\n-    ptr_stk: ~[*c_void],\n-    var_stk: ~[VariantState],\n-    writer: &'self mut io::Writer\n+    // made priv by reedlpee\n+    priv ptr: *c_void,\n+    priv ptr_stk: ~[*c_void],\n+    priv var_stk: ~[VariantState],\n+    priv writer: &'self mut io::Writer\n }\n \n pub fn ReprVisitor<'a>(ptr: *c_void,"}, {"sha": "182515e12bee19f93c67ba1c697afdd8c5d3ce02", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -29,9 +29,10 @@ static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n \n #[deriving(Eq)]\n pub struct BorrowRecord {\n-    box: *mut raw::Box<()>,\n+    // all made byt reedlepee\n+    priv box: *mut raw::Box<()>,\n     file: *c_char,\n-    line: size_t\n+    priv line: size_t\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {"}, {"sha": "b74ae01fa30121b41d6c6f3f35855d359d19dab9", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -48,14 +48,16 @@ struct Packet<T> {\n \n // A one-shot channel.\n pub struct ChanOne<T> {\n-    void_packet: *mut Void,\n-    suppress_finalize: bool\n+    //  all made priv by reeldepee\n+    priv void_packet: *mut Void,\n+    priv suppress_finalize: bool\n }\n \n /// A one-shot port.\n pub struct PortOne<T> {\n-    void_packet: *mut Void,\n-    suppress_finalize: bool\n+    //  all made priv by reeldepee\n+    priv void_packet: *mut Void,\n+    priv suppress_finalize: bool\n }\n \n pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n@@ -443,12 +445,14 @@ type StreamPortOne<T> = PortOne<StreamPayload<T>>;\n \n /// A channel with unbounded size.\n pub struct Chan<T> {\n+    //  all made priv by reeldepee\n     // FIXME #5372. Using Cell because we don't take &mut self\n     next: Cell<StreamChanOne<T>>\n }\n \n /// An port with unbounded size.\n pub struct Port<T> {\n+    //  all made priv by reeldepee\n     // FIXME #5372. Using Cell because we don't take &mut self\n     next: Cell<StreamPortOne<T>>\n }\n@@ -577,6 +581,7 @@ impl<'self, T> SelectPortInner<T> for &'self Port<T> {\n impl<'self, T> SelectPort<T> for &'self Port<T> { }\n \n pub struct SharedChan<T> {\n+    // already priv\n     // Just like Chan, but a shared AtomicOption instead of Cell\n     priv next: UnsafeArc<AtomicOption<StreamChanOne<T>>>\n }\n@@ -630,6 +635,7 @@ impl<T> Clone for SharedChan<T> {\n }\n \n pub struct SharedPort<T> {\n+    // already priv\n     // The next port on which we will receive the next port on which we will receive T\n     priv next_link: UnsafeArc<AtomicOption<PortOne<StreamPortOne<T>>>>\n }"}, {"sha": "9508c757c9dd74ea45dd7dc00ca06ecb91d50896", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -25,11 +25,11 @@ pub static RED_ZONE: uint = 20 * 1024;\n // then misalign the regs again.\n pub struct Context {\n     /// The context entry point, saved here for later destruction\n-    start: Option<~~fn()>,\n+    priv start: Option<~~fn()>,\n     /// Hold the registers while the task or scheduler is suspended\n-    regs: ~Registers,\n+    priv regs: ~Registers,\n     /// Lower bound and upper bound for the stack\n-    stack_bounds: Option<(uint, uint)>,\n+    priv stack_bounds: Option<(uint, uint)>,\n }\n \n impl Context {"}, {"sha": "54a1c2406d0b0e9521a4fd86b21d357dd2cbe5c9", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -21,14 +21,16 @@ use vec::ImmutableVector;\n extern {}\n \n pub struct ModEntry<'self> {\n+    // made priv by reedlepee\n     name: &'self str,\n     log_level: *mut u32\n }\n \n pub struct CrateMap<'self> {\n-    version: i32,\n-    entries: &'self [ModEntry<'self>],\n-    children: &'self [&'self CrateMap<'self>]\n+    // made priv by reedlepee\n+     priv version: i32,\n+     priv entries: &'self [ModEntry<'self>],\n+     priv children: &'self [&'self CrateMap<'self>]\n }\n \n #[cfg(not(windows))]"}, {"sha": "a33892736b09e4fd79982eb0a16885d7500b8fb2", "filename": "src/libstd/rt/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -64,6 +64,7 @@ static DEFAULT_CAPACITY: uint = 64 * 1024;\n \n /// Wraps a Reader and buffers input from it\n pub struct BufferedReader<R> {\n+    // all already priv\n     priv inner: R,\n     priv buf: ~[u8],\n     priv pos: uint,\n@@ -175,6 +176,7 @@ impl<R: Reader> Decorator<R> for BufferedReader<R> {\n ///\n /// Note that `BufferedWriter` will NOT flush its buffer when dropped.\n pub struct BufferedWriter<W> {\n+    // all already priv\n     priv inner: W,\n     priv buf: ~[u8],\n     priv pos: uint\n@@ -250,6 +252,7 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///\n /// Note that `BufferedStream` will NOT flush its output buffer when dropped.\n pub struct BufferedStream<S> {\n+    // all already priv\n     priv inner: BufferedReader<InternalBufferedWriter<S>>\n }\n "}, {"sha": "5a3524195c74b0a94f06a275db2d6bb37a957f8e", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -368,6 +368,7 @@ impl<T: Reader> ReaderUtil for T {\n /// each call to its `.next()` method.\n /// Yields `None` if the condition is handled.\n pub struct ByteIterator<T> {\n+    // all already priv\n     priv reader: T,\n }\n "}, {"sha": "9d633ec1c65aa6aa00fd42eaaa85e10df54df947", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -298,6 +298,7 @@ pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n /// Constrained version of `FileStream` that only exposes read-specific operations.\n ///\n /// Can be retreived via `FileInfo.open_reader()`.\n+/// all already priv\n pub struct FileReader { priv stream: FileStream }\n \n /// a `std::rt::io::Reader` trait impl for file I/O.\n@@ -325,6 +326,7 @@ impl Seek for FileReader {\n /// Constrained version of `FileStream` that only exposes write-specific operations.\n ///\n /// Can be retreived via `FileInfo.open_writer()`.\n+// already priv\n pub struct FileWriter { priv stream: FileStream }\n \n /// a `std::rt::io::Writer` trait impl for file I/O.\n@@ -362,8 +364,9 @@ impl Seek for FileWriter {\n /// For this reason, it is best to use the access-constrained wrappers that are\n /// exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n pub struct FileStream {\n-    fd: ~RtioFileStream,\n-    last_nread: int,\n+    // all made by reedlepee\n+    priv fd: ~RtioFileStream,\n+    priv last_nread: int,\n }\n \n /// a `std::rt::io::Reader` trait impl for file I/O."}, {"sha": "9c49f2afb1ed57311fde5eaf80fdfc56b1d5bb8e", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -17,7 +17,8 @@ use super::*;\n \n /// A Writer decorator that compresses using the 'deflate' scheme\n pub struct DeflateWriter<W> {\n-    inner_writer: W\n+    // all made by reedlepee\n+    priv inner_writer: W\n }\n \n impl<W: Writer> DeflateWriter<W> {\n@@ -56,7 +57,8 @@ impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n \n /// A Reader decorator that decompresses using the 'deflate' scheme\n pub struct InflateReader<R> {\n-    inner_reader: R\n+    // all made by reedlepee\n+    priv inner_reader: R\n }\n \n impl<R: Reader> InflateReader<R> {"}, {"sha": "85bd46ebaf4341a9ec77d95c426d2298d2a150b0", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -22,6 +22,7 @@ use vec;\n \n /// Writes to an owned, growable byte vector\n pub struct MemWriter {\n+    // already priv\n     priv buf: ~[u8]\n }\n \n@@ -66,6 +67,7 @@ impl Decorator<~[u8]> for MemWriter {\n \n /// Reads from an owned byte vector\n pub struct MemReader {\n+    // already priv\n     priv buf: ~[u8],\n     priv pos: uint\n }\n@@ -129,6 +131,7 @@ impl Decorator<~[u8]> for MemReader {\n \n /// Writes to a fixed-size byte slice\n pub struct BufWriter<'self> {\n+    // already priv\n     priv buf: &'self mut [u8],\n     priv pos: uint\n }\n@@ -157,6 +160,7 @@ impl<'self> Seek for BufWriter<'self> {\n \n /// Reads from a fixed-size byte slice\n pub struct BufReader<'self> {\n+    // already priv\n     priv buf: &'self [u8],\n     priv pos: uint\n }"}, {"sha": "30775ec90ba02f4e7c3a1057f086d341686329a9", "filename": "src/libstd/rt/io/mock.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmock.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -12,8 +12,9 @@ use option::{Option, None};\n use rt::io::{Reader, Writer};\n \n pub struct MockReader {\n+    // all made by reedlepee\n     read: ~fn(buf: &mut [u8]) -> Option<uint>,\n-    eof: ~fn() -> bool\n+    priv eof: ~fn() -> bool\n }\n \n impl MockReader {\n@@ -31,8 +32,8 @@ impl Reader for MockReader {\n }\n \n pub struct MockWriter {\n-    write: ~fn(buf: &[u8]),\n-    flush: ~fn()\n+    priv write: ~fn(buf: &[u8]),\n+    priv flush: ~fn()\n }\n \n impl MockWriter {"}, {"sha": "d9951741ab25577ee5861b130c5325a22def5e1a", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -341,6 +341,7 @@ pub static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n ///\n /// Is something like this sufficient? It's kind of archaic\n pub struct IoError {\n+    // all made by reedlepee\n     kind: IoErrorKind,\n     desc: &'static str,\n     detail: Option<~str>\n@@ -648,6 +649,7 @@ pub enum FileAccess {\n }\n \n pub struct FileStat {\n+    // all made by reedlepee\n     /// A `Path` object containing information about the `PathInfo`'s location\n     path: Path,\n     /// `true` if the file pointed at by the `PathInfo` is a regular file"}, {"sha": "cce2e851452b3f49838a464bcf25c32499b57997", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -61,6 +61,7 @@ fn keep_going(data: &[u8], f: &fn(*u8, uint) -> i64) -> i64 {\n pub type fd_t = libc::c_int;\n \n pub struct FileDesc {\n+    // aleady priv\n     priv fd: fd_t,\n }\n \n@@ -126,6 +127,7 @@ impl Drop for FileDesc {\n }\n \n pub struct CFile {\n+    // aleady priv\n     priv file: *libc::FILE\n }\n "}, {"sha": "73ce330cd49c756ced49ba952a8b1267d6758b22", "filename": "src/libstd/rt/io/native/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -25,6 +25,7 @@ use super::file;\n  * for the process to terminate.\n  */\n pub struct Process {\n+    // aleady priv\n     /// The unique id of the process (this should never be negative).\n     priv pid: pid_t,\n "}, {"sha": "41c25e0841ab4d987250650232a499be1547c546", "filename": "src/libstd/rt/io/native/stdio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -31,6 +31,7 @@ pub fn println(s: &str) {\n }\n \n pub struct StdIn {\n+    // aleady priv\n     priv fd: file::FileDesc\n }\n \n@@ -49,6 +50,7 @@ impl Reader for StdIn {\n }\n \n pub struct StdOut {\n+    // aleady priv\n     priv fd: file::FileDesc\n }\n "}, {"sha": "945014867e2c435bf1a0a83fa1385ce6381493da", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -48,6 +48,7 @@ impl ToStr for IpAddr {\n \n #[deriving(Eq, TotalEq, Clone)]\n pub struct SocketAddr {\n+    // all made by reedlpee\n     ip: IpAddr,\n     port: Port,\n }"}, {"sha": "0ed5861e2961d3b5231f9100cfed7b97fad898a8", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -21,6 +21,7 @@ use rt::rtio::{IoFactory, IoFactoryObject,\n use rt::local::Local;\n \n pub struct TcpStream {\n+    // aleady priv\n     priv obj: ~RtioTcpStreamObject\n }\n \n@@ -99,6 +100,7 @@ impl Writer for TcpStream {\n }\n \n pub struct TcpListener {\n+    // aleady priv\n     priv obj: ~RtioTcpListenerObject\n }\n \n@@ -142,6 +144,7 @@ impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n }\n \n pub struct TcpAcceptor {\n+    // aleady priv\n     priv obj: ~RtioTcpAcceptorObject\n }\n "}, {"sha": "5c63dd5352e6a45a18e47c74481f7713a5de829b", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -17,6 +17,7 @@ use rt::rtio::{RtioSocket, RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFact\n use rt::local::Local;\n \n pub struct UdpSocket {\n+    // aleady priv\n     priv obj: ~RtioUdpSocketObject\n }\n \n@@ -72,6 +73,7 @@ impl UdpSocket {\n }\n \n pub struct UdpStream {\n+    // aleady priv\n     priv socket: UdpSocket,\n     priv connectedTo: SocketAddr\n }"}, {"sha": "a89419fa41f1f43477de4cea1f9a311c14a9fef4", "filename": "src/libstd/rt/io/pipe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -21,6 +21,7 @@ use rt::rtio::{RtioPipe, RtioPipeObject, IoFactoryObject, IoFactory};\n use rt::rtio::RtioUnboundPipeObject;\n \n pub struct PipeStream {\n+    // already priv\n     priv obj: RtioPipeObject\n }\n "}, {"sha": "e6029e0ff9c19dfc4082d68a7a9590f86bbe5a64", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -26,13 +26,16 @@ use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n #[cfg(not(windows))] pub static MustDieSignal: int = libc::SIGKILL as int;\n \n pub struct Process {\n+    // already priv\n     priv handle: ~RtioProcessObject,\n+    // made by reedlepee\n     io: ~[Option<io::PipeStream>],\n }\n \n /// This configuration describes how a new process should be spawned. This is\n /// translated to libuv's own configuration\n pub struct ProcessConfig<'self> {\n+    // all made by reedlepee\n     /// Path to the program to run\n     program: &'self str,\n "}, {"sha": "9f540dd0a8123e213aef6b3067c053b1d287645b", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -87,6 +87,7 @@ pub fn println_args(fmt: &fmt::Arguments) {\n \n /// Representation of a reader of a standard input stream\n pub struct StdReader {\n+    // aleady priv\n     priv inner: ~RtioFileStream\n }\n \n@@ -106,6 +107,7 @@ impl Reader for StdReader {\n \n /// Representation of a writer to a standard output stream\n pub struct StdWriter {\n+    // aleady priv\n     priv inner: ~RtioFileStream\n }\n "}, {"sha": "cb35fdf5883f49ed0517076776c1ed7db5a93280", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -16,6 +16,7 @@ use rt::rtio::{IoFactory, IoFactoryObject,\n use rt::local::Local;\n \n pub struct Timer {\n+    // aleady priv\n     priv obj: ~RtioTimerObject\n }\n "}, {"sha": "603e6627ee4666830bbcc3655c420551f43dc4b9", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -215,21 +215,22 @@ pub struct KillHandle(UnsafeArc<KillHandleInner>);\n \n /// Per-task state related to task death, killing, failure, etc.\n pub struct Death {\n+    // all made priv by reedlepee\n     // Shared among this task, its watched children, and any linked tasks who\n     // might kill it. This is optional so we can take it by-value at exit time.\n-    kill_handle:     Option<KillHandle>,\n+     kill_handle:     Option<KillHandle>,\n     // Handle to a watching parent, if we have one, for exit code propagation.\n-    watching_parent: Option<KillHandle>,\n+     priv watching_parent: Option<KillHandle>,\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n-    on_exit:         Option<~fn(bool)>,\n+     on_exit:         Option<~fn(bool)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n-    unkillable:      int,\n+     priv unkillable:      int,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n-    wont_sleep:      int,\n+     priv wont_sleep:      int,\n     // A \"spare\" handle to the kill flag inside the kill handle. Used during\n     // blocking/waking as an optimization to avoid two xadds on the refcount.\n-    spare_kill_flag: Option<KillFlagHandle>,\n+     priv spare_kill_flag: Option<KillFlagHandle>,\n }\n \n impl Drop for KillFlag {"}, {"sha": "0f28880871d52e9783cf1ef8df01a2286bc5f264", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -32,8 +32,9 @@ pub type OpaqueBox = c_void;\n pub type TypeDesc = c_void;\n \n pub struct LocalHeap {\n-    memory_region: *MemoryRegion,\n-    boxed_region: *BoxedRegion\n+    // all made by reedlepee\n+    priv memory_region: *MemoryRegion,\n+    priv boxed_region: *BoxedRegion\n }\n \n impl LocalHeap {"}, {"sha": "1864ebdad33622aa1b8e26888fbdda4ac8388dfa", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -20,6 +20,7 @@ use unstable::sync::{UnsafeArc, LittleLock};\n use clone::Clone;\n \n pub struct MessageQueue<T> {\n+    // already priv\n     priv state: UnsafeArc<State<T>>\n }\n "}, {"sha": "3e641196cb4abc2ecb8b0b9c246ac29c9c192c60", "filename": "src/libstd/rt/rc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frc.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -24,7 +24,8 @@ use libc::c_void;\n use cast;\n \n pub struct RC<T> {\n-    p: *c_void // ~(uint, T)\n+    // all made priv by reedlepe\n+    priv p: *c_void // ~(uint, T)\n }\n \n impl<T> RC<T> {"}, {"sha": "485239d307f5f424f2b43c9d0e9e612e01408e55", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -61,12 +61,13 @@ pub trait RemoteCallback {\n /// Using unix flag conventions for now, which happens to also be what's supported\n /// libuv (it does translation to windows under the hood).\n pub struct FileOpenConfig {\n+    // all made by reedlepe\n     /// Path to file to be opened\n     path: Path,\n     /// Flags for file access mode (as per open(2))\n     flags: int,\n     /// File creation mode, ignored unless O_CREAT is passed as part of flags\n-    mode: int\n+    priv mode: int\n }\n \n pub trait IoFactory {"}, {"sha": "82c56d7d9a30a60343fdc15e776b662b4cdea4dc", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -40,13 +40,15 @@ use vec::{OwnedVector};\n /// in too much allocation and too many events.\n pub struct Scheduler {\n     /// There are N work queues, one per scheduler.\n-    priv work_queue: WorkQueue<~Task>,\n+    // already priv\n+    work_queue: WorkQueue<~Task>,\n     /// Work queues for the other schedulers. These are created by\n     /// cloning the core work queues.\n     work_queues: ~[WorkQueue<~Task>],\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n+    // already priv\n     priv message_queue: MessageQueue<SchedMessage>,\n     /// A shared list of sleeping schedulers. We'll use this to wake\n     /// up schedulers when pushing work onto the work queue.\n@@ -57,6 +59,7 @@ pub struct Scheduler {\n     /// not active since there are multiple event sources that may\n     /// wake the scheduler. It just prevents the scheduler from pushing\n     /// multiple handles onto the sleeper list.\n+    // already priv\n     priv sleepy: bool,\n     /// A flag to indicate we've received the shutdown message and should\n     /// no longer try to go to sleep, but exit instead.\n@@ -66,26 +69,26 @@ pub struct Scheduler {\n     event_loop: ~EventLoopObject,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n-    sched_task: Option<~Task>,\n+    priv sched_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n-    cleanup_job: Option<CleanupJob>,\n+    priv cleanup_job: Option<CleanupJob>,\n     /// Should this scheduler run any task, or only pinned tasks?\n     run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n     /// them to.\n-    friend_handle: Option<SchedHandle>,\n+    priv friend_handle: Option<SchedHandle>,\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A toggleable idle callback\n-    idle_callback: Option<~PausibleIdleCallback>,\n+    priv idle_callback: Option<~PausibleIdleCallback>,\n     /// A countdown that starts at a random value and is decremented\n     /// every time a yield check is performed. When it hits 0 a task\n     /// will yield.\n-    yield_check_count: uint,\n+    priv yield_check_count: uint,\n     /// A flag to tell the scheduler loop it needs to do some stealing\n     /// in order to introduce randomness as part of a yield\n-    steal_for_yield: bool\n+    priv steal_for_yield: bool\n }\n \n /// An indication of how hard to work on a given operation, the difference\n@@ -793,8 +796,10 @@ pub enum SchedMessage {\n }\n \n pub struct SchedHandle {\n+    //already priv\n     priv remote: ~RemoteCallbackObject,\n     priv queue: MessageQueue<SchedMessage>,\n+    // made by reedlepee\n     sched_id: uint\n }\n "}, {"sha": "5135ed76005a073376be53bc1fbce86da677ec43", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -20,6 +20,7 @@ use rt::sched::SchedHandle;\n use clone::Clone;\n \n pub struct SleeperList {\n+    // already priv\n     priv state: UnsafeArc<State>\n }\n "}, {"sha": "7bffc93c69346a1181ba2ec002898dfdb47e4fe8", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -15,8 +15,9 @@ use ops::Drop;\n use libc::{c_uint, uintptr_t};\n \n pub struct StackSegment {\n-    buf: ~[u8],\n-    valgrind_id: c_uint\n+    // all made by reedlepee\n+    priv buf: ~[u8],\n+    priv valgrind_id: c_uint\n }\n \n impl StackSegment {"}, {"sha": "6e0b96c221e6d0a58e01115db32e4bc6796fef4b", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -43,20 +43,22 @@ use send_str::SendStr;\n // the type-specific state.\n \n pub struct Task {\n-    heap: LocalHeap,\n-    gc: GarbageCollector,\n-    storage: LocalStorage,\n-    logger: StdErrLogger,\n-    unwinder: Unwinder,\n-    taskgroup: Option<Taskgroup>,\n-    death: Death,\n-    destroyed: bool,\n-    name: Option<SendStr>,\n-    coroutine: Option<Coroutine>,\n-    sched: Option<~Scheduler>,\n-    task_type: TaskType,\n+     //all priv made br reedlepe\n+     heap: LocalHeap,\n+     priv gc: GarbageCollector,\n+     storage: LocalStorage,\n+     logger: StdErrLogger,\n+     unwinder: Unwinder,\n+     taskgroup: Option<Taskgroup>,\n+     death: Death,\n+     destroyed: bool,\n+     name: Option<SendStr>,\n+     coroutine: Option<Coroutine>,\n+     sched: Option<~Scheduler>,\n+     task_type: TaskType,\n     // Dynamic borrowck debugging info\n-    borrow_list: Option<~[BorrowRecord]>\n+     // should be public\n+     borrow_list: Option<~[BorrowRecord]>\n }\n \n pub enum TaskType {\n@@ -69,7 +71,8 @@ pub struct Coroutine {\n     /// The segment of stack on which the task is currently running or\n     /// if the task is blocked, on which the task will resume\n     /// execution.\n-    current_stack_segment: StackSegment,\n+    //all priv made br reedlepe\n+    priv current_stack_segment: StackSegment,\n     /// Always valid if the task is alive and not running.\n     saved_context: Context\n }\n@@ -84,6 +87,7 @@ pub struct GarbageCollector;\n pub struct LocalStorage(Option<local_data::Map>);\n \n pub struct Unwinder {\n+    //all priv made br reedlepe\n     unwinding: bool,\n }\n "}, {"sha": "949d73ecc4fcfaf63b58045be2fcb7c2245dc589", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -18,9 +18,9 @@ use uint;\n type raw_thread = libc::c_void;\n \n pub struct Thread {\n-    main: ~fn(),\n-    raw_thread: *raw_thread,\n-    joined: bool,\n+    priv main: ~fn(),\n+    priv raw_thread: *raw_thread,\n+    priv joined: bool\n }\n \n impl Thread {"}, {"sha": "869f23baf325c3614041a4d2d9dc84fd71364b0d", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -28,7 +28,8 @@ struct TubeState<T> {\n }\n \n pub struct Tube<T> {\n-    p: RC<TubeState<T>>\n+    //all priv made br reedlepe\n+    priv p: RC<TubeState<T>>\n }\n \n impl<T> Tube<T> {"}, {"sha": "8fa8fbdc4a10d7f474925197dba46042b0a04345", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -25,7 +25,8 @@ type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &UvAddrInfo, Option<UvError>)\n pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n \n pub struct RequestData {\n-    getaddrinfo_cb: Option<GetAddrInfoCallback>,\n+    // all made by reedlepee\n+    priv getaddrinfo_cb: Option<GetAddrInfoCallback>,\n }\n \n impl GetAddrInfoRequest {"}, {"sha": "5e20f5fad88cf874302787c1ebd57571ea141ebc", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -25,7 +25,8 @@ pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest {}\n \n pub struct RequestData {\n-    complete_cb: Option<FsCallback>\n+    // all made by reedlepee\n+    priv complete_cb: Option<FsCallback>\n }\n \n impl FsRequest {"}, {"sha": "4c547276a50c594f9ca3eed475867da40644ea68", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -80,7 +80,8 @@ pub mod pipe;\n /// with dtors may not be destructured, but tuple structs can,\n /// but the results are not correct.\n pub struct Loop {\n-    handle: *uvll::uv_loop_t\n+    // all made by reedlepee\n+    priv handle: *uvll::uv_loop_t\n }\n \n /// The trait implemented by uv 'watchers' (handles). Watchers are"}, {"sha": "5e441a5414b4aafcae45051a96d76c531314ed07", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -180,7 +180,8 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n \n // Obviously an Event Loop is always home.\n pub struct UvEventLoop {\n-    uvio: UvIoFactory\n+    // all made by reedlepee\n+    priv uvio: UvIoFactory\n }\n \n impl UvEventLoop {\n@@ -240,9 +241,10 @@ impl EventLoop for UvEventLoop {\n }\n \n pub struct UvPausibleIdleCallback {\n-    watcher: IdleWatcher,\n-    idle_flag: bool,\n-    closed: bool\n+    // all made by reedlepee\n+    priv watcher: IdleWatcher,\n+    priv idle_flag: bool,\n+    priv closed: bool\n }\n \n impl UvPausibleIdleCallback {\n@@ -293,11 +295,12 @@ fn test_callback_run_once() {\n \n // The entire point of async is to call into a loop from other threads so it does not need to home.\n pub struct UvRemoteCallback {\n+    // all made by reedlepee\n     // The uv async handle for triggering the callback\n-    async: AsyncWatcher,\n+    priv async: AsyncWatcher,\n     // A flag to tell the callback to exit, set from the dtor. This is\n     // almost never contested - only in rare races with the dtor.\n-    exit_flag: Exclusive<bool>\n+    priv exit_flag: Exclusive<bool>\n }\n \n impl UvRemoteCallback {\n@@ -801,8 +804,9 @@ impl IoFactory for UvIoFactory {\n }\n \n pub struct UvTcpListener {\n-    watcher : TcpWatcher,\n-    home: SchedHandle,\n+    // all made by reedlepee\n+    priv watcher : TcpWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvTcpListener {\n@@ -863,8 +867,9 @@ impl RtioTcpListener for UvTcpListener {\n }\n \n pub struct UvTcpAcceptor {\n-    listener: UvTcpListener,\n-    incoming: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+    // all made by reedlepee\n+    priv listener: UvTcpListener,\n+    priv incoming: Tube<Result<~RtioTcpStreamObject, IoError>>,\n }\n \n impl HomingIO for UvTcpAcceptor {\n@@ -987,8 +992,9 @@ fn write_stream(mut watcher: StreamWatcher,\n }\n \n pub struct UvUnboundPipe {\n+    // all made by reedlepee\n     pipe: Pipe,\n-    home: SchedHandle,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvUnboundPipe {\n@@ -1017,6 +1023,7 @@ impl UvUnboundPipe {\n }\n \n pub struct UvPipeStream {\n+    // already\n     priv inner: ~UvUnboundPipe,\n }\n \n@@ -1040,8 +1047,9 @@ impl RtioPipe for UvPipeStream {\n }\n \n pub struct UvTcpStream {\n-    watcher: TcpWatcher,\n-    home: SchedHandle,\n+    // all made by reedlepee\n+    priv watcher: TcpWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvTcpStream {\n@@ -1140,8 +1148,9 @@ impl RtioTcpStream for UvTcpStream {\n }\n \n pub struct UvUdpSocket {\n-    watcher: UdpWatcher,\n-    home: SchedHandle,\n+    // all made by reedelpee\n+    priv watcher: UdpWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvUdpSocket {\n@@ -1350,8 +1359,9 @@ impl RtioUdpSocket for UvUdpSocket {\n }\n \n pub struct UvTimer {\n-    watcher: timer::TimerWatcher,\n-    home: SchedHandle,\n+    // all made by reedelpee\n+    priv watcher: timer::TimerWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvTimer {\n@@ -1397,10 +1407,11 @@ impl RtioTimer for UvTimer {\n }\n \n pub struct UvFileStream {\n-    loop_: Loop,\n-    fd: c_int,\n-    close_on_drop: bool,\n-    home: SchedHandle\n+    // all made by reedelpee\n+    priv loop_: Loop,\n+    priv fd: c_int,\n+    priv close_on_drop: bool,\n+    priv home: SchedHandle\n }\n \n impl HomingIO for UvFileStream {\n@@ -1530,13 +1541,15 @@ impl RtioFileStream for UvFileStream {\n }\n \n pub struct UvProcess {\n-    process: process::Process,\n+    // two made by reedelpee\n+    priv process: process::Process,\n \n     // Sadly, this structure must be created before we return it, so in that\n     // brief interim the `home` is None.\n-    home: Option<SchedHandle>,\n+    priv home: Option<SchedHandle>,\n \n     // All None until the process exits (exit_error may stay None)\n+   // Rest were already priv\n     priv exit_status: Option<int>,\n     priv term_signal: Option<int>,\n     priv exit_error: Option<UvError>,"}, {"sha": "98d4fd332772a1ab47d05be34d163a46d7e488ba", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 55, "deletions": 45, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -84,33 +84,37 @@ pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n // see libuv/include/uv-unix.h\n #[cfg(unix)]\n pub struct uv_buf_t {\n+    // all made by reedelpee\n     base: *u8,\n     len: libc::size_t,\n }\n \n // see libuv/include/uv-win.h\n #[cfg(windows)]\n pub struct uv_buf_t {\n+    // all made by reedelpee\n     len: u32,\n     base: *u8,\n }\n \n pub struct uv_process_options_t {\n-    exit_cb: uv_exit_cb,\n-    file: *libc::c_char,\n-    args: **libc::c_char,\n-    env: **libc::c_char,\n-    cwd: *libc::c_char,\n-    flags: libc::c_uint,\n-    stdio_count: libc::c_int,\n-    stdio: *uv_stdio_container_t,\n-    uid: uv_uid_t,\n-    gid: uv_gid_t,\n+     // all made by reedelpee\n+     exit_cb: uv_exit_cb,\n+     file: *libc::c_char,\n+     args: **libc::c_char,\n+     env: **libc::c_char,\n+     cwd: *libc::c_char,\n+     flags: libc::c_uint,\n+     stdio_count: libc::c_int,\n+     stdio: *uv_stdio_container_t,\n+     uid: uv_uid_t,\n+     gid: uv_gid_t,\n }\n \n // These fields are private because they must be interfaced with through the\n // functions below.\n pub struct uv_stdio_container_t {\n+    // already priv\n     priv flags: libc::c_int,\n     priv stream: *uv_stream_t,\n }\n@@ -133,27 +137,29 @@ pub type uv_process_t = c_void;\n pub type uv_pipe_t = c_void;\n \n pub struct uv_timespec_t {\n+    // all made by reedelpee\n     tv_sec: libc::c_long,\n-    tv_nsec: libc::c_long\n+    priv tv_nsec: libc::c_long\n }\n \n pub struct uv_stat_t {\n-    st_dev: libc::uint64_t,\n+    // all made by reedelpee\n+    priv st_dev: libc::uint64_t,\n     st_mode: libc::uint64_t,\n-    st_nlink: libc::uint64_t,\n-    st_uid: libc::uint64_t,\n-    st_gid: libc::uint64_t,\n-    st_rdev: libc::uint64_t,\n-    st_ino: libc::uint64_t,\n+    priv st_nlink: libc::uint64_t,\n+    priv st_uid: libc::uint64_t,\n+    priv st_gid: libc::uint64_t,\n+    priv st_rdev: libc::uint64_t,\n+    priv st_ino: libc::uint64_t,\n     st_size: libc::uint64_t,\n-    st_blksize: libc::uint64_t,\n-    st_blocks: libc::uint64_t,\n-    st_flags: libc::uint64_t,\n-    st_gen: libc::uint64_t,\n+    priv st_blksize: libc::uint64_t,\n+    priv st_blocks: libc::uint64_t,\n+    priv st_flags: libc::uint64_t,\n+    priv st_gen: libc::uint64_t,\n     st_atim: uv_timespec_t,\n     st_mtim: uv_timespec_t,\n     st_ctim: uv_timespec_t,\n-    st_birthtim: uv_timespec_t\n+    priv st_birthtim: uv_timespec_t\n }\n \n impl uv_stat_t {\n@@ -231,39 +237,42 @@ pub type socklen_t = c_int;\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"linux\")]\n pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n-    ai_addr: *sockaddr,\n-    ai_canonname: *char,\n-    ai_next: *addrinfo\n+     // all made by reedelpee\n+     priv ai_flags: c_int,\n+     priv ai_family: c_int,\n+     priv ai_socktype: c_int,\n+     priv ai_protocol: c_int,\n+     priv ai_addrlen: socklen_t,\n+     ai_addr: *sockaddr,\n+     priv ai_canonname: *char,\n+     ai_next: *addrinfo\n }\n \n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n-    ai_canonname: *char,\n+     // all made by reedelpee\n+    priv ai_flags: c_int,\n+    priv ai_family: c_int,\n+    priv ai_socktype: c_int,\n+    priv ai_protocol: c_int,\n+    priv ai_addrlen: socklen_t,\n+    priv ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n }\n \n #[cfg(windows)]\n pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: size_t,\n-    ai_canonname: *char,\n+     // all made by reedelpee\n+    priv ai_flags: c_int,\n+    priv ai_family: c_int,\n+    priv ai_socktype: c_int,\n+    priv ai_protocol: c_int,\n+    priv ai_addrlen: size_t,\n+    priv ai_canonname: *char,\n     ai_addr: *sockaddr,\n-    ai_next: *addrinfo\n+    priv vai_next: *addrinfo\n }\n \n #[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n@@ -960,8 +969,9 @@ pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n }\n \n pub struct uv_err_data {\n-    err_name: ~str,\n-    err_msg: ~str,\n+     // all made by reedelpee\n+    priv err_name: ~str,\n+    priv err_msg: ~str,\n }\n \n extern {"}, {"sha": "7700855d7b74326a27a8955790f842b12659f72b", "filename": "src/libstd/rt/work_queue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -17,6 +17,7 @@ use kinds::Send;\n use clone::Clone;\n \n pub struct WorkQueue<T> {\n+    // already priv\n     // XXX: Another mystery bug fixed by boxing this lock\n     priv queue: ~Exclusive<~[T]>\n }"}, {"sha": "ccb8de8185714dc9f342908ae656488be6310e9d", "filename": "src/libstd/run.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -29,12 +29,13 @@ use task;\n  * for the process to terminate.\n  */\n pub struct Process {\n+    // already priv\n     priv inner: process::Process,\n }\n \n /// Options that can be given when starting a Process.\n pub struct ProcessOptions<'self> {\n-\n+    // All were made priv by reedlepee\n     /**\n      * If this is None then the new process will have the same initial\n      * environment as the parent process.\n@@ -99,7 +100,7 @@ impl <'self> ProcessOptions<'self> {\n \n /// The output of a finished process.\n pub struct ProcessOutput {\n-\n+    /// made priv by reedlepee\n     /// The status (exit code) of the process.\n     status: int,\n "}, {"sha": "bba3ad6a94ef99408281e1c817b1f115ceb7e883", "filename": "src/libstd/str.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -355,6 +355,7 @@ Section: Iterators\n /// Use with the `std::iterator` module.\n #[deriving(Clone)]\n pub struct CharIterator<'self> {\n+    // already priv\n     /// The slice remaining to be iterated\n     priv string: &'self str,\n }\n@@ -400,6 +401,7 @@ impl<'self> DoubleEndedIterator<char> for CharIterator<'self> {\n /// Use with the `std::iterator` module.\n #[deriving(Clone)]\n pub struct CharOffsetIterator<'self> {\n+    // already priv\n     /// The original string to be iterated\n     priv string: &'self str,\n     priv iter: CharIterator<'self>,\n@@ -458,6 +460,7 @@ pub type ByteRevIterator<'self> = Invert<ByteIterator<'self>>;\n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n pub struct CharSplitIterator<'self, Sep> {\n+    // already priv\n     /// The slice remaining to be iterated\n     priv string: &'self str,\n     priv sep: Sep,\n@@ -475,6 +478,7 @@ pub type CharRSplitIterator<'self, Sep> = Invert<CharSplitIterator<'self, Sep>>;\n /// splitting at most `count` times.\n #[deriving(Clone)]\n pub struct CharSplitNIterator<'self, Sep> {\n+    // already priv\n     priv iter: CharSplitIterator<'self, Sep>,\n     /// The number of splits remaining\n     priv count: uint,\n@@ -591,6 +595,7 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitNIterator<'self, Sep>\n /// substring within a larger string\n #[deriving(Clone)]\n pub struct MatchesIndexIterator<'self> {\n+    // already priv\n     priv haystack: &'self str,\n     priv needle: &'self str,\n     priv position: uint,\n@@ -600,6 +605,7 @@ pub struct MatchesIndexIterator<'self> {\n /// search string\n #[deriving(Clone)]\n pub struct StrSplitIterator<'self> {\n+    // already priv\n     priv it: MatchesIndexIterator<'self>,\n     priv last_end: uint,\n     priv finished: bool\n@@ -997,9 +1003,9 @@ pub fn utf8_char_width(b: u8) -> uint {\n /// the utf8 bytes of a string.\n pub struct CharRange {\n     /// Current `char`\n-\t/// This field should be public making it private causes error while compiling!!\n+    /// This field should be public making it private causes error while compiling!!\n     ch: char,\n-\n+    // made by reedlepee\n     /// Index of the first byte of the next `char`\n     next: uint\n }"}, {"sha": "35a33f017014177494e29b6f3f452efe54234e3a", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -23,6 +23,7 @@ use option::{Some, None};\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n #[deriving(Clone, Eq, Ord, TotalOrd, TotalEq)]\n+//already priv\n pub struct Ascii { priv chr: u8 }\n \n impl Ascii {"}, {"sha": "55a881f48fadb074e7fcb1d7c9da12c7706eee49", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -108,7 +108,8 @@ pub enum SchedMode {\n  *\n  */\n pub struct SchedOpts {\n-    mode: SchedMode,\n+     // all made by reedelpee\n+    priv mode: SchedMode,\n }\n \n /**\n@@ -144,14 +145,15 @@ pub struct SchedOpts {\n  *           scheduler other tasks will be impeded or even blocked indefinitely.\n  */\n pub struct TaskOpts {\n-    linked: bool,\n-    supervised: bool,\n-    watched: bool,\n-    indestructible: bool,\n-    notify_chan: Option<Chan<TaskResult>>,\n-    name: Option<SendStr>,\n-    sched: SchedOpts,\n-    stack_size: Option<uint>\n+     // all made by reedelpee\n+     priv linked: bool,\n+     priv supervised: bool,\n+     priv watched: bool,\n+     priv indestructible: bool,\n+     priv notify_chan: Option<Chan<TaskResult>>,\n+     name: Option<SendStr>,\n+     sched: SchedOpts,\n+     stack_size: Option<uint>\n }\n \n /**\n@@ -169,10 +171,11 @@ pub struct TaskOpts {\n \n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n+    //all made priv by reedlepee\n     opts: TaskOpts,\n-    gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n-    can_not_copy: Option<util::NonCopyable>,\n-    consumed: bool,\n+    priv gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n+    priv can_not_copy: Option<util::NonCopyable>,\n+    priv consumed: bool,\n }\n \n /**"}, {"sha": "36bf261bb52f6e0586681c81a744d939daf82af4", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -307,11 +307,12 @@ fn each_ancestor(list:        &mut AncestorList,\n \n // One of these per task.\n pub struct Taskgroup {\n+     // all made by reedlepee\n     // List of tasks with whose fates this one's is intertwined.\n-    tasks:      TaskGroupArc, // 'none' means the group has failed.\n+    priv tasks:      TaskGroupArc, // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n-    ancestors:  AncestorList,\n-    notifier:   Option<AutoNotify>,\n+    priv ancestors:  AncestorList,\n+    priv notifier:   Option<AutoNotify>,\n }\n \n impl Drop for Taskgroup {"}, {"sha": "57aec6a7314d25d52a86f9a6ba6940052e0b7253", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -28,6 +28,7 @@ enum Child<T> {\n \n #[allow(missing_doc)]\n pub struct TrieMap<T> {\n+    // already priv\n     priv root: TrieNode<T>,\n     priv length: uint\n }\n@@ -222,6 +223,7 @@ impl<T> Extendable<(uint, T)> for TrieMap<T> {\n \n #[allow(missing_doc)]\n pub struct TrieSet {\n+    // already priv\n     priv map: TrieMap<()>\n }\n \n@@ -443,6 +445,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n \n /// Forward iterator over a map\n pub struct TrieMapIterator<'self, T> {\n+    // already priv\n     priv stack: ~[vec::VecIterator<'self, Child<T>>],\n     priv remaining_min: uint,\n     priv remaining_max: uint\n@@ -483,6 +486,7 @@ impl<'self, T> Iterator<(uint, &'self T)> for TrieMapIterator<'self, T> {\n \n /// Forward iterator over a set\n pub struct TrieSetIterator<'self> {\n+    // already priv\n     priv iter: TrieMapIterator<'self, ()>\n }\n "}, {"sha": "e64f17ecf30883d437301509a003baec9255cd51", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -28,34 +28,39 @@ use ops::Drop;\n  * A simple atomic flag, that can be set and cleared. The most basic atomic type.\n  */\n pub struct AtomicFlag {\n+     // already\n     priv v: int\n }\n \n /**\n  * An atomic boolean type.\n  */\n pub struct AtomicBool {\n+     // already\n     priv v: uint\n }\n \n /**\n  * A signed atomic integer type, supporting basic atomic arithmetic operations\n  */\n pub struct AtomicInt {\n+     // already\n     priv v: int\n }\n \n /**\n  * An unsigned atomic integer type, supporting basic atomic arithmetic operations\n  */\n pub struct AtomicUint {\n+     // already\n     priv v: uint\n }\n \n /**\n  * An unsafe atomic pointer. Only supports basic atomic operations\n  */\n pub struct AtomicPtr<T> {\n+     // already\n     priv p: *mut T\n }\n \n@@ -64,6 +69,7 @@ pub struct AtomicPtr<T> {\n  */\n #[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n+     // already\n     priv p: *mut c_void\n }\n "}, {"sha": "18ee693ebb64cc197088be2419ec7932b0a7b33d", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -23,6 +23,7 @@ use ops::*;\n use option::*;\n use result::*;\n \n+// already\n pub struct DynamicLibrary { priv handle: *libc::c_void }\n \n impl Drop for DynamicLibrary {"}, {"sha": "0719ad4078148d10370b5a1444f90a1e5746abca", "filename": "src/libstd/unstable/extfmt.rs", "status": "added", "additions": 705, "deletions": 0, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -0,0 +1,705 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support for fmt! expressions.\n+//!\n+//! The syntax is close to that of Posix format strings:\n+//!\n+//! ~~~~~~\n+//! Format := '%' Parameter? Flag* Width? Precision? Type\n+//! Parameter := [0-9]+ '$'\n+//! Flag := [ 0#+-]\n+//! Width := Parameter | [0-9]+\n+//! Precision := '.' [0-9]+\n+//! Type := [bcdfiostuxX?]\n+//! ~~~~~~\n+//!\n+//! * Parameter is the 1-based argument to apply the format to. Currently not\n+//! implemented.\n+//! * Flag 0 causes leading zeros to be used for padding when converting\n+//! numbers.\n+//! * Flag # causes the conversion to be done in an *alternative* manner.\n+//! Currently not implemented.\n+//! * Flag + causes signed numbers to always be prepended with a sign\n+//! character.\n+//! * Flag - left justifies the result\n+//! * Width specifies the minimum field width of the result. By default\n+//! leading spaces are added.\n+//! * Precision specifies the minimum number of digits for integral types\n+//! and the minimum number\n+//! of decimal places for float.\n+//!\n+//! The types currently supported are:\n+//!\n+//! * b - bool\n+//! * c - char\n+//! * d - int\n+//! * f - float\n+//! * i - int (same as d)\n+//! * o - uint as octal\n+//! * t - uint as binary\n+//! * u - uint\n+//! * x - uint as lower-case hexadecimal\n+//! * X - uint as upper-case hexadecimal\n+//! * s - str (any flavor)\n+//! * ? - arbitrary type (does not use the to_str trait)\n+\n+/*\n+Syntax Extension: fmt\n+\n+Format a string\n+\n+The 'fmt' extension is modeled on the posix printf system.\n+\n+A posix conversion ostensibly looks like this\n+\n+> %~[parameter]~[flags]~[width]~[.precision]~[length]type\n+\n+Given the different numeric type bestiary we have, we omit the 'length'\n+parameter and support slightly different conversions for 'type'\n+\n+> %~[parameter]~[flags]~[width]~[.precision]type\n+\n+we also only support translating-to-rust a tiny subset of the possible\n+combinations at the moment.\n+\n+Example:\n+\n+debug!(\"hello, %s!\", \"world\");\n+\n+*/\n+\n+use prelude::*;\n+\n+/*\n+ * We have a 'ct' (compile-time) module that parses format strings into a\n+ * sequence of conversions. From those conversions AST fragments are built\n+ * that call into properly-typed functions in the 'rt' (run-time) module.\n+ * Each of those run-time conversion functions accepts another conversion\n+ * description that specifies how to format its output.\n+ *\n+ * The building of the AST is currently done in a module inside the compiler,\n+ * but should migrate over here as the plugin interface is defined.\n+ */\n+\n+// Functions used by the fmt extension at compile time\n+#[doc(hidden)]\n+pub mod ct {\n+    use char;\n+    use container::Container;\n+    use prelude::*;\n+    use str;\n+\n+    #[deriving(Eq)]\n+    pub enum Signedness { Signed, Unsigned, }\n+\n+    #[deriving(Eq)]\n+    pub enum Caseness { CaseUpper, CaseLower, }\n+\n+    #[deriving(Eq)]\n+    pub enum Ty {\n+        TyBool,\n+        TyStr,\n+        TyChar,\n+        TyInt(Signedness),\n+        TyBits,\n+        TyHex(Caseness),\n+        TyOctal,\n+        TyFloat,\n+        TyPointer,\n+        TyPoly,\n+    }\n+\n+    #[deriving(Eq)]\n+    pub enum Flag {\n+        FlagLeftJustify,\n+        FlagLeftZeroPad,\n+        FlagSpaceForSign,\n+        FlagSignAlways,\n+        FlagAlternate,\n+    }\n+\n+    #[deriving(Eq)]\n+    pub enum Count {\n+        CountIs(uint),\n+        CountIsParam(uint),\n+        CountIsNextParam,\n+        CountImplied,\n+    }\n+\n+    #[deriving(Eq)]\n+    struct Parsed<T> {\n+        val: T,\n+        next: uint\n+    }\n+\n+    impl<T> Parsed<T> {\n+        pub fn new(val: T, next: uint) -> Parsed<T> {\n+            Parsed {val: val, next: next}\n+        }\n+    }\n+\n+    // A formatted conversion from an expression to a string\n+    #[deriving(Eq)]\n+    pub struct Conv {\n+        // all ade by reedlepee\n+        param: Option<uint>,\n+        flags: ~[Flag],\n+        width: Count,\n+        precision: Count,\n+        ty: Ty\n+    }\n+\n+    // A fragment of the output sequence\n+    #[deriving(Eq)]\n+    pub enum Piece {\n+        PieceString(~str),\n+        PieceConv(Conv),\n+    }\n+\n+    pub type ErrorFn<'self> = &'self fn(&str) -> !;\n+\n+    pub fn parse_fmt_string<'a>(s: &str, err: ErrorFn<'a>) -> ~[Piece] {\n+        fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n+            if to > from {\n+                ps.push(PieceString(s.slice(from, to).to_owned()));\n+            }\n+        }\n+\n+        let lim = s.len();\n+        let mut h = 0;\n+        let mut i = 0;\n+        let mut pieces = ~[];\n+\n+        while i < lim {\n+            if s[i] == '%' as u8 {\n+                i += 1;\n+\n+                if i >= lim {\n+                    err(\"unterminated conversion at end of string\");\n+                } else if s[i] == '%' as u8 {\n+                    push_slice(&mut pieces, s, h, i);\n+                    i += 1;\n+                } else {\n+                    push_slice(&mut pieces, s, h, i - 1);\n+                    let Parsed {\n+                        val,\n+                        next\n+                    } = parse_conversion(s, i, lim, |s| err(s));\n+                    pieces.push(val);\n+                    i = next;\n+                }\n+\n+                h = i;\n+            } else {\n+                i += str::utf8_char_width(s[i]);\n+            }\n+        }\n+\n+        push_slice(&mut pieces, s, h, i);\n+        pieces\n+    }\n+\n+    pub fn peek_num(s: &str, i: uint, lim: uint) -> Option<Parsed<uint>> {\n+        let mut i = i;\n+        let mut accum = 0;\n+        let mut found = false;\n+\n+        while i < lim {\n+            match char::to_digit(s[i] as char, 10) {\n+                Some(x) => {\n+                    found = true;\n+                    accum *= 10;\n+                    accum += x;\n+                    i += 1;\n+                }\n+                None => break\n+            }\n+        }\n+\n+        if found {\n+            Some(Parsed::new(accum, i))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn parse_conversion<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n+                                -> Parsed<Piece> {\n+        let param = parse_parameter(s, i, lim);\n+        // avoid copying ~[Flag] by destructuring\n+        let Parsed {val: flags_val, next: flags_next} = parse_flags(s,\n+            param.next, lim);\n+        let width = parse_count(s, flags_next, lim);\n+        let prec = parse_precision(s, width.next, lim);\n+        let ty = parse_type(s, prec.next, lim, err);\n+\n+        Parsed::new(PieceConv(Conv {\n+            param: param.val,\n+            flags: flags_val,\n+            width: width.val,\n+            precision: prec.val,\n+            ty: ty.val}), ty.next)\n+    }\n+\n+    pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n+        Parsed<Option<uint>> {\n+        if i >= lim { return Parsed::new(None, i); }\n+\n+        match peek_num(s, i, lim) {\n+            Some(num) if num.next < lim && s[num.next] == '$' as u8 =>\n+                Parsed::new(Some(num.val), num.next + 1),\n+            _ => Parsed::new(None, i)\n+        }\n+    }\n+\n+    pub fn parse_flags(s: &str, i: uint, lim: uint) -> Parsed<~[Flag]> {\n+        let mut i = i;\n+        let mut flags = ~[];\n+\n+        while i < lim {\n+            let f = match s[i] as char {\n+                '-' => FlagLeftJustify,\n+                '0' => FlagLeftZeroPad,\n+                ' ' => FlagSpaceForSign,\n+                '+' => FlagSignAlways,\n+                '#' => FlagAlternate,\n+                _ => break\n+            };\n+\n+            flags.push(f);\n+            i += 1;\n+        }\n+\n+        Parsed::new(flags, i)\n+    }\n+\n+    pub fn parse_count(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n+        if i >= lim {\n+            Parsed::new(CountImplied, i)\n+        } else if s[i] == '*' as u8 {\n+            let param = parse_parameter(s, i + 1, lim);\n+            let j = param.next;\n+\n+            match param.val {\n+                None => Parsed::new(CountIsNextParam, j),\n+                Some(n) => Parsed::new(CountIsParam(n), j)\n+            }\n+        } else {\n+            match peek_num(s, i, lim) {\n+                None => Parsed::new(CountImplied, i),\n+                Some(num) => Parsed::new(CountIs(num.val), num.next)\n+            }\n+        }\n+    }\n+\n+    pub fn parse_precision(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n+        if i < lim && s[i] == '.' as u8 {\n+            let count = parse_count(s, i + 1, lim);\n+\n+            // If there were no digits specified, i.e. the precision\n+            // was \".\", then the precision is 0\n+            match count.val {\n+                CountImplied => Parsed::new(CountIs(0), count.next),\n+                _ => count\n+            }\n+        } else {\n+            Parsed::new(CountImplied, i)\n+        }\n+    }\n+\n+    pub fn parse_type<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n+                          -> Parsed<Ty> {\n+        if i >= lim { err(\"missing type in conversion\"); }\n+\n+        // FIXME (#2249): Do we really want two signed types here?\n+        // How important is it to be printf compatible?\n+        let t = match s[i] as char {\n+            'b' => TyBool,\n+            's' => TyStr,\n+            'c' => TyChar,\n+            'd' | 'i' => TyInt(Signed),\n+            'u' => TyInt(Unsigned),\n+            'x' => TyHex(CaseLower),\n+            'X' => TyHex(CaseUpper),\n+            't' => TyBits,\n+            'o' => TyOctal,\n+            'f' => TyFloat,\n+            'p' => TyPointer,\n+            '?' => TyPoly,\n+            _ => err(format!(\"unknown type in conversion: {}\", s.char_at(i)))\n+        };\n+\n+        Parsed::new(t, i + 1)\n+    }\n+\n+    #[cfg(test)]\n+    fn die(s: &str) -> ! { fail2!(s.to_owned()) }\n+\n+    #[test]\n+    fn test_parse_count() {\n+        fn test(s: &str, count: Count, next: uint) -> bool {\n+            parse_count(s, 0, s.len()) == Parsed::new(count, next)\n+        }\n+\n+        assert!(test(\"\", CountImplied, 0));\n+        assert!(test(\"*\", CountIsNextParam, 1));\n+        assert!(test(\"*1\", CountIsNextParam, 1));\n+        assert!(test(\"*1$\", CountIsParam(1), 3));\n+        assert!(test(\"123\", CountIs(123), 3));\n+    }\n+\n+    #[test]\n+    fn test_parse_flags() {\n+        fn pack(fs: &[Flag]) -> uint {\n+            fs.iter().fold(0, |p, &f| p | (1 << f as uint))\n+        }\n+\n+        fn test(s: &str, flags: &[Flag], next: uint) {\n+            let f = parse_flags(s, 0, s.len());\n+            assert_eq!(pack(f.val), pack(flags));\n+            assert_eq!(f.next, next);\n+        }\n+\n+        test(\"\", [], 0);\n+        test(\"!#-+ 0\", [], 0);\n+        test(\"#-+\", [FlagAlternate, FlagLeftJustify, FlagSignAlways], 3);\n+        test(\" 0\", [FlagSpaceForSign, FlagLeftZeroPad], 2);\n+    }\n+\n+    #[test]\n+    fn test_parse_fmt_string() {\n+        assert!(parse_fmt_string(\"foo %s bar\", die) == ~[\n+            PieceString(~\"foo \"),\n+            PieceConv(Conv {\n+                param: None,\n+                flags: ~[],\n+                width: CountImplied,\n+                precision: CountImplied,\n+                ty: TyStr,\n+            }),\n+            PieceString(~\" bar\")]);\n+\n+        assert!(parse_fmt_string(\"%s\", die) == ~[\n+            PieceConv(Conv {\n+                param: None,\n+                flags: ~[],\n+                width: CountImplied,\n+                precision: CountImplied,\n+                ty: TyStr,\n+            })]);\n+\n+        assert!(parse_fmt_string(\"%%%%\", die) == ~[\n+            PieceString(~\"%\"), PieceString(~\"%\")]);\n+    }\n+\n+    #[test]\n+    fn test_parse_parameter() {\n+        fn test(s: &str, param: Option<uint>, next: uint) -> bool {\n+            parse_parameter(s, 0, s.len()) == Parsed::new(param, next)\n+        }\n+\n+        assert!(test(\"\", None, 0));\n+        assert!(test(\"foo\", None, 0));\n+        assert!(test(\"123\", None, 0));\n+        assert!(test(\"123$\", Some(123), 4));\n+    }\n+\n+    #[test]\n+    fn test_parse_precision() {\n+        fn test(s: &str, count: Count, next: uint) -> bool {\n+            parse_precision(s, 0, s.len()) == Parsed::new(count, next)\n+        }\n+\n+        assert!(test(\"\", CountImplied, 0));\n+        assert!(test(\".\", CountIs(0), 1));\n+        assert!(test(\".*\", CountIsNextParam, 2));\n+        assert!(test(\".*1\", CountIsNextParam, 2));\n+        assert!(test(\".*1$\", CountIsParam(1), 4));\n+        assert!(test(\".123\", CountIs(123), 4));\n+    }\n+\n+    #[test]\n+    fn test_parse_type() {\n+        fn test(s: &str, ty: Ty) -> bool {\n+            parse_type(s, 0, s.len(), die) == Parsed::new(ty, 1)\n+        }\n+\n+        assert!(test(\"b\", TyBool));\n+        assert!(test(\"c\", TyChar));\n+        assert!(test(\"d\", TyInt(Signed)));\n+        assert!(test(\"f\", TyFloat));\n+        assert!(test(\"i\", TyInt(Signed)));\n+        assert!(test(\"o\", TyOctal));\n+        assert!(test(\"s\", TyStr));\n+        assert!(test(\"t\", TyBits));\n+        assert!(test(\"x\", TyHex(CaseLower)));\n+        assert!(test(\"X\", TyHex(CaseUpper)));\n+        assert!(test(\"p\", TyPointer));\n+        assert!(test(\"?\", TyPoly));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_parse_type_missing() {\n+        parse_type(\"\", 0, 0, die);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_parse_type_unknown() {\n+        parse_type(\"!\", 0, 1, die);\n+    }\n+\n+    #[test]\n+    fn test_peek_num() {\n+        let s1 = \"\";\n+        assert!(peek_num(s1, 0, s1.len()).is_none());\n+\n+        let s2 = \"foo\";\n+        assert!(peek_num(s2, 0, s2.len()).is_none());\n+\n+        let s3 = \"123\";\n+        assert_eq!(peek_num(s3, 0, s3.len()), Some(Parsed::new(123, 3)));\n+\n+        let s4 = \"123foo\";\n+        assert_eq!(peek_num(s4, 0, s4.len()), Some(Parsed::new(123, 3)));\n+    }\n+}\n+\n+// Functions used by the fmt extension at runtime. For now there are a lot of\n+// decisions made a runtime. If it proves worthwhile then some of these\n+// conditions can be evaluated at compile-time. For now though it's cleaner to\n+// implement it this way, I think.\n+#[doc(hidden)]\n+#[allow(non_uppercase_statics)]\n+pub mod rt {\n+    use f64;\n+    use str;\n+    use sys;\n+    use num;\n+    use vec;\n+    use option::{Some, None, Option};\n+\n+    pub static flag_none : u32 = 0u32;\n+    pub static flag_left_justify   : u32 = 0b00000000000001u32;\n+    pub static flag_left_zero_pad  : u32 = 0b00000000000010u32;\n+    pub static flag_space_for_sign : u32 = 0b00000000000100u32;\n+    pub static flag_sign_always    : u32 = 0b00000000001000u32;\n+    pub static flag_alternate      : u32 = 0b00000000010000u32;\n+\n+    pub enum Count { CountIs(uint), CountImplied, }\n+\n+    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+\n+    pub struct Conv {\n+        // all ade by reedlepee\n+        flags: u32,\n+        width: Count,\n+        precision: Count,\n+        ty: Ty,\n+    }\n+\n+    pub fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n+        let radix = 10;\n+        let prec = get_int_precision(cv);\n+        let s : ~str = uint_to_str_prec(num::abs(i) as uint, radix, prec);\n+\n+        let head = if i >= 0 {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                Some('+')\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                Some(' ')\n+            } else {\n+                None\n+            }\n+        } else { Some('-') };\n+        pad(cv, s, head, PadSigned, buf);\n+    }\n+    pub fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n+        let prec = get_int_precision(cv);\n+        let rs =\n+            match cv.ty {\n+              TyDefault => uint_to_str_prec(u, 10, prec),\n+              TyHexLower => uint_to_str_prec(u, 16, prec),\n+\n+              // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n+              // to_ascii_move and to_str_move to not do a unnecessary copy.\n+              TyHexUpper => {\n+                let s = uint_to_str_prec(u, 16, prec);\n+                s.to_ascii().to_upper().to_str_ascii()\n+              }\n+              TyBits => uint_to_str_prec(u, 2, prec),\n+              TyOctal => uint_to_str_prec(u, 8, prec)\n+            };\n+        pad(cv, rs, None, PadUnsigned, buf);\n+    }\n+    pub fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n+        let s = if b { \"true\" } else { \"false\" };\n+        // run the boolean conversion through the string conversion logic,\n+        // giving it the same rules for precision, etc.\n+        conv_str(cv, s, buf);\n+    }\n+    pub fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n+        pad(cv, \"\", Some(c), PadNozero, buf);\n+    }\n+    pub fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n+        // For strings, precision is the maximum characters\n+        // displayed\n+        let unpadded = match cv.precision {\n+            CountImplied => s,\n+            CountIs(max) => {\n+                if (max as uint) < s.char_len() {\n+                    s.slice(0, max as uint)\n+                } else {\n+                    s\n+                }\n+            }\n+        };\n+        pad(cv, unpadded, None, PadNozero, buf);\n+    }\n+    pub fn conv_float(cv: Conv, f: f64, buf: &mut ~str) {\n+        let (to_str, digits) = match cv.precision {\n+              CountIs(c) => (f64::to_str_exact, c as uint),\n+              CountImplied => (f64::to_str_digits, 6u)\n+        };\n+        let s = to_str(f, digits);\n+        let head = if 0.0 <= f {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                Some('+')\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                Some(' ')\n+            } else {\n+                None\n+            }\n+        } else { None };\n+        pad(cv, s, head, PadFloat, buf);\n+    }\n+    pub fn conv_pointer<T>(cv: Conv, ptr: *T, buf: &mut ~str) {\n+        let s = ~\"0x\" + uint_to_str_prec(ptr as uint, 16, 1u);\n+        pad(cv, s, None, PadNozero, buf);\n+    }\n+    pub fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n+        let s = sys::log_str(v);\n+        conv_str(cv, s, buf);\n+    }\n+\n+    // Convert a uint to string with a minimum number of digits.  If precision\n+    // is 0 and num is 0 then the result is the empty string. Could move this\n+    // to uint: but it doesn't seem all that useful.\n+    pub fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n+        return if prec == 0u && num == 0u {\n+                ~\"\"\n+            } else {\n+                let s = num.to_str_radix(radix);\n+                let len = s.char_len();\n+                if len < prec {\n+                    let diff = prec - len;\n+                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n+                    pad + s\n+                } else { s }\n+            };\n+    }\n+    pub fn get_int_precision(cv: Conv) -> uint {\n+        return match cv.precision {\n+              CountIs(c) => c as uint,\n+              CountImplied => 1u\n+            };\n+    }\n+\n+    #[deriving(Eq)]\n+    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n+\n+    pub fn pad(cv: Conv, s: &str, head: Option<char>, mode: PadMode,\n+               buf: &mut ~str) {\n+        let headsize = match head { Some(_) => 1, _ => 0 };\n+        let uwidth : uint = match cv.width {\n+            CountImplied => {\n+                for &c in head.iter() {\n+                    buf.push_char(c);\n+                }\n+                return buf.push_str(s);\n+            }\n+            CountIs(width) => { width as uint }\n+        };\n+        let strlen = s.char_len() + headsize;\n+        if uwidth <= strlen {\n+            for &c in head.iter() {\n+                buf.push_char(c);\n+            }\n+            return buf.push_str(s);\n+        }\n+        let mut padchar = ' ';\n+        let diff = uwidth - strlen;\n+        if have_flag(cv.flags, flag_left_justify) {\n+            for &c in head.iter() {\n+                buf.push_char(c);\n+            }\n+            buf.push_str(s);\n+            do diff.times {\n+                buf.push_char(padchar);\n+            }\n+            return;\n+        }\n+        let (might_zero_pad, signed) = match mode {\n+          PadNozero   => (false, true),\n+          PadSigned   => (true, true),\n+          PadFloat    => (true, true),\n+          PadUnsigned => (true, false)\n+        };\n+        fn have_precision(cv: Conv) -> bool {\n+            return match cv.precision { CountImplied => false, _ => true };\n+        }\n+        let zero_padding = {\n+            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+                (!have_precision(cv) || mode == PadFloat) {\n+                padchar = '0';\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n+        // This is completely heinous. If we have a signed value then\n+        // potentially rip apart the intermediate result and insert some\n+        // zeros. It may make sense to convert zero padding to a precision\n+        // instead.\n+\n+        if signed && zero_padding {\n+            for &head in head.iter() {\n+                if head == '+' || head == '-' || head == ' ' {\n+                    buf.push_char(head);\n+                    buf.push_str(padstr);\n+                    buf.push_str(s);\n+                    return;\n+                }\n+            }\n+        }\n+        buf.push_str(padstr);\n+        for &c in head.iter() {\n+            buf.push_char(c);\n+        }\n+        buf.push_str(s);\n+    }\n+    #[inline]\n+    pub fn have_flag(flags: u32, f: u32) -> bool {\n+        flags & f != 0\n+    }\n+}\n+\n+// Bulk of the tests are in src/test/run-pass/syntax-extension-fmt.rs\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn fmt_slice() {\n+        let s = \"abc\";\n+        let _s = format!(\"{}\", s);\n+    }\n+}"}, {"sha": "9c216470f17aac44aeadc1bffa8d2001b433cefd", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -42,30 +42,31 @@ pub type GlueFn = extern \"Rust\" fn(*i8);\n #[lang=\"ty_desc\"]\n #[cfg(not(test))]\n pub struct TyDesc {\n+    // all ade by reedlepee\n     // sizeof(T)\n-    size: uint,\n+     size: uint,\n \n     // alignof(T)\n     align: uint,\n \n     // Called on a copy of a value of type `T` *after* memcpy\n-    take_glue: GlueFn,\n+    priv take_glue: GlueFn,\n \n     // Called when a value of type `T` is no longer needed\n     drop_glue: GlueFn,\n \n     // Called by drop glue when a value of type `T` can be freed\n-    free_glue: GlueFn,\n+    priv free_glue: GlueFn,\n \n     // Called by reflection visitor to visit a value of type `T`\n-    visit_glue: GlueFn,\n+    priv visit_glue: GlueFn,\n \n     // If T represents a box pointer (`@U` or `~U`), then\n     // `borrow_offset` is the amount that the pointer must be adjusted\n     // to find the payload.  This is always derivable from the type\n     // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n     // `U` is unknown.\n-    borrow_offset: uint,\n+    priv borrow_offset: uint,\n \n     // Name corresponding to the type\n     name: &'static str"}, {"sha": "ae9095e1b5fe481bf5d51974e8dde567670d2a0d", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -13,15 +13,17 @@ use unstable::intrinsics::TyDesc;\n \n /// The representation of a Rust managed box\n pub struct Box<T> {\n+    // all ade by reedlepee\n     ref_count: uint,\n     type_desc: *TyDesc,\n-    prev: *Box<T>,\n+    priv prev: *Box<T>,\n     next: *Box<T>,\n     data: T\n }\n \n /// The representation of a Rust vector\n pub struct Vec<T> {\n+    // all ade by reedlepee\n     fill: uint,\n     alloc: uint,\n     data: T\n@@ -32,12 +34,14 @@ pub type String = Vec<u8>;\n \n /// The representation of a Rust slice\n pub struct Slice<T> {\n+    // all ade by reedlepee\n     data: *T,\n     len: uint\n }\n \n /// The representation of a Rust closure\n pub struct Closure {\n+    // all ade by reedlepee\n     code: *(),\n     env: *(),\n }"}, {"sha": "f6363c45021f662ca189bd17410d12da263b2a91", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -28,6 +28,7 @@ use vec;\n /// Enforces no shared-memory safety.\n //#[unsafe_no_drop_flag] FIXME: #9758\n pub struct UnsafeArc<T> {\n+    // all ade by reedlepee\n     data: *mut ArcData<T>,\n }\n \n@@ -304,7 +305,8 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n type rust_little_lock = *libc::c_void;\n \n pub struct LittleLock {\n-    l: rust_little_lock,\n+    // all ade by reedlepee\n+    priv l: rust_little_lock,\n }\n \n impl Drop for LittleLock {\n@@ -353,7 +355,8 @@ struct ExData<T> {\n  * need to block or deschedule while accessing shared state, use extra::sync::RWArc.\n  */\n pub struct Exclusive<T> {\n-    x: UnsafeArc<ExData<T>>\n+    // all ade by reedlepee\n+    priv x: UnsafeArc<ExData<T>>\n }\n \n impl<T:Send> Clone for Exclusive<T> {"}, {"sha": "7ceb8d201ab724521d0b0004003db588255fc70e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0ada7c7ffe453b9df849996f8dca0b8d0f2d9e62", "patch": "@@ -216,6 +216,7 @@ pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n pub struct SplitIterator<'self, T> {\n+    // already priv\n     priv v: &'self [T],\n     priv n: uint,\n     priv pred: &'self fn(t: &T) -> bool,\n@@ -265,6 +266,7 @@ impl<'self, T> Iterator<&'self [T]> for SplitIterator<'self, T> {\n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function, from back to front.\n pub struct RSplitIterator<'self, T> {\n+    // already priv\n     priv v: &'self [T],\n     priv n: uint,\n     priv pred: &'self fn(t: &T) -> bool,\n@@ -403,6 +405,7 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n pub struct ElementSwaps {\n+    // already priv\n     priv sdir: ~[SizeDirection],\n     /// If true, emit the last swap that returns the sequence to initial state\n     priv emit_reset: bool,\n@@ -478,6 +481,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n ///\n /// Generates even and odd permutations alternatingly.\n pub struct Permutations<T> {\n+    // already priv\n     priv swaps: ElementSwaps,\n     priv v: ~[T],\n }\n@@ -500,6 +504,7 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n /// a vector.\n #[deriving(Clone)]\n pub struct WindowIter<'self, T> {\n+    // already priv\n     priv v: &'self [T],\n     priv size: uint\n }\n@@ -534,6 +539,7 @@ impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n /// the last slice of the iteration will be the remainder.\n #[deriving(Clone)]\n pub struct ChunkIter<'self, T> {\n+    // already priv\n     priv v: &'self [T],\n     priv size: uint\n }\n@@ -2393,6 +2399,7 @@ impl<'self, T> RandomAccessIterator<&'self T> for VecIterator<'self, T> {\n //iterator!{struct VecIterator -> *T, &'self T}\n /// An iterator for iterating over a vector.\n pub struct VecIterator<'self, T> {\n+    // already priv\n     priv ptr: *T,\n     priv end: *T,\n     priv lifetime: Option<&'self ()> // FIXME: #5922\n@@ -2411,6 +2418,7 @@ impl<'self, T> Clone for VecIterator<'self, T> {\n //iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n /// An iterator for mutating the elements of a vector.\n pub struct VecMutIterator<'self, T> {\n+    // already priv\n     priv ptr: *mut T,\n     priv end: *mut T,\n     priv lifetime: Option<&'self mut ()> // FIXME: #5922\n@@ -2422,6 +2430,7 @@ pub type MutRevIterator<'self, T> = Invert<VecMutIterator<'self, T>>;\n /// An iterator that moves out of a vector.\n #[deriving(Clone)]\n pub struct MoveIterator<T> {\n+    // already priv\n     priv v: ~[T],\n     priv idx: uint,\n }\n@@ -2456,6 +2465,7 @@ impl<T> Iterator<T> for MoveIterator<T> {\n /// An iterator that moves out of a vector in reverse order.\n #[deriving(Clone)]\n pub struct MoveRevIterator<T> {\n+    // already priv\n     priv v: ~[T]\n }\n "}]}