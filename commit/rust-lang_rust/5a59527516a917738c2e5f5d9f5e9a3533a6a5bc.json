{"sha": "5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNTk1Mjc1MTZhOTE3NzM4YzJlNWY1ZDlmNWU5YTM1MzNhNmE1YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-24T04:14:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-24T04:14:20Z"}, "message": "Auto merge of #71215 - marmeladema:issue70853/librustc_middle-local-def-id-2, r=eddyb\n\nSimplify `local_def_id` and `as_local_hir_id`\n\nSee #70853", "tree": {"sha": "932a300c5ae5a293eb8834fe4feac7a00df946c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/932a300c5ae5a293eb8834fe4feac7a00df946c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "html_url": "https://github.com/rust-lang/rust/commit/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45c7838089576552391237bb41cdd3d46582d3e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/45c7838089576552391237bb41cdd3d46582d3e5", "html_url": "https://github.com/rust-lang/rust/commit/45c7838089576552391237bb41cdd3d46582d3e5"}, {"sha": "b9ba521e955e1fd87052c75e081b3c05df47cf04", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9ba521e955e1fd87052c75e081b3c05df47cf04", "html_url": "https://github.com/rust-lang/rust/commit/b9ba521e955e1fd87052c75e081b3c05df47cf04"}], "stats": {"total": 2069, "additions": 1082, "deletions": 987}, "files": [{"sha": "6ad75cff3ddb6be9af1c8cced0c99c0f50930e60", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -116,7 +116,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n                 if cx.tcx.sess.opts.share_generics() {\n                     // We are in share_generics mode.\n \n-                    if instance_def_id.is_local() {\n+                    if let Some(instance_def_id) = instance_def_id.as_local() {\n                         // This is a definition from the current crate. If the\n                         // definition is unreachable for downstream crates or\n                         // the current crate does not re-export generics, the"}, {"sha": "43ced8ee5b13cdf094120b37538a50c5175ecdbb", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -209,7 +209,8 @@ impl CodegenCx<'ll, 'tcx> {\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n-        let g = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n+        let g = if let Some(def_id) = def_id.as_local() {\n+            let id = self.tcx.hir().as_local_hir_id(def_id);\n             let llty = self.layout_of(ty).llvm_type(self);\n             let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item { attrs, span, kind: hir::ItemKind::Static(..), .. }) => {"}, {"sha": "9faddf254d7e53835d1d163c98b6eb08f88d4252", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -96,7 +96,7 @@ fn reachable_non_generics_provider(\n                     if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever codegened\n                         // with \"internal\" linkage and are never exported.\n-                        !Instance::mono(tcx, def_id).def.generates_cgu_internal_copy(tcx)\n+                        !Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n                     {\n                         Some(def_id)\n                     } else {\n@@ -109,7 +109,7 @@ fn reachable_non_generics_provider(\n         })\n         .map(|def_id| {\n             let export_level = if special_runtime_crate {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id)).name.as_str();\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name.as_str();\n                 // We can probably do better here by just ensuring that\n                 // it has hidden visibility rather than public\n                 // visibility, as this is primarily here to ensure it's\n@@ -126,14 +126,14 @@ fn reachable_non_generics_provider(\n                     SymbolExportLevel::Rust\n                 }\n             } else {\n-                symbol_export_level(tcx, def_id)\n+                symbol_export_level(tcx, def_id.to_def_id())\n             };\n             debug!(\n                 \"EXPORTED SYMBOL (local): {} ({:?})\",\n-                tcx.symbol_name(Instance::mono(tcx, def_id)),\n+                tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())),\n                 export_level\n             );\n-            (def_id, export_level)\n+            (def_id.to_def_id(), export_level)\n         })\n         .collect();\n \n@@ -361,8 +361,8 @@ fn upstream_drop_glue_for_provider<'tcx>(\n }\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-        !tcx.reachable_set(LOCAL_CRATE).contains(&hir_id)\n+    if let Some(def_id) = def_id.as_local() {\n+        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().as_local_hir_id(def_id))\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\", def_id)\n     }"}, {"sha": "610e9b9051040eb576ca2c391f8c8e6e233e711d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -322,7 +322,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n \n     fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id)))\n+        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()))\n     }\n }\n "}, {"sha": "033c2973af6eec8245b00de80d91a76e5cc559e2", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -342,12 +342,8 @@ impl Definitions {\n     }\n \n     #[inline]\n-    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<hir::HirId> {\n-        if let Some(def_id) = def_id.as_local() {\n-            Some(self.local_def_id_to_hir_id(def_id))\n-        } else {\n-            None\n-        }\n+    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n+        self.local_def_id_to_hir_id(def_id)\n     }\n \n     #[inline]"}, {"sha": "673d6e92b7ee3fb78dcbf78a54c2273e80e26fe8", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -115,7 +115,7 @@ impl IfThisChanged<'tcx> {\n \n     fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n-        let def_path_hash = self.tcx.def_path_hash(def_id);\n+        let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n         for attr in attrs {\n             if attr.check_name(sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n@@ -131,7 +131,7 @@ impl IfThisChanged<'tcx> {\n                         }\n                     },\n                 };\n-                self.if_this_changed.push((attr.span, def_id, dep_node));\n+                self.if_this_changed.push((attr.span, def_id.to_def_id(), dep_node));\n             } else if attr.check_name(sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {"}, {"sha": "27aebf7b1b98df772db5d53ee63c66425403c119", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -434,16 +434,16 @@ impl DirtyCleanVisitor<'tcx> {\n \n     fn check_item(&mut self, item_id: hir::HirId, item_span: Span) {\n         let def_id = self.tcx.hir().local_def_id(item_id);\n-        for attr in self.tcx.get_attrs(def_id).iter() {\n+        for attr in self.tcx.get_attrs(def_id.to_def_id()).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n                 None => continue,\n             };\n             self.checked_attrs.insert(attr.id);\n-            for dep_node in self.dep_nodes(&assertion.clean, def_id) {\n+            for dep_node in self.dep_nodes(&assertion.clean, def_id.to_def_id()) {\n                 self.assert_clean(item_span, dep_node);\n             }\n-            for dep_node in self.dep_nodes(&assertion.dirty, def_id) {\n+            for dep_node in self.dep_nodes(&assertion.dirty, def_id.to_def_id()) {\n                 self.assert_dirty(item_span, dep_node);\n             }\n         }"}, {"sha": "dd1d08a75ae198f4c308f70090cb51cff34728a1", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -191,7 +191,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     let sm = tcx.sess.source_map();\n \n     let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().as_local_hir_id(scope).unwrap();\n+    let node = tcx.hir().as_local_hir_id(scope.expect_local());\n     let tag = match tcx.hir().find(node) {\n         Some(Node::Block(_) | Node::Expr(_)) => \"body\",\n         Some(Node::Item(it)) => item_scope_tag(&it),\n@@ -1782,10 +1782,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n-                        hir.as_local_hir_id(type_param.def_id).map(|id| {\n+                        type_param.def_id.as_local().map(|def_id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n+                            let id = hir.as_local_hir_id(def_id);\n                             let mut has_bounds = false;\n                             if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();"}, {"sha": "190a2dcc556e91ad15dcda4f1b4cb4c9ce9e9eaf", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -29,7 +29,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ) -> Option<(&hir::Ty<'_>, &hir::FnDecl<'_>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n-            if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n+            if let Some(def_id) = def_id.as_local() {\n+                let hir_id = self.tcx().hir().as_local_hir_id(def_id);\n                 let fndecl = match self.tcx().hir().get(hir_id) {\n                     Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n                     | Node::TraitItem(&hir::TraitItem {"}, {"sha": "fc858a497597e5bad0f2e02bd935c33089a201d5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -46,7 +46,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ) = (&sub_origin, sup_region)\n             {\n                 let hir = &self.tcx().hir();\n-                if let Some(hir_id) = hir.as_local_hir_id(free_region.scope) {\n+                if let Some(def_id) = free_region.scope.as_local() {\n+                    let hir_id = hir.as_local_hir_id(def_id);\n                     if let Node::Expr(Expr { kind: Closure(_, _, _, closure_span, None), .. }) =\n                         hir.get(hir_id)\n                     {"}, {"sha": "5c45f7584360698a41037ef8b102bb7c1312fc7c", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        let hir_id = hir.as_local_hir_id(id)?;\n+        let hir_id = hir.as_local_hir_id(id.as_local()?);\n         let body_id = hir.maybe_body_owned_by(hir_id)?;\n         let body = hir.body(body_id);\n         let owner_id = hir.body_owner(body_id);"}, {"sha": "c74cba81ca9079017c16b132a20959af5505a429", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -16,7 +16,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     let mut finder = Finder { decls: None };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n-    finder.decls.map(|id| tcx.hir().local_def_id(id))\n+    finder.decls.map(|id| tcx.hir().local_def_id(id).to_def_id())\n }\n \n struct Finder {"}, {"sha": "cad6a312521e4ceac0c25296c6851ebea7e8b119", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -436,7 +436,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n-                if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n+                if let Some(def_id) = real_trait.as_local() {\n+                    let hir_id = cx.tcx.hir().as_local_hir_id(def_id);\n                     if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n                         if let hir::VisibilityKind::Inherited = item.vis.node {\n                             for impl_item_ref in items {\n@@ -461,7 +462,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         };\n \n         let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n \n         self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, article, desc);\n     }\n@@ -472,7 +473,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n \n         let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n \n         self.check_missing_docs_attrs(\n             cx,\n@@ -491,7 +492,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n \n         let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n         self.check_missing_docs_attrs(\n             cx,\n             Some(impl_item.hir_id),\n@@ -609,8 +610,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             let mut impls = HirIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(ty_def.did) {\n-                        impls.insert(hir_id);\n+                    if let Some(def_id) = ty_def.did.as_local() {\n+                        impls.insert(cx.tcx.hir().as_local_hir_id(def_id));\n                     }\n                 }\n             });\n@@ -1531,7 +1532,8 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         ty_generics: &'tcx ty::Generics,\n     ) -> Vec<ty::Region<'tcx>> {\n-        let index = ty_generics.param_def_id_to_index[&tcx.hir().local_def_id(param.hir_id)];\n+        let index =\n+            ty_generics.param_def_id_to_index[&tcx.hir().local_def_id(param.hir_id).to_def_id()];\n \n         match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => {"}, {"sha": "c4ac875fec537158044082c8fa8034edf90e9d5a", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -19,7 +19,7 @@ use rustc_ast::ast;\n use rustc_ast::walk_list;\n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit as hir_visit;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::map::Map;\n@@ -353,7 +353,7 @@ crate::late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n+    module_def_id: LocalDefId,\n     pass: T,\n ) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n@@ -364,7 +364,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_store: unerased_lint_store(tcx),\n-        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n+        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id),\n         generics: None,\n         only_module: true,\n     };\n@@ -382,7 +382,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n+    module_def_id: LocalDefId,\n     builtin_lints: T,\n ) {\n     if tcx.sess.opts.debugging_opts.no_interleave_lints {"}, {"sha": "1041ad0186681dc3aa86d3887106820e118b994e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -91,7 +91,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn lint_mod(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n+    late::late_lint_mod(\n+        tcx,\n+        module_def_id.expect_local(),\n+        BuiltinCombinedModuleLateLintPass::new(),\n+    );\n }\n \n macro_rules! pre_expansion_lint_passes {"}, {"sha": "8675197656a48f14f58c59b148ede9bab6b489c3", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -22,9 +22,11 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         };\n \n         let foreign_items =\n-            fm.items.iter().map(|it| self.tcx.hir().local_def_id(it.hir_id)).collect();\n-        self.modules\n-            .push(ForeignModule { foreign_items, def_id: self.tcx.hir().local_def_id(it.hir_id) });\n+            fm.items.iter().map(|it| self.tcx.hir().local_def_id(it.hir_id).to_def_id()).collect();\n+        self.modules.push(ForeignModule {\n+            foreign_items,\n+            def_id: self.tcx.hir().local_def_id(it.hir_id).to_def_id(),\n+        });\n     }\n \n     fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}"}, {"sha": "51c9950a5dfedd1ba40f382fe67802f736836384", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -51,7 +51,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 name: None,\n                 kind: cstore::NativeUnknown,\n                 cfg: None,\n-                foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id)),\n+                foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id).to_def_id()),\n                 wasm_import_module: None,\n             };\n             let mut kind_specified = false;"}, {"sha": "746ce1a28cb62feffa65f01e51bfd3eced15797f", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -605,9 +605,8 @@ impl EncodeContext<'tcx> {\n         record!(self.tables.ty[def_id] <- self.tcx.type_of(def_id));\n     }\n \n-    fn encode_enum_variant_info(&mut self, enum_did: DefId, index: VariantIdx) {\n+    fn encode_enum_variant_info(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n         let tcx = self.tcx;\n-        let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.def_id;\n         debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n@@ -618,7 +617,7 @@ impl EncodeContext<'tcx> {\n             ctor: variant.ctor_def_id.map(|did| did.index),\n         };\n \n-        let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local());\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n@@ -649,9 +648,8 @@ impl EncodeContext<'tcx> {\n         self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_enum_variant_ctor(&mut self, enum_did: DefId, index: VariantIdx) {\n+    fn encode_enum_variant_ctor(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n         let tcx = self.tcx;\n-        let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n@@ -665,7 +663,7 @@ impl EncodeContext<'tcx> {\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n         // non-exhaustive, in which case they are lowered to `pub(crate)`.\n-        let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local());\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n         if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n@@ -697,7 +695,7 @@ impl EncodeContext<'tcx> {\n         vis: &hir::Visibility<'_>,\n     ) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id).to_def_id();\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n@@ -712,21 +710,26 @@ impl EncodeContext<'tcx> {\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- attrs);\n         record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n-            tcx.hir().local_def_id(item_id.id).index\n+            tcx.hir().local_def_id(item_id.id).local_def_index\n         }));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n \n-    fn encode_field(&mut self, adt_def_id: DefId, variant_index: VariantIdx, field_index: usize) {\n+    fn encode_field(\n+        &mut self,\n+        adt_def: &ty::AdtDef,\n+        variant_index: VariantIdx,\n+        field_index: usize,\n+    ) {\n         let tcx = self.tcx;\n-        let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n+        let variant = &adt_def.variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n         debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n+        let variant_id = tcx.hir().as_local_hir_id(variant.def_id.expect_local());\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n@@ -742,10 +745,9 @@ impl EncodeContext<'tcx> {\n         self.encode_inferred_outlives(def_id);\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n+    fn encode_struct_ctor(&mut self, adt_def: &ty::AdtDef, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n-        let adt_def = tcx.adt_def(adt_def_id);\n         let variant = adt_def.non_enum_variant();\n \n         let data = VariantData {\n@@ -754,7 +756,7 @@ impl EncodeContext<'tcx> {\n             ctor: Some(def_id.index),\n         };\n \n-        let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n+        let struct_id = tcx.hir().as_local_hir_id(adt_def.did.expect_local());\n         let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n@@ -816,7 +818,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let ast_item = tcx.hir().expect_trait_item(hir_id);\n         let trait_item = tcx.associated_item(def_id);\n \n@@ -907,7 +909,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n         let ast_item = self.tcx.hir().expect_impl_item(hir_id);\n         let impl_item = self.tcx.associated_item(def_id);\n \n@@ -1101,7 +1103,7 @@ impl EncodeContext<'tcx> {\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n                 let ctor = struct_def.ctor_hir_id().map(|ctor_hir_id| {\n-                    self.tcx.hir().local_def_id(ctor_hir_id).index\n+                    self.tcx.hir().local_def_id(ctor_hir_id).local_def_index\n                 });\n \n                 EntryKind::Struct(self.lazy(VariantData {\n@@ -1182,7 +1184,7 @@ impl EncodeContext<'tcx> {\n                 fm.items\n                     .iter()\n                     .map(|foreign_item| tcx.hir().local_def_id(\n-                        foreign_item.hir_id).index)\n+                        foreign_item.hir_id).local_def_index)\n             ),\n             hir::ItemKind::Enum(..) => record!(self.tables.children[def_id] <-\n                 self.tcx.adt_def(def_id).variants.iter().map(|v| {\n@@ -1287,7 +1289,7 @@ impl EncodeContext<'tcx> {\n \n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n-        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n         record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id] <- macro_def.span);\n@@ -1306,14 +1308,15 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_info_for_closure(&mut self, def_id: DefId) {\n+    fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n         // including on the signature, which is inferred in `typeck_tables_of.\n-        let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n         let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n+        let def_id = def_id.to_def_id();\n         record!(self.tables.kind[def_id] <- match ty.kind {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n@@ -1336,11 +1339,12 @@ impl EncodeContext<'tcx> {\n         self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_info_for_anon_const(&mut self, def_id: DefId) {\n+    fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let id = self.tcx.hir().as_local_hir_id(def_id);\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n+        let def_id = def_id.to_def_id();\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Const(qualifs, const_data));\n@@ -1573,14 +1577,14 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(def_id, item),\n+            _ => self.encode_info_for_item(def_id.to_def_id(), item),\n         }\n         self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n-        self.encode_info_for_foreign_item(def_id, ni);\n+        self.encode_info_for_foreign_item(def_id.to_def_id(), ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         intravisit::walk_generics(self, generics);\n@@ -1592,13 +1596,10 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_fields(&mut self, adt_def_id: DefId) {\n-        let def = self.tcx.adt_def(adt_def_id);\n-        for (variant_index, variant) in def.variants.iter_enumerated() {\n+    fn encode_fields(&mut self, adt_def: &ty::AdtDef) {\n+        for (variant_index, variant) in adt_def.variants.iter_enumerated() {\n             for (field_index, _field) in variant.fields.iter().enumerate() {\n-                // FIXME(eddyb) `adt_def_id` is leftover from incremental isolation,\n-                // pass `def`, `variant` or `field` instead.\n-                self.encode_field(adt_def_id, variant_index, field_index);\n+                self.encode_field(adt_def, variant_index, field_index);\n             }\n         }\n     }\n@@ -1610,13 +1611,17 @@ impl EncodeContext<'tcx> {\n                 GenericParamKind::Lifetime { .. } => continue,\n                 GenericParamKind::Type { ref default, .. } => {\n                     self.encode_info_for_generic_param(\n-                        def_id,\n+                        def_id.to_def_id(),\n                         EntryKind::TypeParam,\n                         default.is_some(),\n                     );\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n+                    self.encode_info_for_generic_param(\n+                        def_id.to_def_id(),\n+                        EntryKind::ConstParam,\n+                        true,\n+                    );\n                 }\n             }\n         }\n@@ -1654,40 +1659,40 @@ impl EncodeContext<'tcx> {\n                 // no sub-item recording needed in these cases\n             }\n             hir::ItemKind::Enum(..) => {\n-                self.encode_fields(def_id);\n+                let def = self.tcx.adt_def(def_id.to_def_id());\n+                self.encode_fields(def);\n \n-                let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n-                    // pass `def` or `variant` instead.\n-                    self.encode_enum_variant_info(def_id, i);\n+                    self.encode_enum_variant_info(def, i);\n \n-                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n-                    // pass `def`, `variant` or `ctor_def_id` instead.\n                     if let Some(_ctor_def_id) = variant.ctor_def_id {\n-                        self.encode_enum_variant_ctor(def_id, i);\n+                        self.encode_enum_variant_ctor(def, i);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                self.encode_fields(def_id);\n+                let def = self.tcx.adt_def(def_id.to_def_id());\n+                self.encode_fields(def);\n \n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n-                    self.encode_struct_ctor(def_id, ctor_def_id);\n+                    self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n                 }\n             }\n             hir::ItemKind::Union(..) => {\n-                self.encode_fields(def_id);\n+                let def = self.tcx.adt_def(def_id.to_def_id());\n+                self.encode_fields(def);\n             }\n             hir::ItemKind::Impl { .. } => {\n-                for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                for &trait_item_def_id in\n+                    self.tcx.associated_item_def_ids(def_id.to_def_id()).iter()\n+                {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                for &item_def_id in self.tcx.associated_item_def_ids(def_id.to_def_id()).iter() {\n                     self.encode_info_for_trait_item(item_def_id);\n                 }\n             }\n@@ -1704,8 +1709,8 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n-                self.impls.entry(trait_ref.def_id).or_default().push(impl_id.index);\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id.to_def_id()) {\n+                self.impls.entry(trait_ref.def_id).or_default().push(impl_id.local_def_index);\n             }\n         }\n     }\n@@ -1725,7 +1730,8 @@ struct PrefetchVisitor<'tcx> {\n }\n \n impl<'tcx> PrefetchVisitor<'tcx> {\n-    fn prefetch_mir(&self, def_id: DefId) {\n+    fn prefetch_mir(&self, def_id: LocalDefId) {\n+        let def_id = def_id.to_def_id();\n         if self.mir_keys.contains(&def_id) {\n             self.tcx.optimized_mir(def_id);\n             self.tcx.promoted_mir(def_id);\n@@ -1743,9 +1749,9 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ItemKind::Fn(ref sig, ..) => {\n                 let def_id = tcx.hir().local_def_id(item.hir_id);\n-                let generics = tcx.generics_of(def_id);\n+                let generics = tcx.generics_of(def_id.to_def_id());\n                 let needs_inline = generics.requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline();\n+                    || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n                 if needs_inline || sig.header.constness == hir::Constness::Const {\n                     self.prefetch_mir(def_id)\n                 }\n@@ -1768,9 +1774,9 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ImplItemKind::Fn(ref sig, _) => {\n                 let def_id = tcx.hir().local_def_id(impl_item.hir_id);\n-                let generics = tcx.generics_of(def_id);\n+                let generics = tcx.generics_of(def_id.to_def_id());\n                 let needs_inline = generics.requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline();\n+                    || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n                 if needs_inline || is_const_fn {\n                     self.prefetch_mir(def_id)"}, {"sha": "4786426792c3d2555dbbb3ab1c4cfa014e996308", "filename": "src/librustc_middle/dep_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n \n mod dep_node;\n \n@@ -106,7 +106,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         match dep_node.kind {\n             DepKind::hir_owner | DepKind::hir_owner_nodes | DepKind::CrateMetadata => {\n                 if let Some(def_id) = dep_node.extract_def_id(*self) {\n-                    if def_id_corresponds_to_hir_dep_node(*self, def_id) {\n+                    if def_id_corresponds_to_hir_dep_node(*self, def_id.expect_local()) {\n                         if dep_node.kind == DepKind::CrateMetadata {\n                             // The `DefPath` has corresponding node,\n                             // and that node should have been marked\n@@ -180,7 +180,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     }\n }\n \n-fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    def_id.index == hir_id.owner.local_def_index\n+fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    def_id == hir_id.owner\n }"}, {"sha": "aee80b6e14e1441f85d8befeaeaa4e32f5476c34", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -171,16 +171,14 @@ impl<'hir> Map<'hir> {\n \n     // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n-    pub fn local_def_id(&self, hir_id: HirId) -> DefId {\n-        self.opt_local_def_id(hir_id)\n-            .unwrap_or_else(|| {\n-                bug!(\n-                    \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n-                    hir_id,\n-                    self.find_entry(hir_id)\n-                )\n-            })\n-            .to_def_id()\n+    pub fn local_def_id(&self, hir_id: HirId) -> LocalDefId {\n+        self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n+            bug!(\n+                \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n+                hir_id,\n+                self.find_entry(hir_id)\n+            )\n+        })\n     }\n \n     #[inline]\n@@ -200,7 +198,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.tcx.definitions.as_local_hir_id(def_id)\n     }\n \n@@ -378,7 +376,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> LocalDefId {\n-        self.local_def_id(self.body_owner(id)).expect_local()\n+        self.local_def_id(self.body_owner(id))\n     }\n \n     /// Given a `HirId`, returns the `BodyId` associated with it,\n@@ -450,8 +448,8 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod<'hir>, Span, HirId) {\n-        let hir_id = self.as_local_hir_id(module).unwrap();\n+    pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n+        let hir_id = self.as_local_hir_id(module);\n         match self.get_entry(hir_id).node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n             Node::Crate(item) => (&item.module, item.span, hir_id),\n@@ -484,7 +482,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        self.as_local_hir_id(id).map(|id| self.get(id))\n+        id.as_local().map(|id| self.get(self.as_local_hir_id(id)))\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n@@ -729,7 +727,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_did(&self, id: HirId) -> LocalDefId {\n-        self.local_def_id(self.get_parent_item(id)).expect_local()\n+        self.local_def_id(self.get_parent_item(id))\n     }\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n@@ -885,7 +883,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n-        self.as_local_hir_id(id).map(|id| self.span(id))\n+        id.as_local().map(|id| self.span(self.as_local_hir_id(id)))\n     }\n \n     pub fn res_span(&self, res: Res) -> Option<Span> {\n@@ -995,7 +993,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n                 let def_id = map.local_def_id(id);\n-                tcx.def_path_str(def_id)\n+                tcx.def_path_str(def_id.to_def_id())\n             } else if let Some(path) = map.def_path_from_hir_id(id) {\n                 path.data\n                     .into_iter()\n@@ -1084,11 +1082,6 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    providers.def_kind = |tcx, def_id| {\n-        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-            tcx.hir().def_kind(hir_id)\n-        } else {\n-            bug!(\"calling local def_kind query provider for upstream DefId: {:?}\", def_id);\n-        }\n-    };\n+    providers.def_kind =\n+        |tcx, def_id| tcx.hir().def_kind(tcx.hir().as_local_hir_id(def_id.expect_local()));\n }"}, {"sha": "7ab66411b21093ab18d14deb91c7456407709e9c", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -68,14 +68,13 @@ impl<'tcx> TyCtxt<'tcx> {\n pub fn provide(providers: &mut Providers<'_>) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n-        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id.to_def_id()).unwrap()))\n-            .expect_local()\n+        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id)))\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;\n     providers.hir_module_items = |tcx, id| {\n         let hir = tcx.hir();\n-        let module = hir.as_local_hir_id(id.to_def_id()).unwrap();\n+        let module = hir.as_local_hir_id(id);\n         &tcx.untracked_crate.modules[&module]\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;"}, {"sha": "c3eeea7662ba94517d647636acf2b7c268bf0d03", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -554,7 +554,7 @@ impl<'tcx> ScopeTree {\n     pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n         let scope = tcx\n             .hir()\n             .maybe_body_owned_by(param_owner_id)\n@@ -595,7 +595,7 @@ impl<'tcx> ScopeTree {\n         // on the same function that they ended up being freed in.\n         assert_eq!(param_owner, fr.scope);\n \n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n         let body_id = tcx.hir().body_owned_by(param_owner_id);\n         Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }"}, {"sha": "9d95a700313d63f526d67c9aa59a58b59544c8fb", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n                 let parent_def_id = self.hir().local_def_id(self.hir().get_parent_item(id));\n                 let skip = self\n-                    .lookup_deprecation_entry(parent_def_id)\n+                    .lookup_deprecation_entry(parent_def_id.to_def_id())\n                     .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n                 if !skip {"}, {"sha": "d3fcf9c64f84fa0559d67923d0aa8778508f5587", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -2338,12 +2338,13 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n-                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                        if let Some(def_id) = def_id.as_local() {\n+                            let hir_id = tcx.hir().as_local_hir_id(def_id);\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 let substs = tcx.lift(&substs).unwrap();\n                                 format!(\n                                     \"[closure@{}]\",\n-                                    tcx.def_path_str_with_substs(def_id, substs),\n+                                    tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n                                 )\n                             } else {\n                                 format!(\"[closure@{:?}]\", tcx.hir().span(hir_id))\n@@ -2364,7 +2365,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                        if let Some(def_id) = def_id.as_local() {\n+                            let hir_id = tcx.hir().as_local_hir_id(def_id);\n                             let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n "}, {"sha": "fd1d410f0516079be5096df84519393608c0648c", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -197,8 +197,12 @@ impl<'tcx> MonoItem<'tcx> {\n \n     pub fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self {\n-            MonoItem::Fn(Instance { def, .. }) => tcx.hir().as_local_hir_id(def.def_id()),\n-            MonoItem::Static(def_id) => tcx.hir().as_local_hir_id(def_id),\n+            MonoItem::Fn(Instance { def, .. }) => {\n+                def.def_id().as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+            }\n+            MonoItem::Static(def_id) => {\n+                def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+            }\n             MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n         }\n         .map(|hir_id| tcx.hir().span(hir_id))\n@@ -339,7 +343,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // instances into account. The others don't matter for\n                             // the codegen tests and can even make item order\n                             // unstable.\n-                            InstanceDef::Item(def_id) => tcx.hir().as_local_hir_id(def_id),\n+                            InstanceDef::Item(def_id) => {\n+                                def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                            }\n                             InstanceDef::VtableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n@@ -350,7 +356,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             | InstanceDef::CloneShim(..) => None,\n                         }\n                     }\n-                    MonoItem::Static(def_id) => tcx.hir().as_local_hir_id(def_id),\n+                    MonoItem::Static(def_id) => {\n+                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                    }\n                     MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n                 },\n                 item.symbol_name(tcx),"}, {"sha": "51bbb9016b6a2fd102dc32cf257c600295281e1b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -277,7 +277,7 @@ rustc_queries! {\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n-                let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n+                let id = tcx.hir().as_local_hir_id(key.1.expect_local());\n                 tcx.hir().ty_param_name(id)\n             }}\n         }"}, {"sha": "7797374259cb768296a8473e45e8574587afdb88", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1413,7 +1413,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope).unwrap();\n+        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope.expect_local());\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1431,7 +1431,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.kind {"}, {"sha": "ee6b06a1cc803568944a15b7f6ba12c94a875de4", "filename": "src/librustc_middle/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> DefIdForest {\n     #[inline]\n     pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n         let crate_id = tcx.hir().local_def_id(CRATE_HIR_ID);\n-        DefIdForest::from_id(crate_id)\n+        DefIdForest::from_id(crate_id.to_def_id())\n     }\n \n     /// Creates a forest containing a `DefId` and all its descendants."}, {"sha": "b785f79e1f35eb97c0b27667636964051369ab26", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -2667,12 +2667,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n-        self.hir().as_local_hir_id(def_id).and_then(|hir_id| self.hir().get(hir_id).ident())\n+        def_id\n+            .as_local()\n+            .and_then(|def_id| self.hir().get(self.hir().as_local_hir_id(def_id)).ident())\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n-        let is_associated_item = if let Some(hir_id) = self.hir().as_local_hir_id(def_id) {\n-            match self.hir().get(hir_id) {\n+        let is_associated_item = if let Some(def_id) = def_id.as_local() {\n+            match self.hir().get(self.hir().as_local_hir_id(def_id)) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -2824,8 +2826,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n-        if let Some(id) = self.hir().as_local_hir_id(did) {\n-            self.hir().attrs(id)\n+        if let Some(did) = did.as_local() {\n+            self.hir().attrs(self.hir().as_local_hir_id(did))\n         } else {\n             self.item_attrs(did)\n         }\n@@ -2863,8 +2865,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n-        if impl_did.is_local() {\n-            let hir_id = self.hir().as_local_hir_id(impl_did).unwrap();\n+        if let Some(impl_did) = impl_did.as_local() {\n+            let hir_id = self.hir().as_local_hir_id(impl_did);\n             Ok(self.hir().span(hir_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n@@ -2924,8 +2926,8 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-        if let Node::Item(item) = tcx.hir().get(hir_id) {\n+    if let Some(def_id) = def_id.as_local() {\n+        if let Node::Item(item) = tcx.hir().get(tcx.hir().as_local_hir_id(def_id)) {\n             if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n                 return opaque_ty.impl_trait_fn;\n             }"}, {"sha": "828f7f6a767b42e64a71e64b0897a99c066ab509", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -608,7 +608,8 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n \n                 // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                if let Some(did) = did.as_local() {\n+                    let hir_id = self.tcx().hir().as_local_hir_id(did);\n                     p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n \n                     if substs.as_generator().is_valid() {\n@@ -652,9 +653,10 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(write(\"[closure\"));\n \n                 // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                if let Some(did) = did.as_local() {\n+                    let hir_id = self.tcx().hir().as_local_hir_id(did);\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n-                        p!(write(\"@\"), print_def_path(did, substs));\n+                        p!(write(\"@\"), print_def_path(did.to_def_id(), substs));\n                     } else {\n                         p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n                     }"}, {"sha": "ac5477edcc3c0c8a920b56ad1e69bd4bc03fc23d", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -2266,11 +2266,12 @@ impl<'tcx> Const<'tcx> {\n             ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n                 // Find the name and index of the const parameter by indexing the generics of\n                 // the parent item and construct a `ParamConst`.\n-                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n+                let generics = tcx.generics_of(item_def_id.to_def_id());\n+                let index =\n+                    generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id).to_def_id()];\n                 let name = tcx.hir().name(hir_id);\n                 ty::ConstKind::Param(ty::ParamConst::new(index, name))\n             }"}, {"sha": "2686759ab971b965fccd41507c1752320fdf37f4", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -217,7 +217,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> &Trai\n         }\n \n         for &hir_id in tcx.hir().trait_impls(trait_id) {\n-            add_impl(tcx.hir().local_def_id(hir_id));\n+            add_impl(tcx.hir().local_def_id(hir_id).to_def_id());\n         }\n     }\n "}, {"sha": "6cc4ee432a58cb977c3b7309b1f950ddbc8e5d3d", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -192,7 +192,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id).unwrap();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id.expect_local());\n \n                     tables.closure_kind_origins().get(hir_id).is_none()\n                 }\n@@ -864,7 +864,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            if let Some(fn_hir_id) = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id) {\n+            if let Some(def_id) = self.mir_def_id.as_local() {\n+                let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id);\n                 err.span_label(\n                     drop_span,\n                     format!(\n@@ -1782,7 +1783,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n+        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did.as_local()?);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n \n         // We need to work out which arguments to highlight. We do this by looking"}, {"sha": "16c5bf1518dabe2bf30d8684c86de09c0af1e275", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -97,7 +97,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                 if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local());\n \n                     if let Some((span, name)) =\n                         self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n@@ -119,7 +119,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n-                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n+                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local());\n \n                 if let Some((span, name)) =\n                     self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n@@ -803,7 +803,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id)?;\n+        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id.as_local()?);\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {"}, {"sha": "1a4876db0ded35181e338d3a2fb80648df76ec9a", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.as_local_hir_id(self.mir_def_id).unwrap();\n+        let closure_id = hir.as_local_hir_id(self.mir_def_id.expect_local());\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.get_parent_item(fn_call_id);\n@@ -691,7 +691,7 @@ fn annotate_struct_field(\n         if let ty::Adt(def, _) = ty.kind {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let hir_id = tcx.hir().as_local_hir_id(field.did)?;\n+            let hir_id = tcx.hir().as_local_hir_id(field.did.as_local()?);\n             let node = tcx.hir().find(hir_id)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type."}, {"sha": "37e2e0475048d7007f661714175d2c17b7ff9cd5", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -237,12 +237,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = self\n-                        .infcx\n-                        .tcx\n-                        .hir()\n-                        .as_local_hir_id(self.mir_def_id)\n-                        .expect(\"non-local mir\");\n+                    let mir_hir_id =\n+                        self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -328,7 +324,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id)?;\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.as_local()?);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n@@ -639,7 +635,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -691,7 +687,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {"}, {"sha": "7c7251c913492e8b7a1e59dbd0e9b3830db93237", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -5,7 +5,10 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n-use rustc_hir::{def_id::DefId, HirId, Node};\n+use rustc_hir::{\n+    def_id::{DefId, LocalDefId},\n+    HirId, Node,\n+};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n@@ -96,7 +99,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> &BorrowCheckResult<'_> {\n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        do_mir_borrowck(&infcx, input_body, promoted, def_id)\n+        do_mir_borrowck(&infcx, input_body, promoted, def_id.expect_local())\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -107,13 +110,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n ) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n \n     let tcx = infcx.tcx;\n     let param_env = tcx.param_env(def_id);\n-    let id = tcx.hir().as_local_hir_id(def_id).expect(\"do_mir_borrowck: non-local DefId\");\n+    let id = tcx.hir().as_local_hir_id(def_id);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {\n@@ -140,7 +143,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     }\n     let upvars: Vec<_> = tables\n         .upvar_list\n-        .get(&def_id)\n+        .get(&def_id.to_def_id())\n         .into_iter()\n         .flat_map(|v| v.values())\n         .map(|upvar_id| {\n@@ -171,7 +174,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n+        nll::replace_regions_in_mir(infcx, def_id.to_def_id(), param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n@@ -186,7 +189,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mdpe = MoveDataParamEnv { move_data, param_env };\n \n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint()\n         .into_results_cursor(&body);\n \n@@ -203,7 +206,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         nll_errors,\n     } = nll::compute_regions(\n         infcx,\n-        def_id,\n+        def_id.to_def_id(),\n         free_regions,\n         body,\n         &promoted,\n@@ -216,14 +219,20 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n-    nll::dump_mir_results(infcx, MirSource::item(def_id), &body, &regioncx, &opt_closure_req);\n+    nll::dump_mir_results(\n+        infcx,\n+        MirSource::item(def_id.to_def_id()),\n+        &body,\n+        &regioncx,\n+        &opt_closure_req,\n+    );\n \n     // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information.\n     nll::dump_annotation(\n         infcx,\n         &body,\n-        def_id,\n+        def_id.to_def_id(),\n         &regioncx,\n         &opt_closure_req,\n         &opaque_type_values,\n@@ -238,13 +247,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let regioncx = Rc::new(regioncx);\n \n     let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint();\n     let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint();\n     let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint();\n \n     let movable_generator = match tcx.hir().get(id) {\n@@ -260,7 +269,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n         body,\n-        mir_def_id: def_id,\n+        mir_def_id: def_id.to_def_id(),\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,"}, {"sha": "e0cfcdb87a5a91e0182789a4da6b743714587a25", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -66,7 +66,7 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n-    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n+    let universal_regions = UniversalRegions::new(infcx, def_id.expect_local(), param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);"}, {"sha": "931e01d30718524fdd83452406d10c41ea899892", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1989,7 +1989,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                             let ccx = ConstCx::new_with_param_env(\n                                 tcx,\n-                                self.mir_def_id,\n+                                self.mir_def_id.expect_local(),\n                                 body,\n                                 self.param_env,\n                             );"}, {"sha": "e6099ba91922526019bf90d01fadb9537502f1df", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -16,7 +16,7 @@ use either::Either;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items;\n use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -220,12 +220,13 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// known between those regions.\n     pub fn new(\n         infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let tcx = infcx.tcx;\n-        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).unwrap();\n-        UniversalRegionsBuilder { infcx, mir_def_id, mir_hir_id, param_env }.build()\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id);\n+        UniversalRegionsBuilder { infcx, mir_def_id: mir_def_id.to_def_id(), mir_hir_id, param_env }\n+            .build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -777,7 +778,7 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n             let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,\n-                bound_region: ty::BoundRegion::BrNamed(region_def_id, name),\n+                bound_region: ty::BoundRegion::BrNamed(region_def_id.to_def_id(), name),\n             }));\n             f(liberated_region);\n         }"}, {"sha": "6d0a02ee3a47f0b9c98c34c07ec0c317c3052ec5", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -342,7 +342,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // validation thus preventing such a hard error from being a backwards\n                     // compatibility hazard\n                     Some(DefKind::Const | DefKind::AssocConst) => {\n-                        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                         err.report_as_lint(\n                             tcx.at(tcx.def_span(def_id)),\n                             \"any use of this value will cause an error\",\n@@ -365,7 +365,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                                 err.report_as_lint(\n                                     tcx.at(span),\n                                     \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().as_local_hir_id(def_id).unwrap(),\n+                                    tcx.hir().as_local_hir_id(def_id.expect_local()),\n                                     Some(err.span),\n                                 )\n                             }"}, {"sha": "74f8a1cb6d1246627d1133cb90d5a2714b2cb725", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -90,8 +90,7 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n /// said intrinsic is on the whitelist for being const callable.\n fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id =\n-        tcx.hir().as_local_hir_id(def_id).expect(\"Non-local call to local provider is_const_fn\");\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "6d1984fd20f9df3d0e2b2da31fa7073199a6ea39", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -180,7 +180,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc_index::bit_set::GrowableBitSet;\n@@ -430,7 +430,8 @@ fn check_recursion_limit<'tcx>(\n     // infinite expansion.\n     if adjusted_recursion_depth > *tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n-        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = tcx.hir().as_local_hir_id(def_id);\n             tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n         } else {\n             tcx.sess.fatal(&error);\n@@ -952,8 +953,8 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                             def_id_to_string(self.tcx, def_id)\n                         );\n \n-                        let ty =\n-                            Instance::new(def_id, InternalSubsts::empty()).monomorphic_ty(self.tcx);\n+                        let ty = Instance::new(def_id.to_def_id(), InternalSubsts::empty())\n+                            .monomorphic_ty(self.tcx);\n                         visit_drop_use(self.tcx, ty, true, self.output);\n                     }\n                 }\n@@ -968,7 +969,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             hir::ItemKind::Static(..) => {\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 debug!(\"RootCollector: ItemKind::Static({})\", def_id_to_string(self.tcx, def_id));\n-                self.output.push(MonoItem::Static(def_id));\n+                self.output.push(MonoItem::Static(def_id.to_def_id()));\n             }\n             hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n@@ -977,7 +978,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 // but even just declaring them must collect the items they refer to\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n-                if let Ok(val) = self.tcx.const_eval_poly(def_id) {\n+                if let Ok(val) = self.tcx.const_eval_poly(def_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n@@ -1002,12 +1003,12 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n }\n \n impl RootCollector<'_, 'v> {\n-    fn is_root(&self, def_id: DefId) -> bool {\n+    fn is_root(&self, def_id: LocalDefId) -> bool {\n         !item_requires_monomorphization(self.tcx, def_id)\n             && match self.mode {\n                 MonoItemCollectionMode::Eager => true,\n                 MonoItemCollectionMode::Lazy => {\n-                    self.entry_fn.map(|(id, _)| id) == Some(def_id)\n+                    self.entry_fn.map(|(id, _)| id) == Some(def_id.to_def_id())\n                         || self.tcx.is_reachable_non_generic(def_id)\n                         || self\n                             .tcx\n@@ -1020,11 +1021,11 @@ impl RootCollector<'_, 'v> {\n \n     /// If `def_id` represents a root, pushes it onto the list of\n     /// outputs. (Note that all roots must be monomorphic.)\n-    fn push_if_root(&mut self, def_id: DefId) {\n+    fn push_if_root(&mut self, def_id: LocalDefId) {\n         if self.is_root(def_id) {\n             debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n \n-            let instance = Instance::mono(self.tcx, def_id);\n+            let instance = Instance::mono(self.tcx, def_id.to_def_id());\n             self.output.push(create_fn_mono_item(instance));\n         }\n     }\n@@ -1066,7 +1067,7 @@ impl RootCollector<'_, 'v> {\n     }\n }\n \n-fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n     generics.requires_monomorphization(tcx)\n }\n@@ -1170,10 +1171,10 @@ fn collect_neighbours<'tcx>(\n     MirNeighborCollector { tcx, body: &body, output, instance }.visit_body(&body);\n }\n \n-fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n+fn def_id_to_string(tcx: TyCtxt<'_>, def_id: LocalDefId) -> String {\n     let mut output = String::new();\n     let printer = DefPathBasedNames::new(tcx, false, false);\n-    printer.push_def_path(def_id, &mut output);\n+    printer.push_def_path(def_id.to_def_id(), &mut output);\n     output\n }\n "}, {"sha": "cad5b114ae4550f28f5ec6a610814021e5984fec", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -306,7 +306,7 @@ fn mono_item_visibility(\n             let def_id = tcx.hir().local_def_id(*hir_id);\n             return if tcx.is_reachable_non_generic(def_id) {\n                 *can_be_internalized = false;\n-                default_visibility(tcx, def_id, false)\n+                default_visibility(tcx, def_id.to_def_id(), false)\n             } else {\n                 Visibility::Hidden\n             };\n@@ -755,7 +755,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id)),\n+        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id).to_def_id()),\n     }\n }\n "}, {"sha": "46a46aa5ae953aa288e12ef9231c53dc0995e6f6", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -5,7 +5,7 @@\n //! it finds operations that are invalid in a certain context.\n \n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -29,20 +29,20 @@ pub struct ConstCx<'mir, 'tcx> {\n }\n \n impl ConstCx<'mir, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'mir mir::Body<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'mir mir::Body<'tcx>) -> Self {\n         let param_env = tcx.param_env(def_id);\n         Self::new_with_param_env(tcx, def_id, body, param_env)\n     }\n \n     pub fn new_with_param_env(\n         tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n+        def_id: LocalDefId,\n         body: &'mir mir::Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let const_kind = ConstKind::for_item(tcx, def_id);\n \n-        ConstCx { body, tcx, def_id, param_env, const_kind }\n+        ConstCx { body, tcx, def_id: def_id.to_def_id(), param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n@@ -69,10 +69,10 @@ pub enum ConstKind {\n impl ConstKind {\n     /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n     /// does not require validation (e.g. a non-const `fn`).\n-    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n+    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Option<Self> {\n         use hir::BodyOwnerKind as HirKind;\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id);\n \n         let mode = match tcx.hir().body_owner_kind(hir_id) {\n             HirKind::Closure => return None,"}, {"sha": "f9f32247c948703b9bd05120c8d962fdaf9fa36b", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -190,7 +190,7 @@ impl Validator<'a, 'mir, 'tcx> {\n             const_kind == Some(ConstKind::Static) && !tcx.has_attr(def_id, sym::thread_local);\n \n         if should_check_for_sync {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n             check_return_ty_is_sync(tcx, &body, hir_id);\n         }\n     }"}, {"sha": "567fb61e0e8c9ebcf52e6dc69e7f01e2b00f5370", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::Node;\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n@@ -465,12 +465,11 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n \n fn check_unused_unsafe(\n     tcx: TyCtxt<'_>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     used_unsafe: &FxHashSet<hir::HirId>,\n     unsafe_blocks: &mut Vec<(hir::HirId, bool)>,\n ) {\n-    let body_id =\n-        tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| tcx.hir().maybe_body_owned_by(hir_id));\n+    let body_id = tcx.hir().maybe_body_owned_by(tcx.hir().as_local_hir_id(def_id));\n \n     let body_id = match body_id {\n         Some(body) => body,\n@@ -495,7 +494,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n \n     let param_env = tcx.param_env(def_id);\n \n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => (is_const_fn(tcx, def_id), is_min_const_fn(tcx, def_id)),\n@@ -504,18 +503,20 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);\n     checker.visit_body(&body);\n \n-    check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);\n+    check_unused_unsafe(\n+        tcx,\n+        def_id.expect_local(),\n+        &checker.used_unsafe,\n+        &mut checker.inherited_blocks,\n+    );\n     UnsafetyCheckResult {\n         violations: checker.violations.into(),\n         unsafe_blocks: checker.inherited_blocks.into(),\n     }\n }\n \n fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let lint_hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap_or_else(|| bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n+    let lint_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n         // FIXME: when we make this a hard error, this should have its"}, {"sha": "92859577d79cd728d34eee54678bd31f62efad99", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -66,10 +66,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         }\n \n         use rustc_middle::hir::map::blocks::FnLikeNode;\n-        let hir_id = tcx\n-            .hir()\n-            .as_local_hir_id(source.def_id())\n-            .expect(\"Non-local call to local provider is_const_fn\");\n+        let hir_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n         let is_assoc_const = match tcx.def_kind(source.def_id()) {"}, {"sha": "523d6a160287329b78f27395c959b777bb32b1be", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -69,7 +69,7 @@ impl Inliner<'tcx> {\n         let param_env = self.tcx.param_env(self.source.def_id()).with_reveal_all();\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n+        let id = self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local());\n         if self.tcx.hir().body_owner_kind(id).is_fn_or_closure() && self.source.promoted.is_none() {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) =\n@@ -94,10 +94,10 @@ impl Inliner<'tcx> {\n                     continue;\n                 }\n \n-                let callee_hir_id = self.tcx.hir().as_local_hir_id(callsite.callee);\n-\n-                let callee_body = if let Some(callee_hir_id) = callee_hir_id {\n-                    let self_hir_id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n+                let callee_body = if let Some(callee_def_id) = callsite.callee.as_local() {\n+                    let callee_hir_id = self.tcx.hir().as_local_hir_id(callee_def_id);\n+                    let self_hir_id =\n+                        self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local());\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation."}, {"sha": "a5ed059ba09e74ff1b1abe38072d884d15e7bfe5", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -80,7 +80,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n             _: Span,\n         ) {\n             if let hir::VariantData::Tuple(_, hir_id) = *v {\n-                self.set.insert(self.tcx.hir().local_def_id(hir_id));\n+                self.set.insert(self.tcx.hir().local_def_id(hir_id).to_def_id());\n             }\n             intravisit::walk_struct_def(self, v)\n         }\n@@ -176,7 +176,7 @@ pub fn run_passes(\n }\n \n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n-    let const_kind = check_consts::ConstKind::for_item(tcx, def_id);\n+    let const_kind = check_consts::ConstKind::for_item(tcx, def_id.expect_local());\n \n     // No need to const-check a non-const `fn`.\n     if const_kind.is_none() {"}, {"sha": "0b73643e33956dace465cda90d4c3500d6c58b6d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let def_id = src.def_id();\n \n         let mut rpo = traversal::reverse_postorder(body);\n-        let ccx = ConstCx::new(tcx, def_id, body);\n+        let ccx = ConstCx::new(tcx, def_id.expect_local(), body);\n         let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n         let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);"}, {"sha": "a7217369bab37b538890bef5fb8dcf2d98d7cacd", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -13,7 +13,7 @@ type McfResult = Result<(), (Span, Cow<'static, str>)>;\n pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n     // Prevent const trait methods from being annotated as `stable`.\n     if tcx.features().staged_api {\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n             return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n         }"}, {"sha": "c6eefcc5ecaf1e89be3f4fd6d86bb786f3492066", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -285,7 +285,7 @@ fn dump_matched_mir_node<'tcx>(\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir().as_local_hir_id(source.def_id()).unwrap();\n+    let item_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n     let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|file| {"}, {"sha": "4dbe4bf7628e0f5e01b84961f053a707a6cd5fb8", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -5,7 +5,7 @@ use crate::hair::{BindingMode, LintLevel, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -22,12 +22,12 @@ use rustc_target::spec::PanicStrategy;\n use super::lints;\n \n crate fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::steal::Steal<Body<'_>> {\n-    tcx.alloc_steal_mir(mir_build(tcx, def_id))\n+    tcx.alloc_steal_mir(mir_build(tcx, def_id.expect_local()))\n }\n \n /// Construct the MIR for a given `DefId`.\n-fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+fn mir_build(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Body<'_> {\n+    let id = tcx.hir().as_local_hir_id(def_id);\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n@@ -181,7 +181,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def_id);\n+        lints::check(tcx, &body, def_id.to_def_id());\n \n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here.\n@@ -523,9 +523,9 @@ macro_rules! unpack {\n     }};\n }\n \n-fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n+fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, _abi: Abi) -> bool {\n     // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n-    let attrs = &tcx.get_attrs(fn_def_id);\n+    let attrs = &tcx.get_attrs(fn_def_id.to_def_id());\n     let unwind_attr = attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs);\n \n     // We never unwind, so it's not relevant to stop an unwind.\n@@ -613,7 +613,7 @@ where\n                         builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                             builder.args_and_body(\n                                 block,\n-                                fn_def_id,\n+                                fn_def_id.to_def_id(),\n                                 &arguments,\n                                 arg_scope,\n                                 &body.value,\n@@ -643,7 +643,7 @@ where\n     } else {\n         None\n     };\n-    debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n+    debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id.to_def_id()));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;"}, {"sha": "0ef6d24d07b48120cbc6dbe5d22dd4e19995c25a", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -408,7 +408,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n-            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id).expect_local();\n+            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id);\n             let count = ty::Const::from_anon_const(cx.tcx, count_def_id);\n \n             ExprKind::Repeat { value: v.to_ref(), count }\n@@ -690,12 +690,12 @@ fn convert_path_expr<'a, 'tcx>(\n         }\n \n         Res::Def(DefKind::ConstParam, def_id) => {\n-            let hir_id = cx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local());\n             let item_id = cx.tcx.hir().get_parent_node(hir_id);\n             let item_def_id = cx.tcx.hir().local_def_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);\n             let local_def_id = cx.tcx.hir().local_def_id(hir_id);\n-            let index = generics.param_def_id_to_index[&local_def_id];\n+            let index = generics.param_def_id_to_index[&local_def_id.to_def_id()];\n             let name = cx.tcx.hir().name(hir_id);\n             let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n@@ -962,7 +962,7 @@ fn capture_upvar<'tcx>(\n ) -> ExprRef<'tcx> {\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id).expect_local(),\n+        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);"}, {"sha": "46607fd07cdd731f69e4d4d0b96ef52fc207fcda", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -82,11 +82,11 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             infcx,\n             root_lint_level: src_id,\n             param_env: tcx.param_env(src_def_id),\n-            identity_substs: InternalSubsts::identity_for_item(tcx, src_def_id),\n+            identity_substs: InternalSubsts::identity_for_item(tcx, src_def_id.to_def_id()),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n             tables,\n             constness,\n-            body_owner: src_def_id,\n+            body_owner: src_def_id.to_def_id(),\n             body_owner_kind,\n             check_overflow,\n             control_flow_destroyed: Vec::new(),"}, {"sha": "c90634e511bb1f1f90eaa06ca2b3a55a2037bc79", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -21,9 +21,9 @@ use rustc_span::{sym, Span};\n use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let body_id = match tcx.hir().as_local_hir_id(def_id) {\n+    let body_id = match def_id.as_local() {\n         None => return,\n-        Some(id) => tcx.hir().body_owned_by(id),\n+        Some(id) => tcx.hir().body_owned_by(tcx.hir().as_local_hir_id(id)),\n     };\n \n     let mut visitor ="}, {"sha": "38f5df3e70557bd3d130b3f379724211a06e918f", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -11,7 +11,7 @@ use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n         if let FnKind::Closure(_) = fn_like_node.kind() {\n@@ -37,7 +37,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n \n         vis.reachable_recursive_calls.sort();\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");"}, {"sha": "6d1fbd6c868c5de83320a81125e15acc8ceca876", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -52,7 +52,8 @@ struct MarkSymbolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n             if should_explore(self.tcx, hir_id) || self.struct_constructors.contains_key(&hir_id) {\n                 self.worklist.push(hir_id);\n             }\n@@ -61,7 +62,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n             debug_assert!(!should_explore(self.tcx, hir_id));\n             self.live_symbols.insert(hir_id);\n         }\n@@ -450,7 +452,8 @@ fn create_and_seed_worklist<'tcx>(\n         )\n         .chain(\n             // Seed entry point\n-            tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id).unwrap()),\n+            tcx.entry_fn(LOCAL_CRATE)\n+                .map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id.expect_local())),\n         )\n         .collect::<Vec<_>>();\n \n@@ -534,7 +537,8 @@ impl DeadVisitor<'tcx> {\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                if let Some(item_hir_id) = self.tcx.hir().as_local_hir_id(item_did) {\n+                if let Some(did) = item_did.as_local() {\n+                    let item_hir_id = self.tcx.hir().as_local_hir_id(did);\n                     if self.live_symbols.contains(&item_hir_id) {\n                         return true;\n                     }"}, {"sha": "bed2221fe60761298a8389fff969c303a91b9ddc", "filename": "src/librustc_passes/diagnostic_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostic_items.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> DiagnosticItemCollector<'tcx> {\n         if let Some(name) = extract(attrs) {\n             let def_id = self.tcx.hir().local_def_id(hir_id);\n             // insert into our table\n-            collect_item(self.tcx, &mut self.items, name, def_id);\n+            collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n         }\n     }\n }"}, {"sha": "35805db8d59efad9c3bd18b943221b0412b85a8d", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -34,7 +34,7 @@ struct EntryContext<'a, 'tcx> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let def_id = self.map.local_def_id(item.hir_id);\n-        let def_key = self.map.def_key(def_id.expect_local());\n+        let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n@@ -145,11 +145,11 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n \n fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(DefId, EntryFnType)> {\n     if let Some((hir_id, _)) = visitor.start_fn {\n-        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Start))\n+        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n-        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n     } else if let Some((hir_id, _)) = visitor.main_fn {\n-        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n     } else {\n         no_main_err(tcx, visitor);\n         None"}, {"sha": "80dfcd9c2417aa708a09d3e77e1310e03b51fed9", "filename": "src/librustc_passes/hir_id_validator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_id_validator.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -17,7 +17,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n         let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(\n-            local_def_id,\n+            local_def_id.to_def_id(),\n             &mut OuterVisitor { hir_map, errors: &errors },\n         );\n     });\n@@ -79,7 +79,7 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n \n     fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self, hir_id: HirId, walk: F) {\n         assert!(self.owner.is_none());\n-        let owner = self.hir_map.local_def_id(hir_id).expect_local();\n+        let owner = self.hir_map.local_def_id(hir_id);\n         self.owner = Some(owner);\n         walk(self);\n "}, {"sha": "c48e6f9133bcd88a8af6c66fd478907566e6ee98", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -34,7 +34,7 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n                     let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    self.collect_item(item_index, def_id);\n+                    self.collect_item(item_index, def_id.to_def_id());\n                 }\n                 // Known lang item with attribute on incorrect target.\n                 Some((_, expected_target)) => {"}, {"sha": "c0826f8cc605fd24a1285d02ea7556b09a80e390", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ast::Attribute;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::ItemKind;\n use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, TyAndLayout};\n@@ -29,7 +29,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..)\n             | ItemKind::OpaqueTy(..) => {\n-                for attr in self.tcx.get_attrs(item_def_id).iter() {\n+                for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n                     if attr.check_name(sym::rustc_layout) {\n                         self.dump_layout_of(item_def_id, item, attr);\n                     }\n@@ -44,7 +44,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n }\n \n impl LayoutTest<'tcx> {\n-    fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item<'tcx>, attr: &Attribute) {\n+    fn dump_layout_of(&self, item_def_id: LocalDefId, item: &hir::Item<'tcx>, attr: &Attribute) {\n         let tcx = self.tcx;\n         let param_env = self.tcx.param_env(item_def_id);\n         let ty = self.tcx.type_of(item_def_id);"}, {"sha": "25d53485bc54dc1180b9c35e3433e1e2bcafb8ce", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -361,7 +361,7 @@ fn visit_fn<'tcx>(\n \n     // swap in a new set of IR maps for this function body:\n     let def_id = ir.tcx.hir().local_def_id(id);\n-    let mut fn_maps = IrMaps::new(ir.tcx, def_id);\n+    let mut fn_maps = IrMaps::new(ir.tcx, def_id.to_def_id());\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n@@ -398,7 +398,7 @@ fn visit_fn<'tcx>(\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, def_id);\n+    let mut lsets = Liveness::new(&mut fn_maps, def_id.to_def_id());\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n@@ -496,7 +496,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n             ir.set_captures(expr.hir_id, call_caps);\n             let old_body_owner = ir.body_owner;\n-            ir.body_owner = closure_def_id;\n+            ir.body_owner = closure_def_id.to_def_id();\n             intravisit::walk_expr(ir, expr);\n             ir.body_owner = old_body_owner;\n         }"}, {"sha": "d913486cb0e1890745387692110154918f452d5e", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -53,13 +53,9 @@ fn method_might_be_inlined(\n             return true;\n         }\n     }\n-    if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src.to_def_id()) {\n-        match tcx.hir().find(impl_hir_id) {\n-            Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n-            Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n-        }\n-    } else {\n-        span_bug!(impl_item.span, \"found a foreign impl as a parent of a local method\")\n+    match tcx.hir().find(tcx.hir().as_local_hir_id(impl_src)) {\n+        Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n+        Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n     }\n }\n \n@@ -108,9 +104,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n             }\n             Some(res) => {\n                 if let Some((hir_id, def_id)) = res.opt_def_id().and_then(|def_id| {\n-                    self.tcx.hir().as_local_hir_id(def_id).map(|hir_id| (hir_id, def_id))\n+                    def_id.as_local().map(|def_id| (self.tcx.hir().as_local_hir_id(def_id), def_id))\n                 }) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n+                    if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n                         self.worklist.push(hir_id);\n                     } else {\n                         match res {\n@@ -141,8 +137,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n-            Some(hir_id) => hir_id,\n+        let hir_id = match def_id.as_local() {\n+            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id),\n             None => {\n                 return false;\n             }\n@@ -170,11 +166,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         if generics.requires_monomorphization(self.tcx) || attrs.requests_inline() {\n                             true\n                         } else {\n-                            let impl_did = self.tcx.hir().get_parent_did(hir_id).to_def_id();\n+                            let impl_did = self.tcx.hir().get_parent_did(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n+                            let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did);\n                             match self.tcx.hir().expect_item(impl_hir_id).kind {\n                                 hir::ItemKind::Impl { .. } => {\n                                     let generics = self.tcx.generics_of(impl_did);\n@@ -361,7 +357,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n                 let tcx = self.tcx;\n                 self.worklist.extend(\n                     tcx.provided_trait_methods(trait_def_id)\n-                        .map(|assoc| tcx.hir().as_local_hir_id(assoc.def_id).unwrap()),\n+                        .map(|assoc| tcx.hir().as_local_hir_id(assoc.def_id.expect_local())),\n                 );\n             }\n         }\n@@ -400,7 +396,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did)) {\n                 reachable_context.worklist.push(hir_id);\n             }\n         }"}, {"sha": "927e6a7e712b5da783d157b724edce42ead2043c", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -807,7 +807,7 @@ fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,"}, {"sha": "fb986caa415c9d62a62e6ac9ca573dc8c0dcd82c", "filename": "src/librustc_passes/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_passes%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fupvars.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -15,7 +15,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n             return None;\n         }\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(hir_id)?);\n \n         let mut local_collector = LocalCollector::default();"}, {"sha": "34522cfe97f352db8e586ff61216cb1cb16f1d2a", "filename": "src/librustc_plugin_impl/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_plugin_impl%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_plugin_impl%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fbuild.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -42,7 +42,7 @@ fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n         0 => None,\n         1 => {\n             let (hir_id, _) = finder.registrars.pop().unwrap();\n-            Some(tcx.hir().local_def_id(hir_id))\n+            Some(tcx.hir().local_def_id(hir_id).to_def_id())\n         }\n         _ => {\n             let diagnostic = tcx.sess.diagnostic();"}, {"sha": "b1fbba7e1a7b3b4845b122877fab225abbf37a1f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -235,7 +235,7 @@ fn def_id_visibility<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (ty::Visibility, Span, &'static str) {\n-    match tcx.hir().as_local_hir_id(def_id) {\n+    match def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id)) {\n         Some(hir_id) => {\n             let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n@@ -268,11 +268,11 @@ fn def_id_visibility<'tcx>(\n                         Node::Variant(..) => {\n                             let parent_did = tcx.hir().local_def_id(parent_hir_id);\n                             let (mut ctor_vis, mut span, mut descr) =\n-                                def_id_visibility(tcx, parent_did);\n+                                def_id_visibility(tcx, parent_did.to_def_id());\n \n                             let adt_def = tcx.adt_def(tcx.hir().get_parent_did(hir_id).to_def_id());\n                             let ctor_did = tcx.hir().local_def_id(vdata.ctor_hir_id().unwrap());\n-                            let variant = adt_def.variant_with_ctor_id(ctor_did);\n+                            let variant = adt_def.variant_with_ctor_id(ctor_did.to_def_id());\n \n                             if variant.is_field_list_non_exhaustive()\n                                 && ctor_vis == ty::Visibility::Public\n@@ -445,7 +445,8 @@ impl VisibilityLike for Option<AccessLevel> {\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n         cmp::min(\n-            if let Some(hir_id) = find.tcx.hir().as_local_hir_id(def_id) {\n+            if let Some(def_id) = def_id.as_local() {\n+                let hir_id = find.tcx.hir().as_local_hir_id(def_id);\n                 find.access_levels.map.get(&hir_id).cloned()\n             } else {\n                 Self::MAX\n@@ -514,7 +515,7 @@ impl EmbargoVisitor<'tcx> {\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n             ev: self,\n         }\n     }\n@@ -547,7 +548,8 @@ impl EmbargoVisitor<'tcx> {\n                 if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         let vis = def_id_visibility(self.tcx, def_id).0;\n-                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                        if let Some(def_id) = def_id.as_local() {\n+                            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n                             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n                     }\n@@ -654,14 +656,16 @@ impl EmbargoVisitor<'tcx> {\n                 // If the module is `self`, i.e. the current crate,\n                 // there will be no corresponding item.\n                 .filter(|def_id| def_id.index != CRATE_DEF_INDEX || def_id.krate != LOCAL_CRATE)\n-                .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n+                .and_then(|def_id| {\n+                    def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n+                })\n                 .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n             {\n                 if let hir::ItemKind::Mod(m) = &item.kind {\n                     for item_id in m.item_ids {\n                         let item = self.tcx.hir().expect_item(item_id.id);\n                         let def_id = self.tcx.hir().local_def_id(item_id.id);\n-                        if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) {\n+                        if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id.to_def_id()) {\n                             continue;\n                         }\n                         if let hir::ItemKind::Use(..) = item.kind {\n@@ -908,7 +912,8 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n                         if let Some(def_id) = export.res.opt_def_id() {\n-                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                            if let Some(def_id) = def_id.as_local() {\n+                                let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n                                 self.update(hir_id, Some(AccessLevel::Exported));\n                             }\n                         }\n@@ -927,7 +932,8 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         }\n \n         let macro_module_def_id =\n-            ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id)).unwrap();\n+            ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id).to_def_id())\n+                .unwrap();\n         // FIXME(#71104) Should really be using just `as_local_hir_id` but\n         // some `DefId` do not seem to have a corresponding HirId.\n         let hir_id = macro_module_def_id\n@@ -995,10 +1001,11 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         self.ev.tcx\n     }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n-        if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.ev.tcx.hir().as_local_hir_id(def_id);\n             if let ((ty::Visibility::Public, ..), _)\n             | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n-                (def_id_visibility(self.tcx(), def_id), self.access_level)\n+                (def_id_visibility(self.tcx(), def_id.to_def_id()), self.access_level)\n             {\n                 self.ev.update(hir_id, self.access_level);\n             }\n@@ -1370,8 +1377,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item =\n-            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n+        let orig_current_item = mem::replace(\n+            &mut self.current_item,\n+            self.tcx.hir().local_def_id(item.hir_id).to_def_id(),\n+        );\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n@@ -1440,10 +1449,10 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n         // A path can only be private if:\n         // it's in this crate...\n-        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+        if let Some(did) = did.as_local() {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n-            match self.tcx.hir().find(hir_id) {\n+            match self.tcx.hir().find(self.tcx.hir().as_local_hir_id(did)) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n@@ -1561,8 +1570,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     |tr| {\n                         let did = tr.path.res.def_id();\n \n-                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n-                            self.trait_is_public(hir_id)\n+                        if let Some(did) = did.as_local() {\n+                            self.trait_is_public(self.tcx.hir().as_local_hir_id(did))\n                         } else {\n                             true // external traits must be public\n                         }\n@@ -1822,8 +1831,8 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n             );\n         }\n \n-        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n-            Some(hir_id) => hir_id,\n+        let hir_id = match def_id.as_local() {\n+            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id),\n             None => return false,\n         };\n \n@@ -1913,7 +1922,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n             item_id,\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n             span: self.tcx.hir().span(item_id),\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n@@ -2067,7 +2076,7 @@ fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: DefId) {\n         current_item: None,\n         empty_tables: &empty_tables,\n     };\n-    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n+    let (module, span, hir_id) = tcx.hir().get_module(module_def_id.expect_local());\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n "}, {"sha": "a988c5829b5ef9334cf301815c43b17e75247a37", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -62,7 +62,7 @@ impl RegionExt for Region {\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id(), origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n@@ -73,7 +73,7 @@ impl RegionExt for Region {\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param, depth, def_id, origin,\n         );\n-        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id.to_def_id(), origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -596,7 +596,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // In the future, this should be fixed and this error should be removed.\n                         let def = self.map.defs.get(&lifetime.hir_id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n-                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                            if let Some(def_id) = def_id.as_local() {\n+                                let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n                                 // Ensure that the parent of the def is an item, not HRTB\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n@@ -1166,7 +1167,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                     if let Some(def) =\n                         lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n                     {\n-                        let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n+                        let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap().expect_local());\n \n                         signal_shadowing_problem(\n                             tcx,\n@@ -1278,7 +1279,7 @@ fn object_lifetime_defaults_for_item(\n                         _ => continue,\n                     };\n \n-                    if res == Res::Def(DefKind::TyParam, param_def_id) {\n+                    if res == Res::Def(DefKind::TyParam, param_def_id.to_def_id()) {\n                         add_bounds(&mut set, &data.bounds);\n                     }\n                 }\n@@ -1304,7 +1305,11 @@ fn object_lifetime_defaults_for_item(\n                                 .find(|&(_, (_, lt_name, _))| lt_name == name)\n                                 .map_or(Set1::Many, |(i, (id, _, origin))| {\n                                     let def_id = tcx.hir().local_def_id(id);\n-                                    Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                                    Set1::One(Region::EarlyBound(\n+                                        i as u32,\n+                                        def_id.to_def_id(),\n+                                        origin,\n+                                    ))\n                                 })\n                         }\n                     }\n@@ -1533,7 +1538,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n                     debug!(\"hir id first={:?}\", hir_id);\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n@@ -1552,9 +1557,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n \n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                            if let Some(parent_hir_id) =\n-                                self.tcx.hir().as_local_hir_id(parent_def_id)\n-                            {\n+                            if let Some(def_id) = parent_def_id.as_local() {\n+                                let parent_hir_id = self.tcx.hir().as_local_hir_id(def_id);\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n                                 if self\n                                     .tcx\n@@ -1596,7 +1600,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"not one use lifetime\");\n                 }\n                 None => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n@@ -1812,7 +1816,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     })\n                     | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n-                        def = Region::Free(scope, def.id().unwrap());\n+                        def = Region::Free(scope.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }\n@@ -1951,7 +1955,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            let unsubst = if let Some(def_id) = def_id.as_local() {\n+                let id = self.tcx.hir().as_local_hir_id(def_id);\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n@@ -2657,7 +2662,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n-                        let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n+                        let hir_id =\n+                            self.tcx.hir().as_local_hir_id(def.id().unwrap().expect_local());\n \n                         signal_shadowing_problem(\n                             self.tcx,"}, {"sha": "5a1c6491f86d812ad3f336eb34f51c0a05214f93", "filename": "src/librustc_symbol_mangling/lib.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_symbol_mangling%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_symbol_mangling%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Flib.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -165,22 +165,18 @@ fn compute_symbol_name(\n \n     debug!(\"symbol_name(def_id={:?}, substs={:?})\", def_id, substs);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n-\n-    if def_id.is_local() {\n-        if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n+    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n+    let is_foreign = if let Some(def_id) = def_id.as_local() {\n+        if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id.to_def_id()) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_plugin_registrar_symbol(disambiguator);\n         }\n-        if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n+        if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id.to_def_id()) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n-    }\n-\n-    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let is_foreign = if let Some(id) = hir_id {\n-        match tcx.hir().get(id) {\n+        let hir_id = tcx.hir().as_local_hir_id(def_id);\n+        match tcx.hir().get(hir_id) {\n             Node::ForeignItem(_) => true,\n             _ => false,\n         }"}, {"sha": "5175b692e17b69156872693f9257d2ec4c597a95", "filename": "src/librustc_symbol_mangling/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_symbol_mangling%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_symbol_mangling%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Ftest.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -33,18 +33,18 @@ impl SymbolNamesTest<'tcx> {\n     fn process_attrs(&mut self, hir_id: hir::HirId) {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(hir_id);\n-        for attr in tcx.get_attrs(def_id).iter() {\n+        for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(tcx, def_id);\n+                let instance = Instance::mono(tcx, def_id.to_def_id());\n                 let mangled = self.tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n                 if let Ok(demangling) = rustc_demangle::try_demangle(&mangled.name.as_str()) {\n                     tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n                     tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n                 }\n             } else if attr.check_name(DEF_PATH) {\n-                let path = tcx.def_path_str(def_id);\n+                let path = tcx.def_path_str(def_id.to_def_id());\n                 tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n             }\n "}, {"sha": "8ff8f5734c9b06524e4a0d1a80bf0c6391e7267f", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -3,7 +3,7 @@ use crate::traits::{self, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -1036,11 +1036,13 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     //     let x = || foo(); // returns the Opaque assoc with `foo`\n                     // }\n                     // ```\n-                    if let Some(opaque_hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                    if let Some(def_id) = def_id.as_local() {\n+                        let opaque_hir_id = tcx.hir().as_local_hir_id(def_id);\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n+                            parent_def_id\n+                                == tcx.hir().local_def_id(opaque_parent_hir_id).to_def_id()\n                         };\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.kind {\n@@ -1056,14 +1058,22 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     origin,\n                                     ..\n                                 }) => (\n-                                    may_define_opaque_type(tcx, self.parent_def_id, opaque_hir_id),\n+                                    may_define_opaque_type(\n+                                        tcx,\n+                                        self.parent_def_id.expect_local(),\n+                                        opaque_hir_id,\n+                                    ),\n                                     origin,\n                                 ),\n                                 _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n                             },\n                             Some(Node::ImplItem(item)) => match item.kind {\n                                 hir::ImplItemKind::OpaqueTy(_) => (\n-                                    may_define_opaque_type(tcx, self.parent_def_id, opaque_hir_id),\n+                                    may_define_opaque_type(\n+                                        tcx,\n+                                        self.parent_def_id.expect_local(),\n+                                        opaque_hir_id,\n+                                    ),\n                                     hir::OpaqueTyOrigin::TypeAlias,\n                                 ),\n                                 _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n@@ -1074,7 +1084,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                             ),\n                         };\n                         if in_definition_scope {\n-                            return self.fold_opaque_ty(ty, def_id, substs, origin);\n+                            return self.fold_opaque_ty(ty, def_id.to_def_id(), substs, origin);\n                         }\n \n                         debug!(\n@@ -1200,11 +1210,15 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` is the `DefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n+/// Here, `def_id` is the `LocalDefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n /// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n /// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n-pub fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: DefId, opaque_hir_id: hir::HirId) -> bool {\n-    let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+pub fn may_define_opaque_type(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+    opaque_hir_id: hir::HirId,\n+) -> bool {\n+    let mut hir_id = tcx.hir().as_local_hir_id(def_id);\n \n     // Named opaque types can be defined by any siblings or children of siblings.\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id);"}, {"sha": "fa9f1c9a7d97a8291ea1cd4c797960c236f0c13f", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -507,7 +507,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.tcx.sess.source_map().guess_head_span(\n                                 self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n                             );\n-                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id.expect_local());\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             closure_span,"}, {"sha": "88b9d257795f79f775f6a93ad49dfba834fcaa2c", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -430,7 +430,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             };\n \n         let hir = self.tcx.hir();\n-        let hir_id = hir.as_local_hir_id(def_id)?;\n+        let hir_id = hir.as_local_hir_id(def_id.as_local()?);\n         let parent_node = hir.get_parent_node(hir_id);\n         match hir.find(parent_node) {\n             Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n@@ -1209,7 +1209,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let span = self.tcx.def_span(generator_did);\n \n         // Do not ICE on closure typeck (#66868).\n-        if hir.as_local_hir_id(generator_did).is_none() {\n+        if !generator_did.is_local() {\n             return false;\n         }\n \n@@ -1235,8 +1235,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let generator_body = hir\n-            .as_local_hir_id(generator_did)\n+        let generator_body = generator_did\n+            .as_local()\n+            .map(|def_id| hir.as_local_hir_id(def_id))\n             .and_then(|hir_id| hir.maybe_body_owned_by(hir_id))\n             .map(|body_id| hir.body(body_id));\n         let mut visitor = AwaitsVisitor::default();\n@@ -1386,7 +1387,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         GeneratorKind::Async(AsyncGeneratorKind::Fn) => self\n                             .tcx\n                             .parent(generator_did)\n-                            .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n+                            .and_then(|parent_did| parent_did.as_local())\n+                            .map(|parent_did| hir.as_local_hir_id(parent_did))\n                             .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n                             .map(|name| {\n                                 format!(\"future returned by `{}` is not {}\", name, trait_name)"}, {"sha": "beebddd72a82033f1314dddd4be727013e0f812b", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -17,7 +17,7 @@ use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -271,9 +271,9 @@ pub(super) fn specialization_graph_provider(\n         .sort_unstable_by_key(|def_id| (-(def_id.krate.as_u32() as i64), def_id.index.index()));\n \n     for impl_def_id in trait_impls {\n-        if impl_def_id.is_local() {\n+        if let Some(impl_def_id) = impl_def_id.as_local() {\n             // This is where impl overlap checking happens:\n-            let insert_result = sg.insert(tcx, impl_def_id);\n+            let insert_result = sg.insert(tcx, impl_def_id.to_def_id());\n             // Report error if there was one.\n             let (overlap, used_to_be_allowed) = match insert_result {\n                 Err(overlap) => (Some(overlap), None),\n@@ -296,19 +296,19 @@ pub(super) fn specialization_graph_provider(\n fn report_overlap_conflict(\n     tcx: TyCtxt<'_>,\n     overlap: OverlapError,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_polarity = tcx.impl_polarity(impl_def_id);\n+    let impl_polarity = tcx.impl_polarity(impl_def_id.to_def_id());\n     let other_polarity = tcx.impl_polarity(overlap.with_impl);\n     match (impl_polarity, other_polarity) {\n         (ty::ImplPolarity::Negative, ty::ImplPolarity::Positive) => {\n             report_negative_positive_conflict(\n                 tcx,\n                 &overlap,\n                 impl_def_id,\n-                impl_def_id,\n+                impl_def_id.to_def_id(),\n                 overlap.with_impl,\n                 sg,\n             );\n@@ -320,7 +320,7 @@ fn report_overlap_conflict(\n                 &overlap,\n                 impl_def_id,\n                 overlap.with_impl,\n-                impl_def_id,\n+                impl_def_id.to_def_id(),\n                 sg,\n             );\n         }\n@@ -334,13 +334,15 @@ fn report_overlap_conflict(\n fn report_negative_positive_conflict(\n     tcx: TyCtxt<'_>,\n     overlap: &OverlapError,\n-    local_impl_def_id: DefId,\n+    local_impl_def_id: LocalDefId,\n     negative_impl_def_id: DefId,\n     positive_impl_def_id: DefId,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_span =\n-        tcx.sess.source_map().guess_head_span(tcx.span_of_impl(local_impl_def_id).unwrap());\n+    let impl_span = tcx\n+        .sess\n+        .source_map()\n+        .guess_head_span(tcx.span_of_impl(local_impl_def_id.to_def_id()).unwrap());\n \n     let mut err = struct_span_err!(\n         tcx.sess,\n@@ -382,11 +384,12 @@ fn report_negative_positive_conflict(\n fn report_conflicting_impls(\n     tcx: TyCtxt<'_>,\n     overlap: OverlapError,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_span = tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap());\n+    let impl_span =\n+        tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id.to_def_id()).unwrap());\n \n     // Work to be done after we've built the DiagnosticBuilder. We have to define it\n     // now because the struct_lint methods don't return back the DiagnosticBuilder\n@@ -449,7 +452,7 @@ fn report_conflicting_impls(\n             };\n             tcx.struct_span_lint_hir(\n                 lint,\n-                tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n+                tcx.hir().as_local_hir_id(impl_def_id),\n                 impl_span,\n                 decorate,\n             )"}, {"sha": "e7fa245fd4055fb55373bd98916f7b534ed75b2a", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -174,7 +174,7 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         // could bound lifetimes.\n         .map(Clause::ForAll);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n     enum NodeKind {"}, {"sha": "16f395a4fec8dcbf3dc17649990d0c56dba8a4d5", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n@@ -78,7 +78,7 @@ fn sized_constraint_for_ty<'tcx>(\n \n fn associated_item_from_trait_item_ref(\n     tcx: TyCtxt<'_>,\n-    parent_def_id: DefId,\n+    parent_def_id: LocalDefId,\n     parent_vis: &hir::Visibility<'_>,\n     trait_item_ref: &hir::TraitItemRef,\n ) -> ty::AssocItem {\n@@ -96,15 +96,15 @@ fn associated_item_from_trait_item_ref(\n         // Visibility of trait items is inherited from their traits.\n         vis: ty::Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, tcx),\n         defaultness: trait_item_ref.defaultness,\n-        def_id,\n-        container: ty::TraitContainer(parent_def_id),\n+        def_id: def_id.to_def_id(),\n+        container: ty::TraitContainer(parent_def_id.to_def_id()),\n         fn_has_self_parameter: has_self,\n     }\n }\n \n fn associated_item_from_impl_item_ref(\n     tcx: TyCtxt<'_>,\n-    parent_def_id: DefId,\n+    parent_def_id: LocalDefId,\n     impl_item_ref: &hir::ImplItemRef<'_>,\n ) -> ty::AssocItem {\n     let def_id = tcx.hir().local_def_id(impl_item_ref.id.hir_id);\n@@ -121,14 +121,14 @@ fn associated_item_from_impl_item_ref(\n         // Visibility of trait impl items doesn't matter.\n         vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, tcx),\n         defaultness: impl_item_ref.defaultness,\n-        def_id,\n-        container: ty::ImplContainer(parent_def_id),\n+        def_id: def_id.to_def_id(),\n+        container: ty::ImplContainer(parent_def_id.to_def_id()),\n         fn_has_self_parameter: has_self,\n     }\n }\n \n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n@@ -166,7 +166,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n }\n \n fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(hir_id);\n     if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n         defaultness\n@@ -200,20 +200,20 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n }\n \n fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(id);\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n             trait_item_refs\n                 .iter()\n                 .map(|trait_item_ref| trait_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+                .map(|id| tcx.hir().local_def_id(id.hir_id).to_def_id()),\n         ),\n         hir::ItemKind::Impl { ref items, .. } => tcx.arena.alloc_from_iter(\n             items\n                 .iter()\n                 .map(|impl_item_ref| impl_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+                .map(|id| tcx.hir().local_def_id(id.hir_id).to_def_id()),\n         ),\n         hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n@@ -265,9 +265,12 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     let unnormalized_env =\n         ty::ParamEnv::new(tcx.intern_predicates(&predicates), traits::Reveal::UserFacing, None);\n \n-    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::CRATE_HIR_ID, |id| {\n-        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n-    });\n+    let body_id = def_id\n+        .as_local()\n+        .map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+        .map_or(hir::CRATE_HIR_ID, |id| {\n+            tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n+        });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n@@ -352,10 +355,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n /// Check if a function is async.\n fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap_or_else(|| bug!(\"asyncness: expected local `DefId`, got `{:?}`\", def_id));\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "63b8eb224cec26f3966bd6c89c0d42843807b809", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -15,7 +15,7 @@ use rustc_errors::ErrorReported;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::lang_items::SizedTraitLangItem;\n use rustc_hir::{Constness, GenericArg, GenericArgs};\n@@ -147,13 +147,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def: Option<&ty::GenericParamDef>,\n     ) -> ty::Region<'tcx> {\n         let tcx = self.tcx();\n-        let lifetime_name = |def_id| tcx.hir().name(tcx.hir().as_local_hir_id(def_id).unwrap());\n+        let lifetime_name = |def_id| tcx.hir().name(tcx.hir().as_local_hir_id(def_id));\n \n         let r = match tcx.named_region(lifetime.hir_id) {\n             Some(rl::Region::Static) => tcx.lifetimes.re_static,\n \n             Some(rl::Region::LateBound(debruijn, id, _)) => {\n-                let name = lifetime_name(id);\n+                let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReLateBound(debruijn, ty::BrNamed(id, name)))\n             }\n \n@@ -162,12 +162,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n \n             Some(rl::Region::EarlyBound(index, id, _)) => {\n-                let name = lifetime_name(id);\n+                let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id: id, index, name }))\n             }\n \n             Some(rl::Region::Free(scope, id)) => {\n-                let name = lifetime_name(id);\n+                let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope,\n                     bound_region: ty::BrNamed(id, name),\n@@ -784,7 +784,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }\n                 (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    let ct_def_id = tcx.hir().local_def_id(ct.value.hir_id).expect_local();\n+                    let ct_def_id = tcx.hir().local_def_id(ct.value.hir_id);\n                     ty::Const::from_anon_const(tcx, ct_def_id).into()\n                 }\n                 _ => unreachable!(),\n@@ -1974,7 +1974,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // any ambiguity.\n     fn find_bound_for_assoc_item(\n         &self,\n-        ty_param_def_id: DefId,\n+        ty_param_def_id: LocalDefId,\n         assoc_name: ast::Ident,\n         span: Span,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported> {\n@@ -1985,11 +1985,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty_param_def_id, assoc_name, span,\n         );\n \n-        let predicates = &self.get_type_parameter_bounds(span, ty_param_def_id).predicates;\n+        let predicates =\n+            &self.get_type_parameter_bounds(span, ty_param_def_id.to_def_id()).predicates;\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n-        let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id).unwrap();\n+        let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id);\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(\n             || {\n@@ -2236,7 +2237,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             (\n                 &ty::Param(_),\n                 Res::SelfTy(Some(param_did), None) | Res::Def(DefKind::TyParam, param_did),\n-            ) => self.find_bound_for_assoc_item(param_did, assoc_ident, span)?,\n+            ) => self.find_bound_for_assoc_item(param_did.expect_local(), assoc_ident, span)?,\n             _ => {\n                 if variant_resolution.is_some() {\n                     // Variant in type position\n@@ -2372,7 +2373,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             debug!(\"qpath_to_ty: self.item_def_id()={:?}\", def_id);\n \n             let parent_def_id = def_id\n-                .and_then(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                .and_then(|def_id| {\n+                    def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                })\n                 .map(|hir_id| tcx.hir().get_parent_did(hir_id).to_def_id());\n \n             debug!(\"qpath_to_ty: parent_def_id={:?}\", parent_def_id);\n@@ -2666,7 +2669,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments);\n \n-                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n@@ -2759,7 +2762,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n                 let did = tcx.hir().local_def_id(item_id.id);\n-                self.impl_trait_ty_to_ty(did, lifetimes)\n+                self.impl_trait_ty_to_ty(did.to_def_id(), lifetimes)\n             }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n@@ -2775,7 +2778,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .unwrap_or(tcx.types.err)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length_def_id = tcx.hir().local_def_id(length.hir_id).expect_local();\n+                let length_def_id = tcx.hir().local_def_id(length.hir_id);\n                 let length = ty::Const::from_anon_const(tcx, length_def_id);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)"}, {"sha": "fc4ca1e04b97bc400a427d951f798a93339a260b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -71,49 +71,52 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n \n         let ClosureSignatures { bound_sig, liberated_sig } =\n-            self.sig_of_closure(expr_def_id, decl, body, expected_sig);\n+            self.sig_of_closure(expr_def_id.to_def_id(), decl, body, expected_sig);\n \n         debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n \n         let generator_types =\n             check_fn(self, self.param_env, liberated_sig, decl, expr.hir_id, body, gen).1;\n \n-        let base_substs =\n-            InternalSubsts::identity_for_item(self.tcx, self.tcx.closure_base_def_id(expr_def_id));\n+        let base_substs = InternalSubsts::identity_for_item(\n+            self.tcx,\n+            self.tcx.closure_base_def_id(expr_def_id.to_def_id()),\n+        );\n         // HACK(eddyb) this hardcodes indices into substs but it should rely on\n         // `ClosureSubsts` and `GeneratorSubsts` providing constructors, instead.\n         // That would also remove the need for most of the inference variables,\n         // as they immediately unified with the actual type below, including\n         // the `InferCtxt::closure_sig` and `ClosureSubsts::sig_ty` methods.\n         let tupled_upvars_idx = base_substs.len() + if generator_types.is_some() { 4 } else { 2 };\n-        let substs = base_substs.extend_to(self.tcx, expr_def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n-            GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n-                self.tcx.mk_tup(self.tcx.upvars(expr_def_id).iter().flat_map(|upvars| {\n-                    upvars.iter().map(|(&var_hir_id, _)| {\n-                        // Create type variables (for now) to represent the transformed\n-                        // types of upvars. These will be unified during the upvar\n-                        // inference phase (`upvar.rs`).\n-                        self.infcx.next_ty_var(TypeVariableOrigin {\n-                            // FIXME(eddyb) distinguish upvar inference variables from the rest.\n-                            kind: TypeVariableOriginKind::ClosureSynthetic,\n-                            span: self.tcx.hir().span(var_hir_id),\n+        let substs =\n+            base_substs.extend_to(self.tcx, expr_def_id.to_def_id(), |param, _| match param.kind {\n+                GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n+                GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n+                    self.tcx.mk_tup(self.tcx.upvars(expr_def_id).iter().flat_map(|upvars| {\n+                        upvars.iter().map(|(&var_hir_id, _)| {\n+                            // Create type variables (for now) to represent the transformed\n+                            // types of upvars. These will be unified during the upvar\n+                            // inference phase (`upvar.rs`).\n+                            self.infcx.next_ty_var(TypeVariableOrigin {\n+                                // FIXME(eddyb) distinguish upvar inference variables from the rest.\n+                                kind: TypeVariableOriginKind::ClosureSynthetic,\n+                                span: self.tcx.hir().span(var_hir_id),\n+                            })\n                         })\n+                    }))\n+                } else {\n+                    // Create type variables (for now) to represent the various\n+                    // pieces of information kept in `{Closure,Generic}Substs`.\n+                    // They will either be unified below, or later during the upvar\n+                    // inference phase (`upvar.rs`)\n+                    self.infcx.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::ClosureSynthetic,\n+                        span: expr.span,\n                     })\n-                }))\n-            } else {\n-                // Create type variables (for now) to represent the various\n-                // pieces of information kept in `{Closure,Generic}Substs`.\n-                // They will either be unified below, or later during the upvar\n-                // inference phase (`upvar.rs`)\n-                self.infcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::ClosureSynthetic,\n-                    span: expr.span,\n-                })\n-            }\n-            .into(),\n-            GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n-        });\n+                }\n+                .into(),\n+                GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n+            });\n         if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n         {\n             let generator_substs = substs.as_generator();\n@@ -126,7 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // it should rely on `GeneratorSubsts` providing a constructor, instead.\n             let substs = self.resolve_vars_if_possible(&substs);\n \n-            return self.tcx.mk_generator(expr_def_id, substs, movability);\n+            return self.tcx.mk_generator(expr_def_id.to_def_id(), substs, movability);\n         }\n \n         // Tuple up the arguments and insert the resulting function type into\n@@ -157,7 +160,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // it should rely on `ClosureSubsts` providing a constructor, instead.\n         let substs = self.resolve_vars_if_possible(&substs);\n \n-        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n+        let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), substs);\n \n         debug!(\"check_closure: expr.hir_id={:?} closure_type={:?}\", expr.hir_id, closure_type);\n "}, {"sha": "8070ad1712025a6758bdb5285a099dd689eb28e2", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1393,7 +1393,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n                 // Get the `impl Trait`'s `DefId`.\n                 if let ty::Opaque(def_id, _) = ty.kind {\n-                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id.expect_local());\n                     // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                     // get the `Trait`'s `DefId`.\n                     if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) ="}, {"sha": "590726ce8ed3778ccc49d8f5eae87ef03694e18d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -76,7 +76,7 @@ fn compare_predicate_entailment<'tcx>(\n     // This node-id should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n \n     let cause = ObligationCause {\n         span: impl_m_span,\n@@ -399,7 +399,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     trait_sig: ty::FnSig<'tcx>,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n     let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n         ImplItemKind::Fn(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n@@ -409,7 +409,8 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n \n     match *terr {\n         TypeError::Mutability => {\n-            if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n+            if let Some(def_id) = trait_m.def_id.as_local() {\n+                let trait_m_hir_id = tcx.hir().as_local_hir_id(def_id);\n                 let trait_m_iter = match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                     TraitItemKind::Fn(ref trait_m_sig, _) => trait_m_sig.decl.inputs.iter(),\n                     _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n@@ -436,7 +437,8 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n             }\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n-            if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n+            if let Some(def_id) = trait_m.def_id.as_local() {\n+                let trait_m_hir_id = tcx.hir().as_local_hir_id(def_id);\n                 let (trait_m_output, trait_m_iter) =\n                     match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                         TraitItemKind::Fn(ref trait_m_sig, _) => {\n@@ -587,33 +589,33 @@ fn compare_number_of_generics<'tcx>(\n         if impl_count != trait_count {\n             err_occurred = true;\n \n-            let (trait_spans, impl_trait_spans) =\n-                if let Some(trait_hir_id) = tcx.hir().as_local_hir_id(trait_.def_id) {\n-                    let trait_item = tcx.hir().expect_trait_item(trait_hir_id);\n-                    if trait_item.generics.params.is_empty() {\n-                        (Some(vec![trait_item.generics.span]), vec![])\n-                    } else {\n-                        let arg_spans: Vec<Span> =\n-                            trait_item.generics.params.iter().map(|p| p.span).collect();\n-                        let impl_trait_spans: Vec<Span> = trait_item\n-                            .generics\n-                            .params\n-                            .iter()\n-                            .filter_map(|p| match p.kind {\n-                                GenericParamKind::Type {\n-                                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                    ..\n-                                } => Some(p.span),\n-                                _ => None,\n-                            })\n-                            .collect();\n-                        (Some(arg_spans), impl_trait_spans)\n-                    }\n+            let (trait_spans, impl_trait_spans) = if let Some(def_id) = trait_.def_id.as_local() {\n+                let trait_hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let trait_item = tcx.hir().expect_trait_item(trait_hir_id);\n+                if trait_item.generics.params.is_empty() {\n+                    (Some(vec![trait_item.generics.span]), vec![])\n                 } else {\n-                    (trait_span.map(|s| vec![s]), vec![])\n-                };\n+                    let arg_spans: Vec<Span> =\n+                        trait_item.generics.params.iter().map(|p| p.span).collect();\n+                    let impl_trait_spans: Vec<Span> = trait_item\n+                        .generics\n+                        .params\n+                        .iter()\n+                        .filter_map(|p| match p.kind {\n+                            GenericParamKind::Type {\n+                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                                ..\n+                            } => Some(p.span),\n+                            _ => None,\n+                        })\n+                        .collect();\n+                    (Some(arg_spans), impl_trait_spans)\n+                }\n+            } else {\n+                (trait_span.map(|s| vec![s]), vec![])\n+            };\n \n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id).unwrap();\n+            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id.expect_local());\n             let impl_item = tcx.hir().expect_impl_item(impl_hir_id);\n             let impl_item_impl_trait_spans: Vec<Span> = impl_item\n                 .generics\n@@ -704,8 +706,8 @@ fn compare_number_of_method_arguments<'tcx>(\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n-        let trait_m_hir_id = tcx.hir().as_local_hir_id(trait_m.def_id);\n-        let trait_span = if let Some(trait_id) = trait_m_hir_id {\n+        let trait_span = if let Some(def_id) = trait_m.def_id.as_local() {\n+            let trait_id = tcx.hir().as_local_hir_id(def_id);\n             match tcx.hir().expect_trait_item(trait_id).kind {\n                 TraitItemKind::Fn(ref trait_m_sig, _) => {\n                     let pos = if trait_number_args > 0 { trait_number_args - 1 } else { 0 };\n@@ -728,7 +730,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         } else {\n             trait_item_span\n         };\n-        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n         let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n             ImplItemKind::Fn(ref impl_m_sig, _) => {\n                 let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n@@ -810,7 +812,7 @@ fn compare_synthetic_generics<'tcx>(\n         impl_m_type_params.zip(trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id).unwrap();\n+            let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id.expect_local());\n             let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n@@ -831,10 +833,10 @@ fn compare_synthetic_generics<'tcx>(\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n                         let new_name = tcx.sess.source_map().span_to_snippet(trait_span).ok()?;\n-                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id)?;\n+                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id.as_local()?);\n                         let trait_m = tcx.hir().trait_item(hir::TraitItemId { hir_id: trait_m });\n \n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?);\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n \n                         // in case there are no generics, take the spot between the function name\n@@ -868,7 +870,7 @@ fn compare_synthetic_generics<'tcx>(\n                 (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?);\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n@@ -961,7 +963,7 @@ crate fn compare_const_impl<'tcx>(\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id).unwrap();\n+        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id.expect_local());\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n@@ -1005,7 +1007,8 @@ crate fn compare_const_impl<'tcx>(\n                 trait_c.ident\n             );\n \n-            let trait_c_hir_id = tcx.hir().as_local_hir_id(trait_c.def_id);\n+            let trait_c_hir_id =\n+                trait_c.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id));\n             let trait_c_span = trait_c_hir_id.map(|trait_c_hir_id| {\n                 // Add a label to the Span containing just the type of the const\n                 match tcx.hir().expect_trait_item(trait_c_hir_id).kind {\n@@ -1093,7 +1096,7 @@ fn compare_type_predicate_entailment(\n     // This `HirId` should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id).unwrap();\n+    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id.expect_local());\n     let cause = ObligationCause {\n         span: impl_ty_span,\n         body_id: impl_ty_hir_id,"}, {"sha": "078401ee6a81526aa86afddeaf0ed3b27cabf383", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1,6 +1,6 @@\n use crate::check::regionck::RegionCtxt;\n use crate::hir;\n-use crate::hir::def_id::DefId;\n+use crate::hir::def_id::{DefId, LocalDefId};\n use rustc_errors::{struct_span_err, ErrorReported};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferOk, RegionckMode, TyCtxtInferExt};\n@@ -39,15 +39,15 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n         ty::Adt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,\n-                drop_impl_did,\n+                drop_impl_did.expect_local(),\n                 dtor_self_type,\n                 adt_def.did,\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n                 tcx,\n                 dtor_predicates,\n-                adt_def.did,\n+                adt_def.did.expect_local(),\n                 self_to_impl_substs,\n             )\n         }\n@@ -67,11 +67,11 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n \n fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    drop_impl_did: DefId,\n+    drop_impl_did: LocalDefId,\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n ) -> Result<(), ErrorReported> {\n-    let drop_impl_hir_id = tcx.hir().as_local_hir_id(drop_impl_did).unwrap();\n+    let drop_impl_hir_id = tcx.hir().as_local_hir_id(drop_impl_did);\n \n     // check that the impl type can be made to match the trait type.\n \n@@ -83,7 +83,8 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         let named_type = tcx.type_of(self_type_did);\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n-        let fresh_impl_substs = infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+        let fresh_impl_substs =\n+            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did.to_def_id());\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_hir_id);\n@@ -135,7 +136,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n \n         infcx.resolve_regions_and_report_errors(\n-            drop_impl_did,\n+            drop_impl_did.to_def_id(),\n             &region_scope_tree,\n             &outlives_env,\n             RegionckMode::default(),\n@@ -149,7 +150,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     dtor_predicates: ty::GenericPredicates<'tcx>,\n-    self_type_did: DefId,\n+    self_type_did: LocalDefId,\n     self_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorReported> {\n     let mut result = Ok(());\n@@ -189,7 +190,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let self_type_hir_id = tcx.hir().as_local_hir_id(self_type_did).unwrap();\n+    let self_type_hir_id = tcx.hir().as_local_hir_id(self_type_did);\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n@@ -243,8 +244,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n-            let self_descr =\n-                tcx.def_kind(self_type_did).map(|kind| kind.descr(self_type_did)).unwrap_or(\"type\");\n+            let self_descr = tcx\n+                .def_kind(self_type_did)\n+                .map(|kind| kind.descr(self_type_did.to_def_id()))\n+                .unwrap_or(\"type\");\n             struct_span_err!(\n                 tcx.sess,\n                 *predicate_sp,"}, {"sha": "2bca5e7582526bb086ba9edfd0cb665cd47cf892", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -1625,8 +1625,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         let param_def_id = generic_param.def_id;\n-        let param_hir_id = match self.tcx.hir().as_local_hir_id(param_def_id) {\n-            Some(x) => x,\n+        let param_hir_id = match param_def_id.as_local() {\n+            Some(x) => self.tcx.hir().as_local_hir_id(x),\n             None => return,\n         };\n         let param_span = self.tcx.hir().span(param_hir_id);"}, {"sha": "90a9f8a4d6f7705d938d4a86a1efdfaad3d02f58", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                 .unwrap()\n-                .insert(import_def_id);\n+                .insert(import_def_id.to_def_id());\n         }\n \n         self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span);\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             for import_id in pick.import_ids {\n                 let import_def_id = tcx.hir().local_def_id(import_id);\n                 debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n-                used_trait_imports.insert(import_def_id);\n+                used_trait_imports.insert(import_def_id.to_def_id());\n             }\n         }\n "}, {"sha": "228c40ac8538bdafb3ee61c5ea976657498e452b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -579,11 +579,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 (&self_ty.kind, parent_pred)\n                             {\n                                 if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n-                                    let node = self\n-                                        .tcx\n-                                        .hir()\n-                                        .as_local_hir_id(def.did)\n-                                        .map(|id| self.tcx.hir().get(id));\n+                                    let node = def.did.as_local().map(|def_id| {\n+                                        self.tcx.hir().get(self.tcx.hir().as_local_hir_id(def_id))\n+                                    });\n                                     if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n                                         if let Some(g) = kind.generics() {\n                                             let key = match &g.where_clause.predicates[..] {\n@@ -857,7 +855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         candidates: Vec<DefId>,\n     ) {\n         let module_did = self.tcx.parent_module(self.body_id);\n-        let module_id = self.tcx.hir().as_local_hir_id(module_did.to_def_id()).unwrap();\n+        let module_id = self.tcx.hir().as_local_hir_id(module_did);\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {\n@@ -950,62 +948,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 !unsatisfied_predicates.iter().any(|(p, _)| match p {\n-                    // Hide traits if they are present in predicates as they can be fixed without\n-                    // having to implement them.\n-                    ty::Predicate::Trait(t, _) => t.def_id() != info.def_id,\n-                    ty::Predicate::Projection(p) => p.item_def_id() != info.def_id,\n-                    _ => true,\n-                }) && (type_is_local || info.def_id.is_local())\n-                    && self\n-                        .associated_item(info.def_id, item_name, Namespace::ValueNS)\n-                        .filter(|item| {\n-                            if let ty::AssocKind::Fn = item.kind {\n-                                let id = self.tcx.hir().as_local_hir_id(item.def_id);\n-                                if let Some(hir::Node::TraitItem(hir::TraitItem {\n-                                    kind: hir::TraitItemKind::Fn(fn_sig, method),\n-                                    ..\n-                                })) = id.map(|id| self.tcx.hir().get(id))\n-                                {\n-                                    let self_first_arg = match method {\n-                                        hir::TraitFn::Required([ident, ..]) => {\n-                                            ident.name == kw::SelfLower\n-                                        }\n-                                        hir::TraitFn::Provided(body_id) => {\n-                                            match &self.tcx.hir().body(*body_id).params[..] {\n-                                                [hir::Param {\n-                                                    pat:\n-                                                        hir::Pat {\n-                                                            kind:\n-                                                                hir::PatKind::Binding(\n-                                                                    _,\n-                                                                    _,\n-                                                                    ident,\n-                                                                    ..,\n-                                                                ),\n-                                                            ..\n-                                                        },\n-                                                    ..\n-                                                }, ..] => ident.name == kw::SelfLower,\n-                                                _ => false,\n-                                            }\n-                                        }\n-                                        _ => false,\n-                                    };\n-\n-                                    if !fn_sig.decl.implicit_self.has_implicit_self()\n-                                        && self_first_arg\n+                        // Hide traits if they are present in predicates as they can be fixed without\n+                        // having to implement them.\n+                        ty::Predicate::Trait(t, _) => t.def_id() != info.def_id,\n+                        ty::Predicate::Projection(p) => p.item_def_id() != info.def_id,\n+                        _ => true,\n+                    }) && (type_is_local || info.def_id.is_local())\n+                        && self\n+                            .associated_item(info.def_id, item_name, Namespace::ValueNS)\n+                            .filter(|item| {\n+                                if let ty::AssocKind::Fn = item.kind {\n+                                    let id = item.def_id.as_local().map(|def_id| {\n+                                        self.tcx.hir().as_local_hir_id(def_id)\n+                                    });\n+                                    if let Some(hir::Node::TraitItem(hir::TraitItem {\n+                                        kind: hir::TraitItemKind::Fn(fn_sig, method),\n+                                        ..\n+                                    })) = id.map(|id| self.tcx.hir().get(id))\n                                     {\n-                                        if let Some(ty) = fn_sig.decl.inputs.get(0) {\n-                                            arbitrary_rcvr.push(ty.span);\n+                                        let self_first_arg = match method {\n+                                            hir::TraitFn::Required([ident, ..]) => {\n+                                                ident.name == kw::SelfLower\n+                                            }\n+                                            hir::TraitFn::Provided(body_id) => {\n+                                                match &self.tcx.hir().body(*body_id).params[..] {\n+                                                    [hir::Param {\n+                                                        pat:\n+                                                            hir::Pat {\n+                                                                kind:\n+                                                                    hir::PatKind::Binding(\n+                                                                        _,\n+                                                                        _,\n+                                                                        ident,\n+                                                                        ..,\n+                                                                    ),\n+                                                                ..\n+                                                            },\n+                                                        ..\n+                                                    }, ..] => ident.name == kw::SelfLower,\n+                                                    _ => false,\n+                                                }\n+                                            }\n+                                            _ => false,\n+                                        };\n+\n+                                        if !fn_sig.decl.implicit_self.has_implicit_self()\n+                                            && self_first_arg\n+                                        {\n+                                            if let Some(ty) = fn_sig.decl.inputs.get(0) {\n+                                                arbitrary_rcvr.push(ty.span);\n+                                            }\n+                                            return false;\n                                         }\n-                                        return false;\n                                     }\n                                 }\n-                            }\n-                            // We only want to suggest public or local traits (#45781).\n-                            item.vis == ty::Visibility::Public || info.def_id.is_local()\n-                        })\n-                        .is_some()\n+                                // We only want to suggest public or local traits (#45781).\n+                                item.vis == ty::Visibility::Public || info.def_id.is_local()\n+                            })\n+                            .is_some()\n             })\n             .collect::<Vec<_>>();\n         for span in &arbitrary_rcvr {\n@@ -1052,7 +1052,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(table_owner.to_def_id());\n                     let type_param = generics.type_param(param, self.tcx);\n                     let hir = &self.tcx.hir();\n-                    if let Some(id) = hir.as_local_hir_id(type_param.def_id) {\n+                    if let Some(def_id) = type_param.def_id.as_local() {\n+                        let id = hir.as_local_hir_id(def_id);\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: FooBar`,\n                         // instead we suggest `T: Foo + Bar` in that case.\n@@ -1258,7 +1259,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n             match i.kind {\n                 hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) => {\n                     let def_id = self.map.local_def_id(i.hir_id);\n-                    self.traits.push(def_id);\n+                    self.traits.push(def_id.to_def_id());\n                 }\n                 _ => (),\n             }"}, {"sha": "51e3bc4cae406ba97184d1749857f9bfe8b5f61c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 82, "deletions": 73, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -750,20 +750,20 @@ fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n fn typeck_item_bodies(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.par_body_owners(|body_owner_def_id| {\n-        tcx.ensure().typeck_tables_of(body_owner_def_id.to_def_id());\n+        tcx.ensure().typeck_tables_of(body_owner_def_id);\n     });\n }\n \n fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_item_well_formed(tcx, def_id);\n+    wfcheck::check_item_well_formed(tcx, def_id.expect_local());\n }\n \n fn check_trait_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_trait_item(tcx, def_id);\n+    wfcheck::check_trait_item(tcx, def_id.expect_local());\n }\n \n fn check_impl_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_impl_item(tcx, def_id);\n+    wfcheck::check_impl_item(tcx, def_id.expect_local());\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -977,7 +977,7 @@ fn diagnostic_only_typeck_tables_of<'tcx>(\n ) -> &ty::TypeckTables<'tcx> {\n     assert!(def_id.is_local());\n     let fallback = move || {\n-        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id).unwrap());\n+        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id.expect_local()));\n         tcx.sess.delay_span_bug(span, \"diagnostic only typeck table used\");\n         tcx.types.err\n     };\n@@ -996,7 +996,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n         return tcx.typeck_tables_of(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n@@ -1332,8 +1332,8 @@ fn check_fn<'a, 'tcx>(\n         fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n     }\n \n-    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id));\n-    let outer_hir_id = hir.as_local_hir_id(outer_def_id).unwrap();\n+    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id());\n+    let outer_hir_id = hir.as_local_hir_id(outer_def_id.expect_local());\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n@@ -1448,7 +1448,7 @@ fn check_fn<'a, 'tcx>(\n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = tcx.lang_items().termination() {\n         if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = hir.as_local_hir_id(def_id).unwrap();\n+            let main_id = hir.as_local_hir_id(def_id.expect_local());\n             if main_id == fn_id {\n                 let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n@@ -1470,7 +1470,7 @@ fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n-        if panic_impl_did == hir.local_def_id(fn_id) {\n+        if panic_impl_did == hir.local_def_id(fn_id).to_def_id() {\n             if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n                 if declared_ret_ty.kind != ty::Never {\n                     sess.span_err(decl.output.span(), \"return type should be `!`\");\n@@ -1514,7 +1514,7 @@ fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n-        if alloc_error_handler_did == hir.local_def_id(fn_id) {\n+        if alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id() {\n             if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.kind != ty::Never {\n                     sess.span_err(decl.output.span(), \"return type should be `!`\");\n@@ -1566,23 +1566,23 @@ fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n         check_simd(tcx, span, def_id);\n     }\n \n-    check_transparent(tcx, span, def_id);\n-    check_packed(tcx, span, def_id);\n+    check_transparent(tcx, span, def);\n+    check_packed(tcx, span, def);\n }\n \n fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n-    check_transparent(tcx, span, def_id);\n+    check_transparent(tcx, span, def);\n     check_union_fields(tcx, span, def_id);\n-    check_packed(tcx, span, def_id);\n+    check_packed(tcx, span, def);\n }\n \n /// When the `#![feature(untagged_unions)]` gate is active,\n /// check that the fields of the `union` does not contain fields that need dropping.\n-fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n+fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n     let item_type = tcx.type_of(item_def_id);\n     if let ty::Adt(def, substs) = item_type.kind {\n         assert!(def.is_union());\n@@ -1614,7 +1614,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n /// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n@@ -1625,9 +1625,8 @@ fn check_opaque<'tcx>(\n \n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n-fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: DefId, span: Span) {\n-    let item =\n-        tcx.hir().expect_item(tcx.hir().as_local_hir_id(def_id).expect(\"opaque type is not local\"));\n+fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    let item = tcx.hir().expect_item(tcx.hir().as_local_hir_id(def_id));\n     debug!(\n         \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n         def_id, span, item\n@@ -1661,8 +1660,10 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: DefId, span:\n             ..\n         }) => {\n             let mut visitor = ProhibitOpaqueVisitor {\n-                opaque_identity_ty: tcx\n-                    .mk_opaque(def_id, InternalSubsts::identity_for_item(tcx, def_id)),\n+                opaque_identity_ty: tcx.mk_opaque(\n+                    def_id.to_def_id(),\n+                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+                ),\n                 generics: tcx.generics_of(def_id),\n             };\n             debug!(\"check_opaque_for_inheriting_lifetimes: visitor={:?}\", visitor);\n@@ -1699,12 +1700,13 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: DefId, span:\n /// Checks that an opaque type does not contain cycles.\n fn check_opaque_for_cycles<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n-    if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n+    if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n+    {\n         if let hir::OpaqueTyOrigin::AsyncFn = origin {\n             struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\",)\n                 .span_label(span, \"recursive `async fn`\")\n@@ -1736,7 +1738,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n-        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id))\n+        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id).to_def_id())\n     );\n     let _indenter = indenter();\n     match it.kind {\n@@ -1764,7 +1766,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n         }\n         hir::ItemKind::Trait(_, _, _, _, ref items) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n-            check_on_unimplemented(tcx, def_id, it);\n+            check_on_unimplemented(tcx, def_id.to_def_id(), it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n@@ -1783,7 +1785,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n \n-            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n             check_opaque(tcx, def_id, substs, it.span, &origin);\n         }\n         hir::ItemKind::TyAlias(..) => {\n@@ -1846,7 +1848,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     }\n }\n \n-fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span) {\n+fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: Span) {\n     // Only restricted on wasm32 target for now\n     if !tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n         return;\n@@ -1866,7 +1868,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     // `#[link_section]` may contain arbitrary, or even undefined bytes, but it is\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n-    match tcx.const_eval_poly(id) {\n+    match tcx.const_eval_poly(id.to_def_id()) {\n         Ok(ConstValue::ByRef { alloc, .. }) => {\n             if alloc.relocations().len() != 0 {\n                 let msg = \"statics with a custom `#[link_section]` must be a \\\n@@ -1883,7 +1885,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n     let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id.to_def_id());\n }\n \n fn report_forbidden_specialization(\n@@ -1987,7 +1989,7 @@ fn check_specialization_validity<'tcx>(\n fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     full_impl_span: Span,\n-    impl_id: DefId,\n+    impl_id: LocalDefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n@@ -2128,13 +2130,19 @@ fn check_impl_items_against_trait<'tcx>(\n                 }\n             }\n \n-            check_specialization_validity(tcx, trait_def, &ty_trait_item, impl_id, impl_item);\n+            check_specialization_validity(\n+                tcx,\n+                trait_def,\n+                &ty_trait_item,\n+                impl_id.to_def_id(),\n+                impl_item,\n+            );\n         }\n     }\n \n     // Check for missing items from trait\n     let mut missing_items = Vec::new();\n-    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) {\n+    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n         for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n             let is_implemented = ancestors\n                 .leaf_def(tcx, trait_item.ident, trait_item.kind)\n@@ -2358,7 +2366,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n+fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bool {\n     let rty = tcx.type_of(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -2368,7 +2376,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive(spans) => {\n-            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id);\n+            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id());\n             for span in spans {\n                 err.span_label(span, \"recursive without indirection\");\n             }\n@@ -2380,7 +2388,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n     true\n }\n \n-pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n+pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     let t = tcx.type_of(def_id);\n     if let ty::Adt(def, substs) = t.kind {\n         if def.is_struct() {\n@@ -2414,10 +2422,10 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     }\n }\n \n-fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n-    let repr = tcx.adt_def(def_id).repr;\n+fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n+    let repr = def.repr;\n     if repr.packed() {\n-        for attr in tcx.get_attrs(def_id).iter() {\n+        for attr in tcx.get_attrs(def.did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n                     if let Some(repr_pack) = repr.pack {\n@@ -2443,7 +2451,7 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n             )\n             .emit();\n         } else {\n-            if let Some(def_spans) = check_packed_inner(tcx, def_id, &mut vec![]) {\n+            if let Some(def_spans) = check_packed_inner(tcx, def.did, &mut vec![]) {\n                 let mut err = struct_span_err!(\n                     tcx.sess,\n                     sp,\n@@ -2452,34 +2460,32 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n                 );\n \n                 let hir = tcx.hir();\n-                if let Some(hir_id) = hir.as_local_hir_id(def_spans[0].0) {\n-                    if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n-                        err.span_note(\n-                            tcx.def_span(def_spans[0].0),\n-                            &format!(\"`{}` has a `#[repr(align)]` attribute\", ident),\n-                        );\n-                    }\n+                let hir_id = hir.as_local_hir_id(def_spans[0].0.expect_local());\n+                if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                    err.span_note(\n+                        tcx.def_span(def_spans[0].0),\n+                        &format!(\"`{}` has a `#[repr(align)]` attribute\", ident),\n+                    );\n                 }\n \n                 if def_spans.len() > 2 {\n                     let mut first = true;\n                     for (adt_def, span) in def_spans.iter().skip(1).rev() {\n-                        if let Some(hir_id) = hir.as_local_hir_id(*adt_def) {\n-                            if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n-                                err.span_note(\n-                                    *span,\n-                                    &if first {\n-                                        format!(\n-                                            \"`{}` contains a field of type `{}`\",\n-                                            tcx.type_of(def_id),\n-                                            ident\n-                                        )\n-                                    } else {\n-                                        format!(\"...which contains a field of type `{}`\", ident)\n-                                    },\n-                                );\n-                                first = false;\n-                            }\n+                        let hir_id = hir.as_local_hir_id(adt_def.expect_local());\n+                        if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                            err.span_note(\n+                                *span,\n+                                &if first {\n+                                    format!(\n+                                        \"`{}` contains a field of type `{}`\",\n+                                        tcx.type_of(def.did),\n+                                        ident\n+                                    )\n+                                } else {\n+                                    format!(\"...which contains a field of type `{}`\", ident)\n+                                },\n+                            );\n+                            first = false;\n                         }\n                     }\n                 }\n@@ -2564,8 +2570,7 @@ fn bad_non_zero_sized_fields<'tcx>(\n     err.emit();\n }\n \n-fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n-    let adt = tcx.adt_def(def_id);\n+fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty::AdtDef) {\n     if !adt.repr.transparent() {\n         return;\n     }\n@@ -2582,7 +2587,7 @@ fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     }\n \n     if adt.variants.len() != 1 {\n-        bad_variant_count(tcx, adt, sp, def_id);\n+        bad_variant_count(tcx, adt, sp, adt.did);\n         if adt.variants.is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n@@ -2634,7 +2639,7 @@ pub fn check_enum<'tcx>(\n     def.destructor(tcx); // force the destructor to be evaluated\n \n     if vs.is_empty() {\n-        let attributes = tcx.get_attrs(def_id);\n+        let attributes = tcx.get_attrs(def_id.to_def_id());\n         if let Some(attr) = attr::find_by_name(&attributes, sym::repr) {\n             struct_span_err!(\n                 tcx.sess,\n@@ -2689,7 +2694,7 @@ pub fn check_enum<'tcx>(\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;\n-            let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n+            let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did.expect_local());\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n@@ -2714,7 +2719,7 @@ pub fn check_enum<'tcx>(\n     }\n \n     check_representable(tcx, sp, def_id);\n-    check_transparent(tcx, sp, def_id);\n+    check_transparent(tcx, sp, def);\n }\n \n fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n@@ -2750,7 +2755,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let item_id = tcx.hir().ty_param_owner(hir_id);\n         let item_def_id = tcx.hir().local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n@@ -3243,7 +3248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (value, opaque_type_map) =\n             self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-                parent_def_id,\n+                parent_def_id.to_def_id(),\n                 self.body_id,\n                 self.param_env,\n                 value,\n@@ -3348,7 +3353,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n-        let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id).expect_local();\n+        let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id);\n         let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n \n         // HACK(eddyb) emulate what a `WellFormedConst` obligation would do.\n@@ -4965,7 +4970,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n                     sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                    match hir.as_local_hir_id(def_id).and_then(|hir_id| hir.def_kind(hir_id)) {\n+                    match def_id\n+                        .as_local()\n+                        .map(|def_id| hir.as_local_hir_id(def_id))\n+                        .and_then(|hir_id| hir.def_kind(hir_id))\n+                    {\n                         Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n                             msg = \"instantiate this tuple variant\";\n                         }"}, {"sha": "58c8d56b55838883c19bcc23fe4d2e4ca10c4474", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self,\n             RepeatingScope(item_id),\n             item_id,\n-            Subject(subject),\n+            Subject(subject.to_def_id()),\n             self.param_env,\n         );\n         rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);"}, {"sha": "3ff79a6b5de6c921b6b9f8c036b28061f489cee4", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let upvar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n                         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                        closure_expr_id: closure_def_id.expect_local(),\n+                        closure_expr_id: closure_def_id,\n                     };\n                     let capture = self.tables.borrow().upvar_capture(upvar_id);\n "}, {"sha": "ffe1dcbd444039c6702ac13a991c63e2d8ce34f4", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::ItemKind;\n@@ -70,14 +70,14 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n-pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\n         \"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n         item.hir_id,\n-        tcx.def_path_str(def_id)\n+        tcx.def_path_str(def_id.to_def_id())\n     );\n \n     match item.kind {\n@@ -183,8 +183,8 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n     }\n }\n \n-pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n     let method_sig = match trait_item.kind {\n@@ -195,10 +195,10 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: DefId) {\n     check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n }\n \n-fn could_be_self(trait_def_id: DefId, ty: &hir::Ty<'_>) -> bool {\n+fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {\n     match ty.kind {\n         hir::TyKind::TraitObject([trait_ref], ..) => match trait_ref.trait_ref.path.segments {\n-            [s] => s.res.and_then(|r| r.opt_def_id()) == Some(trait_def_id),\n+            [s] => s.res.and_then(|r| r.opt_def_id()) == Some(trait_def_id.to_def_id()),\n             _ => false,\n         },\n         _ => false,\n@@ -257,8 +257,8 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n     }\n }\n \n-pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n     let method_sig = match impl_item.kind {\n@@ -330,7 +330,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n }\n \n fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n-    let def_id = tcx.hir().local_def_id(id).expect_local();\n+    let def_id = tcx.hir().local_def_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n         id,\n@@ -413,7 +413,7 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, def_id, None);\n+        check_where_clauses(tcx, fcx, item.span, def_id.to_def_id(), None);\n \n         // No implied bounds in a struct definition.\n         vec![]\n@@ -441,8 +441,8 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     }\n \n     for_item(tcx, item).with_fcx(|fcx, _| {\n-        check_where_clauses(tcx, fcx, item.span, trait_def_id, None);\n-        check_associated_type_defaults(fcx, trait_def_id);\n+        check_where_clauses(tcx, fcx, item.span, trait_def_id.to_def_id(), None);\n+        check_associated_type_defaults(fcx, trait_def_id.to_def_id());\n \n         vec![]\n     });\n@@ -555,7 +555,15 @@ fn check_item_fn(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n             ItemKind::Fn(sig, ..) => sig,\n             _ => bug!(\"expected `ItemKind::Fn`, found `{:?}`\", item.kind),\n         };\n-        check_fn_or_method(tcx, fcx, item.ident.span, sig, hir_sig, def_id, &mut implied_bounds);\n+        check_fn_or_method(\n+            tcx,\n+            fcx,\n+            item.ident.span,\n+            sig,\n+            hir_sig,\n+            def_id.to_def_id(),\n+            &mut implied_bounds,\n+        );\n         implied_bounds\n     })\n }\n@@ -631,9 +639,9 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item_def_id, None);\n+        check_where_clauses(tcx, fcx, item.span, item_def_id.to_def_id(), None);\n \n-        fcx.impl_implied_bounds(item_def_id, item.span)\n+        fcx.impl_implied_bounds(item_def_id.to_def_id(), item.span)\n     });\n }\n \n@@ -781,7 +789,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     let mut predicates = predicates.instantiate_identity(fcx.tcx);\n \n     if let Some((return_ty, span)) = return_ty {\n-        let opaque_types = check_opaque_types(tcx, fcx, def_id, span, return_ty);\n+        let opaque_types = check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n         for _ in 0..opaque_types.len() {\n             predicates.spans.push(span);\n         }\n@@ -854,7 +862,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n fn check_opaque_types<'fcx, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n-    fn_def_id: DefId,\n+    fn_def_id: LocalDefId,\n     span: Span,\n     ty: Ty<'tcx>,\n ) -> Vec<ty::Predicate<'tcx>> {\n@@ -870,7 +878,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                 // FIXME(eddyb) is  `generics.parent.is_none()` correct? It seems\n                 // potentially risky wrt associated types in `impl`s.\n                 if generics.parent.is_none() && def_id.is_local() {\n-                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                     if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n                         trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n                         let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();"}, {"sha": "56714a4fa679313dd8ba713125b2c8a21e71ec74", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -42,7 +42,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is uSymbol for unit tests.\n-        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n+        let rustc_dump_user_substs =\n+            self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for param in body.params {\n@@ -426,7 +427,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n-            let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = self.tcx().hir().as_local_hir_id(def_id.expect_local());\n             let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());"}, {"sha": "da93462fe2681330bb20f973f73967966b9adcc4", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -50,7 +50,7 @@ impl CheckVisitor<'tcx> {\n             return;\n         }\n \n-        if self.used_trait_imports.contains(&def_id) {\n+        if self.used_trait_imports.contains(&def_id.to_def_id()) {\n             return;\n         }\n \n@@ -89,10 +89,8 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n             // Note that if we carry through to the `extern_mod_stmt_cnum` query\n             // below it'll cause a panic because `def_id` is actually bogus at this\n             // point in time otherwise.\n-            if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n-                if tcx.hir().find(id).is_none() {\n-                    return false;\n-                }\n+            if tcx.hir().find(tcx.hir().as_local_hir_id(def_id.expect_local())).is_none() {\n+                return false;\n             }\n             true\n         })\n@@ -115,7 +113,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     });\n \n     for extern_crate in &crates_to_lint {\n-        let id = tcx.hir().as_local_hir_id(extern_crate.def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(extern_crate.def_id.expect_local());\n         let item = tcx.hir().expect_item(id);\n \n         // If the crate is fully unused, we suggest removing it altogether.\n@@ -216,7 +214,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n             let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(ExternCrateToLint {\n-                def_id: extern_crate_def_id,\n+                def_id: extern_crate_def_id.to_def_id(),\n                 span: item.span,\n                 orig_name,\n                 warn_if_unused: !item.ident.as_str().starts_with('_'),"}, {"sha": "c01c4d90c8e17b2f1ffef1400e1818810184cb18", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 143, "deletions": 153, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -3,7 +3,7 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::UnsizeTraitLangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer;\n@@ -35,7 +35,7 @@ struct Checker<'tcx> {\n impl<'tcx> Checker<'tcx> {\n     fn check<F>(&self, trait_def_id: Option<DefId>, mut f: F) -> &Self\n     where\n-        F: FnMut(TyCtxt<'tcx>, DefId),\n+        F: FnMut(TyCtxt<'tcx>, LocalDefId),\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n             for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n@@ -47,13 +47,13 @@ impl<'tcx> Checker<'tcx> {\n     }\n }\n \n-fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n+fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     // Destructors only work on nominal types.\n     if let ty::Adt(..) | ty::Error = tcx.type_of(impl_did).kind {\n         return;\n     }\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).expect(\"foreign Drop impl on non-ADT\");\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n     let sp = match tcx.hir().expect_item(impl_hir_id).kind {\n         ItemKind::Impl { self_ty, .. } => self_ty.span,\n         _ => bug!(\"expected Drop impl item\"),\n@@ -69,15 +69,10 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n     .emit();\n }\n \n-fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n+fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did) {\n-        n\n-    } else {\n-        debug!(\"visit_implementation_of_copy(): impl not in this crate\");\n-        return;\n-    };\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n \n     let self_type = tcx.type_of(impl_did);\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\", self_type);\n@@ -137,187 +132,184 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n     }\n }\n \n-fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\", impl_did);\n \n     // Just compute this for the side-effects, in particular reporting\n     // errors; other parts of the code may demand it for the info of\n     // course.\n-    if impl_did.is_local() {\n-        let span = tcx.def_span(impl_did);\n-        tcx.at(span).coerce_unsized_info(impl_did);\n-    }\n+    let span = tcx.def_span(impl_did);\n+    tcx.at(span).coerce_unsized_info(impl_did);\n }\n \n-fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n+fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n-    if impl_did.is_local() {\n-        let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-        let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n-        let span = tcx.hir().span(impl_hir_id);\n+    let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-        let source = tcx.type_of(impl_did);\n-        assert!(!source.has_escaping_bound_vars());\n-        let target = {\n-            let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n-            assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n+    let span = tcx.hir().span(impl_hir_id);\n \n-            trait_ref.substs.type_at(1)\n-        };\n+    let source = tcx.type_of(impl_did);\n+    assert!(!source.has_escaping_bound_vars());\n+    let target = {\n+        let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+        assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n \n-        debug!(\"visit_implementation_of_dispatch_from_dyn: {:?} -> {:?}\", source, target);\n+        trait_ref.substs.type_at(1)\n+    };\n \n-        let param_env = tcx.param_env(impl_did);\n+    debug!(\"visit_implementation_of_dispatch_from_dyn: {:?} -> {:?}\", source, target);\n \n-        let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n+    let param_env = tcx.param_env(impl_did);\n \n-        tcx.infer_ctxt().enter(|infcx| {\n-            let cause = ObligationCause::misc(span, impl_hir_id);\n+    let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n \n-            use ty::TyKind::*;\n-            match (&source.kind, &target.kind) {\n-                (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n-                (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n-                (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n-                    if def_a.is_struct() && def_b.is_struct() =>\n-                {\n-                    if def_a != def_b {\n-                        let source_path = tcx.def_path_str(def_a.did);\n-                        let target_path = tcx.def_path_str(def_b.did);\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let cause = ObligationCause::misc(span, impl_hir_id);\n \n-                        create_err(&format!(\n-                            \"the trait `DispatchFromDyn` may only be implemented \\\n+        use ty::TyKind::*;\n+        match (&source.kind, &target.kind) {\n+            (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n+                if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+            (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n+            (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n+                if def_a.is_struct() && def_b.is_struct() =>\n+            {\n+                if def_a != def_b {\n+                    let source_path = tcx.def_path_str(def_a.did);\n+                    let target_path = tcx.def_path_str(def_b.did);\n+\n+                    create_err(&format!(\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n                                 for a coercion between structures with the same \\\n                                 definition; expected `{}`, found `{}`\",\n-                            source_path, target_path,\n-                        ))\n-                        .emit();\n+                        source_path, target_path,\n+                    ))\n+                    .emit();\n \n-                        return;\n-                    }\n+                    return;\n+                }\n \n-                    if def_a.repr.c() || def_a.repr.packed() {\n-                        create_err(\n-                            \"structs implementing `DispatchFromDyn` may not have \\\n+                if def_a.repr.c() || def_a.repr.packed() {\n+                    create_err(\n+                        \"structs implementing `DispatchFromDyn` may not have \\\n                              `#[repr(packed)]` or `#[repr(C)]`\",\n-                        )\n-                        .emit();\n-                    }\n+                    )\n+                    .emit();\n+                }\n \n-                    let fields = &def_a.non_enum_variant().fields;\n+                let fields = &def_a.non_enum_variant().fields;\n \n-                    let coerced_fields = fields\n-                        .iter()\n-                        .filter_map(|field| {\n-                            let ty_a = field.ty(tcx, substs_a);\n-                            let ty_b = field.ty(tcx, substs_b);\n+                let coerced_fields = fields\n+                    .iter()\n+                    .filter_map(|field| {\n+                        let ty_a = field.ty(tcx, substs_a);\n+                        let ty_b = field.ty(tcx, substs_b);\n \n-                            if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n-                                if layout.is_zst() && layout.align.abi.bytes() == 1 {\n-                                    // ignore ZST fields with alignment of 1 byte\n-                                    return None;\n-                                }\n+                        if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n+                            if layout.is_zst() && layout.align.abi.bytes() == 1 {\n+                                // ignore ZST fields with alignment of 1 byte\n+                                return None;\n                             }\n+                        }\n \n-                            if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n-                                if ok.obligations.is_empty() {\n-                                    create_err(\n-                                        \"the trait `DispatchFromDyn` may only be implemented \\\n+                        if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                            if ok.obligations.is_empty() {\n+                                create_err(\n+                                    \"the trait `DispatchFromDyn` may only be implemented \\\n                                      for structs containing the field being coerced, \\\n                                      ZST fields with 1 byte alignment, and nothing else\",\n-                                    )\n-                                    .note(&format!(\n-                                        \"extra field `{}` of type `{}` is not allowed\",\n-                                        field.ident, ty_a,\n-                                    ))\n-                                    .emit();\n-\n-                                    return None;\n-                                }\n+                                )\n+                                .note(&format!(\n+                                    \"extra field `{}` of type `{}` is not allowed\",\n+                                    field.ident, ty_a,\n+                                ))\n+                                .emit();\n+\n+                                return None;\n                             }\n+                        }\n \n-                            Some(field)\n-                        })\n-                        .collect::<Vec<_>>();\n+                        Some(field)\n+                    })\n+                    .collect::<Vec<_>>();\n \n-                    if coerced_fields.is_empty() {\n-                        create_err(\n-                            \"the trait `DispatchFromDyn` may only be implemented \\\n+                if coerced_fields.is_empty() {\n+                    create_err(\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n                             for a coercion between structures with a single field \\\n                             being coerced, none found\",\n-                        )\n-                        .emit();\n-                    } else if coerced_fields.len() > 1 {\n-                        create_err(\n-                            \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n-                        )\n-                        .note(\n-                            \"the trait `DispatchFromDyn` may only be implemented \\\n+                    )\n+                    .emit();\n+                } else if coerced_fields.len() > 1 {\n+                    create_err(\n+                        \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n+                    )\n+                    .note(\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n                                 for a coercion between structures with a single field \\\n                                 being coerced\",\n-                        )\n-                        .note(&format!(\n-                            \"currently, {} fields need coercions: {}\",\n-                            coerced_fields.len(),\n-                            coerced_fields\n-                                .iter()\n-                                .map(|field| {\n-                                    format!(\n-                                        \"`{}` (`{}` to `{}`)\",\n-                                        field.ident,\n-                                        field.ty(tcx, substs_a),\n-                                        field.ty(tcx, substs_b),\n-                                    )\n-                                })\n-                                .collect::<Vec<_>>()\n-                                .join(\", \")\n-                        ))\n-                        .emit();\n-                    } else {\n-                        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n-\n-                        for field in coerced_fields {\n-                            let predicate = predicate_for_trait_def(\n-                                tcx,\n-                                param_env,\n-                                cause.clone(),\n-                                dispatch_from_dyn_trait,\n-                                0,\n-                                field.ty(tcx, substs_a),\n-                                &[field.ty(tcx, substs_b).into()],\n-                            );\n-\n-                            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-                        }\n+                    )\n+                    .note(&format!(\n+                        \"currently, {} fields need coercions: {}\",\n+                        coerced_fields.len(),\n+                        coerced_fields\n+                            .iter()\n+                            .map(|field| {\n+                                format!(\n+                                    \"`{}` (`{}` to `{}`)\",\n+                                    field.ident,\n+                                    field.ty(tcx, substs_a),\n+                                    field.ty(tcx, substs_b),\n+                                )\n+                            })\n+                            .collect::<Vec<_>>()\n+                            .join(\", \")\n+                    ))\n+                    .emit();\n+                } else {\n+                    let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+\n+                    for field in coerced_fields {\n+                        let predicate = predicate_for_trait_def(\n+                            tcx,\n+                            param_env,\n+                            cause.clone(),\n+                            dispatch_from_dyn_trait,\n+                            0,\n+                            field.ty(tcx, substs_a),\n+                            &[field.ty(tcx, substs_b).into()],\n+                        );\n \n-                        // Check that all transitive obligations are satisfied.\n-                        if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                            infcx.report_fulfillment_errors(&errors, None, false);\n-                        }\n+                        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                    }\n \n-                        // Finally, resolve all regions.\n-                        let region_scope_tree = region::ScopeTree::default();\n-                        let outlives_env = OutlivesEnvironment::new(param_env);\n-                        infcx.resolve_regions_and_report_errors(\n-                            impl_did,\n-                            &region_scope_tree,\n-                            &outlives_env,\n-                            RegionckMode::default(),\n-                        );\n+                    // Check that all transitive obligations are satisfied.\n+                    if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+                        infcx.report_fulfillment_errors(&errors, None, false);\n                     }\n+\n+                    // Finally, resolve all regions.\n+                    let region_scope_tree = region::ScopeTree::default();\n+                    let outlives_env = OutlivesEnvironment::new(param_env);\n+                    infcx.resolve_regions_and_report_errors(\n+                        impl_did.to_def_id(),\n+                        &region_scope_tree,\n+                        &outlives_env,\n+                        RegionckMode::default(),\n+                    );\n                 }\n-                _ => {\n-                    create_err(\n-                        \"the trait `DispatchFromDyn` may only be implemented \\\n+            }\n+            _ => {\n+                create_err(\n+                    \"the trait `DispatchFromDyn` may only be implemented \\\n                         for a coercion between structures\",\n-                    )\n-                    .emit();\n-                }\n+                )\n+                .emit();\n             }\n-        })\n-    }\n+        }\n+    })\n }\n \n pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n@@ -329,9 +321,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n-        bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n-    });\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local());\n \n     let source = tcx.type_of(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();"}, {"sha": "6817312e303ae2f32ef9a4900a20da8082da6769", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -9,7 +9,7 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::{self, CrateInherentImpls, TyCtxt};\n \n@@ -327,7 +327,7 @@ impl InherentCollect<'tcx> {\n             // the implementation does not have any associated traits.\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n-            vec.push(impl_def_id);\n+            vec.push(impl_def_id.to_def_id());\n         } else {\n             struct_span_err!(\n                 self.tcx.sess,\n@@ -344,18 +344,18 @@ impl InherentCollect<'tcx> {\n \n     fn check_primitive_impl(\n         &self,\n-        impl_def_id: DefId,\n+        impl_def_id: LocalDefId,\n         lang_def_id: Option<DefId>,\n         lang_def_id2: Option<DefId>,\n         lang: &str,\n         ty: &str,\n         span: Span,\n     ) {\n         match (lang_def_id, lang_def_id2) {\n-            (Some(lang_def_id), _) if lang_def_id == impl_def_id => {\n+            (Some(lang_def_id), _) if lang_def_id == impl_def_id.to_def_id() => {\n                 // OK\n             }\n-            (_, Some(lang_def_id)) if lang_def_id == impl_def_id => {\n+            (_, Some(lang_def_id)) if lang_def_id == impl_def_id.to_def_id() => {\n                 // OK\n             }\n             _ => {"}, {"sha": "d8ffb9f6b4c07e080b169b92d7e3b3768ad40c44", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -6,7 +6,7 @@\n // mappings. That mapping code resides here.\n \n use rustc_errors::struct_span_err;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n@@ -19,15 +19,15 @@ mod orphan;\n mod unsafety;\n \n /// Obtains the span of just the impl header of `impl_def_id`.\n-fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Span {\n-    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap())\n+fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) -> Span {\n+    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id.to_def_id()).unwrap())\n }\n \n-fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>) {\n+fn check_impl(tcx: TyCtxt<'_>, impl_def_id: LocalDefId, trait_ref: ty::TraitRef<'_>) {\n     debug!(\n         \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n         trait_ref,\n-        tcx.def_path_str(impl_def_id)\n+        tcx.def_path_str(impl_def_id.to_def_id())\n     );\n \n     // Skip impls where one of the self type is an error type.\n@@ -40,7 +40,11 @@ fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>)\n     enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n }\n \n-fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_trait_manually_implementable(\n+    tcx: TyCtxt<'_>,\n+    impl_def_id: LocalDefId,\n+    trait_def_id: DefId,\n+) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n \n@@ -117,7 +121,11 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, tra\n \n /// We allow impls of marker traits to overlap, so they can't override impls\n /// as that could make it ambiguous which associated item to use.\n-fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_empty_impls_for_marker_traits(\n+    tcx: TyCtxt<'_>,\n+    impl_def_id: LocalDefId,\n+    trait_def_id: DefId,\n+) {\n     if !tcx.trait_def(trait_def_id).is_marker {\n         return;\n     }\n@@ -177,7 +185,7 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n /// Checks whether an impl overlaps with the automatic `impl Trait for dyn Trait`.\n fn check_object_overlap<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     trait_ref: ty::TraitRef<'tcx>,\n ) {\n     let trait_def_id = trait_ref.def_id;"}, {"sha": "71469770f2a33f642f058986d36ef540620fb2f9", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -35,7 +35,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n             let trait_def_id = trait_ref.def_id;\n             let sm = self.tcx.sess.source_map();\n             let sp = sm.guess_head_span(item.span);\n-            match traits::orphan_check(self.tcx, def_id) {\n+            match traits::orphan_check(self.tcx, def_id.to_def_id()) {\n                 Ok(()) => {}\n                 Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {\n                     let mut err = struct_span_err!("}, {"sha": "a831beb2be253089a22d4b95d118262dd32d0c69", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -26,7 +26,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::weak_lang_items;\n use rustc_hir::{GenericParamKind, Node, Unsafety};\n@@ -269,10 +269,7 @@ impl ItemCtxt<'tcx> {\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n-        self.tcx\n-            .hir()\n-            .as_local_hir_id(self.item_def_id)\n-            .expect(\"Non-local call to local provider is_const_fn\")\n+        self.tcx.hir().as_local_hir_id(self.item_def_id.expect_local())\n     }\n \n     pub fn node(&self) -> hir::Node<'tcx> {\n@@ -489,16 +486,19 @@ fn type_param_predicates(\n     // written inline like `<T: Foo>` or in a where-clause like\n     // `where T: Foo`.\n \n-    let param_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let param_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.param_def_id_to_index[&def_id];\n     let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n-    let parent =\n-        if item_def_id == param_owner_def_id { None } else { tcx.generics_of(item_def_id).parent };\n+    let parent = if item_def_id == param_owner_def_id.to_def_id() {\n+        None\n+    } else {\n+        tcx.generics_of(item_def_id).parent\n+    };\n \n     let mut result = parent\n         .map(|parent| {\n@@ -508,7 +508,7 @@ fn type_param_predicates(\n         .unwrap_or_default();\n     let mut extend = None;\n \n-    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id).unwrap();\n+    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n     let ast_generics = match tcx.hir().get(item_hir_id) {\n         Node::TraitItem(item) => &item.generics,\n \n@@ -613,7 +613,7 @@ fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty<'_>, param_id: hir::HirId) -> bool\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.kind {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n-                def_id == tcx.hir().local_def_id(param_id)\n+                def_id == tcx.hir().local_def_id(param_id).to_def_id()\n             }\n             _ => false,\n         }\n@@ -647,7 +647,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id(), &enum_definition.variants);\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.generics_of(def_id);\n@@ -769,7 +769,7 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::V\n         prev_discr = Some(\n             if let Some(ref e) = variant.disr_expr {\n                 let expr_did = tcx.hir().local_def_id(e.hir_id);\n-                def.eval_explicit_discr(tcx, expr_did)\n+                def.eval_explicit_discr(tcx, expr_did.to_def_id())\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n             } else {\n@@ -805,16 +805,16 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::V\n \n fn convert_variant(\n     tcx: TyCtxt<'_>,\n-    variant_did: Option<DefId>,\n-    ctor_did: Option<DefId>,\n+    variant_did: Option<LocalDefId>,\n+    ctor_did: Option<LocalDefId>,\n     ident: Ident,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData<'_>,\n     adt_kind: ty::AdtKind,\n-    parent_did: DefId,\n+    parent_did: LocalDefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did));\n     let fields = def\n         .fields()\n         .iter()\n@@ -837,7 +837,7 @@ fn convert_variant(\n             }\n \n             ty::FieldDef {\n-                did: fid,\n+                did: fid.to_def_id(),\n                 ident: f.ident,\n                 vis: ty::Visibility::from_hir(&f.vis, hir_id, tcx),\n             }\n@@ -850,27 +850,28 @@ fn convert_variant(\n     ty::VariantDef::new(\n         tcx,\n         ident,\n-        variant_did,\n-        ctor_did,\n+        variant_did.map(LocalDefId::to_def_id),\n+        ctor_did.map(LocalDefId::to_def_id),\n         discr,\n         fields,\n         CtorKind::from_hir(def),\n         adt_kind,\n-        parent_did,\n+        parent_did.to_def_id(),\n         recovered,\n     )\n }\n \n fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let def_id = def_id.expect_local();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let item = match tcx.hir().get(hir_id) {\n         Node::Item(item) => item,\n         _ => bug!(),\n     };\n \n-    let repr = ReprOptions::new(tcx, def_id);\n+    let repr = ReprOptions::new(tcx, def_id.to_def_id());\n     let (kind, variants) = match item.kind {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n@@ -884,7 +885,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n \n                     let discr = if let Some(ref e) = v.disr_expr {\n                         distance_from_explicit = 0;\n-                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id))\n+                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id).to_def_id())\n                     } else {\n                         ty::VariantDiscr::Relative(distance_from_explicit)\n                     };\n@@ -906,7 +907,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n             (AdtKind::Enum, variants)\n         }\n         ItemKind::Struct(ref def, _) => {\n-            let variant_did = None;\n+            let variant_did = None::<LocalDefId>;\n             let ctor_did = def.ctor_hir_id().map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n             let variants = std::iter::once(convert_variant(\n@@ -943,15 +944,15 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n         }\n         _ => bug!(),\n     };\n-    tcx.alloc_adt_def(def_id, kind, variants, repr)\n+    tcx.alloc_adt_def(def_id.to_def_id(), kind, variants, repr)\n }\n \n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id).unwrap();\n+    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id.expect_local());\n \n     let item = match tcx.hir().get(trait_hir_id) {\n         Node::Item(item) => item,\n@@ -1002,7 +1003,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(hir_id);\n \n     let (is_auto, unsafety) = match item.kind {\n@@ -1160,7 +1161,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n     let parent_def_id = match node {\n@@ -1170,7 +1171,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n         | Node::Ctor(..)\n         | Node::Field(_) => {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n-            Some(tcx.hir().local_def_id(parent_id))\n+            Some(tcx.hir().local_def_id(parent_id).to_def_id())\n         }\n         // FIXME(#43408) enable this always when we get lazy normalization.\n         Node::AnonConst(_) => {\n@@ -1181,7 +1182,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             // `feature(const_generics)` is enabled, so that const expressions\n             // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n             if tcx.features().const_generics {\n-                Some(parent_def_id)\n+                Some(parent_def_id.to_def_id())\n             } else {\n                 let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n                 match parent_node {\n@@ -1191,7 +1192,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                     Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n                         if constant.hir_id == hir_id =>\n                     {\n-                        Some(parent_def_id)\n+                        Some(parent_def_id.to_def_id())\n                     }\n \n                     _ => None,\n@@ -1214,7 +1215,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         if let Node::Item(hir::Item { kind: ItemKind::OpaqueTy(..), .. }) =\n                             tcx.hir().get(parent_id)\n                         {\n-                            Some(tcx.hir().local_def_id(parent_id))\n+                            Some(tcx.hir().local_def_id(parent_id).to_def_id())\n                         } else {\n                             None\n                         }\n@@ -1261,7 +1262,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: kw::SelfUpper,\n-                        def_id: tcx.hir().local_def_id(param_id),\n+                        def_id: tcx.hir().local_def_id(param_id).to_def_id(),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n@@ -1304,7 +1305,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     params.extend(early_lifetimes.enumerate().map(|(i, param)| ty::GenericParamDef {\n         name: param.name.ident().name,\n         index: own_start + i as u32,\n-        def_id: tcx.hir().local_def_id(param.hir_id),\n+        def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n         pure_wrt_drop: param.pure_wrt_drop,\n         kind: ty::GenericParamDefKind::Lifetime,\n     }));\n@@ -1350,7 +1351,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let param_def = ty::GenericParamDef {\n                 index: type_start + i as u32,\n                 name: param.name.ident().name,\n-                def_id: tcx.hir().local_def_id(param.hir_id),\n+                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind,\n             };\n@@ -1366,7 +1367,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let param_def = ty::GenericParamDef {\n                 index: type_start + i as u32,\n                 name: param.name.ident().name,\n-                def_id: tcx.hir().local_def_id(param.hir_id),\n+                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Const,\n             };\n@@ -1458,7 +1459,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n@@ -1556,7 +1557,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     match tcx.hir().expect_item(hir_id).kind {\n         hir::ItemKind::Impl { ref of_trait, .. } => of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n@@ -1567,7 +1568,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n }\n \n fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n     match &item.kind {\n@@ -1701,7 +1702,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;\n@@ -1845,7 +1846,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir().local_def_id(param.hir_id),\n+            def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n             index,\n             name: param.name.ident().name,\n         }));\n@@ -2064,12 +2065,13 @@ fn associated_item_predicates(\n         // the `Binder` around the the predicate.\n         //\n         // FIXME(generic_associated_types): Currently only lifetimes are handled.\n-        self_trait_ref.substs.extend_to(tcx, item_def_id, mk_bound_param)\n+        self_trait_ref.substs.extend_to(tcx, item_def_id.to_def_id(), mk_bound_param)\n     } else {\n         self_trait_ref.substs\n     };\n \n-    let assoc_ty = tcx.mk_projection(tcx.hir().local_def_id(trait_item.hir_id), bound_substs);\n+    let assoc_ty =\n+        tcx.mk_projection(tcx.hir().local_def_id(trait_item.hir_id).to_def_id(), bound_substs);\n \n     let bounds = AstConv::compute_bounds(\n         &ItemCtxt::new(tcx, def_id),\n@@ -2555,7 +2557,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if codegen_fn_attrs.flags.intersects(CodegenFnAttrFlags::NO_SANITIZE_ANY) {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().as_local_hir_id(id).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(id.expect_local());\n                 tcx.struct_span_lint_hir(\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,"}, {"sha": "5903adc94cb1bc99faf63e619cf3e9f336680b05", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -21,7 +21,7 @@ use super::{bad_placeholder_type, is_suggestable_infer_ty};\n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n@@ -63,7 +63,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n                 }\n \n-                find_opaque_ty_constraints(tcx, def_id)\n+                find_opaque_ty_constraints(tcx, def_id.expect_local())\n             }\n             ImplItemKind::TyAlias(ref ty) => {\n                 if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n@@ -96,7 +96,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     tcx.mk_adt(def, substs)\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n-                    find_opaque_ty_constraints(tcx, def_id)\n+                    find_opaque_ty_constraints(tcx, def_id.expect_local())\n                 }\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), origin, .. }) => {\n@@ -392,7 +392,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n }\n \n-fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n \n     debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n@@ -512,13 +512,13 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n             if let hir::ExprKind::Closure(..) = ex.kind {\n                 let def_id = self.tcx.hir().local_def_id(ex.hir_id);\n-                self.check(def_id);\n+                self.check(def_id.to_def_id());\n             }\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id).to_def_id();\n             // The opaque type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n@@ -527,7 +527,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id).to_def_id();\n             // The opaque type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n@@ -537,14 +537,14 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            self.check(def_id);\n+            self.check(def_id.to_def_id());\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None };\n+    let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n \n     debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n "}, {"sha": "2244a89f12963ad47bd826e4924ba923f5d850f3", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -519,7 +519,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             for &var_id in upvars.keys() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_id },\n-                    closure_expr_id: closure_def_id.expect_local(),\n+                    closure_expr_id: closure_def_id,\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let captured_place = return_if_err!(self.cat_captured_var("}, {"sha": "e13d9ea2b262647ff78d860866bf4544685e9051", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -14,7 +14,7 @@ use min_specialization::check_min_specialization;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n@@ -59,7 +59,7 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n     for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module));\n+        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module).to_def_id());\n     }\n }\n \n@@ -85,7 +85,7 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n             enforce_impl_params_are_constrained(self.tcx, impl_def_id, items);\n             enforce_impl_items_are_distinct(self.tcx, items);\n             if self.min_specialization {\n-                check_min_specialization(self.tcx, impl_def_id, item.span);\n+                check_min_specialization(self.tcx, impl_def_id.to_def_id(), item.span);\n             }\n         }\n     }\n@@ -97,7 +97,7 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n \n fn enforce_impl_params_are_constrained(\n     tcx: TyCtxt<'_>,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n     // Every lifetime used in an associated type must be constrained."}, {"sha": "c7ef07bde30cf9c8ad1ea68e0997d56f8856672a", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -69,7 +69,7 @@ use crate::constrained_generic_params as cgp;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::specialization_graph::Node;\n@@ -130,7 +130,14 @@ fn check_always_applicable(\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n \n-        check_predicates(infcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n+        check_predicates(\n+            infcx,\n+            impl1_def_id.expect_local(),\n+            impl1_substs,\n+            impl2_node,\n+            impl2_substs,\n+            span,\n+        );\n     }\n }\n \n@@ -287,7 +294,7 @@ fn check_static_lifetimes<'tcx>(\n ///   including the `Self`-type.\n fn check_predicates<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    impl1_def_id: DefId,\n+    impl1_def_id: LocalDefId,\n     impl1_substs: SubstsRef<'tcx>,\n     impl2_node: Node,\n     impl2_substs: SubstsRef<'tcx>,\n@@ -339,7 +346,7 @@ fn check_predicates<'tcx>(\n         if let Some(obligations) = wf::obligations(\n             infcx,\n             tcx.param_env(impl1_def_id),\n-            tcx.hir().as_local_hir_id(impl1_def_id).unwrap(),\n+            tcx.hir().as_local_hir_id(impl1_def_id),\n             ty,\n             span,\n         ) {"}, {"sha": "7ca81e5d6b6c6569dd8a12bb15d15d3e34192e2f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -91,7 +91,7 @@ mod variance;\n \n use rustc_errors::{struct_span_err, ErrorReported};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::Node;\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n@@ -152,8 +152,8 @@ fn require_same_types<'tcx>(\n     })\n }\n \n-fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n-    let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n+fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n+    let main_id = tcx.hir().as_local_hir_id(main_def_id);\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.kind {\n@@ -231,8 +231,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     }\n }\n \n-fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n-    let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n+fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n+    let start_id = tcx.hir().as_local_hir_id(start_def_id);\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.kind {\n@@ -303,8 +303,8 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n \n fn check_for_entry_fn(tcx: TyCtxt<'_>) {\n     match tcx.entry_fn(LOCAL_CRATE) {\n-        Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id),\n-        Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id),\n+        Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id.expect_local()),\n+        Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id.expect_local()),\n         _ => {}\n     }\n }\n@@ -378,7 +378,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let env_def_id = tcx.hir().local_def_id(env_node_id);\n-    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n \n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n@@ -393,7 +393,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let env_def_id = tcx.hir().local_def_id(env_hir_id);\n-    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n     let _ = AstConv::instantiate_poly_trait_ref_inner(\n         &item_cx,"}, {"sha": "15c72f8704f65edb8b37418485a0ebd8df24ef12", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -57,7 +57,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-        let hir_id = self.tcx.hir().as_local_hir_id(item_did).expect(\"expected local def-id\");\n+        let hir_id = self.tcx.hir().as_local_hir_id(item_did);\n         let item = match self.tcx.hir().get(hir_id) {\n             Node::Item(item) => item,\n             _ => bug!(),\n@@ -66,7 +66,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         let mut item_required_predicates = RequiredPredicates::default();\n         match item.kind {\n             hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(item_did);\n+                let adt_def = self.tcx.adt_def(item_did.to_def_id());\n \n                 // Iterate over all fields in item_did\n                 for field_def in adt_def.all_fields() {\n@@ -99,10 +99,10 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         // we walk the crates again and re-calculate predicates for all\n         // items.\n         let item_predicates_len: usize =\n-            self.global_inferred_outlives.get(&item_did).map(|p| p.len()).unwrap_or(0);\n+            self.global_inferred_outlives.get(&item_did.to_def_id()).map(|p| p.len()).unwrap_or(0);\n         if item_required_predicates.len() > item_predicates_len {\n             *self.predicates_added = true;\n-            self.global_inferred_outlives.insert(item_did, item_required_predicates);\n+            self.global_inferred_outlives.insert(item_did.to_def_id(), item_required_predicates);\n         }\n     }\n "}, {"sha": "15e0473bbf5967c1e95260590ef6990088c85033", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -18,7 +18,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate<'_>, Span)] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n+    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n \n     match tcx.hir().get(id) {\n         Node::Item(item) => match item.kind {"}, {"sha": "abe9319d71c591438c5faa42a46949d6ba107468", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -18,7 +18,7 @@ impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, sym::rustc_outlives) {\n+        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_outlives) {\n             let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0640, \"{:?}\", inferred_outlives_of).emit();\n         }"}, {"sha": "01d077d47f0393c636d8c2a53229083add7997df", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -3,7 +3,7 @@\n //! The second pass over the AST determines the set of constraints.\n //! We walk the set of items and, for each member, generate new constraints.\n \n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LocalDefId};\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n@@ -128,16 +128,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         self.terms_cx.tcx\n     }\n \n-    fn build_constraints_for_item(&mut self, def_id: DefId) {\n+    fn build_constraints_for_item(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx();\n-        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id));\n+        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id.to_def_id()));\n \n         // Skip items with no generics - there's nothing to infer in them.\n         if tcx.generics_of(def_id).count() == 0 {\n             return;\n         }\n \n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id);\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).kind {\n@@ -377,7 +377,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let (local, remote) = if let Some(id) = self.tcx().hir().as_local_hir_id(def_id) {\n+        let (local, remote) = if let Some(def_id) = def_id.as_local() {\n+            let id = self.tcx().hir().as_local_hir_id(def_id);\n             (Some(self.terms_cx.inferred_starts[&id]), None)\n         } else {\n             (None, Some(self.tcx().variances_of(def_id)))"}, {"sha": "2d78ac4b3c58fe10dd08c0267ccbb45f19c5f8c4", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -38,7 +38,7 @@ fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CrateVariancesMap<'\n }\n \n fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n+    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n     let unsupported = || {\n         // Variance not relevant.\n         span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")"}, {"sha": "7402117a7ebb1aca558d4f33e6aac1e5e6965f9d", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                     }\n                 }\n \n-                (def_id, &*variances)\n+                (def_id.to_def_id(), &*variances)\n             })\n             .collect()\n     }"}, {"sha": "fe585826d2205c164c5afd2aa94cea752476efb5", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -94,7 +94,7 @@ fn lang_items(tcx: TyCtxt<'_>) -> Vec<(hir::HirId, Vec<ty::Variance>)> {\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n         .filter(|&(ref d, _)| d.is_some())\n         .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-        .filter_map(|(d, v)| tcx.hir().as_local_hir_id(d).map(|n| (n, v))) // (HirId, Variance)\n+        .filter_map(|(d, v)| d.as_local().map(|d| tcx.hir().as_local_hir_id(d)).map(|n| (n, v))) // (HirId, Variance)\n         .collect()\n }\n "}, {"sha": "1aab89310c6e881ccc41eb096fb2051e7a63da8e", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -18,7 +18,7 @@ impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, sym::rustc_variance) {\n+        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_variance) {\n             let variances_of = self.tcx.variances_of(item_def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0208, \"{:?}\", variances_of).emit();\n         }"}, {"sha": "6208c1471018308fe87604642e0c88f215e51e18", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -340,7 +340,8 @@ pub fn build_impl(\n         }\n     }\n \n-    let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+    let for_ = if let Some(did) = did.as_local() {\n+        let hir_id = tcx.hir().as_local_hir_id(did);\n         match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n             _ => panic!(\"did given to build_impl was not an impl\"),\n@@ -360,7 +361,8 @@ pub fn build_impl(\n     }\n \n     let predicates = tcx.explicit_predicates_of(did);\n-    let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+    let (trait_items, generics) = if let Some(did) = did.as_local() {\n+        let hir_id = tcx.hir().as_local_hir_id(did);\n         match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl { ref generics, ref items, .. } => (\n                 items.iter().map(|item| tcx.hir().impl_item(item.id).clean(cx)).collect::<Vec<_>>(),\n@@ -486,7 +488,8 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n }\n \n pub fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n-    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n+    if let Some(did) = did.as_local() {\n+        let hir_id = cx.tcx.hir().as_local_hir_id(did);\n         rustc_hir_pretty::id_to_string(&cx.tcx.hir(), hir_id)\n     } else {\n         cx.tcx.rendered_const(did)\n@@ -498,11 +501,9 @@ fn build_const(cx: &DocContext<'_>, did: DefId) -> clean::Constant {\n         type_: cx.tcx.type_of(did).clean(cx),\n         expr: print_inlined_const(cx, did),\n         value: clean::utils::print_evaluated_const(cx, did),\n-        is_literal: cx\n-            .tcx\n-            .hir()\n-            .as_local_hir_id(did)\n-            .map_or(false, |hir_id| clean::utils::is_literal_expr(cx, hir_id)),\n+        is_literal: did.as_local().map_or(false, |did| {\n+            clean::utils::is_literal_expr(cx, cx.tcx.hir().as_local_hir_id(did))\n+        }),\n     }\n }\n "}, {"sha": "4d03bb21cb3ec6ceff12e7c1c0cbeff6ffa7168e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -137,15 +137,16 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .filter_map(|&id| {\n                     let item = cx.tcx.hir().expect_item(id.id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => {\n-                            as_primitive(Res::Def(DefKind::Mod, cx.tcx.hir().local_def_id(id.id)))\n-                        }\n+                        hir::ItemKind::Mod(_) => as_primitive(Res::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n+                        )),\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_primitive(path.res).map(|(_, prim, attrs)| {\n                                 // Pretend the primitive is local.\n-                                (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim, attrs)\n                             })\n                         }\n                         _ => None,\n@@ -191,14 +192,15 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .filter_map(|&id| {\n                     let item = cx.tcx.hir().expect_item(id.id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => {\n-                            as_keyword(Res::Def(DefKind::Mod, cx.tcx.hir().local_def_id(id.id)))\n-                        }\n+                        hir::ItemKind::Mod(_) => as_keyword(Res::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n+                        )),\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_keyword(path.res).map(|(_, prim, attrs)| {\n-                                (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim, attrs)\n                             })\n                         }\n                         _ => None,\n@@ -273,7 +275,7 @@ impl Clean<Item> for doctree::Module<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: ModuleItem(Module { is_crate: self.is_crate, items }),\n         }\n     }\n@@ -624,7 +626,7 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n             hir::GenericParamKind::Type { ref default, synthetic } => (\n                 self.name.ident().name.clean(cx),\n                 GenericParamDefKind::Type {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id),\n+                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),\n                     synthetic,\n@@ -633,7 +635,7 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n             hir::GenericParamKind::Const { ref ty } => (\n                 self.name.ident().name.clean(cx),\n                 GenericParamDefKind::Const {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id),\n+                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n                     ty: ty.clean(cx),\n                 },\n             ),\n@@ -894,7 +896,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n \n         let did = cx.tcx.hir().local_def_id(self.id);\n-        let constness = if is_min_const_fn(cx.tcx, did) {\n+        let constness = if is_min_const_fn(cx.tcx, did.to_def_id()) {\n             hir::Constness::Const\n         } else {\n             hir::Constness::NotConst\n@@ -907,7 +909,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: did,\n+            def_id: did.to_def_id(),\n             inner: FunctionItem(Function {\n                 decl,\n                 generics,\n@@ -974,12 +976,7 @@ where\n impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if cx.tcx.hir().as_local_hir_id(did).is_some() {\n-            &[]\n-        } else {\n-            cx.tcx.fn_arg_names(did)\n-        }\n-        .iter();\n+        let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n \n         FnDecl {\n             output: Return(sig.skip_binder().output().clean(cx)),\n@@ -1016,7 +1013,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1039,7 +1036,7 @@ impl Clean<Item> for doctree::TraitAlias<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1120,10 +1117,10 @@ impl Clean<Item> for hir::TraitItem<'_> {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: local_did,\n+            def_id: local_did.to_def_id(),\n             visibility: Visibility::Inherited,\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n+            stability: get_stability(cx, local_did.to_def_id()),\n+            deprecation: get_deprecation(cx, local_did.to_def_id()),\n             inner,\n         }\n     }\n@@ -1153,10 +1150,10 @@ impl Clean<Item> for hir::ImplItem<'_> {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: local_did,\n+            def_id: local_did.to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n+            stability: get_stability(cx, local_did.to_def_id()),\n+            deprecation: get_deprecation(cx, local_did.to_def_id()),\n             inner,\n         }\n     }\n@@ -1348,7 +1345,7 @@ impl Clean<Type> for hir::Ty<'_> {\n             TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n             TyKind::Array(ref ty, ref length) => {\n                 let def_id = cx.tcx.hir().local_def_id(length.hir_id);\n-                let length = match cx.tcx.const_eval_poly(def_id) {\n+                let length = match cx.tcx.const_eval_poly(def_id.to_def_id()) {\n                     Ok(length) => {\n                         print_const(cx, ty::Const::from_value(cx.tcx, length, cx.tcx.types.usize))\n                     }\n@@ -1382,8 +1379,9 @@ impl Clean<Type> for hir::Ty<'_> {\n                 let mut alias = None;\n                 if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n                     // Substitute private type aliases\n-                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n-                        if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n+                    if let Some(def_id) = def_id.as_local() {\n+                        let hir_id = cx.tcx.hir().as_local_hir_id(def_id);\n+                        if !cx.renderinfo.borrow().access_levels.is_exported(def_id.to_def_id()) {\n                             alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n                         }\n                     }\n@@ -1415,7 +1413,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                                     if let Some(lt) = lifetime.cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                            lt_substs.insert(lt_def_id, lt.clean(cx));\n+                                            lt_substs.insert(lt_def_id.to_def_id(), lt.clean(cx));\n                                         }\n                                     }\n                                     indices.lifetimes += 1;\n@@ -1435,9 +1433,10 @@ impl Clean<Type> for hir::Ty<'_> {\n                                             _ => None,\n                                         });\n                                     if let Some(ty) = type_ {\n-                                        ty_substs.insert(ty_param_def_id, ty.clean(cx));\n+                                        ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n                                     } else if let Some(default) = *default {\n-                                        ty_substs.insert(ty_param_def_id, default.clean(cx));\n+                                        ty_substs\n+                                            .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n                                     }\n                                     indices.types += 1;\n                                 }\n@@ -1457,7 +1456,8 @@ impl Clean<Type> for hir::Ty<'_> {\n                                             _ => None,\n                                         });\n                                     if let Some(ct) = const_ {\n-                                        ct_substs.insert(const_param_def_id, ct.clean(cx));\n+                                        ct_substs\n+                                            .insert(const_param_def_id.to_def_id(), ct.clean(cx));\n                                     }\n                                     // FIXME(const_generics:defaults)\n                                     indices.consts += 1;\n@@ -1749,9 +1749,9 @@ impl Clean<Item> for hir::StructField<'_> {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n-            def_id: local_did,\n+            stability: get_stability(cx, local_did.to_def_id()),\n+            deprecation: get_deprecation(cx, local_did.to_def_id()),\n+            def_id: local_did.to_def_id(),\n             inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n@@ -1799,7 +1799,7 @@ impl Clean<Item> for doctree::Struct<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1819,7 +1819,7 @@ impl Clean<Item> for doctree::Union<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1849,7 +1849,7 @@ impl Clean<Item> for doctree::Enum<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1871,7 +1871,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             visibility: Inherited,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: VariantItem(Variant { kind: self.def.clean(cx) }),\n         }\n     }\n@@ -2020,7 +2020,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2035,7 +2035,7 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2066,7 +2066,7 @@ impl Clean<Item> for doctree::Static<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2087,14 +2087,14 @@ impl Clean<Item> for doctree::Constant<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id,\n+            def_id: def_id.to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n                 expr: print_const_expr(cx, self.expr),\n-                value: print_evaluated_const(cx, def_id),\n+                value: print_evaluated_const(cx, def_id.to_def_id()),\n                 is_literal: is_literal_expr(cx, self.expr.hir_id),\n             }),\n         }\n@@ -2141,7 +2141,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id,\n+            def_id: def_id.to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2299,7 +2299,7 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2343,7 +2343,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             visibility: Public,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n         }\n     }"}, {"sha": "ec5ac48ffe4a848cf74e78eccc5ed3165cf1a9d6", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -473,7 +473,8 @@ pub fn name_from_pat(p: &hir::Pat) -> String {\n pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n         ty::ConstKind::Unevaluated(def_id, _, promoted) => {\n-            let mut s = if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n+            let mut s = if let Some(def_id) = def_id.as_local() {\n+                let hir_id = cx.tcx.hir().as_local_hir_id(def_id);\n                 print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n                 inline::print_inlined_const(cx, def_id)"}, {"sha": "91e60f81cec530b5b3f56919f9bf36f1e7641862", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> DocContext<'tcx> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n-            self.tcx.hir().as_local_hir_id(def_id)\n+            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n         }\n     }\n \n@@ -389,7 +389,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                     map: access_levels\n                         .map\n                         .iter()\n-                        .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n+                        .map(|(&k, &v)| (tcx.hir().local_def_id(k).to_def_id(), v))\n                         .collect(),\n                 };\n "}, {"sha": "4bb50f75791976f7afbb6b7ea0164ead66f9c492", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -646,8 +646,8 @@ impl<'a, 'b> ExtraInfo<'a, 'b> {\n         let hir_id = match (self.hir_id, self.item_did) {\n             (Some(h), _) => h,\n             (None, Some(item_did)) => {\n-                match self.tcx.hir().as_local_hir_id(item_did) {\n-                    Some(hir_id) => hir_id,\n+                match item_did.as_local() {\n+                    Some(item_did) => self.tcx.hir().as_local_hir_id(item_did),\n                     None => {\n                         // If non-local, no need to check anything.\n                         return;"}, {"sha": "43b641c7fe61a790f221671fc16848aff8486dfb", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -335,8 +335,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_hir_id = if item.is_mod() {\n-            if let Some(id) = self.cx.tcx.hir().as_local_hir_id(item.def_id) {\n-                Some(id)\n+            if let Some(def_id) = item.def_id.as_local() {\n+                Some(self.cx.tcx.hir().as_local_hir_id(def_id))\n             } else {\n                 debug!(\"attempting to fold on a non-local item: {:?}\", item);\n                 return self.fold_item_recur(item);"}, {"sha": "6ef01c3dec79f918f683a3d8b6d85e7b34e3a313", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -120,7 +120,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n-            inline::build_impl(cx, impl_did, None, &mut new_items);\n+            inline::build_impl(cx, impl_did.to_def_id(), None, &mut new_items);\n         }\n     }\n "}, {"sha": "2050c6c57bab08ef3635ed42ac7f7fa1b43df7a8", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59527516a917738c2e5f5d9f5e9a3533a6a5bc/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5a59527516a917738c2e5f5d9f5e9a3533a6a5bc", "patch": "@@ -331,8 +331,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n-        let res_hir_id = match tcx.hir().as_local_hir_id(res_did) {\n-            Some(n) => n,\n+        let res_hir_id = match res_did.as_local() {\n+            Some(n) => tcx.hir().as_local_hir_id(n),\n             None => return false,\n         };\n \n@@ -391,7 +391,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         if item.vis.node.is_pub() {\n             let def_id = self.cx.tcx.hir().local_def_id(item.hir_id);\n-            self.store_path(def_id);\n+            self.store_path(def_id.to_def_id());\n         }\n \n         match item.kind {\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         Macro {\n             hid: def.hir_id,\n-            def_id: self.cx.tcx.hir().local_def_id(def.hir_id),\n+            def_id: self.cx.tcx.hir().local_def_id(def.hir_id).to_def_id(),\n             attrs: &def.attrs,\n             name: renamed.unwrap_or(def.ident.name),\n             whence: def.span,"}]}