{"sha": "e15c48672850c0a0b7936df3dfa861bfa34db4bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNWM0ODY3Mjg1MGMwYTBiNzkzNmRmM2RmYTg2MWJmYTM0ZGI0YmQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-17T23:08:13Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-17T23:09:53Z"}, "message": "Remove infinite loop detector", "tree": {"sha": "f9414af6445cd32894dd48979709ac93c20f2bd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9414af6445cd32894dd48979709ac93c20f2bd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e15c48672850c0a0b7936df3dfa861bfa34db4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e15c48672850c0a0b7936df3dfa861bfa34db4bd", "html_url": "https://github.com/rust-lang/rust/commit/e15c48672850c0a0b7936df3dfa861bfa34db4bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e15c48672850c0a0b7936df3dfa861bfa34db4bd/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b66f27ed34849a849bd93ce662bffeec2e56947", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b66f27ed34849a849bd93ce662bffeec2e56947", "html_url": "https://github.com/rust-lang/rust/commit/5b66f27ed34849a849bd93ce662bffeec2e56947"}], "stats": {"total": 421, "additions": 0, "deletions": 421}, "files": [{"sha": "3063a99886b7bdb76a917614b5d339ac6b4bc472", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e15c48672850c0a0b7936df3dfa861bfa34db4bd/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15c48672850c0a0b7936df3dfa861bfa34db4bd/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=e15c48672850c0a0b7936df3dfa861bfa34db4bd", "patch": "@@ -9,7 +9,6 @@ mod memory;\n mod operand;\n mod operator;\n mod place;\n-pub(crate) mod snapshot; // for const_eval\n mod step;\n mod terminator;\n mod traits;"}, {"sha": "ee45179fd8b316bd53ad98280f33079d2ed3d063", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "removed", "additions": 0, "deletions": 420, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/5b66f27ed34849a849bd93ce662bffeec2e56947/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b66f27ed34849a849bd93ce662bffeec2e56947/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=5b66f27ed34849a849bd93ce662bffeec2e56947", "patch": "@@ -1,420 +0,0 @@\n-//! This module contains the machinery necessary to detect infinite loops\n-//! during const-evaluation by taking snapshots of the state of the interpreter\n-//! at regular intervals.\n-\n-// This lives in `interpret` because it needs access to all sots of private state.  However,\n-// it is not used by the general miri engine, just by CTFE.\n-\n-use std::hash::{Hash, Hasher};\n-\n-use rustc::ich::StableHashingContextProvider;\n-use rustc::mir;\n-use rustc::mir::interpret::{\n-    AllocId, Allocation, InterpResult, Pointer, Relocations, Scalar, UndefMask,\n-};\n-\n-use rustc::ty::layout::{Align, Size};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_ast::ast::Mutability;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_index::vec::IndexVec;\n-use rustc_macros::HashStable;\n-use rustc_span::source_map::Span;\n-\n-use super::eval_context::{LocalState, StackPopCleanup};\n-use super::{\n-    Frame, Immediate, LocalValue, MemPlace, MemPlaceMeta, Memory, Operand, Place, ScalarMaybeUndef,\n-};\n-use crate::const_eval::CompileTimeInterpreter;\n-\n-#[derive(Default)]\n-pub(crate) struct InfiniteLoopDetector<'mir, 'tcx> {\n-    /// The set of all `InterpSnapshot` *hashes* observed by this detector.\n-    ///\n-    /// When a collision occurs in this table, we store the full snapshot in\n-    /// `snapshots`.\n-    hashes: FxHashSet<u64>,\n-\n-    /// The set of all `InterpSnapshot`s observed by this detector.\n-    ///\n-    /// An `InterpSnapshot` will only be fully cloned once it has caused a\n-    /// collision in `hashes`. As a result, the detector must observe at least\n-    /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<InterpSnapshot<'mir, 'tcx>>,\n-}\n-\n-impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n-    pub fn observe_and_analyze(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>],\n-    ) -> InterpResult<'tcx, ()> {\n-        // Compute stack's hash before copying anything\n-        let mut hcx = tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-        stack.hash_stable(&mut hcx, &mut hasher);\n-        let hash = hasher.finish::<u64>();\n-\n-        // Check if we know that hash already\n-        if self.hashes.is_empty() {\n-            // FIXME(#49980): make this warning a lint\n-            tcx.sess.span_warn(\n-                span,\n-                \"Constant evaluating a complex constant, this might take some time\",\n-            );\n-        }\n-        if self.hashes.insert(hash) {\n-            // No collision\n-            return Ok(());\n-        }\n-\n-        // We need to make a full copy. NOW things that to get really expensive.\n-        info!(\"snapshotting the state of the interpreter\");\n-\n-        if self.snapshots.insert(InterpSnapshot::new(memory, stack)) {\n-            // Spurious collision or first cycle\n-            return Ok(());\n-        }\n-\n-        // Second cycle\n-        throw_exhaust!(InfiniteLoop)\n-    }\n-}\n-\n-trait SnapshotContext<'a> {\n-    fn resolve(&'a self, id: &AllocId) -> Option<&'a Allocation>;\n-}\n-\n-/// Taking a snapshot of the evaluation context produces a view of\n-/// the state of the interpreter that is invariant to `AllocId`s.\n-trait Snapshot<'a, Ctx: SnapshotContext<'a>> {\n-    type Item;\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item;\n-}\n-\n-macro_rules! __impl_snapshot_field {\n-    ($field:ident, $ctx:expr) => {\n-        $field.snapshot($ctx)\n-    };\n-    ($field:ident, $ctx:expr, $delegate:expr) => {\n-        $delegate\n-    };\n-}\n-\n-// This assumes the type has two type parameters, first for the tag (set to `()`),\n-// then for the id\n-macro_rules! impl_snapshot_for {\n-    (enum $enum_name:ident {\n-        $( $variant:ident $( ( $($field:ident $(-> $delegate:expr)?),* ) )? ),* $(,)?\n-    }) => {\n-\n-        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $enum_name\n-            where Ctx: self::SnapshotContext<'a>,\n-        {\n-            type Item = $enum_name<(), AllocIdSnapshot<'a>>;\n-\n-            #[inline]\n-            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n-                match *self {\n-                    $(\n-                        $enum_name::$variant $( ( $(ref $field),* ) )? => {\n-                            $enum_name::$variant $(\n-                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* )\n-                            )?\n-                        }\n-                    )*\n-                }\n-            }\n-        }\n-    };\n-\n-    (struct $struct_name:ident { $($field:ident $(-> $delegate:expr)?),*  $(,)? }) => {\n-        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $struct_name\n-            where Ctx: self::SnapshotContext<'a>,\n-        {\n-            type Item = $struct_name<(), AllocIdSnapshot<'a>>;\n-\n-            #[inline]\n-            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n-                let $struct_name {\n-                    $(ref $field),*\n-                } = *self;\n-\n-                $struct_name {\n-                    $( $field: __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),*\n-                }\n-            }\n-        }\n-    };\n-}\n-\n-impl<'a, Ctx, T> Snapshot<'a, Ctx> for Option<T>\n-where\n-    Ctx: SnapshotContext<'a>,\n-    T: Snapshot<'a, Ctx>,\n-{\n-    type Item = Option<<T as Snapshot<'a, Ctx>>::Item>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Some(x) => Some(x.snapshot(ctx)),\n-            None => None,\n-        }\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct AllocIdSnapshot<'a>(Option<AllocationSnapshot<'a>>);\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = AllocIdSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        AllocIdSnapshot(ctx.resolve(self).map(|alloc| alloc.snapshot(ctx)))\n-    }\n-}\n-\n-impl_snapshot_for!(struct Pointer {\n-    alloc_id,\n-    offset -> *offset, // just copy offset verbatim\n-    tag -> *tag, // just copy tag\n-});\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Scalar<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n-            Scalar::Raw { size, data } => Scalar::Raw { data: *data, size: *size },\n-        }\n-    }\n-}\n-\n-impl_snapshot_for!(\n-    enum ScalarMaybeUndef {\n-        Scalar(s),\n-        Undef,\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum MemPlaceMeta {\n-        Meta(s),\n-        None,\n-        Poison,\n-    }\n-);\n-\n-impl_snapshot_for!(struct MemPlace {\n-    ptr,\n-    meta,\n-    align -> *align, // just copy alignment verbatim\n-});\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Place<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Place::Ptr(p) => Place::Ptr(p.snapshot(ctx)),\n-\n-            Place::Local { frame, local } => Place::Local { frame: *frame, local: *local },\n-        }\n-    }\n-}\n-\n-impl_snapshot_for!(\n-    enum Immediate {\n-        Scalar(s),\n-        ScalarPair(s, t),\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum Operand {\n-        Immediate(v),\n-        Indirect(m),\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum LocalValue {\n-        Dead,\n-        Uninitialized,\n-        Live(v),\n-    }\n-);\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Relocations<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        Relocations::from_presorted(\n-            self.iter().map(|(size, ((), id))| (*size, ((), id.snapshot(ctx)))).collect(),\n-        )\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct AllocationSnapshot<'a> {\n-    bytes: &'a [u8],\n-    relocations: Relocations<(), AllocIdSnapshot<'a>>,\n-    undef_mask: &'a UndefMask,\n-    align: &'a Align,\n-    size: &'a Size,\n-    mutability: &'a Mutability,\n-}\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = AllocationSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Allocation { size, align, mutability, extra: (), .. } = self;\n-\n-        let all_bytes = 0..self.len();\n-        // This 'inspect' is okay since following access respects undef and relocations. This does\n-        // influence interpreter exeuction, but only to detect the error of cycles in evaluation\n-        // dependencies.\n-        let bytes = self.inspect_with_undef_and_ptr_outside_interpreter(all_bytes);\n-\n-        let undef_mask = self.undef_mask();\n-        let relocations = self.relocations();\n-\n-        AllocationSnapshot {\n-            bytes,\n-            undef_mask,\n-            align,\n-            size,\n-            mutability,\n-            relocations: relocations.snapshot(ctx),\n-        }\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct FrameSnapshot<'a, 'tcx> {\n-    instance: ty::Instance<'tcx>,\n-    span: Span,\n-    return_to_block: &'a StackPopCleanup,\n-    return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n-    locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n-    block: Option<mir::BasicBlock>,\n-    stmt: usize,\n-}\n-\n-impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = FrameSnapshot<'a, 'tcx>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Frame {\n-            body: _,\n-            instance,\n-            span,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-            extra: _,\n-        } = self;\n-\n-        FrameSnapshot {\n-            instance: *instance,\n-            span: *span,\n-            return_to_block,\n-            block: *block,\n-            stmt: *stmt,\n-            return_place: return_place.map(|r| r.snapshot(ctx)),\n-            locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = LocalValue<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let LocalState { value, layout: _ } = self;\n-        value.snapshot(ctx)\n-    }\n-}\n-\n-impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n-    for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n-{\n-    fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n-        self.get_raw(*id).ok()\n-    }\n-}\n-\n-/// The virtual machine state during const-evaluation at a given point in time.\n-/// We assume the `CompileTimeInterpreter` has no interesting extra state that\n-/// is worth considering here.\n-#[derive(HashStable)]\n-struct InterpSnapshot<'mir, 'tcx> {\n-    // Not hashing memory: Avoid hashing memory all the time during execution\n-    #[stable_hasher(ignore)]\n-    memory: Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-}\n-\n-impl InterpSnapshot<'mir, 'tcx> {\n-    fn new(\n-        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>],\n-    ) -> Self {\n-        InterpSnapshot { memory: memory.clone(), stack: stack.into() }\n-    }\n-\n-    // Used to compare two snapshots\n-    fn snapshot(&'b self) -> Vec<FrameSnapshot<'b, 'tcx>> {\n-        // Start with the stack, iterate and recursively snapshot\n-        self.stack.iter().map(|frame| frame.snapshot(&self.memory)).collect()\n-    }\n-}\n-\n-impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n-        let mut hcx = self.memory.tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-        self.hash_stable(&mut hcx, &mut hasher);\n-        hasher.finish::<u64>().hash(state)\n-    }\n-}\n-\n-impl<'mir, 'tcx> Eq for InterpSnapshot<'mir, 'tcx> {}\n-\n-impl<'mir, 'tcx> PartialEq for InterpSnapshot<'mir, 'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        // FIXME: This looks to be a *ridiculously expensive* comparison operation.\n-        // Doesn't this make tons of copies?  Either `snapshot` is very badly named,\n-        // or it does!\n-        self.snapshot() == other.snapshot()\n-    }\n-}"}]}