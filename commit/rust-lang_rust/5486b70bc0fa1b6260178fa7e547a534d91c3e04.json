{"sha": "5486b70bc0fa1b6260178fa7e547a534d91c3e04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ODZiNzBiYzBmYTFiNjI2MDE3OGZhN2U1NDdhNTM0ZDkxYzNlMDQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-09-18T14:43:50Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-09-18T14:43:50Z"}, "message": "Use hir_def to resolve proc macros", "tree": {"sha": "ac4a36773afb0e7f33e9e6abdecd07c0216557f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac4a36773afb0e7f33e9e6abdecd07c0216557f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5486b70bc0fa1b6260178fa7e547a534d91c3e04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5486b70bc0fa1b6260178fa7e547a534d91c3e04", "html_url": "https://github.com/rust-lang/rust/commit/5486b70bc0fa1b6260178fa7e547a534d91c3e04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5486b70bc0fa1b6260178fa7e547a534d91c3e04/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfa3a3f017c39f745f06d96de11359b97c76fc47", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa3a3f017c39f745f06d96de11359b97c76fc47", "html_url": "https://github.com/rust-lang/rust/commit/dfa3a3f017c39f745f06d96de11359b97c76fc47"}], "stats": {"total": 95, "additions": 79, "deletions": 16}, "files": [{"sha": "a841b97bfe45a67302935fea3ee9e6144087207b", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5486b70bc0fa1b6260178fa7e547a534d91c3e04/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5486b70bc0fa1b6260178fa7e547a534d91c3e04/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=5486b70bc0fa1b6260178fa7e547a534d91c3e04", "patch": "@@ -171,13 +171,19 @@ pub struct AttrQuery<'a> {\n }\n \n impl<'a> AttrQuery<'a> {\n+    /// For an attribute like `#[attr(value)]`, returns the `(value)` subtree.\n+    ///\n+    /// If the attribute does not have a token tree argument, returns `None`.\n     pub fn tt_values(self) -> impl Iterator<Item = &'a Subtree> {\n         self.attrs().filter_map(|attr| match attr.input.as_ref()? {\n             AttrInput::TokenTree(it) => Some(it),\n             _ => None,\n         })\n     }\n \n+    /// For an attribute like `#[key = \"value\"]`, returns `\"value\"`.\n+    ///\n+    /// Returns `None` if the attribute does not have `key = \"value\"` form.\n     pub fn string_value(self) -> Option<&'a SmolStr> {\n         self.attrs().find_map(|attr| match attr.input.as_ref()? {\n             AttrInput::Literal(it) => Some(it),"}, {"sha": "42c0f0536932d90ec3447a9d415a09110fe7171e", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5486b70bc0fa1b6260178fa7e547a534d91c3e04/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5486b70bc0fa1b6260178fa7e547a534d91c3e04/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=5486b70bc0fa1b6260178fa7e547a534d91c3e04", "patch": "@@ -16,10 +16,10 @@ use hir_expand::{\n     proc_macro::ProcMacroExpander,\n     HirFileId, MacroCallId, MacroDefId, MacroDefKind,\n };\n-use rustc_hash::FxHashMap;\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n use test_utils::mark;\n+use tt::{Leaf, TokenTree};\n \n use crate::{\n     attr::Attrs,\n@@ -281,6 +281,25 @@ impl DefCollector<'_> {\n         }\n     }\n \n+    fn resolve_proc_macro(&mut self, name: &Name) {\n+        let macro_def = match self.proc_macros.iter().find(|(n, _)| n == name) {\n+            Some((_, expander)) => MacroDefId {\n+                ast_id: None,\n+                krate: Some(self.def_map.krate),\n+                kind: MacroDefKind::ProcMacro(*expander),\n+                local_inner: false,\n+            },\n+            None => MacroDefId {\n+                ast_id: None,\n+                krate: Some(self.def_map.krate),\n+                kind: MacroDefKind::ProcMacro(ProcMacroExpander::dummy(self.def_map.krate)),\n+                local_inner: false,\n+            },\n+        };\n+\n+        self.define_proc_macro(name.clone(), macro_def);\n+    }\n+\n     /// Define a macro with `macro_rules`.\n     ///\n     /// It will define the macro in legacy textual scope, and if it has `#[macro_export]`,\n@@ -917,6 +936,9 @@ impl ModCollector<'_, '_> {\n                 }\n                 ModItem::Function(id) => {\n                     let func = &self.item_tree[id];\n+\n+                    self.collect_proc_macro_def(&func.name, attrs);\n+\n                     def = Some(DefData {\n                         id: FunctionLoc {\n                             container: container.into(),\n@@ -1177,6 +1199,30 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n+    /// If `attrs` registers a procedural macro, collects its definition.\n+    fn collect_proc_macro_def(&mut self, func_name: &Name, attrs: &Attrs) {\n+        // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n+        // FIXME: distinguish the type of macro\n+        let macro_name = if attrs.by_key(\"proc_macro\").exists()\n+            || attrs.by_key(\"proc_macro_attribute\").exists()\n+        {\n+            func_name.clone()\n+        } else {\n+            let derive = attrs.by_key(\"proc_macro_derive\");\n+            if let Some(arg) = derive.tt_values().next() {\n+                if let [TokenTree::Leaf(Leaf::Ident(trait_name))] = &*arg.token_trees {\n+                    trait_name.as_name()\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        };\n+\n+        self.def_collector.resolve_proc_macro(&macro_name);\n+    }\n+\n     fn collect_macro(&mut self, mac: &MacroCall) {\n         let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, mac.path.clone());\n "}, {"sha": "7505cb061bf9e62ee4385fcc4ee50db1ca876501", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5486b70bc0fa1b6260178fa7e547a534d91c3e04/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5486b70bc0fa1b6260178fa7e547a534d91c3e04/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=5486b70bc0fa1b6260178fa7e547a534d91c3e04", "patch": "@@ -7,7 +7,7 @@ use tt::buffer::{Cursor, TokenBuffer};\n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n     krate: CrateId,\n-    proc_macro_id: ProcMacroId,\n+    proc_macro_id: Option<ProcMacroId>,\n }\n \n macro_rules! err {\n@@ -20,8 +20,14 @@ macro_rules! err {\n }\n \n impl ProcMacroExpander {\n-    pub fn new(krate: CrateId, proc_macro_id: ProcMacroId) -> ProcMacroExpander {\n-        ProcMacroExpander { krate, proc_macro_id }\n+    pub fn new(krate: CrateId, proc_macro_id: ProcMacroId) -> Self {\n+        Self { krate, proc_macro_id: Some(proc_macro_id) }\n+    }\n+\n+    pub fn dummy(krate: CrateId) -> Self {\n+        // FIXME: Should store the name for better errors\n+        // FIXME: I think this is the second layer of \"dummy\" expansion, we should reduce that\n+        Self { krate, proc_macro_id: None }\n     }\n \n     pub fn expand(\n@@ -30,17 +36,22 @@ impl ProcMacroExpander {\n         _id: LazyMacroId,\n         tt: &tt::Subtree,\n     ) -> Result<tt::Subtree, mbe::ExpandError> {\n-        let krate_graph = db.crate_graph();\n-        let proc_macro = krate_graph[self.krate]\n-            .proc_macro\n-            .get(self.proc_macro_id.0 as usize)\n-            .clone()\n-            .ok_or_else(|| err!(\"No derive macro found.\"))?;\n-\n-        let tt = remove_derive_attrs(tt)\n-            .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n-\n-        proc_macro.expander.expand(&tt, None).map_err(mbe::ExpandError::from)\n+        match self.proc_macro_id {\n+            Some(id) => {\n+                let krate_graph = db.crate_graph();\n+                let proc_macro = krate_graph[self.krate]\n+                    .proc_macro\n+                    .get(id.0 as usize)\n+                    .clone()\n+                    .ok_or_else(|| err!(\"No derive macro found.\"))?;\n+\n+                let tt = remove_derive_attrs(tt)\n+                    .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n+\n+                proc_macro.expander.expand(&tt, None).map_err(mbe::ExpandError::from)\n+            }\n+            None => Err(err!(\"Unresolved proc macro\")),\n+        }\n     }\n }\n "}]}