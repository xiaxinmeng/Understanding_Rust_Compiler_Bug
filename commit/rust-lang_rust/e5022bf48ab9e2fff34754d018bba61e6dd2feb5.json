{"sha": "e5022bf48ab9e2fff34754d018bba61e6dd2feb5", "node_id": "C_kwDOAAsO6NoAKGU1MDIyYmY0OGFiOWUyZmZmMzQ3NTRkMDE4YmJhNjFlNmRkMmZlYjU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-25T19:17:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-25T19:46:47Z"}, "message": "join all the threads", "tree": {"sha": "cbb059a1bea41cf38b4eb598f56199bc2915af0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbb059a1bea41cf38b4eb598f56199bc2915af0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5022bf48ab9e2fff34754d018bba61e6dd2feb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5022bf48ab9e2fff34754d018bba61e6dd2feb5", "html_url": "https://github.com/rust-lang/rust/commit/e5022bf48ab9e2fff34754d018bba61e6dd2feb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5022bf48ab9e2fff34754d018bba61e6dd2feb5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9124420b2fd64ded303d5e8d8ad41df813d83985", "url": "https://api.github.com/repos/rust-lang/rust/commits/9124420b2fd64ded303d5e8d8ad41df813d83985", "html_url": "https://github.com/rust-lang/rust/commit/9124420b2fd64ded303d5e8d8ad41df813d83985"}], "stats": {"total": 100, "additions": 51, "deletions": 49}, "files": [{"sha": "396c1a97e07e8db80c9a8f36bce33900c15f3a2d", "filename": "tests/pass/concurrency/sync.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e5022bf48ab9e2fff34754d018bba61e6dd2feb5/tests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5022bf48ab9e2fff34754d018bba61e6dd2feb5/tests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync.rs?ref=e5022bf48ab9e2fff34754d018bba61e6dd2feb5", "patch": "@@ -35,7 +35,7 @@ fn check_conditional_variables_notify_one() {\n     let pair2 = pair.clone();\n \n     // Spawn a new thread.\n-    thread::spawn(move || {\n+    let t = thread::spawn(move || {\n         thread::yield_now();\n         let (lock, cvar) = &*pair2;\n         let mut started = lock.lock().unwrap();\n@@ -50,6 +50,8 @@ fn check_conditional_variables_notify_one() {\n     while !*started {\n         started = cvar.wait(started).unwrap();\n     }\n+\n+    t.join().unwrap();\n }\n \n /// Test that waiting on a conditional variable with a timeout does not\n@@ -191,51 +193,6 @@ fn check_once() {\n     }\n }\n \n-fn check_rwlock_unlock_bug1() {\n-    // There was a bug where when un-read-locking an rwlock that still has other\n-    // readers waiting, we'd accidentally also let a writer in.\n-    // That caused an ICE.\n-    let l = Arc::new(RwLock::new(0));\n-\n-    let r1 = l.read().unwrap();\n-    let r2 = l.read().unwrap();\n-\n-    // Make a waiting writer.\n-    let l2 = l.clone();\n-    thread::spawn(move || {\n-        let mut w = l2.write().unwrap();\n-        *w += 1;\n-    });\n-    thread::yield_now();\n-\n-    drop(r1);\n-    assert_eq!(*r2, 0);\n-    thread::yield_now();\n-    thread::yield_now();\n-    thread::yield_now();\n-    assert_eq!(*r2, 0);\n-    drop(r2);\n-}\n-\n-fn check_rwlock_unlock_bug2() {\n-    // There was a bug where when un-read-locking an rwlock by letting the last reader leaver,\n-    // we'd forget to wake up a writer.\n-    // That meant the writer thread could never run again.\n-    let l = Arc::new(RwLock::new(0));\n-\n-    let r = l.read().unwrap();\n-\n-    // Make a waiting writer.\n-    let l2 = l.clone();\n-    let h = thread::spawn(move || {\n-        let _w = l2.write().unwrap();\n-    });\n-    thread::yield_now();\n-\n-    drop(r);\n-    h.join().unwrap();\n-}\n-\n fn park_timeout() {\n     let start = Instant::now();\n \n@@ -277,8 +234,6 @@ fn main() {\n     check_rwlock_write();\n     check_rwlock_read_no_deadlock();\n     check_once();\n-    check_rwlock_unlock_bug1();\n-    check_rwlock_unlock_bug2();\n     park_timeout();\n     park_unpark();\n     check_condvar();"}, {"sha": "391f65ae5a9cb0013267d14b06b9c768e821a174", "filename": "tests/pass/concurrency/sync_nopreempt.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e5022bf48ab9e2fff34754d018bba61e6dd2feb5/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5022bf48ab9e2fff34754d018bba61e6dd2feb5/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=e5022bf48ab9e2fff34754d018bba61e6dd2feb5", "patch": "@@ -2,7 +2,7 @@\n // We are making scheduler assumptions here.\n // compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n \n-use std::sync::{Arc, Condvar, Mutex};\n+use std::sync::{Arc, Condvar, Mutex, RwLock};\n use std::thread;\n \n fn check_conditional_variables_notify_all() {\n@@ -35,6 +35,53 @@ fn check_conditional_variables_notify_all() {\n     }\n }\n \n+fn check_rwlock_unlock_bug1() {\n+    // There was a bug where when un-read-locking an rwlock that still has other\n+    // readers waiting, we'd accidentally also let a writer in.\n+    // That caused an ICE.\n+    let l = Arc::new(RwLock::new(0));\n+\n+    let r1 = l.read().unwrap();\n+    let r2 = l.read().unwrap();\n+\n+    // Make a waiting writer.\n+    let l2 = l.clone();\n+    thread::spawn(move || {\n+        let mut w = l2.write().unwrap();\n+        *w += 1;\n+    });\n+    thread::yield_now();\n+\n+    drop(r1);\n+    assert_eq!(*r2, 0);\n+    thread::yield_now();\n+    thread::yield_now();\n+    thread::yield_now();\n+    assert_eq!(*r2, 0);\n+    drop(r2);\n+}\n+\n+fn check_rwlock_unlock_bug2() {\n+    // There was a bug where when un-read-locking an rwlock by letting the last reader leaver,\n+    // we'd forget to wake up a writer.\n+    // That meant the writer thread could never run again.\n+    let l = Arc::new(RwLock::new(0));\n+\n+    let r = l.read().unwrap();\n+\n+    // Make a waiting writer.\n+    let l2 = l.clone();\n+    let h = thread::spawn(move || {\n+        let _w = l2.write().unwrap();\n+    });\n+    thread::yield_now();\n+\n+    drop(r);\n+    h.join().unwrap();\n+}\n+\n fn main() {\n     check_conditional_variables_notify_all();\n+    check_rwlock_unlock_bug1();\n+    check_rwlock_unlock_bug2();\n }"}]}