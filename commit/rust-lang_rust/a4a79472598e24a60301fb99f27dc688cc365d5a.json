{"sha": "a4a79472598e24a60301fb99f27dc688cc365d5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YTc5NDcyNTk4ZTI0YTYwMzAxZmI5OWYyN2RjNjg4Y2MzNjVkNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-01T10:10:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-01T10:10:46Z"}, "message": "Auto merge of #49724 - kennytm:range-inc-start-end-methods, r=Kimundi\n\nIntroduce RangeInclusive::{new, start, end} methods and make the fields private.\n\ncc #49022", "tree": {"sha": "fe68f488a9b19bccc2845870fe40286543c6aaa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe68f488a9b19bccc2845870fe40286543c6aaa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4a79472598e24a60301fb99f27dc688cc365d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a79472598e24a60301fb99f27dc688cc365d5a", "html_url": "https://github.com/rust-lang/rust/commit/a4a79472598e24a60301fb99f27dc688cc365d5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4a79472598e24a60301fb99f27dc688cc365d5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eb68b797b2d2d2ae20093b824f69fe817c96ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb68b797b2d2d2ae20093b824f69fe817c96ed1", "html_url": "https://github.com/rust-lang/rust/commit/0eb68b797b2d2d2ae20093b824f69fe817c96ed1"}, {"sha": "f70b2ebd08f47c504681ca5f62c3ccdacdd69763", "url": "https://api.github.com/repos/rust-lang/rust/commits/f70b2ebd08f47c504681ca5f62c3ccdacdd69763", "html_url": "https://github.com/rust-lang/rust/commit/f70b2ebd08f47c504681ca5f62c3ccdacdd69763"}], "stats": {"total": 193, "additions": 139, "deletions": 54}, "files": [{"sha": "da4b76a4d527d41ee755812ffae464e780e2e4c4", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -122,7 +122,7 @@\n #![feature(on_unimplemented)]\n #![feature(exact_chunks)]\n #![feature(pointer_methods)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![cfg_attr(stage0, feature(generic_param_attrs))]\n #![feature(rustc_const_unstable)]\n "}, {"sha": "1c8ff316e55aab6fdaf4aae5ff8872ad835c9f5d", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -25,7 +25,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(exact_chunks)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n \n extern crate alloc_system;\n extern crate core;"}, {"sha": "04dd42583d406eb468e646e10bfd56dbcf81be8a", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -102,6 +102,7 @@\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(doc_alias)]\n+#![feature(inclusive_range_methods)]\n \n #![cfg_attr(not(stage0), feature(mmx_target_feature))]\n #![cfg_attr(not(stage0), feature(tbm_target_feature))]"}, {"sha": "b01a769eda7fd4201e7239003425d93cbb26e937", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -318,9 +318,9 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(inclusive_range_fields)]\n+/// #![feature(inclusive_range_methods)]\n ///\n-/// assert_eq!((3..=5), std::ops::RangeInclusive { start: 3, end: 5 });\n+/// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());\n ///\n /// let arr = [0, 1, 2, 3];\n@@ -331,14 +331,88 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n+    // FIXME: The current representation follows RFC 1980,\n+    // but it is known that LLVM is not able to optimize loops following that RFC.\n+    // Consider adding an extra `bool` field to indicate emptiness of the range.\n+    // See #45222 for performance test cases.\n+    #[cfg(not(stage0))]\n+    pub(crate) start: Idx,\n+    #[cfg(not(stage0))]\n+    pub(crate) end: Idx,\n     /// The lower bound of the range (inclusive).\n+    #[cfg(stage0)]\n     #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub start: Idx,\n     /// The upper bound of the range (inclusive).\n+    #[cfg(stage0)]\n     #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub end: Idx,\n }\n \n+impl<Idx> RangeInclusive<Idx> {\n+    /// Creates a new inclusive range. Equivalent to writing `start..=end`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inclusive_range_methods)]\n+    /// use std::ops::RangeInclusive;\n+    ///\n+    /// assert_eq!(3..=5, RangeInclusive::new(3, 5));\n+    /// ```\n+    #[unstable(feature = \"inclusive_range_methods\", issue = \"49022\")]\n+    #[inline]\n+    pub const fn new(start: Idx, end: Idx) -> Self {\n+        Self { start, end }\n+    }\n+\n+    /// Returns the lower bound of the range (inclusive).\n+    ///\n+    /// When using an inclusive range for iteration, the values of `start()` and\n+    /// [`end()`] are unspecified after the iteration ended. To determine\n+    /// whether the inclusive range is empty, use the [`is_empty()`] method\n+    /// instead of comparing `start() > end()`.\n+    ///\n+    /// [`end()`]: #method.end\n+    /// [`is_empty()`]: #method.is_empty\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inclusive_range_methods)]\n+    ///\n+    /// assert_eq!((3..=5).start(), &3);\n+    /// ```\n+    #[unstable(feature = \"inclusive_range_methods\", issue = \"49022\")]\n+    #[inline]\n+    pub fn start(&self) -> &Idx {\n+        &self.start\n+    }\n+\n+    /// Returns the upper bound of the range (inclusive).\n+    ///\n+    /// When using an inclusive range for iteration, the values of [`start()`]\n+    /// and `end()` are unspecified after the iteration ended. To determine\n+    /// whether the inclusive range is empty, use the [`is_empty()`] method\n+    /// instead of comparing `start() > end()`.\n+    ///\n+    /// [`start()`]: #method.start\n+    /// [`is_empty()`]: #method.is_empty\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inclusive_range_methods)]\n+    ///\n+    /// assert_eq!((3..=5).end(), &5);\n+    /// ```\n+    #[unstable(feature = \"inclusive_range_methods\", issue = \"49022\")]\n+    #[inline]\n+    pub fn end(&self) -> &Idx {\n+        &self.end\n+    }\n+}\n+\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "f6750c590b33ab97303f7f5b3231bbd7caa334df", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -44,7 +44,7 @@\n #![feature(exact_chunks)]\n #![cfg_attr(stage0, feature(atomic_nand))]\n #![feature(reverse_bits)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![feature(iterator_find_map)]\n \n extern crate core;"}, {"sha": "d66193b1687c86c921687f589862cbbf2cd94815", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -50,21 +50,21 @@ fn test_full_range() {\n \n #[test]\n fn test_range_inclusive() {\n-    let mut r = RangeInclusive { start: 1i8, end: 2 };\n+    let mut r = RangeInclusive::new(1i8, 2);\n     assert_eq!(r.next(), Some(1));\n     assert_eq!(r.next(), Some(2));\n     assert_eq!(r.next(), None);\n \n-    r = RangeInclusive { start: 127i8, end: 127 };\n+    r = RangeInclusive::new(127i8, 127);\n     assert_eq!(r.next(), Some(127));\n     assert_eq!(r.next(), None);\n \n-    r = RangeInclusive { start: -128i8, end: -128 };\n+    r = RangeInclusive::new(-128i8, -128);\n     assert_eq!(r.next_back(), Some(-128));\n     assert_eq!(r.next_back(), None);\n \n     // degenerate\n-    r = RangeInclusive { start: 1, end: -1 };\n+    r = RangeInclusive::new(1, -1);\n     assert_eq!(r.size_hint(), (0, Some(0)));\n     assert_eq!(r.next(), None);\n }"}, {"sha": "196f7879980e8446d24b090e3b91eaaccc4d5b8c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -3119,6 +3119,20 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n+            // Desugar `<start>..=<end>` to `std::ops::RangeInclusive::new(<start>, <end>)`\n+            ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                // FIXME: Use head_sp directly after RangeInclusive::new() is stabilized in stage0.\n+                let span = self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n+                let id = self.lower_node_id(e.id);\n+                let e1 = self.lower_expr(e1);\n+                let e2 = self.lower_expr(e2);\n+                let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], false));\n+                let ty = self.ty_path(id, span, hir::QPath::Resolved(None, ty_path));\n+                let new_seg = P(hir::PathSegment::from_name(Symbol::intern(\"new\")));\n+                let new_path = hir::QPath::TypeRelative(ty, new_seg);\n+                let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n+                hir::ExprCall(new, hir_vec![e1, e2])\n+            }\n             ExprKind::Range(ref e1, ref e2, lims) => {\n                 use syntax::ast::RangeLimits::*;\n \n@@ -3128,7 +3142,7 @@ impl<'a> LoweringContext<'a> {\n                     (&None, &Some(..), HalfOpen) => \"RangeTo\",\n                     (&Some(..), &Some(..), HalfOpen) => \"Range\",\n                     (&None, &Some(..), Closed) => \"RangeToInclusive\",\n-                    (&Some(..), &Some(..), Closed) => \"RangeInclusive\",\n+                    (&Some(..), &Some(..), Closed) => unreachable!(),\n                     (_, &None, Closed) => self.diagnostic()\n                         .span_fatal(e.span, \"inclusive range with no end\")\n                         .raise(),"}, {"sha": "9dc9fb1144efa07a8ab3db23f0b66de2eca5c0d6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -69,7 +69,7 @@\n #![feature(trusted_len)]\n #![feature(catch_expr)]\n #![feature(test)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "47b52cacd56bd846e55f8ae7760b5e777082cc69", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -19,7 +19,6 @@ use std::cmp;\n use std::fmt;\n use std::i128;\n use std::mem;\n-use std::ops::RangeInclusive;\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -492,7 +491,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::TyFloat(FloatTy::F64) => scalar(F64),\n             ty::TyFnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n-                ptr.valid_range.start = 1;\n+                ptr.valid_range = 1..=*ptr.valid_range.end();\n                 tcx.intern_layout(LayoutDetails::scalar(self, ptr))\n             }\n \n@@ -506,7 +505,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n-                    data_ptr.valid_range.start = 1;\n+                    data_ptr.valid_range = 1..=*data_ptr.valid_range.end();\n                 }\n \n                 let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n@@ -524,7 +523,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n                     ty::TyDynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n-                        vtable.valid_range.start = 1;\n+                        vtable.valid_range = 1..=*vtable.valid_range.end();\n                         vtable\n                     }\n                     _ => return Err(LayoutError::Unknown(unsized_part))\n@@ -751,8 +750,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         match st.abi {\n                             Abi::Scalar(ref mut scalar) |\n                             Abi::ScalarPair(ref mut scalar, _) => {\n-                                if scalar.valid_range.start == 0 {\n-                                    scalar.valid_range.start = 1;\n+                                if *scalar.valid_range.start() == 0 {\n+                                    scalar.valid_range = 1..=*scalar.valid_range.end();\n                                 }\n                             }\n                             _ => {}\n@@ -788,18 +787,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 }\n                             }\n                         }\n-                        if niche_variants.start > v {\n-                            niche_variants.start = v;\n-                        }\n-                        niche_variants.end = v;\n+                        niche_variants = *niche_variants.start().min(&v)..=v;\n                     }\n \n-                    if niche_variants.start > niche_variants.end {\n+                    if niche_variants.start() > niche_variants.end() {\n                         dataful_variant = None;\n                     }\n \n                     if let Some(i) = dataful_variant {\n-                        let count = (niche_variants.end - niche_variants.start + 1) as u128;\n+                        let count = (niche_variants.end() - niche_variants.start() + 1) as u128;\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n                             let (offset, niche, niche_start) =\n                                 match self.find_niche(field, count)? {\n@@ -1659,22 +1655,22 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let max_value = !0u128 >> (128 - bits);\n \n             // Find out how many values are outside the valid range.\n-            let niches = if v.start <= v.end {\n-                v.start + (max_value - v.end)\n+            let niches = if v.start() <= v.end() {\n+                v.start() + (max_value - v.end())\n             } else {\n-                v.start - v.end - 1\n+                v.start() - v.end() - 1\n             };\n \n             // Give up if we can't fit `count` consecutive niches.\n             if count > niches {\n                 return None;\n             }\n \n-            let niche_start = v.end.wrapping_add(1) & max_value;\n-            let niche_end = v.end.wrapping_add(count) & max_value;\n+            let niche_start = v.end().wrapping_add(1) & max_value;\n+            let niche_end = v.end().wrapping_add(count) & max_value;\n             Some((offset, Scalar {\n                 value,\n-                valid_range: v.start..=niche_end\n+                valid_range: *v.start()..=niche_end\n             }, niche_start))\n         };\n \n@@ -1744,14 +1740,14 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n             }\n             NicheFilling {\n                 dataful_variant,\n-                niche_variants: RangeInclusive { start, end },\n+                ref niche_variants,\n                 ref niche,\n                 niche_start,\n                 ref variants,\n             } => {\n                 dataful_variant.hash_stable(hcx, hasher);\n-                start.hash_stable(hcx, hasher);\n-                end.hash_stable(hcx, hasher);\n+                niche_variants.start().hash_stable(hcx, hasher);\n+                niche_variants.end().hash_stable(hcx, hasher);\n                 niche.hash_stable(hcx, hasher);\n                 niche_start.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n@@ -1814,10 +1810,10 @@ impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        let Scalar { value, valid_range: RangeInclusive { start, end } } = *self;\n+        let Scalar { value, ref valid_range } = *self;\n         value.hash_stable(hcx, hasher);\n-        start.hash_stable(hcx, hasher);\n-        end.hash_stable(hcx, hasher);\n+        valid_range.start().hash_stable(hcx, hasher);\n+        valid_range.end().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "c8cebf8328d59a7a2afbfe429e11814676c8406d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -917,8 +917,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 niche_start,\n                 ..\n             } => {\n-                let variants_start = niche_variants.start as u128;\n-                let variants_end = niche_variants.end as u128;\n+                let variants_start = *niche_variants.start() as u128;\n+                let variants_end = *niche_variants.end() as u128;\n                 match raw_discr {\n                     PrimVal::Ptr(_) => {\n                         assert!(niche_start == 0);\n@@ -984,7 +984,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 if variant_index != dataful_variant {\n                     let (niche_dest, niche) =\n                         self.place_field(dest, mir::Field::new(0), layout)?;\n-                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n                     self.write_primval(niche_dest, PrimVal::Bytes(niche_value), niche.ty)?;\n                 }"}, {"sha": "a6dc4c74f36345064226c83407ddcc4fc3fc561f", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -31,7 +31,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(nonzero)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n #![cfg_attr(stage0, feature(try_trait))]"}, {"sha": "f73085196f4e6f3119a8b6a04705c3261bc6e801", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -555,8 +555,8 @@ impl Scalar {\n         let bits = self.value.size(cx).bits();\n         assert!(bits <= 128);\n         let mask = !0u128 >> (128 - bits);\n-        let start = self.valid_range.start;\n-        let end = self.valid_range.end;\n+        let start = *self.valid_range.start();\n+        let end = *self.valid_range.end();\n         assert_eq!(start, start & mask);\n         assert_eq!(end, end & mask);\n         start..(end.wrapping_add(1) & mask)"}, {"sha": "45f2ee13bbdc94e29f5e5922564f24314351d1ff", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -29,7 +29,7 @@\n #![feature(const_fn)]\n #![feature(fs_read_write)]\n #![feature(inclusive_range)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![feature(slice_patterns)]\n \n #[macro_use]"}, {"sha": "1838dae049ad7e1a18cb205ed7ce6648900e4ae0", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -388,8 +388,8 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 return;\n             }\n \n-            if scalar.valid_range.start < scalar.valid_range.end {\n-                if scalar.valid_range.start > 0 {\n+            if scalar.valid_range.start() < scalar.valid_range.end() {\n+                if *scalar.valid_range.start() > 0 {\n                     attrs.set(ArgAttribute::NonNull);\n                 }\n             }"}, {"sha": "2fc6c9d4433016f74613225759412724916744cd", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -1236,7 +1236,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                    self.layout,\n                                    self.layout.fields.offset(0),\n                                    self.layout.field(cx, 0).size);\n-                name.push_str(&adt.variants[niche_variants.start].name.as_str());\n+                name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec!["}, {"sha": "9259fef279f1a6290c370ce984af0409cb5b42d9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -29,7 +29,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(optin_builtin_traits)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;"}, {"sha": "79859aee64d874dfddbbb6333e6521d65bf6eaf7", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                         bx.range_metadata(load, range);\n                     }\n                 }\n-                layout::Pointer if vr.start < vr.end && !vr.contains(&0) => {\n+                layout::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 ..\n             } => {\n                 let niche_llty = discr.layout.immediate_llvm_type(bx.cx);\n-                if niche_variants.start == niche_variants.end {\n+                if niche_variants.start() == niche_variants.end() {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n                         // HACK(eddyb) Using `C_null` as it works on all types.\n@@ -296,13 +296,13 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                         C_uint_big(niche_llty, niche_start)\n                     };\n                     bx.select(bx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n-                        C_uint(cast_to, niche_variants.start as u64),\n+                        C_uint(cast_to, *niche_variants.start() as u64),\n                         C_uint(cast_to, dataful_variant as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n-                    let delta = niche_start.wrapping_sub(niche_variants.start as u128);\n+                    let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n                     let lldiscr = bx.sub(lldiscr, C_uint_big(niche_llty, delta));\n-                    let lldiscr_max = C_uint(niche_llty, niche_variants.end as u64);\n+                    let lldiscr_max = C_uint(niche_llty, *niche_variants.end() as u64);\n                     bx.select(bx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n                         bx.intcast(lldiscr, cast_to, false),\n                         C_uint(cast_to, dataful_variant as u64))\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n                     let niche = self.project_field(bx, 0);\n                     let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n-                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    let niche_value = ((variant_index - *niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {"}, {"sha": "4fa54dc276d20e127fac876b00fd5407667c6df0", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -301,15 +301,15 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                             if let layout::Int(_, s) = scalar.value {\n                                 signed = s;\n \n-                                if scalar.valid_range.end > scalar.valid_range.start {\n+                                if scalar.valid_range.end() > scalar.valid_range.start() {\n                                     // We want `table[e as usize]` to not\n                                     // have bound checks, and this is the most\n                                     // convenient place to put the `assume`.\n \n                                     base::call_assume(&bx, bx.icmp(\n                                         llvm::IntULE,\n                                         llval,\n-                                        C_uint_big(ll_t_in, scalar.valid_range.end)\n+                                        C_uint_big(ll_t_in, *scalar.valid_range.end())\n                                     ));\n                                 }\n                             }"}]}