{"sha": "2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "node_id": "C_kwDOAAsO6NoAKDJkM2E4NWI0ZjhiYTdlMjU1NGY0ZDRmZWUxMjZiYzJhYzZlZTJhZjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-07T17:37:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-07T17:37:39Z"}, "message": "Auto merge of #102787 - Dylan-DPC:rollup-fvbb4t9, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #102300 (Use a macro to not have to copy-paste `ConstFnMutClosure::new(&mut fold, NeverShortCircuit::wrap_mut_2_imp)).0` everywhere)\n - #102475 (unsafe keyword: trait examples and unsafe_op_in_unsafe_fn update)\n - #102760 (Avoid repeated re-initialization of the BufReader buffer)\n - #102764 (Check `WhereClauseReferencesSelf` after all other object safety checks)\n - #102779 (Fix `type_of` ICE)\n - #102780 (run Miri CI when std::sys changes)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f40bafbf266a8500e96c2b232e8dfba5c98c0af8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f40bafbf266a8500e96c2b232e8dfba5c98c0af8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "html_url": "https://github.com/rust-lang/rust/commit/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43c22af267fd9337bc05382b2771dde49d2e9f26", "url": "https://api.github.com/repos/rust-lang/rust/commits/43c22af267fd9337bc05382b2771dde49d2e9f26", "html_url": "https://github.com/rust-lang/rust/commit/43c22af267fd9337bc05382b2771dde49d2e9f26"}, {"sha": "3800d40dc8ca3d4bb9967cbee27d2c2bb7c12be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3800d40dc8ca3d4bb9967cbee27d2c2bb7c12be6", "html_url": "https://github.com/rust-lang/rust/commit/3800d40dc8ca3d4bb9967cbee27d2c2bb7c12be6"}], "stats": {"total": 483, "additions": 319, "deletions": 164}, "files": [{"sha": "5972f6b88008eb6f4a418bffde89f5d25559a146", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -493,8 +493,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         },\n                         def_id.to_def_id(),\n                     );\n-                    if let Some(assoc_item) = assoc_item {\n-                        tcx.type_of(tcx.generics_of(assoc_item.def_id).params[idx].def_id)\n+                    if let Some(param)\n+                        = assoc_item.map(|item| &tcx.generics_of(item.def_id).params[idx]).filter(|param| param.kind.is_ty_or_const())\n+                    {\n+                        tcx.type_of(param.def_id)\n                     } else {\n                         // FIXME(associated_const_equality): add a useful error message here.\n                         tcx.ty_error_with_message("}, {"sha": "52ee5e6ea9361f28dce22ea5db1034cafa4dcc8f", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -447,19 +447,6 @@ fn virtual_call_violation_for_method<'tcx>(\n         return Some(MethodViolationCode::Generic);\n     }\n \n-    if tcx\n-        .predicates_of(method.def_id)\n-        .predicates\n-        .iter()\n-        // A trait object can't claim to live more than the concrete type,\n-        // so outlives predicates will always hold.\n-        .cloned()\n-        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n-    {\n-        return Some(MethodViolationCode::WhereClauseReferencesSelf);\n-    }\n-\n     let receiver_ty = tcx.liberate_late_bound_regions(method.def_id, sig.input(0));\n \n     // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n@@ -538,6 +525,21 @@ fn virtual_call_violation_for_method<'tcx>(\n         }\n     }\n \n+    // NOTE: This check happens last, because it results in a lint, and not a\n+    // hard error.\n+    if tcx\n+        .predicates_of(method.def_id)\n+        .predicates\n+        .iter()\n+        // A trait object can't claim to live more than the concrete type,\n+        // so outlives predicates will always hold.\n+        .cloned()\n+        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n+        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n+    {\n+        return Some(MethodViolationCode::WhereClauseReferencesSelf);\n+    }\n+\n     None\n }\n "}, {"sha": "d4fb886101fe78aff33812627e5c10748edeb4b3", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -1,7 +1,6 @@\n use crate::array;\n-use crate::const_closure::ConstFnMutClosure;\n use crate::iter::{ByRefSized, FusedIterator, Iterator};\n-use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n+use crate::ops::{ControlFlow, Try};\n \n /// An iterator over `N` elements of the iterator at a time.\n ///\n@@ -83,13 +82,7 @@ where\n         }\n     }\n \n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> B,\n-    {\n-        self.try_fold(init, ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp)).0\n-    }\n+    impl_fold_via_try_fold! { fold -> try_fold }\n }\n \n #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n@@ -127,13 +120,7 @@ where\n         try { acc }\n     }\n \n-    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> B,\n-    {\n-        self.try_rfold(init, ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp)).0\n-    }\n+    impl_fold_via_try_fold! { rfold -> try_rfold }\n }\n \n impl<I, const N: usize> ArrayChunks<I, N>"}, {"sha": "fbdeca4d4ee4f7e689e8f7fdfb0a8b57e75ebb83", "filename": "library/core/src/iter/adapters/map_while.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -64,19 +64,7 @@ where\n         .into_try()\n     }\n \n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n+    impl_fold_via_try_fold! { fold -> try_fold }\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]"}, {"sha": "8cc2b7cec41650f273669b836593f809cbe4a899", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -1,6 +1,5 @@\n-use crate::const_closure::ConstFnMutClosure;\n use crate::iter::{InPlaceIterable, Iterator};\n-use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, NeverShortCircuit, Residual, Try};\n+use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n mod array_chunks;\n mod by_ref_sized;\n@@ -204,13 +203,7 @@ where\n             .into_try()\n     }\n \n-    fn fold<B, F>(mut self, init: B, mut fold: F) -> B\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> B,\n-    {\n-        self.try_fold(init, ConstFnMutClosure::new(&mut fold, NeverShortCircuit::wrap_mut_2_imp)).0\n-    }\n+    impl_fold_via_try_fold! { fold -> try_fold }\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]"}, {"sha": "62470512cc747f9ee3ea975584de5a21944ae8fb", "filename": "library/core/src/iter/adapters/scan.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -74,19 +74,7 @@ where\n         self.iter.try_fold(init, scan(state, f, fold)).into_try()\n     }\n \n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n+    impl_fold_via_try_fold! { fold -> try_fold }\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]"}, {"sha": "c6334880db57cdbc346f42c0b2e3f779f6fef1e3", "filename": "library/core/src/iter/adapters/skip.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -206,17 +206,7 @@ where\n         if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n     }\n \n-    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_rfold(init, ok(fold)).unwrap()\n-    }\n+    impl_fold_via_try_fold! { rfold -> try_rfold }\n \n     #[inline]\n     fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {"}, {"sha": "58a0b9d7bbe99cd9c6965a61ef5e1509147cef07", "filename": "library/core/src/iter/adapters/take.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -98,19 +98,7 @@ where\n         }\n     }\n \n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n+    impl_fold_via_try_fold! { fold -> try_fold }\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]"}, {"sha": "ec66dc3aec3602cc814c0345df547d5f8c8854c5", "filename": "library/core/src/iter/adapters/take_while.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -94,19 +94,7 @@ where\n         }\n     }\n \n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n+    impl_fold_via_try_fold! { fold -> try_fold }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "ef0f397825b15ebb0c96d17fea966d2201321aae", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -352,6 +352,29 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+// This needs to be up here in order to be usable in the child modules\n+macro_rules! impl_fold_via_try_fold {\n+    (fold -> try_fold) => {\n+        impl_fold_via_try_fold! { @internal fold -> try_fold }\n+    };\n+    (rfold -> try_rfold) => {\n+        impl_fold_via_try_fold! { @internal rfold -> try_rfold }\n+    };\n+    (@internal $fold:ident -> $try_fold:ident) => {\n+        #[inline]\n+        fn $fold<AAA, FFF>(mut self, init: AAA, mut fold: FFF) -> AAA\n+        where\n+            FFF: FnMut(AAA, Self::Item) -> AAA,\n+        {\n+            use crate::const_closure::ConstFnMutClosure;\n+            use crate::ops::NeverShortCircuit;\n+\n+            let fold = ConstFnMutClosure::new(&mut fold, NeverShortCircuit::wrap_mut_2_imp);\n+            self.$try_fold(init, fold).0\n+        }\n+    };\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::Iterator;\n "}, {"sha": "ac7b389b15b4d5e9e00e99ef2a4740a7c51b2971", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -1150,19 +1150,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         self.spec_try_fold(init, f)\n     }\n \n-    #[inline]\n-    fn fold<B, F>(mut self, init: B, f: F) -> B\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> B,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(f)).unwrap()\n-    }\n+    impl_fold_via_try_fold! { fold -> try_fold }\n \n     #[inline]\n     fn last(mut self) -> Option<A> {\n@@ -1230,19 +1218,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         self.spec_try_rfold(init, f)\n     }\n \n-    #[inline]\n-    fn rfold<B, F>(mut self, init: B, f: F) -> B\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> B,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_rfold(init, ok(f)).unwrap()\n-    }\n+    impl_fold_via_try_fold! { rfold -> try_rfold }\n }\n \n // Safety: See above implementation for `ops::Range<A>`"}, {"sha": "4f339a18a480ec8ef42187b347b9dc0ce2bfbd1e", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -224,6 +224,14 @@ impl<R> BufReader<R> {\n     }\n }\n \n+// This is only used by a test which asserts that the initialization-tracking is correct.\n+#[cfg(test)]\n+impl<R> BufReader<R> {\n+    pub fn initialized(&self) -> usize {\n+        self.buf.initialized()\n+    }\n+}\n+\n impl<R: Seek> BufReader<R> {\n     /// Seeks relative to the current position. If the new position lies within the buffer,\n     /// the buffer will not be flushed, allowing for more efficient seeks."}, {"sha": "e9e29d60ca2826a915937688e8fe02488b861a4e", "filename": "library/std/src/io/buffered/bufreader/buffer.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -20,13 +20,19 @@ pub struct Buffer {\n     // Each call to `fill_buf` sets `filled` to indicate how many bytes at the start of `buf` are\n     // initialized with bytes from a read.\n     filled: usize,\n+    // This is the max number of bytes returned across all `fill_buf` calls. We track this so that we\n+    // can accurately tell `read_buf` how many bytes of buf are initialized, to bypass as much of its\n+    // defensive initialization as possible. Note that while this often the same as `filled`, it\n+    // doesn't need to be. Calls to `fill_buf` are not required to actually fill the buffer, and\n+    // omitting this is a huge perf regression for `Read` impls that do not.\n+    initialized: usize,\n }\n \n impl Buffer {\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         let buf = Box::new_uninit_slice(capacity);\n-        Self { buf, pos: 0, filled: 0 }\n+        Self { buf, pos: 0, filled: 0, initialized: 0 }\n     }\n \n     #[inline]\n@@ -51,6 +57,12 @@ impl Buffer {\n         self.pos\n     }\n \n+    // This is only used by a test which asserts that the initialization-tracking is correct.\n+    #[cfg(test)]\n+    pub fn initialized(&self) -> usize {\n+        self.initialized\n+    }\n+\n     #[inline]\n     pub fn discard_buffer(&mut self) {\n         self.pos = 0;\n@@ -96,13 +108,14 @@ impl Buffer {\n             let mut buf = BorrowedBuf::from(&mut *self.buf);\n             // SAFETY: `self.filled` bytes will always have been initialized.\n             unsafe {\n-                buf.set_init(self.filled);\n+                buf.set_init(self.initialized);\n             }\n \n             reader.read_buf(buf.unfilled())?;\n \n-            self.filled = buf.len();\n             self.pos = 0;\n+            self.filled = buf.len();\n+            self.initialized = buf.init_len();\n         }\n         Ok(self.buffer())\n     }"}, {"sha": "f4e688eb926cc7bff8962f1f79ecca455d7c27bc", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -1039,3 +1039,27 @@ fn single_formatted_write() {\n     writeln!(&mut writer, \"{}, {}!\", \"hello\", \"world\").unwrap();\n     assert_eq!(writer.get_ref().events, [RecordedEvent::Write(\"hello, world!\\n\".to_string())]);\n }\n+\n+#[test]\n+fn bufreader_full_initialize() {\n+    struct OneByteReader;\n+    impl Read for OneByteReader {\n+        fn read(&mut self, buf: &mut [u8]) -> crate::io::Result<usize> {\n+            if buf.len() > 0 {\n+                buf[0] = 0;\n+                Ok(1)\n+            } else {\n+                Ok(0)\n+            }\n+        }\n+    }\n+    let mut reader = BufReader::new(OneByteReader);\n+    // Nothing is initialized yet.\n+    assert_eq!(reader.initialized(), 0);\n+\n+    let buf = reader.fill_buf().unwrap();\n+    // We read one byte...\n+    assert_eq!(buf.len(), 1);\n+    // But we initialized the whole buffer!\n+    assert_eq!(reader.initialized(), reader.capacity());\n+}"}, {"sha": "e35145c4ade48dc6538aca96c46deb126edaea48", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 120, "deletions": 31, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -1867,11 +1867,15 @@ mod type_keyword {}\n /// Code or interfaces whose [memory safety] cannot be verified by the type\n /// system.\n ///\n-/// The `unsafe` keyword has two uses: to declare the existence of contracts the\n-/// compiler can't check (`unsafe fn` and `unsafe trait`), and to declare that a\n-/// programmer has checked that these contracts have been upheld (`unsafe {}`\n-/// and `unsafe impl`, but also `unsafe fn` -- see below). They are not mutually\n-/// exclusive, as can be seen in `unsafe fn`.\n+/// The `unsafe` keyword has two uses:\n+/// - to declare the existence of contracts the compiler can't check (`unsafe fn` and `unsafe\n+/// trait`),\n+/// - and to declare that a programmer has checked that these contracts have been upheld (`unsafe\n+/// {}` and `unsafe impl`, but also `unsafe fn` -- see below).\n+///\n+/// They are not mutually exclusive, as can be seen in `unsafe fn`: the body of an `unsafe fn` is,\n+/// by default, treated like an unsafe block. The `unsafe_op_in_unsafe_fn` lint can be enabled to\n+/// change that.\n ///\n /// # Unsafe abilities\n ///\n@@ -1914,12 +1918,12 @@ mod type_keyword {}\n /// - `unsafe impl`: the contract necessary to implement the trait has been\n /// checked by the programmer and is guaranteed to be respected.\n ///\n-/// `unsafe fn` also acts like an `unsafe {}` block\n+/// By default, `unsafe fn` also acts like an `unsafe {}` block\n /// around the code inside the function. This means it is not just a signal to\n /// the caller, but also promises that the preconditions for the operations\n-/// inside the function are upheld. Mixing these two meanings can be confusing\n-/// and [proposal]s exist to use `unsafe {}` blocks inside such functions when\n-/// making `unsafe` operations.\n+/// inside the function are upheld. Mixing these two meanings can be confusing, so the\n+/// `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe\n+/// blocks even inside `unsafe fn`.\n ///\n /// See the [Rustnomicon] and the [Reference] for more information.\n ///\n@@ -1987,13 +1991,16 @@ mod type_keyword {}\n ///\n /// ```rust\n /// # #![allow(dead_code)]\n+/// #![deny(unsafe_op_in_unsafe_fn)]\n+///\n /// /// Dereference the given pointer.\n /// ///\n /// /// # Safety\n /// ///\n /// /// `ptr` must be aligned and must not be dangling.\n /// unsafe fn deref_unchecked(ptr: *const i32) -> i32 {\n-///     *ptr\n+///     // SAFETY: the caller is required to ensure that `ptr` is aligned and dereferenceable.\n+///     unsafe { *ptr }\n /// }\n ///\n /// let a = 3;\n@@ -2003,35 +2010,118 @@ mod type_keyword {}\n /// unsafe { assert_eq!(*b, deref_unchecked(b)); };\n /// ```\n ///\n-/// Traits marked as `unsafe` must be [`impl`]emented using `unsafe impl`. This\n-/// makes a guarantee to other `unsafe` code that the implementation satisfies\n-/// the trait's safety contract. The [Send] and [Sync] traits are examples of\n-/// this behaviour in the standard library.\n+/// ## `unsafe` and traits\n+///\n+/// The interactions of `unsafe` and traits can be surprising, so let us contrast the\n+/// two combinations of safe `fn` in `unsafe trait` and `unsafe fn` in safe trait using two\n+/// examples:\n+///\n+/// ```rust\n+/// /// # Safety\n+/// ///\n+/// /// `make_even` must return an even number.\n+/// unsafe trait MakeEven {\n+///     fn make_even(&self) -> i32;\n+/// }\n+///\n+/// // SAFETY: Our `make_even` always returns something even.\n+/// unsafe impl MakeEven for i32 {\n+///     fn make_even(&self) -> i32 {\n+///         self << 1\n+///     }\n+/// }\n+///\n+/// fn use_make_even(x: impl MakeEven) {\n+///     if x.make_even() % 2 == 1 {\n+///         // SAFETY: this can never happen, because all `MakeEven` implementations\n+///         // ensure that `make_even` returns something even.\n+///         unsafe { std::hint::unreachable_unchecked() };\n+///     }\n+/// }\n+/// ```\n+///\n+/// Note how the safety contract of the trait is upheld by the implementation, and is itself used to\n+/// uphold the safety contract of the unsafe function `unreachable_unchecked` called by\n+/// `use_make_even`. `make_even` itself is a safe function because its *callers* do not have to\n+/// worry about any contract, only the *implementation* of `MakeEven` is required to uphold a\n+/// certain contract. `use_make_even` is safe because it can use the promise made by `MakeEven`\n+/// implementations to uphold the safety contract of the `unsafe fn unreachable_unchecked` it calls.\n+///\n+/// It is also possible to have `unsafe fn` in a regular safe `trait`:\n ///\n /// ```rust\n-/// /// Implementors of this trait must guarantee an element is always\n-/// /// accessible with index 3.\n-/// unsafe trait ThreeIndexable<T> {\n-///     /// Returns a reference to the element with index 3 in `&self`.\n-///     fn three(&self) -> &T;\n+/// # #![feature(never_type)]\n+/// #![deny(unsafe_op_in_unsafe_fn)]\n+///\n+/// trait Indexable {\n+///     const LEN: usize;\n+///\n+///     /// # Safety\n+///     ///\n+///     /// The caller must ensure that `idx < LEN`.\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32;\n /// }\n ///\n-/// // The implementation of `ThreeIndexable` for `[T; 4]` is `unsafe`\n-/// // because the implementor must abide by a contract the compiler cannot\n-/// // check but as a programmer we know there will always be a valid element\n-/// // at index 3 to access.\n-/// unsafe impl<T> ThreeIndexable<T> for [T; 4] {\n-///     fn three(&self) -> &T {\n-///         // SAFETY: implementing the trait means there always is an element\n-///         // with index 3 accessible.\n-///         unsafe { self.get_unchecked(3) }\n+/// // The implementation for `i32` doesn't need to do any contract reasoning.\n+/// impl Indexable for i32 {\n+///     const LEN: usize = 1;\n+///\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         debug_assert_eq!(idx, 0);\n+///         *self\n ///     }\n /// }\n ///\n-/// let a = [1, 2, 4, 8];\n-/// assert_eq!(a.three(), &8);\n+/// // The implementation for arrays exploits the function contract to\n+/// // make use of `get_unchecked` on slices and avoid a run-time check.\n+/// impl Indexable for [i32; 42] {\n+///     const LEN: usize = 42;\n+///\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         // SAFETY: As per this trait's documentation, the caller ensures\n+///         // that `idx < 42`.\n+///         unsafe { *self.get_unchecked(idx) }\n+///     }\n+/// }\n+///\n+/// // The implementation for the never type declares a length of 0,\n+/// // which means `idx_unchecked` can never be called.\n+/// impl Indexable for ! {\n+///     const LEN: usize = 0;\n+///\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         // SAFETY: As per this trait's documentation, the caller ensures\n+///         // that `idx < 0`, which is impossible, so this is dead code.\n+///         unsafe { std::hint::unreachable_unchecked() }\n+///     }\n+/// }\n+///\n+/// fn use_indexable<I: Indexable>(x: I, idx: usize) -> i32 {\n+///     if idx < I::LEN {\n+///         // SAFETY: We have checked that `idx < I::LEN`.\n+///         unsafe { x.idx_unchecked(idx) }\n+///     } else {\n+///         panic!(\"index out-of-bounds\")\n+///     }\n+/// }\n /// ```\n ///\n+/// This time, `use_indexable` is safe because it uses a run-time check to discharge the safety\n+/// contract of `idx_unchecked`. Implementing `Indexable` is safe because when writing\n+/// `idx_unchecked`, we don't have to worry: our *callers* need to discharge a proof obligation\n+/// (like `use_indexable` does), but the *implementation* of `get_unchecked` has no proof obligation\n+/// to contend with. Of course, the implementation of `Indexable` may choose to call other unsafe\n+/// operations, and then it needs an `unsafe` *block* to indicate it discharged the proof\n+/// obligations of its callees. (We enabled `unsafe_op_in_unsafe_fn`, so the body of `idx_unchecked`\n+/// is not implicitly an unsafe block.) For that purpose it can make use of the contract that all\n+/// its callers must uphold -- the fact that `idx < LEN`.\n+///\n+/// Formally speaking, an `unsafe fn` in a trait is a function with *preconditions* that go beyond\n+/// those encoded by the argument types (such as `idx < LEN`), whereas an `unsafe trait` can declare\n+/// that some of its functions have *postconditions* that go beyond those encoded in the return type\n+/// (such as returning an even integer). If a trait needs a function with both extra precondition\n+/// and extra postcondition, then it needs an `unsafe fn` in an `unsafe trait`.\n+///\n /// [`extern`]: keyword.extern.html\n /// [`trait`]: keyword.trait.html\n /// [`static`]: keyword.static.html\n@@ -2043,7 +2133,6 @@ mod type_keyword {}\n /// [nomicon-soundness]: ../nomicon/safe-unsafe-meaning.html\n /// [soundness]: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\n /// [Reference]: ../reference/unsafety.html\n-/// [proposal]: https://github.com/rust-lang/rfcs/pull/2585\n /// [discussion on Rust Internals]: https://internals.rust-lang.org/t/what-does-unsafe-mean/6696\n mod unsafe_keyword {}\n "}, {"sha": "60c2960b160ecd96990c5ff93b78e6600b41d15e", "filename": "src/ci/scripts/should-skip-this.sh", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fshould-skip-this.sh?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -19,9 +19,12 @@ if [[ -n \"${CI_ONLY_WHEN_SUBMODULES_CHANGED-}\" ]]; then\n         # those files are present in the diff a submodule was updated.\n         echo \"Submodules were updated\"\n     elif ! (git diff --quiet \"$BASE_COMMIT\" -- \\\n-             src/tools/clippy src/tools/rustfmt src/tools/miri); then\n+             src/tools/clippy src/tools/rustfmt src/tools/miri\n+             library/std/src/sys); then\n         # There is not an easy blanket search for subtrees. For now, manually list\n         # the subtrees.\n+        # Also run this when the platform-specific parts of std change, in case\n+        # that breaks Miri.\n         echo \"Tool subtrees were updated\"\n     elif ! (git diff --quiet \"$BASE_COMMIT\" -- \\\n              src/test/rustdoc-gui \\"}, {"sha": "7aea0d30d1a76059cdd2feed64cf60a34067253d", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-102768.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-102768.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-102768.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-102768.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -0,0 +1,14 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait X {\n+    type Y<'a>;\n+}\n+\n+const _: () = {\n+    fn f2<'a>(arg: Box<dyn X<Y<1> = &'a ()>>) {}\n+    //~^ ERROR this associated type takes 1 lifetime argument but 0 lifetime arguments\n+    //~| ERROR this associated type takes 0 generic arguments but 1 generic argument\n+};\n+\n+fn main() {}"}, {"sha": "9deb9b26588f88b466c50d7d5f7744dc1ab4f8e0", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-102768.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-102768.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-102768.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-102768.stderr?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -0,0 +1,33 @@\n+error[E0107]: this associated type takes 1 lifetime argument but 0 lifetime arguments were supplied\n+  --> $DIR/issue-102768.rs:9:30\n+   |\n+LL |     fn f2<'a>(arg: Box<dyn X<Y<1> = &'a ()>>) {}\n+   |                              ^ expected 1 lifetime argument\n+   |\n+note: associated type defined here, with 1 lifetime parameter: `'a`\n+  --> $DIR/issue-102768.rs:5:10\n+   |\n+LL |     type Y<'a>;\n+   |          ^ --\n+help: add missing lifetime argument\n+   |\n+LL |     fn f2<'a>(arg: Box<dyn X<Y<'a, 1> = &'a ()>>) {}\n+   |                                +++\n+\n+error[E0107]: this associated type takes 0 generic arguments but 1 generic argument was supplied\n+  --> $DIR/issue-102768.rs:9:30\n+   |\n+LL |     fn f2<'a>(arg: Box<dyn X<Y<1> = &'a ()>>) {}\n+   |                              ^--- help: remove these generics\n+   |                              |\n+   |                              expected 0 generic arguments\n+   |\n+note: associated type defined here, with 0 generic parameters\n+  --> $DIR/issue-102768.rs:5:10\n+   |\n+LL |     type Y<'a>;\n+   |          ^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "4f4c3634528a14835828fd685083cb83c15d0b95", "filename": "src/test/ui/object-safety/issue-102762.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fobject-safety%2Fissue-102762.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fobject-safety%2Fissue-102762.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fissue-102762.rs?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -0,0 +1,26 @@\n+// compile-flags: --crate-type=lib\n+// This test checks that the `where_clauses_object_safety` lint does not cause\n+// other object safety *hard errors* to be suppressed, because we currently\n+// only emit one object safety error per trait...\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+pub trait Fetcher: Send + Sync {\n+    fn get<'a>(self: &'a Box<Self>) -> Pin<Box<dyn Future<Output = Vec<u8>> + 'a>>\n+    where\n+        Self: Sync,\n+    {\n+        todo!()\n+    }\n+}\n+\n+fn fetcher() -> Box<dyn Fetcher> {\n+    //~^ ERROR the trait `Fetcher` cannot be made into an object\n+    todo!()\n+}\n+\n+pub fn foo() {\n+    let fetcher = fetcher();\n+    let _ = fetcher.get();\n+}"}, {"sha": "5041ebe77605158a9389319437bb1f9487df4186", "filename": "src/test/ui/object-safety/issue-102762.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fobject-safety%2Fissue-102762.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4/src%2Ftest%2Fui%2Fobject-safety%2Fissue-102762.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fissue-102762.stderr?ref=2d3a85b4f8ba7e2554f4d4fee126bc2ac6ee2af4", "patch": "@@ -0,0 +1,20 @@\n+error[E0038]: the trait `Fetcher` cannot be made into an object\n+  --> $DIR/issue-102762.rs:18:21\n+   |\n+LL |     fn get<'a>(self: &'a Box<Self>) -> Pin<Box<dyn Future<Output = Vec<u8>> + 'a>>\n+   |                      ------------- help: consider changing method `get`'s `self` parameter to be `&self`: `&Self`\n+...\n+LL | fn fetcher() -> Box<dyn Fetcher> {\n+   |                     ^^^^^^^^^^^ `Fetcher` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/issue-102762.rs:10:22\n+   |\n+LL | pub trait Fetcher: Send + Sync {\n+   |           ------- this trait cannot be made into an object...\n+LL |     fn get<'a>(self: &'a Box<Self>) -> Pin<Box<dyn Future<Output = Vec<u8>> + 'a>>\n+   |                      ^^^^^^^^^^^^^ ...because method `get`'s `self` parameter cannot be dispatched on\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}]}