{"sha": "7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NThkYzIzN2Q3MGZjMGM1YTMxZWI1MjhkZmFiMWFkMGJhZjZhMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-20T04:14:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-20T04:14:51Z"}, "message": "Auto merge of #63497 - eddyb:miri-subst, r=oli-obk\n\nrustc_mir: fix miri substitution/\"universe\" discipline.\n\nAlternative to #61041, based on @RalfJung's own attempt at it.\nI haven't done a full audit, but I believe everything is fixed now.\n\nFixes #61432.\nCloses #61336, as a drive-by fix (for a subset of #43408, that is already special-cased).\n\nr? @oli-obk / @RalfJung cc @varkor @yodaldevoid", "tree": {"sha": "dc806a4c924f3d9ba6d1536cc7ee4668cc29352d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc806a4c924f3d9ba6d1536cc7ee4668cc29352d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "html_url": "https://github.com/rust-lang/rust/commit/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8d99baf565bb389b82553dfe1f6e56ddc650184", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d99baf565bb389b82553dfe1f6e56ddc650184", "html_url": "https://github.com/rust-lang/rust/commit/d8d99baf565bb389b82553dfe1f6e56ddc650184"}, {"sha": "96fc98904f9e4b16e427f3e8988b7335cd60cf77", "url": "https://api.github.com/repos/rust-lang/rust/commits/96fc98904f9e4b16e427f3e8988b7335cd60cf77", "html_url": "https://github.com/rust-lang/rust/commit/96fc98904f9e4b16e427f3e8988b7335cd60cf77"}], "stats": {"total": 235, "additions": 159, "deletions": 76}, "files": [{"sha": "210647ac1e9a3de60307d4490cdd7a26c2000812", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, TypeAndMut};\n+use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n use syntax::ast::FloatTy;\n@@ -36,15 +36,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n                             bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n-                        let instance = ty::Instance::resolve(\n-                            *self.tcx,\n-                            self.param_env,\n-                            def_id,\n-                            substs,\n-                        ).ok_or_else(|| err_inval!(TooGeneric))?;\n+                        let instance = self.resolve(def_id, substs)?;\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n@@ -67,7 +67,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::Closure(def_id, substs) => {\n-                        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,\n                             def_id,"}, {"sha": "6f48396cdd7cfeca0af170637f00b6ccb23d3d5d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 29, "deletions": 60, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -9,7 +9,7 @@ use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n-use rustc::ty::subst::{Subst, SubstsRef};\n+use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -291,41 +291,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n     }\n \n-    pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n-        &self,\n-        substs: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.tcx.subst_and_normalize_erasing_regions(\n-                frame.instance.substs,\n-                self.param_env,\n-                &substs,\n-            )),\n-            None => if substs.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(substs)\n-            },\n-        }\n-    }\n-\n-    pub(super) fn resolve(\n-        &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n-        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n-        trace!(\"param_env: {:#?}\", self.param_env);\n-        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n-        trace!(\"substs: {:#?}\", substs);\n-        ty::Instance::resolve(\n-            *self.tcx,\n-            self.param_env,\n-            def_id,\n-            substs,\n-        ).ok_or_else(|| err_inval!(TooGeneric).into())\n-    }\n-\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n@@ -349,34 +314,34 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// Call this on things you got out of the MIR (so it is as generic as the current\n+    /// stack frame), to bring it into the proper environment for this interpreter.\n+    pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n-        t: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n-            None => if t.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(t)\n-            },\n-        }\n+        value: T,\n+    ) -> T {\n+        self.tcx.subst_and_normalize_erasing_regions(\n+            self.frame().instance.substs,\n+            self.param_env,\n+            &value,\n+        )\n     }\n \n-    fn monomorphize_with_substs<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n+    pub(super) fn resolve(\n         &self,\n-        t: T,\n+        def_id: DefId,\n         substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, T> {\n-        // miri doesn't care about lifetimes, and will choke on some crazy ones\n-        // let's simply get rid of them\n-        let substituted = t.subst(*self.tcx, substs);\n-\n-        if substituted.needs_subst() {\n-            throw_inval!(TooGeneric)\n-        }\n-\n-        Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n+    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n+        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n+        trace!(\"param_env: {:#?}\", self.param_env);\n+        trace!(\"substs: {:#?}\", substs);\n+        ty::Instance::resolve(\n+            *self.tcx,\n+            self.param_env,\n+            def_id,\n+            substs,\n+        ).ok_or_else(|| err_inval!(TooGeneric).into())\n     }\n \n     pub fn layout_of_local(\n@@ -391,7 +356,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs)?;\n+                    let local_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                        frame.instance.substs,\n+                        self.param_env,\n+                        &local_ty,\n+                    );\n                     self.layout_of(local_ty)\n                 })?;\n                 if let Some(state) = frame.locals.get(local) {"}, {"sha": "7a545e8ad6f792abbee4190061bf46eed0ac56fd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -522,7 +522,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => self.eval_const_to_op(constant.literal, layout)?,\n+            Constant(ref constant) => {\n+                let val = self.subst_from_frame_and_normalize_erasing_regions(constant.literal);\n+                self.eval_const_to_op(val, layout)?\n+            }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -540,6 +543,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     // Used when the miri-engine runs into a constant and for extracting information from constants\n     // in patterns via the `const_eval` module\n+    /// The `val` and `layout` are assumed to already be in our interpreter\n+    /// \"universe\" (param_env).\n     crate fn eval_const_to_op(\n         &self,\n         val: &'tcx ty::Const<'tcx>,\n@@ -552,7 +557,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         match val.val {\n             ConstValue::Param(_) =>\n-                // FIXME(oli-obk): try to monomorphize\n                 throw_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n@@ -565,7 +569,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // Other cases need layout.\n         let layout = from_known_layout(layout, || {\n-            self.layout_of(self.monomorphize(val.ty)?)\n+            self.layout_of(val.ty)\n         })?;\n         let op = match val.val {\n             ConstValue::ByRef { alloc, offset } => {"}, {"sha": "85f9cbd37589ab2260f0d66211e44d5539759128", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -640,8 +640,11 @@ where\n                         // their layout on return.\n                         PlaceTy {\n                             place: *return_place,\n-                            layout: self\n-                                .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n+                            layout: self.layout_of(\n+                                self.subst_from_frame_and_normalize_erasing_regions(\n+                                    self.frame().body.return_ty()\n+                                )\n+                            )?,\n                         }\n                     }\n                     None => throw_unsup!(InvalidNullPointerUsage),"}, {"sha": "ca4da451a1f2d58f9f57879c683073b107fcb980", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -254,7 +254,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(ty)?;\n+                let ty = self.subst_from_frame_and_normalize_erasing_regions(ty);\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");"}, {"sha": "a2fc75739ffa0ae34ffe672fb06c6c395a483fbf", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, Instance};\n+use rustc::ty::{self, Ty, Instance, TypeFoldable};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic,};\n \n@@ -20,6 +20,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n+        // All vtables must be monomorphic, bail out otherwise.\n+        if ty.needs_subst() || poly_trait_ref.needs_subst() {\n+            throw_inval!(TooGeneric);\n+        }\n+\n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n             // This means we guarantee that there are no duplicate vtables, we will\n             // always use the same vtable for the same (Type, Trait) combination.\n@@ -77,7 +82,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n-                let substs = self.subst_and_normalize_erasing_regions(substs)?;\n                 let instance = ty::Instance::resolve_for_vtable(\n                     *self.tcx,\n                     self.param_env,"}, {"sha": "312a598af02bf20962c6a67e6abe8f725afec00f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -900,6 +900,20 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id(parent_id))\n         }\n+        // FIXME(#43408) enable this in all cases when we get lazy normalization.\n+        Node::AnonConst(&anon_const) => {\n+            // HACK(eddyb) this provides the correct generics when the workaround\n+            // for a const parameter `AnonConst` is being used elsewhere, as then\n+            // there won't be the kind of cyclic dependency blocking #43408.\n+            let expr = &tcx.hir().body(anon_const.body).value;\n+            let icx = ItemCtxt::new(tcx, def_id);\n+            if AstConv::const_param_def_id(&icx, expr).is_some() {\n+                let parent_id = tcx.hir().get_parent_item(hir_id);\n+                Some(tcx.hir().local_def_id(parent_id))\n+            } else {\n+                None\n+            }\n+        }\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             .."}, {"sha": "832095ce542062b89c2d76fd8332bfb7eae21950", "filename": "src/test/ui/const-generics/issue-61432.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn promote<const N: i32>() {\n+    // works:\n+    //\n+    // let n = N;\n+    // &n;\n+\n+    &N;\n+}\n+\n+fn main() {\n+    promote::<0>();\n+}"}, {"sha": "33f77b028104eb40ab44c3c247d56d2221db237f", "filename": "src/test/ui/const-generics/issue-61432.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-61432.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "7a299169bc4e19e59a5c0d63749140049a14fe9a", "filename": "src/test/ui/consts/too_generic_eval_ice.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -0,0 +1,13 @@\n+pub struct Foo<A, B>(A, B);\n+\n+impl<A, B> Foo<A, B> {\n+    const HOST_SIZE: usize = std::mem::size_of::<B>();\n+\n+    pub fn crash() -> bool {\n+        [5; Self::HOST_SIZE] == [6; 0] //~ ERROR no associated item named `HOST_SIZE`\n+        //~^ the size for values of type `A` cannot be known\n+        //~| the size for values of type `B` cannot be known\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eef79421270ce6c917c774a9ef08648acb0201ce", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "patch": "@@ -0,0 +1,47 @@\n+error[E0599]: no associated item named `HOST_SIZE` found for type `Foo<A, B>` in the current scope\n+  --> $DIR/too_generic_eval_ice.rs:7:19\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | --------------------------- associated item `HOST_SIZE` not found for this\n+...\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |                   ^^^^^^^^^ associated item not found in `Foo<A, B>`\n+   |\n+   = note: the method `HOST_SIZE` exists but the following trait bounds were not satisfied:\n+           `A : std::marker::Sized`\n+           `B : std::marker::Sized`\n+\n+error[E0277]: the size for values of type `A` cannot be known at compilation time\n+  --> $DIR/too_generic_eval_ice.rs:7:13\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `A`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = help: consider adding a `where A: std::marker::Sized` bound\n+note: required by `Foo`\n+  --> $DIR/too_generic_eval_ice.rs:1:1\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the size for values of type `B` cannot be known at compilation time\n+  --> $DIR/too_generic_eval_ice.rs:7:13\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `B`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = help: consider adding a `where B: std::marker::Sized` bound\n+note: required by `Foo`\n+  --> $DIR/too_generic_eval_ice.rs:1:1\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0599.\n+For more information about an error, try `rustc --explain E0277`."}]}