{"sha": "4aa632761f1db5f18338c9bd568156c0259b9252", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYTYzMjc2MWYxZGI1ZjE4MzM4YzliZDU2ODE1NmMwMjU5YjkyNTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-11T11:57:19Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-11T11:57:19Z"}, "message": "make on dot typed actually work", "tree": {"sha": "d977aab44ae138ba2427b0588efafd8fa7e7fd71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d977aab44ae138ba2427b0588efafd8fa7e7fd71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4aa632761f1db5f18338c9bd568156c0259b9252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4aa632761f1db5f18338c9bd568156c0259b9252", "html_url": "https://github.com/rust-lang/rust/commit/4aa632761f1db5f18338c9bd568156c0259b9252", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4aa632761f1db5f18338c9bd568156c0259b9252/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd122145b57513cf57076ae3235d70215b226039", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd122145b57513cf57076ae3235d70215b226039", "html_url": "https://github.com/rust-lang/rust/commit/dd122145b57513cf57076ae3235d70215b226039"}], "stats": {"total": 246, "additions": 121, "deletions": 125}, "files": [{"sha": "3495ad967706d887d67a02c1e2683f3d606efaa9", "filename": "crates/ra_ide_api_light/src/assists.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4aa632761f1db5f18338c9bd568156c0259b9252/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa632761f1db5f18338c9bd568156c0259b9252/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs?ref=4aa632761f1db5f18338c9bd568156c0259b9252", "patch": "@@ -15,10 +15,11 @@ use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_syntax::{\n     Direction, SyntaxNode, TextUnit, TextRange, SourceFile, AstNode,\n     algo::{find_leaf_at_offset, find_node_at_offset, find_covering_node, LeafAtOffset},\n-    ast::{self, AstToken},\n };\n use itertools::Itertools;\n \n+use crate::formatting::leading_indent;\n+\n pub use self::{\n     flip_comma::flip_comma,\n     add_derive::add_derive,\n@@ -165,7 +166,7 @@ impl AssistBuilder {\n     }\n     fn replace_node_and_indent(&mut self, node: &SyntaxNode, replace_with: impl Into<String>) {\n         let mut replace_with = replace_with.into();\n-        if let Some(indent) = calc_indent(node) {\n+        if let Some(indent) = leading_indent(node) {\n             replace_with = reindent(&replace_with, indent)\n         }\n         self.replace(node.range(), replace_with)\n@@ -182,12 +183,6 @@ impl AssistBuilder {\n     }\n }\n \n-fn calc_indent(node: &SyntaxNode) -> Option<&str> {\n-    let prev = node.prev_sibling()?;\n-    let ws_text = ast::Whitespace::cast(prev)?.text();\n-    ws_text.rfind('\\n').map(|pos| &ws_text[pos + 1..])\n-}\n-\n fn reindent(text: &str, indent: &str) -> String {\n     let indent = format!(\"\\n{}\", indent);\n     text.lines().intersperse(&indent).collect()"}, {"sha": "4635fbd605a0897fcb48d481ba238e93c9698707", "filename": "crates/ra_ide_api_light/src/formatting.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4aa632761f1db5f18338c9bd568156c0259b9252/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa632761f1db5f18338c9bd568156c0259b9252/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs?ref=4aa632761f1db5f18338c9bd568156c0259b9252", "patch": "@@ -1,8 +1,16 @@\n use ra_syntax::{\n-    ast, AstNode,\n+    AstNode,\n     SyntaxNode, SyntaxKind::*,\n+    ast::{self, AstToken},\n };\n \n+/// If the node is on the begining of the line, calculate indent.\n+pub(crate) fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n+    let prev = node.prev_sibling()?;\n+    let ws_text = ast::Whitespace::cast(prev)?.text();\n+    ws_text.rfind('\\n').map(|pos| &ws_text[pos + 1..])\n+}\n+\n pub(crate) fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {\n     let expr = block.expr()?;\n     if expr.syntax().text().contains('\\n') {"}, {"sha": "05845a0cc2c69dcd1c931f0329539e215380c771", "filename": "crates/ra_ide_api_light/src/typing.rs", "status": "modified", "additions": 109, "deletions": 116, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/4aa632761f1db5f18338c9bd568156c0259b9252/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa632761f1db5f18338c9bd568156c0259b9252/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs?ref=4aa632761f1db5f18338c9bd568156c0259b9252", "patch": "@@ -1,11 +1,11 @@\n use ra_syntax::{\n+    AstNode, SourceFile, SyntaxKind::*,\n+    SyntaxNode, TextUnit, TextRange,\n     algo::{find_node_at_offset, find_leaf_at_offset, LeafAtOffset},\n-    ast,\n-    AstNode, Direction, SourceFile, SyntaxKind::*,\n-    SyntaxNode, TextUnit,\n+    ast::{self, AstToken},\n };\n \n-use crate::{LocalEdit, TextEditBuilder};\n+use crate::{LocalEdit, TextEditBuilder, formatting::leading_indent};\n \n pub fn on_enter(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     let comment = find_leaf_at_offset(file.syntax(), offset)\n@@ -53,20 +53,21 @@ fn node_indent<'a>(file: &'a SourceFile, node: &SyntaxNode) -> Option<&'a str> {\n     Some(&text[pos..])\n }\n \n-pub fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n-    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n+pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<LocalEdit> {\n+    assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n+    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n     if let Some(expr) = let_stmt.initializer() {\n         let expr_range = expr.syntax().range();\n-        if expr_range.contains(offset) && offset != expr_range.start() {\n+        if expr_range.contains(eq_offset) && eq_offset != expr_range.start() {\n             return None;\n         }\n         if file\n             .syntax()\n             .text()\n-            .slice(offset..expr_range.start())\n+            .slice(eq_offset..expr_range.start())\n             .contains('\\n')\n         {\n             return None;\n@@ -84,54 +85,44 @@ pub fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     })\n }\n \n-pub fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n-    let before_dot_offset = offset - TextUnit::of_char('.');\n+pub fn on_dot_typed(file: &SourceFile, dot_offset: TextUnit) -> Option<LocalEdit> {\n+    assert_eq!(file.syntax().text().char_at(dot_offset), Some('.'));\n \n-    let whitespace = find_leaf_at_offset(file.syntax(), before_dot_offset).left_biased()?;\n-\n-    // find whitespace just left of the dot\n-    ast::Whitespace::cast(whitespace)?;\n-\n-    // make sure there is a method call\n-    let method_call = whitespace\n-        .siblings(Direction::Prev)\n-        // first is whitespace\n-        .skip(1)\n-        .next()?;\n-\n-    ast::MethodCallExpr::cast(method_call)?;\n-\n-    // find how much the _method call is indented\n-    let method_chain_indent = method_call\n-        .parent()?\n-        .siblings(Direction::Prev)\n-        .skip(1)\n-        .next()?\n-        .leaf_text()\n-        .map(|x| last_line_indent_in_whitespace(x))?;\n-\n-    let current_indent = TextUnit::of_str(last_line_indent_in_whitespace(whitespace.leaf_text()?));\n-    // TODO: indent is always 4 spaces now. A better heuristic could look on the previous line(s)\n-\n-    let target_indent = TextUnit::of_str(method_chain_indent) + TextUnit::from_usize(4);\n-\n-    let diff = target_indent - current_indent;\n-\n-    let indent = \"\".repeat(diff.to_usize());\n+    let whitespace = find_leaf_at_offset(file.syntax(), dot_offset)\n+        .left_biased()\n+        .and_then(ast::Whitespace::cast)?;\n \n-    let cursor_position = offset + diff;\n+    let current_indent = {\n+        let text = whitespace.text();\n+        let newline = text.rfind('\\n')?;\n+        &text[newline + 1..]\n+    };\n+    let current_indent_len = TextUnit::of_str(current_indent);\n+\n+    // Make sure dot is a part of call chain\n+    let field_expr = whitespace\n+        .syntax()\n+        .parent()\n+        .and_then(ast::FieldExpr::cast)?;\n+    let prev_indent = leading_indent(field_expr.syntax())?;\n+    let target_indent = format!(\"    {}\", prev_indent);\n+    let target_indent_len = TextUnit::of_str(&target_indent);\n+    if current_indent_len == target_indent_len {\n+        return None;\n+    }\n     let mut edit = TextEditBuilder::default();\n-    edit.insert(before_dot_offset, indent);\n-    Some(LocalEdit {\n-        label: \"indent dot\".to_string(),\n+    edit.replace(\n+        TextRange::from_to(dot_offset - current_indent_len, dot_offset),\n+        target_indent.into(),\n+    );\n+    let res = LocalEdit {\n+        label: \"reindent dot\".to_string(),\n         edit: edit.finish(),\n-        cursor_position: Some(cursor_position),\n-    })\n-}\n-\n-/// Finds the last line in the whitespace\n-fn last_line_indent_in_whitespace(ws: &str) -> &str {\n-    ws.split('\\n').last().unwrap_or(\"\")\n+        cursor_position: Some(\n+            dot_offset + target_indent_len - current_indent_len + TextUnit::of_char('.'),\n+        ),\n+    };\n+    Some(res)\n }\n \n #[cfg(test)]\n@@ -162,7 +153,7 @@ mod tests {\n         do_check(\n             r\"\n fn foo() {\n-    let foo =<|> 1 + 1\n+    let foo <|>= 1 + 1\n }\n \",\n             r\"\n@@ -189,107 +180,109 @@ fn foo() {\n         fn do_check(before: &str, after: &str) {\n             let (offset, before) = extract_offset(before);\n             let file = SourceFile::parse(&before);\n-            if let Some(result) = on_eq_typed(&file, offset) {\n+            if let Some(result) = on_dot_typed(&file, offset) {\n                 let actual = result.edit.apply(&before);\n                 assert_eq_text!(after, &actual);\n+            } else {\n+                assert_eq_text!(&before, after)\n             };\n         }\n         // indent if continuing chain call\n         do_check(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-        .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                <|>.\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .\n+            }\n+            \",\n         );\n \n         // do not indent if already indented\n         do_check(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    <|>.\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .\n+            }\n+            \",\n         );\n \n         // indent if the previous line is already indented\n         do_check(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-        .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                <|>.\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                    .\n+            }\n+            \",\n         );\n \n         // don't indent if indent matches previous line\n         do_check(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-            .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                    <|>.\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                    .\n+            }\n+            \",\n         );\n \n         // don't indent if there is no method call on previous line\n         do_check(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                <|>.\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                .\n+            }\n+            \",\n         );\n \n         // indent to match previous expr\n         do_check(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-.<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+            <|>.\n+                }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .\n+            }\n+            \",\n         );\n     }\n "}]}