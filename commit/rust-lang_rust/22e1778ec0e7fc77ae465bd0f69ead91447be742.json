{"sha": "22e1778ec0e7fc77ae465bd0f69ead91447be742", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZTE3NzhlYzBlN2ZjNzdhZTQ2NWJkMGY2OWVhZDkxNDQ3YmU3NDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-09T12:04:34Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-12T14:14:57Z"}, "message": "rustc_args_required_const is no longer a promotion site", "tree": {"sha": "5d17af00eb587cf1c4d8ab31ab2807f0034c9342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d17af00eb587cf1c4d8ab31ab2807f0034c9342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22e1778ec0e7fc77ae465bd0f69ead91447be742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22e1778ec0e7fc77ae465bd0f69ead91447be742", "html_url": "https://github.com/rust-lang/rust/commit/22e1778ec0e7fc77ae465bd0f69ead91447be742", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22e1778ec0e7fc77ae465bd0f69ead91447be742/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1ff91f439bc09f566da211c6449821b4e949279", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1ff91f439bc09f566da211c6449821b4e949279", "html_url": "https://github.com/rust-lang/rust/commit/e1ff91f439bc09f566da211c6449821b4e949279"}], "stats": {"total": 311, "additions": 28, "deletions": 283}, "files": [{"sha": "f786f327ba2f503e894b064047b5b9d79d9499ad", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 28, "deletions": 161, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/22e1778ec0e7fc77ae465bd0f69ead91447be742/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e1778ec0e7fc77ae465bd0f69ead91447be742/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=22e1778ec0e7fc77ae465bd0f69ead91447be742", "patch": "@@ -12,20 +12,16 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n-use rustc_ast::LitKind;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::mir::traversal::ReversePostorder;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, List, TyCtxt, TypeFoldable};\n-use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_target::spec::abi::Abi;\n \n use std::cell::Cell;\n use std::{cmp, iter, mem};\n@@ -101,47 +97,16 @@ impl TempState {\n pub enum Candidate {\n     /// Borrow of a constant temporary, candidate for lifetime extension.\n     Ref(Location),\n-\n-    /// Currently applied to function calls where the callee has the unstable\n-    /// `#[rustc_args_required_const]` attribute as well as the SIMD shuffle\n-    /// intrinsic. The intrinsic requires the arguments are indeed constant and\n-    /// the attribute currently provides the semantic requirement that arguments\n-    /// must be constant.\n-    Argument { bb: BasicBlock, index: usize },\n }\n \n impl Candidate {\n-    /// Returns `true` if we should use the \"explicit\" rules for promotability for this `Candidate`.\n-    fn forces_explicit_promotion(&self) -> bool {\n-        match self {\n-            Candidate::Ref(_) => false,\n-            Candidate::Argument { .. } => true,\n-        }\n-    }\n-\n     fn source_info(&self, body: &Body<'_>) -> SourceInfo {\n         match self {\n             Candidate::Ref(location) => *body.source_info(*location),\n-            Candidate::Argument { bb, .. } => *body.source_info(body.terminator_loc(*bb)),\n         }\n     }\n }\n \n-fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n-    let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| tcx.sess.check_name(a, sym::rustc_args_required_const))?;\n-    let mut ret = vec![];\n-    for meta in attr.meta_item_list()? {\n-        match meta.literal()?.kind {\n-            LitKind::Int(a, _) => {\n-                ret.push(a as usize);\n-            }\n-            _ => bug!(\"invalid arg index\"),\n-        }\n-    }\n-    Some(ret)\n-}\n-\n struct Collector<'a, 'tcx> {\n     ccx: &'a ConstCx<'a, 'tcx>,\n     temps: IndexVec<Local, TempState>,\n@@ -208,31 +173,6 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             _ => {}\n         }\n     }\n-\n-    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        self.super_terminator(terminator, location);\n-\n-        if let TerminatorKind::Call { ref func, .. } = terminator.kind {\n-            if let ty::FnDef(def_id, _) = *func.ty(self.ccx.body, self.ccx.tcx).kind() {\n-                let fn_sig = self.ccx.tcx.fn_sig(def_id);\n-                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n-                    let name = self.ccx.tcx.item_name(def_id);\n-                    // FIXME(eddyb) use `#[rustc_args_required_const(2)]` for shuffles.\n-                    if name.as_str().starts_with(\"simd_shuffle\") {\n-                        self.candidates.push(Candidate::Argument { bb: location.block, index: 2 });\n-\n-                        return; // Don't double count `simd_shuffle` candidates\n-                    }\n-                }\n-\n-                if let Some(constant_args) = args_required_const(self.ccx.tcx, def_id) {\n-                    for index in constant_args {\n-                        self.candidates.push(Candidate::Argument { bb: location.block, index });\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n pub fn collect_temps_and_candidates(\n@@ -256,14 +196,6 @@ pub fn collect_temps_and_candidates(\n struct Validator<'a, 'tcx> {\n     ccx: &'a ConstCx<'a, 'tcx>,\n     temps: &'a IndexVec<Local, TempState>,\n-\n-    /// Explicit promotion happens e.g. for constant arguments declared via\n-    /// `rustc_args_required_const`.\n-    /// Implicit promotion has almost the same rules, except that disallows `const fn`\n-    /// except for those marked `#[rustc_promotable]`. This is to avoid changing\n-    /// a legitimate run-time operation into a failing compile-time operation\n-    /// e.g. due to addresses being compared inside the function.\n-    explicit: bool,\n }\n \n impl std::ops::Deref for Validator<'a, 'tcx> {\n@@ -280,8 +212,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n         match candidate {\n             Candidate::Ref(loc) => {\n-                assert!(!self.explicit);\n-\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n@@ -310,15 +240,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     _ => bug!(),\n                 }\n             }\n-            Candidate::Argument { bb, index } => {\n-                assert!(self.explicit);\n-\n-                let terminator = self.body[bb].terminator();\n-                match &terminator.kind {\n-                    TerminatorKind::Call { args, .. } => self.validate_operand(&args[index]),\n-                    _ => bug!(),\n-                }\n-            }\n         }\n     }\n \n@@ -448,12 +369,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {}\n \n                     ProjectionElem::Index(local) => {\n-                        if !self.explicit {\n-                            let mut promotable = false;\n-                            // Only accept if we can predict the index and are indexing an array.\n-                            let val = if let TempState::Defined { location: loc, .. } =\n-                                self.temps[local]\n-                            {\n+                        let mut promotable = false;\n+                        // Only accept if we can predict the index and are indexing an array.\n+                        let val =\n+                            if let TempState::Defined { location: loc, .. } = self.temps[local] {\n                                 let block = &self.body[loc.block];\n                                 if loc.statement_index < block.statements.len() {\n                                     let statement = &block.statements[loc.statement_index];\n@@ -470,28 +389,27 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             } else {\n                                 None\n                             };\n-                            if let Some(idx) = val {\n-                                // Determine the type of the thing we are indexing.\n-                                let ty = place_base.ty(self.body, self.tcx).ty;\n-                                match ty.kind() {\n-                                    ty::Array(_, len) => {\n-                                        // It's an array; determine its length.\n-                                        if let Some(len) =\n-                                            len.try_eval_usize(self.tcx, self.param_env)\n-                                        {\n-                                            // If the index is in-bounds, go ahead.\n-                                            if idx < len {\n-                                                promotable = true;\n-                                            }\n+                        if let Some(idx) = val {\n+                            // Determine the type of the thing we are indexing.\n+                            let ty = place_base.ty(self.body, self.tcx).ty;\n+                            match ty.kind() {\n+                                ty::Array(_, len) => {\n+                                    // It's an array; determine its length.\n+                                    if let Some(len) = len.try_eval_usize(self.tcx, self.param_env)\n+                                    {\n+                                        // If the index is in-bounds, go ahead.\n+                                        if idx < len {\n+                                            promotable = true;\n                                         }\n                                     }\n-                                    _ => {}\n                                 }\n+                                _ => {}\n                             }\n-                            if !promotable {\n-                                return Err(Unpromotable);\n-                            }\n                         }\n+                        if !promotable {\n+                            return Err(Unpromotable);\n+                        }\n+\n                         self.validate_local(local)?;\n                     }\n \n@@ -636,7 +554,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n                 match op {\n                     BinOp::Div | BinOp::Rem => {\n-                        if !self.explicit && lhs_ty.is_integral() {\n+                        if lhs_ty.is_integral() {\n                             // Integer division: the RHS must be a non-zero const.\n                             let const_val = match rhs {\n                                 Operand::Constant(c) => {\n@@ -721,13 +639,12 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        // When doing explicit promotion and inside const/static items, we promote all (eligible) function calls.\n+        // Inside const/static items, we promote all (eligible) function calls.\n         // Everywhere else, we require `#[rustc_promotable]` on the callee.\n-        let promote_all_const_fn = self.explicit\n-            || matches!(\n-                self.const_kind,\n-                Some(hir::ConstContext::Static(_) | hir::ConstContext::Const)\n-            );\n+        let promote_all_const_fn = matches!(\n+            self.const_kind,\n+            Some(hir::ConstContext::Static(_) | hir::ConstContext::Const)\n+        );\n         if !promote_all_const_fn {\n             if let ty::FnDef(def_id, _) = *fn_ty.kind() {\n                 // Never promote runtime `const fn` calls of\n@@ -765,41 +682,12 @@ pub fn validate_candidates(\n     temps: &IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n-    let mut validator = Validator { ccx, temps, explicit: false };\n+    let validator = Validator { ccx, temps };\n \n     candidates\n         .iter()\n         .copied()\n-        .filter(|&candidate| {\n-            validator.explicit = candidate.forces_explicit_promotion();\n-\n-            // FIXME(eddyb) also emit the errors for shuffle indices\n-            // and `#[rustc_args_required_const]` arguments here.\n-\n-            let is_promotable = validator.validate_candidate(candidate).is_ok();\n-\n-            // If we use explicit validation, we carry the risk of turning a legitimate run-time\n-            // operation into a failing compile-time operation. Make sure that does not happen\n-            // by asserting that there is no possible run-time behavior here in case promotion\n-            // fails.\n-            if validator.explicit && !is_promotable {\n-                ccx.tcx.sess.delay_span_bug(\n-                    ccx.body.span,\n-                    \"Explicit promotion requested, but failed to promote\",\n-                );\n-            }\n-\n-            match candidate {\n-                Candidate::Argument { bb, index } if !is_promotable => {\n-                    let span = ccx.body[bb].terminator().source_info.span;\n-                    let msg = format!(\"argument {} is required to be a constant\", index + 1);\n-                    ccx.tcx.sess.span_err(span, &msg);\n-                }\n-                _ => (),\n-            }\n-\n-            is_promotable\n-        })\n+        .filter(|&candidate| validator.validate_candidate(candidate).is_ok())\n         .collect()\n }\n \n@@ -1039,26 +927,6 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         _ => bug!(),\n                     }\n                 }\n-                Candidate::Argument { bb, index } => {\n-                    let terminator = blocks[bb].terminator_mut();\n-                    match terminator.kind {\n-                        TerminatorKind::Call { ref mut args, .. } => {\n-                            let ty = args[index].ty(local_decls, self.tcx);\n-                            let span = terminator.source_info.span;\n-\n-                            Rvalue::Use(mem::replace(&mut args[index], promoted_operand(ty, span)))\n-                        }\n-                        // We expected a `TerminatorKind::Call` for which we'd like to promote an\n-                        // argument. `qualify_consts` saw a `TerminatorKind::Call` here, but\n-                        // we are seeing a `Goto`. That means that the `promote_temps` method\n-                        // already promoted this call away entirely. This case occurs when calling\n-                        // a function requiring a constant argument and as that constant value\n-                        // providing a value whose computation contains another call to a function\n-                        // requiring a constant argument.\n-                        TerminatorKind::Goto { .. } => return None,\n-                        _ => bug!(),\n-                    }\n-                }\n             }\n         };\n \n@@ -1113,7 +981,6 @@ pub fn promote_candidates<'tcx>(\n                     }\n                 }\n             }\n-            Candidate::Argument { .. } => {}\n         }\n \n         // Declare return place local so that `mir::Body::new` doesn't complain."}, {"sha": "9add1f8d5a3592615956cefb6ccb69ab5fe1a4e5", "filename": "src/test/ui/consts/const_arg_local.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_local.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,11 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-#[rustc_args_required_const(0)]\n-fn foo(_imm8: i32) {}\n-\n-fn bar() {\n-    let imm8 = 3;\n-    foo(imm8) //~ ERROR argument 1 is required to be a constant\n-}\n-\n-fn main() {}"}, {"sha": "bad85471a6b376df719c9574b98488ba457176b7", "filename": "src/test/ui/consts/const_arg_local.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_local.stderr?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,8 +0,0 @@\n-error: argument 1 is required to be a constant\n-  --> $DIR/const_arg_local.rs:8:5\n-   |\n-LL |     foo(imm8)\n-   |     ^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "cea3817550eb2b101215ac0f16289dd03d53e38d", "filename": "src/test/ui/consts/const_arg_promotable.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,10 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-#[rustc_args_required_const(0)]\n-fn foo(_imm8: i32) {}\n-\n-fn bar() {\n-    foo(*&mut 42) //~ ERROR argument 1 is required to be a constant\n-}\n-\n-fn main() {}"}, {"sha": "b24b245b3ce0c867f5539e035711208e6b5400cc", "filename": "src/test/ui/consts/const_arg_promotable.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable.stderr?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,8 +0,0 @@\n-error: argument 1 is required to be a constant\n-  --> $DIR/const_arg_promotable.rs:7:5\n-   |\n-LL |     foo(*&mut 42)\n-   |     ^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "3399e51ed4edb26d60636b89282a557d4af89f7a", "filename": "src/test/ui/consts/const_arg_promotable2.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable2.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,18 +0,0 @@\n-// This test is a regression test for a bug where we only checked function calls in no-const\n-// functions for `rustc_args_required_const` arguments. This meant that even though `bar` needs its\n-// argument to be const, inside a const fn (callable at runtime), the value for it may come from a\n-// non-constant (namely an argument to the const fn).\n-\n-#![feature(rustc_attrs)]\n-const fn foo(a: i32) {\n-    bar(a); //~ ERROR argument 1 is required to be a constant\n-}\n-\n-#[rustc_args_required_const(0)]\n-const fn bar(_: i32) {}\n-\n-fn main() {\n-    // this function call will pass a runtime-value (number of program arguments) to `foo`, which\n-    // will in turn forward it to `bar`, which expects a compile-time argument\n-    foo(std::env::args().count() as i32);\n-}"}, {"sha": "149d1ce89408d78473de8e7138fa0e1f875918a9", "filename": "src/test/ui/consts/const_arg_promotable2.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_promotable2.stderr?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,8 +0,0 @@\n-error: argument 1 is required to be a constant\n-  --> $DIR/const_arg_promotable2.rs:8:5\n-   |\n-LL |     bar(a);\n-   |     ^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "3dd3a2ffaf3cba83f332c2fca31e2b85592a8a5f", "filename": "src/test/ui/consts/const_arg_wrapper.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_wrapper.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,10 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-#[rustc_args_required_const(0)]\n-fn foo(_imm8: i32) {}\n-\n-fn bar(imm8: i32) {\n-    foo(imm8) //~ ERROR argument 1 is required to be a constant\n-}\n-\n-fn main() {}"}, {"sha": "9cd95a2020fcd1c2b2e0f2ddb0039568e7946e06", "filename": "src/test/ui/consts/const_arg_wrapper.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_wrapper.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_wrapper.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_arg_wrapper.stderr?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,8 +0,0 @@\n-error: argument 1 is required to be a constant\n-  --> $DIR/const_arg_wrapper.rs:7:5\n-   |\n-LL |     foo(imm8)\n-   |     ^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "0723b66879c388bf213ddfcc4913ebed6ed1f356", "filename": "src/test/ui/consts/rustc-args-required-const.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Frustc-args-required-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Frustc-args-required-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frustc-args-required-const.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,27 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-#[rustc_args_required_const(0)]\n-fn foo(_a: i32) {\n-}\n-\n-#[rustc_args_required_const(1)]\n-fn bar(_a: i32, _b: i32) {\n-}\n-\n-const A: i32 = 3;\n-\n-const fn baz() -> i32 {\n-    3\n-}\n-\n-fn main() {\n-    foo(2);\n-    foo(2 + 3);\n-    const BAZ: i32 = baz();\n-    foo(BAZ);\n-    let a = 4;\n-    foo(A);\n-    foo(a); //~ ERROR: argument 1 is required to be a constant\n-    bar(a, 3);\n-    bar(a, a); //~ ERROR: argument 2 is required to be a constant\n-}"}, {"sha": "8b302692053a2b973e928784f8e256be8cff2482", "filename": "src/test/ui/consts/rustc-args-required-const.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Frustc-args-required-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fui%2Fconsts%2Frustc-args-required-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frustc-args-required-const.stderr?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1,14 +0,0 @@\n-error: argument 1 is required to be a constant\n-  --> $DIR/rustc-args-required-const.rs:24:5\n-   |\n-LL |     foo(a);\n-   |     ^^^^^^\n-\n-error: argument 2 is required to be a constant\n-  --> $DIR/rustc-args-required-const.rs:26:5\n-   |\n-LL |     bar(a, a);\n-   |     ^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-"}]}