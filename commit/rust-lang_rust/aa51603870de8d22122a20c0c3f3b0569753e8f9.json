{"sha": "aa51603870de8d22122a20c0c3f3b0569753e8f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNTE2MDM4NzBkZThkMjIxMjJhMjBjMGMzZjNiMDU2OTc1M2U4Zjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-10T18:53:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:51:12Z"}, "message": "extract the `implied_bounds` code into a helper function", "tree": {"sha": "415a568f497679139e40e9b322801368d17dca5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/415a568f497679139e40e9b322801368d17dca5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa51603870de8d22122a20c0c3f3b0569753e8f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa51603870de8d22122a20c0c3f3b0569753e8f9", "html_url": "https://github.com/rust-lang/rust/commit/aa51603870de8d22122a20c0c3f3b0569753e8f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa51603870de8d22122a20c0c3f3b0569753e8f9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22b31758ecaf5384e82f258d6c7fad27feca411b", "url": "https://api.github.com/repos/rust-lang/rust/commits/22b31758ecaf5384e82f258d6c7fad27feca411b", "html_url": "https://github.com/rust-lang/rust/commit/22b31758ecaf5384e82f258d6c7fad27feca411b"}], "stats": {"total": 373, "additions": 201, "deletions": 172}, "files": [{"sha": "409230ba79b833ecec4499aa1cb623b2ea6cbaf4", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 3, "deletions": 172, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/aa51603870de8d22122a20c0c3f3b0569753e8f9/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa51603870de8d22122a20c0c3f3b0569753e8f9/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=aa51603870de8d22122a20c0c3f3b0569753e8f9", "patch": "@@ -10,10 +10,8 @@\n \n use middle::free_region::FreeRegionMap;\n use infer::{InferCtxt, GenericKind};\n-use traits::FulfillmentContext;\n-use ty::{self, Ty, TypeFoldable};\n-use ty::outlives::Component;\n-use ty::wf;\n+use infer::outlives::implied_bounds::ImpliedBound;\n+use ty::{self, Ty};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -44,24 +42,6 @@ pub struct OutlivesEnvironment<'tcx> {\n     region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n }\n \n-/// Implied bounds are region relationships that we deduce\n-/// automatically.  The idea is that (e.g.) a caller must check that a\n-/// function's argument types are well-formed immediately before\n-/// calling that fn, and hence the *callee* can assume that its\n-/// argument types are well-formed. This may imply certain relationships\n-/// between generic parameters. For example:\n-///\n-///     fn foo<'a,T>(x: &'a T)\n-///\n-/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-#[derive(Debug)]\n-enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut free_region_map = FreeRegionMap::new();\n@@ -163,7 +143,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = infcx.resolve_type_vars_if_possible(&ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n-            let implied_bounds = self.implied_bounds(infcx, body_id, ty, span);\n+            let implied_bounds = infcx.implied_bounds(self.param_env, body_id, ty, span);\n \n             // But also record other relationships, such as `T:'x`,\n             // that don't go into the free-region-map but which we use\n@@ -203,153 +183,4 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n             }\n         }\n     }\n-\n-    /// Compute the implied bounds that a callee/impl can assume based on\n-    /// the fact that caller/projector has ensured that `ty` is WF.  See\n-    /// the `ImpliedBound` type for more details.\n-    fn implied_bounds(\n-        &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-        body_id: ast::NodeId,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Vec<ImpliedBound<'tcx>> {\n-        let tcx = infcx.tcx;\n-\n-        // Sometimes when we ask what it takes for T: WF, we get back that\n-        // U: WF is required; in that case, we push U onto this stack and\n-        // process it next. Currently (at least) these resulting\n-        // predicates are always guaranteed to be a subset of the original\n-        // type, so we need not fear non-termination.\n-        let mut wf_types = vec![ty];\n-\n-        let mut implied_bounds = vec![];\n-\n-        let mut fulfill_cx = FulfillmentContext::new();\n-\n-        while let Some(ty) = wf_types.pop() {\n-            // Compute the obligations for `ty` to be well-formed. If `ty` is\n-            // an unresolved inference variable, just substituted an empty set\n-            // -- because the return type here is going to be things we *add*\n-            // to the environment, it's always ok for this set to be smaller\n-            // than the ultimate set. (Note: normally there won't be\n-            // unresolved inference variables here anyway, but there might be\n-            // during typeck under some circumstances.)\n-            let obligations =\n-                wf::obligations(infcx, self.param_env, body_id, ty, span).unwrap_or(vec![]);\n-\n-            // NB: All of these predicates *ought* to be easily proven\n-            // true. In fact, their correctness is (mostly) implied by\n-            // other parts of the program. However, in #42552, we had\n-            // an annoying scenario where:\n-            //\n-            // - Some `T::Foo` gets normalized, resulting in a\n-            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-            //   (not sure why it couldn't immediately get\n-            //   solved). This result of `_1` got cached.\n-            // - These obligations were dropped on the floor here,\n-            //   rather than being registered.\n-            // - Then later we would get a request to normalize\n-            //   `T::Foo` which would result in `_1` being used from\n-            //   the cache, but hence without the `T: Trait<Foo=_1>`\n-            //   constraint. As a result, `_1` never gets resolved,\n-            //   and we get an ICE (in dropck).\n-            //\n-            // Therefore, we register any predicates involving\n-            // inference variables. We restrict ourselves to those\n-            // involving inference variables both for efficiency and\n-            // to avoids duplicate errors that otherwise show up.\n-            fulfill_cx.register_predicate_obligations(\n-                infcx,\n-                obligations\n-                    .iter()\n-                    .filter(|o| o.predicate.has_infer_types())\n-                    .cloned());\n-\n-            // From the full set of obligations, just filter down to the\n-            // region relationships.\n-            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n-                assert!(!obligation.has_escaping_regions());\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::ConstEvaluatable(..) => vec![],\n-\n-                    ty::Predicate::WellFormed(subty) => {\n-                        wf_types.push(subty);\n-                        vec![]\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref data) => {\n-                        match tcx.no_late_bound_regions(data) {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)]\n-                            }\n-                        }\n-                    }\n-\n-                    ty::Predicate::TypeOutlives(ref data) => {\n-                        match tcx.no_late_bound_regions(data) {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n-                                let components = tcx.outlives_components(ty_a);\n-                                self.implied_bounds_from_components(r_b, components)\n-                            }\n-                        }\n-                    }\n-                }\n-            }));\n-        }\n-\n-        // Ensure that those obligations that we had to solve\n-        // get solved *here*.\n-        match fulfill_cx.select_all_or_error(infcx) {\n-            Ok(()) => (),\n-            Err(errors) => infcx.report_fulfillment_errors(&errors, None),\n-        }\n-\n-        implied_bounds\n-    }\n-\n-    /// When we have an implied bound that `T: 'a`, we can further break\n-    /// this down to determine what relationships would have to hold for\n-    /// `T: 'a` to hold. We get to assume that the caller has validated\n-    /// those relationships.\n-    fn implied_bounds_from_components(\n-        &self,\n-        sub_region: ty::Region<'tcx>,\n-        sup_components: Vec<Component<'tcx>>,\n-    ) -> Vec<ImpliedBound<'tcx>> {\n-        sup_components\n-            .into_iter()\n-            .flat_map(|component| {\n-                match component {\n-                    Component::Region(r) =>\n-                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n-                    Component::Param(p) =>\n-                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n-                    Component::Projection(p) =>\n-                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n-                    Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                        vec![],\n-                    Component::UnresolvedInferenceVariable(..) =>\n-                        vec![],\n-                }\n-            })\n-            .collect()\n-    }\n }"}, {"sha": "ae6961a071393348366384fecb3442ff42aa73c6", "filename": "src/librustc/infer/outlives/implied_bounds.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/aa51603870de8d22122a20c0c3f3b0569753e8f9/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa51603870de8d22122a20c0c3f3b0569753e8f9/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs?ref=aa51603870de8d22122a20c0c3f3b0569753e8f9", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use traits::FulfillmentContext;\n+use ty::{self, Ty, TypeFoldable};\n+use ty::outlives::Component;\n+use ty::wf;\n+\n+/// Implied bounds are region relationships that we deduce\n+/// automatically.  The idea is that (e.g.) a caller must check that a\n+/// function's argument types are well-formed immediately before\n+/// calling that fn, and hence the *callee* can assume that its\n+/// argument types are well-formed. This may imply certain relationships\n+/// between generic parameters. For example:\n+///\n+///     fn foo<'a,T>(x: &'a T)\n+///\n+/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+#[derive(Debug)]\n+pub enum ImpliedBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Compute the implied bounds that a callee/impl can assume based on\n+    /// the fact that caller/projector has ensured that `ty` is WF.  See\n+    /// the `ImpliedBound` type for more details.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `param_env`, the where-clauses in scope\n+    /// - `body_id`, the body-id to use when normalizing assoc types.\n+    ///   Note that this may cause outlives obligations to be injected\n+    ///   into the inference context with this body-id.\n+    /// - `ty`, the type that we are supposed to assume is WF.\n+    /// - `span`, a span to use when normalizing, hopefully not important,\n+    ///   might be useful if a `bug!` occurs.\n+    pub fn implied_bounds(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<ImpliedBound<'tcx>> {\n+        let tcx = self.tcx;\n+\n+        // Sometimes when we ask what it takes for T: WF, we get back that\n+        // U: WF is required; in that case, we push U onto this stack and\n+        // process it next. Currently (at least) these resulting\n+        // predicates are always guaranteed to be a subset of the original\n+        // type, so we need not fear non-termination.\n+        let mut wf_types = vec![ty];\n+\n+        let mut implied_bounds = vec![];\n+\n+        let mut fulfill_cx = FulfillmentContext::new();\n+\n+        while let Some(ty) = wf_types.pop() {\n+            // Compute the obligations for `ty` to be well-formed. If `ty` is\n+            // an unresolved inference variable, just substituted an empty set\n+            // -- because the return type here is going to be things we *add*\n+            // to the environment, it's always ok for this set to be smaller\n+            // than the ultimate set. (Note: normally there won't be\n+            // unresolved inference variables here anyway, but there might be\n+            // during typeck under some circumstances.)\n+            let obligations =\n+                wf::obligations(self, param_env, body_id, ty, span).unwrap_or(vec![]);\n+\n+            // NB: All of these predicates *ought* to be easily proven\n+            // true. In fact, their correctness is (mostly) implied by\n+            // other parts of the program. However, in #42552, we had\n+            // an annoying scenario where:\n+            //\n+            // - Some `T::Foo` gets normalized, resulting in a\n+            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n+            //   (not sure why it couldn't immediately get\n+            //   solved). This result of `_1` got cached.\n+            // - These obligations were dropped on the floor here,\n+            //   rather than being registered.\n+            // - Then later we would get a request to normalize\n+            //   `T::Foo` which would result in `_1` being used from\n+            //   the cache, but hence without the `T: Trait<Foo=_1>`\n+            //   constraint. As a result, `_1` never gets resolved,\n+            //   and we get an ICE (in dropck).\n+            //\n+            // Therefore, we register any predicates involving\n+            // inference variables. We restrict ourselves to those\n+            // involving inference variables both for efficiency and\n+            // to avoids duplicate errors that otherwise show up.\n+            fulfill_cx.register_predicate_obligations(\n+                self,\n+                obligations\n+                    .iter()\n+                    .filter(|o| o.predicate.has_infer_types())\n+                    .cloned());\n+\n+            // From the full set of obligations, just filter down to the\n+            // region relationships.\n+            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+                assert!(!obligation.has_escaping_regions());\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => vec![],\n+\n+                    ty::Predicate::WellFormed(subty) => {\n+                        wf_types.push(subty);\n+                        vec![]\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref data) => {\n+                        match tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)]\n+                            }\n+                        }\n+                    }\n+\n+                    ty::Predicate::TypeOutlives(ref data) => {\n+                        match tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                                let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n+                                let components = tcx.outlives_components(ty_a);\n+                                Self::implied_bounds_from_components(r_b, components)\n+                            }\n+                        }\n+                    }\n+                }\n+            }));\n+        }\n+\n+        // Ensure that those obligations that we had to solve\n+        // get solved *here*.\n+        match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => (),\n+            Err(errors) => self.report_fulfillment_errors(&errors, None),\n+        }\n+\n+        implied_bounds\n+    }\n+\n+    /// When we have an implied bound that `T: 'a`, we can further break\n+    /// this down to determine what relationships would have to hold for\n+    /// `T: 'a` to hold. We get to assume that the caller has validated\n+    /// those relationships.\n+    fn implied_bounds_from_components(\n+        sub_region: ty::Region<'tcx>,\n+        sup_components: Vec<Component<'tcx>>,\n+    ) -> Vec<ImpliedBound<'tcx>> {\n+        sup_components\n+            .into_iter()\n+            .flat_map(|component| {\n+                match component {\n+                    Component::Region(r) =>\n+                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n+                    Component::Param(p) =>\n+                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n+                    Component::Projection(p) =>\n+                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n+                    Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                        vec![],\n+                    Component::UnresolvedInferenceVariable(..) =>\n+                        vec![],\n+                }\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "30d6799266e1c25985fda9a0b0863bfc54c81685", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa51603870de8d22122a20c0c3f3b0569753e8f9/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa51603870de8d22122a20c0c3f3b0569753e8f9/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=aa51603870de8d22122a20c0c3f3b0569753e8f9", "patch": "@@ -8,5 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Various code related to computing outlives relations.\n+\n pub mod env;\n+pub mod implied_bounds;\n mod obligations;"}]}