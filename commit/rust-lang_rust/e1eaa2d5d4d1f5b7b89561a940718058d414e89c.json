{"sha": "e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "node_id": "C_kwDOAAsO6NoAKGUxZWFhMmQ1ZDRkMWY1YjdiODk1NjFhOTQwNzE4MDU4ZDQxNGU4OWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-06T20:20:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-06T20:20:53Z"}, "message": "Auto merge of #107738 - matthiaskrgr:rollup-o18lzi8, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #106477 (Refine error spans for \"The trait bound `T: Trait` is not satisfied\" when passing literal structs/tuples)\n - #107596 (Add nicer output to PGO build timer)\n - #107692 (Sort Generator `print-type-sizes` according to their yield points)\n - #107714 (Clarify wording on f64::round() and f32::round())\n - #107720 (end entry paragraph with a period (.))\n - #107724 (remove unused rustc_* imports)\n - #107725 (Turn MarkdownWithToc into a struct with named fields)\n - #107731 (interpret: move discriminant reading and writing to separate file)\n - #107735 (Add mailmap for commits made by xes@meta.com)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1987fc60ff88039718ef203de7a201bc469fb077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1987fc60ff88039718ef203de7a201bc469fb077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "html_url": "https://github.com/rust-lang/rust/commit/e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ff69b49dfcc0f7d37ee17e36f67c57168c44073", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ff69b49dfcc0f7d37ee17e36f67c57168c44073", "html_url": "https://github.com/rust-lang/rust/commit/7ff69b49dfcc0f7d37ee17e36f67c57168c44073"}, {"sha": "5e958293e3d2bf3ee0b7e9101ea33c385ab704bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e958293e3d2bf3ee0b7e9101ea33c385ab704bc", "html_url": "https://github.com/rust-lang/rust/commit/5e958293e3d2bf3ee0b7e9101ea33c385ab704bc"}], "stats": {"total": 1961, "additions": 1536, "deletions": 425}, "files": [{"sha": "b814767786f2af8b235793fc32708fcda2459a55", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -166,6 +166,7 @@ Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n Eduardo Broto <ebroto@tutanota.com>\n+Edward Shen <code@eddie.sh> <xes@meta.com>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>"}, {"sha": "b2948fb38959e8df8c256f68ade4377609037f7f", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -3689,7 +3689,6 @@ dependencies = [\n name = \"rustc_ast_lowering\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n@@ -3698,7 +3697,6 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n- \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3731,7 +3729,6 @@ name = \"rustc_ast_pretty\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n- \"rustc_parse_format\",\n  \"rustc_span\",\n ]\n \n@@ -3838,7 +3835,6 @@ dependencies = [\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_query_system\",\n- \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n@@ -3864,7 +3860,6 @@ dependencies = [\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n- \"rustc_const_eval\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n@@ -3905,7 +3900,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_mir_dataflow\",\n- \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4100,15 +4094,12 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n- \"rustc_graphviz\",\n  \"rustc_hir\",\n- \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n- \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4195,7 +4186,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n- \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n@@ -4238,7 +4228,6 @@ dependencies = [\n  \"rustc_privacy\",\n  \"rustc_query_impl\",\n  \"rustc_resolve\",\n- \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n@@ -4404,7 +4393,6 @@ dependencies = [\n  \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n- \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n@@ -4436,7 +4424,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n- \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n@@ -4567,7 +4554,6 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"rustc_trait_selection\",\n  \"tracing\",\n ]\n \n@@ -4588,7 +4574,6 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"rustc_target\",\n  \"thin-vec\",\n  \"tracing\",\n ]\n@@ -4789,7 +4774,6 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n- \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_parse_format\",\n@@ -4811,7 +4795,6 @@ dependencies = [\n  \"chalk-ir\",\n  \"chalk-solve\",\n  \"rustc_ast\",\n- \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_index\","}, {"sha": "6e76c349a4a048bd2c4d8fb07b95db8774ec244f", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -7,7 +7,6 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n-rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n@@ -16,7 +15,6 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "d1513c114fef4a960558120c63d9c08188723e29", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -7,5 +7,4 @@ edition = \"2021\"\n \n [dependencies]\n rustc_ast = { path = \"../rustc_ast\" }\n-rustc_parse_format = { path = \"../rustc_parse_format\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "773c0ebbe59db8ce86121f8fd678368c0c1f8f9a", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -30,7 +30,6 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "c55991e00d3ae864e0cab69dbc54b9b125a8910a", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -41,7 +41,6 @@ rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_const_eval = { path = \"../rustc_const_eval\" }\n \n [dependencies.object]\n version = \"0.30.1\""}, {"sha": "98ac36c1ced73bf5d12e7565f54bdec939d96c62", "filename": "compiler/rustc_const_eval/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -19,7 +19,6 @@ rustc_infer = { path = \"../rustc_infer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_mir_dataflow = { path = \"../rustc_mir_dataflow\" }\n-rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "557e721249d7f0c653fdabce5aa2fd4e4d6b0580", "filename": "compiler/rustc_const_eval/src/interpret/discriminant.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -0,0 +1,238 @@\n+//! Functions for reading and writing discriminants of multi-variant layouts (enums and generators).\n+\n+use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt};\n+use rustc_middle::{mir, ty};\n+use rustc_target::abi::{self, TagEncoding};\n+use rustc_target::abi::{VariantIdx, Variants};\n+\n+use super::{ImmTy, InterpCx, InterpResult, Machine, OpTy, PlaceTy, Scalar};\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    /// Writes the discriminant of the given variant.\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn write_discriminant(\n+        &mut self,\n+        variant_index: VariantIdx,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        // Layout computation excludes uninhabited variants from consideration\n+        // therefore there's no way to represent those variants in the given layout.\n+        // Essentially, uninhabited variants do not have a tag that corresponds to their\n+        // discriminant, so we cannot do anything here.\n+        // When evaluating we will always error before even getting here, but ConstProp 'executes'\n+        // dead code, so we cannot ICE here.\n+        if dest.layout.for_variant(self, variant_index).abi.is_uninhabited() {\n+            throw_ub!(UninhabitedEnumVariantWritten)\n+        }\n+\n+        match dest.layout.variants {\n+            abi::Variants::Single { index } => {\n+                assert_eq!(index, variant_index);\n+            }\n+            abi::Variants::Multiple {\n+                tag_encoding: TagEncoding::Direct,\n+                tag: tag_layout,\n+                tag_field,\n+                ..\n+            } => {\n+                // No need to validate that the discriminant here because the\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n+\n+                let discr_val =\n+                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n+\n+                // raw discriminants for enums are isize or bigger during\n+                // their computation, but the in-memory tag is the smallest possible\n+                // representation\n+                let size = tag_layout.size(self);\n+                let tag_val = size.truncate(discr_val);\n+\n+                let tag_dest = self.place_field(dest, tag_field)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n+            }\n+            abi::Variants::Multiple {\n+                tag_encoding:\n+                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n+                tag: tag_layout,\n+                tag_field,\n+                ..\n+            } => {\n+                // No need to validate that the discriminant here because the\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n+\n+                if variant_index != untagged_variant {\n+                    let variants_start = niche_variants.start().as_u32();\n+                    let variant_index_relative = variant_index\n+                        .as_u32()\n+                        .checked_sub(variants_start)\n+                        .expect(\"overflow computing relative variant idx\");\n+                    // We need to use machine arithmetic when taking into account `niche_start`:\n+                    // tag_val = variant_index_relative + niche_start_val\n+                    let tag_layout = self.layout_of(tag_layout.primitive().to_int_ty(*self.tcx))?;\n+                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n+                    let variant_index_relative_val =\n+                        ImmTy::from_uint(variant_index_relative, tag_layout);\n+                    let tag_val = self.binary_op(\n+                        mir::BinOp::Add,\n+                        &variant_index_relative_val,\n+                        &niche_start_val,\n+                    )?;\n+                    // Write result.\n+                    let niche_dest = self.place_field(dest, tag_field)?;\n+                    self.write_immediate(*tag_val, &niche_dest)?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Read discriminant, return the runtime value as well as the variant index.\n+    /// Can also legally be called on non-enums (e.g. through the discriminant_value intrinsic)!\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn read_discriminant(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, VariantIdx)> {\n+        trace!(\"read_discriminant_value {:#?}\", op.layout);\n+        // Get type and layout of the discriminant.\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n+        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n+\n+        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n+        // This is not to be confused with its \"variant index\", which is just determining its position in the\n+        // declared list of variants -- they can differ with explicitly assigned discriminants.\n+        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n+        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n+        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n+            Variants::Single { index } => {\n+                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                    Some(discr) => {\n+                        // This type actually has discriminants.\n+                        assert_eq!(discr.ty, discr_layout.ty);\n+                        Scalar::from_uint(discr.val, discr_layout.size)\n+                    }\n+                    None => {\n+                        // On a type without actual discriminants, variant is 0.\n+                        assert_eq!(index.as_u32(), 0);\n+                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n+                    }\n+                };\n+                return Ok((discr, index));\n+            }\n+            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n+            }\n+        };\n+\n+        // There are *three* layouts that come into play here:\n+        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n+        //   the `Scalar` we return.\n+        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n+        //   and used to interpret the value we read from the tag field.\n+        //   For the return value, a cast to `discr_layout` is performed.\n+        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n+        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n+\n+        // Get layout for tag.\n+        let tag_layout = self.layout_of(tag_scalar_layout.primitive().to_int_ty(*self.tcx))?;\n+\n+        // Read tag and sanity-check `tag_layout`.\n+        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n+        assert_eq!(tag_layout.size, tag_val.layout.size);\n+        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n+        trace!(\"tag value: {}\", tag_val);\n+\n+        // Figure out which discriminant and variant this corresponds to.\n+        Ok(match *tag_encoding {\n+            TagEncoding::Direct => {\n+                let scalar = tag_val.to_scalar();\n+                // Generate a specific error if `tag_val` is not an integer.\n+                // (`tag_bits` itself is only used for error messages below.)\n+                let tag_bits = scalar\n+                    .try_to_int()\n+                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n+                    .assert_bits(tag_layout.size);\n+                // Cast bits from tag layout to discriminant layout.\n+                // After the checks we did above, this cannot fail, as\n+                // discriminants are int-like.\n+                let discr_val =\n+                    self.cast_from_int_like(scalar, tag_val.layout, discr_layout.ty).unwrap();\n+                let discr_bits = discr_val.assert_bits(discr_layout.size);\n+                // Convert discriminant to variant index, and catch invalid discriminants.\n+                let index = match *op.layout.ty.kind() {\n+                    ty::Adt(adt, _) => {\n+                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n+                    }\n+                    ty::Generator(def_id, substs, _) => {\n+                        let substs = substs.as_generator();\n+                        substs\n+                            .discriminants(def_id, *self.tcx)\n+                            .find(|(_, var)| var.val == discr_bits)\n+                    }\n+                    _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n+                }\n+                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n+                // Return the cast value, and the index.\n+                (discr_val, index.0)\n+            }\n+            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n+                let tag_val = tag_val.to_scalar();\n+                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n+                // discriminant (encoded in niche/tag) and variant index are the same.\n+                let variants_start = niche_variants.start().as_u32();\n+                let variants_end = niche_variants.end().as_u32();\n+                let variant = match tag_val.try_to_int() {\n+                    Err(dbg_val) => {\n+                        // So this is a pointer then, and casting to an int failed.\n+                        // Can only happen during CTFE.\n+                        // The niche must be just 0, and the ptr not null, then we know this is\n+                        // okay. Everything else, we conservatively reject.\n+                        let ptr_valid = niche_start == 0\n+                            && variants_start == variants_end\n+                            && !self.scalar_may_be_null(tag_val)?;\n+                        if !ptr_valid {\n+                            throw_ub!(InvalidTag(dbg_val))\n+                        }\n+                        untagged_variant\n+                    }\n+                    Ok(tag_bits) => {\n+                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n+                        // We need to use machine arithmetic to get the relative variant idx:\n+                        // variant_index_relative = tag_val - niche_start_val\n+                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n+                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n+                        let variant_index_relative_val =\n+                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n+                        let variant_index_relative =\n+                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n+                        // Check if this is in the range that indicates an actual discriminant.\n+                        if variant_index_relative <= u128::from(variants_end - variants_start) {\n+                            let variant_index_relative = u32::try_from(variant_index_relative)\n+                                .expect(\"we checked that this fits into a u32\");\n+                            // Then computing the absolute variant idx should not overflow any more.\n+                            let variant_index = variants_start\n+                                .checked_add(variant_index_relative)\n+                                .expect(\"overflow computing absolute variant idx\");\n+                            let variants_len = op\n+                                .layout\n+                                .ty\n+                                .ty_adt_def()\n+                                .expect(\"tagged layout for non adt\")\n+                                .variants()\n+                                .len();\n+                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n+                            VariantIdx::from_u32(variant_index)\n+                        } else {\n+                            untagged_variant\n+                        }\n+                    }\n+                };\n+                // Compute the size of the scalar we need to return.\n+                // No need to cast, because the variant index directly serves as discriminant and is\n+                // encoded in the tag.\n+                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n+            }\n+        })\n+    }\n+}"}, {"sha": "86de4e4e32c2a5961c1871f420a9c92859ef7d04", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1,6 +1,7 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n mod cast;\n+mod discriminant;\n mod eval_context;\n mod intern;\n mod intrinsics;"}, {"sha": "52613d5ca1f9b43c2ed532f398a368da5fabc6ea", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 151, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -4,13 +4,12 @@\n use either::{Either, Left, Right};\n \n use rustc_hir::def::Namespace;\n-use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n use rustc_middle::ty::{ConstInt, Ty, ValTree};\n use rustc_middle::{mir, ty};\n use rustc_span::Span;\n-use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n-use rustc_target::abi::{VariantIdx, Variants};\n+use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size};\n \n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n@@ -657,154 +656,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n-\n-    /// Read discriminant, return the runtime value as well as the variant index.\n-    /// Can also legally be called on non-enums (e.g. through the discriminant_value intrinsic)!\n-    pub fn read_discriminant(\n-        &self,\n-        op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, VariantIdx)> {\n-        trace!(\"read_discriminant_value {:#?}\", op.layout);\n-        // Get type and layout of the discriminant.\n-        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n-        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n-\n-        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n-        // This is not to be confused with its \"variant index\", which is just determining its position in the\n-        // declared list of variants -- they can differ with explicitly assigned discriminants.\n-        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n-        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n-        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n-            Variants::Single { index } => {\n-                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n-                    Some(discr) => {\n-                        // This type actually has discriminants.\n-                        assert_eq!(discr.ty, discr_layout.ty);\n-                        Scalar::from_uint(discr.val, discr_layout.size)\n-                    }\n-                    None => {\n-                        // On a type without actual discriminants, variant is 0.\n-                        assert_eq!(index.as_u32(), 0);\n-                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n-                    }\n-                };\n-                return Ok((discr, index));\n-            }\n-            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n-                (tag, tag_encoding, tag_field)\n-            }\n-        };\n-\n-        // There are *three* layouts that come into play here:\n-        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n-        //   the `Scalar` we return.\n-        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n-        //   and used to interpret the value we read from the tag field.\n-        //   For the return value, a cast to `discr_layout` is performed.\n-        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n-        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n-\n-        // Get layout for tag.\n-        let tag_layout = self.layout_of(tag_scalar_layout.primitive().to_int_ty(*self.tcx))?;\n-\n-        // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n-        assert_eq!(tag_layout.size, tag_val.layout.size);\n-        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n-        trace!(\"tag value: {}\", tag_val);\n-\n-        // Figure out which discriminant and variant this corresponds to.\n-        Ok(match *tag_encoding {\n-            TagEncoding::Direct => {\n-                let scalar = tag_val.to_scalar();\n-                // Generate a specific error if `tag_val` is not an integer.\n-                // (`tag_bits` itself is only used for error messages below.)\n-                let tag_bits = scalar\n-                    .try_to_int()\n-                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n-                    .assert_bits(tag_layout.size);\n-                // Cast bits from tag layout to discriminant layout.\n-                // After the checks we did above, this cannot fail, as\n-                // discriminants are int-like.\n-                let discr_val =\n-                    self.cast_from_int_like(scalar, tag_val.layout, discr_layout.ty).unwrap();\n-                let discr_bits = discr_val.assert_bits(discr_layout.size);\n-                // Convert discriminant to variant index, and catch invalid discriminants.\n-                let index = match *op.layout.ty.kind() {\n-                    ty::Adt(adt, _) => {\n-                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n-                    }\n-                    ty::Generator(def_id, substs, _) => {\n-                        let substs = substs.as_generator();\n-                        substs\n-                            .discriminants(def_id, *self.tcx)\n-                            .find(|(_, var)| var.val == discr_bits)\n-                    }\n-                    _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n-                }\n-                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n-                // Return the cast value, and the index.\n-                (discr_val, index.0)\n-            }\n-            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-                let tag_val = tag_val.to_scalar();\n-                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n-                // discriminant (encoded in niche/tag) and variant index are the same.\n-                let variants_start = niche_variants.start().as_u32();\n-                let variants_end = niche_variants.end().as_u32();\n-                let variant = match tag_val.try_to_int() {\n-                    Err(dbg_val) => {\n-                        // So this is a pointer then, and casting to an int failed.\n-                        // Can only happen during CTFE.\n-                        // The niche must be just 0, and the ptr not null, then we know this is\n-                        // okay. Everything else, we conservatively reject.\n-                        let ptr_valid = niche_start == 0\n-                            && variants_start == variants_end\n-                            && !self.scalar_may_be_null(tag_val)?;\n-                        if !ptr_valid {\n-                            throw_ub!(InvalidTag(dbg_val))\n-                        }\n-                        untagged_variant\n-                    }\n-                    Ok(tag_bits) => {\n-                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n-                        // We need to use machine arithmetic to get the relative variant idx:\n-                        // variant_index_relative = tag_val - niche_start_val\n-                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n-                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n-                        let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n-                        let variant_index_relative =\n-                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n-                        // Check if this is in the range that indicates an actual discriminant.\n-                        if variant_index_relative <= u128::from(variants_end - variants_start) {\n-                            let variant_index_relative = u32::try_from(variant_index_relative)\n-                                .expect(\"we checked that this fits into a u32\");\n-                            // Then computing the absolute variant idx should not overflow any more.\n-                            let variant_index = variants_start\n-                                .checked_add(variant_index_relative)\n-                                .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = op\n-                                .layout\n-                                .ty\n-                                .ty_adt_def()\n-                                .expect(\"tagged layout for non adt\")\n-                                .variants()\n-                                .len();\n-                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            VariantIdx::from_u32(variant_index)\n-                        } else {\n-                            untagged_variant\n-                        }\n-                    }\n-                };\n-                // Compute the size of the scalar we need to return.\n-                // No need to cast, because the variant index directly serves as discriminant and is\n-                // encoded in the tag.\n-                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n-            }\n-        })\n-    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "f82a41078d153a4485c9585ef1b85257568e3c63", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 83, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -7,8 +7,8 @@ use either::{Either, Left, Right};\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n-use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n-use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding, VariantIdx};\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n+use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, VariantIdx};\n \n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n@@ -767,87 +767,8 @@ where\n         MPlaceTy { mplace, layout, align: layout.align.abi }\n     }\n \n-    /// Writes the discriminant of the given variant.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn write_discriminant(\n-        &mut self,\n-        variant_index: VariantIdx,\n-        dest: &PlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx> {\n-        // Layout computation excludes uninhabited variants from consideration\n-        // therefore there's no way to represent those variants in the given layout.\n-        // Essentially, uninhabited variants do not have a tag that corresponds to their\n-        // discriminant, so we cannot do anything here.\n-        // When evaluating we will always error before even getting here, but ConstProp 'executes'\n-        // dead code, so we cannot ICE here.\n-        if dest.layout.for_variant(self, variant_index).abi.is_uninhabited() {\n-            throw_ub!(UninhabitedEnumVariantWritten)\n-        }\n-\n-        match dest.layout.variants {\n-            abi::Variants::Single { index } => {\n-                assert_eq!(index, variant_index);\n-            }\n-            abi::Variants::Multiple {\n-                tag_encoding: TagEncoding::Direct,\n-                tag: tag_layout,\n-                tag_field,\n-                ..\n-            } => {\n-                // No need to validate that the discriminant here because the\n-                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n-\n-                let discr_val =\n-                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n-\n-                // raw discriminants for enums are isize or bigger during\n-                // their computation, but the in-memory tag is the smallest possible\n-                // representation\n-                let size = tag_layout.size(self);\n-                let tag_val = size.truncate(discr_val);\n-\n-                let tag_dest = self.place_field(dest, tag_field)?;\n-                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n-            }\n-            abi::Variants::Multiple {\n-                tag_encoding:\n-                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n-                tag: tag_layout,\n-                tag_field,\n-                ..\n-            } => {\n-                // No need to validate that the discriminant here because the\n-                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n-\n-                if variant_index != untagged_variant {\n-                    let variants_start = niche_variants.start().as_u32();\n-                    let variant_index_relative = variant_index\n-                        .as_u32()\n-                        .checked_sub(variants_start)\n-                        .expect(\"overflow computing relative variant idx\");\n-                    // We need to use machine arithmetic when taking into account `niche_start`:\n-                    // tag_val = variant_index_relative + niche_start_val\n-                    let tag_layout = self.layout_of(tag_layout.primitive().to_int_ty(*self.tcx))?;\n-                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n-                    let variant_index_relative_val =\n-                        ImmTy::from_uint(variant_index_relative, tag_layout);\n-                    let tag_val = self.binary_op(\n-                        mir::BinOp::Add,\n-                        &variant_index_relative_val,\n-                        &niche_start_val,\n-                    )?;\n-                    // Write result.\n-                    let niche_dest = self.place_field(dest, tag_field)?;\n-                    self.write_immediate(*tag_val, &niche_dest)?;\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Writes the discriminant of the given variant.\n-    #[instrument(skip(self), level = \"debug\")]\n+    /// Writes the aggregate to the destination.\n+    #[instrument(skip(self), level = \"trace\")]\n     pub fn write_aggregate(\n         &mut self,\n         kind: &mir::AggregateKind<'tcx>,"}, {"sha": "c939c8303bf200e4d7a2b7c981356d943ba9c8cf", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -15,9 +15,7 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n-rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n-rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n@@ -27,6 +25,5 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_lint = { path = \"../rustc_lint\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_feature = { path = \"../rustc_feature\" }"}, {"sha": "2eab68050d43043d6395205cbb863cb908445677", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -0,0 +1,457 @@\n+use crate::FnCtxt;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_trait_selection::traits;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /**\n+     * Recursively searches for the most-specific blamable expression.\n+     * For example, if you have a chain of constraints like:\n+     * - want `Vec<i32>: Copy`\n+     * - because `Option<Vec<i32>>: Copy` needs `Vec<i32>: Copy` because `impl <T: Copy> Copy for Option<T>`\n+     * - because `(Option<Vec<i32>, bool)` needs `Option<Vec<i32>>: Copy` because `impl <A: Copy, B: Copy> Copy for (A, B)`\n+     * then if you pass in `(Some(vec![1, 2, 3]), false)`, this helper `point_at_specific_expr_if_possible`\n+     * will find the expression `vec![1, 2, 3]` as the \"most blameable\" reason for this missing constraint.\n+     *\n+     * This function only updates the error span.\n+     */\n+    pub fn blame_specific_expr_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) {\n+        // Whether it succeeded or failed, it likely made some amount of progress.\n+        // In the very worst case, it's just the same `expr` we originally passed in.\n+        let expr = match self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &error.obligation.cause.code(),\n+            expr,\n+        ) {\n+            Ok(expr) => expr,\n+            Err(expr) => expr,\n+        };\n+\n+        // Either way, use this expression to update the error span.\n+        // If it doesn't overlap the existing span at all, use the original span.\n+        // FIXME: It would possibly be better to do this more continuously, at each level...\n+        error.obligation.cause.span = expr\n+            .span\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(error.obligation.cause.span);\n+    }\n+\n+    fn blame_specific_expr_if_possible_for_obligation_cause_code(\n+        &self,\n+        obligation_cause_code: &traits::ObligationCauseCode<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        match obligation_cause_code {\n+            traits::ObligationCauseCode::ExprBindingObligation(_, _, _, _) => {\n+                // This is the \"root\"; we assume that the `expr` is already pointing here.\n+                // Therefore, we return `Ok` so that this `expr` can be refined further.\n+                Ok(expr)\n+            }\n+            traits::ObligationCauseCode::ImplDerivedObligation(impl_derived) => self\n+                .blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+                    impl_derived,\n+                    expr,\n+                ),\n+            _ => {\n+                // We don't recognize this kind of constraint, so we cannot refine the expression\n+                // any further.\n+                Err(expr)\n+            }\n+        }\n+    }\n+\n+    /// We want to achieve the error span in the following example:\n+    ///\n+    /// ```ignore (just for demonstration)\n+    /// struct Burrito<Filling> {\n+    ///   filling: Filling,\n+    /// }\n+    /// impl <Filling: Delicious> Delicious for Burrito<Filling> {}\n+    /// fn eat_delicious_food<Food: Delicious>(_food: Food) {}\n+    ///\n+    /// fn will_type_error() {\n+    ///   eat_delicious_food(Burrito { filling: Kale });\n+    /// } //                                    ^--- The trait bound `Kale: Delicious`\n+    ///   //                                         is not satisfied\n+    /// ```\n+    ///\n+    /// Without calling this function, the error span will cover the entire argument expression.\n+    ///\n+    /// Before we do any of this logic, we recursively call `point_at_specific_expr_if_possible` on the parent\n+    /// obligation. Hence we refine the `expr` \"outwards-in\" and bail at the first kind of expression/impl we don't recognize.\n+    ///\n+    /// This function returns a `Result<&Expr, &Expr>` - either way, it returns the `Expr` whose span should be\n+    /// reported as an error. If it is `Ok`, then it means it refined successfull. If it is `Err`, then it may be\n+    /// only a partial success - but it cannot be refined even further.\n+    fn blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+        &self,\n+        obligation: &traits::ImplDerivedObligationCause<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        // First, we attempt to refine the `expr` for our span using the parent obligation.\n+        // If this cannot be done, then we are already stuck, so we stop early (hence the use\n+        // of the `?` try operator here).\n+        let expr = self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &*obligation.derived.parent_code,\n+            expr,\n+        )?;\n+\n+        // This is the \"trait\" (meaning, the predicate \"proved\" by this `impl`) which provides the `Self` type we care about.\n+        // For the purposes of this function, we hope that it is a `struct` type, and that our current `expr` is a literal of\n+        // that struct type.\n+        let impl_trait_self_ref: Option<ty::TraitRef<'tcx>> =\n+            self.tcx.impl_trait_ref(obligation.impl_def_id).map(|impl_def| impl_def.skip_binder());\n+\n+        let Some(impl_trait_self_ref) = impl_trait_self_ref else {\n+            // It is possible that this is absent. In this case, we make no progress.\n+            return Err(expr);\n+        };\n+\n+        // We only really care about the `Self` type itself, which we extract from the ref.\n+        let impl_self_ty: Ty<'tcx> = impl_trait_self_ref.self_ty();\n+\n+        let impl_predicates: ty::GenericPredicates<'tcx> =\n+            self.tcx.predicates_of(obligation.impl_def_id);\n+        let Some(impl_predicate_index) = obligation.impl_def_predicate_index else {\n+            // We don't have the index, so we can only guess.\n+            return Err(expr);\n+        };\n+\n+        if impl_predicate_index >= impl_predicates.predicates.len() {\n+            // This shouldn't happen, but since this is only a diagnostic improvement, avoid breaking things.\n+            return Err(expr);\n+        }\n+        let relevant_broken_predicate: ty::PredicateKind<'tcx> =\n+            impl_predicates.predicates[impl_predicate_index].0.kind().skip_binder();\n+\n+        match relevant_broken_predicate {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(broken_trait)) => {\n+                // ...\n+                self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                    broken_trait.trait_ref.self_ty().into(),\n+                    expr,\n+                    impl_self_ty.into(),\n+                )\n+            }\n+            _ => Err(expr),\n+        }\n+    }\n+\n+    /// Drills into `expr` to arrive at the equivalent location of `find_generic_param` in `in_ty`.\n+    /// For example, given\n+    /// - expr: `(Some(vec![1, 2, 3]), false)`\n+    /// - param: `T`\n+    /// - in_ty: `(Option<Vec<T>, bool)`\n+    /// we would drill until we arrive at `vec![1, 2, 3]`.\n+    ///\n+    /// If successful, we return `Ok(refined_expr)`. If unsuccesful, we return `Err(partially_refined_expr`),\n+    /// which will go as far as possible. For example, given `(foo(), false)` instead, we would drill to\n+    /// `foo()` and then return `Err(\"foo()\")`.\n+    ///\n+    /// This means that you can (and should) use the `?` try operator to chain multiple calls to this\n+    /// function with different types, since you can only continue drilling the second time if you\n+    /// succeeded the first time.\n+    fn blame_specific_part_of_expr_corresponding_to_generic_param(\n+        &self,\n+        param: ty::GenericArg<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        in_ty: ty::GenericArg<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        if param == in_ty {\n+            // The types match exactly, so we have drilled as far as we can.\n+            return Ok(expr);\n+        }\n+\n+        let ty::GenericArgKind::Type(in_ty) = in_ty.unpack() else {\n+            return Err(expr);\n+        };\n+\n+        if let (hir::ExprKind::Tup(expr_elements), ty::Tuple(in_ty_elements)) =\n+            (&expr.kind, in_ty.kind())\n+        {\n+            if in_ty_elements.len() != expr_elements.len() {\n+                return Err(expr);\n+            }\n+            // Find out which of `in_ty_elements` refer to `param`.\n+            // FIXME: It may be better to take the first if there are multiple,\n+            // just so that the error points to a smaller expression.\n+            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            })) else {\n+                // The param is not mentioned, or it is mentioned in multiple indexes.\n+                return Err(expr);\n+            };\n+\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                drill_expr,\n+                drill_ty.into(),\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Struct(expr_struct_path, expr_struct_fields, _expr_struct_rest),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            // First, confirm that this struct is the same one as in the types, and if so,\n+            // find the right variant.\n+            let Res::Def(expr_struct_def_kind, expr_struct_def_id) = self.typeck_results.borrow().qpath_res(expr_struct_path, expr.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Struct => {\n+                    if in_ty_adt.did() != expr_struct_def_id {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                hir::def::DefKind::Variant => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_struct_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field which mentions the type in our constraint:\n+            let (field_expr, field_type) = self\n+                .point_at_field_if_possible(\n+                    in_ty_adt.did(),\n+                    param_to_point_at_in_struct,\n+                    variant_def_id,\n+                    expr_struct_fields,\n+                )\n+                .ok_or(expr)?;\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                field_expr,\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Call(expr_callee, expr_args),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            let hir::ExprKind::Path(expr_callee_path) = &expr_callee.kind else {\n+                // FIXME: This case overlaps with another one worth handling,\n+                // which should happen above since it applies to non-ADTs:\n+                // we can drill down into regular generic functions.\n+                return Err(expr);\n+            };\n+            // This is (possibly) a constructor call, like `Some(...)` or `MyStruct(a, b, c)`.\n+\n+            let Res::Def(expr_struct_def_kind, expr_ctor_def_id) = self.typeck_results.borrow().qpath_res(expr_callee_path, expr_callee.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, hir::def::CtorKind::Fn) => {\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    self.tcx.parent(expr_ctor_def_id)\n+                }\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, hir::def::CtorKind::Fn) => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_ctor_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field index which mentions the type in our constraint:\n+            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+                in_ty_adt\n+                    .variant_with_id(variant_def_id)\n+                    .fields\n+                    .iter()\n+                    .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n+                    .enumerate()\n+                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+            ) else {\n+                return Err(expr);\n+            };\n+\n+            if field_index >= expr_args.len() {\n+                return Err(expr);\n+            }\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                &expr_args[field_index],\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        // At this point, none of the basic patterns matched.\n+        // One major possibility which remains is that we have a function call.\n+        // In this case, it's often possible to dive deeper into the call to find something to blame,\n+        // but this is not always possible.\n+\n+        Err(expr)\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+    pub fn find_param_in_ty(\n+        ty: ty::GenericArg<'tcx>,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+    ) -> bool {\n+        let mut walk = ty.walk();\n+        while let Some(arg) = walk.next() {\n+            if arg == param_to_point_at {\n+            return true;\n+        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+            && let ty::Alias(ty::Projection, ..) = ty.kind()\n+        {\n+            // This logic may seem a bit strange, but typically when\n+            // we have a projection type in a function signature, the\n+            // argument that's being passed into that signature is\n+            // not actually constraining that projection's substs in\n+            // a meaningful way. So we skip it, and see improvements\n+            // in some UI tests.\n+            walk.skip_current_subtree();\n+        }\n+        }\n+        false\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+        match (iterator.next(), iterator.next()) {\n+            (_, Some(_)) => None,\n+            (first, _) => first,\n+        }\n+    }\n+}"}, {"sha": "1055ee953eae6f554036ddd90007e0813e7f312a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -34,9 +34,10 @@ use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext}\n \n use std::iter;\n use std::mem;\n-use std::ops::ControlFlow;\n use std::slice;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n         // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n@@ -1843,7 +1844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .into_iter()\n                         .flatten()\n                     {\n-                        if self.point_at_arg_if_possible(\n+                        if self.blame_specific_arg_if_possible(\n                                 error,\n                                 def_id,\n                                 param,\n@@ -1873,7 +1874,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .into_iter()\n                     .flatten()\n                 {\n-                    if self.point_at_arg_if_possible(\n+                    if self.blame_specific_arg_if_possible(\n                         error,\n                         def_id,\n                         param,\n@@ -1898,16 +1899,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     for param in\n                         [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                     {\n-                        if let Some(param) = param\n-                            && self.point_at_field_if_possible(\n-                                error,\n+                        if let Some(param) = param {\n+                            let refined_expr = self.point_at_field_if_possible(\n                                 def_id,\n                                 param,\n                                 variant_def_id,\n                                 fields,\n-                            )\n-                        {\n-                            return true;\n+                            );\n+\n+                            match refined_expr {\n+                                None => {}\n+                                Some((refined_expr, _)) => {\n+                                    error.obligation.cause.span = refined_expr\n+                                        .span\n+                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                        .unwrap_or(refined_expr.span);\n+                                    return true;\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -1940,7 +1949,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn point_at_arg_if_possible(\n+    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n+    /// looking for the most-specific-possible span to blame.\n+    ///\n+    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n+    /// expression mentioned.\n+    ///\n+    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n+    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// error.\n+    fn blame_specific_arg_if_possible(\n         &self,\n         error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n@@ -1959,13 +1977,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| find_param_in_ty(**ty, param_to_point_at))\n+            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n             && let Some(arg) = receiver\n                 .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n+\n             error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n+\n+            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n+                // This is more specific than pointing at the entire argument.\n+                self.blame_specific_expr_if_possible(error, arg_expr)\n+            }\n+\n             error.obligation.cause.map_code(|parent_code| {\n                 ObligationCauseCode::FunctionArgumentObligation {\n                     arg_hir_id: arg.hir_id,\n@@ -1983,14 +2008,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn point_at_field_if_possible(\n+    // FIXME: Make this private and move to mod adjust_fulfillment_errors\n+    pub fn point_at_field_if_possible(\n         &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n         param_to_point_at: ty::GenericArg<'tcx>,\n         variant_def_id: DefId,\n         expr_fields: &[hir::ExprField<'tcx>],\n-    ) -> bool {\n+    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n         let def = self.tcx.adt_def(def_id);\n \n         let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n@@ -2000,7 +2025,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                find_param_in_ty(field_ty, param_to_point_at)\n+                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -2010,17 +2035,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // same rules that check_expr_struct uses for macro hygiene.\n                 if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n                 {\n-                    error.obligation.cause.span = expr_field\n-                        .expr\n-                        .span\n-                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                        .unwrap_or(expr_field.span);\n-                    return true;\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n                 }\n             }\n         }\n \n-        false\n+        None\n     }\n \n     fn point_at_path_if_possible(\n@@ -2240,23 +2260,3 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n-\n-fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>) -> bool {\n-    let mut walk = ty.walk();\n-    while let Some(arg) = walk.next() {\n-        if arg == param_to_point_at {\n-            return true;\n-        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Alias(ty::Projection, ..) = ty.kind()\n-        {\n-            // This logic may seem a bit strange, but typically when\n-            // we have a projection type in a function signature, the\n-            // argument that's being passed into that signature is\n-            // not actually constraining that projection's substs in\n-            // a meaningful way. So we skip it, and see improvements\n-            // in some UI tests.\n-            walk.skip_current_subtree();\n-        }\n-    }\n-    false\n-}"}, {"sha": "1e14eddd4c86ef511732e116a9dfeafe69b2ba8e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1,4 +1,5 @@\n mod _impl;\n+mod adjust_fulfillment_errors;\n mod arg_matrix;\n mod checks;\n mod suggestions;"}, {"sha": "9ab29a6778fc91eceb2a99bd4ae9f9cbba5683ca", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1563,6 +1563,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n                                         impl_def_id,\n+                                        impl_def_predicate_index: None,\n                                         span,\n                                     },\n                                 ))"}, {"sha": "02ac83a5e8b25b3f32ecdbfb62d81013c34a71f3", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -15,7 +15,6 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "18a966449aa72f2e9432ab3c833d8bdc1ba22bae", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -145,30 +145,32 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|&(mut pred, span)| {\n-                    // when parent predicate is non-const, elaborate it to non-const predicates.\n-                    if data.constness == ty::BoundConstness::NotConst {\n-                        pred = pred.without_const(tcx);\n-                    }\n-\n-                    let cause = obligation.cause.clone().derived_cause(\n-                        bound_predicate.rebind(data),\n-                        |derived| {\n-                            traits::ImplDerivedObligation(Box::new(\n-                                traits::ImplDerivedObligationCause {\n-                                    derived,\n-                                    impl_def_id: data.def_id(),\n-                                    span,\n-                                },\n-                            ))\n-                        },\n-                    );\n-                    predicate_obligation(\n-                        pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n-                        obligation.param_env,\n-                        cause,\n-                    )\n-                });\n+                let obligations =\n+                    predicates.predicates.iter().enumerate().map(|(index, &(mut pred, span))| {\n+                        // when parent predicate is non-const, elaborate it to non-const predicates.\n+                        if data.constness == ty::BoundConstness::NotConst {\n+                            pred = pred.without_const(tcx);\n+                        }\n+\n+                        let cause = obligation.cause.clone().derived_cause(\n+                            bound_predicate.rebind(data),\n+                            |derived| {\n+                                traits::ImplDerivedObligation(Box::new(\n+                                    traits::ImplDerivedObligationCause {\n+                                        derived,\n+                                        impl_def_id: data.def_id(),\n+                                        impl_def_predicate_index: Some(index),\n+                                        span,\n+                                    },\n+                                ))\n+                            },\n+                        );\n+                        predicate_obligation(\n+                            pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n+                            obligation.param_env,\n+                            cause,\n+                        )\n+                    });\n                 debug!(?data, ?obligations, \"super_predicates\");\n \n                 // Only keep those bounds that we haven't already seen."}, {"sha": "955ab3c4680abded5dbdf0c1782c0a9d73a6749a", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -20,7 +20,6 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_lowering = { path = \"../rustc_ast_lowering\" }\n rustc_ast_passes = { path = \"../rustc_ast_passes\" }"}, {"sha": "c528929e7561dacb8572e7185a1d2dd3a6bacb5d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -475,6 +475,8 @@ pub enum WellFormedLoc {\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n     pub impl_def_id: DefId,\n+    /// The index of the derived predicate in the parent impl's predicates.\n+    pub impl_def_predicate_index: Option<usize>,\n     pub span: Span,\n }\n "}, {"sha": "f24b165d7c239345b13c7ac2647d89d6c20f10b7", "filename": "compiler/rustc_mir_build/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -11,7 +11,6 @@ tracing = \"0.1\"\n either = \"1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n-rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "68c61a18d72fcde55c03c9e37ed6de8a8bd5c5d3", "filename": "compiler/rustc_mir_dataflow/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_mir_dataflow%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_mir_dataflow%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -19,6 +19,5 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "744cb77dd00cd1c7b5a2a9131a626eb63d952cb8", "filename": "compiler/rustc_privacy/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -13,6 +13,5 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n tracing = \"0.1\""}, {"sha": "21732d260354d995daa6185af1f183d4f95c61ad", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -20,7 +20,6 @@ rustc-rayon-core = { version = \"0.4.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_target = { path = \"../rustc_target\" }\n thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n "}, {"sha": "55178250472ef94bc08d45ba429ea02f7f83458b", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -84,7 +84,11 @@ impl CodeStats {\n         // Sort variants so the largest ones are shown first. A stable sort is\n         // used here so that source code order is preserved for all variants\n         // that have the same size.\n-        variants.sort_by(|info1, info2| info2.size.cmp(&info1.size));\n+        // Except for Generators, whose variants are already sorted according to\n+        // their yield points in `variant_info_for_generator`.\n+        if kind != DataTypeKind::Generator {\n+            variants.sort_by(|info1, info2| info2.size.cmp(&info1.size));\n+        }\n         let info = TypeSizeInfo {\n             kind,\n             type_description: type_desc.to_string(),"}, {"sha": "3f863038efb3769f6b0968ce25ebc55331c8f2f1", "filename": "compiler/rustc_trait_selection/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -16,7 +16,6 @@ rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n-rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_serialize = { path = \"../rustc_serialize\" }"}, {"sha": "94d9eb8f587a70ebbd9383cccdab5c516cdbca04", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1190,6 +1190,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id,\n+                    impl_def_predicate_index: None,\n                     span: obligation.cause.span,\n                 }))\n             });"}, {"sha": "0c6b2406bbdafb0cd0e547a405e72cc988e9a494", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -2608,11 +2608,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.instantiate_own(tcx, substs);\n         let mut obligations = Vec::with_capacity(predicates.len());\n-        for (predicate, span) in predicates {\n+        for (index, (predicate, span)) in predicates.into_iter().enumerate() {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id: def_id,\n+                    impl_def_predicate_index: Some(index),\n                     span,\n                 }))\n             });"}, {"sha": "eff6fb26dd4c503f8091b224acc24e9f3be40597", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -5,7 +5,6 @@ edition = \"2021\"\n \n [dependencies]\n tracing = \"0.1\"\n-rustc_attr = { path = \"../rustc_attr\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_hir = { path = \"../rustc_hir\" }"}, {"sha": "2aeb255c1641c61b6329110582aa8bd8ea06808d", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -970,7 +970,7 @@ fn variant_info_for_generator<'tcx>(\n         })\n         .collect();\n \n-    let variant_infos: Vec<_> = generator\n+    let mut variant_infos: Vec<_> = generator\n         .variant_fields\n         .iter_enumerated()\n         .map(|(variant_idx, variant_def)| {\n@@ -1033,6 +1033,15 @@ fn variant_info_for_generator<'tcx>(\n             }\n         })\n         .collect();\n+\n+    // The first three variants are hardcoded to be `UNRESUMED`, `RETURNED` and `POISONED`.\n+    // We will move the `RETURNED` and `POISONED` elements to the end so we\n+    // are left with a sorting order according to the generators yield points:\n+    // First `Unresumed`, then the `SuspendN` followed by `Returned` and `Panicked` (POISONED).\n+    let end_states = variant_infos.drain(1..=2);\n+    let end_states: Vec<_> = end_states.collect();\n+    variant_infos.extend(end_states);\n+\n     (\n         variant_infos,\n         match tag_encoding {"}, {"sha": "dcc0835ecd6d2c6b22a777e96eac9ce925eff8d0", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -18,7 +18,7 @@ macro_rules! uint_impl {\n         pub const MIN: Self = 0;\n \n         /// The largest value that can be represented by this integer type\n-        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \")\")]\n+        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n         ///\n         /// # Examples\n         ///"}, {"sha": "6b1f0cba82dfc877cddfba31465fcb28af5798ad", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -69,8 +69,8 @@ impl f32 {\n         unsafe { intrinsics::ceilf32(self) }\n     }\n \n-    /// Returns the nearest integer to `self`. Round half-way cases away from\n-    /// `0.0`.\n+    /// Returns the nearest integer to `self`. If a value is half-way between two\n+    /// integers, round away from `0.0`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "16359766b510d865e6c8846fe5a6c966fa488429", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -69,8 +69,8 @@ impl f64 {\n         unsafe { intrinsics::ceilf64(self) }\n     }\n \n-    /// Returns the nearest integer to `self`. Round half-way cases away from\n-    /// `0.0`.\n+    /// Returns the nearest integer to `self`. If a value is half-way between two\n+    /// integers, round away from `0.0`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "662c9e36694c652d31f932e668054c5ec35c846f", "filename": "src/ci/stage-build.py", "status": "modified", "additions": 123, "deletions": 49, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -15,10 +15,9 @@\n import time\n import traceback\n import urllib.request\n-from collections import OrderedDict\n from io import StringIO\n from pathlib import Path\n-from typing import Callable, Dict, Iterable, List, Optional, Union\n+from typing import Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\n \n PGO_HOST = os.environ[\"PGO_HOST\"]\n \n@@ -204,48 +203,105 @@ def supports_bolt(self) -> bool:\n         return False\n \n \n+def get_timestamp() -> float:\n+    return time.time()\n+\n+\n+Duration = float\n+TimerSection = Union[Duration, \"Timer\"]\n+\n+\n+def iterate_sections(section: TimerSection, name: str, level: int = 0) -> Iterator[Tuple[int, str, Duration]]:\n+    \"\"\"\n+    Hierarchically iterate the sections of a timer, in a depth-first order.\n+    \"\"\"\n+    if isinstance(section, Duration):\n+        yield (level, name, section)\n+    elif isinstance(section, Timer):\n+        yield (level, name, section.total_duration())\n+        for (child_name, child_section) in section.sections:\n+            yield from iterate_sections(child_section, child_name, level=level + 1)\n+    else:\n+        assert False\n+\n+\n class Timer:\n-    def __init__(self):\n-        # We want this dictionary to be ordered by insertion.\n-        # We use `OrderedDict` for compatibility with older Python versions.\n-        self.stages = OrderedDict()\n+    def __init__(self, parent_names: Tuple[str, ...] = ()):\n+        self.sections: List[Tuple[str, TimerSection]] = []\n+        self.section_active = False\n+        self.parent_names = parent_names\n \n     @contextlib.contextmanager\n-    def stage(self, name: str):\n-        assert name not in self.stages\n+    def section(self, name: str) -> \"Timer\":\n+        assert not self.section_active\n+        self.section_active = True\n \n-        start = time.time()\n+        start = get_timestamp()\n         exc = None\n+\n+        child_timer = Timer(parent_names=self.parent_names + (name, ))\n+        full_name = \" > \".join(child_timer.parent_names)\n         try:\n-            LOGGER.info(f\"Stage `{name}` starts\")\n-            yield\n+            LOGGER.info(f\"Section `{full_name}` starts\")\n+            yield child_timer\n         except BaseException as exception:\n             exc = exception\n             raise\n         finally:\n-            end = time.time()\n+            end = get_timestamp()\n             duration = end - start\n-            self.stages[name] = duration\n+\n+            if child_timer.has_children():\n+                self.sections.append((name, child_timer))\n+            else:\n+                self.sections.append((name, duration))\n             if exc is None:\n-                LOGGER.info(f\"Stage `{name}` ended: OK ({duration:.2f}s)\")\n+                LOGGER.info(f\"Section `{full_name}` ended: OK ({duration:.2f}s)\")\n+            else:\n+                LOGGER.info(f\"Section `{full_name}` ended: FAIL ({duration:.2f}s)\")\n+            self.section_active = False\n+\n+    def total_duration(self) -> Duration:\n+        duration = 0\n+        for (_, section) in self.sections:\n+            if isinstance(section, Duration):\n+                duration += section\n             else:\n-                LOGGER.info(f\"Stage `{name}` ended: FAIL ({duration:.2f}s)\")\n+                duration += section.total_duration()\n+        return duration\n+\n+    def has_children(self) -> bool:\n+        return len(self.sections) > 0\n \n     def print_stats(self):\n-        total_duration = sum(self.stages.values())\n+        rows = []\n+        for (child_name, child_section) in self.sections:\n+            for (level, name, duration) in iterate_sections(child_section, child_name, level=0):\n+                label = f\"{' ' * level}{name}:\"\n+                rows.append((label, duration))\n \n-        # 57 is the width of the whole table\n-        divider = \"-\" * 57\n+        # Empty row\n+        rows.append((\"\", \"\"))\n+\n+        total_duration_label = \"Total duration:\"\n+        total_duration = self.total_duration()\n+        rows.append((total_duration_label, humantime(total_duration)))\n+\n+        space_after_label = 2\n+        max_label_length = max(16, max(len(label) for (label, _) in rows)) + space_after_label\n+\n+        table_width = max_label_length + 23\n+        divider = \"-\" * table_width\n \n         with StringIO() as output:\n             print(divider, file=output)\n-            for (name, duration) in self.stages.items():\n-                pct = (duration / total_duration) * 100\n-                name_str = f\"{name}:\"\n-                print(f\"{name_str:<34} {duration:>12.2f}s ({pct:>5.2f}%)\", file=output)\n-\n-            total_duration_label = \"Total duration:\"\n-            print(f\"{total_duration_label:<34} {total_duration:>12.2f}s\", file=output)\n+            for (label, duration) in rows:\n+                if isinstance(duration, Duration):\n+                    pct = (duration / total_duration) * 100\n+                    value = f\"{duration:>12.2f}s ({pct:>5.2f}%)\"\n+                else:\n+                    value = f\"{duration:>{len(total_duration_label) + 7}}\"\n+                print(f\"{label:<{max_label_length}} {value}\", file=output)\n             print(divider, file=output, end=\"\")\n             LOGGER.info(f\"Timer results\\n{output.getvalue()}\")\n \n@@ -265,6 +321,21 @@ def change_cwd(dir: Path):\n         os.chdir(cwd)\n \n \n+def humantime(time_s: float) -> str:\n+    hours = time_s // 3600\n+    time_s = time_s % 3600\n+    minutes = time_s // 60\n+    seconds = time_s % 60\n+\n+    result = \"\"\n+    if hours > 0:\n+        result += f\"{int(hours)}h \"\n+    if minutes > 0:\n+        result += f\"{int(minutes)}m \"\n+    result += f\"{round(seconds)}s\"\n+    return result\n+\n+\n def move_path(src: Path, dst: Path):\n     LOGGER.info(f\"Moving `{src}` to `{dst}`\")\n     shutil.move(src, dst)\n@@ -585,15 +656,16 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n     pipeline.build_rustc_perf()\n \n     # Stage 1: Build rustc + PGO instrumented LLVM\n-    with timer.stage(\"Build rustc (LLVM PGO)\"):\n-        build_rustc(pipeline, args=[\n-            \"--llvm-profile-generate\"\n-        ], env=dict(\n-            LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n-        ))\n+    with timer.section(\"Stage 1 (LLVM PGO)\") as stage1:\n+        with stage1.section(\"Build rustc and LLVM\"):\n+            build_rustc(pipeline, args=[\n+                \"--llvm-profile-generate\"\n+            ], env=dict(\n+                LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n+            ))\n \n-    with timer.stage(\"Gather profiles (LLVM PGO)\"):\n-        gather_llvm_profiles(pipeline)\n+        with stage1.section(\"Gather profiles\"):\n+            gather_llvm_profiles(pipeline)\n \n     clear_llvm_files(pipeline)\n     final_build_args += [\n@@ -602,14 +674,15 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n     ]\n \n     # Stage 2: Build PGO instrumented rustc + LLVM\n-    with timer.stage(\"Build rustc (rustc PGO)\"):\n-        build_rustc(pipeline, args=[\n-            \"--rust-profile-generate\",\n-            pipeline.rustc_profile_dir_root()\n-        ])\n+    with timer.section(\"Stage 2 (rustc PGO)\") as stage2:\n+        with stage2.section(\"Build rustc and LLVM\"):\n+            build_rustc(pipeline, args=[\n+                \"--rust-profile-generate\",\n+                pipeline.rustc_profile_dir_root()\n+            ])\n \n-    with timer.stage(\"Gather profiles (rustc PGO)\"):\n-        gather_rustc_profiles(pipeline)\n+        with stage2.section(\"Gather profiles\"):\n+            gather_rustc_profiles(pipeline)\n \n     clear_llvm_files(pipeline)\n     final_build_args += [\n@@ -619,14 +692,15 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n \n     # Stage 3: Build rustc + BOLT instrumented LLVM\n     if pipeline.supports_bolt():\n-        with timer.stage(\"Build rustc (LLVM BOLT)\"):\n-            build_rustc(pipeline, args=[\n-                \"--llvm-profile-use\",\n-                pipeline.llvm_profile_merged_file(),\n-                \"--llvm-bolt-profile-generate\",\n-            ])\n-        with timer.stage(\"Gather profiles (LLVM BOLT)\"):\n-            gather_llvm_bolt_profiles(pipeline)\n+        with timer.section(\"Stage 3 (LLVM BOLT)\") as stage3:\n+            with stage3.section(\"Build rustc and LLVM\"):\n+                build_rustc(pipeline, args=[\n+                    \"--llvm-profile-use\",\n+                    pipeline.llvm_profile_merged_file(),\n+                    \"--llvm-bolt-profile-generate\",\n+                ])\n+            with stage3.section(\"Gather profiles\"):\n+                gather_llvm_bolt_profiles(pipeline)\n \n         clear_llvm_files(pipeline)\n         final_build_args += [\n@@ -635,7 +709,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n         ]\n \n     # Stage 4: Build PGO optimized rustc + PGO/BOLT optimized LLVM\n-    with timer.stage(\"Final build\"):\n+    with timer.section(\"Stage 4 (final build)\"):\n         cmd(final_build_args)\n \n "}, {"sha": "fb7c34118a4913569671e2d714334ae3ed36b438", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -102,14 +102,14 @@ pub struct Markdown<'a> {\n     /// E.g. if `heading_offset: HeadingOffset::H2`, then `# something` renders an `<h2>`.\n     pub heading_offset: HeadingOffset,\n }\n-/// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n-pub(crate) struct MarkdownWithToc<'a>(\n-    pub(crate) &'a str,\n-    pub(crate) &'a mut IdMap,\n-    pub(crate) ErrorCodes,\n-    pub(crate) Edition,\n-    pub(crate) &'a Option<Playground>,\n-);\n+/// A struct like `Markdown` that renders the markdown with a table of contents.\n+pub(crate) struct MarkdownWithToc<'a> {\n+    pub(crate) content: &'a str,\n+    pub(crate) ids: &'a mut IdMap,\n+    pub(crate) error_codes: ErrorCodes,\n+    pub(crate) edition: Edition,\n+    pub(crate) playground: &'a Option<Playground>,\n+}\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags\n /// and includes no paragraph tags.\n pub(crate) struct MarkdownItemInfo<'a>(pub(crate) &'a str, pub(crate) &'a mut IdMap);\n@@ -1048,7 +1048,7 @@ impl Markdown<'_> {\n \n impl MarkdownWithToc<'_> {\n     pub(crate) fn into_string(self) -> String {\n-        let MarkdownWithToc(md, ids, codes, edition, playground) = self;\n+        let MarkdownWithToc { content: md, ids, error_codes: codes, edition, playground } = self;\n \n         let p = Parser::new_ext(md, main_body_opts()).into_offset_iter();\n "}, {"sha": "4321d4aa343dcd8f7065ee0134975e5740b7add8", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -72,7 +72,14 @@ pub(crate) fn render<P: AsRef<Path>>(\n     let mut ids = IdMap::new();\n     let error_codes = ErrorCodes::from(options.unstable_features.is_nightly_build());\n     let text = if !options.markdown_no_toc {\n-        MarkdownWithToc(text, &mut ids, error_codes, edition, &playground).into_string()\n+        MarkdownWithToc {\n+            content: text,\n+            ids: &mut ids,\n+            error_codes,\n+            edition,\n+            playground: &playground,\n+        }\n+        .into_string()\n     } else {\n         Markdown {\n             content: text,"}, {"sha": "91db4b1531f541177ba1944d798f9d68b9fc24e0", "filename": "tests/ui/async-await/future-sizes/large-arg.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Flarge-arg.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Flarge-arg.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Flarge-arg.stdout?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1,17 +1,17 @@\n print-type-size type: `[async fn body@$DIR/large-arg.rs:6:21: 8:2]`: 3076 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 0 bytes\n print-type-size     variant `Suspend0`: 3075 bytes\n print-type-size         local `.__awaitee`: 3075 bytes, offset: 0 bytes, alignment: 1 bytes\n-print-type-size     variant `Unresumed`: 0 bytes\n print-type-size     variant `Returned`: 0 bytes\n print-type-size     variant `Panicked`: 0 bytes\n print-type-size type: `[async fn body@$DIR/large-arg.rs:10:30: 12:2]`: 3075 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 1024 bytes\n+print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Suspend0`: 3074 bytes\n print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size         local `.__awaitee`: 2050 bytes\n-print-type-size     variant `Unresumed`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Returned`: 1024 bytes\n print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Panicked`: 1024 bytes\n@@ -24,11 +24,11 @@ print-type-size         field `.uninit`: 0 bytes\n print-type-size         field `.value`: 3075 bytes\n print-type-size type: `[async fn body@$DIR/large-arg.rs:13:26: 15:2]`: 2050 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 1024 bytes\n+print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Suspend0`: 2049 bytes\n print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size         local `.__awaitee`: 1025 bytes\n-print-type-size     variant `Unresumed`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Returned`: 1024 bytes\n print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Panicked`: 1024 bytes"}, {"sha": "c0c2215c04adb44d520aa84fe983587948d661a0", "filename": "tests/ui/derives/deriving-copyclone.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `B<C>: Copy` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:31:13\n+  --> $DIR/deriving-copyclone.rs:31:26\n    |\n LL |     is_copy(B { a: 1, b: C });\n-   |     ------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `B<C>`\n+   |     -------              ^ the trait `Copy` is not implemented for `B<C>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -19,14 +19,14 @@ LL | fn is_copy<T: Copy>(_: T) {}\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_copy(&B { a: 1, b: C });\n-   |             +\n+LL |     is_copy(B { a: 1, b: &C });\n+   |                          +\n \n error[E0277]: the trait bound `B<C>: Clone` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:32:14\n+  --> $DIR/deriving-copyclone.rs:32:27\n    |\n LL |     is_clone(B { a: 1, b: C });\n-   |     -------- ^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `B<C>`\n+   |     --------              ^ the trait `Clone` is not implemented for `B<C>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -43,14 +43,14 @@ LL | fn is_clone<T: Clone>(_: T) {}\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_clone(&B { a: 1, b: C });\n-   |              +\n+LL |     is_clone(B { a: 1, b: &C });\n+   |                           +\n \n error[E0277]: the trait bound `B<D>: Copy` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:35:13\n+  --> $DIR/deriving-copyclone.rs:35:26\n    |\n LL |     is_copy(B { a: 1, b: D });\n-   |     ------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `B<D>`\n+   |     -------              ^ the trait `Copy` is not implemented for `B<D>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -67,8 +67,8 @@ LL | fn is_copy<T: Copy>(_: T) {}\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_copy(&B { a: 1, b: D });\n-   |             +\n+LL |     is_copy(B { a: 1, b: &D });\n+   |                          +\n \n error: aborting due to 3 previous errors\n "}, {"sha": "5134c672f5f4ed70c5e53e73b0aa28bb32ec4681", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -0,0 +1,28 @@\n+trait T1 {}\n+trait T2 {}\n+trait T3 {}\n+trait T4 {}\n+\n+impl<B: T2> T1 for Wrapper<B> {}\n+\n+impl T2 for i32 {}\n+impl T3 for i32 {}\n+\n+impl<A: T3> T2 for Burrito<A> {}\n+\n+struct Wrapper<W> {\n+    value: W,\n+}\n+\n+struct Burrito<F> {\n+    filling: F,\n+}\n+\n+fn want<V: T1>(_x: V) {}\n+\n+fn example<Q>(q: Q) {\n+    want(Wrapper { value: Burrito { filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+}\n+\n+fn main() {}"}, {"sha": "27b002db1306a5a4c44a79a49fbd145d50bd892e", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:24:46\n+   |\n+LL |     want(Wrapper { value: Burrito { filling: q } });\n+   |     ----                                     ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error.rs:11:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Burrito<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:6:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:21:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2b75f43241289f1c41a70f5626f7113f6dfb327a", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -0,0 +1,131 @@\n+// This test examines the error spans reported when a generic `impl` fails.\n+// For example, if a function wants an `Option<T>` where `T: Copy` but you pass `Some(vec![1, 2])`,\n+// then we want to point at the `vec![1, 2]` and not the `Some( ... )` expression.\n+\n+trait T1 {}\n+trait T2 {}\n+trait T3 {}\n+trait T4 {}\n+\n+impl T2 for i32 {}\n+impl T3 for i32 {}\n+\n+struct Wrapper<W> {\n+    value: W,\n+}\n+impl<B: T2> T1 for Wrapper<B> {}\n+\n+struct Burrito<F> {\n+    spicy: bool,\n+    filling: F,\n+}\n+impl<A: T3> T2 for Burrito<A> {}\n+\n+struct BurritoTuple<F>(F);\n+impl<C: T3> T2 for BurritoTuple<C> {}\n+\n+enum BurritoKinds<G> {\n+    SmallBurrito { spicy: bool, small_filling: G },\n+    LargeBurrito { spicy: bool, large_filling: G },\n+    MultiBurrito { first_filling: G, second_filling: G },\n+}\n+impl<D: T3> T2 for BurritoKinds<D> {}\n+\n+struct Taco<H>(bool, H);\n+impl<E: T3> T2 for Taco<E> {}\n+\n+enum TacoKinds<H> {\n+    OneTaco(bool, H),\n+    TwoTacos(bool, H, H),\n+}\n+impl<F: T3> T2 for TacoKinds<F> {}\n+\n+struct GenericBurrito<Spiciness, Filling> {\n+    spiciness: Spiciness,\n+    filling: Filling,\n+}\n+impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+struct NotSpicy;\n+\n+impl<A: T3, B: T3> T2 for (A, B) {}\n+impl<A: T2, B: T2> T1 for (A, B) {}\n+\n+fn want<V: T1>(_x: V) {}\n+\n+// Some more-complex examples:\n+type AliasBurrito<T> = GenericBurrito<T, T>;\n+\n+// The following example is fairly confusing. The idea is that we want to \"misdirect\" the location\n+// of the error.\n+\n+struct Two<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+\n+struct DoubleWrapper<T> {\n+    item: Wrapper<T>,\n+}\n+\n+impl<T: T1> T1 for DoubleWrapper<T> {}\n+\n+fn example<Q>(q: Q) {\n+    // In each of the following examples, we expect the error span to point at the 'q' variable,\n+    // since the missing constraint is `Q: T3`.\n+\n+    // Verifies for struct:\n+    want(Wrapper { value: Burrito { spicy: false, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for enum with named fields in variant:\n+    want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple struct:\n+    want(Wrapper { value: Taco(false, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple enum variant:\n+    want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for generic type with multiple parameters:\n+    want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple:\n+    want((3, q));\n+    //~^ ERROR the trait bound `Q: T2` is not satisfied [E0277]\n+\n+    // Verifies for nested tuple:\n+    want(Wrapper { value: (3, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for nested tuple:\n+    want(((3, q), 5));\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    want(DoubleWrapper { item: Wrapper { value: q } });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    // Verifies for type alias to struct:\n+    want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    want(Two { a: Two { a: (), b: q }, b: () });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    // We *should* blame the 'q'.\n+    // FIXME: Right now, the wrong field is blamed.\n+    want(\n+        Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n+        //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+    );\n+}\n+\n+fn main() {}"}, {"sha": "5f87c670d8acd7ef3df6dc900d77bc1aff9e322b", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.stderr", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -0,0 +1,380 @@\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:79:60\n+   |\n+LL |     want(Wrapper { value: Burrito { spicy: false, filling: q } });\n+   |     ---- required by a bound introduced by this call       ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:22:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Burrito<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:83:84\n+   |\n+LL |     want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n+   |     ---- required by a bound introduced by this call                               ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `BurritoKinds<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:32:13\n+   |\n+LL | impl<D: T3> T2 for BurritoKinds<D> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<BurritoKinds<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:87:39\n+   |\n+LL |     want(Wrapper { value: Taco(false, q) });\n+   |     ----                              ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Taco<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:35:13\n+   |\n+LL | impl<E: T3> T2 for Taco<E> {}\n+   |         --  ^^     ^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Taco<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:91:27\n+   |\n+LL |     want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n+   |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `TacoKinds<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:41:13\n+   |\n+LL | impl<F: T3> T2 for TacoKinds<F> {}\n+   |         --  ^^     ^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<TacoKinds<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:95:74\n+   |\n+LL |     want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n+   |     ---- required by a bound introduced by this call                     ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `GenericBurrito<NotSpicy, Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:47:16\n+   |\n+LL | impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+   |            --  ^^     ^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required for `Wrapper<GenericBurrito<NotSpicy, Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T2` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:99:14\n+   |\n+LL |     want((3, q));\n+   |     ----     ^ the trait `T2` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:51:20\n+   |\n+LL | impl<A: T2, B: T2> T1 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T2>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:103:31\n+   |\n+LL |     want(Wrapper { value: (3, q) });\n+   |     ----                      ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:50:20\n+   |\n+LL | impl<A: T3, B: T3> T2 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required for `Wrapper<(i32, Q)>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:107:15\n+   |\n+LL |     want(((3, q), 5));\n+   |     ----      ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:50:20\n+   |\n+LL | impl<A: T3, B: T3> T2 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required for `((i32, Q), i32)` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:51:20\n+   |\n+LL | impl<A: T2, B: T2> T1 for (A, B) {}\n+   |         --         ^^     ^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:110:49\n+   |\n+LL |     want(DoubleWrapper { item: Wrapper { value: q } });\n+   |     ----                                        ^ the trait `T1` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `DoubleWrapper<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:72:13\n+   |\n+LL | impl<T: T1> T1 for DoubleWrapper<T> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:113:88\n+   |\n+LL |     want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n+   |     ---- required by a bound introduced by this call                                   ^ the trait `T1` is not implemented for `Q`\n+   |\n+note: required for `DoubleWrapper<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:72:13\n+   |\n+LL | impl<T: T1> T1 for DoubleWrapper<T> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `DoubleWrapper<DoubleWrapper<Q>>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:117:27\n+   |\n+LL |     want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n+   |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `GenericBurrito<Q, Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:47:16\n+   |\n+LL | impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+   |            --  ^^     ^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required for `Wrapper<GenericBurrito<Q, Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:120:35\n+   |\n+LL |     want(Two { a: Two { a: (), b: q }, b: () });\n+   |     ----                          ^ the trait `T1` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Two<Two<(), Q>, ()>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:66:19\n+   |\n+LL | impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+   |            --     ^^     ^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:126:59\n+   |\n+LL |     want(\n+   |     ---- required by a bound introduced by this call\n+LL |         Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n+   |                                                           ^ the trait `T1` is not implemented for `Q`\n+   |\n+note: required for `Two<Two<(), Q>, ()>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:66:19\n+   |\n+LL | impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+   |            --     ^^     ^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `Two<Two<(), Two<Two<(), Q>, ()>>, ()>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8fe936efc8983ed96b21ecdb7ef781b6227cbe39", "filename": "tests/ui/print_type_sizes/async.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fprint_type_sizes%2Fasync.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fprint_type_sizes%2Fasync.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_type_sizes%2Fasync.stdout?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1,11 +1,11 @@\n print-type-size type: `[async fn body@$DIR/async.rs:8:36: 11:2]`: 16386 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 8192 bytes\n+print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Suspend0`: 16385 bytes\n print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size         local `.arg`: 8192 bytes\n print-type-size         local `.__awaitee`: 1 bytes\n-print-type-size     variant `Unresumed`: 8192 bytes\n-print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Returned`: 8192 bytes\n print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Panicked`: 8192 bytes"}, {"sha": "7c58d6ce5ffa1e79785cd7577cbe5174c8d8f082", "filename": "tests/ui/print_type_sizes/generator.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_type_sizes%2Fgenerator.stdout?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -2,9 +2,9 @@ print-type-size type: `[generator@$DIR/generator.rs:10:5: 10:14]`: 8193 bytes, a\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 8192 bytes\n print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Suspend0`: 8192 bytes\n+print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Returned`: 8192 bytes\n print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Panicked`: 8192 bytes\n print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n-print-type-size     variant `Suspend0`: 8192 bytes\n-print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes"}, {"sha": "f2a11c7a33bab49c2d8f343d8fb63f610be500dc", "filename": "tests/ui/print_type_sizes/generator_discr_placement.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fprint_type_sizes%2Fgenerator_discr_placement.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Fprint_type_sizes%2Fgenerator_discr_placement.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_type_sizes%2Fgenerator_discr_placement.stdout?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -1,11 +1,11 @@\n print-type-size type: `[generator@$DIR/generator_discr_placement.rs:11:13: 11:15]`: 8 bytes, alignment: 4 bytes\n print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 0 bytes\n print-type-size     variant `Suspend0`: 7 bytes\n print-type-size         padding: 3 bytes\n print-type-size         local `.w`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `Suspend1`: 7 bytes\n print-type-size         padding: 3 bytes\n print-type-size         local `.z`: 4 bytes, alignment: 4 bytes\n-print-type-size     variant `Unresumed`: 0 bytes\n print-type-size     variant `Returned`: 0 bytes\n print-type-size     variant `Panicked`: 0 bytes"}, {"sha": "b680ce7f99013d67848469be9943f8771331ee39", "filename": "tests/ui/traits/negative-impls/negated-auto-traits-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1eaa2d5d4d1f5b7b89561a940718058d414e89c/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr?ref=e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "patch": "@@ -101,10 +101,10 @@ LL | fn is_send<T: Send>(_: T) {}\n    |               ^^^^ required by this bound in `is_send`\n \n error[E0277]: `main::TestType` cannot be sent between threads safely\n-  --> $DIR/negated-auto-traits-error.rs:66:13\n+  --> $DIR/negated-auto-traits-error.rs:66:20\n    |\n LL |     is_sync(Outer2(TestType));\n-   |     ------- ^^^^^^^^^^^^^^^^ `main::TestType` cannot be sent between threads safely\n+   |     -------        ^^^^^^^^ `main::TestType` cannot be sent between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |"}]}