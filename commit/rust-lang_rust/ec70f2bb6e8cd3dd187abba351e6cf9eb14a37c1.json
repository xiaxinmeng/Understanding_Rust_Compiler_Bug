{"sha": "ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNzBmMmJiNmU4Y2QzZGQxODdhYmJhMzUxZTZjZjllYjE0YTM3YzE=", "commit": {"author": {"name": "Tom Jakubowski", "email": "tom@crystae.net", "date": "2014-07-20T06:02:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-21T16:54:29Z"}, "message": "rustdoc: Add an --extern flag analagous to rustc's\n\nThis adds an `--extern` flag to `rustdoc` much like the compiler's to\nspecify the path where a given crate can be found.", "tree": {"sha": "0f181e1bdc3cc89102421429f7b86199f0a51673", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f181e1bdc3cc89102421429f7b86199f0a51673"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "html_url": "https://github.com/rust-lang/rust/commit/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/comments", "author": {"login": "tomjakubowski", "id": 667901, "node_id": "MDQ6VXNlcjY2NzkwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/667901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomjakubowski", "html_url": "https://github.com/tomjakubowski", "followers_url": "https://api.github.com/users/tomjakubowski/followers", "following_url": "https://api.github.com/users/tomjakubowski/following{/other_user}", "gists_url": "https://api.github.com/users/tomjakubowski/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomjakubowski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomjakubowski/subscriptions", "organizations_url": "https://api.github.com/users/tomjakubowski/orgs", "repos_url": "https://api.github.com/users/tomjakubowski/repos", "events_url": "https://api.github.com/users/tomjakubowski/events{/privacy}", "received_events_url": "https://api.github.com/users/tomjakubowski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97ca98f5ccda65589049397723662e634ada04a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/97ca98f5ccda65589049397723662e634ada04a4", "html_url": "https://github.com/rust-lang/rust/commit/97ca98f5ccda65589049397723662e634ada04a4"}], "stats": {"total": 83, "additions": 66, "deletions": 17}, "files": [{"sha": "dd951d963e0d7cfcfd35d0c8038e83e4a26dd65e", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "patch": "@@ -582,7 +582,7 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n         optmulti(\"\", \"extern\", \"Specify where an external rust library is located\",\n-                 \"PATH\"),\n+                 \"NAME=PATH\"),\n     )\n }\n "}, {"sha": "7f021510f4a0ed85838d81f036856df189155a29", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "patch": "@@ -77,8 +77,10 @@ pub struct CrateAnalysis {\n     pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n }\n \n+pub type Externs = HashMap<String, Vec<String>>;\n+\n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n+fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>, externs: Externs)\n                        -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput,\n@@ -96,6 +98,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(driver::config::CrateTypeRlib),\n         lint_opts: vec!((warning_lint, lint::Allow)),\n+        externs: externs,\n         ..rustc::driver::config::basic_options().clone()\n     };\n \n@@ -148,9 +151,9 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     })\n }\n \n-pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, path: &Path)\n+pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, externs: Externs, path: &Path)\n                 -> (clean::Crate, CrateAnalysis) {\n-    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n+    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs);\n     let ctxt = box(GC) ctxt;\n     super::ctxtkey.replace(Some(ctxt));\n "}, {"sha": "a7c9ac10118296b3830270a6af0b918aa14d18d3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "patch": "@@ -30,6 +30,7 @@ extern crate time;\n use std::io;\n use std::io::{File, MemWriter};\n use std::gc::Gc;\n+use std::collections::HashMap;\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n \n@@ -104,6 +105,7 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n         optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n                  \"DIR\"),\n         optmulti(\"\", \"cfg\", \"pass a --cfg to rustc\", \"\"),\n+        optmulti(\"\", \"extern\", \"pass an --extern to rustc\", \"NAME=PATH\"),\n         optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n         optmulti(\"\", \"passes\", \"space separated list of passes to also run, a \\\n                                 value of `list` will print available passes\",\n@@ -170,6 +172,13 @@ pub fn main_args(args: &[String]) -> int {\n     let input = matches.free[0].as_slice();\n \n     let libs = matches.opt_strs(\"L\").iter().map(|s| Path::new(s.as_slice())).collect();\n+    let externs = match parse_externs(&matches) {\n+        Ok(ex) => ex,\n+        Err(err) => {\n+            println!(\"{}\", err);\n+            return 1;\n+        }\n+    };\n \n     let test_args = matches.opt_strs(\"test-args\");\n     let test_args: Vec<String> = test_args.iter()\n@@ -193,10 +202,10 @@ pub fn main_args(args: &[String]) -> int {\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, libs, test_args)\n+            return markdown::test(input, libs, externs, test_args)\n         }\n         (true, false) => {\n-            return test::run(input, cfgs, libs, test_args)\n+            return test::run(input, cfgs, libs, externs, test_args)\n         }\n         (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n                                                  &matches, &external_html),\n@@ -215,7 +224,7 @@ pub fn main_args(args: &[String]) -> int {\n         return 0;\n     }\n \n-    let (krate, res) = match acquire_input(input, &matches) {\n+    let (krate, res) = match acquire_input(input, externs, &matches) {\n         Ok(pair) => pair,\n         Err(s) => {\n             println!(\"input error: {}\", s);\n@@ -252,27 +261,53 @@ pub fn main_args(args: &[String]) -> int {\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input(input: &str,\n+                 externs: core::Externs,\n                  matches: &getopts::Matches) -> Result<Output, String> {\n     match matches.opt_str(\"r\").as_ref().map(|s| s.as_slice()) {\n-        Some(\"rust\") => Ok(rust_input(input, matches)),\n+        Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n         Some(\"json\") => json_input(input),\n         Some(s) => Err(format!(\"unknown input format: {}\", s)),\n         None => {\n             if input.ends_with(\".json\") {\n                 json_input(input)\n             } else {\n-                Ok(rust_input(input, matches))\n+                Ok(rust_input(input, externs, matches))\n             }\n         }\n     }\n }\n \n+/// Extracts `--extern CRATE=PATH` arguments from `matches` and\n+/// returns a `HashMap` mapping crate names to their paths or else an\n+/// error message.\n+fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n+    let mut externs = HashMap::new();\n+    for arg in matches.opt_strs(\"extern\").iter() {\n+        let mut parts = arg.as_slice().splitn('=', 1);\n+        let name = match parts.next() {\n+            Some(s) => s,\n+            None => {\n+                return Err(\"--extern value must not be empty\".to_string());\n+            }\n+        };\n+        let location = match parts.next() {\n+            Some(s) => s,\n+            None => {\n+                return Err(\"--extern value must be of the format `foo=bar`\".to_string());\n+            }\n+        };\n+        let locs = externs.find_or_insert(name.to_string(), Vec::new());\n+        locs.push(location.to_string());\n+    }\n+    Ok(externs)\n+}\n+\n /// Interprets the input file as a rust source file, passing it through the\n /// compiler all the way through the analysis passes. The rustdoc output is then\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n+fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matches) -> Output {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n     let mut plugins = matches.opt_strs(\"plugins\");\n@@ -283,12 +318,14 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n                                  .map(|s| Path::new(s.as_slice()))\n                                  .collect();\n     let cfgs = matches.opt_strs(\"cfg\");\n+\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n     let (krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n-        core::run_core(libs.move_iter().map(|x| x.clone()).collect(),\n+        core::run_core(libs.move_iter().collect(),\n                        cfgs,\n+                       externs,\n                        &cr)\n     }).map_err(|boxed_any|format!(\"{:?}\", boxed_any)).unwrap();\n     info!(\"finished with rustc\");"}, {"sha": "47009c1f2cc15ef8cc447fdadc002fc2e4e248ea", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "patch": "@@ -12,6 +12,7 @@ use std::collections::HashSet;\n use std::io;\n use std::string::String;\n \n+use core;\n use getopts;\n use testing;\n \n@@ -129,10 +130,11 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<String>) -> int {\n+pub fn test(input: &str, libs: HashSet<Path>, externs: core::Externs,\n+            mut test_args: Vec<String>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n-    let mut collector = Collector::new(input.to_string(), libs, true);\n+    let mut collector = Collector::new(input.to_string(), libs, externs, true);\n     find_testable_code(input_str.as_slice(), &mut collector);\n     test_args.unshift(\"rustdoctest\".to_string());\n     testing::test_main(test_args.as_slice(), collector.tests);"}, {"sha": "2ed35469dfa8d127db57e0bc66819d339a9206b9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ec70f2bb6e8cd3dd187abba351e6cf9eb14a37c1", "patch": "@@ -40,6 +40,7 @@ use visit_ast::RustdocVisitor;\n pub fn run(input: &str,\n            cfgs: Vec<String>,\n            libs: HashSet<Path>,\n+           externs: core::Externs,\n            mut test_args: Vec<String>)\n            -> int {\n     let input_path = Path::new(input);\n@@ -49,10 +50,10 @@ pub fn run(input: &str,\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs.clone()),\n         crate_types: vec!(config::CrateTypeDylib),\n+        externs: externs.clone(),\n         ..config::basic_options().clone()\n     };\n \n-\n     let codemap = CodeMap::new();\n     let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n     let span_diagnostic_handler =\n@@ -92,6 +93,7 @@ pub fn run(input: &str,\n \n     let mut collector = Collector::new(krate.name.to_string(),\n                                        libs,\n+                                       externs,\n                                        false);\n     collector.fold_crate(krate);\n \n@@ -102,8 +104,8 @@ pub fn run(input: &str,\n     0\n }\n \n-fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n-           no_run: bool, as_test_harness: bool) {\n+fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, externs: core::Externs,\n+           should_fail: bool, no_run: bool, as_test_harness: bool) {\n     // the test harness wants its own `main` & top level functions, so\n     // never wrap the test in `fn main() { ... }`\n     let test = maketest(test, Some(cratename), true, as_test_harness);\n@@ -115,6 +117,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(link::OutputTypeExe),\n         no_trans: no_run,\n+        externs: externs,\n         cg: config::CodegenOptions {\n             prefer_dynamic: true,\n             .. config::basic_codegen_options()\n@@ -237,19 +240,21 @@ pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n     names: Vec<String>,\n     libs: HashSet<Path>,\n+    externs: core::Externs,\n     cnt: uint,\n     use_headers: bool,\n     current_header: Option<String>,\n     cratename: String,\n }\n \n impl Collector {\n-    pub fn new(cratename: String, libs: HashSet<Path>,\n+    pub fn new(cratename: String, libs: HashSet<Path>, externs: core::Externs,\n                use_headers: bool) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n             libs: libs,\n+            externs: externs,\n             cnt: 0,\n             use_headers: use_headers,\n             current_header: None,\n@@ -267,6 +272,7 @@ impl Collector {\n         };\n         self.cnt += 1;\n         let libs = self.libs.clone();\n+        let externs = self.externs.clone();\n         let cratename = self.cratename.to_string();\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n@@ -279,6 +285,7 @@ impl Collector {\n                 runtest(test.as_slice(),\n                         cratename.as_slice(),\n                         libs,\n+                        externs,\n                         should_fail,\n                         no_run,\n                         as_test_harness);"}]}