{"sha": "aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZWZiYzRjYmFkNDQ2MWY0Zjg0NmU4OTdhMDRlMGIzY2U4Y2RiMjI=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T22:54:00Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-11T21:26:07Z"}, "message": "More review fixes", "tree": {"sha": "f0dd83e8839e567adbcf56fb0a1a8b28bdb2a568", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0dd83e8839e567adbcf56fb0a1a8b28bdb2a568"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "html_url": "https://github.com/rust-lang/rust/commit/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f3ad881dfd28ae918a29ee3c9501e97f8e60e21", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21", "html_url": "https://github.com/rust-lang/rust/commit/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21"}], "stats": {"total": 56, "additions": 17, "deletions": 39}, "files": [{"sha": "310228838e0ad4bff571b500353acc3f735bfd48", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "patch": "@@ -1501,13 +1501,6 @@ impl<'tcx> BasicBlockData<'tcx> {\n         self.terminator.as_mut().expect(\"invalid terminator state\")\n     }\n \n-    pub fn is_unreachable(&self) -> bool {\n-        match self.terminator().kind {\n-            TerminatorKind::Unreachable => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn retain_statements<F>(&mut self, mut f: F)\n     where\n         F: FnMut(&mut Statement<'_>) -> bool,"}, {"sha": "2cf61d7b3f5295668c3d6d17222f02825fad1971", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "patch": "@@ -1311,7 +1311,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     ) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n         use SavedLocalEligibility::*;\n         let tcx = self.tcx;\n-        let recompute_memory_index = |offsets: &Vec<u32>| -> Vec<u32> {\n+        let recompute_memory_index = |offsets: &[Size]| -> Vec<u32> {\n             debug!(\"recompute_memory_index({:?})\", offsets);\n             let mut inverse_index = (0..offsets.len() as u32).collect::<Vec<_>>();\n             inverse_index.sort_unstable_by_key(|i| offsets[*i as usize]);\n@@ -1349,19 +1349,14 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         // get included in each variant that requested them in\n         // GeneratorLayout.\n         debug!(\"prefix = {:#?}\", prefix);\n-        let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n-            FieldPlacement::Arbitrary { offsets, memory_index } => {\n-                let (offsets_a, offsets_b) =\n-                    offsets.split_at(discr_index + 1);\n-                let (memory_index_a, memory_index_b) =\n-                    memory_index.split_at(discr_index + 1);\n-                let outer_fields = FieldPlacement::Arbitrary {\n-                    offsets: offsets_a.to_vec(),\n-                    memory_index: recompute_memory_index(&memory_index_a.to_vec())\n-                };\n-                (outer_fields,\n-                 offsets_b.to_vec(),\n-                 recompute_memory_index(&memory_index_b.to_vec()))\n+        let (outer_fields, promoted_offsets) = match prefix.fields {\n+            FieldPlacement::Arbitrary { mut offsets, .. } => {\n+                let offsets_b = offsets.split_off(discr_index + 1);\n+                let offsets_a = offsets;\n+\n+                let memory_index = recompute_memory_index(&offsets_a);\n+                let outer_fields = FieldPlacement::Arbitrary { offsets: offsets_a, memory_index };\n+                (outer_fields, offsets_b)\n             }\n             _ => bug!(),\n         };\n@@ -1391,41 +1386,30 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 StructKind::Prefixed(prefix_size, prefix_align.abi))?;\n             variant.variants = Variants::Single { index };\n \n-            let (offsets, memory_index) = match variant.fields {\n-                FieldPlacement::Arbitrary { offsets, memory_index } => (offsets, memory_index),\n+            let offsets = match variant.fields {\n+                FieldPlacement::Arbitrary { offsets, .. } => offsets,\n                 _ => bug!(),\n             };\n \n             // Now, stitch the promoted and variant-only fields back together in\n             // the order they are mentioned by our GeneratorLayout.\n             let mut next_variant_field = 0;\n             let mut combined_offsets = Vec::new();\n-            let mut combined_memory_index = Vec::new();\n             for local in variant_fields.iter() {\n                 match assignments[*local] {\n                     Unassigned => bug!(),\n                     Assigned(_) => {\n                         combined_offsets.push(offsets[next_variant_field]);\n-                        // Shift memory indices by the number of promoted\n-                        // fields, which all come first. We may not use all\n-                        // promoted fields in our variant but that's okay; we'll\n-                        // renumber them below.\n-                        combined_memory_index.push(\n-                            promoted_memory_index.len() as u32 +\n-                            memory_index[next_variant_field]);\n                         next_variant_field += 1;\n                     }\n                     Ineligible(field_idx) => {\n                         let field_idx = field_idx.unwrap() as usize;\n                         combined_offsets.push(promoted_offsets[field_idx]);\n-                        combined_memory_index.push(promoted_memory_index[field_idx]);\n                     }\n                 }\n             }\n-            variant.fields = FieldPlacement::Arbitrary {\n-                offsets: combined_offsets,\n-                memory_index: recompute_memory_index(&combined_memory_index),\n-            };\n+            let memory_index = recompute_memory_index(&combined_offsets);\n+            variant.fields = FieldPlacement::Arbitrary { offsets: combined_offsets, memory_index };\n \n             size = size.max(variant.size);\n             align = align.max(variant.align);"}, {"sha": "e3c35064546010abae922aea079f1593b5d93a8e", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "patch": "@@ -660,9 +660,10 @@ impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n                    flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n                    loc: Location) {\n         // Ignore unreachable blocks.\n-        if self.body.basic_blocks()[loc.block].is_unreachable() {\n-            return;\n-        }\n+        match self.body.basic_blocks()[loc.block].terminator().kind {\n+            TerminatorKind::Unreachable => return,\n+            _ => (),\n+        };\n \n         let mut eligible_storage_live = flow_state.as_dense().clone();\n         eligible_storage_live.intersect(&self.stored_locals);"}]}