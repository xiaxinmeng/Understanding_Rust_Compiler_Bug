{"sha": "36dca8de93c07be62724f973aa4c8a045941d218", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZGNhOGRlOTNjMDdiZTYyNzI0Zjk3M2FhNGM4YTA0NTk0MWQyMTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-26T12:42:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-26T12:42:15Z"}, "message": "Merge #2410\n\n2410: Introduce hir_ty r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "dbe3d521c869aa12c922098e9544859343494a0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbe3d521c869aa12c922098e9544859343494a0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36dca8de93c07be62724f973aa4c8a045941d218", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd3R2nCRBK7hj4Ov3rIwAAdHIIAJBDfju2NlOhmOZeEOfReoY+\nFZ06r7YnRH6qkzJitZ7CzdP31YxnK7M57ohCKAUUQoMlsybn6HJZcbtJO1RaCzx9\n7UdQUWzDsJqrTczV0XUe3qeJb9SRkHtd0yjJ5ds/1Aze593QMvgfuZH9qahXwzta\ntzTFBF9rF7uWgA3finnAPAaPGHyt8aFg6g6tVLtZx0KFoPleAEh5RzthwW9Om6Hl\nCK6R6Qa1C1/QxGgwvZmcebnS7t9lJOuJ2qwkhKmuMmrU65UldNXzQ31PZKvVpddp\nayyxnfSzihKPuCBcS6F4W6OZvqk3xpw4aPefw6+3G9oVC34gdznOkaynpHXqqgM=\n=YCLW\n-----END PGP SIGNATURE-----\n", "payload": "tree dbe3d521c869aa12c922098e9544859343494a0e\nparent 280946e597f880709d2dc2e12eb9a6db3223d979\nparent 4e17718a9aaba34533ba6a46d52b4aa959c662c7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574772135 +0000\ncommitter GitHub <noreply@github.com> 1574772135 +0000\n\nMerge #2410\n\n2410: Introduce hir_ty r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36dca8de93c07be62724f973aa4c8a045941d218", "html_url": "https://github.com/rust-lang/rust/commit/36dca8de93c07be62724f973aa4c8a045941d218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36dca8de93c07be62724f973aa4c8a045941d218/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "280946e597f880709d2dc2e12eb9a6db3223d979", "url": "https://api.github.com/repos/rust-lang/rust/commits/280946e597f880709d2dc2e12eb9a6db3223d979", "html_url": "https://github.com/rust-lang/rust/commit/280946e597f880709d2dc2e12eb9a6db3223d979"}, {"sha": "4e17718a9aaba34533ba6a46d52b4aa959c662c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e17718a9aaba34533ba6a46d52b4aa959c662c7", "html_url": "https://github.com/rust-lang/rust/commit/4e17718a9aaba34533ba6a46d52b4aa959c662c7"}], "stats": {"total": 574, "additions": 329, "deletions": 245}, "files": [{"sha": "5c87cf8e5446b98b2e6eb826fa63c4fe6dae3360", "filename": "Cargo.lock", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -995,6 +995,7 @@ dependencies = [\n  \"ra_db 0.1.0\",\n  \"ra_hir_def 0.1.0\",\n  \"ra_hir_expand 0.1.0\",\n+ \"ra_hir_ty 0.1.0\",\n  \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n@@ -1036,6 +1037,28 @@ dependencies = [\n  \"ra_tt 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_hir_ty\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n+ \"ra_hir_expand 0.1.0\",\n+ \"ra_prof 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_ide_api\"\n version = \"0.1.0\""}, {"sha": "caba85a4f0753a0e3cd2b6bc7bf6dc8280fee0af", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -23,6 +23,7 @@ mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n+hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n "}, {"sha": "821f919d47ea79a85af672cadcace4149f89e4f6", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -997,6 +997,15 @@ pub struct ImplBlock {\n }\n \n impl ImplBlock {\n+    pub fn all_in_crate(db: &impl HirDatabase, krate: Crate) -> Vec<ImplBlock> {\n+        let impls = db.impls_in_crate(krate.crate_id);\n+        impls.all_impls().map(Self::from).collect()\n+    }\n+    pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplBlock> {\n+        let impls = db.impls_in_crate(krate.crate_id);\n+        impls.lookup_impl_blocks_for_trait(trait_).map(Self::from).collect()\n+    }\n+\n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n         db.impl_data(self.id).target_trait.clone()\n     }"}, {"sha": "32f05a4d8b9ecac9576ff9f2b920bc1555e15d61", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use ra_arena::map::ArenaMap;\n-use ra_db::salsa;\n+use ra_db::{salsa, CrateId};\n \n use crate::{\n     ty::{\n@@ -60,7 +60,7 @@ pub trait HirDatabase: DefDatabase {\n     fn generic_defaults(&self, def: GenericDefId) -> Substs;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n-    fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n+    fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplBlocks>;\n \n     #[salsa::invoke(crate::ty::traits::impls_for_trait_query)]\n     fn impls_for_trait(&self, krate: Crate, trait_: Trait) -> Arc<[ImplBlock]>;"}, {"sha": "2d23890a58da8f17a54b193540ee4ef228c3dd94", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -9,7 +9,7 @@ use std::iter;\n use std::sync::Arc;\n \n use hir_def::{\n-    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType},\n+    builtin_type::BuiltinType,\n     generics::WherePredicate,\n     path::{GenericArg, PathSegment},\n     resolver::{HasResolver, Resolver, TypeNs},\n@@ -27,7 +27,7 @@ use super::{\n use crate::{\n     db::HirDatabase,\n     ty::{\n-        primitive::{FloatTy, IntTy, Uncertain},\n+        primitive::{FloatTy, IntTy},\n         Adt,\n     },\n     util::make_mut_slice,\n@@ -679,36 +679,6 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n     })\n }\n \n-impl From<BuiltinInt> for IntTy {\n-    fn from(t: BuiltinInt) -> Self {\n-        IntTy { signedness: t.signedness, bitness: t.bitness }\n-    }\n-}\n-\n-impl From<BuiltinFloat> for FloatTy {\n-    fn from(t: BuiltinFloat) -> Self {\n-        FloatTy { bitness: t.bitness }\n-    }\n-}\n-\n-impl From<Option<BuiltinInt>> for Uncertain<IntTy> {\n-    fn from(t: Option<BuiltinInt>) -> Self {\n-        match t {\n-            None => Uncertain::Unknown,\n-            Some(t) => Uncertain::Known(t.into()),\n-        }\n-    }\n-}\n-\n-impl From<Option<BuiltinFloat>> for Uncertain<FloatTy> {\n-    fn from(t: Option<BuiltinFloat>) -> Self {\n-        match t {\n-            None => Uncertain::Unknown,\n-            Some(t) => Uncertain::Known(t.into()),\n-        }\n-    }\n-}\n-\n fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> FnSig {\n     let struct_data = db.struct_data(def.into());\n     let fields = struct_data.variant_data.fields();"}, {"sha": "489fcd64b98f5d02207d40e7a754e4dd9d0a1b46", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 55, "deletions": 46, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -5,14 +5,19 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver, AstItemDef, HasModule};\n+use hir_def::{\n+    lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, AssocItemId, AstItemDef,\n+    HasModule, ImplId, TraitId,\n+};\n+use ra_db::CrateId;\n+use ra_prof::profile;\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{Ty, TypeCtor},\n-    AssocItem, Crate, Function, ImplBlock, Module, Mutability, Name, Trait,\n+    AssocItem, Crate, Function, Mutability, Name, Trait,\n };\n \n use super::{autoderef, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -37,54 +42,58 @@ impl TyFingerprint {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n-    impls: FxHashMap<TyFingerprint, Vec<ImplBlock>>,\n-    impls_by_trait: FxHashMap<Trait, Vec<ImplBlock>>,\n+    impls: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+    impls_by_trait: FxHashMap<TraitId, Vec<ImplId>>,\n }\n \n impl CrateImplBlocks {\n     pub(crate) fn impls_in_crate_query(\n         db: &impl HirDatabase,\n-        krate: Crate,\n+        krate: CrateId,\n     ) -> Arc<CrateImplBlocks> {\n-        let mut crate_impl_blocks =\n+        let _p = profile(\"impls_in_crate_query\");\n+        let mut res =\n             CrateImplBlocks { impls: FxHashMap::default(), impls_by_trait: FxHashMap::default() };\n-        if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module);\n+\n+        let crate_def_map = db.crate_def_map(krate);\n+        for (_module_id, module_data) in crate_def_map.modules.iter() {\n+            for &impl_id in module_data.impls.iter() {\n+                let impl_data = db.impl_data(impl_id);\n+                let resolver = impl_id.resolver(db);\n+\n+                let target_ty = { Ty::from_hir(db, &resolver, &impl_data.target_type) };\n+\n+                match &impl_data.target_trait {\n+                    Some(trait_ref) => {\n+                        if let Some(tr) =\n+                            TraitRef::from_hir(db, &resolver, &trait_ref, Some(target_ty))\n+                        {\n+                            res.impls_by_trait.entry(tr.trait_.id).or_default().push(impl_id);\n+                        }\n+                    }\n+                    None => {\n+                        if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                            res.impls.entry(target_ty_fp).or_default().push(impl_id);\n+                        }\n+                    }\n+                }\n+            }\n         }\n-        Arc::new(crate_impl_blocks)\n+\n+        Arc::new(res)\n     }\n-    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplBlock> + '_ {\n+    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplId> + '_ {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flatten().copied()\n     }\n \n-    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplBlock> + '_ {\n-        self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n+    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplId> + '_ {\n+        self.impls_by_trait.get(&tr.id).into_iter().flatten().copied()\n     }\n \n-    pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n+    pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplId> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n     }\n-\n-    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n-        for impl_block in module.impl_blocks(db) {\n-            let target_ty = impl_block.target_ty(db);\n-\n-            if impl_block.target_trait(db).is_some() {\n-                if let Some(tr) = impl_block.target_trait_ref(db) {\n-                    self.impls_by_trait.entry(tr.trait_).or_default().push(impl_block);\n-                }\n-            } else {\n-                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                    self.impls.entry(target_ty_fp).or_default().push(impl_block);\n-                }\n-            }\n-        }\n-\n-        for child in module.children(db) {\n-            self.collect_recursive(db, child);\n-        }\n-    }\n }\n \n fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {\n@@ -279,14 +288,14 @@ fn iterate_inherent_methods<T>(\n     mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     for krate in def_crates(db, krate, &ty.value)? {\n-        let impls = db.impls_in_crate(krate);\n+        let impls = db.impls_in_crate(krate.crate_id);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n-            for item in impl_block.items(db) {\n+            for &item in db.impl_data(impl_block).items.iter() {\n                 if !is_valid_candidate(db, name, mode, item) {\n                     continue;\n                 }\n-                if let Some(result) = callback(&ty.value, item) {\n+                if let Some(result) = callback(&ty.value, item.into()) {\n                     return Some(result);\n                 }\n             }\n@@ -299,17 +308,17 @@ fn is_valid_candidate(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    item: AssocItem,\n+    item: AssocItemId,\n ) -> bool {\n     match item {\n-        AssocItem::Function(m) => {\n-            let data = db.function_data(m.id);\n-            name.map_or(true, |name| data.name == *name)\n+        AssocItemId::FunctionId(m) => {\n+            let data = db.function_data(m);\n+            name.map_or(true, |name| &data.name == name)\n                 && (data.has_self_param || mode == LookupMode::Path)\n         }\n-        AssocItem::Const(c) => {\n-            name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n-                && (mode == LookupMode::Path)\n+        AssocItemId::ConstId(c) => {\n+            let data = db.const_data(c);\n+            name.map_or(true, |name| data.name.as_ref() == Some(name)) && (mode == LookupMode::Path)\n         }\n         _ => false,\n     }\n@@ -344,11 +353,11 @@ impl Ty {\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         for krate in def_crates(db, krate, &self)? {\n-            let impls = db.impls_in_crate(krate);\n+            let impls = db.impls_in_crate(krate.crate_id);\n \n             for impl_block in impls.lookup_impl_blocks(&self) {\n-                for item in impl_block.items(db) {\n-                    if let Some(result) = callback(item) {\n+                for &item in db.impl_data(impl_block).items.iter() {\n+                    if let Some(result) = callback(item.into()) {\n                         return Some(result);\n                     }\n                 }"}, {"sha": "12dc9657255a9839902afad68200deada898d44b", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 1, "deletions": 158, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -1,160 +1,3 @@\n //! FIXME: write short doc here\n \n-use std::fmt;\n-\n-pub use hir_def::builtin_type::{FloatBitness, IntBitness, Signedness};\n-\n-#[derive(Clone, Copy, Eq, PartialEq, Hash, Debug)]\n-pub enum Uncertain<T> {\n-    Unknown,\n-    Known(T),\n-}\n-\n-impl From<IntTy> for Uncertain<IntTy> {\n-    fn from(ty: IntTy) -> Self {\n-        Uncertain::Known(ty)\n-    }\n-}\n-\n-impl fmt::Display for Uncertain<IntTy> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Uncertain::Unknown => write!(f, \"{{integer}}\"),\n-            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n-        }\n-    }\n-}\n-\n-impl From<FloatTy> for Uncertain<FloatTy> {\n-    fn from(ty: FloatTy) -> Self {\n-        Uncertain::Known(ty)\n-    }\n-}\n-\n-impl fmt::Display for Uncertain<FloatTy> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Uncertain::Unknown => write!(f, \"{{float}}\"),\n-            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n-pub struct IntTy {\n-    pub signedness: Signedness,\n-    pub bitness: IntBitness,\n-}\n-\n-impl fmt::Debug for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n-impl IntTy {\n-    pub fn isize() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::Xsize }\n-    }\n-\n-    pub fn i8() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X8 }\n-    }\n-\n-    pub fn i16() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X16 }\n-    }\n-\n-    pub fn i32() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X32 }\n-    }\n-\n-    pub fn i64() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X64 }\n-    }\n-\n-    pub fn i128() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X128 }\n-    }\n-\n-    pub fn usize() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize }\n-    }\n-\n-    pub fn u8() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X8 }\n-    }\n-\n-    pub fn u16() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X16 }\n-    }\n-\n-    pub fn u32() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X32 }\n-    }\n-\n-    pub fn u64() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X64 }\n-    }\n-\n-    pub fn u128() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X128 }\n-    }\n-\n-    pub(crate) fn ty_to_string(self) -> &'static str {\n-        match (self.signedness, self.bitness) {\n-            (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n-            (Signedness::Signed, IntBitness::X8) => \"i8\",\n-            (Signedness::Signed, IntBitness::X16) => \"i16\",\n-            (Signedness::Signed, IntBitness::X32) => \"i32\",\n-            (Signedness::Signed, IntBitness::X64) => \"i64\",\n-            (Signedness::Signed, IntBitness::X128) => \"i128\",\n-            (Signedness::Unsigned, IntBitness::Xsize) => \"usize\",\n-            (Signedness::Unsigned, IntBitness::X8) => \"u8\",\n-            (Signedness::Unsigned, IntBitness::X16) => \"u16\",\n-            (Signedness::Unsigned, IntBitness::X32) => \"u32\",\n-            (Signedness::Unsigned, IntBitness::X64) => \"u64\",\n-            (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct FloatTy {\n-    pub bitness: FloatBitness,\n-}\n-\n-impl fmt::Debug for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n-impl FloatTy {\n-    pub fn f32() -> FloatTy {\n-        FloatTy { bitness: FloatBitness::X32 }\n-    }\n-\n-    pub fn f64() -> FloatTy {\n-        FloatTy { bitness: FloatBitness::X64 }\n-    }\n-\n-    pub(crate) fn ty_to_string(self) -> &'static str {\n-        match self.bitness {\n-            FloatBitness::X32 => \"f32\",\n-            FloatBitness::X64 => \"f64\",\n-        }\n-    }\n-}\n+pub use hir_ty::primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain};"}, {"sha": "2eeb030999034153152d3427406d929f56c2074a", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -88,8 +88,8 @@ pub(crate) fn impls_for_trait_query(\n     for dep in krate.dependencies(db) {\n         impls.extend(db.impls_for_trait(dep.krate, trait_).iter());\n     }\n-    let crate_impl_blocks = db.impls_in_crate(krate);\n-    impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_));\n+    let crate_impl_blocks = db.impls_in_crate(krate.crate_id);\n+    impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_).map(ImplBlock::from));\n     impls.into_iter().collect()\n }\n "}, {"sha": "70216ab24000d620c9c027ad0f81f3687adc0e08", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -0,0 +1,32 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir_ty\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+log = \"0.4.5\"\n+rustc-hash = \"1.0\"\n+parking_lot = \"0.9.0\"\n+ena = \"0.13\"\n+\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n+test_utils = { path = \"../test_utils\" }\n+ra_prof = { path = \"../ra_prof\" }\n+\n+# https://github.com/rust-lang/chalk/pull/294\n+chalk-solve =   { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n+chalk-rust-ir = { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n+chalk-ir =      { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n+\n+lalrpop-intern = \"0.15.1\"\n+\n+[dev-dependencies]\n+insta = \"0.12.0\""}, {"sha": "28859ba6366d5dcc49b50bcfcd0450ee7ec41abf", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -0,0 +1,4 @@\n+//! Work in Progress: everything related to types, type inference and trait\n+//! solving.\n+\n+pub mod primitive;"}, {"sha": "02a8179d94db858f0d1e9ed141fcfc0e6d3cb8b6", "filename": "crates/ra_hir_ty/src/primitive.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -0,0 +1,193 @@\n+//! Defines primitive types, which have a couple of peculiarities:\n+//!\n+//! * during type inference, they can be uncertain (ie, `let x = 92;`)\n+//! * they don't belong to any particular crate.\n+\n+use std::fmt;\n+\n+pub use hir_def::builtin_type::{BuiltinFloat, BuiltinInt, FloatBitness, IntBitness, Signedness};\n+\n+#[derive(Clone, Copy, Eq, PartialEq, Hash, Debug)]\n+pub enum Uncertain<T> {\n+    Unknown,\n+    Known(T),\n+}\n+\n+impl From<IntTy> for Uncertain<IntTy> {\n+    fn from(ty: IntTy) -> Self {\n+        Uncertain::Known(ty)\n+    }\n+}\n+\n+impl fmt::Display for Uncertain<IntTy> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Uncertain::Unknown => write!(f, \"{{integer}}\"),\n+            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n+        }\n+    }\n+}\n+\n+impl From<FloatTy> for Uncertain<FloatTy> {\n+    fn from(ty: FloatTy) -> Self {\n+        Uncertain::Known(ty)\n+    }\n+}\n+\n+impl fmt::Display for Uncertain<FloatTy> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Uncertain::Unknown => write!(f, \"{{float}}\"),\n+            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub struct IntTy {\n+    pub signedness: Signedness,\n+    pub bitness: IntBitness,\n+}\n+\n+impl fmt::Debug for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+impl IntTy {\n+    pub fn isize() -> IntTy {\n+        IntTy { signedness: Signedness::Signed, bitness: IntBitness::Xsize }\n+    }\n+\n+    pub fn i8() -> IntTy {\n+        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X8 }\n+    }\n+\n+    pub fn i16() -> IntTy {\n+        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X16 }\n+    }\n+\n+    pub fn i32() -> IntTy {\n+        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X32 }\n+    }\n+\n+    pub fn i64() -> IntTy {\n+        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X64 }\n+    }\n+\n+    pub fn i128() -> IntTy {\n+        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X128 }\n+    }\n+\n+    pub fn usize() -> IntTy {\n+        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize }\n+    }\n+\n+    pub fn u8() -> IntTy {\n+        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X8 }\n+    }\n+\n+    pub fn u16() -> IntTy {\n+        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X16 }\n+    }\n+\n+    pub fn u32() -> IntTy {\n+        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X32 }\n+    }\n+\n+    pub fn u64() -> IntTy {\n+        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X64 }\n+    }\n+\n+    pub fn u128() -> IntTy {\n+        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X128 }\n+    }\n+\n+    pub fn ty_to_string(self) -> &'static str {\n+        match (self.signedness, self.bitness) {\n+            (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n+            (Signedness::Signed, IntBitness::X8) => \"i8\",\n+            (Signedness::Signed, IntBitness::X16) => \"i16\",\n+            (Signedness::Signed, IntBitness::X32) => \"i32\",\n+            (Signedness::Signed, IntBitness::X64) => \"i64\",\n+            (Signedness::Signed, IntBitness::X128) => \"i128\",\n+            (Signedness::Unsigned, IntBitness::Xsize) => \"usize\",\n+            (Signedness::Unsigned, IntBitness::X8) => \"u8\",\n+            (Signedness::Unsigned, IntBitness::X16) => \"u16\",\n+            (Signedness::Unsigned, IntBitness::X32) => \"u32\",\n+            (Signedness::Unsigned, IntBitness::X64) => \"u64\",\n+            (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct FloatTy {\n+    pub bitness: FloatBitness,\n+}\n+\n+impl fmt::Debug for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+impl FloatTy {\n+    pub fn f32() -> FloatTy {\n+        FloatTy { bitness: FloatBitness::X32 }\n+    }\n+\n+    pub fn f64() -> FloatTy {\n+        FloatTy { bitness: FloatBitness::X64 }\n+    }\n+\n+    pub fn ty_to_string(self) -> &'static str {\n+        match self.bitness {\n+            FloatBitness::X32 => \"f32\",\n+            FloatBitness::X64 => \"f64\",\n+        }\n+    }\n+}\n+\n+impl From<BuiltinInt> for IntTy {\n+    fn from(t: BuiltinInt) -> Self {\n+        IntTy { signedness: t.signedness, bitness: t.bitness }\n+    }\n+}\n+\n+impl From<BuiltinFloat> for FloatTy {\n+    fn from(t: BuiltinFloat) -> Self {\n+        FloatTy { bitness: t.bitness }\n+    }\n+}\n+\n+impl From<Option<BuiltinInt>> for Uncertain<IntTy> {\n+    fn from(t: Option<BuiltinInt>) -> Self {\n+        match t {\n+            None => Uncertain::Unknown,\n+            Some(t) => Uncertain::Known(t.into()),\n+        }\n+    }\n+}\n+\n+impl From<Option<BuiltinFloat>> for Uncertain<FloatTy> {\n+    fn from(t: Option<BuiltinFloat>) -> Self {\n+        match t {\n+            None => Uncertain::Unknown,\n+            Some(t) => Uncertain::Known(t.into()),\n+        }\n+    }\n+}"}, {"sha": "b3ebd914546c621a369383328428bfc30a2ae2b2", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36dca8de93c07be62724f973aa4c8a045941d218/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=36dca8de93c07be62724f973aa4c8a045941d218", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{db::HirDatabase, ApplicationTy, FromSource, Ty, TypeCtor};\n+use hir::{ApplicationTy, FromSource, ImplBlock, Ty, TypeCtor};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n@@ -56,11 +56,11 @@ fn impls_for_def(\n     };\n \n     let krate = module.krate();\n-    let impls = db.impls_in_crate(krate);\n+    let impls = ImplBlock::all_in_crate(db, krate);\n \n     Some(\n         impls\n-            .all_impls()\n+            .into_iter()\n             .filter(|impl_block| is_equal_for_find_impls(&ty, &impl_block.target_ty(db)))\n             .map(|imp| imp.to_nav(db))\n             .collect(),\n@@ -77,9 +77,9 @@ fn impls_for_trait(\n     let tr = hir::Trait::from_source(db, src)?;\n \n     let krate = module.krate();\n-    let impls = db.impls_in_crate(krate);\n+    let impls = ImplBlock::for_trait(db, krate, tr);\n \n-    Some(impls.lookup_impl_blocks_for_trait(tr).map(|imp| imp.to_nav(db)).collect())\n+    Some(impls.into_iter().map(|imp| imp.to_nav(db)).collect())\n }\n \n fn is_equal_for_find_impls(original_ty: &Ty, impl_ty: &Ty) -> bool {"}]}