{"sha": "bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjODdlZmVmMmNjZWFlYzk5ZDMwZTgwOWNhYzJiOGQyMmI5ZTI1ZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T19:52:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T19:52:04Z"}, "message": "Auto merge of #22153 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "1f59e50bc58a426615cc15594cade8b69f24bdbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f59e50bc58a426615cc15594cade8b69f24bdbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "html_url": "https://github.com/rust-lang/rust/commit/bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d8ba5ab3b1d22288b021708c3d87464e43b880", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d8ba5ab3b1d22288b021708c3d87464e43b880", "html_url": "https://github.com/rust-lang/rust/commit/88d8ba5ab3b1d22288b021708c3d87464e43b880"}, {"sha": "3e10785e21b731d536cf9ad9b911e8261862bde7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e10785e21b731d536cf9ad9b911e8261862bde7", "html_url": "https://github.com/rust-lang/rust/commit/3e10785e21b731d536cf9ad9b911e8261862bde7"}], "stats": {"total": 1462, "additions": 1029, "deletions": 433}, "files": [{"sha": "e6b8d23544829ca6d277375067b09ec5409c860c", "filename": "configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/configure", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -525,6 +525,7 @@ opt verify-install 1 \"verify installed binaries work\"\n opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt jemalloc 1 \"build liballoc with jemalloc\"\n+opt llvm-version-check 1 \"don't check if the LLVM version is supported, build anyway\"\n \n valopt localstatedir \"/var/lib\" \"local state directory\"\n valopt sysconfdir \"/etc\" \"install system configuration files\"\n@@ -796,7 +797,7 @@ then\n     putvar CFG_ENABLE_CLANG\n fi\n \n-if [ ! -z \"$CFG_LLVM_ROOT\" -a -e \"$CFG_LLVM_ROOT/bin/llvm-config\" ]\n+if [ ! -z \"$CFG_LLVM_ROOT\" -a -z \"$CFG_DISABLE_LLVM_VERSION_CHECK\" -a -e \"$CFG_LLVM_ROOT/bin/llvm-config\" ]\n then\n     step_msg \"using custom LLVM at $CFG_LLVM_ROOT\"\n "}, {"sha": "3c92fa02f2040fbfc738fbde38de4115d275fed9", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -12,7 +12,6 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(os)]"}, {"sha": "b4e023c2039111079484dcebdad800f2f0a026f5", "filename": "src/doc/grammar.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -157,7 +157,7 @@ token : simple_token | ident | literal | symbol | whitespace token ;\n \n |          |          |          |          |        |\n |----------|----------|----------|----------|--------|\n-| abstract | alignof  | as       | be       | box    |\n+| abstract | alignof  | as       | become   | box    |\n | break    | const    | continue | crate    | do     |\n | else     | enum     | extern   | false    | final  |\n | fn       | for      | if       | impl     | in     |"}, {"sha": "a4f79412220189436fb3ad850210a4a28dcf66d1", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -59,8 +59,7 @@ tools we have are really nice.\n [Cargo](http://crates.io) is Rust's package manager, and its website contains\n lots of good documentation.\n \n-[The `rustdoc` manual](rustdoc.html) contains information about Rust's\n-documentation tool.\n+[`rustdoc`](book/documentation.html) is used to generate documentation for Rust code.\n \n # FAQs\n "}, {"sha": "d50c0d6582b30f5ce5e235dd0e64ae20dbd2e9b7", "filename": "src/doc/reference.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -189,7 +189,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n |          |          |          |          |         |\n |----------|----------|----------|----------|---------|\n-| abstract | alignof  | as       | be       | box     |\n+| abstract | alignof  | as       | become   | box     |\n | break    | const    | continue | crate    | do      |\n | else     | enum     | extern   | false    | final   |\n | fn       | for      | if       | impl     | in      |\n@@ -381,11 +381,13 @@ character (`\\`), or a single _escape_. It is equivalent to a `u8` unsigned\n \n ##### Byte string literals\n \n-A _byte string literal_ is a sequence of ASCII characters and _escapes_\n-enclosed within two `U+0022` (double-quote) characters, with the exception of\n-`U+0022` itself, which must be _escaped_ by a preceding `U+005C` character\n-(`\\`), or a _raw byte string literal_. It is equivalent to a `&'static [u8]`\n-borrowed array of unsigned 8-bit integers.\n+A non-raw _byte string literal_ is a sequence of ASCII characters and _escapes_,\n+preceded by the characters `U+0062` (`b`) and `U+0022` (double-quote), and\n+followed by the character `U+0022`. If the character `U+0022` is present within\n+the literal, it must be _escaped_ by a preceding `U+005C` (`\\`) character.\n+Alternatively, a byte string literal can be a _raw byte string literal_, defined\n+below. A byte string literal is equivalent to a `&'static [u8]` borrowed array\n+of unsigned 8-bit integers.\n \n Some additional _escapes_ are available in either byte or non-raw byte string\n literals. An escape starts with a `U+005C` (`\\`) and continues with one of the\n@@ -1253,9 +1255,7 @@ fn my_err(s: &str) -> ! {\n We call such functions \"diverging\" because they never return a value to the\n caller. Every control path in a diverging function must end with a `panic!()` or\n a call to another diverging function on every control path. The `!` annotation\n-does *not* denote a type. Rather, the result type of a diverging function is a\n-special type called \u22a5 (\"bottom\") that unifies with any type. Rust has no\n-syntax for \u22a5.\n+does *not* denote a type.\n \n It might be necessary to declare a diverging function because as mentioned\n previously, the typechecker checks that every control path in a function ends\n@@ -2354,8 +2354,8 @@ Supported traits for `derive` are:\n * `FromPrimitive`, to create an instance from a numeric primitive.\n * `Hash`, to iterate over the bytes in a data type.\n * `Rand`, to create a random instance of a data type.\n-* `Show`, to format a value using the `{}` formatter.\n-* `Zero`, to create a zero instance of a numeric data type.\n+* `Debug`, to format a value using the `{:?}` formatter.\n+* `Copy`, for \"Plain Old Data\" types which can be copied by simply moving bits.\n \n ### Compiler Features\n "}, {"sha": "c2a25cd7a584ec39c85978737dc0e3c3770c2339", "filename": "src/doc/rust.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -58,7 +58,7 @@\n body {\n     margin: 0 auto;\n     padding: 0 15px;\n-    font-family: \"Source Serif Pro\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+    font-family: \"Source Serif Pro\", Georgia, Times, \"Times New Roman\", serif;\n     font-size: 18px;\n     color: #333;\n     line-height: 1.428571429;"}, {"sha": "bfc1247dc3bc074002fd1de4721729cf0e9c25ed", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -27,6 +27,7 @@\n     * [Iterators](iterators.md)\n     * [Generics](generics.md)\n     * [Traits](traits.md)\n+    * [Static and Dynamic Dispatch](static-and-dynamic-dispatch.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [Documentation](documentation.md)"}, {"sha": "8cc6be7387ca1ee1e1bc78022d2b9d4ab64abba0", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -9,7 +9,7 @@ arguments, really powerful things are possible.\n Let's make a closure:\n \n ```{rust}\n-let add_one = |&: x| { 1 + x };\n+let add_one = |x| { 1 + x };\n \n println!(\"The sum of 5 plus 1 is {}.\", add_one(5));\n ```\n@@ -21,8 +21,8 @@ binding name and two parentheses, just like we would for a named function.\n Let's compare syntax. The two are pretty close:\n \n ```{rust}\n-let add_one = |&: x: i32| -> i32 { 1 + x };\n-fn  add_one      (x: i32) -> i32 { 1 + x }\n+let add_one = |x: i32| -> i32 { 1 + x };\n+fn  add_one   (x: i32) -> i32 { 1 + x }\n ```\n \n As you may have noticed, closures infer their argument and return types, so you\n@@ -37,7 +37,7 @@ this:\n fn main() {\n     let x: i32 = 5;\n \n-    let printer = |&:| { println!(\"x is: {}\", x); };\n+    let printer = || { println!(\"x is: {}\", x); };\n \n     printer(); // prints \"x is: 5\"\n }\n@@ -53,7 +53,7 @@ defined. The closure borrows any variables it uses, so this will error:\n fn main() {\n     let mut x: i32 = 5;\n \n-    let printer = |&:| { println!(\"x is: {}\", x); };\n+    let printer = || { println!(\"x is: {}\", x); };\n \n     x = 6; // error: cannot assign to `x` because it is borrowed\n }\n@@ -80,7 +80,7 @@ fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n }\n \n fn main() {\n-    let square = |&: x: i32| { x * x };\n+    let square = |x: i32| { x * x };\n \n     twice(5, square); // evaluates to 50\n }\n@@ -89,15 +89,15 @@ fn main() {\n Let's break the example down, starting with `main`:\n \n ```{rust}\n-let square = |&: x: i32| { x * x };\n+let square = |x: i32| { x * x };\n ```\n \n We've seen this before. We make a closure that takes an integer, and returns\n its square.\n \n ```{rust}\n # fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 { f(x) + f(x) }\n-# let square = |&: x: i32| { x * x };\n+# let square = |x: i32| { x * x };\n twice(5, square); // evaluates to 50\n ```\n \n@@ -184,8 +184,8 @@ fn compose<F, G>(x: i32, f: F, g: G) -> i32\n \n fn main() {\n     compose(5,\n-            |&: n: i32| { n + 42 },\n-            |&: n: i32| { n * 2 }); // evaluates to 94\n+            |n: i32| { n + 42 },\n+            |n: i32| { n * 2 }); // evaluates to 94\n }\n ```\n "}, {"sha": "51a4edbdac802b4da219d9ffb5ba6abfbb0f50d3", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -72,6 +72,20 @@ if x == y {\n \n This will print `no`, because some of the values aren't equal.\n \n+Note that the order of the values is considered when checking for equality,\n+so the following example will also print `no`.\n+\n+```rust\n+let x = (1, 2, 3);\n+let y = (2, 1, 3);\n+\n+if x == y {\n+    println!(\"yes\");\n+} else {\n+    println!(\"no\");\n+}\n+```\n+\n One other use of tuples is to return multiple values from a function:\n \n ```rust"}, {"sha": "9421dac7bf65d750a554e9c1f0a17de1bfe6a5c4", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,286 @@\n+% Static and Dynamic Dispatch\n+\n+When code involves polymorphism, there needs to be a mechanism to determine\n+which specific version is actually run. This is called 'dispatch.' There are\n+two major forms of dispatch: static dispatch and dynamic dispatch. While Rust\n+favors static dispatch, it also supports dynamic dispatch through a mechanism\n+called 'trait objects.'\n+\n+## Background\n+\n+For the rest of this chapter, we'll need a trait and some implementations.\n+Let's make a simple one, `Foo`. It has one method that is expected to return a\n+`String`.\n+\n+```rust\n+trait Foo {\n+    fn method(&self) -> String;\n+}\n+```\n+\n+We'll also implement this trait for `u8` and `String`:\n+\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+impl Foo for u8 {\n+    fn method(&self) -> String { format!(\"u8: {}\", *self) }\n+}\n+\n+impl Foo for String {\n+    fn method(&self) -> String { format!(\"string: {}\", *self) }\n+}\n+```\n+\n+\n+## Static dispatch\n+\n+We can use this trait to perform static dispatch with trait bounds:\n+\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n+# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n+fn do_something<T: Foo>(x: T) {\n+    x.method();\n+}\n+\n+fn main() {\n+    let x = 5u8;\n+    let y = \"Hello\".to_string();\n+\n+    do_something(x);\n+    do_something(y);\n+}\n+```\n+\n+Rust uses 'monomorphization' to perform static dispatch here. This means that\n+Rust will create a special version of `do_something()` for both `u8` and\n+`String`, and then replace the call sites with calls to these specialized\n+functions. In other words, Rust generates something like this:\n+\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n+# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n+fn do_something_u8(x: u8) {\n+    x.method();\n+}\n+\n+fn do_something_string(x: String) {\n+    x.method();\n+}\n+\n+fn main() {\n+    let x = 5u8;\n+    let y = \"Hello\".to_string();\n+\n+    do_something_u8(x);\n+    do_something_string(y);\n+}\n+```\n+\n+This has some upsides: static dispatching of any method calls, allowing for\n+inlining and hence usually higher performance. It also has some downsides:\n+causing code bloat due to many copies of the same function existing in the\n+binary, one for each type.\n+\n+Furthermore, compilers aren\u2019t perfect and may \u201coptimise\u201d code to become slower.\n+For example, functions inlined too eagerly will bloat the instruction cache\n+(cache rules everything around us). This is part of the reason that `#[inline]`\n+and `#[inline(always)]` should be used carefully, and one reason why using a\n+dynamic dispatch is sometimes more efficient.\n+\n+However, the common case is that it is more efficient to use static dispatch,\n+and one can always have a thin statically-dispatched wrapper function that does\n+a dynamic, but not vice versa, meaning static calls are more flexible. The\n+standard library tries to be statically dispatched where possible for this\n+reason. \n+\n+## Dynamic dispatch\n+\n+Rust provides dynamic dispatch through a feature called 'trait objects.' Trait\n+objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of\n+*any* type that implements the given trait, where the precise type can only be\n+known at runtime. The methods of the trait can be called on a trait object via\n+a special record of function pointers (created and managed by the compiler).\n+\n+A function that takes a trait object is not specialised to each of the types\n+that implements `Foo`: only one copy is generated, often (but not always)\n+resulting in less code bloat. However, this comes at the cost of requiring\n+slower virtual function calls, and effectively inhibiting any chance of\n+inlining and related optimisations from occurring.\n+\n+Trait objects are both simple and complicated: their core representation and\n+layout is quite straight-forward, but there are some curly error messages and\n+surprising behaviours to discover.\n+\n+### Obtaining a trait object\n+\n+There's two similar ways to get a trait object value: casts and coercions. If\n+`T` is a type that implements a trait `Foo` (e.g. `u8` for the `Foo` above),\n+then the two ways to get a `Foo` trait object out of a pointer to `T` look\n+like:\n+\n+```{rust,ignore}\n+let ref_to_t: &T = ...;\n+\n+// `as` keyword for casting\n+let cast = ref_to_t as &Foo;\n+\n+// using a `&T` in a place that has a known type of `&Foo` will implicitly coerce:\n+let coerce: &Foo = ref_to_t;\n+\n+fn also_coerce(_unused: &Foo) {}\n+also_coerce(ref_to_t);\n+```\n+\n+These trait object coercions and casts also work for pointers like `&mut T` to\n+`&mut Foo` and `Box<T>` to `Box<Foo>`, but that's all at the moment. Coercions\n+and casts are identical.\n+\n+This operation can be seen as \"erasing\" the compiler's knowledge about the\n+specific type of the pointer, and hence trait objects are sometimes referred to\n+\"type erasure\".\n+\n+### Representation\n+\n+Let's start simple, with the runtime representation of a trait object. The\n+`std::raw` module contains structs with layouts that are the same as the\n+complicated build-in types, [including trait objects][stdraw]:\n+\n+```rust\n+# mod foo {\n+pub struct TraitObject {\n+    pub data: *mut (),\n+    pub vtable: *mut (),\n+}\n+# }\n+```\n+\n+[stdraw]: ../std/raw/struct.TraitObject.html\n+\n+That is, a trait object like `&Foo` consists of a \"data\" pointer and a \"vtable\"\n+pointer.\n+\n+The data pointer addresses the data (of some unknown type `T`) that the trait\n+object is storing, and the vtable pointer points to the vtable (\"virtual method\n+table\") corresponding to the implementation of `Foo` for `T`.\n+\n+\n+A vtable is essentially a struct of function pointers, pointing to the concrete\n+piece of machine code for each method in the implementation. A method call like\n+`trait_object.method()` will retrieve the correct pointer out of the vtable and\n+then do a dynamic call of it. For example:\n+\n+```{rust,ignore}\n+struct FooVtable {\n+    destructor: fn(*mut ()),\n+    size: usize,\n+    align: usize,\n+    method: fn(*const ()) -> String,\n+}\n+\n+// u8:\n+\n+fn call_method_on_u8(x: *const ()) -> String {\n+    // the compiler guarantees that this function is only called\n+    // with `x` pointing to a u8\n+    let byte: &u8 = unsafe { &*(x as *const u8) };\n+\n+    byte.method()\n+}\n+\n+static Foo_for_u8_vtable: FooVtable = FooVtable {\n+    destructor: /* compiler magic */,\n+    size: 1,\n+    align: 1,\n+\n+    // cast to a function pointer\n+    method: call_method_on_u8 as fn(*const ()) -> String,\n+};\n+\n+\n+// String:\n+\n+fn call_method_on_String(x: *const ()) -> String {\n+    // the compiler guarantees that this function is only called\n+    // with `x` pointing to a String\n+    let string: &String = unsafe { &*(x as *const String) };\n+\n+    string.method()\n+}\n+\n+static Foo_for_String_vtable: FooVtable = FooVtable {\n+    destructor: /* compiler magic */,\n+    // values for a 64-bit computer, halve them for 32-bit ones\n+    size: 24,\n+    align: 8,\n+\n+    method: call_method_on_String as fn(*const ()) -> String,\n+};\n+```\n+\n+The `destructor` field in each vtable points to a function that will clean up\n+any resources of the vtable's type, for `u8` it is trivial, but for `String` it\n+will free the memory. This is necessary for owning trait objects like\n+`Box<Foo>`, which need to clean-up both the `Box` allocation and as well as the\n+internal type when they go out of scope. The `size` and `align` fields store\n+the size of the erased type, and its alignment requirements; these are\n+essentially unused at the moment since the information is embedded in the\n+destructor, but will be used in future, as trait objects are progressively made\n+more flexible.\n+\n+Suppose we've got some values that implement `Foo`, the explicit form of\n+construction and use of `Foo` trait objects might look a bit like (ignoring the\n+type mismatches: they're all just pointers anyway):\n+\n+```{rust,ignore}\n+let a: String = \"foo\".to_string();\n+let x: u8 = 1;\n+\n+// let b: &Foo = &a;\n+let b = TraitObject {\n+    // store the data\n+    data: &a,\n+    // store the methods\n+    vtable: &Foo_for_String_vtable\n+};\n+\n+// let y: &Foo = x;\n+let y = TraitObject {\n+    // store the data\n+    data: &x,\n+    // store the methods\n+    vtable: &Foo_for_u8_vtable\n+};\n+\n+// b.method();\n+(b.vtable.method)(b.data);\n+\n+// y.method();\n+(y.vtable.method)(y.data);\n+```\n+\n+If `b` or `y` were owning trait objects (`Box<Foo>`), there would be a\n+`(b.vtable.destructor)(b.data)` (respectively `y`) call when they went out of\n+scope.\n+\n+### Why pointers?\n+\n+The use of language like \"fat pointer\" implies that a trait object is\n+always a pointer of some form, but why?\n+\n+Rust does not put things behind a pointer by default, unlike many managed\n+languages, so types can have different sizes. Knowing the size of the value at\n+compile time is important for things like passing it as an argument to a\n+function, moving it about on the stack and allocating (and deallocating) space\n+on the heap to store it.\n+\n+For `Foo`, we would need to have a value that could be at least either a\n+`String` (24 bytes) or a `u8` (1 byte), as well as any other type for which\n+dependent crates may implement `Foo` (any number of bytes at all). There's no\n+way to guarantee that this last point can work if the values are stored without\n+a pointer, because those other types can be arbitrarily large.\n+\n+Putting the value behind a pointer means the size of the value is not relevant\n+when we are tossing a trait object around, only the size of the pointer itself."}, {"sha": "e091878cf86ec200df19b5b1878adebf7969ef64", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -270,51 +270,8 @@ not, because both the trait and the type aren't in our crate.\n \n One last thing about traits: generic functions with a trait bound use\n *monomorphization* (*mono*: one, *morph*: form), so they are statically\n-dispatched. What's that mean? Well, let's take a look at `print_area` again:\n-\n-```{rust,ignore}\n-fn print_area<T: HasArea>(shape: T) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-\n-fn main() {\n-    let c = Circle { ... };\n-\n-    let s = Square { ... };\n-\n-    print_area(c);\n-    print_area(s);\n-}\n-```\n-\n-When we use this trait with `Circle` and `Square`, Rust ends up generating\n-two different functions with the concrete type, and replacing the call sites with\n-calls to the concrete implementations. In other words, you get something like\n-this:\n-\n-```{rust,ignore}\n-fn __print_area_circle(shape: Circle) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-\n-fn __print_area_square(shape: Square) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-\n-fn main() {\n-    let c = Circle { ... };\n-\n-    let s = Square { ... };\n-\n-    __print_area_circle(c);\n-    __print_area_square(s);\n-}\n-```\n-\n-The names don't actually change to this, it's just for illustration. But\n-as you can see, there's no overhead of deciding which version to call here,\n-hence *statically dispatched*. The downside is that we have two copies of\n-the same function, so our binary is a little bit larger.\n+dispatched. What's that mean? Check out the chapter on [static and dynamic\n+dispatch](static-and-dynamic-dispatch.html) for more.\n \n ## Our `inverse` Example\n "}, {"sha": "0617c604121f49bcc9cb2569185ca2dbb704b805", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -206,12 +206,12 @@ impl<T> Arc<T> {\n /// Get the number of weak references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n+pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n+pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Arc<T> {\n@@ -649,7 +649,7 @@ mod tests {\n         let (tx, rx) = channel();\n \n         let _t = Thread::spawn(move || {\n-            let arc_v: Arc<Vec<int>> = rx.recv().unwrap();\n+            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n             assert_eq!((*arc_v)[3], 4);\n         });\n \n@@ -818,5 +818,5 @@ mod tests {\n \n     // Make sure deriving works with Arc<T>\n     #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n-    struct Foo { inner: Arc<int> }\n+    struct Foo { inner: Arc<i32> }\n }"}, {"sha": "b7bacaa0cae2bf074ba3a311da0a34c7a7b256b9", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -22,7 +22,7 @@ use std::boxed::BoxAny;\n #[test]\n fn test_owned_clone() {\n     let a = Box::new(5);\n-    let b: Box<int> = a.clone();\n+    let b: Box<i32> = a.clone();\n     assert!(a == b);\n }\n \n@@ -31,11 +31,11 @@ struct Test;\n \n #[test]\n fn any_move() {\n-    let a = Box::new(8us) as Box<Any>;\n+    let a = Box::new(8) as Box<Any>;\n     let b = Box::new(Test) as Box<Any>;\n \n-    match a.downcast::<uint>() {\n-        Ok(a) => { assert!(a == Box::new(8us)); }\n+    match a.downcast::<i32>() {\n+        Ok(a) => { assert!(a == Box::new(8)); }\n         Err(..) => panic!()\n     }\n     match b.downcast::<Test>() {\n@@ -47,7 +47,7 @@ fn any_move() {\n     let b = Box::new(Test) as Box<Any>;\n \n     assert!(a.downcast::<Box<Test>>().is_err());\n-    assert!(b.downcast::<Box<uint>>().is_err());\n+    assert!(b.downcast::<Box<i32>>().is_err());\n }\n \n #[test]"}, {"sha": "d3d86270d1e9fdea6a4bb02149f6cfbc2a554c0a", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -21,7 +21,7 @@ use core::ptr::PtrExt;\n /// power of 2. The alignment must be no larger than the largest supported page\n /// size on the platform.\n #[inline]\n-pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n     imp::allocate(size, align)\n }\n \n@@ -37,7 +37,7 @@ pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n     imp::reallocate(ptr, old_size, size, align)\n }\n \n@@ -54,7 +54,8 @@ pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint)\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> uint {\n+pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                                 align: usize) -> usize {\n     imp::reallocate_inplace(ptr, old_size, size, align)\n }\n \n@@ -66,14 +67,14 @@ pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint, align\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     imp::deallocate(ptr, old_size, align)\n }\n \n /// Returns the usable size of an allocation created with the specified the\n /// `size` and `align`.\n #[inline]\n-pub fn usable_size(size: uint, align: uint) -> uint {\n+pub fn usable_size(size: usize, align: usize) -> usize {\n     imp::usable_size(size, align)\n }\n \n@@ -96,7 +97,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n+unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n         EMPTY as *mut u8\n     } else {\n@@ -109,7 +110,7 @@ unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n #[cfg(not(test))]\n #[lang=\"exchange_free\"]\n #[inline]\n-unsafe fn exchange_free(ptr: *mut u8, old_size: uint, align: uint) {\n+unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n     deallocate(ptr, old_size, align);\n }\n \n@@ -122,49 +123,49 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: uint, align: uint) {\n               target_arch = \"mips\",\n               target_arch = \"mipsel\",\n               target_arch = \"powerpc\")))]\n-const MIN_ALIGN: uint = 8;\n+const MIN_ALIGN: usize = 8;\n #[cfg(all(not(feature = \"external_funcs\"),\n           not(feature = \"external_crate\"),\n           any(target_arch = \"x86\",\n               target_arch = \"x86_64\",\n               target_arch = \"aarch64\")))]\n-const MIN_ALIGN: uint = 16;\n+const MIN_ALIGN: usize = 16;\n \n #[cfg(feature = \"external_funcs\")]\n mod imp {\n     extern {\n-        fn rust_allocate(size: uint, align: uint) -> *mut u8;\n-        fn rust_deallocate(ptr: *mut u8, old_size: uint, align: uint);\n-        fn rust_reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8;\n-        fn rust_reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n-                                   align: uint) -> uint;\n-        fn rust_usable_size(size: uint, align: uint) -> uint;\n+        fn rust_allocate(size: usize, align: usize) -> *mut u8;\n+        fn rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n+        fn rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n+        fn rust_reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                                   align: usize) -> usize;\n+        fn rust_usable_size(size: usize, align: usize) -> usize;\n         fn rust_stats_print();\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         rust_allocate(size, align)\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n         rust_deallocate(ptr, old_size, align)\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n         rust_reallocate(ptr, old_size, size, align)\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n-                                     align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                                     align: usize) -> usize {\n         rust_reallocate_inplace(ptr, old_size, size, align)\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, align: uint) -> uint {\n+    pub fn usable_size(size: usize, align: usize) -> usize {\n         unsafe { rust_usable_size(size, align) }\n     }\n \n@@ -215,42 +216,42 @@ mod imp {\n \n     // MALLOCX_ALIGN(a) macro\n     #[inline(always)]\n-    fn mallocx_align(a: uint) -> c_int { a.trailing_zeros() as c_int }\n+    fn mallocx_align(a: usize) -> c_int { a.trailing_zeros() as c_int }\n \n     #[inline(always)]\n-    fn align_to_flags(align: uint) -> c_int {\n+    fn align_to_flags(align: usize) -> c_int {\n         if align <= MIN_ALIGN { 0 } else { mallocx_align(align) }\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         let flags = align_to_flags(align);\n         je_mallocx(size as size_t, flags) as *mut u8\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n         let flags = align_to_flags(align);\n         je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, _old_size: uint, size: uint,\n-                                     align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, _old_size: usize, size: usize,\n+                                     align: usize) -> usize {\n         let flags = align_to_flags(align);\n-        je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as uint\n+        je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n         let flags = align_to_flags(align);\n         je_sdallocx(ptr as *mut c_void, old_size as size_t, flags)\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, align: uint) -> uint {\n+    pub fn usable_size(size: usize, align: usize) -> usize {\n         let flags = align_to_flags(align);\n-        unsafe { je_nallocx(size as size_t, flags) as uint }\n+        unsafe { je_nallocx(size as size_t, flags) as usize }\n     }\n \n     pub fn stats_print() {\n@@ -277,7 +278,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::malloc(size as libc::size_t) as *mut u8\n         } else {\n@@ -294,7 +295,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n         } else {\n@@ -306,18 +307,18 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: uint, _size: uint,\n-                                     _align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n+                                     _align: usize) -> usize {\n         old_size\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: uint, _align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n         libc::free(ptr as *mut libc::c_void)\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, _align: uint) -> uint {\n+    pub fn usable_size(size: usize, _align: usize) -> usize {\n         size\n     }\n \n@@ -341,7 +342,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::malloc(size as size_t) as *mut u8\n         } else {\n@@ -350,7 +351,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::realloc(ptr as *mut c_void, size as size_t) as *mut u8\n         } else {\n@@ -359,13 +360,13 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: uint, _size: uint,\n-                                     _align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n+                                     _align: usize) -> usize {\n         old_size\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: uint, align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n         if align <= MIN_ALIGN {\n             libc::free(ptr as *mut libc::c_void)\n         } else {\n@@ -374,7 +375,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, _align: uint) -> uint {\n+    pub fn usable_size(size: usize, _align: usize) -> usize {\n         size\n     }\n "}, {"sha": "0e6266f9cbc578f395c255e20df4bb322d8ab79d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -70,7 +70,6 @@\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n-#![feature(int_uint)]\n #![feature(unboxed_closures)]\n #![feature(core)]\n #![feature(hash)]"}, {"sha": "ab3c0901bc9563276b8a13660286db43fbf1900b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -40,7 +40,7 @@\n //! }\n //!\n //! struct Gadget {\n-//!     id: int,\n+//!     id: i32,\n //!     owner: Rc<Owner>\n //!     // ...other fields\n //! }\n@@ -99,7 +99,7 @@\n //! }\n //!\n //! struct Gadget {\n-//!     id: int,\n+//!     id: i32,\n //!     owner: Rc<Owner>\n //!     // ...other fields\n //! }\n@@ -166,8 +166,8 @@ use heap::deallocate;\n \n struct RcBox<T> {\n     value: T,\n-    strong: Cell<uint>,\n-    weak: Cell<uint>\n+    strong: Cell<usize>,\n+    weak: Cell<usize>\n }\n \n /// An immutable reference-counted pointer type.\n@@ -233,12 +233,12 @@ impl<T> Rc<T> {\n /// Get the number of weak references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n+pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n+pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n ///\n@@ -447,7 +447,7 @@ impl<T: Default> Default for Rc<T> {\n     /// use std::rc::Rc;\n     /// use std::default::Default;\n     ///\n-    /// let x: Rc<int> = Default::default();\n+    /// let x: Rc<i32> = Default::default();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -750,7 +750,7 @@ trait RcBoxPtr<T> {\n     fn inner(&self) -> &RcBox<T>;\n \n     #[inline]\n-    fn strong(&self) -> uint { self.inner().strong.get() }\n+    fn strong(&self) -> usize { self.inner().strong.get() }\n \n     #[inline]\n     fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }\n@@ -759,7 +759,7 @@ trait RcBoxPtr<T> {\n     fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n \n     #[inline]\n-    fn weak(&self) -> uint { self.inner().weak.get() }\n+    fn weak(&self) -> usize { self.inner().weak.get() }\n \n     #[inline]\n     fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }"}, {"sha": "223c5111f8f4e72e4747c7b10ebaf10808733f00", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -31,7 +31,6 @@\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_destructor)]\n@@ -55,12 +54,12 @@ use std::rt::heap::{allocate, deallocate};\n #[derive(Clone, PartialEq)]\n struct Chunk {\n     data: Rc<RefCell<Vec<u8>>>,\n-    fill: Cell<uint>,\n+    fill: Cell<usize>,\n     is_copy: Cell<bool>,\n }\n \n impl Chunk {\n-    fn capacity(&self) -> uint {\n+    fn capacity(&self) -> usize {\n         self.data.borrow().capacity()\n     }\n \n@@ -105,7 +104,7 @@ impl Arena {\n     }\n \n     /// Allocates a new Arena with `initial_size` bytes preallocated.\n-    pub fn new_with_size(initial_size: uint) -> Arena {\n+    pub fn new_with_size(initial_size: usize) -> Arena {\n         Arena {\n             head: RefCell::new(chunk(initial_size, false)),\n             copy_head: RefCell::new(chunk(initial_size, true)),\n@@ -114,7 +113,7 @@ impl Arena {\n     }\n }\n \n-fn chunk(size: uint, is_copy: bool) -> Chunk {\n+fn chunk(size: usize, is_copy: bool) -> Chunk {\n     Chunk {\n         data: Rc::new(RefCell::new(Vec::with_capacity(size))),\n         fill: Cell::new(0),\n@@ -137,7 +136,7 @@ impl Drop for Arena {\n }\n \n #[inline]\n-fn round_up(base: uint, align: uint) -> uint {\n+fn round_up(base: usize, align: usize) -> usize {\n     (base.checked_add(align - 1)).unwrap() & !(align - 1)\n }\n \n@@ -149,7 +148,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *const uint = mem::transmute(buf.offset(idx as int));\n+        let tydesc_data: *const usize = mem::transmute(buf.offset(idx as isize));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n@@ -160,7 +159,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n-            ((*tydesc).drop_glue)(buf.offset(start as int) as *const i8);\n+            ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n         }\n \n         // Find where the next tydesc lives\n@@ -173,21 +172,21 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // is necessary in order to properly do cleanup if a panic occurs\n // during an initializer.\n #[inline]\n-fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> uint {\n-    p as uint | (is_done as uint)\n+fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> usize {\n+    p as usize | (is_done as usize)\n }\n #[inline]\n-fn un_bitpack_tydesc_ptr(p: uint) -> (*const TyDesc, bool) {\n+fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n     ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n impl Arena {\n-    fn chunk_size(&self) -> uint {\n+    fn chunk_size(&self) -> usize {\n         self.copy_head.borrow().capacity()\n     }\n \n     // Functions for the POD part of the arena\n-    fn alloc_copy_grow(&self, n_bytes: uint, align: uint) -> *const u8 {\n+    fn alloc_copy_grow(&self, n_bytes: usize, align: usize) -> *const u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n@@ -199,7 +198,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy_inner(&self, n_bytes: uint, align: uint) -> *const u8 {\n+    fn alloc_copy_inner(&self, n_bytes: usize, align: usize) -> *const u8 {\n         let start = round_up(self.copy_head.borrow().fill.get(), align);\n \n         let end = start + n_bytes;\n@@ -211,7 +210,7 @@ impl Arena {\n         copy_head.fill.set(end);\n \n         unsafe {\n-            copy_head.as_ptr().offset(start as int)\n+            copy_head.as_ptr().offset(start as isize)\n         }\n     }\n \n@@ -227,8 +226,8 @@ impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&self, n_bytes: uint,\n-                          align: uint) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_grow(&self, n_bytes: usize,\n+                          align: usize) -> (*const u8, *const u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n@@ -240,8 +239,8 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy_inner(&self, n_bytes: uint,\n-                           align: uint) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_inner(&self, n_bytes: usize,\n+                           align: usize) -> (*const u8, *const u8) {\n         // Be careful to not maintain any `head` borrows active, because\n         // `alloc_noncopy_grow` borrows it mutably.\n         let (start, end, tydesc_start, head_capacity) = {\n@@ -265,7 +264,7 @@ impl Arena {\n \n         unsafe {\n             let buf = head.as_ptr();\n-            return (buf.offset(tydesc_start as int), buf.offset(start as int));\n+            return (buf.offset(tydesc_start as isize), buf.offset(start as isize));\n         }\n     }\n \n@@ -276,7 +275,7 @@ impl Arena {\n             let (ty_ptr, ptr) =\n                 self.alloc_noncopy_inner(mem::size_of::<T>(),\n                                          mem::min_align_of::<T>());\n-            let ty_ptr = ty_ptr as *mut uint;\n+            let ty_ptr = ty_ptr as *mut usize;\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n             // has *not* been initialized yet.\n@@ -320,7 +319,7 @@ fn test_arena_destructors() {\n \n #[test]\n fn test_arena_alloc_nested() {\n-    struct Inner { value: uint }\n+    struct Inner { value: usize }\n     struct Outer<'a> { inner: &'a Inner }\n \n     let arena = Arena::new();\n@@ -343,10 +342,10 @@ fn test_arena_destructors_fail() {\n         arena.alloc(|| { Rc::new(i) });\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        arena.alloc(|| { [0u8, 1u8, 2u8] });\n+        arena.alloc(|| { [0u8, 1, 2] });\n     }\n     // Now, panic while allocating\n-    arena.alloc::<Rc<int>, _>(|| {\n+    arena.alloc::<Rc<i32>, _>(|| {\n         panic!();\n     });\n }\n@@ -373,12 +372,12 @@ struct TypedArenaChunk<T> {\n     next: *mut TypedArenaChunk<T>,\n \n     /// The number of elements that this chunk can hold.\n-    capacity: uint,\n+    capacity: usize,\n \n     // Objects follow here, suitably aligned.\n }\n \n-fn calculate_size<T>(capacity: uint) -> uint {\n+fn calculate_size<T>(capacity: usize) -> usize {\n     let mut size = mem::size_of::<TypedArenaChunk<T>>();\n     size = round_up(size, mem::min_align_of::<T>());\n     let elem_size = mem::size_of::<T>();\n@@ -389,7 +388,7 @@ fn calculate_size<T>(capacity: uint) -> uint {\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: uint)\n+    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize)\n            -> *mut TypedArenaChunk<T> {\n         let size = calculate_size::<T>(capacity);\n         let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>())\n@@ -403,13 +402,13 @@ impl<T> TypedArenaChunk<T> {\n     /// Destroys this arena chunk. If the type descriptor is supplied, the\n     /// drop glue is called; otherwise, drop glue is not called.\n     #[inline]\n-    unsafe fn destroy(&mut self, len: uint) {\n+    unsafe fn destroy(&mut self, len: usize) {\n         // Destroy all the allocated objects.\n         if intrinsics::needs_drop::<T>() {\n             let mut start = self.start();\n             for _ in 0..len {\n                 ptr::read(start as *const T); // run the destructor on the pointer\n-                start = start.offset(mem::size_of::<T>() as int)\n+                start = start.offset(mem::size_of::<T>() as isize)\n             }\n         }\n \n@@ -429,7 +428,7 @@ impl<T> TypedArenaChunk<T> {\n     fn start(&self) -> *const u8 {\n         let this: *const TypedArenaChunk<T> = self;\n         unsafe {\n-            mem::transmute(round_up(this.offset(1) as uint,\n+            mem::transmute(round_up(this.offset(1) as usize,\n                                     mem::min_align_of::<T>()))\n         }\n     }\n@@ -439,7 +438,7 @@ impl<T> TypedArenaChunk<T> {\n     fn end(&self) -> *const u8 {\n         unsafe {\n             let size = mem::size_of::<T>().checked_mul(self.capacity).unwrap();\n-            self.start().offset(size as int)\n+            self.start().offset(size as isize)\n         }\n     }\n }\n@@ -454,7 +453,7 @@ impl<T> TypedArena<T> {\n     /// Creates a new `TypedArena` with preallocated space for the given number of\n     /// objects.\n     #[inline]\n-    pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n+    pub fn with_capacity(capacity: usize) -> TypedArena<T> {\n         unsafe {\n             let chunk = TypedArenaChunk::<T>::new(ptr::null_mut(), capacity);\n             TypedArena {\n@@ -501,8 +500,8 @@ impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // Determine how much was filled.\n-            let start = self.first.borrow().as_ref().unwrap().start() as uint;\n-            let end = self.ptr.get() as uint;\n+            let start = self.first.borrow().as_ref().unwrap().start() as usize;\n+            let end = self.ptr.get() as usize;\n             let diff = (end - start) / mem::size_of::<T>();\n \n             // Pass that to the `destroy` method.\n@@ -519,9 +518,9 @@ mod tests {\n \n     #[allow(dead_code)]\n     struct Point {\n-        x: int,\n-        y: int,\n-        z: int,\n+        x: i32,\n+        y: i32,\n+        z: i32,\n     }\n \n     #[test]\n@@ -576,7 +575,7 @@ mod tests {\n     #[allow(dead_code)]\n     struct Noncopy {\n         string: String,\n-        array: Vec<int>,\n+        array: Vec<i32>,\n     }\n \n     #[test]"}, {"sha": "11576fbb00c9b5dcb44710df6d51da75cc0efd02", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -656,15 +656,15 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n }\n \n impl<T: Ord> IntoIterator for BinaryHeap<T> {\n-    type Iter = IntoIter<T>;\n+    type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n-    type Iter = Iter<'a, T>;\n+    type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()"}, {"sha": "6d15a264172a1c53f2b34f0d108a59ead8318c46", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1071,7 +1071,7 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n }\n \n impl<'a> IntoIterator for &'a Bitv {\n-    type Iter = Iter<'a>;\n+    type IntoIter = Iter<'a>;\n \n     fn into_iter(self) -> Iter<'a> {\n         self.iter()\n@@ -1883,7 +1883,7 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n }\n \n impl<'a> IntoIterator for &'a BitvSet {\n-    type Iter = SetIter<'a>;\n+    type IntoIter = SetIter<'a>;\n \n     fn into_iter(self) -> SetIter<'a> {\n         self.iter()"}, {"sha": "2cef08725a2f6aa13294085eb6f56b66de535550", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -463,23 +463,23 @@ impl<K: Ord, V> BTreeMap<K, V> {\n }\n \n impl<K, V> IntoIterator for BTreeMap<K, V> {\n-    type Iter = IntoIter<K, V>;\n+    type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n         self.into_iter()\n     }\n }\n \n impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n-    type Iter = Iter<'a, K, V>;\n+    type IntoIter = Iter<'a, K, V>;\n \n     fn into_iter(self) -> Iter<'a, K, V> {\n         self.iter()\n     }\n }\n \n impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n-    type Iter = IterMut<'a, K, V>;\n+    type IntoIter = IterMut<'a, K, V>;\n \n     fn into_iter(mut self) -> IterMut<'a, K, V> {\n         self.iter_mut()"}, {"sha": "7cb31ab1f6dbec86664400dd1aca636980cc641f", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -481,15 +481,15 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n }\n \n impl<T> IntoIterator for BTreeSet<T> {\n-    type Iter = IntoIter<T>;\n+    type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n-    type Iter = Iter<'a, T>;\n+    type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()"}, {"sha": "a080146e0ec508fe6c2d443de0f21809468d5e27", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -831,23 +831,23 @@ impl<A> FromIterator<A> for DList<A> {\n }\n \n impl<T> IntoIterator for DList<T> {\n-    type Iter = IntoIter<T>;\n+    type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a DList<T> {\n-    type Iter = Iter<'a, T>;\n+    type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a mut DList<T> {\n-    type Iter = IterMut<'a, T>;\n+    type IntoIter = IterMut<'a, T>;\n \n     fn into_iter(mut self) -> IterMut<'a, T> {\n         self.iter_mut()"}, {"sha": "da533d34703dd9574cf9b9a5c97d0af6b3863b3b", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -258,7 +258,7 @@ impl<E:CLike> FromIterator<E> for EnumSet<E> {\n }\n \n impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n-    type Iter = Iter<E>;\n+    type IntoIter = Iter<E>;\n \n     fn into_iter(self) -> Iter<E> {\n         self.iter()"}, {"sha": "a542ee5d47d36c84c14175fc6a63cafdbbf8d950", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -30,7 +30,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsafe_destructor, slicing_syntax)]\n-#![cfg_attr(test, feature(test))]\n+#![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand\n \n #![feature(no_std)]"}, {"sha": "5f1dc1d2ef4ffb0ef8cbf26d871485849c65497c", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1608,23 +1608,23 @@ impl<A> FromIterator<A> for RingBuf<A> {\n }\n \n impl<T> IntoIterator for RingBuf<T> {\n-    type Iter = IntoIter<T>;\n+    type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a RingBuf<T> {\n-    type Iter = Iter<'a, T>;\n+    type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n-    type Iter = IterMut<'a, T>;\n+    type IntoIter = IterMut<'a, T>;\n \n     fn into_iter(mut self) -> IterMut<'a, T> {\n         self.iter_mut()"}, {"sha": "1cd2a89ad604e970bda2f690a1d4b0a7a40abb12", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1388,23 +1388,23 @@ impl<T> FromIterator<T> for Vec<T> {\n }\n \n impl<T> IntoIterator for Vec<T> {\n-    type Iter = IntoIter<T>;\n+    type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a Vec<T> {\n-    type Iter = slice::Iter<'a, T>;\n+    type IntoIter = slice::Iter<'a, T>;\n \n     fn into_iter(self) -> slice::Iter<'a, T> {\n         self.iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a mut Vec<T> {\n-    type Iter = slice::IterMut<'a, T>;\n+    type IntoIter = slice::IterMut<'a, T>;\n \n     fn into_iter(mut self) -> slice::IterMut<'a, T> {\n         self.iter_mut()"}, {"sha": "93d02de9b550e9aaecce48a15da6155f6ded66a6", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -669,23 +669,23 @@ impl<V> FromIterator<(usize, V)> for VecMap<V> {\n }\n \n impl<T> IntoIterator for VecMap<T> {\n-    type Iter = IntoIter<T>;\n+    type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a VecMap<T> {\n-    type Iter = Iter<'a, T>;\n+    type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n-    type Iter = IterMut<'a, T>;\n+    type IntoIter = IterMut<'a, T>;\n \n     fn into_iter(mut self) -> IterMut<'a, T> {\n         self.iter_mut()"}, {"sha": "462b6771b4a9af77a50d635857475953a445f1e8", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -27,7 +27,7 @@\n //! # Examples\n //!\n //! Consider a situation where we want to log out a value passed to a function.\n-//! We know the value we're working on implements Show, but we don't know its\n+//! We know the value we're working on implements Debug, but we don't know its\n //! concrete type.  We want to give special treatment to certain types: in this\n //! case printing out the length of String values prior to their value.\n //! We don't know the concrete type of our value at compile time, so we need to"}, {"sha": "a596fe4a588098685c301244bbf9a9aea8b22b7e", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -49,15 +49,15 @@ macro_rules! array_impls {\n             }\n \n             impl<'a, T> IntoIterator for &'a [T; $N] {\n-                type Iter = Iter<'a, T>;\n+                type IntoIter = Iter<'a, T>;\n \n                 fn into_iter(self) -> Iter<'a, T> {\n                     self.iter()\n                 }\n             }\n \n             impl<'a, T> IntoIterator for &'a mut [T; $N] {\n-                type Iter = IterMut<'a, T>;\n+                type IntoIter = IterMut<'a, T>;\n \n                 fn into_iter(self) -> IterMut<'a, T> {\n                     self.iter_mut()"}, {"sha": "050b34508ff87b5eb7b532df1cdae1dddc70f693", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -151,7 +151,7 @@ use option::Option::{None, Some};\n \n /// A mutable memory location that admits only `Copy` data.\n ///\n-/// See the [module-level documentation](../index.html) for more.\n+/// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n@@ -259,7 +259,7 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n \n /// A mutable memory location with dynamically checked borrow rules\n ///\n-/// See the [module-level documentation](../index.html) for more.\n+/// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n@@ -534,7 +534,7 @@ impl<'b> Clone for BorrowRef<'b> {\n /// Wraps a borrowed reference to a value in a `RefCell` box.\n /// A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n ///\n-/// See the [module-level documentation](../index.html) for more.\n+/// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n@@ -595,7 +595,7 @@ impl<'b> BorrowRefMut<'b> {\n \n /// A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n ///\n-/// See the [module-level documentation](../index.html) for more.\n+/// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with"}, {"sha": "5562845e11d6f087342271866fae955ca30b3664", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -222,12 +222,11 @@ extern \"rust-intrinsic\" {\n \n     /// Unsafely transforms a value of one type into a value of another type.\n     ///\n-    /// Both types must have the same size and alignment, and this guarantee\n-    /// is enforced at compile-time.\n+    /// Both types must have the same size.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::mem;\n     ///\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };"}, {"sha": "7740cd6867cbd2707d96719ee8e1d7b7f7034edf", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -120,14 +120,15 @@ pub trait FromIterator<A> {\n \n /// Conversion into an `Iterator`\n pub trait IntoIterator {\n-    type Iter: Iterator;\n+    type IntoIter: Iterator;\n \n     /// Consumes `Self` and returns an iterator over it\n-    fn into_iter(self) -> Self::Iter;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_iter(self) -> Self::IntoIter;\n }\n \n impl<I> IntoIterator for I where I: Iterator {\n-    type Iter = I;\n+    type IntoIter = I;\n \n     fn into_iter(self) -> I {\n         self\n@@ -967,10 +968,9 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates an iterator that clones the elements it yields. Useful for converting an\n     /// Iterator<&T> to an Iterator<T>.\n     #[unstable(feature = \"core\", reason = \"recent addition\")]\n-    fn cloned<T, D>(self) -> Cloned<Self> where\n-        Self: Iterator<Item=D>,\n-        D: Deref<Target=T>,\n-        T: Clone,\n+    fn cloned(self) -> Cloned<Self> where\n+        Self::Item: Deref,\n+        <Self::Item as Deref>::Output: Clone,\n     {\n         Cloned { it: self }\n     }\n@@ -2646,13 +2646,7 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl ExactSizeIterator for ::ops::Range<$t> {\n-            #[inline]\n-            fn len(&self) -> usize {\n-                debug_assert!(self.end >= self.start);\n-                (self.end - self.start) as usize\n-            }\n-        }\n+        impl ExactSizeIterator for ::ops::Range<$t> { }\n     )*)\n }\n \n@@ -2673,9 +2667,12 @@ impl<A: Int> Iterator for ::ops::Range<A> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        debug_assert!(self.end >= self.start);\n-        let hint = (self.end - self.start).to_uint();\n-        (hint.unwrap_or(0), hint)\n+        if self.start >= self.end {\n+            (0, Some(0))\n+        } else {\n+            let length = (self.end - self.start).to_uint();\n+            (length.unwrap_or(0), length)\n+        }\n     }\n }\n "}, {"sha": "a122bcb2c7aed22fa109fb468c0b5d85b4d75ce4", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -141,6 +141,10 @@ pub mod hash;\n pub mod fmt;\n pub mod error;\n \n+#[doc(primitive = \"bool\")]\n+mod bool {\n+}\n+\n // note: does not need to be public\n mod tuple;\n mod array;"}, {"sha": "bf801a88ca5b3e3c92961ae23a8e72f928fa962f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -522,21 +522,21 @@ impl<T> PartialOrd for *mut T {\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-pub struct Unique<T>(pub *mut T);\n+pub struct Unique<T: ?Sized>(pub *mut T);\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-unsafe impl<T:Send> Send for Unique<T> { }\n+unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-unsafe impl<T:Sync> Sync for Unique<T> { }\n+unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n impl<T> Unique<T> {\n     /// Returns a null Unique."}, {"sha": "459addb09fd721ad78b4dbf1504c86b6f367214a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -628,15 +628,15 @@ impl<'a, T> Default for &'a [T] {\n //\n \n impl<'a, T> IntoIterator for &'a [T] {\n-    type Iter = Iter<'a, T>;\n+    type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n     }\n }\n \n impl<'a, T> IntoIterator for &'a mut [T] {\n-    type Iter = IterMut<'a, T>;\n+    type IntoIter = IterMut<'a, T>;\n \n     fn into_iter(self) -> IterMut<'a, T> {\n         self.iter_mut()"}, {"sha": "72b2d5dc18882d0e1e5a7f9220758491d1911072", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -34,6 +34,7 @@\n //! * `Default`\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(primitive = \"tuple\")]\n \n use clone::Clone;\n use cmp::*;"}, {"sha": "3f8e330b332b8806570069fa615d0fea9487fd5f", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -756,6 +756,7 @@ fn test_range() {\n     // this test is only meaningful when sizeof uint < sizeof u64\n     assert_eq!((uint::MAX - 1..uint::MAX).size_hint(), (1, Some(1)));\n     assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n+    assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n }\n \n #[test]"}, {"sha": "2365b907b3ff5ba4468f951eb4ca7b661b9f8535", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -167,3 +167,12 @@ fn test_set_memory() {\n     unsafe { set_memory(ptr, 5u8, xs.len()); }\n     assert!(xs == [5u8; 20]);\n }\n+\n+#[test]\n+fn test_unsized_unique() {\n+    let xs: &mut [_] = &mut [1, 2, 3];\n+    let ptr = Unique(xs as *mut [_]);\n+    let ys = unsafe { &mut *ptr.0 };\n+    let zs: &mut [_] = &mut [1, 2, 3];\n+    assert!(ys == zs);\n+}"}, {"sha": "a3cae259fd3e5da758c15b5152d9550b7ac2e1fc", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -90,7 +90,6 @@\n \n #![deny(missing_docs)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(int_uint)]\n #![feature(slicing_syntax)]\n #![feature(staged_api)]\n@@ -195,7 +194,7 @@ pub struct Matches {\n }\n \n /// The type returned when the command line does not conform to the\n-/// expected format. Use the `Show` implementation to output detailed\n+/// expected format. Use the `Debug` implementation to output detailed\n /// information.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum Fail {\n@@ -545,7 +544,7 @@ impl Fail {\n     /// Convert a `Fail` enum into an error string.\n     #[unstable(feature = \"rustc_private\")]\n     #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `fmt::String` (`{}` format specifier)\")]\n+                 reason = \"use `fmt::Display` (`{}` format specifier)\")]\n     pub fn to_err_msg(self) -> String {\n         self.to_string()\n     }\n@@ -579,7 +578,7 @@ impl fmt::Display for Fail {\n /// `opt_str`, etc. to interrogate results.\n /// # Panics\n ///\n-/// Returns `Err(Fail)` on failure: use the `Show` implementation of `Fail` to display\n+/// Returns `Err(Fail)` on failure: use the `Debug` implementation of `Fail` to display\n /// information about it.\n pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();"}, {"sha": "94e4012c5ee13f14a8c1fd9b51d18c193b854850", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -15,7 +15,6 @@\n #![cfg_attr(not(feature = \"cargo-build\"), feature(staged_api))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n #![cfg_attr(not(feature = \"cargo-build\"), feature(core))]\n-#![feature(int_uint)]\n #![feature(no_std)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -1905,7 +1904,7 @@ pub mod types {\n                 #[repr(C)]\n                 #[derive(Copy)] pub struct WSAPROTOCOLCHAIN {\n                     pub ChainLen: c_int,\n-                    pub ChainEntries: [DWORD; MAX_PROTOCOL_CHAIN as uint],\n+                    pub ChainEntries: [DWORD; MAX_PROTOCOL_CHAIN as usize],\n                 }\n \n                 pub type LPWSAPROTOCOLCHAIN = *mut WSAPROTOCOLCHAIN;\n@@ -1931,7 +1930,7 @@ pub mod types {\n                     pub iSecurityScheme: c_int,\n                     pub dwMessageSize: DWORD,\n                     pub dwProviderReserved: DWORD,\n-                    pub szProtocol: [u8; (WSAPROTOCOL_LEN as uint) + 1us],\n+                    pub szProtocol: [u8; WSAPROTOCOL_LEN as usize + 1us],\n                 }\n \n                 pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;"}, {"sha": "b5904f23ef364e0e1d4a8d31bbd794efe269de9f", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -50,7 +50,10 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n     let any_exe = session.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeExecutable\n     });\n-    if !any_exe {\n+    let emit_link = session.opts.output_types.iter().any(|ty| {\n+        *ty == config::OutputTypeExe\n+    });\n+    if !any_exe || !emit_link {\n         // No need to find a main function\n         return\n     }"}, {"sha": "5323a32243642cf7c5a6fe434763d9fc680253d4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1549,6 +1549,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return Ok(ParameterBuiltin);\n                 }\n \n+                // Upvars are always local variables or references to\n+                // local variables, and local variables cannot be\n+                // unsized, so the closure struct as a whole must be\n+                // Sized.\n+                if bound == ty::BoundSized {\n+                    return Ok(If(Vec::new()));\n+                }\n+\n                 match self.closure_typer.closure_upvars(def_id, substs) {\n                     Some(upvars) => {\n                         Ok(If(upvars.iter().map(|c| c.ty).collect()))"}, {"sha": "97e6517a61517b6d8be4a426934b72152f6a22a5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -70,7 +70,7 @@ use arena::TypedArena;\n use std::borrow::{BorrowFrom, Cow};\n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::fmt::{self, Show};\n+use std::fmt;\n use std::hash::{Hash, Writer, SipHasher, Hasher};\n use std::mem;\n use std::ops;"}, {"sha": "949fee45517e2840375c14ab2c06d6ee31328f65", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -83,7 +83,7 @@ pub struct Options {\n     pub debuginfo: DebugInfoLevel,\n     pub lint_opts: Vec<(String, lint::Level)>,\n     pub describe_lints: bool,\n-    pub output_types: Vec<OutputType> ,\n+    pub output_types: Vec<OutputType>,\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n@@ -1076,7 +1076,9 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n                                        part));\n                 }\n             };\n-            crate_types.push(new_part)\n+            if !crate_types.contains(&new_part) {\n+                crate_types.push(new_part)\n+            }\n         }\n     }\n "}, {"sha": "10ffb89e728ff4fe08fe4fc3f901b2327d9af0d1", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -118,6 +118,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     match move_from.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n+        mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n         mc::cat_static_item => {\n             bccx.span_err(move_from.span,\n                           &format!(\"cannot move out of {}\","}, {"sha": "96e146fc894f98cddc149c6f850e45546b3519c6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -390,8 +390,8 @@ enum PrivacyResult {\n \n enum FieldName {\n     UnnamedField(uint), // index\n-    // FIXME #6993: change type (and name) from Ident to Name\n-    NamedField(ast::Ident),\n+    // (Name, not Ident, because struct fields are not macro-hygienic)\n+    NamedField(ast::Name),\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n@@ -665,9 +665,9 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                    name: FieldName) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         let field = match name {\n-            NamedField(ident) => {\n-                debug!(\"privacy - check named field {} in struct {:?}\", ident.name, id);\n-                fields.iter().find(|f| f.name == ident.name).unwrap()\n+            NamedField(f_name) => {\n+                debug!(\"privacy - check named field {} in struct {:?}\", f_name, id);\n+                fields.iter().find(|f| f.name == f_name).unwrap()\n             }\n             UnnamedField(idx) => &fields[idx]\n         };\n@@ -686,7 +686,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         };\n         let msg = match name {\n             NamedField(name) => format!(\"field `{}` of {} is private\",\n-                                        token::get_ident(name), struct_desc),\n+                                        token::get_name(name), struct_desc),\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n@@ -873,7 +873,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprField(ref base, ident) => {\n                 if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n-                    self.check_field(expr.span, id, NamedField(ident.node));\n+                    self.check_field(expr.span, id, NamedField(ident.node.name));\n                 }\n             }\n             ast::ExprTupField(ref base, idx) => {\n@@ -897,18 +897,22 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n                 match ty::expr_ty(self.tcx, expr).sty {\n-                    ty::ty_struct(id, _) => {\n-                        for field in &(*fields) {\n-                            self.check_field(expr.span, id,\n-                                             NamedField(field.ident.node));\n+                    ty::ty_struct(ctor_id, _) => {\n+                        // RFC 736: ensure all unmentioned fields are visible.\n+                        // Rather than computing the set of unmentioned fields\n+                        // (i.e. `all_fields - fields`), just check them all.\n+                        let all_fields = ty::lookup_struct_fields(self.tcx, ctor_id);\n+                        for field in all_fields {\n+                            self.check_field(expr.span, ctor_id,\n+                                             NamedField(field.name));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow()[expr.id].clone() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields {\n                                     self.check_field(expr.span, variant_id,\n-                                                     NamedField(field.ident.node));\n+                                                     NamedField(field.ident.node.name));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(expr.span,\n@@ -973,15 +977,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     ty::ty_struct(id, _) => {\n                         for field in fields {\n                             self.check_field(pattern.span, id,\n-                                             NamedField(field.node.ident));\n+                                             NamedField(field.node.ident.name));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get(&pattern.id) {\n                             Some(&def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields {\n                                     self.check_field(pattern.span, variant_id,\n-                                                     NamedField(field.node.ident));\n+                                                     NamedField(field.node.ident.name));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(pattern.span,"}, {"sha": "00f6c6109faeff664728612ccd04a309d3de1fd6", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 47, "deletions": 62, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n+use check::demand;\n use middle::traits::{self, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n use middle::ty::{self, Ty, AsPredicate};\n-use middle::infer;\n use syntax::ast;\n use syntax::codemap::Span;\n use util::nodemap::FnvHashSet;\n@@ -24,71 +24,63 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    source_expr: &ast::Expr,\n                                    target_object_ty: Ty<'tcx>)\n {\n+    let tcx = fcx.tcx();\n     debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n-           cast_expr.repr(fcx.tcx()),\n-           target_object_ty.repr(fcx.tcx()));\n+           cast_expr.repr(tcx),\n+           target_object_ty.repr(tcx));\n \n     // Look up vtables for the type we're casting to,\n     // passing in the source and target type.  The source\n     // must be a pointer type suitable to the object sigil,\n     // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-    let source_ty = fcx.expr_ty(source_expr);\n-    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n-    debug!(\"source_ty={}\", source_ty.repr(fcx.tcx()));\n-    match (&source_ty.sty, &target_object_ty.sty) {\n-        (&ty::ty_uniq(referent_ty), &ty::ty_uniq(object_trait_ty)) => {\n-            let object_trait = object_trait(&object_trait_ty);\n-\n-            // Ensure that if ~T is cast to ~Trait, then T : Trait\n-            push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n-            check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n-        }\n-\n-        (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n-                                                mutbl: referent_mutbl }),\n-         &ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n-                                              mutbl: target_mutbl })) =>\n-        {\n-            let object_trait = object_trait(&object_trait_ty);\n-            if !mutability_allowed(referent_mutbl, target_mutbl) {\n-                span_err!(fcx.tcx().sess, source_expr.span, E0188,\n-                                        \"types differ in mutability\");\n-            } else {\n-                // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n-                push_cast_obligation(fcx, cast_expr,\n-                                     object_trait,\n-                                     referent_ty);\n-\n-                // Ensure that if &'a T is cast to &'b Trait, then 'b <= 'a\n-                infer::mk_subr(fcx.infcx(),\n-                               infer::RelateObjectBound(source_expr.span),\n-                               *target_region,\n-                               *referent_region);\n-\n-                check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n-            }\n-        }\n \n-        (_, &ty::ty_uniq(..)) => {\n-            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0189,\n-                \"can only cast a boxed pointer \\\n-                         to a boxed object, not a {}\",\n-                      ty::ty_sort_string(fcx.tcx(), source_ty));\n+    // First, construct a fresh type that we can feed into `<expr>`\n+    // within `<expr> as <type>` to inform type inference (e.g. to\n+    // tell it that we are expecting a `Box<_>` or an `&_`).\n+    let fresh_ty = fcx.infcx().next_ty_var();\n+    let (object_trait_ty, source_expected_ty) = match target_object_ty.sty {\n+        ty::ty_uniq(object_trait_ty) => {\n+            (object_trait_ty, ty::mk_uniq(fcx.tcx(), fresh_ty))\n         }\n-\n-        (_, &ty::ty_rptr(..)) => {\n-            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0190,\n-                \"can only cast a &-pointer \\\n-                         to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty));\n+        ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n+                                            mutbl: target_mutbl }) => {\n+            (object_trait_ty,\n+             ty::mk_rptr(fcx.tcx(),\n+                         target_region, ty::mt { ty: fresh_ty,\n+                                                 mutbl: target_mutbl }))\n         }\n-\n         _ => {\n-            fcx.tcx().sess.span_bug(\n-                source_expr.span,\n-                \"expected object type\");\n+            fcx.tcx().sess.span_bug(source_expr.span, \"expected object type\");\n         }\n-    }\n+    };\n+\n+    let source_ty = fcx.expr_ty(source_expr);\n+    debug!(\"check_object_cast pre unify source_ty={}\", source_ty.repr(tcx));\n+\n+    // This ensures that the source_ty <: source_expected_ty, which\n+    // will ensure e.g. that &'a T <: &'b T when doing `&'a T as &'b Trait`\n+    //\n+    // FIXME (pnkfelix): do we need to use suptype_with_fn in order to\n+    // override the error message emitted when the types do not work\n+    // out in the manner desired?\n+    demand::suptype(fcx, source_expr.span, source_expected_ty, source_ty);\n+\n+    debug!(\"check_object_cast postunify source_ty={}\", source_ty.repr(tcx));\n+    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n+    debug!(\"check_object_cast resolveto source_ty={}\", source_ty.repr(tcx));\n+\n+    let object_trait = object_trait(&object_trait_ty);\n+\n+    let referent_ty = match source_ty.sty {\n+        ty::ty_uniq(ty) => ty,\n+        ty::ty_rptr(_, ty::mt { ty, mutbl: _ }) => ty,\n+        _ => fcx.tcx().sess.span_bug(source_expr.span,\n+                                     \"expected appropriate reference type\"),\n+    };\n+\n+    // Ensure that if Ptr<T> is cast to Ptr<Trait>, then T : Trait.\n+    push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n+    check_object_safety(tcx, object_trait, source_expr.span);\n \n     fn object_trait<'a, 'tcx>(t: &'a Ty<'tcx>) -> &'a ty::TyTrait<'tcx> {\n         match t.sty {\n@@ -97,13 +89,6 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn mutability_allowed(a_mutbl: ast::Mutability,\n-                          b_mutbl: ast::Mutability)\n-                          -> bool {\n-        a_mutbl == b_mutbl ||\n-            (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n-    }\n-\n     fn push_cast_obligation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       cast_expr: &ast::Expr,\n                                       object_trait: &ty::TyTrait<'tcx>,"}, {"sha": "e916b63eb8dc7f9b9ee96ce256da768f1c6215b9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -10,7 +10,7 @@\n \n //! HTML formatting module\n //!\n-//! This module contains a large number of `fmt::String` implementations for\n+//! This module contains a large number of `fmt::Display` implementations for\n //! various types in `rustdoc::clean`. These implementations all currently\n //! assume that HTML output is desired, although it may be possible to redesign\n //! them in the future to instead emit any format desired."}, {"sha": "7267f95b31f2f136f38d5e3b992b40de37dcb0c3", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -64,7 +64,7 @@\n \n body {\n     color: #333;\n-    font: 16px/1.4 \"Source Serif Pro\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+    font: 16px/1.4 \"Source Serif Pro\", Georgia, Times, \"Times New Roman\", serif;\n     margin: 0;\n     position: relative;\n     padding: 10px 15px 20px 15px;"}, {"sha": "09df9fc8cbb66bc3b12d9abea82537e03c3457ba", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -24,11 +24,8 @@ use rustc::session::{self, config};\n use rustc::session::config::get_unstable_features_setting;\n use rustc::session::search_paths::{SearchPaths, PathKind};\n use rustc_driver::{driver, Compilation};\n-use syntax::ast;\n-use syntax::codemap::{CodeMap, dummy_spanned};\n+use syntax::codemap::CodeMap;\n use syntax::diagnostic;\n-use syntax::parse::token;\n-use syntax::ptr::P;\n \n use core;\n use clean;\n@@ -67,10 +64,7 @@ pub fn run(input: &str,\n                                       span_diagnostic_handler);\n \n     let mut cfg = config::build_configuration(&sess);\n-    cfg.extend(cfgs.into_iter().map(|cfg_| {\n-        let cfg_ = token::intern_and_get_ident(&cfg_);\n-        P(dummy_spanned(ast::MetaWord(cfg_)))\n-    }));\n+    cfg.extend(config::parse_cfgspecs(cfgs).into_iter());\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let krate = driver::phase_2_configure_and_expand(&sess, krate,\n                                                      \"rustdoc-test\", None)"}, {"sha": "daa358647d8e6bec3bcea870fb089d3f74217046", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1032,7 +1032,7 @@ pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<T> {\n \n impl Json {\n     /// Borrow this json object as a pretty object to generate a pretty\n-    /// representation for it via `Show`.\n+    /// representation for it via `Display`.\n     pub fn pretty(&self) -> PrettyJson {\n         PrettyJson { inner: self }\n     }\n@@ -3540,7 +3540,7 @@ mod tests {\n     fn test_hashmap_with_enum_key() {\n         use std::collections::HashMap;\n         use json;\n-        #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Show)]\n+        #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Debug)]\n         enum Enum {\n             Foo,\n             #[allow(dead_code)]"}, {"sha": "ac48481027d6fd53b22c5730e7328a039dbc324e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -338,21 +338,18 @@ mod tests {\n         assert!(\"\".is_ascii());\n         assert!(\"a\".is_ascii());\n         assert!(!\"\\u{2009}\".is_ascii());\n-\n     }\n \n     #[test]\n     fn test_to_ascii_uppercase() {\n         assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n         assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n \n-        let mut i = 0;\n-        while i <= 500 {\n+        for i in 0u32..501 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n                        (from_u32(upper).unwrap()).to_string());\n-            i += 1;\n         }\n     }\n \n@@ -362,13 +359,11 @@ mod tests {\n         // Dotted capital I, Kelvin sign, Sharp S.\n         assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n \n-        let mut i = 0;\n-        while i <= 500 {\n+        for i in 0u32..501 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n                        (from_u32(lower).unwrap()).to_string());\n-            i += 1;\n         }\n     }\n \n@@ -378,13 +373,11 @@ mod tests {\n                    \"URL()URL()URL()\u00fcRL\".to_string());\n         assert_eq!((\"h\u0131\u212a\u00df\".to_string()).into_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n \n-        let mut i = 0;\n-        while i <= 500 {\n+        for i in 0u32..501 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_uppercase(),\n                        (from_u32(upper).unwrap()).to_string());\n-            i += 1;\n         }\n     }\n \n@@ -395,13 +388,11 @@ mod tests {\n         // Dotted capital I, Kelvin sign, Sharp S.\n         assert_eq!((\"H\u0130\u212a\u00df\".to_string()).into_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n \n-        let mut i = 0;\n-        while i <= 500 {\n+        for i in 0u32..501 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_lowercase(),\n                        (from_u32(lower).unwrap()).to_string());\n-            i += 1;\n         }\n     }\n \n@@ -415,14 +406,11 @@ mod tests {\n         assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n         assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n \n-        let mut i = 0;\n-        while i <= 500 {\n-            let c = i;\n-            let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n-                        else { c };\n+        for i in 0u32..501 {\n+            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                        else { i };\n             assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n                     &from_u32(lower).unwrap().to_string()));\n-            i += 1;\n         }\n     }\n }"}, {"sha": "18dd122891daee93c08c2d2e9ae06aeab6acf1f7", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1377,7 +1377,7 @@ impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    type Iter = Iter<'a, K, V>;\n+    type IntoIter = Iter<'a, K, V>;\n \n     fn into_iter(self) -> Iter<'a, K, V> {\n         self.iter()\n@@ -1389,7 +1389,7 @@ impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    type Iter = IterMut<'a, K, V>;\n+    type IntoIter = IterMut<'a, K, V>;\n \n     fn into_iter(mut self) -> IterMut<'a, K, V> {\n         self.iter_mut()\n@@ -1401,7 +1401,7 @@ impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    type Iter = IntoIter<K, V>;\n+    type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n         self.into_iter()"}, {"sha": "de3c0424c9a858073c2a07db44bf76d480921e25", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -840,7 +840,7 @@ impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    type Iter = Iter<'a, T>;\n+    type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n@@ -852,7 +852,7 @@ impl<T, S, H> IntoIterator for HashSet<T, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    type Iter = IntoIter<T>;\n+    type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {\n         self.into_iter()"}, {"sha": "17cfe1c82972f33c6a7a1d30d166bcafee15c82d", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -228,7 +228,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// ```\n     fn into_vec(self) -> Vec<u8>;\n \n-    /// Returns an object that implements `Show` for printing paths\n+    /// Returns an object that implements `Display` for printing paths\n     ///\n     /// # Example\n     ///\n@@ -244,7 +244,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         Display{ path: self, filename: false }\n     }\n \n-    /// Returns an object that implements `Show` for printing filenames\n+    /// Returns an object that implements `Display` for printing filenames\n     ///\n     /// If there is no filename, nothing will be printed.\n     ///"}, {"sha": "526b5edd4cbde8bf5fb1497ff9af81db7c35c9cd", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -723,7 +723,7 @@ extern \"system\" {\n ///     println!(\"{}\", argument);\n /// }\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::args instead\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::env::args() instead\")]\n #[unstable(feature = \"os\")]\n pub fn args() -> Vec<String> {\n     real_args()"}, {"sha": "92b936e74f6542a611a05a0a2bff6de29c780976", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -56,10 +56,6 @@ pub fn stack_guard() -> uint {\n \n pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n-    match thread.name() {\n-        Some(name) => unsafe { ::sys::thread::set_name(name); },\n-        None => {}\n-    }\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n         stack_bounds: stack_bounds,\n         stack_guard: stack_guard,"}, {"sha": "cc9d7492441cd86175a138ad7b325c6332d33573", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -156,6 +156,7 @@ use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n use result::Result::{Err, Ok};\n use sync::{Mutex, Condvar, Arc};\n+use str::Str;\n use string::String;\n use rt::{self, unwind};\n use old_io::{Writer, stdio};\n@@ -280,6 +281,10 @@ impl Builder {\n             unsafe {\n                 stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n             }\n+            match their_thread.name() {\n+                Some(name) => unsafe { imp::set_name(name.as_slice()); },\n+                None => {}\n+            }\n             thread_info::set(\n                 (my_stack_bottom, my_stack_top),\n                 unsafe { imp::guard::current() },"}, {"sha": "5979d339e17a46263cf9abb3cec2626b555ec9a8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -64,7 +64,6 @@ use parse::token;\n use ptr::P;\n \n use std::fmt;\n-use std::fmt::Show;\n use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};"}, {"sha": "7ca0591be5064e9e78745463dcdc29f4b1ac5aa7", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -12,7 +12,7 @@ use attr::AttrMetaMethods;\n use diagnostic::SpanHandler;\n use fold::Folder;\n use {ast, fold, attr};\n-use codemap::Spanned;\n+use codemap::{Spanned, respan};\n use ptr::P;\n \n use util::small_vector::SmallVector;\n@@ -26,6 +26,7 @@ struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate) -> ast::Crate {\n+    let krate = process_cfg_attr(diagnostic, krate);\n     let config = krate.config.clone();\n     strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs))\n }\n@@ -281,3 +282,49 @@ fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attr\n         attr::cfg_matches(diagnostic, cfg, &*mis[0])\n     })\n }\n+\n+struct CfgAttrFolder<'a> {\n+    diag: &'a SpanHandler,\n+    config: ast::CrateConfig,\n+}\n+\n+// Process `#[cfg_attr]`.\n+fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate) -> ast::Crate {\n+    let mut fld = CfgAttrFolder {\n+        diag: diagnostic,\n+        config: krate.config.clone(),\n+    };\n+    fld.fold_crate(krate)\n+}\n+\n+impl<'a> fold::Folder for CfgAttrFolder<'a> {\n+    fn fold_attribute(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n+        if !attr.check_name(\"cfg_attr\") {\n+            return fold::noop_fold_attribute(attr, self);\n+        }\n+\n+        let (cfg, mi) = match attr.meta_item_list() {\n+            Some([ref cfg, ref mi]) => (cfg, mi),\n+            _ => {\n+                self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                return None;\n+            }\n+        };\n+\n+        if attr::cfg_matches(self.diag, &self.config[], &cfg) {\n+            Some(respan(mi.span, ast::Attribute_ {\n+                id: attr::mk_attr_id(),\n+                style: attr.node.style,\n+                value: mi.clone(),\n+                is_sugared_doc: false,\n+            }))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // Need the ability to run pre-expansion.\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n+    }\n+}"}, {"sha": "83a4d938bb5d5567ef9af4fc4fea835aa4e2d2e8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -518,10 +518,11 @@ fn highlight_lines(err: &mut EmitterWriter,\n             let count = match lastc {\n                 // Most terminals have a tab stop every eight columns by default\n                 '\\t' => 8 - col%8,\n-                _ => lastc.width(false).unwrap_or(1),\n+                _ => lastc.width(false).unwrap_or(0),\n             };\n             col += count;\n-            s.extend(::std::iter::repeat('~').take(count - 1));\n+            s.extend(::std::iter::repeat('~').take(count));\n+\n             let hi = cm.lookup_char_pos(sp.hi);\n             if hi.col != lo.col {\n                 for (pos, ch) in iter {\n@@ -534,6 +535,12 @@ fn highlight_lines(err: &mut EmitterWriter,\n                     s.extend(::std::iter::repeat('~').take(count));\n                 }\n             }\n+\n+            if s.len() > 1 {\n+                // One extra squiggly is replaced by a \"^\"\n+                s.pop();\n+            }\n+\n             try!(print_maybe_styled(err,\n                                     &format!(\"{}\\n\", s)[],\n                                     term::attr::ForegroundColor(lvl.color())));"}, {"sha": "64ae6162ef4e56060ffd95e56c3a30fec5b607c7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -528,8 +528,6 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n     syntax_expanders.insert(intern(\"cfg\"),\n                             builtin_normal_expander(\n                                     ext::cfg::expand_cfg));\n-    syntax_expanders.insert(intern(\"cfg_attr\"),\n-                            Modifier(box ext::cfg_attr::expand));\n     syntax_expanders.insert(intern(\"trace_macros\"),\n                             builtin_normal_expander(\n                                     ext::trace_macros::expand_trace_macros));"}, {"sha": "5bfd4a9f6111c6a48f4564f2d578eac979c1c83d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -40,6 +40,18 @@ pub trait AstBuilder {\n                 bindings: Vec<P<ast::TypeBinding>> )\n         -> ast::Path;\n \n+    fn qpath(&self, self_type: P<ast::Ty>,\n+             trait_ref: P<ast::TraitRef>,\n+             ident: ast::Ident )\n+        -> P<ast::QPath>;\n+    fn qpath_all(&self, self_type: P<ast::Ty>,\n+                trait_ref: P<ast::TraitRef>,\n+                ident: ast::Ident,\n+                lifetimes: Vec<ast::Lifetime>,\n+                types: Vec<P<ast::Ty>>,\n+                bindings: Vec<P<ast::TypeBinding>> )\n+        -> P<ast::QPath>;\n+\n     // types\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n \n@@ -102,6 +114,7 @@ pub trait AstBuilder {\n     // expressions\n     fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n+    fn expr_qpath(&self, span: Span, qpath: P<ast::QPath>) -> P<ast::Expr>;\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n@@ -330,6 +343,44 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n+    /// Constructs a qualified path.\n+    ///\n+    /// Constructs a path like `<self_type as trait_ref>::ident`.\n+    fn qpath(&self,\n+             self_type: P<ast::Ty>,\n+             trait_ref: P<ast::TraitRef>,\n+             ident: ast::Ident)\n+             -> P<ast::QPath> {\n+        self.qpath_all(self_type, trait_ref, ident, Vec::new(), Vec::new(), Vec::new())\n+    }\n+\n+    /// Constructs a qualified path.\n+    ///\n+    /// Constructs a path like `<self_type as trait_ref>::ident<a, T, A=Bar>`.\n+    fn qpath_all(&self,\n+                 self_type: P<ast::Ty>,\n+                 trait_ref: P<ast::TraitRef>,\n+                 ident: ast::Ident,\n+                 lifetimes: Vec<ast::Lifetime>,\n+                 types: Vec<P<ast::Ty>>,\n+                 bindings: Vec<P<ast::TypeBinding>> )\n+                 -> P<ast::QPath> {\n+        let segment = ast::PathSegment {\n+            identifier: ident,\n+            parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                lifetimes: lifetimes,\n+                types: OwnedSlice::from_vec(types),\n+                bindings: OwnedSlice::from_vec(bindings),\n+            })\n+        };\n+\n+        P(ast::QPath {\n+            self_type: self_type,\n+            trait_ref: trait_ref,\n+            item_path: segment,\n+        })\n+    }\n+\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n         ast::MutTy {\n             ty: ty,\n@@ -554,6 +605,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(path.span, ast::ExprPath(path))\n     }\n \n+    /// Constructs a QPath expression.\n+    fn expr_qpath(&self, span: Span, qpath: P<ast::QPath>) -> P<ast::Expr> {\n+        self.expr(span, ast::ExprQPath(qpath))\n+    }\n+\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }"}, {"sha": "72eaa3e47bec6cda739043cacdd1c9b6e2a8c709", "filename": "src/libsyntax/ext/cfg_attr.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Flibsyntax%2Fext%2Fcfg_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Flibsyntax%2Fext%2Fcfg_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg_attr.rs?ref=88d8ba5ab3b1d22288b021708c3d87464e43b880", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast;\n-use attr;\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ptr::P;\n-\n-pub fn expand(cx: &mut ExtCtxt, sp: Span, mi: &ast::MetaItem, it: P<ast::Item>) -> P<ast::Item> {\n-    let (cfg, attr) = match mi.node {\n-        ast::MetaList(_, ref mis) if mis.len() == 2 => (&mis[0], &mis[1]),\n-        _ => {\n-            cx.span_err(sp, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n-            return it;\n-        }\n-    };\n-\n-    let mut out = (*it).clone();\n-    if attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &**cfg) {\n-        out.attrs.push(cx.attribute(attr.span, attr.clone()));\n-    }\n-\n-    P(out)\n-}\n-"}, {"sha": "131bbc4100546985d5436f725fa86c997eef206d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -844,7 +844,7 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n         arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n     let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n     ast::Arm {\n-        attrs: arm.attrs.move_map(|x| fld.fold_attribute(x)),\n+        attrs: fold::fold_attrs(arm.attrs, fld),\n         pats: rewritten_pats,\n         guard: rewritten_guard,\n         body: rewritten_body,\n@@ -1273,7 +1273,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n             let (rewritten_fn_decl, rewritten_body)\n                 = expand_and_rename_fn_decl_and_block(decl, body, fld);\n             SmallVector::one(P(ast::Method {\n-                    attrs: m.attrs.move_map(|a| fld.fold_attribute(a)),\n+                    attrs: fold::fold_attrs(m.attrs, fld),\n                     id: id,\n                     span: fld.new_span(m.span),\n                     node: ast::MethDecl(fld.fold_ident(ident),"}, {"sha": "1fb0642d24ff74fdb0665916b7a66516da204901", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -223,7 +223,7 @@ pub trait Folder : Sized {\n         noop_fold_lifetime_def(l, self)\n     }\n \n-    fn fold_attribute(&mut self, at: Attribute) -> Attribute {\n+    fn fold_attribute(&mut self, at: Attribute) -> Option<Attribute> {\n         noop_fold_attribute(at, self)\n     }\n \n@@ -373,9 +373,13 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n     })\n }\n \n+pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n+    attrs.into_iter().flat_map(|x| fld.fold_attribute(x).into_iter()).collect()\n+}\n+\n pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n     Arm {\n-        attrs: attrs.move_map(|x| fld.fold_attribute(x)),\n+        attrs: fold_attrs(attrs, fld),\n         pats: pats.move_map(|x| fld.fold_pat(x)),\n         guard: guard.map(|x| fld.fold_expr(x)),\n         body: fld.fold_expr(body),\n@@ -475,7 +479,7 @@ pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n         node: Variant_ {\n             id: fld.new_id(id),\n             name: name,\n-            attrs: attrs.move_map(|x| fld.fold_attribute(x)),\n+            attrs: fold_attrs(attrs, fld),\n             kind: match kind {\n                 TupleVariantKind(variant_args) => {\n                     TupleVariantKind(variant_args.move_map(|x|\n@@ -553,17 +557,17 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     })\n }\n \n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n+pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n     let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Spanned {\n+    Some(Spanned {\n         node: Attribute_ {\n             id: id,\n             style: style,\n             value: fld.fold_meta_item(value),\n             is_sugared_doc: is_sugared_doc\n         },\n         span: fld.new_span(span)\n-    }\n+    })\n }\n \n pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mut T)\n@@ -845,8 +849,8 @@ pub fn noop_fold_typedef<T>(t: Typedef, folder: &mut T)\n                             where T: Folder {\n     let new_id = folder.new_id(t.id);\n     let new_span = folder.new_span(t.span);\n-    let new_attrs = t.attrs.iter().map(|attr| {\n-        folder.fold_attribute((*attr).clone())\n+    let new_attrs = t.attrs.iter().flat_map(|attr| {\n+        folder.fold_attribute((*attr).clone()).into_iter()\n     }).collect();\n     let new_ident = folder.fold_ident(t.ident);\n     let new_type = folder.fold_ty(t.typ);\n@@ -866,7 +870,7 @@ pub fn noop_fold_associated_type<T>(at: AssociatedType, folder: &mut T)\n {\n     let new_attrs = at.attrs\n                       .iter()\n-                      .map(|attr| folder.fold_attribute((*attr).clone()))\n+                      .flat_map(|attr| folder.fold_attribute((*attr).clone()).into_iter())\n                       .collect();\n     let new_param = folder.fold_ty_param(at.ty_param);\n     ast::AssociatedType {\n@@ -909,7 +913,7 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n             id: fld.new_id(id),\n             kind: kind,\n             ty: fld.fold_ty(ty),\n-            attrs: attrs.move_map(|a| fld.fold_attribute(a))\n+            attrs: fold_attrs(attrs, fld),\n         },\n         span: fld.new_span(span)\n     }\n@@ -1072,7 +1076,7 @@ pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMetho\n     TypeMethod {\n         id: fld.new_id(id),\n         ident: fld.fold_ident(ident),\n-        attrs: attrs.move_map(|a| fld.fold_attribute(a)),\n+        attrs: fold_attrs(attrs, fld),\n         unsafety: unsafety,\n         abi: abi,\n         decl: fld.fold_fn_decl(decl),\n@@ -1154,7 +1158,7 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n     Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n-        attrs: attrs.move_map(|e| folder.fold_attribute(e)),\n+        attrs: fold_attrs(attrs, folder),\n         node: node,\n         vis: vis,\n         span: folder.new_span(span)\n@@ -1165,7 +1169,7 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n     ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n         id: folder.new_id(id),\n         ident: folder.fold_ident(ident),\n-        attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n+        attrs: fold_attrs(attrs, folder),\n         node: match node {\n             ForeignItemFn(fdec, generics) => {\n                 ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n@@ -1184,7 +1188,7 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n pub fn noop_fold_method<T: Folder>(m: P<Method>, folder: &mut T) -> SmallVector<P<Method>> {\n     SmallVector::one(m.map(|Method {id, attrs, node, span}| Method {\n         id: folder.new_id(id),\n-        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n+        attrs: fold_attrs(attrs, folder),\n         node: match node {\n             MethDecl(ident,\n                      generics,"}, {"sha": "41850ada3e62b3aaec5961b5fdfd77a0fa789648", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -96,7 +96,6 @@ pub mod ext {\n     pub mod base;\n     pub mod build;\n     pub mod cfg;\n-    pub mod cfg_attr;\n     pub mod concat;\n     pub mod concat_idents;\n     pub mod deriving;"}, {"sha": "4c9881645282861a6c6bebfb2243aa114c517cad", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -562,7 +562,7 @@ declare_special_idents_and_keywords! {\n         (45,                         Where,      \"where\");\n         'reserved:\n         (46,                         Alignof,    \"alignof\");\n-        (47,                         Be,         \"be\");\n+        (47,                         Become,     \"become\");\n         (48,                         Offsetof,   \"offsetof\");\n         (49,                         Priv,       \"priv\");\n         (50,                         Pure,       \"pure\");"}, {"sha": "084152f107c1d71561eba30b35fa502f49b901d0", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -52,7 +52,6 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(path)]"}, {"sha": "b71a3be5dcea4ec5630f4877b5e9a8765dfca03c", "filename": "src/test/compile-fail/cfg-attr-cfg-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fcfg-attr-cfg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fcfg-attr-cfg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcfg-attr-cfg-2.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// error-pattern: main function not found\n+// compile-flags: --cfg foo\n+\n+// main is conditionally compiled, but the conditional compilation\n+// is conditional too!\n+\n+#[cfg_attr(foo, cfg(bar))]\n+fn main() { }"}, {"sha": "4867dd8d0b4abac1e8238265c98e8f3cbb9ceae5", "filename": "src/test/compile-fail/cfg-attr-crate-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fcfg-attr-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fcfg-attr-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcfg-attr-crate-2.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// compile-flags: --cfg broken\n+\n+// https://github.com/rust-lang/rust/issues/21833#issuecomment-72353044\n+\n+#![cfg_attr(broken, no_std)] //~ ERROR no_std is experimental\n+\n+fn main() { }"}, {"sha": "51e23a689a1ad148266a61102aa82a54ec66191d", "filename": "src/test/compile-fail/functional-struct-update-respects-privacy.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// RFC 736 (and Issue 21407): functional struct update should respect privacy.\n+\n+// The `foo` module attempts to maintains an invariant that each `S`\n+// has a unique `u64` id.\n+use self::foo::S;\n+mod foo {\n+    use std::cell::{UnsafeCell};\n+\n+    static mut count : UnsafeCell<u64> = UnsafeCell { value: 1 };\n+\n+    pub struct S { pub a: u8, pub b: String, secret_uid: u64 }\n+\n+    pub fn make_secrets(a: u8, b: String) -> S {\n+        let val = unsafe { let p = count.get(); let val = *p; *p = val + 1; val };\n+        println!(\"creating {}, uid {}\", b, val);\n+        S { a: a, b: b, secret_uid: val }\n+    }\n+\n+    impl Drop for S {\n+        fn drop(&mut self) {\n+            println!(\"dropping {}, uid {}\", self.b, self.secret_uid);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let s_1 = foo::make_secrets(3, format!(\"ess one\"));\n+    let s_2 = foo::S { b: format!(\"ess two\"), ..s_1 }; // FRU ...\n+    //~^ ERROR field `secret_uid` of struct `foo::S` is private\n+    println!(\"main forged an S named: {}\", s_2.b);\n+    // at end of scope, ... both s_1 *and* s_2 get dropped.  Boom!\n+}"}, {"sha": "e037ba92b4a6a02e749552bfb6b37b559e06be1f", "filename": "src/test/compile-fail/issue-17551.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -13,6 +13,6 @@\n struct B<T>;\n \n fn main() {\n-    let foo = B;\n-    let closure = || foo; //~ ERROR unable to infer enough type information\n+    let foo = B; //~ ERROR: unable to infer enough type information\n+    let closure = || foo;\n }"}, {"sha": "88945f80eae91a701a612fd9d95d077d7c4554db", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![deny(unused_variables)]\n-#![feature(core)]\n \n fn main() {\n     for _ in 1..101 {"}, {"sha": "929c8ec0fd684eef81bed84c67e68fe818c201cd", "filename": "src/test/compile-fail/issue-20801.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-20801.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-20801.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20801.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// We used to ICE when moving out of a `*mut T` or `*const T`.\n+\n+struct T(u8);\n+\n+static mut GLOBAL_MUT_T: T = T(0);\n+\n+static GLOBAL_T: T = T(0);\n+\n+fn imm_ref() -> &'static T {\n+    unsafe { &GLOBAL_T }\n+}\n+\n+fn mut_ref() -> &'static mut T {\n+    unsafe { &mut GLOBAL_MUT_T }\n+}\n+\n+fn mut_ptr() -> *mut T {\n+    unsafe { 0u8 as *mut T }\n+}\n+\n+fn const_ptr() -> *const T {\n+    unsafe { 0u8 as *const T }\n+}\n+\n+pub fn main() {\n+    let a = unsafe { *mut_ref() };\n+    //~^ ERROR cannot move out of borrowed content\n+\n+    let b = unsafe { *imm_ref() };\n+    //~^ ERROR cannot move out of borrowed content\n+\n+    let c = unsafe { *mut_ptr() };\n+    //~^ ERROR cannot move out of dereference of unsafe pointer\n+\n+    let d = unsafe { *const_ptr() };\n+    //~^ ERROR cannot move out of dereference of unsafe pointer\n+}"}, {"sha": "79df16c8979decc1ce2b5617cc4b18e3f696d6e8", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -11,7 +11,6 @@\n #![deny(unreachable_code)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(core)]\n \n fn fail_len(v: Vec<isize> ) -> usize {\n     let mut i = 3;"}, {"sha": "ac4b8a5f3090b09102e7452c2af3277ebe1b339c", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -11,7 +11,6 @@\n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types)]\n-#![feature(core)]\n \n fn f1(x: isize) {\n     //~^ ERROR unused variable: `x`"}, {"sha": "82e9ebc10d1c8ebeed6fca10b6bdbe12d8aa8874", "filename": "src/test/compile-fail/reserved-become.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Freserved-become.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Fcompile-fail%2Freserved-become.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-become.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    let be = 0;\n-    //~^ ERROR `be` is a reserved keyword\n+    let become = 0;\n+    //~^ ERROR `become` is a reserved keyword\n }", "previous_filename": "src/test/parse-fail/reserved-be.rs"}, {"sha": "477b85f362a29876e72d08d651dbdb44e3a6817d", "filename": "src/test/run-make/c-link-to-rust-staticlib/Makefile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1,9 +1,7 @@\n -include ../tools.mk\n \n ifndef IS_WINDOWS\n-ifneq ($(shell uname),Darwin)\n-\tEXTRAFLAGS := -lm -lrt -ldl -lpthread\n-endif\n+EXTRAFLAGS := $(EXTRACFLAGS)\n endif\n \n # FIXME: ignore freebsd"}, {"sha": "e33279966c97187be0c905c72e015b60c66345ce", "filename": "src/test/run-make/duplicate-output-flavors/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fduplicate-output-flavors%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fduplicate-output-flavors%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fduplicate-output-flavors%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -2,3 +2,4 @@ include ../tools.mk\n \n all:\n \t$(RUSTC) --crate-type=rlib foo.rs\n+\t$(RUSTC) --crate-type=rlib,rlib foo.rs"}, {"sha": "f55a2cc3bb158758462e3131fbbf7e21ccc7e60e", "filename": "src/test/run-make/empty-file/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fempty-file%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fempty-file%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fempty-file%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --emit=asm,llvm-bc,llvm-ir,obj,dep-info empty.rs\n+\t$(RUSTC) --emit=link --crate-type=rlib,dylib,staticlib empty.rs"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/run-make/empty-file/empty.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fempty-file%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fempty-file%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fempty-file%2Fempty.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc"}, {"sha": "0f927320c4e58b0e29be1498f3f6677d099de122", "filename": "src/test/run-make/issue-22131/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all: foo.rs\n+\t$(RUSTC) --cfg 'feature=\"bar\"' --crate-type lib foo.rs\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) --test --cfg 'feature=\"bar\"' \\\n+\t\t-L $(TMPDIR) foo.rs |\\\n+\t\tgrep --quiet 'test foo_0 ... ok'"}, {"sha": "0b1f1291df0665b5bff30d60b600a27fc1c77a28", "filename": "src/test/run-make/issue-22131/foo.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fissue-22131%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fissue-22131%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-22131%2Ffoo.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name=\"foo\"]\n+\n+/// ```rust\n+/// assert_eq!(foo::foo(), 1);\n+/// ```\n+#[cfg(feature = \"bar\")]\n+pub fn foo() -> i32 { 1 }"}, {"sha": "5fce35e2beb87774e7c2218145b923cb4e755d94", "filename": "src/test/run-make/no-stack-check/Makefile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fno-stack-check%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fno-stack-check%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-stack-check%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1,6 +1,7 @@\n -include ../tools.mk\n \n ifndef IS_WINDOWS\n+ifneq ($(UNAME),OpenBSD)\n all:\n \t$(RUSTC) -O --emit asm attr.rs\n \t! grep -q morestack $(TMPDIR)/attr.s\n@@ -9,6 +10,10 @@ all:\n \t$(RUSTC) -O --emit asm -C no-stack-check flag.rs\n \t! grep -q morestack $(TMPDIR)/flag.s\n else\n+# On OpenBSD, morestack isn't used as the segmented stacks are disabled\n+all:\n+endif\n+else\n # On Windows we use __chkstk and it only appears in functions with large allocations,\n # so this test wouldn't be reliable.\n all:"}, {"sha": "89f610dee17d05c809ff1e8a91ec61196d8ded0f", "filename": "src/test/run-make/symbols-are-reasonable/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -10,6 +10,6 @@ OUT=$(TMPDIR)/lib.s\n all:\n \t$(RUSTC) lib.rs --emit=asm --crate-type=staticlib\n \t# just check for symbol declarations with the names we're expecting.\n-\tgrep 'str[0-9]\\+:' $(OUT)\n-\tgrep 'binary[0-9]\\+:' $(OUT)\n-\tgrep 'vtable[0-9]\\+' $(OUT)\n+\tgrep 'str[0-9][0-9]*:' $(OUT)\n+\tgrep 'binary[0-9][0-9]*:' $(OUT)\n+\tgrep 'vtable[0-9][0-9]*' $(OUT)"}, {"sha": "db2b253a6f1a7ed9965e2dae62f24ba664b2979f", "filename": "src/test/run-make/target-specs/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1,11 +1,11 @@\n -include ../tools.mk\n all:\n \t$(RUSTC) foo.rs --target=my-awesome-platform.json --crate-type=lib --emit=asm\n-\tgrep --quiet --invert-match morestack < $(TMPDIR)/foo.s\n+\tgrep -q -v morestack < $(TMPDIR)/foo.s\n \t$(RUSTC) foo.rs --target=my-invalid-platform.json 2>&1 | grep --quiet \"Error loading target specification\"\n \t$(RUSTC) foo.rs --target=my-incomplete-platform.json 2>&1 | grep 'Field llvm-target'\n \tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=my-awesome-platform --crate-type=lib --emit=asm\n \tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=x86_64-unknown-linux-gnu --crate-type=lib --emit=asm\n \t# The built-in target *should* override the one we have here, and thus we\n \t# should have morestack\n-\tgrep --quiet morestack < $(TMPDIR)/foo.s\n+\tgrep -q morestack < $(TMPDIR)/foo.s"}, {"sha": "bdce7b7810aaf4581c7cc75fd5d25016b6f29e97", "filename": "src/test/run-make/use-extern-for-plugins/Makefile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fuse-extern-for-plugins%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-make%2Fuse-extern-for-plugins%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fuse-extern-for-plugins%2FMakefile?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -1,5 +1,6 @@\n -include ../tools.mk\n \n+ifneq ($(UNAME),OpenBSD)\n HOST := $(shell $(RUSTC) -vV | grep 'host:' | sed 's/host: //')\n ifeq ($(findstring i686,$(HOST)),i686)\n TARGET := $(subst i686,x86_64,$(HOST))\n@@ -11,3 +12,7 @@ all:\n \t$(RUSTC) foo.rs -C extra-filename=-host\n \t$(RUSTC) bar.rs -C extra-filename=-targ --target $(TARGET)\n \t$(RUSTC) baz.rs --extern a=$(TMPDIR)/liba-targ.rlib --target $(TARGET)\n+else\n+# OpenBSD support only x86_64 architecture for now\n+all:\n+endif"}, {"sha": "09ab70194864f1b6905858c6f2a866620128f451", "filename": "src/test/run-pass/cfg-attr-cfg.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Fcfg-attr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Fcfg-attr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-attr-cfg.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// main is conditionally compiled, but the conditional compilation\n+// is conditional too!\n+\n+#[cfg_attr(foo, cfg(bar))]\n+fn main() { }"}, {"sha": "e6bd8afad280b98e928883216ea6c851512280df", "filename": "src/test/run-pass/cfg-attr-crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Fcfg-attr-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Fcfg-attr-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-attr-crate.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/21833#issuecomment-72353044\n+\n+#![cfg_attr(not_used, no_std)]\n+\n+fn main() { }"}, {"sha": "979e76b1ff994a4dd4d62a2cc8f4040e5afb3ee0", "filename": "src/test/run-pass/infer-container-across-object-cast.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Given `<expr> as Box<Trait>`, we should be able to infer that a\n+// `Box<_>` is the expected type.\n+\n+trait Foo { fn foo(&self) -> u32; }\n+impl Foo for u32 { fn foo(&self) -> u32 { *self } }\n+\n+// (another impl to ensure trait-matching cannot just choose from a singleton set)\n+impl Foo for  () { fn foo(&self) -> u32 { -176 } }\n+\n+trait Boxed { fn make() -> Self; }\n+impl Boxed for Box<u32> { fn make() -> Self { Box::new(7) } }\n+\n+// (another impl to ensure trait-matching cannot just choose from a singleton set)\n+impl Boxed for () { fn make() -> Self { () } }\n+\n+fn boxed_foo() {\n+    let b7 = Boxed::make() as Box<Foo>;\n+    assert_eq!(b7.foo(), 7);\n+}\n+\n+trait Refed<'a,T> { fn make(&'a T) -> Self; }\n+impl<'a> Refed<'a, u32> for &'a u32 { fn make(x: &'a u32) -> Self { x } }\n+\n+// (another impl to ensure trait-matching cannot just choose from a singleton set)\n+impl<'a,'b> Refed<'a, ()> for &'b () { fn make(_: &'a ()) -> Self { static U: () = (); &U } }\n+\n+fn refed_foo() {\n+    let a = 8;\n+    let b7 = Refed::make(&a) as &Foo;\n+    assert_eq!(b7.foo(), 8);\n+}\n+\n+fn check_subtyping_works() {\n+    fn inner<'short, 'long:'short>(_s: &'short u32,\n+                                   l: &'long u32) -> &'short (Foo+'short) {\n+        Refed::make(l) as &Foo\n+    }\n+\n+    let a = 9;\n+    let b = 10;\n+    let r = inner(&b, &a);\n+    assert_eq!(r.foo(), 9);\n+}\n+\n+pub fn main() {\n+    boxed_foo();\n+    refed_foo();\n+    check_subtyping_works();\n+}"}, {"sha": "087ef5dcf05e4a08bc529f342eb174f596269434", "filename": "src/test/run-pass/unboxed-closures-infer-upvar.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87efef2cceaec99d30e809cac2b8d22b9e25fc/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs?ref=bc87efef2cceaec99d30e809cac2b8d22b9e25fc", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the type variable in the type(`Vec<_>`) of a closed over\n+// variable does not interfere with type inference.\n+\n+fn f<F: FnMut()>(mut f: F) {\n+    f();\n+}\n+\n+fn main() {\n+    let mut v: Vec<_> = vec![];\n+    f(|| v.push(0));\n+    assert_eq!(v, vec![0]);\n+}"}]}