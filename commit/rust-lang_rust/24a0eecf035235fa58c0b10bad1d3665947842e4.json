{"sha": "24a0eecf035235fa58c0b10bad1d3665947842e4", "node_id": "C_kwDOAAsO6NoAKDI0YTBlZWNmMDM1MjM1ZmE1OGMwYjEwYmFkMWQzNjY1OTQ3ODQyZTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T17:53:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T17:53:59Z"}, "message": "Auto merge of #96657 - cuviper:time64, r=joshtriplett\n\nUse 64-bit time on 32-bit linux-gnu\n\nThe standard library suffered the [Year 2038 problem][Y2038] in two main places on targets with 32-bit `time_t`:\n\n- In `std::time::SystemTime`, we stored a `timespec` that has `time_t` seconds. This is now changed to directly store 64-bit seconds and nanoseconds, and on 32-bit linux-gnu we try to use `__clock_gettime64` (glibc 2.34+) to get the larger timestamp.\n\n- In `std::fs::Metadata`, we store a `stat64`, which has 64-bit `off_t` but still 32-bit `time_t`, and unfortunately that is baked in the API by the (deprecated) `MetadataExt::as_raw_stat()`. However, we can use `statx` for 64-bit `statx_timestamp` to store in addition to the `stat64`, as we already do to support creation time, and the rest of the `MetadataExt` methods can return those full values. Note that some filesystems may still be limited in their actual timestamp support, but that's not something Rust can change.\n\nThere remain a few places that need `timespec` for system call timeouts -- I leave that to future work.\n\n[Y2038]: https://en.wikipedia.org/wiki/Year_2038_problem", "tree": {"sha": "d38c1a7a4d82a081753ac8410f611c5c754c73b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d38c1a7a4d82a081753ac8410f611c5c754c73b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24a0eecf035235fa58c0b10bad1d3665947842e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24a0eecf035235fa58c0b10bad1d3665947842e4", "html_url": "https://github.com/rust-lang/rust/commit/24a0eecf035235fa58c0b10bad1d3665947842e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24a0eecf035235fa58c0b10bad1d3665947842e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9b2e3c87b76c03cc398be8b8f65d096c0583eb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b2e3c87b76c03cc398be8b8f65d096c0583eb2", "html_url": "https://github.com/rust-lang/rust/commit/f9b2e3c87b76c03cc398be8b8f65d096c0583eb2"}, {"sha": "f9675185a32564a8b0c455ec1da16c9a62e74b4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9675185a32564a8b0c455ec1da16c9a62e74b4d", "html_url": "https://github.com/rust-lang/rust/commit/f9675185a32564a8b0c455ec1da16c9a62e74b4d"}], "stats": {"total": 373, "additions": 205, "deletions": 168}, "files": [{"sha": "23267c44685b00df3dc8887262e36a4bbb6d414a", "filename": "library/std/src/os/linux/fs.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs?ref=24a0eecf035235fa58c0b10bad1d3665947842e4", "patch": "@@ -356,19 +356,34 @@ impl MetadataExt for Metadata {\n         self.as_inner().as_inner().st_size as u64\n     }\n     fn st_atime(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime as i64\n+        let file_attr = self.as_inner();\n+        #[cfg(all(target_env = \"gnu\", target_pointer_width = \"32\"))]\n+        if let Some(atime) = file_attr.stx_atime() {\n+            return atime.tv_sec;\n+        }\n+        file_attr.as_inner().st_atime as i64\n     }\n     fn st_atime_nsec(&self) -> i64 {\n         self.as_inner().as_inner().st_atime_nsec as i64\n     }\n     fn st_mtime(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime as i64\n+        let file_attr = self.as_inner();\n+        #[cfg(all(target_env = \"gnu\", target_pointer_width = \"32\"))]\n+        if let Some(mtime) = file_attr.stx_mtime() {\n+            return mtime.tv_sec;\n+        }\n+        file_attr.as_inner().st_mtime as i64\n     }\n     fn st_mtime_nsec(&self) -> i64 {\n         self.as_inner().as_inner().st_mtime_nsec as i64\n     }\n     fn st_ctime(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime as i64\n+        let file_attr = self.as_inner();\n+        #[cfg(all(target_env = \"gnu\", target_pointer_width = \"32\"))]\n+        if let Some(ctime) = file_attr.stx_ctime() {\n+            return ctime.tv_sec;\n+        }\n+        file_attr.as_inner().st_ctime as i64\n     }\n     fn st_ctime_nsec(&self) -> i64 {\n         self.as_inner().as_inner().st_ctime_nsec as i64"}, {"sha": "61fb2814018e0f7817784384b0dd149d90ddda56", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=24a0eecf035235fa58c0b10bad1d3665947842e4", "patch": "@@ -113,10 +113,19 @@ cfg_has_statx! {{\n         // This is needed to check if btime is supported by the filesystem.\n         stx_mask: u32,\n         stx_btime: libc::statx_timestamp,\n+        // With statx, we can overcome 32-bit `time_t` too.\n+        #[cfg(target_pointer_width = \"32\")]\n+        stx_atime: libc::statx_timestamp,\n+        #[cfg(target_pointer_width = \"32\")]\n+        stx_ctime: libc::statx_timestamp,\n+        #[cfg(target_pointer_width = \"32\")]\n+        stx_mtime: libc::statx_timestamp,\n+\n     }\n \n-    // We prefer `statx` on Linux if available, which contains file creation time.\n-    // Default `stat64` contains no creation time.\n+    // We prefer `statx` on Linux if available, which contains file creation time,\n+    // as well as 64-bit timestamps of all kinds.\n+    // Default `stat64` contains no creation time and may have 32-bit `time_t`.\n     unsafe fn try_statx(\n         fd: c_int,\n         path: *const c_char,\n@@ -192,6 +201,13 @@ cfg_has_statx! {{\n         let extra = StatxExtraFields {\n             stx_mask: buf.stx_mask,\n             stx_btime: buf.stx_btime,\n+            // Store full times to avoid 32-bit `time_t` truncation.\n+            #[cfg(target_pointer_width = \"32\")]\n+            stx_atime: buf.stx_atime,\n+            #[cfg(target_pointer_width = \"32\")]\n+            stx_ctime: buf.stx_ctime,\n+            #[cfg(target_pointer_width = \"32\")]\n+            stx_mtime: buf.stx_mtime,\n         };\n \n         Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n@@ -310,6 +326,36 @@ cfg_has_statx! {{\n         fn from_stat64(stat: stat64) -> Self {\n             Self { stat, statx_extra_fields: None }\n         }\n+\n+        #[cfg(target_pointer_width = \"32\")]\n+        pub fn stx_mtime(&self) -> Option<&libc::statx_timestamp> {\n+            if let Some(ext) = &self.statx_extra_fields {\n+                if (ext.stx_mask & libc::STATX_MTIME) != 0 {\n+                    return Some(&ext.stx_mtime);\n+                }\n+            }\n+            None\n+        }\n+\n+        #[cfg(target_pointer_width = \"32\")]\n+        pub fn stx_atime(&self) -> Option<&libc::statx_timestamp> {\n+            if let Some(ext) = &self.statx_extra_fields {\n+                if (ext.stx_mask & libc::STATX_ATIME) != 0 {\n+                    return Some(&ext.stx_atime);\n+                }\n+            }\n+            None\n+        }\n+\n+        #[cfg(target_pointer_width = \"32\")]\n+        pub fn stx_ctime(&self) -> Option<&libc::statx_timestamp> {\n+            if let Some(ext) = &self.statx_extra_fields {\n+                if (ext.stx_mask & libc::STATX_CTIME) != 0 {\n+                    return Some(&ext.stx_ctime);\n+                }\n+            }\n+            None\n+        }\n     }\n } else {\n     impl FileAttr {\n@@ -335,59 +381,52 @@ impl FileAttr {\n #[cfg(target_os = \"netbsd\")]\n impl FileAttr {\n     pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_mtime as libc::time_t,\n-            tv_nsec: self.stat.st_mtimensec as libc::c_long,\n-        }))\n+        Ok(SystemTime::new(self.stat.st_mtime as i64, self.stat.st_mtimensec as i64))\n     }\n \n     pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_atime as libc::time_t,\n-            tv_nsec: self.stat.st_atimensec as libc::c_long,\n-        }))\n+        Ok(SystemTime::new(self.stat.st_atime as i64, self.stat.st_atimensec as i64))\n     }\n \n     pub fn created(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_birthtime as libc::time_t,\n-            tv_nsec: self.stat.st_birthtimensec as libc::c_long,\n-        }))\n+        Ok(SystemTime::new(self.stat.st_birthtime as i64, self.stat.st_birthtimensec as i64))\n     }\n }\n \n #[cfg(not(target_os = \"netbsd\"))]\n impl FileAttr {\n     #[cfg(all(not(target_os = \"vxworks\"), not(target_os = \"espidf\")))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_mtime as libc::time_t,\n-            tv_nsec: self.stat.st_mtime_nsec as _,\n-        }))\n+        #[cfg(target_pointer_width = \"32\")]\n+        cfg_has_statx! {\n+            if let Some(mtime) = self.stx_mtime() {\n+                return Ok(SystemTime::new(mtime.tv_sec, mtime.tv_nsec as i64));\n+            }\n+        }\n+\n+        Ok(SystemTime::new(self.stat.st_mtime as i64, self.stat.st_mtime_nsec as i64))\n     }\n \n     #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_mtime as libc::time_t,\n-            tv_nsec: 0,\n-        }))\n+        Ok(SystemTime::new(self.stat.st_mtime as i64, 0))\n     }\n \n     #[cfg(all(not(target_os = \"vxworks\"), not(target_os = \"espidf\")))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_atime as libc::time_t,\n-            tv_nsec: self.stat.st_atime_nsec as _,\n-        }))\n+        #[cfg(target_pointer_width = \"32\")]\n+        cfg_has_statx! {\n+            if let Some(atime) = self.stx_atime() {\n+                return Ok(SystemTime::new(atime.tv_sec, atime.tv_nsec as i64));\n+            }\n+        }\n+\n+        Ok(SystemTime::new(self.stat.st_atime as i64, self.stat.st_atime_nsec as i64))\n     }\n \n     #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_atime as libc::time_t,\n-            tv_nsec: 0,\n-        }))\n+        Ok(SystemTime::new(self.stat.st_atime as i64, 0))\n     }\n \n     #[cfg(any(\n@@ -397,10 +436,7 @@ impl FileAttr {\n         target_os = \"ios\"\n     ))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_birthtime as libc::time_t,\n-            tv_nsec: self.stat.st_birthtime_nsec as libc::c_long,\n-        }))\n+        Ok(SystemTime::new(self.stat.st_birthtime as i64, self.stat.st_birthtime_nsec as i64))\n     }\n \n     #[cfg(not(any(\n@@ -413,10 +449,7 @@ impl FileAttr {\n         cfg_has_statx! {\n             if let Some(ext) = &self.statx_extra_fields {\n                 return if (ext.stx_mask & libc::STATX_BTIME) != 0 {\n-                    Ok(SystemTime::from(libc::timespec {\n-                        tv_sec: ext.stx_btime.tv_sec as libc::time_t,\n-                        tv_nsec: ext.stx_btime.tv_nsec as _,\n-                    }))\n+                    Ok(SystemTime::new(ext.stx_btime.tv_sec, ext.stx_btime.tv_nsec as i64))\n                 } else {\n                     Err(io::const_io_error!(\n                         io::ErrorKind::Uncategorized,"}, {"sha": "c1966d6707856887f2c7c5c927ddcbaa61a35e0f", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=24a0eecf035235fa58c0b10bad1d3665947842e4", "patch": "@@ -24,8 +24,9 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n     // Calculate the timeout as an absolute timespec.\n     //\n     // Overflows are rounded up to an infinite timeout (None).\n-    let timespec =\n-        timeout.and_then(|d| Some(Timespec::now(libc::CLOCK_MONOTONIC).checked_add_duration(&d)?));\n+    let timespec = timeout\n+        .and_then(|d| Some(Timespec::now(libc::CLOCK_MONOTONIC).checked_add_duration(&d)?))\n+        .and_then(|t| t.to_timespec());\n \n     loop {\n         // No need to wait if the value already changed.\n@@ -41,7 +42,7 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n                     // identical. It supports absolute timeouts through a flag\n                     // in the _umtx_time struct.\n                     let umtx_timeout = timespec.map(|t| libc::_umtx_time {\n-                        _timeout: t.t,\n+                        _timeout: t,\n                         _flags: libc::UMTX_ABSTIME,\n                         _clockid: libc::CLOCK_MONOTONIC as u32,\n                     });\n@@ -62,7 +63,7 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n                         futex as *const AtomicU32,\n                         libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,\n                         expected,\n-                        timespec.as_ref().map_or(null(), |t| &t.t as *const libc::timespec),\n+                        timespec.as_ref().map_or(null(), |t| t as *const libc::timespec),\n                         null::<u32>(), // This argument is unused for FUTEX_WAIT_BITSET.\n                         !0u32,         // A full bitmask, to make it behave like a regular FUTEX_WAIT.\n                     )"}, {"sha": "30ed2ec7f5442964b1addc4c2a374ff36a2e721f", "filename": "library/std/src/sys/unix/thread_parker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs?ref=24a0eecf035235fa58c0b10bad1d3665947842e4", "patch": "@@ -79,7 +79,8 @@ unsafe fn wait_timeout(\n         (Timespec::now(libc::CLOCK_MONOTONIC), dur)\n     };\n \n-    let timeout = now.checked_add_duration(&dur).map(|t| t.t).unwrap_or(TIMESPEC_MAX);\n+    let timeout =\n+        now.checked_add_duration(&dur).and_then(|t| t.to_timespec()).unwrap_or(TIMESPEC_MAX);\n     let r = libc::pthread_cond_timedwait(cond, lock, &timeout);\n     debug_assert!(r == libc::ETIMEDOUT || r == 0);\n }"}, {"sha": "ac8355188bb3c208e13fe5bb7eb5f59e8fb697a1", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 109, "deletions": 122, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a0eecf035235fa58c0b10bad1d3665947842e4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=24a0eecf035235fa58c0b10bad1d3665947842e4", "patch": "@@ -1,44 +1,86 @@\n-use crate::cmp::Ordering;\n+use crate::fmt;\n use crate::time::Duration;\n \n-use core::hash::{Hash, Hasher};\n-\n-pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n+pub use self::inner::Instant;\n use crate::convert::TryInto;\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n+pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct SystemTime {\n+    pub(in crate::sys::unix) t: Timespec,\n+}\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(in crate::sys::unix) struct Timespec {\n-    pub t: libc::timespec,\n+    tv_sec: i64,\n+    tv_nsec: i64,\n+}\n+\n+impl SystemTime {\n+    pub fn new(tv_sec: i64, tv_nsec: i64) -> SystemTime {\n+        SystemTime { t: Timespec::new(tv_sec, tv_nsec) }\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n+        self.t.sub_timespec(&other.t)\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n+    }\n+\n+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n+    }\n+}\n+\n+impl From<libc::timespec> for SystemTime {\n+    fn from(t: libc::timespec) -> SystemTime {\n+        SystemTime { t: Timespec::from(t) }\n+    }\n+}\n+\n+impl fmt::Debug for SystemTime {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SystemTime\")\n+            .field(\"tv_sec\", &self.t.tv_sec)\n+            .field(\"tv_nsec\", &self.t.tv_nsec)\n+            .finish()\n+    }\n }\n \n impl Timespec {\n     const fn zero() -> Timespec {\n-        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n+        Timespec { tv_sec: 0, tv_nsec: 0 }\n+    }\n+\n+    fn new(tv_sec: i64, tv_nsec: i64) -> Timespec {\n+        Timespec { tv_sec, tv_nsec }\n     }\n \n     pub fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n         if self >= other {\n             // NOTE(eddyb) two aspects of this `if`-`else` are required for LLVM\n             // to optimize it into a branchless form (see also #75545):\n             //\n-            // 1. `self.t.tv_sec - other.t.tv_sec` shows up as a common expression\n+            // 1. `self.tv_sec - other.tv_sec` shows up as a common expression\n             //    in both branches, i.e. the `else` must have its `- 1`\n             //    subtraction after the common one, not interleaved with it\n-            //    (it used to be `self.t.tv_sec - 1 - other.t.tv_sec`)\n+            //    (it used to be `self.tv_sec - 1 - other.tv_sec`)\n             //\n             // 2. the `Duration::new` call (or any other additional complexity)\n             //    is outside of the `if`-`else`, not duplicated in both branches\n             //\n             // Ideally this code could be rearranged such that it more\n             // directly expresses the lower-cost behavior we want from it.\n-            let (secs, nsec) = if self.t.tv_nsec >= other.t.tv_nsec {\n-                ((self.t.tv_sec - other.t.tv_sec) as u64, (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+            let (secs, nsec) = if self.tv_nsec >= other.tv_nsec {\n+                ((self.tv_sec - other.tv_sec) as u64, (self.tv_nsec - other.tv_nsec) as u32)\n             } else {\n                 (\n-                    (self.t.tv_sec - other.t.tv_sec - 1) as u64,\n-                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n+                    (self.tv_sec - other.tv_sec - 1) as u64,\n+                    self.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.tv_nsec as u32,\n                 )\n             };\n \n@@ -54,89 +96,65 @@ impl Timespec {\n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n         let mut secs = other\n             .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n+            .try_into() // <- target type would be `i64`\n             .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n+            .and_then(|secs| self.tv_sec.checked_add(secs))?;\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n-        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        let mut nsec = other.subsec_nanos() + self.tv_nsec as u32;\n         if nsec >= NSEC_PER_SEC as u32 {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n+        Some(Timespec::new(secs, nsec as i64))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n         let mut secs = other\n             .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n+            .try_into() // <- target type would be `i64`\n             .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n+            .and_then(|secs| self.tv_sec.checked_sub(secs))?;\n \n         // Similar to above, nanos can't overflow.\n-        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        let mut nsec = self.tv_nsec as i32 - other.subsec_nanos() as i32;\n         if nsec < 0 {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n-    }\n-}\n-\n-impl PartialEq for Timespec {\n-    fn eq(&self, other: &Timespec) -> bool {\n-        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n-    }\n-}\n-\n-impl Eq for Timespec {}\n-\n-impl PartialOrd for Timespec {\n-    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n-        Some(self.cmp(other))\n+        Some(Timespec::new(secs, nsec as i64))\n     }\n-}\n \n-impl Ord for Timespec {\n-    fn cmp(&self, other: &Timespec) -> Ordering {\n-        let me = (self.t.tv_sec, self.t.tv_nsec);\n-        let other = (other.t.tv_sec, other.t.tv_nsec);\n-        me.cmp(&other)\n+    pub fn to_timespec(&self) -> Option<libc::timespec> {\n+        use crate::convert::TryInto;\n+        Some(libc::timespec {\n+            tv_sec: self.tv_sec.try_into().ok()?,\n+            tv_nsec: self.tv_nsec.try_into().ok()?,\n+        })\n     }\n }\n \n-impl Hash for Timespec {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.t.tv_sec.hash(state);\n-        self.t.tv_nsec.hash(state);\n+impl From<libc::timespec> for Timespec {\n+    fn from(t: libc::timespec) -> Timespec {\n+        Timespec::new(t.tv_sec as i64, t.tv_nsec as i64)\n     }\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod inner {\n-    use crate::fmt;\n     use crate::sync::atomic::{AtomicU64, Ordering};\n     use crate::sys::cvt;\n     use crate::sys_common::mul_div_u64;\n     use crate::time::Duration;\n \n-    use super::Timespec;\n-    use super::NSEC_PER_SEC;\n+    use super::{SystemTime, Timespec, NSEC_PER_SEC};\n \n     #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n     pub struct Instant {\n         t: u64,\n     }\n \n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub struct SystemTime {\n-        pub(in crate::sys::unix) t: Timespec,\n-    }\n-\n-    pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n-\n     #[repr(C)]\n     #[derive(Copy, Clone)]\n     struct mach_timebase_info {\n@@ -178,41 +196,17 @@ mod inner {\n             cvt(unsafe { libc::gettimeofday(&mut s, ptr::null_mut()) }).unwrap();\n             return SystemTime::from(s);\n         }\n+    }\n \n-        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n-            self.t.sub_timespec(&other.t)\n-        }\n-\n-        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n-        }\n-\n-        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n+    impl From<libc::timeval> for Timespec {\n+        fn from(t: libc::timeval) -> Timespec {\n+            Timespec::new(t.tv_sec as i64, 1000 * t.tv_usec as i64)\n         }\n     }\n \n     impl From<libc::timeval> for SystemTime {\n         fn from(t: libc::timeval) -> SystemTime {\n-            SystemTime::from(libc::timespec {\n-                tv_sec: t.tv_sec,\n-                tv_nsec: (t.tv_usec * 1000) as libc::c_long,\n-            })\n-        }\n-    }\n-\n-    impl From<libc::timespec> for SystemTime {\n-        fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t } }\n-        }\n-    }\n-\n-    impl fmt::Debug for SystemTime {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"SystemTime\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-                .finish()\n+            SystemTime { t: Timespec::from(t) }\n         }\n     }\n \n@@ -270,20 +264,13 @@ mod inner {\n     use crate::sys::cvt;\n     use crate::time::Duration;\n \n-    use super::Timespec;\n+    use super::{SystemTime, Timespec};\n \n     #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     pub struct Instant {\n         t: Timespec,\n     }\n \n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub struct SystemTime {\n-        pub(in crate::sys::unix) t: Timespec,\n-    }\n-\n-    pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n-\n     impl Instant {\n         pub fn now() -> Instant {\n             Instant { t: Timespec::now(libc::CLOCK_MONOTONIC) }\n@@ -305,8 +292,8 @@ mod inner {\n     impl fmt::Debug for Instant {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"Instant\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .field(\"tv_sec\", &self.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.tv_nsec)\n                 .finish()\n         }\n     }\n@@ -315,33 +302,6 @@ mod inner {\n         pub fn now() -> SystemTime {\n             SystemTime { t: Timespec::now(libc::CLOCK_REALTIME) }\n         }\n-\n-        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n-            self.t.sub_timespec(&other.t)\n-        }\n-\n-        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n-        }\n-\n-        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n-        }\n-    }\n-\n-    impl From<libc::timespec> for SystemTime {\n-        fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t } }\n-        }\n-    }\n-\n-    impl fmt::Debug for SystemTime {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"SystemTime\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-                .finish()\n-        }\n     }\n \n     #[cfg(not(any(target_os = \"dragonfly\", target_os = \"espidf\")))]\n@@ -351,9 +311,36 @@ mod inner {\n \n     impl Timespec {\n         pub fn now(clock: clock_t) -> Timespec {\n+            // Try to use 64-bit time in preparation for Y2038.\n+            #[cfg(all(target_os = \"linux\", target_env = \"gnu\", target_pointer_width = \"32\"))]\n+            {\n+                use crate::sys::weak::weak;\n+\n+                // __clock_gettime64 was added to 32-bit arches in glibc 2.34,\n+                // and it handles both vDSO calls and ENOSYS fallbacks itself.\n+                weak!(fn __clock_gettime64(libc::clockid_t, *mut __timespec64) -> libc::c_int);\n+\n+                #[repr(C)]\n+                struct __timespec64 {\n+                    tv_sec: i64,\n+                    #[cfg(target_endian = \"big\")]\n+                    _padding: i32,\n+                    tv_nsec: i32,\n+                    #[cfg(target_endian = \"little\")]\n+                    _padding: i32,\n+                }\n+\n+                if let Some(clock_gettime64) = __clock_gettime64.get() {\n+                    let mut t = MaybeUninit::uninit();\n+                    cvt(unsafe { clock_gettime64(clock, t.as_mut_ptr()) }).unwrap();\n+                    let t = unsafe { t.assume_init() };\n+                    return Timespec { tv_sec: t.tv_sec, tv_nsec: t.tv_nsec as i64 };\n+                }\n+            }\n+\n             let mut t = MaybeUninit::uninit();\n             cvt(unsafe { libc::clock_gettime(clock, t.as_mut_ptr()) }).unwrap();\n-            Timespec { t: unsafe { t.assume_init() } }\n+            Timespec::from(unsafe { t.assume_init() })\n         }\n     }\n }"}]}