{"sha": "aa50ebd03ed1d1f698d0d275f9570ef53e720831", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNTBlYmQwM2VkMWQxZjY5OGQwZDI3NWY5NTcwZWY1M2U3MjA4MzE=", "commit": {"author": {"name": "Niels langager Ellegaard", "email": "niels.ellegaard@gmail.com", "date": "2014-01-05T10:23:39Z"}, "committer": {"name": "Niels langager Ellegaard", "email": "niels.ellegaard@gmail.com", "date": "2014-01-05T10:25:12Z"}, "message": "Move command line parsing to parse_args.rs", "tree": {"sha": "2206f9e1378b71556fa913e794b0d51792ee186e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2206f9e1378b71556fa913e794b0d51792ee186e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa50ebd03ed1d1f698d0d275f9570ef53e720831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa50ebd03ed1d1f698d0d275f9570ef53e720831", "html_url": "https://github.com/rust-lang/rust/commit/aa50ebd03ed1d1f698d0d275f9570ef53e720831", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa50ebd03ed1d1f698d0d275f9570ef53e720831/comments", "author": {"login": "nielsle", "id": 292118, "node_id": "MDQ6VXNlcjI5MjExOA==", "avatar_url": "https://avatars.githubusercontent.com/u/292118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nielsle", "html_url": "https://github.com/nielsle", "followers_url": "https://api.github.com/users/nielsle/followers", "following_url": "https://api.github.com/users/nielsle/following{/other_user}", "gists_url": "https://api.github.com/users/nielsle/gists{/gist_id}", "starred_url": "https://api.github.com/users/nielsle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nielsle/subscriptions", "organizations_url": "https://api.github.com/users/nielsle/orgs", "repos_url": "https://api.github.com/users/nielsle/repos", "events_url": "https://api.github.com/users/nielsle/events{/privacy}", "received_events_url": "https://api.github.com/users/nielsle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nielsle", "id": 292118, "node_id": "MDQ6VXNlcjI5MjExOA==", "avatar_url": "https://avatars.githubusercontent.com/u/292118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nielsle", "html_url": "https://github.com/nielsle", "followers_url": "https://api.github.com/users/nielsle/followers", "following_url": "https://api.github.com/users/nielsle/following{/other_user}", "gists_url": "https://api.github.com/users/nielsle/gists{/gist_id}", "starred_url": "https://api.github.com/users/nielsle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nielsle/subscriptions", "organizations_url": "https://api.github.com/users/nielsle/orgs", "repos_url": "https://api.github.com/users/nielsle/repos", "events_url": "https://api.github.com/users/nielsle/events{/privacy}", "received_events_url": "https://api.github.com/users/nielsle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1c59828b4fd1f2049b9ec21d657c2adda2fe55d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c59828b4fd1f2049b9ec21d657c2adda2fe55d", "html_url": "https://github.com/rust-lang/rust/commit/e1c59828b4fd1f2049b9ec21d657c2adda2fe55d"}], "stats": {"total": 379, "additions": 219, "deletions": 160}, "files": [{"sha": "e9c41d6b897bbf87c4914299803012f4f5dbd890", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 29, "deletions": 160, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/aa50ebd03ed1d1f698d0d275f9570ef53e720831/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa50ebd03ed1d1f698d0d275f9570ef53e720831/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=aa50ebd03ed1d1f698d0d275f9570ef53e720831", "patch": "@@ -20,9 +20,8 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::{os, result, run, str, task};\n+use std::{os, run, str, task};\n use std::io::process;\n-use std::hashmap::HashSet;\n use std::io;\n use std::io::fs;\n pub use std::path::Path;\n@@ -32,27 +31,26 @@ use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use rustc::util::sha2;\n-use extra::{getopts};\n use syntax::{ast, diagnostic};\n use messages::{error, warn, note};\n+use parse_args::{ParseResult, parse_args};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n use path_util::in_rust_path;\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace, dir_has_crate_file};\n use source_control::{CheckedOutSources, is_git_dir, make_read_only};\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, cwd_to_workspace};\n use workspace::determine_destination;\n-use context::{Context, BuildContext,\n-                       RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n-                       LLVMAssemble, LLVMCompileBitcode};\n+use context::{BuildContext, Trans, Nothing, Pretty, Analysis,\n+              LLVMAssemble, LLVMCompileBitcode};\n use context::{Command, BuildCmd, CleanCmd, DoCmd, InfoCmd, InstallCmd, ListCmd,\n     PreferCmd, TestCmd, InitCmd, UninstallCmd, UnpreferCmd};\n use crate_id::CrateId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n use workcache_support::digest_only_date;\n-use exit_codes::{COPY_FAILED_CODE, BAD_FLAG_CODE};\n+use exit_codes::{COPY_FAILED_CODE};\n \n pub mod api;\n mod conditions;\n@@ -63,6 +61,7 @@ mod installed_packages;\n mod messages;\n pub mod crate_id;\n pub mod package_source;\n+mod parse_args;\n mod path_util;\n mod source_control;\n mod target;\n@@ -751,173 +750,43 @@ pub fn main() {\n }\n \n pub fn main_args(args: &[~str]) -> int {\n-    let opts = ~[getopts::optflag(\"h\"), getopts::optflag(\"help\"),\n-                                        getopts::optflag(\"no-link\"),\n-                                        getopts::optflag(\"no-trans\"),\n-                 // n.b. Ignores different --pretty options for now\n-                                        getopts::optflag(\"pretty\"),\n-                                        getopts::optflag(\"parse-only\"),\n-                 getopts::optflag(\"S\"), getopts::optflag(\"assembly\"),\n-                 getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n-                 getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n-                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\"),\n-                                        getopts::optopt(\"sysroot\"),\n-                                        getopts::optflag(\"emit-llvm\"),\n-                                        getopts::optopt(\"linker\"),\n-                                        getopts::optopt(\"link-args\"),\n-                                        getopts::optopt(\"opt-level\"),\n-                 getopts::optflag(\"O\"),\n-                                        getopts::optflag(\"save-temps\"),\n-                                        getopts::optopt(\"target\"),\n-                                        getopts::optopt(\"target-cpu\"),\n-                 getopts::optmulti(\"Z\")                                   ];\n-    let matches = &match getopts::getopts(args, opts) {\n-        result::Ok(m) => m,\n-        result::Err(f) => {\n-            error(format!(\"{}\", f.to_err_msg()));\n-\n-            return 1;\n-        }\n-    };\n-    let help = matches.opt_present(\"h\") ||\n-                   matches.opt_present(\"help\");\n-    let no_link = matches.opt_present(\"no-link\");\n-    let no_trans = matches.opt_present(\"no-trans\");\n-    let supplied_sysroot = matches.opt_str(\"sysroot\");\n-    let generate_asm = matches.opt_present(\"S\") ||\n-        matches.opt_present(\"assembly\");\n-    let parse_only = matches.opt_present(\"parse-only\");\n-    let pretty = matches.opt_present(\"pretty\");\n-    let emit_llvm = matches.opt_present(\"emit-llvm\");\n-\n-    if matches.opt_present(\"v\") ||\n-       matches.opt_present(\"version\") {\n-        rustc::version(args[0]);\n-        return 0;\n-    }\n-\n-    let use_rust_path_hack = matches.opt_present(\"r\") ||\n-                             matches.opt_present(\"rust-path-hack\");\n-\n-    let linker = matches.opt_str(\"linker\");\n-    let link_args = matches.opt_str(\"link-args\");\n-    let cfgs = matches.opt_strs(\"cfg\") + matches.opt_strs(\"c\");\n-    let mut user_supplied_opt_level = true;\n-    let opt_level = match matches.opt_str(\"opt-level\") {\n-        Some(~\"0\") => session::No,\n-        Some(~\"1\") => session::Less,\n-        Some(~\"2\") => session::Default,\n-        Some(~\"3\") => session::Aggressive,\n-        _ if matches.opt_present(\"O\") => session::Default,\n-        _ => {\n-            user_supplied_opt_level = false;\n-            session::No\n-        }\n-    };\n \n-    let save_temps = matches.opt_present(\"save-temps\");\n-    let target     = matches.opt_str(\"target\");\n-    let target_cpu = matches.opt_str(\"target-cpu\");\n-    let experimental_features = {\n-        let strs = matches.opt_strs(\"Z\");\n-        if matches.opt_present(\"Z\") {\n-            Some(strs)\n-        }\n-        else {\n-            None\n+    let (command, args, context, supplied_sysroot) = match parse_args(args) {\n+        Ok(ParseResult {\n+            command: cmd,\n+            args: args,\n+            context: ctx,\n+            sysroot: sroot}) => (cmd, args, ctx, sroot),\n+        Err(error_code) => {\n+            debug!(\"Parsing failed. Returning error code {}\", error_code);\n+            return error_code\n         }\n     };\n-\n-    let mut args = matches.free.clone();\n-    args.shift();\n-\n-    if (args.len() < 1) {\n-        usage::general();\n-        return 1;\n-    }\n-\n-    let rustc_flags = RustcFlags {\n-        linker: linker,\n-        link_args: link_args,\n-        optimization_level: opt_level,\n-        compile_upto: if no_trans {\n-            Trans\n-        } else if no_link {\n-            Link\n-        } else if pretty {\n-            Pretty\n-        } else if parse_only {\n-            Analysis\n-        } else if emit_llvm && generate_asm {\n-            LLVMAssemble\n-        } else if generate_asm {\n-            Assemble\n-        } else if emit_llvm {\n-            LLVMCompileBitcode\n-        } else {\n-            Nothing\n-        },\n-        save_temps: save_temps,\n-        target: target,\n-        target_cpu: target_cpu,\n-        additional_library_paths:\n-            HashSet::new(), // No way to set this from the rustpkg command line\n-        experimental_features: experimental_features\n-    };\n-\n-    let cmd_opt = args.iter().filter_map( |s| from_str(s.clone())).next();\n-    let command = match(cmd_opt) {\n-        None => {\n-            usage::general();\n-            return 0;\n-        }\n-        Some(cmd) => {\n-            let bad_option = context::flags_forbidden_for_cmd(&rustc_flags,\n-                                                              cfgs,\n-                                                              cmd,\n-                                                              user_supplied_opt_level);\n-            if help || bad_option {\n-                usage::usage_for_command(cmd);\n-                if bad_option {\n-                    return BAD_FLAG_CODE;\n-                }\n-                else {\n-                    return 0;\n-                }\n-            } else {\n-                cmd\n-            }\n-        }\n-    };\n-\n-    // Pop off all flags, plus the command\n-    let mut remaining_args: ~[~str] = args.iter().skip_while(|&s| {\n-        let maybe_command: Option<Command> = from_str(*s);\n-        maybe_command.is_none()\n-    }).map(|s| s.clone()).collect();\n-    remaining_args.shift();\n-    let sroot = match supplied_sysroot {\n+    debug!(\"Finished parsing commandline args {:?}\", args);\n+    debug!(\"  Using command: {:?}\", command);\n+    debug!(\"  Using args {:?}\", args);\n+    debug!(\"  Using cflags: {:?}\", context.rustc_flags);\n+    debug!(\"  Using rust_path_hack {:b}\", context.use_rust_path_hack);\n+    debug!(\"  Using cfgs: {:?}\", context.cfgs);\n+    debug!(\"  Using supplied_sysroot: {:?}\", supplied_sysroot);\n+\n+    let sysroot = match supplied_sysroot {\n         Some(s) => Path::new(s),\n         _ => filesearch::get_or_default_sysroot()\n     };\n \n-    debug!(\"Using sysroot: {}\", sroot.display());\n+    debug!(\"Using sysroot: {}\", sysroot.display());\n     let ws = default_workspace();\n     debug!(\"Will store workcache in {}\", ws.display());\n \n-    let rm_args = remaining_args.clone();\n     // Wrap the rest in task::try in case of a condition failure in a task\n     let result = do task::try {\n         BuildContext {\n-            context: Context {\n-                cfgs: cfgs.clone(),\n-                rustc_flags: rustc_flags.clone(),\n-                use_rust_path_hack: use_rust_path_hack,\n-            },\n-            sysroot: sroot.clone(), // Currently, only tests override this\n-            workcache_context: api::default_context(sroot.clone(),\n+            context: context,\n+            sysroot: sysroot.clone(), // Currently, only tests override this\n+            workcache_context: api::default_context(sysroot.clone(),\n                                                     default_workspace()).workcache_context\n-        }.run(command, rm_args.clone())\n+        }.run(command, args.clone())\n     };\n     // FIXME #9262: This is using the same error code for all errors,\n     // and at least one test case succeeds if rustpkg returns COPY_FAILED_CODE,"}, {"sha": "8f21c6d3bfa68f65494197283068b5b8f4e3483d", "filename": "src/librustpkg/parse_args.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/aa50ebd03ed1d1f698d0d275f9570ef53e720831/src%2Flibrustpkg%2Fparse_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa50ebd03ed1d1f698d0d275f9570ef53e720831/src%2Flibrustpkg%2Fparse_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fparse_args.rs?ref=aa50ebd03ed1d1f698d0d275f9570ef53e720831", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::{Context, RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n+                       LLVMAssemble, LLVMCompileBitcode};\n+use context::{Command, flags_forbidden_for_cmd};\n+use rustc::version;\n+use exit_codes::{BAD_FLAG_CODE};\n+use rustc::driver::{session};\n+\n+use usage;\n+\n+use extra::{getopts};\n+use std::{result};\n+use std::hashmap::HashSet;\n+\n+///  Result of parsing command line arguments\n+pub struct ParseResult {\n+    // Command\n+    command: Command,\n+    // Args\n+    args: ~[~str],\n+    // Parsed command line flags\n+    context: Context,\n+    // Path to system root\n+    sysroot: Option<~str>\n+}\n+\n+/// Parses command line arguments of rustpkg.\n+/// Returns a triplet (command, remaining_args, context)\n+pub fn parse_args(args: &[~str]) -> Result<ParseResult, int> {\n+    let opts = ~[ getopts::optflag(\"no-link\"),\n+                                        getopts::optflag(\"no-trans\"),\n+                 // n.b. Ignores different --pretty options for now\n+                                        getopts::optflag(\"pretty\"),\n+                                        getopts::optflag(\"parse-only\"),\n+                 getopts::optflag(\"S\"), getopts::optflag(\"assembly\"),\n+                 getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n+                 getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n+                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\"),\n+                                        getopts::optopt(\"sysroot\"),\n+                                        getopts::optflag(\"emit-llvm\"),\n+                                        getopts::optopt(\"linker\"),\n+                                        getopts::optopt(\"link-args\"),\n+                                        getopts::optopt(\"opt-level\"),\n+                 getopts::optflag(\"O\"),\n+                                        getopts::optflag(\"save-temps\"),\n+                                        getopts::optopt(\"target\"),\n+                                        getopts::optopt(\"target-cpu\"),\n+                 getopts::optmulti(\"Z\")                                   ];\n+    let matches = &match getopts::getopts(args, opts) {\n+        result::Ok(m) => m,\n+        result::Err(f) => {\n+            error!(\"{}\", f.to_err_msg());\n+            return Err(1);\n+        }\n+    };\n+    let no_link = matches.opt_present(\"no-link\");\n+    let no_trans = matches.opt_present(\"no-trans\");\n+    let supplied_sysroot = matches.opt_str(\"sysroot\");\n+    let generate_asm = matches.opt_present(\"S\") ||\n+        matches.opt_present(\"assembly\");\n+    let parse_only = matches.opt_present(\"parse-only\");\n+    let pretty = matches.opt_present(\"pretty\");\n+    let emit_llvm = matches.opt_present(\"emit-llvm\");\n+\n+    if matches.opt_present(\"v\") ||\n+       matches.opt_present(\"version\") {\n+        version(args[0]);\n+        return Err(0);\n+    }\n+\n+    let use_rust_path_hack = matches.opt_present(\"r\") ||\n+                             matches.opt_present(\"rust-path-hack\");\n+\n+    let linker = matches.opt_str(\"linker\");\n+    let link_args = matches.opt_str(\"link-args\");\n+    let cfgs = matches.opt_strs(\"cfg\") + matches.opt_strs(\"c\");\n+    let mut user_supplied_opt_level = true;\n+    let opt_level = match matches.opt_str(\"opt-level\") {\n+        Some(~\"0\") => session::No,\n+        Some(~\"1\") => session::Less,\n+        Some(~\"2\") => session::Default,\n+        Some(~\"3\") => session::Aggressive,\n+        _ if matches.opt_present(\"O\") => session::Default,\n+        _ => {\n+            user_supplied_opt_level = false;\n+            session::No\n+        }\n+    };\n+\n+    let save_temps = matches.opt_present(\"save-temps\");\n+    let target     = matches.opt_str(\"target\");\n+    let target_cpu = matches.opt_str(\"target-cpu\");\n+    let experimental_features = {\n+        let strs = matches.opt_strs(\"Z\");\n+        if matches.opt_present(\"Z\") {\n+            Some(strs)\n+        }\n+        else {\n+            None\n+        }\n+    };\n+\n+    let mut args = matches.free.clone();\n+    args.shift();\n+\n+    if (args.len() < 1) {\n+        usage::general();\n+        return Err(1);\n+    }\n+\n+    let rustc_flags = RustcFlags {\n+        linker: linker,\n+        link_args: link_args,\n+        optimization_level: opt_level,\n+        compile_upto: if no_trans {\n+            Trans\n+        } else if no_link {\n+            Link\n+        } else if pretty {\n+            Pretty\n+        } else if parse_only {\n+            Analysis\n+        } else if emit_llvm && generate_asm {\n+            LLVMAssemble\n+        } else if generate_asm {\n+            Assemble\n+        } else if emit_llvm {\n+            LLVMCompileBitcode\n+        } else {\n+            Nothing\n+        },\n+        save_temps: save_temps,\n+        target: target,\n+        target_cpu: target_cpu,\n+        additional_library_paths:\n+            HashSet::new(), // No way to set this from the rustpkg command line\n+        experimental_features: experimental_features\n+    };\n+\n+    let cmd_opt = args.iter().filter_map( |s| from_str(s.clone())).next();\n+    let command = match(cmd_opt){\n+        None => {\n+            debug!(\"No legal command. Returning 0\");\n+            usage::general();\n+            return Err(0);\n+        }\n+        Some(cmd) => {\n+            let bad_option = flags_forbidden_for_cmd(&rustc_flags,\n+                                                              cfgs,\n+                                                              cmd,\n+                                                              user_supplied_opt_level);\n+            if bad_option {\n+                usage::usage_for_command(cmd);\n+                debug!(\"Bad  option, returning BAD_FLAG_CODE\");\n+                return Err(BAD_FLAG_CODE);\n+            } else {\n+                cmd\n+            }\n+        }\n+    };\n+\n+    // Pop off all flags, plus the command\n+    let mut remaining_args: ~[~str] = args.iter().skip_while(|&s| {\n+        let maybe_command: Option<Command> = from_str(*s);\n+        maybe_command.is_none()\n+    }).map(|s| s.clone()).collect();\n+    remaining_args.shift();\n+\n+    let context = Context{\n+        rustc_flags: rustc_flags,\n+        cfgs: cfgs,\n+        use_rust_path_hack: use_rust_path_hack,\n+    };\n+    Ok(ParseResult {\n+        command:  command,\n+        args: remaining_args,\n+        context: context,\n+        sysroot: supplied_sysroot\n+    })\n+}\n+"}]}