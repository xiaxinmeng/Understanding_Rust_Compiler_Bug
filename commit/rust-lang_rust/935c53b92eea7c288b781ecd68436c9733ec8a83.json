{"sha": "935c53b92eea7c288b781ecd68436c9733ec8a83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNWM1M2I5MmVlYTdjMjg4Yjc4MWVjZDY4NDM2Yzk3MzNlYzhhODM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T18:55:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T18:55:51Z"}, "message": "internal: use cov-mark rather than bailing out diagnostic", "tree": {"sha": "379899e0c1b3027df86a028b24203b58dd2fc49b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/379899e0c1b3027df86a028b24203b58dd2fc49b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/935c53b92eea7c288b781ecd68436c9733ec8a83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/935c53b92eea7c288b781ecd68436c9733ec8a83", "html_url": "https://github.com/rust-lang/rust/commit/935c53b92eea7c288b781ecd68436c9733ec8a83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/935c53b92eea7c288b781ecd68436c9733ec8a83/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b292e1b9da39813e2739cb450c263e7502c97c8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b292e1b9da39813e2739cb450c263e7502c97c8d", "html_url": "https://github.com/rust-lang/rust/commit/b292e1b9da39813e2739cb450c263e7502c97c8d"}], "stats": {"total": 170, "additions": 62, "deletions": 108}, "files": [{"sha": "1f6a7000687bd843e1638f7f82763f550c83b317", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=935c53b92eea7c288b781ecd68436c9733ec8a83", "patch": "@@ -3,8 +3,6 @@\n //!\n //! This probably isn't the best way to do this -- ideally, diagnistics should\n //! be expressed in terms of hir types themselves.\n-use std::any::Any;\n-\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_def::path::ModPath;\n@@ -157,25 +155,4 @@ pub struct MissingMatchArms {\n     pub arms: AstPtr<ast::MatchArmList>,\n }\n \n-#[derive(Debug)]\n-pub struct InternalBailedOut {\n-    pub file: HirFileId,\n-    pub pat_syntax_ptr: SyntaxNodePtr,\n-}\n-\n-impl Diagnostic for InternalBailedOut {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"internal:match-check-bailed-out\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"Internal: match check bailed out\")\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.pat_syntax_ptr.clone() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "7f689cd41b5f2d0dbdf83e757458eda8fa0a6b71", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=935c53b92eea7c288b781ecd68436c9733ec8a83", "patch": "@@ -86,8 +86,8 @@ use crate::{\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InternalBailedOut,\n-        MacroError, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, MacroError,\n+        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n         MissingUnsafe, NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n         UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedModule, UnresolvedProcMacro,\n@@ -461,7 +461,6 @@ impl Module {\n         self,\n         db: &dyn HirDatabase,\n         sink: &mut DiagnosticSink,\n-        internal_diagnostics: bool,\n     ) -> Vec<AnyDiagnostic> {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n@@ -619,11 +618,11 @@ impl Module {\n         }\n         for decl in self.declarations(db) {\n             match decl {\n-                ModuleDef::Function(f) => acc.extend(f.diagnostics(db, sink, internal_diagnostics)),\n+                ModuleDef::Function(f) => acc.extend(f.diagnostics(db, sink)),\n                 ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n                     if def_map[m.id.local_id].origin.is_inline() {\n-                        acc.extend(m.diagnostics(db, sink, internal_diagnostics))\n+                        acc.extend(m.diagnostics(db, sink))\n                     }\n                 }\n                 _ => acc.extend(decl.diagnostics(db)),\n@@ -633,7 +632,7 @@ impl Module {\n         for impl_def in self.impl_defs(db) {\n             for item in impl_def.items(db) {\n                 if let AssocItem::Function(f) = item {\n-                    acc.extend(f.diagnostics(db, sink, internal_diagnostics));\n+                    acc.extend(f.diagnostics(db, sink));\n                 }\n             }\n         }\n@@ -1040,7 +1039,6 @@ impl Function {\n         self,\n         db: &dyn HirDatabase,\n         sink: &mut DiagnosticSink,\n-        internal_diagnostics: bool,\n     ) -> Vec<AnyDiagnostic> {\n         let mut acc: Vec<AnyDiagnostic> = Vec::new();\n         let krate = self.module(db).id.krate();\n@@ -1100,9 +1098,7 @@ impl Function {\n             }\n         }\n \n-        for diagnostic in\n-            BodyValidationDiagnostic::collect(db, self.id.into(), internal_diagnostics)\n-        {\n+        for diagnostic in BodyValidationDiagnostic::collect(db, self.id.into()) {\n             match diagnostic {\n                 BodyValidationDiagnostic::RecordMissingFields {\n                     record,\n@@ -1223,18 +1219,6 @@ impl Function {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                BodyValidationDiagnostic::InternalBailedOut { pat } => {\n-                    match source_map.pat_syntax(pat) {\n-                        Ok(source_ptr) => {\n-                            let pat_syntax_ptr = source_ptr.value.either(Into::into, Into::into);\n-                            sink.push(InternalBailedOut {\n-                                file: source_ptr.file_id,\n-                                pat_syntax_ptr,\n-                            });\n-                        }\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n             }\n         }\n "}, {"sha": "b809b96a0f60074ebd874b4fef5ae21be9e18c60", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=935c53b92eea7c288b781ecd68436c9733ec8a83", "patch": "@@ -50,21 +50,13 @@ pub enum BodyValidationDiagnostic {\n     MissingMatchArms {\n         match_expr: ExprId,\n     },\n-    InternalBailedOut {\n-        pat: PatId,\n-    },\n }\n \n impl BodyValidationDiagnostic {\n-    pub fn collect(\n-        db: &dyn HirDatabase,\n-        owner: DefWithBodyId,\n-        internal_diagnostics: bool,\n-    ) -> Vec<BodyValidationDiagnostic> {\n+    pub fn collect(db: &dyn HirDatabase, owner: DefWithBodyId) -> Vec<BodyValidationDiagnostic> {\n         let _p = profile::span(\"BodyValidationDiagnostic::collect\");\n         let infer = db.infer(owner);\n         let mut validator = ExprValidator::new(owner, infer.clone());\n-        validator.internal_diagnostics = internal_diagnostics;\n         validator.validate_body(db);\n         validator.diagnostics\n     }\n@@ -74,12 +66,11 @@ struct ExprValidator {\n     owner: DefWithBodyId,\n     infer: Arc<InferenceResult>,\n     pub(super) diagnostics: Vec<BodyValidationDiagnostic>,\n-    internal_diagnostics: bool,\n }\n \n impl ExprValidator {\n     fn new(owner: DefWithBodyId, infer: Arc<InferenceResult>) -> ExprValidator {\n-        ExprValidator { owner, infer, diagnostics: Vec::new(), internal_diagnostics: false }\n+        ExprValidator { owner, infer, diagnostics: Vec::new() }\n     }\n \n     fn validate_body(&mut self, db: &dyn HirDatabase) {\n@@ -308,9 +299,7 @@ impl ExprValidator {\n             // fit the match expression, we skip this diagnostic. Skipping the entire\n             // diagnostic rather than just not including this match arm is preferred\n             // to avoid the chance of false positives.\n-            if self.internal_diagnostics {\n-                self.diagnostics.push(BodyValidationDiagnostic::InternalBailedOut { pat: arm.pat })\n-            }\n+            cov_mark::hit!(validate_match_bailed_out);\n             return;\n         }\n "}, {"sha": "fe6236e446fa5ef2d09fa5d7dd08f4972c1b1433", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=935c53b92eea7c288b781ecd68436c9733ec8a83", "patch": "@@ -181,10 +181,9 @@ pub(crate) fn diagnostics(\n         });\n \n     let mut diags = Vec::new();\n-    let internal_diagnostics = cfg!(test);\n     let module = sema.to_module_def(file_id);\n     if let Some(m) = module {\n-        diags = m.diagnostics(db, &mut sink, internal_diagnostics)\n+        diags = m.diagnostics(db, &mut sink)\n     }\n \n     drop(sink);"}, {"sha": "b636489b3f7e67fabfadb410c48f7904e725f250", "filename": "crates/ide/src/diagnostics/missing_match_arms.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs?ref=935c53b92eea7c288b781ecd68436c9733ec8a83", "patch": "@@ -20,9 +20,14 @@ pub(super) fn missing_match_arms(\n pub(super) mod tests {\n     use crate::diagnostics::tests::check_diagnostics;\n \n+    fn check_diagnostics_no_bails(ra_fixture: &str) {\n+        cov_mark::check_count!(validate_match_bailed_out, 0);\n+        crate::diagnostics::tests::check_diagnostics(ra_fixture)\n+    }\n+\n     #[test]\n     fn empty_tuple() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match () { }\n@@ -40,7 +45,7 @@ fn main() {\n \n     #[test]\n     fn tuple_of_two_empty_tuple() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match ((), ()) { }\n@@ -54,7 +59,7 @@ fn main() {\n \n     #[test]\n     fn boolean() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn test_main() {\n     match false { }\n@@ -107,7 +112,7 @@ fn test_main() {\n \n     #[test]\n     fn tuple_of_tuple_and_bools() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match (false, ((), false)) {}\n@@ -135,7 +140,7 @@ fn main() {\n \n     #[test]\n     fn enums() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either { A, B, }\n \n@@ -163,7 +168,7 @@ fn main() {\n \n     #[test]\n     fn enum_containing_bool() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either { A(bool), B }\n \n@@ -196,7 +201,7 @@ fn main() {\n \n     #[test]\n     fn enum_different_sizes() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either { A(bool), B(bool, bool) }\n \n@@ -224,7 +229,7 @@ fn main() {\n \n     #[test]\n     fn tuple_of_enum_no_diagnostic() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either { A(bool), B(bool, bool) }\n enum Either2 { C, D }\n@@ -243,7 +248,7 @@ fn main() {\n \n     #[test]\n     fn or_pattern_no_diagnostic() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either {A, B}\n \n@@ -257,6 +262,7 @@ fn main() {\n \n     #[test]\n     fn mismatched_types() {\n+        cov_mark::check_count!(validate_match_bailed_out, 4);\n         // Match statements with arms that don't match the\n         // expression pattern do not fire this diagnostic.\n         check_diagnostics(\n@@ -267,18 +273,14 @@ enum Either2 { C, D }\n fn main() {\n     match Either::A {\n         Either2::C => (),\n-    //  ^^^^^^^^^^ Internal: match check bailed out\n         Either2::D => (),\n     }\n     match (true, false) {\n         (true, false, true) => (),\n-    //  ^^^^^^^^^^^^^^^^^^^ Internal: match check bailed out\n         (true) => (),\n     }\n     match (true, false) { (true,) => {} }\n-    //                    ^^^^^^^ Internal: match check bailed out\n     match (0) { () => () }\n-            //  ^^ Internal: match check bailed out\n     match Unresolved::Bar { Unresolved::Baz => () }\n }\n         \"#,\n@@ -287,13 +289,12 @@ fn main() {\n \n     #[test]\n     fn mismatched_types_in_or_patterns() {\n+        cov_mark::check_count!(validate_match_bailed_out, 2);\n         check_diagnostics(\n             r#\"\n fn main() {\n     match false { true | () => {} }\n-    //            ^^^^^^^^^ Internal: match check bailed out\n     match (false,) { (true | (),) => {} }\n-    //               ^^^^^^^^^^^^ Internal: match check bailed out\n }\n \"#,\n         );\n@@ -303,7 +304,7 @@ fn main() {\n     fn malformed_match_arm_tuple_enum_missing_pattern() {\n         // We are testing to be sure we don't panic here when the match\n         // arm `Either::B` is missing its pattern.\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either { A, B(u32) }\n \n@@ -319,17 +320,16 @@ fn main() {\n \n     #[test]\n     fn malformed_match_arm_extra_fields() {\n+        cov_mark::check_count!(validate_match_bailed_out, 2);\n         check_diagnostics(\n             r#\"\n enum A { B(isize, isize), C }\n fn main() {\n     match A::B(1, 2) {\n         A::B(_, _, _) => (),\n-    //  ^^^^^^^^^^^^^ Internal: match check bailed out\n     }\n     match A::B(1, 2) {\n         A::C(_) => (),\n-    //  ^^^^^^^ Internal: match check bailed out\n     }\n }\n \"#,\n@@ -338,19 +338,18 @@ fn main() {\n \n     #[test]\n     fn expr_diverges() {\n+        cov_mark::check_count!(validate_match_bailed_out, 2);\n         check_diagnostics(\n             r#\"\n enum Either { A, B }\n \n fn main() {\n     match loop {} {\n         Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n         Either::B => (),\n     }\n     match loop {} {\n         Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n     }\n     match loop { break Foo::A } {\n         //^^^^^^^^^^^^^^^^^^^^^ missing match arm\n@@ -367,7 +366,7 @@ fn main() {\n \n     #[test]\n     fn expr_partially_diverges() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either<T> { A(T), B }\n \n@@ -384,7 +383,7 @@ fn main() -> u32 {\n \n     #[test]\n     fn enum_record() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either { A { foo: bool }, B }\n \n@@ -422,7 +421,7 @@ fn main() {\n \n     #[test]\n     fn enum_record_fields_out_of_order() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either {\n     A { foo: bool, bar: () },\n@@ -449,7 +448,7 @@ fn main() {\n \n     #[test]\n     fn enum_record_ellipsis() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either {\n     A { foo: bool, bar: bool },\n@@ -485,7 +484,7 @@ fn main() {\n \n     #[test]\n     fn enum_tuple_partial_ellipsis() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Either {\n     A(bool, bool, bool, bool),\n@@ -529,7 +528,7 @@ fn main() {\n \n     #[test]\n     fn never() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Never {}\n \n@@ -549,6 +548,8 @@ fn bang(never: !) {\n \n     #[test]\n     fn unknown_type() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n         check_diagnostics(\n             r#\"\n enum Option<T> { Some(T), None }\n@@ -558,7 +559,6 @@ fn main() {\n     match Option::<Never>::None {\n         None => (),\n         Some(never) => match never {},\n-    //  ^^^^^^^^^^^ Internal: match check bailed out\n     }\n     match Option::<Never>::None {\n         //^^^^^^^^^^^^^^^^^^^^^ missing match arm\n@@ -571,7 +571,7 @@ fn main() {\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match (false, true, false) {\n@@ -584,7 +584,7 @@ fn main() {\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match (false, true, false) {\n@@ -597,7 +597,7 @@ fn main() {\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match (false, true, false) {\n@@ -610,7 +610,7 @@ fn main() {\n \n     #[test]\n     fn record_struct() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"struct Foo { a: bool }\n fn main(f: Foo) {\n     match f {}\n@@ -635,7 +635,7 @@ fn main(f: Foo) {\n \n     #[test]\n     fn tuple_struct() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"struct Foo(bool);\n fn main(f: Foo) {\n     match f {}\n@@ -653,7 +653,7 @@ fn main(f: Foo) {\n \n     #[test]\n     fn unit_struct() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"struct Foo;\n fn main(f: Foo) {\n     match f {}\n@@ -666,7 +666,7 @@ fn main(f: Foo) {\n \n     #[test]\n     fn record_struct_ellipsis() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"struct Foo { foo: bool, bar: bool }\n fn main(f: Foo) {\n     match f { Foo { foo: true, .. } => () }\n@@ -688,7 +688,7 @@ fn main(f: Foo) {\n \n     #[test]\n     fn internal_or() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     enum Either { A(bool), B }\n@@ -703,14 +703,15 @@ fn main() {\n \n     #[test]\n     fn no_panic_at_unimplemented_subpattern_type() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n         check_diagnostics(\n             r#\"\n struct S { a: char}\n fn main(v: S) {\n     match v { S{ a }      => {} }\n     match v { S{ a: _x }  => {} }\n     match v { S{ a: 'a' } => {} }\n-            //^^^^^^^^^^^ Internal: match check bailed out\n     match v { S{..}       => {} }\n     match v { _           => {} }\n     match v { }\n@@ -722,7 +723,7 @@ fn main(v: S) {\n \n     #[test]\n     fn binding() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match true {\n@@ -738,6 +739,8 @@ fn main() {\n \n     #[test]\n     fn binding_ref_has_correct_type() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n         // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n         // If that's not true match checking will panic with \"incompatible constructors\"\n         // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n@@ -749,7 +752,6 @@ fn main() {\n     // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n     match Foo::A {\n         ref _x => {}\n-    //  ^^^^^^ Internal: match check bailed out\n         Foo::A => {}\n     }\n     match (true,) {\n@@ -763,7 +765,7 @@ fn main() {\n \n     #[test]\n     fn enum_non_exhaustive() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n //- /lib.rs crate:lib\n #[non_exhaustive]\n@@ -799,7 +801,7 @@ fn main() {\n \n     #[test]\n     fn match_guard() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n fn main() {\n     match true {\n@@ -820,7 +822,7 @@ fn main() {\n     #[test]\n     fn pattern_type_is_of_substitution() {\n         cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n struct Foo<T>(T);\n struct Bar;\n@@ -835,20 +837,21 @@ fn main() {\n \n     #[test]\n     fn record_struct_no_such_field() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n         check_diagnostics(\n             r#\"\n struct Foo { }\n fn main(f: Foo) {\n     match f { Foo { bar } => () }\n-    //        ^^^^^^^^^^^ Internal: match check bailed out\n }\n \"#,\n         );\n     }\n \n     #[test]\n     fn match_ergonomics_issue_9095() {\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Foo<T> { A(T) }\n fn main() {\n@@ -875,13 +878,14 @@ fn main() {\n \n         #[test]\n         fn integers() {\n+            cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n             // We don't currently check integer exhaustiveness.\n             check_diagnostics(\n                 r#\"\n fn main() {\n     match 5 {\n         10 => (),\n-    //  ^^ Internal: match check bailed out\n         11..20 => (),\n     }\n }\n@@ -891,12 +895,13 @@ fn main() {\n \n         #[test]\n         fn reference_patterns_at_top_level() {\n+            cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n             check_diagnostics(\n                 r#\"\n fn main() {\n     match &false {\n         &true => {}\n-    //  ^^^^^ Internal: match check bailed out\n     }\n }\n             \"#,\n@@ -905,16 +910,16 @@ fn main() {\n \n         #[test]\n         fn reference_patterns_in_fields() {\n+            cov_mark::check_count!(validate_match_bailed_out, 2);\n+\n             check_diagnostics(\n                 r#\"\n fn main() {\n     match (&false,) {\n         (true,) => {}\n-    //  ^^^^^^^ Internal: match check bailed out\n     }\n     match (&false,) {\n         (&true,) => {}\n-    //  ^^^^^^^^ Internal: match check bailed out\n     }\n }\n             \"#,"}]}