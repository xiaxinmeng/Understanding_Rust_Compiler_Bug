{"sha": "e10fd317211511c3fb4656aee10eb4fd17dc8586", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMGZkMzE3MjExNTExYzNmYjQ2NTZhZWUxMGViNGZkMTdkYzg1ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-15T02:31:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-15T02:31:52Z"}, "message": "auto merge of #14170 : pcwalton/rust/detildestr-misclibs, r=alexcrichton\n\nr? @brson", "tree": {"sha": "751c444f333d465d11aa20ae6bbd377755bf8aa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/751c444f333d465d11aa20ae6bbd377755bf8aa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e10fd317211511c3fb4656aee10eb4fd17dc8586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e10fd317211511c3fb4656aee10eb4fd17dc8586", "html_url": "https://github.com/rust-lang/rust/commit/e10fd317211511c3fb4656aee10eb4fd17dc8586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e10fd317211511c3fb4656aee10eb4fd17dc8586/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a7a39191a83fc2a63df6cb47acd344ae669d9c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a7a39191a83fc2a63df6cb47acd344ae669d9c7", "html_url": "https://github.com/rust-lang/rust/commit/2a7a39191a83fc2a63df6cb47acd344ae669d9c7"}, {"sha": "351a564df5d62175696a1f87c40629f212f1ee1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/351a564df5d62175696a1f87c40629f212f1ee1e", "html_url": "https://github.com/rust-lang/rust/commit/351a564df5d62175696a1f87c40629f212f1ee1e"}], "stats": {"total": 3781, "additions": 1996, "deletions": 1785}, "files": [{"sha": "32bd66c2004311bd673749c07f297bd2ae63dc1e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -152,7 +152,8 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n             \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n-        test_shard: test::opt_shard(matches.opt_str(\"test-shard\")),\n+        test_shard: test::opt_shard(matches.opt_str(\"test-shard\")\n+                                           .map(|x| x.to_strbuf())),\n         verbose: matches.opt_present(\"verbose\")\n     }\n }\n@@ -235,7 +236,10 @@ pub fn run_tests(config: &Config) {\n \n pub fn test_opts(config: &Config) -> test::TestOpts {\n     test::TestOpts {\n-        filter: config.filter.clone(),\n+        filter: match config.filter {\n+            None => None,\n+            Some(ref filter) => Some(filter.to_strbuf()),\n+        },\n         run_ignored: config.run_ignored,\n         logfile: config.logfile.clone(),\n         run_tests: true,\n@@ -314,7 +318,9 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n         format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n-    test::DynTestName(format!(\"[{}] {}\", config.mode, shorten(testfile)))\n+    test::DynTestName(format_strbuf!(\"[{}] {}\",\n+                                     config.mode,\n+                                     shorten(testfile)))\n }\n \n pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {"}, {"sha": "47e9a013e11354c7186b09ca66dad376de98ca00", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -530,7 +530,7 @@ mod tests {\n     }\n \n     struct Noncopy {\n-        string: ~str,\n+        string: StrBuf,\n         array: Vec<int> ,\n     }\n \n@@ -539,7 +539,7 @@ mod tests {\n         let arena = TypedArena::new();\n         for _ in range(0, 100000) {\n             arena.alloc(Noncopy {\n-                string: \"hello world\".to_owned(),\n+                string: \"hello world\".to_strbuf(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             });\n         }\n@@ -550,7 +550,7 @@ mod tests {\n         let arena = TypedArena::new();\n         b.iter(|| {\n             arena.alloc(Noncopy {\n-                string: \"hello world\".to_owned(),\n+                string: \"hello world\".to_strbuf(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })\n@@ -560,7 +560,7 @@ mod tests {\n     pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n             box Noncopy {\n-                string: \"hello world\".to_owned(),\n+                string: \"hello world\".to_strbuf(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             }\n         })\n@@ -571,7 +571,7 @@ mod tests {\n         let arena = Arena::new();\n         b.iter(|| {\n             arena.alloc(|| Noncopy {\n-                string: \"hello world\".to_owned(),\n+                string: \"hello world\".to_strbuf(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })"}, {"sha": "72eefe4f44d66d1a28ca72dd9f2e086c728debc7", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -270,23 +270,23 @@ mod tests {\n \n     #[test]\n     fn test_put_update() {\n-        let mut cache: LruCache<~str, Vec<u8>> = LruCache::new(1);\n-        cache.put(\"1\".to_owned(), vec![10, 10]);\n-        cache.put(\"1\".to_owned(), vec![10, 19]);\n-        assert_opt_eq(cache.get(&\"1\".to_owned()), vec![10, 19]);\n+        let mut cache: LruCache<StrBuf, Vec<u8>> = LruCache::new(1);\n+        cache.put(\"1\".to_strbuf(), vec![10, 10]);\n+        cache.put(\"1\".to_strbuf(), vec![10, 19]);\n+        assert_opt_eq(cache.get(&\"1\".to_strbuf()), vec![10, 19]);\n         assert_eq!(cache.len(), 1);\n     }\n \n     #[test]\n     fn test_expire_lru() {\n-        let mut cache: LruCache<~str, ~str> = LruCache::new(2);\n-        cache.put(\"foo1\".to_owned(), \"bar1\".to_owned());\n-        cache.put(\"foo2\".to_owned(), \"bar2\".to_owned());\n-        cache.put(\"foo3\".to_owned(), \"bar3\".to_owned());\n-        assert!(cache.get(&\"foo1\".to_owned()).is_none());\n-        cache.put(\"foo2\".to_owned(), \"bar2update\".to_owned());\n-        cache.put(\"foo4\".to_owned(), \"bar4\".to_owned());\n-        assert!(cache.get(&\"foo3\".to_owned()).is_none());\n+        let mut cache: LruCache<StrBuf, StrBuf> = LruCache::new(2);\n+        cache.put(\"foo1\".to_strbuf(), \"bar1\".to_strbuf());\n+        cache.put(\"foo2\".to_strbuf(), \"bar2\".to_strbuf());\n+        cache.put(\"foo3\".to_strbuf(), \"bar3\".to_strbuf());\n+        assert!(cache.get(&\"foo1\".to_strbuf()).is_none());\n+        cache.put(\"foo2\".to_strbuf(), \"bar2update\".to_strbuf());\n+        cache.put(\"foo4\".to_strbuf(), \"bar4\".to_strbuf());\n+        assert!(cache.get(&\"foo3\".to_strbuf()).is_none());\n     }\n \n     #[test]"}, {"sha": "7b9260c7eb9dcffe215870b54c4afa632c87ebbf", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -310,7 +310,7 @@ impl Pattern {\n      * brackets. The resulting string will, when compiled into a `Pattern`,\n      * match the input string and nothing else.\n      */\n-    pub fn escape(s: &str) -> ~str {\n+    pub fn escape(s: &str) -> StrBuf {\n         let mut escaped = StrBuf::new();\n         for c in s.chars() {\n             match c {\n@@ -325,7 +325,7 @@ impl Pattern {\n                 }\n             }\n         }\n-        escaped.into_owned()\n+        escaped\n     }\n \n     /**\n@@ -767,8 +767,8 @@ mod test {\n     #[test]\n     fn test_pattern_escape() {\n         let s = \"_[_]_?_*_!_\";\n-        assert_eq!(Pattern::escape(s), \"_[[]_[]]_[?]_[*]_!_\".to_owned());\n-        assert!(Pattern::new(Pattern::escape(s)).matches(s));\n+        assert_eq!(Pattern::escape(s), \"_[[]_[]]_[?]_[*]_!_\".to_strbuf());\n+        assert!(Pattern::new(Pattern::escape(s).as_slice()).matches(s));\n     }\n \n     #[test]"}, {"sha": "a87bb1e6752fd42d985d6868e9a92a6ff6b433d3", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -433,10 +433,10 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Renders text as string suitable for a label in a .dot file.\n-    pub fn escape(&self) -> ~str {\n+    pub fn escape(&self) -> StrBuf {\n         match self {\n-            &LabelStr(ref s) => s.as_slice().escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(s.as_slice()).into_owned(),\n+            &LabelStr(ref s) => s.as_slice().escape_default().to_strbuf(),\n+            &EscStr(ref s) => LabelText::escape_str(s.as_slice()).to_strbuf(),\n         }\n     }\n }\n@@ -661,11 +661,14 @@ mod tests {\n         }\n     }\n \n-    fn test_input(g: LabelledGraph) -> IoResult<~str> {\n+    fn test_input(g: LabelledGraph) -> IoResult<StrBuf> {\n         let mut writer = MemWriter::new();\n         render(&g, &mut writer).unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        r.read_to_str()\n+        match r.read_to_str() {\n+            Ok(string) => Ok(string.to_strbuf()),\n+            Err(err) => Err(err),\n+        }\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,"}, {"sha": "dda14fb10af027d25086a84a70569316e8f443f7", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -70,30 +70,39 @@ pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n \n //Check if the literal is valid (as LLVM expects),\n //and return a descriptive error if not.\n-fn hex_float_lit_err(s: &str) -> Option<(uint, ~str)> {\n+fn hex_float_lit_err(s: &str) -> Option<(uint, StrBuf)> {\n     let mut chars = s.chars().peekable();\n     let mut i = 0;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n-    if chars.next() != Some('0') { return Some((i, \"Expected '0'\".to_owned())); } i+=1;\n-    if chars.next() != Some('x') { return Some((i, \"Expected 'x'\".to_owned())); } i+=1;\n+    if chars.next() != Some('0') {\n+        return Some((i, \"Expected '0'\".to_strbuf()));\n+    } i+=1;\n+    if chars.next() != Some('x') {\n+        return Some((i, \"Expected 'x'\".to_strbuf()));\n+    } i+=1;\n     let mut d_len = 0;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; d_len += 1;}\n-    if chars.next() != Some('.') { return Some((i, \"Expected '.'\".to_owned())); } i+=1;\n+    if chars.next() != Some('.') {\n+        return Some((i, \"Expected '.'\".to_strbuf()));\n+    } i+=1;\n     let mut f_len = 0;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; f_len += 1;}\n     if d_len == 0 && f_len == 0 {\n-        return Some((i, \"Expected digits before or after decimal point\".to_owned()));\n+        return Some((i, \"Expected digits before or after decimal \\\n+                         point\".to_strbuf()));\n     }\n-    if chars.next() != Some('p') { return Some((i, \"Expected 'p'\".to_owned())); } i+=1;\n+    if chars.next() != Some('p') {\n+        return Some((i, \"Expected 'p'\".to_strbuf()));\n+    } i+=1;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n     let mut e_len = 0;\n     for _ in chars.take_while(|c| c.is_digit()) { chars.next(); i+=1; e_len += 1}\n     if e_len == 0 {\n-        return Some((i, \"Expected exponent digits\".to_owned()));\n+        return Some((i, \"Expected exponent digits\".to_strbuf()));\n     }\n     match chars.next() {\n         None => None,\n-        Some(_) => Some((i, \"Expected end of string\".to_owned()))\n+        Some(_) => Some((i, \"Expected end of string\".to_strbuf()))\n     }\n }\n "}, {"sha": "a5bcb7463029be932df0936003a12a6afc299c50", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@ use std::cmp;\n \n #[deriving(Show, Clone)]\n pub struct LogDirective {\n-    pub name: Option<~str>,\n+    pub name: Option<StrBuf>,\n     pub level: u32,\n }\n \n@@ -64,7 +64,7 @@ pub fn parse_logging_spec(spec: &str) -> Vec<LogDirective> {\n             }\n         };\n         dirs.push(LogDirective {\n-            name: name.map(|s| s.to_owned()),\n+            name: name.map(|s| s.to_strbuf()),\n             level: log_level,\n         });\n     }\n@@ -80,13 +80,13 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 3);\n-        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_owned()));\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_strbuf()));\n         assert_eq!(dirs[0].level, 1);\n \n-        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_owned()));\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_strbuf()));\n         assert_eq!(dirs[1].level, ::MAX_LOG_LEVEL);\n \n-        assert_eq!(dirs[2].name, Some(\"crate2\".to_owned()));\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_strbuf()));\n         assert_eq!(dirs[2].level, 4);\n     }\n \n@@ -96,7 +96,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_strbuf()));\n         assert_eq!(dirs[0].level, 4);\n     }\n \n@@ -106,7 +106,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_strbuf()));\n         assert_eq!(dirs[0].level, 4);\n     }\n \n@@ -116,7 +116,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_strbuf()));\n         assert_eq!(dirs[0].level, ::WARN);\n     }\n \n@@ -128,7 +128,7 @@ mod tests {\n         assert_eq!(dirs.len(), 2);\n         assert_eq!(dirs[0].name, None);\n         assert_eq!(dirs[0].level, 2);\n-        assert_eq!(dirs[1].name, Some(\"crate2\".to_owned()));\n+        assert_eq!(dirs[1].name, Some(\"crate2\".to_strbuf()));\n         assert_eq!(dirs[1].level, 4);\n     }\n }"}, {"sha": "9dd87a38fb63af5d139884bc4537216118ba7359", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -307,7 +307,7 @@ fn enabled(level: u32, module: &str,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(*name) => {},\n+            Some(ref name) if !module.starts_with(name.as_slice()) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -362,8 +362,16 @@ mod tests {\n \n     #[test]\n     fn match_full_path() {\n-        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n-                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n+        let dirs = [\n+            LogDirective {\n+                name: Some(\"crate2\".to_strbuf()),\n+                level: 3\n+            },\n+            LogDirective {\n+                name: Some(\"crate1::mod1\".to_strbuf()),\n+                level: 2\n+            }\n+        ];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(!enabled(3, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2\", dirs.iter()));\n@@ -372,39 +380,49 @@ mod tests {\n \n     #[test]\n     fn no_match() {\n-        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n-                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n+        let dirs = [\n+            LogDirective { name: Some(\"crate2\".to_strbuf()), level: 3 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+        ];\n         assert!(!enabled(2, \"crate3\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning() {\n-        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n-                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n+        let dirs = [\n+            LogDirective { name: Some(\"crate2\".to_strbuf()), level: 3 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+        ];\n         assert!(enabled(3, \"crate2::mod1\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning_longest_match() {\n-        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n-                    LogDirective { name: Some(\"crate2::mod\".to_owned()), level: 4 },\n-                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n+        let dirs = [\n+            LogDirective { name: Some(\"crate2\".to_strbuf()), level: 3 },\n+            LogDirective { name: Some(\"crate2::mod\".to_strbuf()), level: 4 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+        ];\n         assert!(enabled(4, \"crate2::mod1\", dirs.iter()));\n         assert!(!enabled(4, \"crate2\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_default() {\n-        let dirs = [LogDirective { name: None, level: 3 },\n-                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n+        let dirs = [\n+            LogDirective { name: None, level: 3 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+        ];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }\n \n     #[test]\n     fn zero_level() {\n-        let dirs = [LogDirective { name: None, level: 3 },\n-                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 0 }];\n+        let dirs = [\n+            LogDirective { name: None, level: 3 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 0 }\n+        ];\n         assert!(!enabled(1, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }"}, {"sha": "9f66f767f20e70da9a86f7dc0fd8fd64d238c498", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -1865,60 +1865,60 @@ mod biguint_tests {\n         assert!(((one << 64) + one).is_odd());\n     }\n \n-    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, ~str)>)> {\n+    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, StrBuf)>)> {\n         let bits = BigDigit::bits;\n         vec!(( Zero::zero(), vec!(\n-            (2, \"0\".to_owned()), (3, \"0\".to_owned())\n+            (2, \"0\".to_strbuf()), (3, \"0\".to_strbuf())\n         )), ( BigUint::from_slice([ 0xff ]), vec!(\n-            (2,  \"11111111\".to_owned()),\n-            (3,  \"100110\".to_owned()),\n-            (4,  \"3333\".to_owned()),\n-            (5,  \"2010\".to_owned()),\n-            (6,  \"1103\".to_owned()),\n-            (7,  \"513\".to_owned()),\n-            (8,  \"377\".to_owned()),\n-            (9,  \"313\".to_owned()),\n-            (10, \"255\".to_owned()),\n-            (11, \"212\".to_owned()),\n-            (12, \"193\".to_owned()),\n-            (13, \"168\".to_owned()),\n-            (14, \"143\".to_owned()),\n-            (15, \"120\".to_owned()),\n-            (16, \"ff\".to_owned())\n+            (2,  \"11111111\".to_strbuf()),\n+            (3,  \"100110\".to_strbuf()),\n+            (4,  \"3333\".to_strbuf()),\n+            (5,  \"2010\".to_strbuf()),\n+            (6,  \"1103\".to_strbuf()),\n+            (7,  \"513\".to_strbuf()),\n+            (8,  \"377\".to_strbuf()),\n+            (9,  \"313\".to_strbuf()),\n+            (10, \"255\".to_strbuf()),\n+            (11, \"212\".to_strbuf()),\n+            (12, \"193\".to_strbuf()),\n+            (13, \"168\".to_strbuf()),\n+            (14, \"143\".to_strbuf()),\n+            (15, \"120\".to_strbuf()),\n+            (16, \"ff\".to_strbuf())\n         )), ( BigUint::from_slice([ 0xfff ]), vec!(\n-            (2,  \"111111111111\".to_owned()),\n-            (4,  \"333333\".to_owned()),\n-            (16, \"fff\".to_owned())\n+            (2,  \"111111111111\".to_strbuf()),\n+            (4,  \"333333\".to_strbuf()),\n+            (16, \"fff\".to_strbuf())\n         )), ( BigUint::from_slice([ 1, 2 ]), vec!(\n             (2,\n-             \"10\".to_owned() +\n-             \"0\".repeat(bits - 1) + \"1\"),\n+             format_strbuf!(\"10{}1\", \"0\".repeat(bits - 1))),\n             (4,\n-             \"2\".to_owned() +\n-             \"0\".repeat(bits / 2 - 1) + \"1\"),\n+             format_strbuf!(\"2{}1\", \"0\".repeat(bits / 2 - 1))),\n             (10, match bits {\n-                32 => \"8589934593\".to_owned(), 16 => \"131073\".to_owned(), _ => fail!()\n+                32 => \"8589934593\".to_strbuf(),\n+                16 => \"131073\".to_strbuf(),\n+                _ => fail!()\n             }),\n             (16,\n-             \"2\".to_owned() +\n-             \"0\".repeat(bits / 4 - 1) + \"1\")\n+             format_strbuf!(\"2{}1\", \"0\".repeat(bits / 4 - 1)))\n         )), ( BigUint::from_slice([ 1, 2, 3 ]), vec!(\n             (2,\n-             \"11\".to_owned() +\n-             \"0\".repeat(bits - 2) + \"10\" +\n-             \"0\".repeat(bits - 1) + \"1\"),\n+             format_strbuf!(\"11{}10{}1\",\n+                            \"0\".repeat(bits - 2),\n+                            \"0\".repeat(bits - 1))),\n             (4,\n-             \"3\".to_owned() +\n-             \"0\".repeat(bits / 2 - 1) + \"2\" +\n-             \"0\".repeat(bits / 2 - 1) + \"1\"),\n+             format_strbuf!(\"3{}2{}1\",\n+                            \"0\".repeat(bits / 2 - 1),\n+                            \"0\".repeat(bits / 2 - 1))),\n             (10, match bits {\n-                32 => \"55340232229718589441\".to_owned(),\n-                16 => \"12885032961\".to_owned(),\n+                32 => \"55340232229718589441\".to_strbuf(),\n+                16 => \"12885032961\".to_strbuf(),\n                 _ => fail!()\n             }),\n-            (16, \"3\".to_owned() +\n-             \"0\".repeat(bits / 4 - 1) + \"2\" +\n-             \"0\".repeat(bits / 4 - 1) + \"1\")\n+            (16,\n+             format_strbuf!(\"3{}2{}1\",\n+                            \"0\".repeat(bits / 4 - 1),\n+                            \"0\".repeat(bits / 4 - 1)))\n         )) )\n     }\n \n@@ -1929,7 +1929,8 @@ mod biguint_tests {\n             let &(ref n, ref rs) = num_pair;\n             for str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n-                assert_eq!(&n.to_str_radix(*radix), str);\n+                assert_eq!(n.to_str_radix(*radix).as_slice(),\n+                           str.as_slice());\n             }\n         }\n     }\n@@ -1941,7 +1942,9 @@ mod biguint_tests {\n             let &(ref n, ref rs) = num_pair;\n             for str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n-                assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).unwrap());\n+                assert_eq!(n,\n+                           &FromStrRadix::from_str_radix(str.as_slice(),\n+                                                         *radix).unwrap());\n             }\n         }\n "}, {"sha": "b82c4d177ba02e18a4dce036930f0f77b812ec75", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -348,15 +348,15 @@ mod test {\n \n     #[test]\n     fn test_to_str() {\n-        fn test(c : Complex64, s: ~str) {\n-            assert_eq!(c.to_str(), s);\n+        fn test(c : Complex64, s: StrBuf) {\n+            assert_eq!(c.to_str().to_strbuf(), s);\n         }\n-        test(_0_0i, \"0+0i\".to_owned());\n-        test(_1_0i, \"1+0i\".to_owned());\n-        test(_0_1i, \"0+1i\".to_owned());\n-        test(_1_1i, \"1+1i\".to_owned());\n-        test(_neg1_1i, \"-1+1i\".to_owned());\n-        test(-_neg1_1i, \"1-1i\".to_owned());\n-        test(_05_05i, \"0.5+0.5i\".to_owned());\n+        test(_0_0i, \"0+0i\".to_strbuf());\n+        test(_1_0i, \"1+0i\".to_strbuf());\n+        test(_0_1i, \"0+1i\".to_strbuf());\n+        test(_1_1i, \"1+1i\".to_strbuf());\n+        test(_neg1_1i, \"-1+1i\".to_strbuf());\n+        test(-_neg1_1i, \"1-1i\".to_strbuf());\n+        test(_05_05i, \"0.5+0.5i\".to_strbuf());\n     }\n }"}, {"sha": "bffca79f351d4d0cc2fadb1ea912a2d4e8b48248", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -555,16 +555,16 @@ mod test {\n \n     #[test]\n     fn test_to_from_str() {\n-        fn test(r: Rational, s: ~str) {\n-            assert_eq!(FromStr::from_str(s), Some(r));\n-            assert_eq!(r.to_str(), s);\n+        fn test(r: Rational, s: StrBuf) {\n+            assert_eq!(FromStr::from_str(s.as_slice()), Some(r));\n+            assert_eq!(r.to_str().to_strbuf(), s);\n         }\n-        test(_1, \"1/1\".to_owned());\n-        test(_0, \"0/1\".to_owned());\n-        test(_1_2, \"1/2\".to_owned());\n-        test(_3_2, \"3/2\".to_owned());\n-        test(_2, \"2/1\".to_owned());\n-        test(_neg1_2, \"-1/2\".to_owned());\n+        test(_1, \"1/1\".to_strbuf());\n+        test(_0, \"0/1\".to_strbuf());\n+        test(_1_2, \"1/2\".to_strbuf());\n+        test(_3_2, \"3/2\".to_strbuf());\n+        test(_2, \"2/1\".to_strbuf());\n+        test(_neg1_2, \"-1/2\".to_strbuf());\n     }\n     #[test]\n     fn test_from_str_fail() {\n@@ -581,30 +581,31 @@ mod test {\n \n     #[test]\n     fn test_to_from_str_radix() {\n-        fn test(r: Rational, s: ~str, n: uint) {\n-            assert_eq!(FromStrRadix::from_str_radix(s, n), Some(r));\n-            assert_eq!(r.to_str_radix(n), s);\n+        fn test(r: Rational, s: StrBuf, n: uint) {\n+            assert_eq!(FromStrRadix::from_str_radix(s.to_owned(), n),\n+                       Some(r));\n+            assert_eq!(r.to_str_radix(n).to_strbuf(), s);\n         }\n-        fn test3(r: Rational, s: ~str) { test(r, s, 3) }\n-        fn test16(r: Rational, s: ~str) { test(r, s, 16) }\n-\n-        test3(_1, \"1/1\".to_owned());\n-        test3(_0, \"0/1\".to_owned());\n-        test3(_1_2, \"1/2\".to_owned());\n-        test3(_3_2, \"10/2\".to_owned());\n-        test3(_2, \"2/1\".to_owned());\n-        test3(_neg1_2, \"-1/2\".to_owned());\n-        test3(_neg1_2 / _2, \"-1/11\".to_owned());\n-\n-        test16(_1, \"1/1\".to_owned());\n-        test16(_0, \"0/1\".to_owned());\n-        test16(_1_2, \"1/2\".to_owned());\n-        test16(_3_2, \"3/2\".to_owned());\n-        test16(_2, \"2/1\".to_owned());\n-        test16(_neg1_2, \"-1/2\".to_owned());\n-        test16(_neg1_2 / _2, \"-1/4\".to_owned());\n-        test16(Ratio::new(13,15), \"d/f\".to_owned());\n-        test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_owned());\n+        fn test3(r: Rational, s: StrBuf) { test(r, s, 3) }\n+        fn test16(r: Rational, s: StrBuf) { test(r, s, 16) }\n+\n+        test3(_1, \"1/1\".to_strbuf());\n+        test3(_0, \"0/1\".to_strbuf());\n+        test3(_1_2, \"1/2\".to_strbuf());\n+        test3(_3_2, \"10/2\".to_strbuf());\n+        test3(_2, \"2/1\".to_strbuf());\n+        test3(_neg1_2, \"-1/2\".to_strbuf());\n+        test3(_neg1_2 / _2, \"-1/11\".to_strbuf());\n+\n+        test16(_1, \"1/1\".to_strbuf());\n+        test16(_0, \"0/1\".to_strbuf());\n+        test16(_1_2, \"1/2\".to_strbuf());\n+        test16(_3_2, \"3/2\".to_strbuf());\n+        test16(_2, \"2/1\".to_strbuf());\n+        test16(_neg1_2, \"-1/2\".to_strbuf());\n+        test16(_neg1_2 / _2, \"-1/4\".to_strbuf());\n+        test16(Ratio::new(13,15), \"d/f\".to_strbuf());\n+        test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_strbuf());\n     }\n \n     #[test]"}, {"sha": "5b71d5c4da722c34c3b3a9b58acf8274040731b6", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -260,15 +260,15 @@ pub trait Rng {\n     ///\n     /// println!(\"{}\", task_rng().gen_ascii_str(10));\n     /// ```\n-    fn gen_ascii_str(&mut self, len: uint) -> ~str {\n+    fn gen_ascii_str(&mut self, len: uint) -> StrBuf {\n         static GEN_ASCII_STR_CHARSET: &'static [u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                                              abcdefghijklmnopqrstuvwxyz\\\n                                                              0123456789\");\n         let mut s = StrBuf::with_capacity(len);\n         for _ in range(0, len) {\n             s.push_char(self.choose(GEN_ASCII_STR_CHARSET) as char)\n         }\n-        s.into_owned()\n+        s\n     }\n \n     /// Choose an item randomly, failing if `values` is empty."}, {"sha": "1ba691044463d38213d1dfe67934290b283f5693", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -83,12 +83,12 @@ pub struct Program {\n     /// If the regular expression requires a literal prefix in order to have a\n     /// match, that prefix is stored here. (It's used in the VM to implement\n     /// an optimization.)\n-    pub prefix: ~str,\n+    pub prefix: StrBuf,\n }\n \n impl Program {\n     /// Compiles a Regex given its AST.\n-    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<~str>>) {\n+    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<StrBuf>>) {\n         let mut c = Compiler {\n             insts: Vec::with_capacity(100),\n             names: Vec::with_capacity(10),\n@@ -113,7 +113,7 @@ impl Program {\n         let Compiler { insts, names } = c;\n         let prog = Program {\n             insts: insts,\n-            prefix: pre.into_owned(),\n+            prefix: pre,\n         };\n         (prog, names)\n     }\n@@ -135,7 +135,7 @@ impl Program {\n \n struct Compiler<'r> {\n     insts: Vec<Inst>,\n-    names: Vec<Option<~str>>,\n+    names: Vec<Option<StrBuf>>,\n }\n \n // The compiler implemented here is extremely simple. Most of the complexity"}, {"sha": "d1a01cc974f8b3afbe2a3d17dddebfe0cfa6b19f", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -32,7 +32,7 @@ pub struct Error {\n     /// The *approximate* character index of where the error occurred.\n     pub pos: uint,\n     /// A message describing the error.\n-    pub msg: ~str,\n+    pub msg: StrBuf,\n }\n \n impl fmt::Show for Error {\n@@ -59,7 +59,7 @@ pub enum Ast {\n     Begin(Flags),\n     End(Flags),\n     WordBoundary(Flags),\n-    Capture(uint, Option<~str>, Box<Ast>),\n+    Capture(uint, Option<StrBuf>, Box<Ast>),\n     // Represent concatenation as a flat vector to avoid blowing the\n     // stack in the compiler.\n     Cat(Vec<Ast>),\n@@ -104,7 +104,7 @@ impl Greed {\n #[deriving(Show)]\n enum BuildAst {\n     Ast(Ast),\n-    Paren(Flags, uint, ~str), // '('\n+    Paren(Flags, uint, StrBuf), // '('\n     Bar, // '|'\n }\n \n@@ -131,7 +131,7 @@ impl BuildAst {\n         }\n     }\n \n-    fn capture_name(&self) -> Option<~str> {\n+    fn capture_name(&self) -> Option<StrBuf> {\n         match *self {\n             Paren(_, 0, _) => None,\n             Paren(_, _, ref name) => {\n@@ -185,7 +185,7 @@ struct Parser<'a> {\n     // opening a capture group).\n     caps: uint,\n     // A set of all capture group names used only to detect duplicates.\n-    names: Vec<~str>,\n+    names: Vec<StrBuf>,\n }\n \n pub fn parse(s: &str) -> Result<Ast, Error> {\n@@ -222,7 +222,7 @@ impl<'a> Parser<'a> {\n                         self.caps += 1;\n                         self.stack.push(Paren(self.flags,\n                                               self.caps,\n-                                              \"\".to_owned()))\n+                                              \"\".to_strbuf()))\n                     }\n                 }\n                 ')' => {\n@@ -470,7 +470,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name) {\n+        match find_class(ASCII_CLASSES, name.as_slice()) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -611,7 +611,7 @@ impl<'a> Parser<'a> {\n     // character).\n     fn parse_unicode_name(&mut self) -> Result<Ast, Error> {\n         let negated = if self.cur() == 'P' { FLAG_NEGATED } else { FLAG_EMPTY };\n-        let mut name: ~str;\n+        let mut name: StrBuf;\n         if self.peek_is(1, '{') {\n             try!(self.expect('{'))\n             let closer =\n@@ -633,7 +633,7 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name) {\n+        match find_class(UNICODE_CLASSES, name.as_slice()) {\n             None => return self.err(format!(\n                 \"Could not find Unicode class '{}'\", name)),\n             Some(ranges) => {\n@@ -657,7 +657,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s, 8) {\n+        match num::from_str_radix::<u32>(s.as_slice(), 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => self.err(format!(\n                 \"Could not parse '{}' as octal number.\", s)),\n@@ -679,7 +679,7 @@ impl<'a> Parser<'a> {\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer))\n+        self.parse_hex_digits(self.slice(start, closer).as_slice())\n     }\n \n     // Parses a two-digit hex number.\n@@ -690,7 +690,7 @@ impl<'a> Parser<'a> {\n         let (start, end) = (self.chari, self.chari + 2);\n         let bad = self.slice(start - 2, self.chars.len());\n         try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\", bad)))\n-        self.parse_hex_digits(self.slice(start, end))\n+        self.parse_hex_digits(self.slice(start, end).as_slice())\n     }\n \n     // Parses `s` as a hexadecimal number.\n@@ -717,7 +717,7 @@ impl<'a> Parser<'a> {\n             return self.err(\"Capture names must have at least 1 character.\")\n         }\n         let name = self.slice(self.chari, closer);\n-        if !name.chars().all(is_valid_cap) {\n+        if !name.as_slice().chars().all(is_valid_cap) {\n             return self.err(\n                 \"Capture names can only have underscores, letters and digits.\")\n         }\n@@ -771,7 +771,7 @@ impl<'a> Parser<'a> {\n                     }\n                     if self.cur() == ':' {\n                         // Save the old flags with the opening paren.\n-                        self.stack.push(Paren(self.flags, 0, \"\".to_owned()));\n+                        self.stack.push(Paren(self.flags, 0, \"\".to_strbuf()));\n                     }\n                     self.flags = flags;\n                     return Ok(())\n@@ -892,7 +892,7 @@ impl<'a> Parser<'a> {\n     fn err<T>(&self, msg: &str) -> Result<T, Error> {\n         Err(Error {\n             pos: self.chari,\n-            msg: msg.to_owned(),\n+            msg: msg.to_strbuf(),\n         })\n     }\n \n@@ -911,8 +911,8 @@ impl<'a> Parser<'a> {\n         *self.chars.get(self.chari)\n     }\n \n-    fn slice(&self, start: uint, end: uint) -> ~str {\n-        str::from_chars(self.chars.as_slice().slice(start, end))\n+    fn slice(&self, start: uint, end: uint) -> StrBuf {\n+        str::from_chars(self.chars.as_slice().slice(start, end)).to_strbuf()\n     }\n }\n "}, {"sha": "f22889b22a324b56cf27a5ec561ee109a781d0c7", "filename": "src/libregex/re.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -20,15 +20,15 @@ use vm::{CaptureLocs, MatchKind, Exists, Location, Submatches};\n \n /// Escapes all regular expression meta characters in `text` so that it may be\n /// safely used in a regular expression as a literal string.\n-pub fn quote(text: &str) -> ~str {\n+pub fn quote(text: &str) -> StrBuf {\n     let mut quoted = StrBuf::with_capacity(text.len());\n     for c in text.chars() {\n         if parse::is_punct(c) {\n             quoted.push_char('\\\\')\n         }\n         quoted.push_char(c);\n     }\n-    quoted.into_owned()\n+    quoted\n }\n \n /// Tests if the given regular expression matches somewhere in the text given.\n@@ -107,9 +107,9 @@ pub struct Regex {\n     /// See the comments for the `program` module in `lib.rs` for a more\n     /// detailed explanation for what `regex!` requires.\n     #[doc(hidden)]\n-    pub original: ~str,\n+    pub original: StrBuf,\n     #[doc(hidden)]\n-    pub names: Vec<Option<~str>>,\n+    pub names: Vec<Option<StrBuf>>,\n     #[doc(hidden)]\n     pub p: MaybeNative,\n }\n@@ -146,7 +146,10 @@ impl Regex {\n     pub fn new(re: &str) -> Result<Regex, parse::Error> {\n         let ast = try!(parse::parse(re));\n         let (prog, names) = Program::new(ast);\n-        Ok(Regex { original: re.to_owned(), names: names, p: Dynamic(prog) })\n+        Ok(Regex {\n+            original: re.to_strbuf(),\n+            names: names, p: Dynamic(prog),\n+        })\n     }\n \n     /// Returns true if and only if the regex matches the string given.\n@@ -404,7 +407,7 @@ impl Regex {\n     /// ```\n     ///\n     /// But anything satisfying the `Replacer` trait will work. For example,\n-    /// a closure of type `|&Captures| -> ~str` provides direct access to the\n+    /// a closure of type `|&Captures| -> StrBuf` provides direct access to the\n     /// captures corresponding to a match. This allows one to access\n     /// submatches easily:\n     ///\n@@ -414,7 +417,7 @@ impl Regex {\n     /// # use regex::Captures; fn main() {\n     /// let re = regex!(r\"([^,\\s]+),\\s+(\\S+)\");\n     /// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n-    ///     format!(\"{} {}\", caps.at(2), caps.at(1))\n+    ///     format_strbuf!(\"{} {}\", caps.at(2), caps.at(1))\n     /// });\n     /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n     /// # }\n@@ -526,7 +529,7 @@ impl<'t> Replacer for &'t str {\n     }\n }\n \n-impl<'a> Replacer for |&Captures|: 'a -> ~str {\n+impl<'a> Replacer for |&Captures|: 'a -> StrBuf {\n     fn reg_replace<'r>(&'r mut self, caps: &Captures) -> MaybeOwned<'r> {\n         Owned((*self)(caps).into_owned())\n     }\n@@ -605,7 +608,7 @@ impl<'r, 't> Iterator<&'t str> for RegexSplitsN<'r, 't> {\n pub struct Captures<'t> {\n     text: &'t str,\n     locs: CaptureLocs,\n-    named: Option<HashMap<~str, uint>>,\n+    named: Option<HashMap<StrBuf, uint>>,\n }\n \n impl<'t> Captures<'t> {\n@@ -624,7 +627,7 @@ impl<'t> Captures<'t> {\n                     match name {\n                         &None => {},\n                         &Some(ref name) => {\n-                            named.insert(name.to_owned(), i);\n+                            named.insert(name.to_strbuf(), i);\n                         }\n                     }\n                 }\n@@ -707,12 +710,14 @@ impl<'t> Captures<'t> {\n         // How evil can you get?\n         // FIXME: Don't use regexes for this. It's completely unnecessary.\n         let re = Regex::new(r\"(^|[^$]|\\b)\\$(\\w+)\").unwrap();\n-        let text = re.replace_all(text, |refs: &Captures| -> ~str {\n+        let text = re.replace_all(text, |refs: &Captures| -> StrBuf {\n             let (pre, name) = (refs.at(1), refs.at(2));\n-            pre + match from_str::<uint>(name) {\n-                None => self.name(name).to_owned(),\n-                Some(i) => self.at(i).to_owned(),\n-            }\n+            format_strbuf!(\"{}{}\",\n+                           pre,\n+                           match from_str::<uint>(name.as_slice()) {\n+                None => self.name(name).to_strbuf(),\n+                Some(i) => self.at(i).to_strbuf(),\n+            })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n         re.replace_all(text.as_slice(), NoExpand(\"$\"))"}, {"sha": "4c4ba8dd6bf93e133db10fa4b8208cd85cf5cbed", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -140,7 +140,7 @@ macro_rules! throughput(\n         fn $name(b: &mut Bencher) {\n             let text = gen_text($size);\n             b.bytes = $size;\n-            b.iter(|| if $regex.is_match(text) { fail!(\"match\") });\n+            b.iter(|| if $regex.is_match(text.as_slice()) { fail!(\"match\") });\n         }\n     );\n )\n@@ -151,15 +151,15 @@ fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n #[allow(deprecated_owned_vector)]\n-fn gen_text(n: uint) -> ~str {\n+fn gen_text(n: uint) -> StrBuf {\n     let mut rng = task_rng();\n     let mut bytes = rng.gen_ascii_str(n).into_bytes();\n     for (i, b) in bytes.mut_iter().enumerate() {\n         if i % 20 == 0 {\n             *b = '\\n' as u8\n         }\n     }\n-    str::from_utf8(bytes).unwrap().to_owned()\n+    str::from_utf8(bytes.as_slice()).unwrap().to_strbuf()\n }\n \n throughput!(easy0_32, easy0(), 32)"}, {"sha": "b85a1592eff02ae439fb1895b3909f068e5767c8", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -105,8 +105,8 @@ struct NfaGen<'a> {\n     cx: &'a ExtCtxt<'a>,\n     sp: codemap::Span,\n     prog: Program,\n-    names: Vec<Option<~str>>,\n-    original: ~str,\n+    names: Vec<Option<StrBuf>>,\n+    original: StrBuf,\n }\n \n impl<'a> NfaGen<'a> {\n@@ -119,7 +119,7 @@ impl<'a> NfaGen<'a> {\n             |cx, name| match *name {\n                 Some(ref name) => {\n                     let name = name.as_slice();\n-                    quote_expr!(cx, Some($name.to_owned()))\n+                    quote_expr!(cx, Some($name.to_strbuf()))\n                 }\n                 None => cx.expr_none(self.sp),\n             }\n@@ -311,7 +311,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n }\n \n ::regex::Regex {\n-    original: $regex.to_owned(),\n+    original: $regex.to_strbuf(),\n     names: vec!$cap_names,\n     p: ::regex::native::Native(exec),\n }\n@@ -601,14 +601,14 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n /// Looks for a single string literal and returns it.\n /// Otherwise, logs an error with cx.span_err and returns None.\n-fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<~str> {\n+fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<StrBuf> {\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(),\n                                                 Vec::from_slice(tts));\n     let entry = cx.expand_expr(parser.parse_expr());\n     let regex = match entry.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => s.to_str(),\n+                ast::LitStr(ref s, _) => s.to_str().to_strbuf(),\n                 _ => {\n                     cx.span_err(entry.span, format!(\n                         \"expected string literal but got `{}`\","}, {"sha": "0d532d7cec13c41cdf6976faa56e67c82c879da0", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -327,7 +327,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n         pub fn main() {\n             #![main]\n             use std::slice::Vector;\n-            test::test_main_static(::std::os::args().as_slice(), TESTS);\n+            test::test_main_static_x(::std::os::args().as_slice(), TESTS);\n         }\n     )).unwrap();\n "}, {"sha": "e43e7d69a2d006df146e66594032773f7fa95452", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -176,10 +176,6 @@ pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<StrBuf>) -> int\n     let mut collector = Collector::new(input.to_strbuf(), libs, true, true);\n     find_testable_code(input_str.as_slice(), &mut collector);\n     test_args.unshift(\"rustdoctest\".to_strbuf());\n-    testing::test_main(test_args.move_iter()\n-                                .map(|x| x.to_str())\n-                                .collect::<Vec<_>>()\n-                                .as_slice(),\n-                       collector.tests);\n+    testing::test_main(test_args.as_slice(), collector.tests);\n     0\n }"}, {"sha": "9e63848b90eab0d9d2f821e630229e1654513402", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -92,10 +92,7 @@ pub fn run(input: &str,\n \n     test_args.unshift(\"rustdoctest\".to_strbuf());\n \n-    testing::test_main(test_args.move_iter()\n-                                .map(|x| x.to_str())\n-                                .collect::<Vec<_>>()\n-                                .as_slice(),\n+    testing::test_main(test_args.as_slice(),\n                        collector.tests.move_iter().collect());\n     0\n }\n@@ -235,9 +232,9 @@ impl Collector {\n     pub fn add_test(&mut self, test: StrBuf, should_fail: bool, no_run: bool, should_ignore: bool) {\n         let name = if self.use_headers {\n             let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n-            format!(\"{}_{}\", s, self.cnt)\n+            format_strbuf!(\"{}_{}\", s, self.cnt)\n         } else {\n-            format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n+            format_strbuf!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n         };\n         self.cnt += 1;\n         let libs = self.libs.clone();"}, {"sha": "3035b305617879d6fa62300c1ad07be5417e9066", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -50,7 +50,7 @@ use std::strbuf::StrBuf;\n #[allow(missing_doc)]\n pub enum Identifier {\n     Numeric(uint),\n-    AlphaNumeric(~str)\n+    AlphaNumeric(StrBuf)\n }\n \n impl cmp::Ord for Identifier {\n@@ -158,7 +158,7 @@ impl cmp::Ord for Version {\n }\n \n fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n-                        -> (~str, Option<char>) {\n+                        -> (StrBuf, Option<char>) {\n     let mut buf = StrBuf::new();\n     let mut ch = rdr.next();\n     loop {\n@@ -171,21 +171,21 @@ fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n             }\n         }\n     }\n-    (buf.into_owned(), ch)\n+    (buf, ch)\n }\n \n fn take_num<T: Iterator<char>>(rdr: &mut T) -> Option<(uint, Option<char>)> {\n     let (s, ch) = take_nonempty_prefix(rdr, char::is_digit);\n-    match from_str::<uint>(s) {\n+    match from_str::<uint>(s.as_slice()) {\n         None => None,\n         Some(i) => Some((i, ch))\n     }\n }\n \n fn take_ident<T: Iterator<char>>(rdr: &mut T) -> Option<(Identifier, Option<char>)> {\n     let (s,ch) = take_nonempty_prefix(rdr, char::is_alphanumeric);\n-    if s.chars().all(char::is_digit) {\n-        match from_str::<uint>(s) {\n+    if s.as_slice().chars().all(char::is_digit) {\n+        match from_str::<uint>(s.as_slice()) {\n             None => None,\n             Some(i) => Some((Numeric(i), ch))\n         }\n@@ -308,52 +308,52 @@ fn test_parse() {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n         build: vec!(),\n     }));\n     assert!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n         build: vec!()\n     }));\n     assert!(parse(\"1.2.3+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n+        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n     }));\n     assert!(parse(\"  1.2.3+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n+        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n     }));\n     assert!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n-        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n+        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n     }));\n     assert!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n-        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n+        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n     }));\n     assert!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(Numeric(1),AlphaNumeric(\"alpha1\".to_owned()),Numeric(9)),\n-        build: vec!(AlphaNumeric(\"build5\".to_owned()),\n+        pre: vec!(Numeric(1),AlphaNumeric(\"alpha1\".to_strbuf()),Numeric(9)),\n+        build: vec!(AlphaNumeric(\"build5\".to_strbuf()),\n                  Numeric(7),\n-                 AlphaNumeric(\"3aedf\".to_owned()))\n+                 AlphaNumeric(\"3aedf\".to_strbuf()))\n     }));\n \n }\n@@ -377,10 +377,14 @@ fn test_ne() {\n \n #[test]\n fn test_show() {\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3\").unwrap()), \"1.2.3\".to_owned());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1\").unwrap()), \"1.2.3-alpha1\".to_owned());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3+build.42\").unwrap()), \"1.2.3+build.42\".to_owned());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1+42\").unwrap()), \"1.2.3-alpha1+42\".to_owned());\n+    assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3\").unwrap()),\n+               \"1.2.3\".to_strbuf());\n+    assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3-alpha1\").unwrap()),\n+               \"1.2.3-alpha1\".to_strbuf());\n+    assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3+build.42\").unwrap()),\n+               \"1.2.3+build.42\".to_strbuf());\n+    assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3-alpha1+42\").unwrap()),\n+               \"1.2.3-alpha1+42\".to_strbuf());\n }\n \n #[test]"}, {"sha": "88081d90b40013d55c8e37acb74e118e65659de7", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -1511,9 +1511,9 @@ mod tests {\n \n     fn make_rand_name() -> ~str {\n         let mut rng = rand::task_rng();\n-        let n = \"TEST\".to_owned() + rng.gen_ascii_str(10u);\n-        assert!(getenv(n).is_none());\n-        n\n+        let n = format_strbuf!(\"TEST{}\", rng.gen_ascii_str(10u).as_slice());\n+        assert!(getenv(n.as_slice()).is_none());\n+        n.into_owned()\n     }\n \n     #[test]"}, {"sha": "b3268674fb1bbeddeffd38da1e33ff562b1a5343", "filename": "src/libsync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -189,7 +189,7 @@ mod test {\n     #[should_fail]\n     fn test_futurefail() {\n         let mut f = Future::spawn(proc() fail!());\n-        let _x: ~str = f.get();\n+        let _x: StrBuf = f.get();\n     }\n \n     #[test]"}, {"sha": "2d1b938ec3781733a3a84756fe3a2618529f8407", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -126,10 +126,12 @@ impl<T: Writer> Terminal<T> {\n     /// Returns `Err()` on failure to open the terminfo database correctly.\n     /// Also, in the event that the individual terminfo database entry can not\n     /// be parsed.\n-    pub fn new(out: T) -> Result<Terminal<T>, ~str> {\n+    pub fn new(out: T) -> Result<Terminal<T>, StrBuf> {\n         let term = match os::getenv(\"TERM\") {\n             Some(t) => t,\n-            None => return Err(\"TERM environment variable undefined\".to_owned())\n+            None => {\n+                return Err(\"TERM environment variable undefined\".to_strbuf())\n+            }\n         };\n \n         let mut file = match open(term) {\n@@ -251,7 +253,8 @@ impl<T: Writer> Terminal<T> {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_owned()), |op| {\n+        let s = cap.map_or(Err(\"can't find terminfo capability \\\n+                                `sgr0`\".to_strbuf()), |op| {\n             expand(op.as_slice(), [], &mut Variables::new())\n         });\n         if s.is_ok() {"}, {"sha": "46dd397853157cb889a45dc097e2fc679713b561", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,13 +15,13 @@ use collections::HashMap;\n /// A parsed terminfo database entry.\n pub struct TermInfo {\n     /// Names for the terminal\n-    pub names: Vec<~str> ,\n+    pub names: Vec<StrBuf> ,\n     /// Map of capability name to boolean value\n-    pub bools: HashMap<~str, bool>,\n+    pub bools: HashMap<StrBuf, bool>,\n     /// Map of capability name to numeric value\n-    pub numbers: HashMap<~str, u16>,\n+    pub numbers: HashMap<StrBuf, u16>,\n     /// Map of capability name to raw (unexpanded) string\n-    pub strings: HashMap<~str, Vec<u8> >\n+    pub strings: HashMap<StrBuf, Vec<u8> >\n }\n \n pub mod searcher;"}, {"sha": "ed94de8e81ddd2d7c3143af4ce8e503f0d72152e", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 68, "deletions": 59, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -41,7 +41,7 @@ enum FormatState {\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub enum Param {\n-    String(~str),\n+    String(StrBuf),\n     Number(int)\n }\n \n@@ -89,7 +89,7 @@ impl Variables {\n   multiple capabilities for the same terminal.\n   */\n pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n-    -> Result<Vec<u8> , ~str> {\n+    -> Result<Vec<u8> , StrBuf> {\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n@@ -124,9 +124,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n-                            _       => return Err(\"a non-char was used with %c\".to_owned())\n+                            _       => return Err(\"a non-char was used with %c\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n@@ -135,112 +135,112 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'l' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             String(s) => stack.push(Number(s.len() as int)),\n-                            _         => return Err(\"a non-str was used with %l\".to_owned())\n+                            _         => return Err(\"a non-str was used with %l\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '+' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x + y)),\n-                            _ => return Err(\"non-numbers on stack with +\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with +\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '-' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x - y)),\n-                            _ => return Err(\"non-numbers on stack with -\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with -\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '*' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x * y)),\n-                            _ => return Err(\"non-numbers on stack with *\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with *\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '/' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x / y)),\n-                            _ => return Err(\"non-numbers on stack with /\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with /\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'm' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x % y)),\n-                            _ => return Err(\"non-numbers on stack with %\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with %\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '&' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x & y)),\n-                            _ => return Err(\"non-numbers on stack with &\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with &\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '|' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x | y)),\n-                            _ => return Err(\"non-numbers on stack with |\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with |\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '^' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n-                            _ => return Err(\"non-numbers on stack with ^\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with ^\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '=' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with =\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with =\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '>' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with >\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with >\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '<' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with <\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with <\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'A' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(_)) => stack.push(Number(0)),\n                             (Number(_), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical and\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with logical and\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'O' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical or\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with logical or\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '!' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n-                            _ => return Err(\"non-number on stack with logical not\".to_owned())\n+                            _ => return Err(\"non-number on stack with logical not\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '~' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n-                            _         => return Err(\"non-number on stack with %~\".to_owned())\n+                            _         => return Err(\"non-number on stack with %~\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'i' => match (mparams[0].clone(), mparams[1].clone()) {\n                         (Number(x), Number(y)) => {\n                             mparams[0] = Number(x+1);\n                             mparams[1] = Number(y+1);\n                         },\n-                        (_, _) => return Err(\"first two params not numbers with %i\".to_owned())\n+                        (_, _) => return Err(\"first two params not numbers with %i\".to_strbuf())\n                     },\n \n                     // printf-style support for %doxXs\n@@ -249,7 +249,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice())\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     ':'|'#'|' '|'.'|'0'..'9' => {\n                         let mut flags = Flags::new();\n                         let mut fstate = FormatStateFlags;\n@@ -274,35 +274,39 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n                             _         => return Err(\"non-number on stack \\\n-                                                    with conditional\".to_owned())\n+                                                    with conditional\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n-                    _ => return Err(format!(\"unrecognized format option {}\", cur))\n+                    _ => {\n+                        return Err(format_strbuf!(\"unrecognized format \\\n+                                                   option {}\",\n+                                                  cur))\n+                    }\n                 }\n             },\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match char::to_digit(cur, 10) {\n                     Some(d) => d - 1,\n-                    None => return Err(\"bad param number\".to_owned())\n+                    None => return Err(\"bad param number\".to_strbuf())\n                 }].clone());\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('A' as u8);\n                         vars.sta[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_owned()) }\n+                    } else { return Err(\"stack is empty\".to_strbuf()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('a' as u8);\n                         vars.dyn[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_owned()) }\n+                    } else { return Err(\"stack is empty\".to_strbuf()) }\n                 } else {\n-                    return Err(\"bad variable name in %P\".to_owned());\n+                    return Err(\"bad variable name in %P\".to_strbuf());\n                 }\n             },\n             GetVar => {\n@@ -313,7 +317,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     let idx = (cur as u8) - ('a' as u8);\n                     stack.push(vars.dyn[idx as uint].clone());\n                 } else {\n-                    return Err(\"bad variable name in %g\".to_owned());\n+                    return Err(\"bad variable name in %g\".to_strbuf());\n                 }\n             },\n             CharConstant => {\n@@ -322,7 +326,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             CharClose => {\n                 if cur != '\\'' {\n-                    return Err(\"malformed character constant\".to_owned());\n+                    return Err(\"malformed character constant\".to_strbuf());\n                 }\n             },\n             IntConstant(i) => {\n@@ -335,7 +339,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         state = IntConstant(i*10 + (cur as int - '0' as int));\n                         old_state = Nothing;\n                     }\n-                    _ => return Err(\"bad int constant\".to_owned())\n+                    _ => return Err(\"bad int constant\".to_strbuf())\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n@@ -346,7 +350,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice());\n                         old_state = state; // will cause state to go to Nothing\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     (FormatStateFlags,'#') => {\n                         flags.alternate = true;\n                     }\n@@ -369,7 +373,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     (FormatStateWidth,'0'..'9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as uint - '0' as uint);\n-                        if flags.width < old { return Err(\"format width overflow\".to_owned()) }\n+                        if flags.width < old { return Err(\"format width overflow\".to_strbuf()) }\n                     }\n                     (FormatStateWidth,'.') => {\n                         *fstate = FormatStatePrecision;\n@@ -378,10 +382,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as uint - '0' as uint);\n                         if flags.precision < old {\n-                            return Err(\"format precision overflow\".to_owned())\n+                            return Err(\"format precision overflow\".to_strbuf())\n                         }\n                     }\n-                    _ => return Err(\"invalid format specifier\".to_owned())\n+                    _ => return Err(\"invalid format specifier\".to_strbuf())\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -479,7 +483,7 @@ impl FormatOp {\n     }\n }\n \n-fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,StrBuf> {\n     let mut s = match val {\n         Number(d) => {\n             let s = match (op, flags.sign) {\n@@ -488,7 +492,9 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n                 (FormatOctal, _)     => format!(\"{:o}\", d).into_bytes(),\n                 (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n                 (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n-                (FormatString, _)    => return Err(\"non-number on stack with %s\".to_owned()),\n+                (FormatString, _)    => {\n+                    return Err(\"non-number on stack with %s\".to_strbuf())\n+                }\n             };\n             let mut s: Vec<u8> = s.move_iter().collect();\n             if flags.precision > s.len() {\n@@ -543,7 +549,8 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n                     s\n                 }\n                 _ => {\n-                    return Err(format!(\"non-string on stack with %{}\", op.to_char()))\n+                    return Err(format_strbuf!(\"non-string on stack with %{}\",\n+                                              op.to_char()))\n                 }\n             }\n         }\n@@ -600,7 +607,7 @@ mod test {\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" {\n-                String(\"foo\".to_owned())\n+                String(\"foo\".to_strbuf())\n             } else {\n                 Number(97)\n             };\n@@ -678,10 +685,12 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n-                          [String(\"foo\".to_owned()), String(\"foo\".to_owned()),\n-                           String(\"f\".to_owned()), String(\"foo\".to_owned())], vars),\n+                          [String(\"foo\".to_strbuf()),\n+                           String(\"foo\".to_strbuf()),\n+                           String(\"f\".to_strbuf()),\n+                           String(\"foo\".to_strbuf())], vars),\n                    Ok(bytes!(\"foofoo ffo\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_owned())], vars),\n+        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_strbuf())], vars),\n                    Ok(bytes!(\"fo  \").iter().map(|x| *x).collect()));\n \n         assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),"}, {"sha": "5a1c8ea02e2219920a53b4f5b49c7f2eb9466ad1", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -160,9 +160,12 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader, longnames: bool)\n-             -> Result<Box<TermInfo>, ~str> {\n+             -> Result<Box<TermInfo>, StrBuf> {\n     macro_rules! try( ($e:expr) => (\n-        match $e { Ok(e) => e, Err(e) => return Err(format!(\"{}\", e)) }\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(format_strbuf!(\"{}\", e))\n+        }\n     ) )\n \n     let bnames;\n@@ -182,8 +185,10 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n     // Check magic number\n     let magic = try!(file.read_le_u16());\n     if magic != 0x011A {\n-        return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n-                           0x011A, magic as uint));\n+        return Err(format_strbuf!(\"invalid magic number: expected {:x} but \\\n+                                   found {:x}\",\n+                                  0x011A,\n+                                  magic as uint));\n     }\n \n     let names_bytes          = try!(file.read_le_i16()) as int;\n@@ -195,24 +200,30 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n     assert!(names_bytes          > 0);\n \n     if (bools_bytes as uint) > boolnames.len() {\n-        return Err(\"incompatible file: more booleans than expected\".to_owned());\n+        return Err(\"incompatible file: more booleans than \\\n+                    expected\".to_strbuf());\n     }\n \n     if (numbers_count as uint) > numnames.len() {\n-        return Err(\"incompatible file: more numbers than expected\".to_owned());\n+        return Err(\"incompatible file: more numbers than \\\n+                    expected\".to_strbuf());\n     }\n \n     if (string_offsets_count as uint) > stringnames.len() {\n-        return Err(\"incompatible file: more string offsets than expected\".to_owned());\n+        return Err(\"incompatible file: more string offsets than \\\n+                    expected\".to_strbuf());\n     }\n \n     // don't read NUL\n     let bytes = try!(file.read_exact(names_bytes as uint - 1));\n     let names_str = match str::from_utf8(bytes.as_slice()) {\n-        Some(s) => s.to_owned(), None => return Err(\"input not utf-8\".to_owned()),\n+        Some(s) => s.to_owned(),\n+        None => return Err(\"input not utf-8\".to_strbuf()),\n     };\n \n-    let term_names: Vec<~str> = names_str.split('|').map(|s| s.to_owned()).collect();\n+    let term_names: Vec<StrBuf> = names_str.split('|')\n+                                           .map(|s| s.to_strbuf())\n+                                           .collect();\n \n     try!(file.read_byte()); // consume NUL\n \n@@ -221,7 +232,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         for i in range(0, bools_bytes) {\n             let b = try!(file.read_byte());\n             if b == 1 {\n-                bools_map.insert(bnames[i as uint].to_owned(), true);\n+                bools_map.insert(bnames[i as uint].to_strbuf(), true);\n             }\n         }\n     }\n@@ -235,7 +246,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         for i in range(0, numbers_count) {\n             let n = try!(file.read_le_u16());\n             if n != 0xFFFF {\n-                numbers_map.insert(nnames[i as uint].to_owned(), n);\n+                numbers_map.insert(nnames[i as uint].to_strbuf(), n);\n             }\n         }\n     }\n@@ -251,7 +262,8 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         let string_table = try!(file.read_exact(string_table_bytes as uint));\n \n         if string_table.len() != string_table_bytes as uint {\n-            return Err(\"error: hit EOF before end of string table\".to_owned());\n+            return Err(\"error: hit EOF before end of string \\\n+                        table\".to_strbuf());\n         }\n \n         for (i, v) in string_offsets.iter().enumerate() {\n@@ -269,7 +281,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n             if offset == 0xFFFE {\n                 // undocumented: FFFE indicates cap@, which means the capability is not present\n                 // unsure if the handling for this is correct\n-                string_map.insert(name.to_owned(), Vec::new());\n+                string_map.insert(name.to_strbuf(), Vec::new());\n                 continue;\n             }\n \n@@ -279,13 +291,14 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n-                    string_map.insert(name.to_owned(),\n+                    string_map.insert(name.to_strbuf(),\n                                       Vec::from_slice(\n                                           string_table.slice(offset as uint,\n                                           offset as uint + len)))\n                 },\n                 None => {\n-                    return Err(\"invalid file: missing NUL in string_table\".to_owned());\n+                    return Err(\"invalid file: missing NUL in \\\n+                                string_table\".to_strbuf());\n                 }\n             };\n         }\n@@ -303,12 +316,12 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n-    strings.insert(\"bold\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n-    strings.insert(\"setaf\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n-    strings.insert(\"setab\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n+    strings.insert(\"sgr0\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n+    strings.insert(\"bold\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n+    strings.insert(\"setaf\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n+    strings.insert(\"setab\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n     box TermInfo {\n-        names: vec!(\"cygwin\".to_owned()), // msys is a fork of an older cygwin version\n+        names: vec!(\"cygwin\".to_strbuf()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),\n         strings: strings"}, {"sha": "a7365102f96cadbfdc9246d005f9063352110cde", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -76,15 +76,17 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n }\n \n /// Return open file for `term`\n-pub fn open(term: &str) -> Result<File, ~str> {\n+pub fn open(term: &str) -> Result<File, StrBuf> {\n     match get_dbpath_for_term(term) {\n         Some(x) => {\n             match File::open(x) {\n                 Ok(file) => Ok(file),\n-                Err(e) => Err(format!(\"error opening file: {}\", e)),\n+                Err(e) => Err(format_strbuf!(\"error opening file: {}\", e)),\n             }\n         }\n-        None => Err(format!(\"could not find terminfo entry for {}\", term))\n+        None => {\n+            Err(format_strbuf!(\"could not find terminfo entry for {}\", term))\n+        }\n     }\n }\n \n@@ -95,14 +97,14 @@ fn test_get_dbpath_for_term() {\n     // note: current tests won't work with non-standard terminfo hierarchies (e.g. OS X's)\n     use std::os::{setenv, unsetenv};\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    fn x(t: &str) -> ~str {\n+    fn x(t: &str) -> StrBuf {\n         let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n-        p.as_str().unwrap().to_owned()\n+        p.as_str().unwrap().to_strbuf()\n     };\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_owned());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_strbuf());\n     assert!(get_dbpath_for_term(\"\") == None);\n     setenv(\"TERMINFO_DIRS\", \":\");\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_owned());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_strbuf());\n     unsetenv(\"TERMINFO_DIRS\");\n }\n "}, {"sha": "ba8b8f776d97cbdc8bd35346953523683dc0c4ea", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 116, "deletions": 79, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -70,7 +70,7 @@ pub mod test {\n              MetricChange, Improvement, Regression, LikelyNoise,\n              StaticTestFn, StaticTestName, DynTestName, DynTestFn,\n              run_test, test_main, test_main_static, filter_tests,\n-             parse_opts, StaticBenchFn};\n+             parse_opts, StaticBenchFn, test_main_static_x};\n }\n \n pub mod stats;\n@@ -83,7 +83,7 @@ pub mod stats;\n #[deriving(Clone)]\n pub enum TestName {\n     StaticTestName(&'static str),\n-    DynTestName(~str)\n+    DynTestName(StrBuf)\n }\n impl fmt::Show for TestName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -98,20 +98,20 @@ impl fmt::Show for TestName {\n enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n \n impl TestDesc {\n-    fn padded_name(&self, column_count: uint, align: NamePadding) -> ~str {\n+    fn padded_name(&self, column_count: uint, align: NamePadding) -> StrBuf {\n         use std::num::Saturating;\n         let mut name = StrBuf::from_str(self.name.to_str());\n         let fill = column_count.saturating_sub(name.len());\n         let mut pad = StrBuf::from_owned_str(\" \".repeat(fill));\n         match align {\n-            PadNone => name.into_owned(),\n+            PadNone => name,\n             PadOnLeft => {\n                 pad.push_str(name.as_slice());\n-                pad.into_owned()\n+                pad\n             }\n             PadOnRight => {\n                 name.push_str(pad.as_slice());\n-                name.into_owned()\n+                name\n             }\n         }\n     }\n@@ -187,7 +187,7 @@ impl Metric {\n }\n \n #[deriving(Eq)]\n-pub struct MetricMap(TreeMap<~str,Metric>);\n+pub struct MetricMap(TreeMap<StrBuf,Metric>);\n \n impl Clone for MetricMap {\n     fn clone(&self) -> MetricMap {\n@@ -206,11 +206,11 @@ pub enum MetricChange {\n     Regression(f64)\n }\n \n-pub type MetricDiff = TreeMap<~str,MetricChange>;\n+pub type MetricDiff = TreeMap<StrBuf,MetricChange>;\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[~str], tests: Vec<TestDescAndFn> ) {\n+pub fn test_main(args: &[StrBuf], tests: Vec<TestDescAndFn> ) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n@@ -231,7 +231,7 @@ pub fn test_main(args: &[~str], tests: Vec<TestDescAndFn> ) {\n // a ~[TestDescAndFn] is used in order to effect ownership-transfer\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n-pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n+pub fn test_main_static(args: &[StrBuf], tests: &[TestDescAndFn]) {\n     let owned_tests = tests.iter().map(|t| {\n         match t.testfn {\n             StaticTestFn(f) =>\n@@ -248,8 +248,16 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n     test_main(args, owned_tests)\n }\n \n+pub fn test_main_static_x(args: &[~str], tests: &[TestDescAndFn]) {\n+    test_main_static(args.iter()\n+                         .map(|x| x.to_strbuf())\n+                         .collect::<Vec<_>>()\n+                         .as_slice(),\n+                     tests)\n+}\n+\n pub struct TestOpts {\n-    pub filter: Option<~str>,\n+    pub filter: Option<StrBuf>,\n     pub run_ignored: bool,\n     pub run_tests: bool,\n     pub run_benchmarks: bool,\n@@ -280,7 +288,7 @@ impl TestOpts {\n }\n \n /// Result of parsing the options.\n-pub type OptRes = Result<TestOpts, ~str>;\n+pub type OptRes = Result<TestOpts, StrBuf>;\n \n fn optgroups() -> Vec<getopts::OptGroup> {\n     vec!(getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n@@ -337,20 +345,30 @@ Test Attributes:\n }\n \n // Parses command line arguments into test options\n-pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n+pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match getopts::getopts(args_, optgroups().as_slice()) {\n+        match getopts::getopts(args_.iter()\n+                                    .map(|x| x.to_owned())\n+                                    .collect::<Vec<_>>()\n+                                    .as_slice(),\n+                               optgroups().as_slice()) {\n           Ok(m) => m,\n-          Err(f) => return Some(Err(f.to_err_msg()))\n+          Err(f) => return Some(Err(f.to_err_msg().to_strbuf()))\n         };\n \n-    if matches.opt_present(\"h\") { usage(args[0], \"h\"); return None; }\n-    if matches.opt_present(\"help\") { usage(args[0], \"help\"); return None; }\n+    if matches.opt_present(\"h\") {\n+        usage(args[0].as_slice(), \"h\");\n+        return None;\n+    }\n+    if matches.opt_present(\"help\") {\n+        usage(args[0].as_slice(), \"help\");\n+        return None;\n+    }\n \n     let filter =\n         if matches.free.len() > 0 {\n-            Some((*matches.free.get(0)).clone())\n+            Some((*matches.free.get(0)).to_strbuf())\n         } else {\n             None\n         };\n@@ -374,7 +392,7 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let save_metrics = save_metrics.map(|s| Path::new(s));\n \n     let test_shard = matches.opt_str(\"test-shard\");\n-    let test_shard = opt_shard(test_shard);\n+    let test_shard = opt_shard(test_shard.map(|x| x.to_strbuf()));\n \n     let mut nocapture = matches.opt_present(\"nocapture\");\n     if !nocapture {\n@@ -397,11 +415,11 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     Some(Ok(test_opts))\n }\n \n-pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n+pub fn opt_shard(maybestr: Option<StrBuf>) -> Option<(uint,uint)> {\n     match maybestr {\n         None => None,\n         Some(s) => {\n-            let mut it = s.split('.');\n+            let mut it = s.as_slice().split('.');\n             match (it.next().and_then(from_str), it.next().and_then(from_str), it.next()) {\n                 (Some(a), Some(b), None) => Some((a, b)),\n                 _ => None,\n@@ -567,9 +585,9 @@ impl<T: Writer> ConsoleTestState<T> {\n             None => Ok(()),\n             Some(ref mut o) => {\n                 let s = format!(\"{} {}\\n\", match *result {\n-                        TrOk => \"ok\".to_owned(),\n-                        TrFailed => \"failed\".to_owned(),\n-                        TrIgnored => \"ignored\".to_owned(),\n+                        TrOk => \"ok\".to_strbuf(),\n+                        TrFailed => \"failed\".to_strbuf(),\n+                        TrIgnored => \"ignored\".to_strbuf(),\n                         TrMetrics(ref mm) => fmt_metrics(mm),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.to_str());\n@@ -696,25 +714,25 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n }\n \n-pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n+pub fn fmt_metrics(mm: &MetricMap) -> StrBuf {\n     let MetricMap(ref mm) = *mm;\n-    let v : Vec<~str> = mm.iter()\n-        .map(|(k,v)| format!(\"{}: {} (+/- {})\",\n+    let v : Vec<StrBuf> = mm.iter()\n+        .map(|(k,v)| format_strbuf!(\"{}: {} (+/- {})\",\n                           *k,\n                           v.value as f64,\n                           v.noise as f64))\n         .collect();\n-    v.connect(\", \")\n+    v.connect(\", \").to_strbuf()\n }\n \n-pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n+pub fn fmt_bench_samples(bs: &BenchSamples) -> StrBuf {\n     if bs.mb_s != 0 {\n-        format!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n+        format_strbuf!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n              bs.mb_s)\n     } else {\n-        format!(\"{:>9} ns/iter (+/- {})\",\n+        format_strbuf!(\"{:>9} ns/iter (+/- {})\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n     }\n@@ -738,8 +756,10 @@ pub fn run_tests_console(opts: &TestOpts,\n                         let tname = test.name.to_str();\n                         let MetricMap(mm) = mm;\n                         for (k,v) in mm.iter() {\n-                            st.metrics.insert_metric(tname + \".\" + *k,\n-                                                     v.value, v.noise);\n+                            st.metrics\n+                              .insert_metric(tname + \".\" + k.as_slice(),\n+                                             v.value,\n+                                             v.noise);\n                         }\n                         st.measured += 1\n                     }\n@@ -924,7 +944,7 @@ pub fn filter_tests(\n     } else {\n         let filter_str = match opts.filter {\n           Some(ref f) => (*f).clone(),\n-          None => \"\".to_owned()\n+          None => \"\".to_strbuf()\n         };\n \n         fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n@@ -936,7 +956,9 @@ pub fn filter_tests(\n             }\n         }\n \n-        filtered.move_iter().filter_map(|x| filter_fn(x, filter_str)).collect()\n+        filtered.move_iter()\n+                .filter_map(|x| filter_fn(x, filter_str.as_slice()))\n+                .collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -995,8 +1017,8 @@ pub fn run_test(opts: &TestOpts,\n             let stdout = ChanWriter::new(tx.clone());\n             let stderr = ChanWriter::new(tx);\n             let mut task = TaskBuilder::new().named(match desc.name {\n-                DynTestName(ref name) => name.clone().into_maybe_owned(),\n-                StaticTestName(name) => name.into_maybe_owned(),\n+                DynTestName(ref name) => name.clone().to_owned(),\n+                StaticTestName(name) => name.to_owned(),\n             });\n             if nocapture {\n                 drop((stdout, stderr));\n@@ -1091,7 +1113,14 @@ impl MetricMap {\n     pub fn save(&self, p: &Path) -> io::IoResult<()> {\n         let mut file = try!(File::create(p));\n         let MetricMap(ref map) = *self;\n-        map.to_json().to_pretty_writer(&mut file)\n+\n+        // FIXME(pcwalton): Yuck.\n+        let mut new_map = TreeMap::new();\n+        for (ref key, ref value) in map.iter() {\n+            new_map.insert(key.to_owned(), (*value).clone());\n+        }\n+\n+        new_map.to_json().to_pretty_writer(&mut file)\n     }\n \n     /// Compare against another MetricMap. Optionally compare all\n@@ -1170,7 +1199,7 @@ impl MetricMap {\n             noise: noise\n         };\n         let MetricMap(ref mut map) = *self;\n-        map.insert(name.to_owned(), m);\n+        map.insert(name.to_strbuf(), m);\n     }\n \n     /// Attempt to \"ratchet\" an external metric file. This involves loading\n@@ -1416,17 +1445,19 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = vec!(\"progname\".to_owned(), \"filter\".to_owned());\n+        let args = vec!(\"progname\".to_strbuf(), \"filter\".to_strbuf());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(\"filter\" == opts.filter.clone().unwrap());\n+        assert!(\"filter\" == opts.filter.clone().unwrap().as_slice());\n     }\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = vec!(\"progname\".to_owned(), \"filter\".to_owned(), \"--ignored\".to_owned());\n+        let args = vec!(\"progname\".to_strbuf(),\n+                        \"filter\".to_strbuf(),\n+                        \"--ignored\".to_strbuf());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in parse_ignored_flag\")\n@@ -1463,7 +1494,8 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered.get(0).desc.name.to_str(), \"1\".to_owned());\n+        assert_eq!(filtered.get(0).desc.name.to_str().to_strbuf(),\n+                   \"1\".to_strbuf());\n         assert!(filtered.get(0).desc.ignore == false);\n     }\n \n@@ -1473,12 +1505,15 @@ mod tests {\n         opts.run_tests = true;\n \n         let names =\n-            vec!(\"sha1::test\".to_owned(), \"int::test_to_str\".to_owned(), \"int::test_pow\".to_owned(),\n-             \"test::do_not_run_ignored_tests\".to_owned(),\n-             \"test::ignored_tests_result_in_ignored\".to_owned(),\n-             \"test::first_free_arg_should_be_a_filter\".to_owned(),\n-             \"test::parse_ignored_flag\".to_owned(), \"test::filter_for_ignored_option\".to_owned(),\n-             \"test::sort_tests\".to_owned());\n+            vec!(\"sha1::test\".to_strbuf(),\n+                 \"int::test_to_str\".to_strbuf(),\n+                 \"int::test_pow\".to_strbuf(),\n+                 \"test::do_not_run_ignored_tests\".to_strbuf(),\n+                 \"test::ignored_tests_result_in_ignored\".to_strbuf(),\n+                 \"test::first_free_arg_should_be_a_filter\".to_strbuf(),\n+                 \"test::parse_ignored_flag\".to_strbuf(),\n+                 \"test::filter_for_ignored_option\".to_strbuf(),\n+                 \"test::sort_tests\".to_strbuf());\n         let tests =\n         {\n             fn testfn() { }\n@@ -1499,16 +1534,18 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         let expected =\n-            vec!(\"int::test_pow\".to_owned(), \"int::test_to_str\".to_owned(), \"sha1::test\".to_owned(),\n-              \"test::do_not_run_ignored_tests\".to_owned(),\n-              \"test::filter_for_ignored_option\".to_owned(),\n-              \"test::first_free_arg_should_be_a_filter\".to_owned(),\n-              \"test::ignored_tests_result_in_ignored\".to_owned(),\n-              \"test::parse_ignored_flag\".to_owned(),\n-              \"test::sort_tests\".to_owned());\n+            vec!(\"int::test_pow\".to_strbuf(),\n+                 \"int::test_to_str\".to_strbuf(),\n+                 \"sha1::test\".to_strbuf(),\n+                 \"test::do_not_run_ignored_tests\".to_strbuf(),\n+                 \"test::filter_for_ignored_option\".to_strbuf(),\n+                 \"test::first_free_arg_should_be_a_filter\".to_strbuf(),\n+                 \"test::ignored_tests_result_in_ignored\".to_strbuf(),\n+                 \"test::parse_ignored_flag\".to_strbuf(),\n+                 \"test::sort_tests\".to_strbuf());\n \n         for (a, b) in expected.iter().zip(filtered.iter()) {\n-            assert!(*a == b.desc.name.to_str());\n+            assert!(*a == b.desc.name.to_str().to_strbuf());\n         }\n     }\n \n@@ -1536,31 +1573,31 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&\"in-both-noise\".to_owned()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&\"in-first-noise\".to_owned()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&\"in-second-noise\".to_owned()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-noise\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"in-first-noise\".to_strbuf()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.find(&\"in-second-noise\".to_strbuf()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_strbuf()).unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_strbuf()).unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_strbuf()).unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_strbuf()).unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&\"in-both-noise\".to_owned()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-first-noise\".to_owned()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&\"in-second-noise\".to_owned()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-noise\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-first-noise\".to_strbuf()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.find(&\"in-second-noise\".to_strbuf()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n@@ -1585,29 +1622,29 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&\"runtime\".to_owned()).unwrap()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&\"throughput\".to_owned()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"runtime\".to_strbuf()).unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.find(&\"throughput\".to_strbuf()).unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         let MetricMap(m3) = m3;\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&\"runtime\".to_owned()).unwrap()), Metric::new(1000.0, 2.0));\n-        assert_eq!(*(m3.find(&\"throughput\".to_owned()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m3.find(&\"runtime\".to_strbuf()).unwrap()), Metric::new(1000.0, 2.0));\n+        assert_eq!(*(m3.find(&\"throughput\".to_strbuf()).unwrap()), Metric::new(50.0, 2.0));\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&\"runtime\".to_owned()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"throughput\".to_owned()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"runtime\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"throughput\".to_strbuf()).unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         let MetricMap(m4) = m4;\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&\"runtime\".to_owned()).unwrap()), Metric::new(1100.0, 2.0));\n-        assert_eq!(*(m4.find(&\"throughput\".to_owned()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m4.find(&\"runtime\".to_strbuf()).unwrap()), Metric::new(1100.0, 2.0));\n+        assert_eq!(*(m4.find(&\"throughput\".to_strbuf()).unwrap()), Metric::new(50.0, 2.0));\n     }\n }"}, {"sha": "bf40a2d601fcca67d75aaeeead94ffc270b0ef2e", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -1028,17 +1028,20 @@ mod tests {\n     #[test]\n     fn test_boxplot_nonpositive() {\n         #[allow(deprecated_owned_vector)]\n-        fn t(s: &Summary<f64>, expected: ~str) {\n+        fn t(s: &Summary<f64>, expected: StrBuf) {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n-            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n+            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_strbuf();\n             assert_eq!(out, expected);\n         }\n \n-        t(&Summary::new([-2.0, -1.0]), \"-2 |[------******#*****---]| -1\".to_owned());\n-        t(&Summary::new([0.0, 2.0]), \"0 |[-------*****#*******---]| 2\".to_owned());\n-        t(&Summary::new([-2.0, 0.0]), \"-2 |[------******#******---]| 0\".to_owned());\n+        t(&Summary::new([-2.0, -1.0]),\n+                        \"-2 |[------******#*****---]| -1\".to_strbuf());\n+        t(&Summary::new([0.0, 2.0]),\n+                        \"0 |[-------*****#*******---]| 2\".to_strbuf());\n+        t(&Summary::new([-2.0, 0.0]),\n+                        \"-2 |[------******#******---]| 0\".to_strbuf());\n \n     }\n     #[test]"}, {"sha": "1ffe4d3cbadc456d0c87fd34f5262c359df84cc7", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 267, "deletions": 261, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -315,10 +315,10 @@ impl Tm {\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    pub fn ctime(&self) -> ~str { self.strftime(\"%c\") }\n+    pub fn ctime(&self) -> StrBuf { self.strftime(\"%c\") }\n \n     /// Formats the time according to the format string.\n-    pub fn strftime(&self, format: &str) -> ~str {\n+    pub fn strftime(&self, format: &str) -> StrBuf {\n         strftime(format, self)\n     }\n \n@@ -328,7 +328,7 @@ impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    pub fn rfc822(&self) -> ~str {\n+    pub fn rfc822(&self) -> StrBuf {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%a, %d %b %Y %T GMT\")\n         } else {\n@@ -342,7 +342,7 @@ impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    pub fn rfc822z(&self) -> ~str {\n+    pub fn rfc822z(&self) -> StrBuf {\n         self.strftime(\"%a, %d %b %Y %T %z\")\n     }\n \n@@ -352,7 +352,7 @@ impl Tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    pub fn rfc3339(&self) -> ~str {\n+    pub fn rfc3339(&self) -> StrBuf {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {\n@@ -361,13 +361,13 @@ impl Tm {\n             let mut m = num::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            s + format!(\"{}{:02d}:{:02d}\", sign, h as int, m as int)\n+            format_strbuf!(\"{}{}{:02d}:{:02d}\", s, sign, h as int, m as int)\n         }\n     }\n }\n \n /// Parses the time from the string according to the format string.\n-pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n+pub fn strptime(s: &str, format: &str) -> Result<Tm, StrBuf> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n         for ch in needle.bytes() {\n@@ -379,14 +379,14 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         return true;\n     }\n \n-    fn match_strs(ss: &str, pos: uint, strs: &[(~str, i32)])\n+    fn match_strs(ss: &str, pos: uint, strs: &[(StrBuf, i32)])\n       -> Option<(i32, uint)> {\n         let mut i = 0u;\n         let len = strs.len();\n         while i < len {\n             match strs[i] { // can't use let due to let-pattern bugs\n                 (ref needle, value) => {\n-                    if match_str(ss, pos, *needle) {\n+                    if match_str(ss, pos, needle.as_slice()) {\n                         return Some((value, pos + needle.len()));\n                     }\n                 }\n@@ -461,78 +461,78 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ~str> {\n+    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, StrBuf> {\n         let range = s.char_range_at(pos);\n \n         if c == range.ch {\n             Ok(range.next)\n         } else {\n-            Err(format!(\"Expected {}, found {}\",\n+            Err(format_strbuf!(\"Expected {}, found {}\",\n                 str::from_char(c),\n                 str::from_char(range.ch)))\n         }\n     }\n \n     fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n-      -> Result<uint, ~str> {\n+      -> Result<uint, StrBuf> {\n         match ch {\n           'A' => match match_strs(s, pos, [\n-              (\"Sunday\".to_owned(), 0_i32),\n-              (\"Monday\".to_owned(), 1_i32),\n-              (\"Tuesday\".to_owned(), 2_i32),\n-              (\"Wednesday\".to_owned(), 3_i32),\n-              (\"Thursday\".to_owned(), 4_i32),\n-              (\"Friday\".to_owned(), 5_i32),\n-              (\"Saturday\".to_owned(), 6_i32)\n+              (\"Sunday\".to_strbuf(), 0_i32),\n+              (\"Monday\".to_strbuf(), 1_i32),\n+              (\"Tuesday\".to_strbuf(), 2_i32),\n+              (\"Wednesday\".to_strbuf(), 3_i32),\n+              (\"Thursday\".to_strbuf(), 4_i32),\n+              (\"Friday\".to_strbuf(), 5_i32),\n+              (\"Saturday\".to_strbuf(), 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(\"Invalid day\".to_owned())\n+            None => Err(\"Invalid day\".to_strbuf())\n           },\n           'a' => match match_strs(s, pos, [\n-              (\"Sun\".to_owned(), 0_i32),\n-              (\"Mon\".to_owned(), 1_i32),\n-              (\"Tue\".to_owned(), 2_i32),\n-              (\"Wed\".to_owned(), 3_i32),\n-              (\"Thu\".to_owned(), 4_i32),\n-              (\"Fri\".to_owned(), 5_i32),\n-              (\"Sat\".to_owned(), 6_i32)\n+              (\"Sun\".to_strbuf(), 0_i32),\n+              (\"Mon\".to_strbuf(), 1_i32),\n+              (\"Tue\".to_strbuf(), 2_i32),\n+              (\"Wed\".to_strbuf(), 3_i32),\n+              (\"Thu\".to_strbuf(), 4_i32),\n+              (\"Fri\".to_strbuf(), 5_i32),\n+              (\"Sat\".to_strbuf(), 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(\"Invalid day\".to_owned())\n+            None => Err(\"Invalid day\".to_strbuf())\n           },\n           'B' => match match_strs(s, pos, [\n-              (\"January\".to_owned(), 0_i32),\n-              (\"February\".to_owned(), 1_i32),\n-              (\"March\".to_owned(), 2_i32),\n-              (\"April\".to_owned(), 3_i32),\n-              (\"May\".to_owned(), 4_i32),\n-              (\"June\".to_owned(), 5_i32),\n-              (\"July\".to_owned(), 6_i32),\n-              (\"August\".to_owned(), 7_i32),\n-              (\"September\".to_owned(), 8_i32),\n-              (\"October\".to_owned(), 9_i32),\n-              (\"November\".to_owned(), 10_i32),\n-              (\"December\".to_owned(), 11_i32)\n+              (\"January\".to_strbuf(), 0_i32),\n+              (\"February\".to_strbuf(), 1_i32),\n+              (\"March\".to_strbuf(), 2_i32),\n+              (\"April\".to_strbuf(), 3_i32),\n+              (\"May\".to_strbuf(), 4_i32),\n+              (\"June\".to_strbuf(), 5_i32),\n+              (\"July\".to_strbuf(), 6_i32),\n+              (\"August\".to_strbuf(), 7_i32),\n+              (\"September\".to_strbuf(), 8_i32),\n+              (\"October\".to_strbuf(), 9_i32),\n+              (\"November\".to_strbuf(), 10_i32),\n+              (\"December\".to_strbuf(), 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(\"Invalid month\".to_owned())\n+            None => Err(\"Invalid month\".to_strbuf())\n           },\n           'b' | 'h' => match match_strs(s, pos, [\n-              (\"Jan\".to_owned(), 0_i32),\n-              (\"Feb\".to_owned(), 1_i32),\n-              (\"Mar\".to_owned(), 2_i32),\n-              (\"Apr\".to_owned(), 3_i32),\n-              (\"May\".to_owned(), 4_i32),\n-              (\"Jun\".to_owned(), 5_i32),\n-              (\"Jul\".to_owned(), 6_i32),\n-              (\"Aug\".to_owned(), 7_i32),\n-              (\"Sep\".to_owned(), 8_i32),\n-              (\"Oct\".to_owned(), 9_i32),\n-              (\"Nov\".to_owned(), 10_i32),\n-              (\"Dec\".to_owned(), 11_i32)\n+              (\"Jan\".to_strbuf(), 0_i32),\n+              (\"Feb\".to_strbuf(), 1_i32),\n+              (\"Mar\".to_strbuf(), 2_i32),\n+              (\"Apr\".to_strbuf(), 3_i32),\n+              (\"May\".to_strbuf(), 4_i32),\n+              (\"Jun\".to_strbuf(), 5_i32),\n+              (\"Jul\".to_strbuf(), 6_i32),\n+              (\"Aug\".to_strbuf(), 7_i32),\n+              (\"Sep\".to_strbuf(), 8_i32),\n+              (\"Oct\".to_strbuf(), 9_i32),\n+              (\"Nov\".to_strbuf(), 10_i32),\n+              (\"Dec\".to_strbuf(), 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(\"Invalid month\".to_owned())\n+            None => Err(\"Invalid month\".to_strbuf())\n           },\n           'C' => match match_digits_in_range(s, pos, 2u, false, 0_i32,\n                                              99_i32) {\n@@ -541,7 +541,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                   tm.tm_year += (v * 100_i32) - 1900_i32;\n                   Ok(pos)\n               }\n-            None => Err(\"Invalid year\".to_owned())\n+            None => Err(\"Invalid year\".to_strbuf())\n           },\n           'c' => {\n             parse_type(s, pos, 'a', &mut *tm)\n@@ -564,12 +564,12 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           'd' => match match_digits_in_range(s, pos, 2u, false, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(\"Invalid day of the month\".to_owned())\n+            None => Err(\"Invalid day of the month\".to_strbuf())\n           },\n           'e' => match match_digits_in_range(s, pos, 2u, true, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(\"Invalid day of the month\".to_owned())\n+            None => Err(\"Invalid day of the month\".to_strbuf())\n           },\n           'f' => {\n             let (val, pos) = match_fractional_seconds(s, pos);\n@@ -586,7 +586,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           'H' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(\"Invalid hour\".to_owned())\n+              None => Err(\"Invalid hour\".to_strbuf())\n             }\n           }\n           'I' => {\n@@ -596,7 +596,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(\"Invalid hour\".to_owned())\n+              None => Err(\"Invalid hour\".to_strbuf())\n             }\n           }\n           'j' => {\n@@ -606,13 +606,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_yday = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid day of year\".to_owned())\n+              None => Err(\"Invalid day of year\".to_strbuf())\n             }\n           }\n           'k' => {\n             match match_digits_in_range(s, pos, 2u, true, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(\"Invalid hour\".to_owned())\n+              None => Err(\"Invalid hour\".to_strbuf())\n             }\n           }\n           'l' => {\n@@ -622,13 +622,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(\"Invalid hour\".to_owned())\n+              None => Err(\"Invalid hour\".to_strbuf())\n             }\n           }\n           'M' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 59_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_min = v; Ok(pos) }\n-              None => Err(\"Invalid minute\".to_owned())\n+              None => Err(\"Invalid minute\".to_strbuf())\n             }\n           }\n           'm' => {\n@@ -638,21 +638,21 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_mon = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid month\".to_owned())\n+              None => Err(\"Invalid month\".to_strbuf())\n             }\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n-                                  [(\"am\".to_owned(), 0_i32), (\"pm\".to_owned(), 12_i32)]) {\n+                                  [(\"am\".to_strbuf(), 0_i32), (\"pm\".to_strbuf(), 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(\"Invalid hour\".to_owned())\n+            None => Err(\"Invalid hour\".to_strbuf())\n           },\n           'p' => match match_strs(s, pos,\n-                                  [(\"AM\".to_owned(), 0_i32), (\"PM\".to_owned(), 12_i32)]) {\n+                                  [(\"AM\".to_strbuf(), 0_i32), (\"PM\".to_strbuf(), 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(\"Invalid hour\".to_owned())\n+            None => Err(\"Invalid hour\".to_strbuf())\n           },\n           'R' => {\n             parse_type(s, pos, 'H', &mut *tm)\n@@ -675,7 +675,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_sec = v;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid second\".to_owned())\n+              None => Err(\"Invalid second\".to_strbuf())\n             }\n           }\n           //'s' {}\n@@ -694,7 +694,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_wday = if v == 7 { 0 } else { v };\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid day of week\".to_owned())\n+              None => Err(\"Invalid day of week\".to_strbuf())\n             }\n           }\n           'v' => {\n@@ -708,7 +708,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           'w' => {\n             match match_digits_in_range(s, pos, 1u, false, 0_i32, 6_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-              None => Err(\"Invalid day of week\".to_owned())\n+              None => Err(\"Invalid day of week\".to_strbuf())\n             }\n           }\n           'Y' => {\n@@ -718,7 +718,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_year = v - 1900_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid year\".to_owned())\n+              None => Err(\"Invalid year\".to_strbuf())\n             }\n           }\n           'y' => {\n@@ -728,7 +728,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_year = v;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid year\".to_owned())\n+              None => Err(\"Invalid year\".to_strbuf())\n             }\n           }\n           'Z' => {\n@@ -764,15 +764,16 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n                     Ok(pos)\n                   }\n-                  None => Err(\"Invalid zone offset\".to_owned())\n+                  None => Err(\"Invalid zone offset\".to_strbuf())\n                 }\n             } else {\n-                Err(\"Invalid zone offset\".to_owned())\n+                Err(\"Invalid zone offset\".to_strbuf())\n             }\n           }\n           '%' => parse_char(s, pos, '%'),\n           ch => {\n-            Err(format!(\"unknown formatting type: {}\", str::from_char(ch)))\n+            Err(format_strbuf!(\"unknown formatting type: {}\",\n+                               str::from_char(ch)))\n           }\n         }\n     }\n@@ -794,7 +795,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     };\n     let mut pos = 0u;\n     let len = s.len();\n-    let mut result = Err(\"Invalid time\".to_owned());\n+    let mut result = Err(\"Invalid time\".to_strbuf());\n \n     while pos < len {\n         let range = s.char_range_at(pos);\n@@ -843,7 +844,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n }\n \n /// Formats the time according to the format string.\n-pub fn strftime(format: &str, tm: &Tm) -> ~str {\n+pub fn strftime(format: &str, tm: &Tm) -> StrBuf {\n     fn days_in_year(year: int) -> i32 {\n         if (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)) {\n             366    /* Days in a leap year */\n@@ -871,7 +872,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n             + iso_week1_wday - iso_week_start_wday\n     }\n \n-    fn iso_week(ch:char, tm: &Tm) -> ~str {\n+    fn iso_week(ch:char, tm: &Tm) -> StrBuf {\n         let mut year: int = tm.tm_year as int + 1900;\n         let mut days: int = iso_week_days (tm.tm_yday, tm.tm_wday);\n \n@@ -890,160 +891,164 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n         }\n \n         match ch {\n-            'G' => format!(\"{}\", year),\n-            'g' => format!(\"{:02d}\", (year % 100 + 100) % 100),\n-            'V' => format!(\"{:02d}\", days / 7 + 1),\n-            _ => \"\".to_owned()\n+            'G' => format_strbuf!(\"{}\", year),\n+            'g' => format_strbuf!(\"{:02d}\", (year % 100 + 100) % 100),\n+            'V' => format_strbuf!(\"{:02d}\", days / 7 + 1),\n+            _ => \"\".to_strbuf()\n         }\n     }\n \n-    fn parse_type(ch: char, tm: &Tm) -> ~str {\n-      let die = || format!(\"strftime: can't understand this format {} \", ch);\n+    fn parse_type(ch: char, tm: &Tm) -> StrBuf {\n+      let die = || {\n+          format_strbuf!(\"strftime: can't understand this format {} \", ch)\n+      };\n         match ch {\n           'A' => match tm.tm_wday as int {\n-            0 => \"Sunday\".to_owned(),\n-            1 => \"Monday\".to_owned(),\n-            2 => \"Tuesday\".to_owned(),\n-            3 => \"Wednesday\".to_owned(),\n-            4 => \"Thursday\".to_owned(),\n-            5 => \"Friday\".to_owned(),\n-            6 => \"Saturday\".to_owned(),\n+            0 => \"Sunday\".to_strbuf(),\n+            1 => \"Monday\".to_strbuf(),\n+            2 => \"Tuesday\".to_strbuf(),\n+            3 => \"Wednesday\".to_strbuf(),\n+            4 => \"Thursday\".to_strbuf(),\n+            5 => \"Friday\".to_strbuf(),\n+            6 => \"Saturday\".to_strbuf(),\n             _ => die()\n           },\n          'a' => match tm.tm_wday as int {\n-            0 => \"Sun\".to_owned(),\n-            1 => \"Mon\".to_owned(),\n-            2 => \"Tue\".to_owned(),\n-            3 => \"Wed\".to_owned(),\n-            4 => \"Thu\".to_owned(),\n-            5 => \"Fri\".to_owned(),\n-            6 => \"Sat\".to_owned(),\n+            0 => \"Sun\".to_strbuf(),\n+            1 => \"Mon\".to_strbuf(),\n+            2 => \"Tue\".to_strbuf(),\n+            3 => \"Wed\".to_strbuf(),\n+            4 => \"Thu\".to_strbuf(),\n+            5 => \"Fri\".to_strbuf(),\n+            6 => \"Sat\".to_strbuf(),\n             _ => die()\n           },\n           'B' => match tm.tm_mon as int {\n-            0 => \"January\".to_owned(),\n-            1 => \"February\".to_owned(),\n-            2 => \"March\".to_owned(),\n-            3 => \"April\".to_owned(),\n-            4 => \"May\".to_owned(),\n-            5 => \"June\".to_owned(),\n-            6 => \"July\".to_owned(),\n-            7 => \"August\".to_owned(),\n-            8 => \"September\".to_owned(),\n-            9 => \"October\".to_owned(),\n-            10 => \"November\".to_owned(),\n-            11 => \"December\".to_owned(),\n+            0 => \"January\".to_strbuf(),\n+            1 => \"February\".to_strbuf(),\n+            2 => \"March\".to_strbuf(),\n+            3 => \"April\".to_strbuf(),\n+            4 => \"May\".to_strbuf(),\n+            5 => \"June\".to_strbuf(),\n+            6 => \"July\".to_strbuf(),\n+            7 => \"August\".to_strbuf(),\n+            8 => \"September\".to_strbuf(),\n+            9 => \"October\".to_strbuf(),\n+            10 => \"November\".to_strbuf(),\n+            11 => \"December\".to_strbuf(),\n             _ => die()\n           },\n           'b' | 'h' => match tm.tm_mon as int {\n-            0 => \"Jan\".to_owned(),\n-            1 => \"Feb\".to_owned(),\n-            2 => \"Mar\".to_owned(),\n-            3 => \"Apr\".to_owned(),\n-            4 => \"May\".to_owned(),\n-            5 => \"Jun\".to_owned(),\n-            6 => \"Jul\".to_owned(),\n-            7 => \"Aug\".to_owned(),\n-            8 => \"Sep\".to_owned(),\n-            9 => \"Oct\".to_owned(),\n-            10 => \"Nov\".to_owned(),\n-            11 => \"Dec\".to_owned(),\n+            0 => \"Jan\".to_strbuf(),\n+            1 => \"Feb\".to_strbuf(),\n+            2 => \"Mar\".to_strbuf(),\n+            3 => \"Apr\".to_strbuf(),\n+            4 => \"May\".to_strbuf(),\n+            5 => \"Jun\".to_strbuf(),\n+            6 => \"Jul\".to_strbuf(),\n+            7 => \"Aug\".to_strbuf(),\n+            8 => \"Sep\".to_strbuf(),\n+            9 => \"Oct\".to_strbuf(),\n+            10 => \"Nov\".to_strbuf(),\n+            11 => \"Dec\".to_strbuf(),\n             _  => die()\n           },\n-          'C' => format!(\"{:02d}\", (tm.tm_year as int + 1900) / 100),\n+          'C' => format_strbuf!(\"{:02d}\", (tm.tm_year as int + 1900) / 100),\n           'c' => {\n-            format!(\"{} {} {} {} {}\",\n+            format_strbuf!(\"{} {} {} {} {}\",\n                 parse_type('a', tm),\n                 parse_type('b', tm),\n                 parse_type('e', tm),\n                 parse_type('T', tm),\n                 parse_type('Y', tm))\n           }\n           'D' | 'x' => {\n-            format!(\"{}/{}/{}\",\n+            format_strbuf!(\"{}/{}/{}\",\n                 parse_type('m', tm),\n                 parse_type('d', tm),\n                 parse_type('y', tm))\n           }\n-          'd' => format!(\"{:02d}\", tm.tm_mday),\n-          'e' => format!(\"{:2d}\", tm.tm_mday),\n-          'f' => format!(\"{:09d}\", tm.tm_nsec),\n+          'd' => format_strbuf!(\"{:02d}\", tm.tm_mday),\n+          'e' => format_strbuf!(\"{:2d}\", tm.tm_mday),\n+          'f' => format_strbuf!(\"{:09d}\", tm.tm_nsec),\n           'F' => {\n-            format!(\"{}-{}-{}\",\n+            format_strbuf!(\"{}-{}-{}\",\n                 parse_type('Y', tm),\n                 parse_type('m', tm),\n                 parse_type('d', tm))\n           }\n           'G' => iso_week('G', tm),\n           'g' => iso_week('g', tm),\n-          'H' => format!(\"{:02d}\", tm.tm_hour),\n+          'H' => format_strbuf!(\"{:02d}\", tm.tm_hour),\n           'I' => {\n             let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            format!(\"{:02d}\", h)\n+            format_strbuf!(\"{:02d}\", h)\n           }\n-          'j' => format!(\"{:03d}\", tm.tm_yday + 1),\n-          'k' => format!(\"{:2d}\", tm.tm_hour),\n+          'j' => format_strbuf!(\"{:03d}\", tm.tm_yday + 1),\n+          'k' => format_strbuf!(\"{:2d}\", tm.tm_hour),\n           'l' => {\n             let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            format!(\"{:2d}\", h)\n+            format_strbuf!(\"{:2d}\", h)\n           }\n-          'M' => format!(\"{:02d}\", tm.tm_min),\n-          'm' => format!(\"{:02d}\", tm.tm_mon + 1),\n-          'n' => \"\\n\".to_owned(),\n-          'P' => if (tm.tm_hour as int) < 12 { \"am\".to_owned() } else { \"pm\".to_owned() },\n-          'p' => if (tm.tm_hour as int) < 12 { \"AM\".to_owned() } else { \"PM\".to_owned() },\n+          'M' => format_strbuf!(\"{:02d}\", tm.tm_min),\n+          'm' => format_strbuf!(\"{:02d}\", tm.tm_mon + 1),\n+          'n' => \"\\n\".to_strbuf(),\n+          'P' => if (tm.tm_hour as int) < 12 { \"am\".to_strbuf() } else { \"pm\".to_strbuf() },\n+          'p' => if (tm.tm_hour as int) < 12 { \"AM\".to_strbuf() } else { \"PM\".to_strbuf() },\n           'R' => {\n-            format!(\"{}:{}\",\n+            format_strbuf!(\"{}:{}\",\n                 parse_type('H', tm),\n                 parse_type('M', tm))\n           }\n           'r' => {\n-            format!(\"{}:{}:{} {}\",\n+            format_strbuf!(\"{}:{}:{} {}\",\n                 parse_type('I', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm),\n                 parse_type('p', tm))\n           }\n-          'S' => format!(\"{:02d}\", tm.tm_sec),\n-          's' => format!(\"{}\", tm.to_timespec().sec),\n+          'S' => format_strbuf!(\"{:02d}\", tm.tm_sec),\n+          's' => format_strbuf!(\"{}\", tm.to_timespec().sec),\n           'T' | 'X' => {\n-            format!(\"{}:{}:{}\",\n+            format_strbuf!(\"{}:{}:{}\",\n                 parse_type('H', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm))\n           }\n-          't' => \"\\t\".to_owned(),\n-          'U' => format!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n+          't' => \"\\t\".to_strbuf(),\n+          'U' => format_strbuf!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n           'u' => {\n             let i = tm.tm_wday as int;\n-            (if i == 0 { 7 } else { i }).to_str()\n+            (if i == 0 { 7 } else { i }).to_str().to_strbuf()\n           }\n           'V' => iso_week('V', tm),\n           'v' => {\n-            format!(\"{}-{}-{}\",\n+            format_strbuf!(\"{}-{}-{}\",\n                 parse_type('e', tm),\n                 parse_type('b', tm),\n                 parse_type('Y', tm))\n           }\n-          'W' => format!(\"{:02d}\", (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7)\n-                         / 7),\n-          'w' => (tm.tm_wday as int).to_str(),\n-          'Y' => (tm.tm_year as int + 1900).to_str(),\n-          'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => tm.tm_zone.clone(),\n+          'W' => {\n+              format_strbuf!(\"{:02d}\",\n+                             (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7)\n+          }\n+          'w' => (tm.tm_wday as int).to_str().to_strbuf(),\n+          'Y' => (tm.tm_year as int + 1900).to_str().to_strbuf(),\n+          'y' => format_strbuf!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n+          'Z' => tm.tm_zone.to_strbuf(),\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            format!(\"{}{:02d}{:02d}\", sign, h, m)\n+            format_strbuf!(\"{}{:02d}{:02d}\", sign, h, m)\n           }\n           '+' => tm.rfc3339(),\n-          '%' => \"%\".to_owned(),\n+          '%' => \"%\".to_strbuf(),\n           _   => die()\n         }\n     }\n@@ -1067,7 +1072,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    str::from_utf8(buf.as_slice()).unwrap().to_str()\n+    str::from_utf8(buf.as_slice()).unwrap().to_strbuf()\n }\n \n #[cfg(test)]\n@@ -1235,9 +1240,9 @@ mod tests {\n         }\n \n         let format = \"%a %b %e %T.%f %Y\";\n-        assert_eq!(strptime(\"\", format), Err(\"Invalid time\".to_owned()));\n+        assert_eq!(strptime(\"\", format), Err(\"Invalid time\".to_strbuf()));\n         assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n-            == Err(\"Invalid time\".to_owned()));\n+            == Err(\"Invalid time\".to_strbuf()));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n           Err(e) => fail!(e),\n@@ -1259,71 +1264,71 @@ mod tests {\n \n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              Ok(ref tm) => tm.strftime(format) == s.to_owned(),\n+              Ok(ref tm) => tm.strftime(format) == s.to_strbuf(),\n               Err(e) => fail!(e)\n             }\n         }\n \n         let days = [\n-            \"Sunday\".to_owned(),\n-            \"Monday\".to_owned(),\n-            \"Tuesday\".to_owned(),\n-            \"Wednesday\".to_owned(),\n-            \"Thursday\".to_owned(),\n-            \"Friday\".to_owned(),\n-            \"Saturday\".to_owned()\n+            \"Sunday\".to_strbuf(),\n+            \"Monday\".to_strbuf(),\n+            \"Tuesday\".to_strbuf(),\n+            \"Wednesday\".to_strbuf(),\n+            \"Thursday\".to_strbuf(),\n+            \"Friday\".to_strbuf(),\n+            \"Saturday\".to_strbuf()\n         ];\n         for day in days.iter() {\n-            assert!(test(*day, \"%A\"));\n+            assert!(test(day.as_slice(), \"%A\"));\n         }\n \n         let days = [\n-            \"Sun\".to_owned(),\n-            \"Mon\".to_owned(),\n-            \"Tue\".to_owned(),\n-            \"Wed\".to_owned(),\n-            \"Thu\".to_owned(),\n-            \"Fri\".to_owned(),\n-            \"Sat\".to_owned()\n+            \"Sun\".to_strbuf(),\n+            \"Mon\".to_strbuf(),\n+            \"Tue\".to_strbuf(),\n+            \"Wed\".to_strbuf(),\n+            \"Thu\".to_strbuf(),\n+            \"Fri\".to_strbuf(),\n+            \"Sat\".to_strbuf()\n         ];\n         for day in days.iter() {\n-            assert!(test(*day, \"%a\"));\n+            assert!(test(day.as_slice(), \"%a\"));\n         }\n \n         let months = [\n-            \"January\".to_owned(),\n-            \"February\".to_owned(),\n-            \"March\".to_owned(),\n-            \"April\".to_owned(),\n-            \"May\".to_owned(),\n-            \"June\".to_owned(),\n-            \"July\".to_owned(),\n-            \"August\".to_owned(),\n-            \"September\".to_owned(),\n-            \"October\".to_owned(),\n-            \"November\".to_owned(),\n-            \"December\".to_owned()\n+            \"January\".to_strbuf(),\n+            \"February\".to_strbuf(),\n+            \"March\".to_strbuf(),\n+            \"April\".to_strbuf(),\n+            \"May\".to_strbuf(),\n+            \"June\".to_strbuf(),\n+            \"July\".to_strbuf(),\n+            \"August\".to_strbuf(),\n+            \"September\".to_strbuf(),\n+            \"October\".to_strbuf(),\n+            \"November\".to_strbuf(),\n+            \"December\".to_strbuf()\n         ];\n         for day in months.iter() {\n-            assert!(test(*day, \"%B\"));\n+            assert!(test(day.as_slice(), \"%B\"));\n         }\n \n         let months = [\n-            \"Jan\".to_owned(),\n-            \"Feb\".to_owned(),\n-            \"Mar\".to_owned(),\n-            \"Apr\".to_owned(),\n-            \"May\".to_owned(),\n-            \"Jun\".to_owned(),\n-            \"Jul\".to_owned(),\n-            \"Aug\".to_owned(),\n-            \"Sep\".to_owned(),\n-            \"Oct\".to_owned(),\n-            \"Nov\".to_owned(),\n-            \"Dec\".to_owned()\n+            \"Jan\".to_strbuf(),\n+            \"Feb\".to_strbuf(),\n+            \"Mar\".to_strbuf(),\n+            \"Apr\".to_strbuf(),\n+            \"May\".to_strbuf(),\n+            \"Jun\".to_strbuf(),\n+            \"Jul\".to_strbuf(),\n+            \"Aug\".to_strbuf(),\n+            \"Sep\".to_strbuf(),\n+            \"Oct\".to_strbuf(),\n+            \"Nov\".to_strbuf(),\n+            \"Dec\".to_strbuf()\n         ];\n         for day in months.iter() {\n-            assert!(test(*day, \"%b\"));\n+            assert!(test(day.as_slice(), \"%b\"));\n         }\n \n         assert!(test(\"19\", \"%C\"));\n@@ -1375,7 +1380,7 @@ mod tests {\n         assert!(test(\"%\", \"%%\"));\n \n         // Test for #7256\n-        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(\"Invalid year\".to_owned()))\n+        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(\"Invalid year\".to_strbuf()))\n     }\n \n     fn test_ctime() {\n@@ -1387,8 +1392,8 @@ mod tests {\n \n         debug!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n \n-        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_owned());\n-        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_owned());\n+        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_strbuf());\n+        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_strbuf());\n     }\n \n     fn test_strftime() {\n@@ -1398,70 +1403,71 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(\"\"), \"\".to_owned());\n-        assert_eq!(local.strftime(\"%A\"), \"Friday\".to_owned());\n-        assert_eq!(local.strftime(\"%a\"), \"Fri\".to_owned());\n-        assert_eq!(local.strftime(\"%B\"), \"February\".to_owned());\n-        assert_eq!(local.strftime(\"%b\"), \"Feb\".to_owned());\n-        assert_eq!(local.strftime(\"%C\"), \"20\".to_owned());\n-        assert_eq!(local.strftime(\"%c\"), \"Fri Feb 13 15:31:30 2009\".to_owned());\n-        assert_eq!(local.strftime(\"%D\"), \"02/13/09\".to_owned());\n-        assert_eq!(local.strftime(\"%d\"), \"13\".to_owned());\n-        assert_eq!(local.strftime(\"%e\"), \"13\".to_owned());\n-        assert_eq!(local.strftime(\"%f\"), \"000054321\".to_owned());\n-        assert_eq!(local.strftime(\"%F\"), \"2009-02-13\".to_owned());\n-        assert_eq!(local.strftime(\"%G\"), \"2009\".to_owned());\n-        assert_eq!(local.strftime(\"%g\"), \"09\".to_owned());\n-        assert_eq!(local.strftime(\"%H\"), \"15\".to_owned());\n-        assert_eq!(local.strftime(\"%I\"), \"03\".to_owned());\n-        assert_eq!(local.strftime(\"%j\"), \"044\".to_owned());\n-        assert_eq!(local.strftime(\"%k\"), \"15\".to_owned());\n-        assert_eq!(local.strftime(\"%l\"), \" 3\".to_owned());\n-        assert_eq!(local.strftime(\"%M\"), \"31\".to_owned());\n-        assert_eq!(local.strftime(\"%m\"), \"02\".to_owned());\n-        assert_eq!(local.strftime(\"%n\"), \"\\n\".to_owned());\n-        assert_eq!(local.strftime(\"%P\"), \"pm\".to_owned());\n-        assert_eq!(local.strftime(\"%p\"), \"PM\".to_owned());\n-        assert_eq!(local.strftime(\"%R\"), \"15:31\".to_owned());\n-        assert_eq!(local.strftime(\"%r\"), \"03:31:30 PM\".to_owned());\n-        assert_eq!(local.strftime(\"%S\"), \"30\".to_owned());\n-        assert_eq!(local.strftime(\"%s\"), \"1234567890\".to_owned());\n-        assert_eq!(local.strftime(\"%T\"), \"15:31:30\".to_owned());\n-        assert_eq!(local.strftime(\"%t\"), \"\\t\".to_owned());\n-        assert_eq!(local.strftime(\"%U\"), \"06\".to_owned());\n-        assert_eq!(local.strftime(\"%u\"), \"5\".to_owned());\n-        assert_eq!(local.strftime(\"%V\"), \"07\".to_owned());\n-        assert_eq!(local.strftime(\"%v\"), \"13-Feb-2009\".to_owned());\n-        assert_eq!(local.strftime(\"%W\"), \"06\".to_owned());\n-        assert_eq!(local.strftime(\"%w\"), \"5\".to_owned());\n-        assert_eq!(local.strftime(\"%X\"), \"15:31:30\".to_owned()); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%x\"), \"02/13/09\".to_owned()); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%Y\"), \"2009\".to_owned());\n-        assert_eq!(local.strftime(\"%y\"), \"09\".to_owned());\n-        assert_eq!(local.strftime(\"%+\"), \"2009-02-13T15:31:30-08:00\".to_owned());\n+        assert_eq!(local.strftime(\"\"), \"\".to_strbuf());\n+        assert_eq!(local.strftime(\"%A\"), \"Friday\".to_strbuf());\n+        assert_eq!(local.strftime(\"%a\"), \"Fri\".to_strbuf());\n+        assert_eq!(local.strftime(\"%B\"), \"February\".to_strbuf());\n+        assert_eq!(local.strftime(\"%b\"), \"Feb\".to_strbuf());\n+        assert_eq!(local.strftime(\"%C\"), \"20\".to_strbuf());\n+        assert_eq!(local.strftime(\"%c\"), \"Fri Feb 13 15:31:30 2009\".to_strbuf());\n+        assert_eq!(local.strftime(\"%D\"), \"02/13/09\".to_strbuf());\n+        assert_eq!(local.strftime(\"%d\"), \"13\".to_strbuf());\n+        assert_eq!(local.strftime(\"%e\"), \"13\".to_strbuf());\n+        assert_eq!(local.strftime(\"%f\"), \"000054321\".to_strbuf());\n+        assert_eq!(local.strftime(\"%F\"), \"2009-02-13\".to_strbuf());\n+        assert_eq!(local.strftime(\"%G\"), \"2009\".to_strbuf());\n+        assert_eq!(local.strftime(\"%g\"), \"09\".to_strbuf());\n+        assert_eq!(local.strftime(\"%H\"), \"15\".to_strbuf());\n+        assert_eq!(local.strftime(\"%I\"), \"03\".to_strbuf());\n+        assert_eq!(local.strftime(\"%j\"), \"044\".to_strbuf());\n+        assert_eq!(local.strftime(\"%k\"), \"15\".to_strbuf());\n+        assert_eq!(local.strftime(\"%l\"), \" 3\".to_strbuf());\n+        assert_eq!(local.strftime(\"%M\"), \"31\".to_strbuf());\n+        assert_eq!(local.strftime(\"%m\"), \"02\".to_strbuf());\n+        assert_eq!(local.strftime(\"%n\"), \"\\n\".to_strbuf());\n+        assert_eq!(local.strftime(\"%P\"), \"pm\".to_strbuf());\n+        assert_eq!(local.strftime(\"%p\"), \"PM\".to_strbuf());\n+        assert_eq!(local.strftime(\"%R\"), \"15:31\".to_strbuf());\n+        assert_eq!(local.strftime(\"%r\"), \"03:31:30 PM\".to_strbuf());\n+        assert_eq!(local.strftime(\"%S\"), \"30\".to_strbuf());\n+        assert_eq!(local.strftime(\"%s\"), \"1234567890\".to_strbuf());\n+        assert_eq!(local.strftime(\"%T\"), \"15:31:30\".to_strbuf());\n+        assert_eq!(local.strftime(\"%t\"), \"\\t\".to_strbuf());\n+        assert_eq!(local.strftime(\"%U\"), \"06\".to_strbuf());\n+        assert_eq!(local.strftime(\"%u\"), \"5\".to_strbuf());\n+        assert_eq!(local.strftime(\"%V\"), \"07\".to_strbuf());\n+        assert_eq!(local.strftime(\"%v\"), \"13-Feb-2009\".to_strbuf());\n+        assert_eq!(local.strftime(\"%W\"), \"06\".to_strbuf());\n+        assert_eq!(local.strftime(\"%w\"), \"5\".to_strbuf());\n+        assert_eq!(local.strftime(\"%X\"), \"15:31:30\".to_strbuf()); // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%x\"), \"02/13/09\".to_strbuf()); // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%Y\"), \"2009\".to_strbuf());\n+        assert_eq!(local.strftime(\"%y\"), \"09\".to_strbuf());\n+        assert_eq!(local.strftime(\"%+\"), \"2009-02-13T15:31:30-08:00\".to_strbuf());\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.strftime(\"%Z\");\n-        assert!(zone == \"PST\".to_owned() || zone == \"Pacific Standard Time\".to_owned());\n+        assert!(zone == \"PST\".to_strbuf() || zone == \"Pacific Standard Time\".to_strbuf());\n \n-        assert_eq!(local.strftime(\"%z\"), \"-0800\".to_owned());\n-        assert_eq!(local.strftime(\"%%\"), \"%\".to_owned());\n+        assert_eq!(local.strftime(\"%z\"), \"-0800\".to_strbuf());\n+        assert_eq!(local.strftime(\"%%\"), \"%\".to_strbuf());\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let rfc822 = local.rfc822();\n-        let prefix = \"Fri, 13 Feb 2009 15:31:30 \".to_owned();\n-        assert!(rfc822 == prefix + \"PST\" || rfc822 == prefix + \"Pacific Standard Time\");\n-\n-        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_owned());\n-        assert_eq!(local.rfc822z(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_owned());\n-        assert_eq!(local.rfc3339(), \"2009-02-13T15:31:30-08:00\".to_owned());\n-\n-        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_owned());\n-        assert_eq!(utc.rfc822(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_owned());\n-        assert_eq!(utc.rfc822z(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_owned());\n-        assert_eq!(utc.rfc3339(), \"2009-02-13T23:31:30Z\".to_owned());\n+        let prefix = \"Fri, 13 Feb 2009 15:31:30 \".to_strbuf();\n+        assert!(rfc822 == format_strbuf!(\"{}PST\", prefix) ||\n+                rfc822 == format_strbuf!(\"{}Pacific Standard Time\", prefix));\n+\n+        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_strbuf());\n+        assert_eq!(local.rfc822z(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_strbuf());\n+        assert_eq!(local.rfc3339(), \"2009-02-13T15:31:30-08:00\".to_strbuf());\n+\n+        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_strbuf());\n+        assert_eq!(utc.rfc822(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_strbuf());\n+        assert_eq!(utc.rfc822z(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_strbuf());\n+        assert_eq!(utc.rfc3339(), \"2009-02-13T23:31:30Z\".to_strbuf());\n     }\n \n     fn test_timespec_eq_ord() {"}, {"sha": "a2e75e0bf9b1eb0c90a615461bac300c38280f4e", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 315, "deletions": 302, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -39,65 +39,67 @@ use std::uint;\n /// ```rust\n /// use url::{Url, UserInfo};\n ///\n-/// let url = Url { scheme: \"https\".to_owned(),\n-///                 user: Some(UserInfo { user: \"username\".to_owned(), pass: None }),\n-///                 host: \"example.com\".to_owned(),\n-///                 port: Some(\"8080\".to_owned()),\n-///                 path: \"/foo/bar\".to_owned(),\n-///                 query: vec!((\"baz\".to_owned(), \"qux\".to_owned())),\n-///                 fragment: Some(\"quz\".to_owned()) };\n+/// let url = Url { scheme: \"https\".to_strbuf(),\n+///                 user: Some(UserInfo { user: \"username\".to_strbuf(), pass: None }),\n+///                 host: \"example.com\".to_strbuf(),\n+///                 port: Some(\"8080\".to_strbuf()),\n+///                 path: \"/foo/bar\".to_strbuf(),\n+///                 query: vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf())),\n+///                 fragment: Some(\"quz\".to_strbuf()) };\n /// // https://username@example.com:8080/foo/bar?baz=qux#quz\n /// ```\n #[deriving(Clone, Eq, TotalEq)]\n pub struct Url {\n     /// The scheme part of a URL, such as `https` in the above example.\n-    pub scheme: ~str,\n+    pub scheme: StrBuf,\n     /// A URL subcomponent for user authentication.  `username` in the above example.\n     pub user: Option<UserInfo>,\n     /// A domain name or IP address.  For example, `example.com`.\n-    pub host: ~str,\n+    pub host: StrBuf,\n     /// A TCP port number, for example `8080`.\n-    pub port: Option<~str>,\n+    pub port: Option<StrBuf>,\n     /// The path component of a URL, for example `/foo/bar`.\n-    pub path: ~str,\n-    /// The query component of a URL.  `vec!((\"baz\".to_owned(), \"qux\".to_owned()))` represents the\n-    /// fragment `baz=qux` in the above example.\n+    pub path: StrBuf,\n+    /// The query component of a URL.\n+    /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n+    /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n-    pub fragment: Option<~str>\n+    pub fragment: Option<StrBuf>\n }\n \n #[deriving(Clone, Eq)]\n pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n-    pub path: ~str,\n-    /// The query component of a URL.  `vec!((\"baz\".to_owned(), \"qux\".to_owned()))` represents the\n-    /// fragment `baz=qux` in the above example.\n+    pub path: StrBuf,\n+    /// The query component of a URL.\n+    /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n+    /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n-    pub fragment: Option<~str>\n+    pub fragment: Option<StrBuf>\n }\n \n /// An optional subcomponent of a URI authority component.\n #[deriving(Clone, Eq, TotalEq)]\n pub struct UserInfo {\n     /// The user name.\n-    pub user: ~str,\n+    pub user: StrBuf,\n     /// Password or other scheme-specific authentication information.\n-    pub pass: Option<~str>\n+    pub pass: Option<StrBuf>\n }\n \n /// Represents the query component of a URI.\n-pub type Query = Vec<(~str, ~str)>;\n+pub type Query = Vec<(StrBuf, StrBuf)>;\n \n impl Url {\n-    pub fn new(scheme: ~str,\n+    pub fn new(scheme: StrBuf,\n                user: Option<UserInfo>,\n-               host: ~str,\n-               port: Option<~str>,\n-               path: ~str,\n+               host: StrBuf,\n+               port: Option<StrBuf>,\n+               path: StrBuf,\n                query: Query,\n-               fragment: Option<~str>)\n+               fragment: Option<StrBuf>)\n                -> Url {\n         Url {\n             scheme: scheme,\n@@ -112,9 +114,9 @@ impl Url {\n }\n \n impl Path {\n-    pub fn new(path: ~str,\n+    pub fn new(path: StrBuf,\n                query: Query,\n-               fragment: Option<~str>)\n+               fragment: Option<StrBuf>)\n                -> Path {\n         Path {\n             path: path,\n@@ -126,12 +128,12 @@ impl Path {\n \n impl UserInfo {\n     #[inline]\n-    pub fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+    pub fn new(user: StrBuf, pass: Option<StrBuf>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n }\n \n-fn encode_inner(s: &str, full_url: bool) -> ~str {\n+fn encode_inner(s: &str, full_url: bool) -> StrBuf {\n     let mut rdr = BufReader::new(s.as_bytes());\n     let mut out = StrBuf::new();\n \n@@ -171,7 +173,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n@@ -189,7 +191,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  * println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n  * ```\n  */\n-pub fn encode(s: &str) -> ~str {\n+pub fn encode(s: &str) -> StrBuf {\n     encode_inner(s, true)\n }\n \n@@ -200,11 +202,11 @@ pub fn encode(s: &str) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n \n-pub fn encode_component(s: &str) -> ~str {\n+pub fn encode_component(s: &str) -> StrBuf {\n     encode_inner(s, false)\n }\n \n-fn decode_inner(s: &str, full_url: bool) -> ~str {\n+fn decode_inner(s: &str, full_url: bool) -> StrBuf {\n     let mut rdr = BufReader::new(s.as_bytes());\n     let mut out = StrBuf::new();\n \n@@ -247,7 +249,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n@@ -264,18 +266,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  * println!(\"{}\", url); // https://example.com/Rust (programming language)\n  * ```\n  */\n-pub fn decode(s: &str) -> ~str {\n+pub fn decode(s: &str) -> StrBuf {\n     decode_inner(s, true)\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n-pub fn decode_component(s: &str) -> ~str {\n+pub fn decode_component(s: &str) -> StrBuf {\n     decode_inner(s, false)\n }\n \n-fn encode_plus(s: &str) -> ~str {\n+fn encode_plus(s: &str) -> StrBuf {\n     let mut rdr = BufReader::new(s.as_bytes());\n     let mut out = StrBuf::new();\n \n@@ -294,18 +296,18 @@ fn encode_plus(s: &str) -> ~str {\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n-pub fn encode_form_urlencoded(m: &HashMap<~str, Vec<~str>>) -> ~str {\n+pub fn encode_form_urlencoded(m: &HashMap<StrBuf, Vec<StrBuf>>) -> StrBuf {\n     let mut out = StrBuf::new();\n     let mut first = true;\n \n     for (key, values) in m.iter() {\n-        let key = encode_plus(*key);\n+        let key = encode_plus(key.as_slice());\n \n         for value in values.iter() {\n             if first {\n@@ -315,21 +317,23 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, Vec<~str>>) -> ~str {\n                 first = false;\n             }\n \n-            out.push_str(format!(\"{}={}\", key, encode_plus(*value)));\n+            out.push_str(format!(\"{}={}\",\n+                                 key,\n+                                 encode_plus(value.as_slice())));\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n #[allow(experimental)]\n-pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n+pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<StrBuf, Vec<StrBuf>> {\n     let mut rdr = BufReader::new(s);\n-    let mut m: HashMap<~str,Vec<~str>> = HashMap::new();\n+    let mut m: HashMap<StrBuf,Vec<StrBuf>> = HashMap::new();\n     let mut key = StrBuf::new();\n     let mut value = StrBuf::new();\n     let mut parsing_key = true;\n@@ -348,8 +352,8 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n                         None => vec!(),\n                     };\n \n-                    values.push(value.into_owned());\n-                    m.insert(key.into_owned(), values);\n+                    values.push(value);\n+                    m.insert(key, values);\n                 }\n \n                 parsing_key = true;\n@@ -386,15 +390,15 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n             None => vec!(),\n         };\n \n-        values.push(value.into_owned());\n-        m.insert(key.into_owned(), values);\n+        values.push(value);\n+        m.insert(key, values);\n     }\n \n     m\n }\n \n \n-fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n+fn split_char_first(s: &str, c: char) -> (StrBuf, StrBuf) {\n     let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n@@ -413,10 +417,10 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (s.slice(0, index).to_owned(), \"\".to_owned());\n+        return (s.slice(0, index).to_strbuf(), \"\".to_strbuf());\n     } else {\n-        return (s.slice(0, index).to_owned(),\n-             s.slice(index + mat, s.len()).to_owned());\n+        return (s.slice(0, index).to_strbuf(),\n+                s.slice(index + mat, s.len()).to_strbuf());\n     }\n }\n \n@@ -434,7 +438,8 @@ fn query_from_str(rawquery: &str) -> Query {\n     if !rawquery.is_empty() {\n         for p in rawquery.split('&') {\n             let (k, v) = split_char_first(p, '=');\n-            query.push((decode_component(k), decode_component(v)));\n+            query.push((decode_component(k.as_slice()),\n+                        decode_component(v.as_slice())));\n         };\n     }\n     return query;\n@@ -446,24 +451,24 @@ fn query_from_str(rawquery: &str) -> Query {\n  * # Example\n  *\n  * ```rust\n- * let query = vec!((\"title\".to_owned(), \"The Village\".to_owned()),\n-                    (\"north\".to_owned(), \"52.91\".to_owned()),\n-                    (\"west\".to_owned(), \"4.10\".to_owned()));\n+ * let query = vec!((\"title\".to_strbuf(), \"The Village\".to_strbuf()),\n+                    (\"north\".to_strbuf(), \"52.91\".to_strbuf()),\n+                    (\"west\".to_strbuf(), \"4.10\".to_strbuf()));\n  * println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n  * ```\n  */\n #[allow(unused_must_use)]\n-pub fn query_to_str(query: &Query) -> ~str {\n+pub fn query_to_str(query: &Query) -> StrBuf {\n     use std::io::MemWriter;\n     use std::str;\n \n     let mut writer = MemWriter::new();\n     for (i, &(ref k, ref v)) in query.iter().enumerate() {\n         if i != 0 { write!(&mut writer, \"&\"); }\n-        write!(&mut writer, \"{}={}\", encode_component(*k),\n-               encode_component(*v));\n+        write!(&mut writer, \"{}={}\", encode_component(k.as_slice()),\n+               encode_component(v.as_slice()));\n     }\n-    str::from_utf8_lossy(writer.unwrap().as_slice()).into_owned()\n+    str::from_utf8_lossy(writer.unwrap().as_slice()).to_strbuf()\n }\n \n /**\n@@ -478,35 +483,36 @@ pub fn query_to_str(query: &Query) -> ~str {\n  *\n  * let scheme = match get_scheme(\"https://example.com/\") {\n  *     Ok((sch, _)) => sch,\n- *     Err(_) => \"(None)\".to_owned(),\n+ *     Err(_) => \"(None)\".to_strbuf(),\n  * };\n  * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n  * ```\n  */\n-pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n+pub fn get_scheme(rawurl: &str) -> Result<(StrBuf, StrBuf), StrBuf> {\n     for (i,c) in rawurl.chars().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => continue,\n           '0' .. '9' | '+' | '-' | '.' => {\n             if i == 0 {\n-                return Err(\"url: Scheme must begin with a letter.\".to_owned());\n+                return Err(\"url: Scheme must begin with a \\\n+                            letter.\".to_strbuf());\n             }\n             continue;\n           }\n           ':' => {\n             if i == 0 {\n-                return Err(\"url: Scheme cannot be empty.\".to_owned());\n+                return Err(\"url: Scheme cannot be empty.\".to_strbuf());\n             } else {\n-                return Ok((rawurl.slice(0,i).to_owned(),\n-                                rawurl.slice(i+1,rawurl.len()).to_owned()));\n+                return Ok((rawurl.slice(0,i).to_strbuf(),\n+                           rawurl.slice(i+1,rawurl.len()).to_strbuf()));\n             }\n           }\n           _ => {\n-            return Err(\"url: Invalid character in scheme.\".to_owned());\n+            return Err(\"url: Invalid character in scheme.\".to_strbuf());\n           }\n         }\n     };\n-    return Err(\"url: Scheme must be terminated with a colon.\".to_owned());\n+    return Err(\"url: Scheme must be terminated with a colon.\".to_strbuf());\n }\n \n #[deriving(Clone, Eq)]\n@@ -518,10 +524,10 @@ enum Input {\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n-    Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n+    Result<(Option<UserInfo>, StrBuf, Option<StrBuf>, StrBuf), StrBuf> {\n     if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n-        return Ok((None, \"\".to_owned(), None, rawurl.to_str()));\n+        return Ok((None, \"\".to_strbuf(), None, rawurl.to_str().to_strbuf()));\n     }\n \n     enum State {\n@@ -538,7 +544,7 @@ fn get_authority(rawurl: &str) ->\n     let mut input = Digit; // most restricted, start here.\n \n     let mut userinfo = None;\n-    let mut host = \"\".to_owned();\n+    let mut host = \"\".to_strbuf();\n     let mut port = None;\n \n     let mut colon_count = 0;\n@@ -565,7 +571,7 @@ fn get_authority(rawurl: &str) ->\n             // separators, don't change anything\n           }\n           _ => {\n-            return Err(\"Illegal character in authority\".to_owned());\n+            return Err(\"Illegal character in authority\".to_strbuf());\n           }\n         }\n \n@@ -582,15 +588,15 @@ fn get_authority(rawurl: &str) ->\n                 // multiple colons means ipv6 address.\n                 if input == Unreserved {\n                     return Err(\n-                        \"Illegal characters in IPv6 address.\".to_owned());\n+                        \"Illegal characters in IPv6 address.\".to_strbuf());\n                 }\n                 st = Ip6Host;\n               }\n               InHost => {\n                 pos = i;\n                 if input == Unreserved {\n                     // must be port\n-                    host = rawurl.slice(begin, i).to_owned();\n+                    host = rawurl.slice(begin, i).to_strbuf();\n                     st = InPort;\n                 } else {\n                     // can't be sure whether this is an ipv6 address or a port\n@@ -599,19 +605,20 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Port => {\n                 if input == Unreserved {\n-                    return Err(\"Illegal characters in authority.\".to_owned());\n+                    return Err(\"Illegal characters in \\\n+                                authority.\".to_strbuf());\n                 }\n                 st = Ip6Host;\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = rawurl.slice(begin, i).to_owned();\n+                    host = rawurl.slice(begin, i).to_strbuf();\n                     pos = i;\n                     st = InPort;\n                 }\n               }\n               _ => {\n-                return Err(\"Invalid ':' in authority.\".to_owned());\n+                return Err(\"Invalid ':' in authority.\".to_strbuf());\n               }\n             }\n             input = Digit; // reset input class\n@@ -622,18 +629,18 @@ fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = rawurl.slice(begin, i).to_owned();\n+                let user = rawurl.slice(begin, i).to_strbuf();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = rawurl.slice(begin, pos).to_owned();\n-                let pass = rawurl.slice(pos+1, i).to_owned();\n+                let user = rawurl.slice(begin, pos).to_strbuf();\n+                let pass = rawurl.slice(pos+1, i).to_strbuf();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n               _ => {\n-                return Err(\"Invalid '@' in authority.\".to_owned());\n+                return Err(\"Invalid '@' in authority.\".to_strbuf());\n               }\n             }\n             begin = i+1;\n@@ -650,34 +657,34 @@ fn get_authority(rawurl: &str) ->\n     // finish up\n     match st {\n       Start => {\n-        host = rawurl.slice(begin, end).to_owned();\n+        host = rawurl.slice(begin, end).to_strbuf();\n       }\n       PassHostPort | Ip6Port => {\n         if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_owned());\n+            return Err(\"Non-digit characters in port.\".to_strbuf());\n         }\n-        host = rawurl.slice(begin, pos).to_owned();\n-        port = Some(rawurl.slice(pos+1, end).to_owned());\n+        host = rawurl.slice(begin, pos).to_strbuf();\n+        port = Some(rawurl.slice(pos+1, end).to_strbuf());\n       }\n       Ip6Host | InHost => {\n-        host = rawurl.slice(begin, end).to_owned();\n+        host = rawurl.slice(begin, end).to_strbuf();\n       }\n       InPort => {\n         if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_owned());\n+            return Err(\"Non-digit characters in port.\".to_strbuf());\n         }\n-        port = Some(rawurl.slice(pos+1, end).to_owned());\n+        port = Some(rawurl.slice(pos+1, end).to_strbuf());\n       }\n     }\n \n-    let rest = rawurl.slice(end, len).to_owned();\n+    let rest = rawurl.slice(end, len).to_strbuf();\n     return Ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n fn get_path(rawurl: &str, authority: bool) ->\n-    Result<(~str, ~str), ~str> {\n+    Result<(StrBuf, StrBuf), StrBuf> {\n     let len = rawurl.len();\n     let mut end = len;\n     for (i,c) in rawurl.chars().enumerate() {\n@@ -691,24 +698,24 @@ fn get_path(rawurl: &str, authority: bool) ->\n             end = i;\n             break;\n           }\n-          _ => return Err(\"Invalid character in path.\".to_owned())\n+          _ => return Err(\"Invalid character in path.\".to_strbuf())\n         }\n     }\n \n     if authority {\n         if end != 0 && !rawurl.starts_with(\"/\") {\n             return Err(\"Non-empty path must begin with\\\n-                              '/' in presence of authority.\".to_owned());\n+                              '/' in presence of authority.\".to_strbuf());\n         }\n     }\n \n     return Ok((decode_component(rawurl.slice(0, end)),\n-                    rawurl.slice(end, len).to_owned()));\n+                    rawurl.slice(end, len).to_strbuf()));\n }\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n-    Result<(Query, Option<~str>), ~str> {\n+    Result<(Query, Option<StrBuf>), StrBuf> {\n     if !rawurl.starts_with(\"?\") {\n         if rawurl.starts_with(\"#\") {\n             let f = decode_component(rawurl.slice(\n@@ -721,8 +728,11 @@ fn get_query_fragment(rawurl: &str) ->\n     }\n     let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n     let f = if r.len() != 0 {\n-        Some(decode_component(r)) } else { None };\n-    return Ok((query_from_str(q), f));\n+        Some(decode_component(r.as_slice()))\n+    } else {\n+        None\n+    };\n+    return Ok((query_from_str(q.as_slice()), f));\n }\n \n /**\n@@ -736,43 +746,43 @@ fn get_query_fragment(rawurl: &str) ->\n  *\n  * A `Url` struct type representing the URL.\n  */\n-pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n+pub fn from_str(rawurl: &str) -> Result<Url, StrBuf> {\n     // scheme\n     let (scheme, rest) = match get_scheme(rawurl) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     // authority\n-    let (userinfo, host, port, rest) = match get_authority(rest) {\n+    let (userinfo, host, port, rest) = match get_authority(rest.as_slice()) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     // path\n-    let has_authority = if host == \"\".to_owned() { false } else { true };\n-    let (path, rest) = match get_path(rest, has_authority) {\n+    let has_authority = host.len() > 0;\n+    let (path, rest) = match get_path(rest.as_slice(), has_authority) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest) {\n+    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n }\n \n-pub fn path_from_str(rawpath: &str) -> Result<Path, ~str> {\n+pub fn path_from_str(rawpath: &str) -> Result<Path, StrBuf> {\n     let (path, rest) = match get_path(rawpath, false) {\n         Ok(val) => val,\n         Err(e) => return Err(e)\n     };\n \n     // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest) {\n+    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n@@ -836,8 +846,9 @@ impl fmt::Show for Url {\n         }\n \n         match self.fragment {\n-            Some(ref fragment) => write!(f.buf, \"\\\\#{}\",\n-                                         encode_component(*fragment)),\n+            Some(ref fragment) => {\n+                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+            }\n             None => Ok(()),\n         }\n     }\n@@ -852,7 +863,7 @@ impl fmt::Show for Path {\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f.buf, \"\\\\#{}\", encode_component(*fragment))\n+                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(())\n         }\n@@ -877,53 +888,53 @@ impl<S: Writer> Hash<S> for Path {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, \"hello\".to_owned());\n-    assert_eq!(v, \" sweet world\".to_owned());\n+    assert_eq!(u, \"hello\".to_strbuf());\n+    assert_eq!(v, \" sweet world\".to_strbuf());\n \n     let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, \"hello sweet world\".to_owned());\n-    assert_eq!(v, \"\".to_owned());\n+    assert_eq!(u, \"hello sweet world\".to_strbuf());\n+    assert_eq!(v, \"\".to_strbuf());\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"user\".to_owned(), Some(\"pass\".to_owned()))));\n-    assert_eq!(h, \"rust-lang.org\".to_owned());\n+    assert_eq!(u, Some(UserInfo::new(\"user\".to_strbuf(), Some(\"pass\".to_strbuf()))));\n+    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n     assert!(p.is_none());\n-    assert_eq!(r, \"/something\".to_owned());\n+    assert_eq!(r, \"/something\".to_strbuf());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_owned());\n-    assert_eq!(p, Some(\"8000\".to_owned()));\n-    assert_eq!(r, \"?something\".to_owned());\n+    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n+    assert_eq!(p, Some(\"8000\".to_strbuf()));\n+    assert_eq!(r, \"?something\".to_strbuf());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_owned());\n+    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n     assert!(p.is_none());\n-    assert_eq!(r, \"#blah\".to_owned());\n+    assert_eq!(r, \"#blah\".to_strbuf());\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n-    assert_eq!(p, Some(\"8000\".to_owned()));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n+    assert_eq!(p, Some(\"8000\".to_strbuf()));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"us\".to_owned(), Some(\"p\".to_owned()))));\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n-    assert_eq!(p, Some(\"8000\".to_owned()));\n+    assert_eq!(u, Some(UserInfo::new(\"us\".to_strbuf(), Some(\"p\".to_strbuf()))));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n+    assert_eq!(p, Some(\"8000\".to_strbuf()));\n \n     // invalid authorities;\n     assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n@@ -935,22 +946,22 @@ fn test_get_authority() {\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, \"\".to_owned());\n+    assert_eq!(h, \"\".to_strbuf());\n     let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, \"\".to_owned());\n+    assert_eq!(h, \"\".to_strbuf());\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert_eq!(p, \"/something+ orother\".to_owned());\n-    assert_eq!(r, \"\".to_owned());\n+    assert_eq!(p, \"/something+ orother\".to_strbuf());\n+    assert_eq!(r, \"\".to_strbuf());\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert_eq!(p, \"test@email.com\".to_owned());\n-    assert_eq!(r, \"#fragment\".to_owned());\n+    assert_eq!(p, \"test@email.com\".to_strbuf());\n+    assert_eq!(r, \"#fragment\".to_strbuf());\n     let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n-    assert_eq!(p, \"/gen/:addr=\".to_owned());\n-    assert_eq!(r, \"?q=v\".to_owned());\n+    assert_eq!(p, \"/gen/:addr=\".to_strbuf());\n+    assert_eq!(r, \"?q=v\".to_strbuf());\n \n     //failure cases\n     assert!(get_path(\"something?q\", true).is_err());\n@@ -966,87 +977,88 @@ mod tests {\n \n     #[test]\n     fn test_url_parse() {\n-        let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\".to_owned();\n+        let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\";\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        assert_eq!(&u.scheme, &\"http\".to_owned());\n-        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_owned(), Some(\"pass\".to_owned()))));\n-        assert_eq!(&u.host, &\"rust-lang.org\".to_owned());\n-        assert_eq!(&u.port, &Some(\"8080\".to_owned()));\n-        assert_eq!(&u.path, &\"/doc/~u\".to_owned());\n-        assert_eq!(&u.query, &vec!((\"s\".to_owned(), \"v\".to_owned())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_owned()));\n+        assert_eq!(&u.scheme, &\"http\".to_strbuf());\n+        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_strbuf(), Some(\"pass\".to_strbuf()))));\n+        assert_eq!(&u.host, &\"rust-lang.org\".to_strbuf());\n+        assert_eq!(&u.port, &Some(\"8080\".to_strbuf()));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_strbuf());\n+        assert_eq!(&u.query, &vec!((\"s\".to_strbuf(), \"v\".to_strbuf())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_strbuf()));\n     }\n \n     #[test]\n     fn test_path_parse() {\n-        let path = \"/doc/~u?s=v#something\".to_owned();\n+        let path = \"/doc/~u?s=v#something\";\n \n         let up = path_from_str(path);\n         let u = up.unwrap();\n-        assert_eq!(&u.path, &\"/doc/~u\".to_owned());\n-        assert_eq!(&u.query, &vec!((\"s\".to_owned(), \"v\".to_owned())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_owned()));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_strbuf());\n+        assert_eq!(&u.query, &vec!((\"s\".to_strbuf(), \"v\".to_strbuf())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_strbuf()));\n     }\n \n     #[test]\n     fn test_url_parse_host_slash() {\n-        let urlstr = \"http://0.42.42.42/\".to_owned();\n+        let urlstr = \"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.host == \"0.42.42.42\".to_owned());\n-        assert!(url.path == \"/\".to_owned());\n+        assert!(url.host == \"0.42.42.42\".to_strbuf());\n+        assert!(url.path == \"/\".to_strbuf());\n     }\n \n     #[test]\n     fn test_path_parse_host_slash() {\n-        let pathstr = \"/\".to_owned();\n+        let pathstr = \"/\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/\".to_owned());\n+        assert!(path.path == \"/\".to_strbuf());\n     }\n \n     #[test]\n     fn test_url_host_with_port() {\n-        let urlstr = \"scheme://host:1234\".to_owned();\n+        let urlstr = \"scheme://host:1234\";\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_owned());\n-        assert_eq!(&url.host, &\"host\".to_owned());\n-        assert_eq!(&url.port, &Some(\"1234\".to_owned()));\n-        assert_eq!(&url.path, &\"\".to_owned()); // is empty path really correct? Other tests think so\n-        let urlstr = \"scheme://host:1234/\".to_owned();\n+        assert_eq!(&url.scheme, &\"scheme\".to_strbuf());\n+        assert_eq!(&url.host, &\"host\".to_strbuf());\n+        assert_eq!(&url.port, &Some(\"1234\".to_strbuf()));\n+        // is empty path really correct? Other tests think so\n+        assert_eq!(&url.path, &\"\".to_strbuf());\n+        let urlstr = \"scheme://host:1234/\";\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_owned());\n-        assert_eq!(&url.host, &\"host\".to_owned());\n-        assert_eq!(&url.port, &Some(\"1234\".to_owned()));\n-        assert_eq!(&url.path, &\"/\".to_owned());\n+        assert_eq!(&url.scheme, &\"scheme\".to_strbuf());\n+        assert_eq!(&url.host, &\"host\".to_strbuf());\n+        assert_eq!(&url.port, &Some(\"1234\".to_strbuf()));\n+        assert_eq!(&url.path, &\"/\".to_strbuf());\n     }\n \n     #[test]\n     fn test_url_with_underscores() {\n-        let urlstr = \"http://dotcom.com/file_name.html\".to_owned();\n+        let urlstr = \"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file_name.html\".to_owned());\n+        assert!(url.path == \"/file_name.html\".to_strbuf());\n     }\n \n     #[test]\n     fn test_path_with_underscores() {\n-        let pathstr = \"/file_name.html\".to_owned();\n+        let pathstr = \"/file_name.html\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file_name.html\".to_owned());\n+        assert!(path.path == \"/file_name.html\".to_strbuf());\n     }\n \n     #[test]\n     fn test_url_with_dashes() {\n-        let urlstr = \"http://dotcom.com/file-name.html\".to_owned();\n+        let urlstr = \"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file-name.html\".to_owned());\n+        assert!(url.path == \"/file-name.html\".to_strbuf());\n     }\n \n     #[test]\n     fn test_path_with_dashes() {\n-        let pathstr = \"/file-name.html\".to_owned();\n+        let pathstr = \"/file-name.html\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file-name.html\".to_owned());\n+        assert!(path.path == \"/file-name.html\".to_strbuf());\n     }\n \n     #[test]\n@@ -1062,217 +1074,217 @@ mod tests {\n \n     #[test]\n     fn test_full_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?s=v#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org/doc?s=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_userless_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc?s=v#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org/doc?s=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_queryless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org/doc#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_empty_query_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?#something\".to_owned();\n-        let should_be = \"http://user:pass@rust-lang.org/doc#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), should_be);\n+        let url = \"http://user:pass@rust-lang.org/doc?#something\";\n+        let should_be = \"http://user:pass@rust-lang.org/doc#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), should_be);\n     }\n \n     #[test]\n     fn test_fragmentless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?q=v\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org/doc?q=v\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_minimal_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org/doc\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_with_port_parse_and_format() {\n-        let url = \"http://rust-lang.org:80/doc\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org:80/doc\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_pathless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org?q=v#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org?q=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_fragment_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_component_encoding() {\n-        let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\".to_owned();\n+        let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n-        assert!(u.path == \"/doc uments\".to_owned());\n-        assert!(u.query == vec!((\"ba%d \".to_owned(), \"#&+\".to_owned())));\n+        assert!(u.path == \"/doc uments\".to_strbuf());\n+        assert!(u.query == vec!((\"ba%d \".to_strbuf(), \"#&+\".to_strbuf())));\n     }\n \n     #[test]\n     fn test_path_component_encoding() {\n-        let path = \"/doc%20uments?ba%25d%20=%23%26%2B\".to_owned();\n+        let path = \"/doc%20uments?ba%25d%20=%23%26%2B\";\n         let p = path_from_str(path).unwrap();\n-        assert!(p.path == \"/doc uments\".to_owned());\n-        assert!(p.query == vec!((\"ba%d \".to_owned(), \"#&+\".to_owned())));\n+        assert!(p.path == \"/doc uments\".to_strbuf());\n+        assert!(p.query == vec!((\"ba%d \".to_strbuf(), \"#&+\".to_strbuf())));\n     }\n \n     #[test]\n     fn test_url_without_authority() {\n-        let url = \"mailto:test@email.com\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"mailto:test@email.com\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_encode() {\n-        assert_eq!(encode(\"\"), \"\".to_owned());\n-        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_owned());\n-        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_owned());\n-        assert_eq!(encode(\" \"), \"%20\".to_owned());\n-        assert_eq!(encode(\"!\"), \"!\".to_owned());\n-        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_owned());\n-        assert_eq!(encode(\"#\"), \"#\".to_owned());\n-        assert_eq!(encode(\"$\"), \"$\".to_owned());\n-        assert_eq!(encode(\"%\"), \"%25\".to_owned());\n-        assert_eq!(encode(\"&\"), \"&\".to_owned());\n-        assert_eq!(encode(\"'\"), \"%27\".to_owned());\n-        assert_eq!(encode(\"(\"), \"(\".to_owned());\n-        assert_eq!(encode(\")\"), \")\".to_owned());\n-        assert_eq!(encode(\"*\"), \"*\".to_owned());\n-        assert_eq!(encode(\"+\"), \"+\".to_owned());\n-        assert_eq!(encode(\",\"), \",\".to_owned());\n-        assert_eq!(encode(\"/\"), \"/\".to_owned());\n-        assert_eq!(encode(\":\"), \":\".to_owned());\n-        assert_eq!(encode(\";\"), \";\".to_owned());\n-        assert_eq!(encode(\"=\"), \"=\".to_owned());\n-        assert_eq!(encode(\"?\"), \"?\".to_owned());\n-        assert_eq!(encode(\"@\"), \"@\".to_owned());\n-        assert_eq!(encode(\"[\"), \"[\".to_owned());\n-        assert_eq!(encode(\"]\"), \"]\".to_owned());\n+        assert_eq!(encode(\"\"), \"\".to_strbuf());\n+        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_strbuf());\n+        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_strbuf());\n+        assert_eq!(encode(\" \"), \"%20\".to_strbuf());\n+        assert_eq!(encode(\"!\"), \"!\".to_strbuf());\n+        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_strbuf());\n+        assert_eq!(encode(\"#\"), \"#\".to_strbuf());\n+        assert_eq!(encode(\"$\"), \"$\".to_strbuf());\n+        assert_eq!(encode(\"%\"), \"%25\".to_strbuf());\n+        assert_eq!(encode(\"&\"), \"&\".to_strbuf());\n+        assert_eq!(encode(\"'\"), \"%27\".to_strbuf());\n+        assert_eq!(encode(\"(\"), \"(\".to_strbuf());\n+        assert_eq!(encode(\")\"), \")\".to_strbuf());\n+        assert_eq!(encode(\"*\"), \"*\".to_strbuf());\n+        assert_eq!(encode(\"+\"), \"+\".to_strbuf());\n+        assert_eq!(encode(\",\"), \",\".to_strbuf());\n+        assert_eq!(encode(\"/\"), \"/\".to_strbuf());\n+        assert_eq!(encode(\":\"), \":\".to_strbuf());\n+        assert_eq!(encode(\";\"), \";\".to_strbuf());\n+        assert_eq!(encode(\"=\"), \"=\".to_strbuf());\n+        assert_eq!(encode(\"?\"), \"?\".to_strbuf());\n+        assert_eq!(encode(\"@\"), \"@\".to_strbuf());\n+        assert_eq!(encode(\"[\"), \"[\".to_strbuf());\n+        assert_eq!(encode(\"]\"), \"]\".to_strbuf());\n     }\n \n     #[test]\n     fn test_encode_component() {\n-        assert_eq!(encode_component(\"\"), \"\".to_owned());\n+        assert_eq!(encode_component(\"\"), \"\".to_strbuf());\n         assert!(encode_component(\"http://example.com\") ==\n-            \"http%3A%2F%2Fexample.com\".to_owned());\n+            \"http%3A%2F%2Fexample.com\".to_strbuf());\n         assert!(encode_component(\"foo bar% baz\") ==\n-            \"foo%20bar%25%20baz\".to_owned());\n-        assert_eq!(encode_component(\" \"), \"%20\".to_owned());\n-        assert_eq!(encode_component(\"!\"), \"%21\".to_owned());\n-        assert_eq!(encode_component(\"#\"), \"%23\".to_owned());\n-        assert_eq!(encode_component(\"$\"), \"%24\".to_owned());\n-        assert_eq!(encode_component(\"%\"), \"%25\".to_owned());\n-        assert_eq!(encode_component(\"&\"), \"%26\".to_owned());\n-        assert_eq!(encode_component(\"'\"), \"%27\".to_owned());\n-        assert_eq!(encode_component(\"(\"), \"%28\".to_owned());\n-        assert_eq!(encode_component(\")\"), \"%29\".to_owned());\n-        assert_eq!(encode_component(\"*\"), \"%2A\".to_owned());\n-        assert_eq!(encode_component(\"+\"), \"%2B\".to_owned());\n-        assert_eq!(encode_component(\",\"), \"%2C\".to_owned());\n-        assert_eq!(encode_component(\"/\"), \"%2F\".to_owned());\n-        assert_eq!(encode_component(\":\"), \"%3A\".to_owned());\n-        assert_eq!(encode_component(\";\"), \"%3B\".to_owned());\n-        assert_eq!(encode_component(\"=\"), \"%3D\".to_owned());\n-        assert_eq!(encode_component(\"?\"), \"%3F\".to_owned());\n-        assert_eq!(encode_component(\"@\"), \"%40\".to_owned());\n-        assert_eq!(encode_component(\"[\"), \"%5B\".to_owned());\n-        assert_eq!(encode_component(\"]\"), \"%5D\".to_owned());\n+            \"foo%20bar%25%20baz\".to_strbuf());\n+        assert_eq!(encode_component(\" \"), \"%20\".to_strbuf());\n+        assert_eq!(encode_component(\"!\"), \"%21\".to_strbuf());\n+        assert_eq!(encode_component(\"#\"), \"%23\".to_strbuf());\n+        assert_eq!(encode_component(\"$\"), \"%24\".to_strbuf());\n+        assert_eq!(encode_component(\"%\"), \"%25\".to_strbuf());\n+        assert_eq!(encode_component(\"&\"), \"%26\".to_strbuf());\n+        assert_eq!(encode_component(\"'\"), \"%27\".to_strbuf());\n+        assert_eq!(encode_component(\"(\"), \"%28\".to_strbuf());\n+        assert_eq!(encode_component(\")\"), \"%29\".to_strbuf());\n+        assert_eq!(encode_component(\"*\"), \"%2A\".to_strbuf());\n+        assert_eq!(encode_component(\"+\"), \"%2B\".to_strbuf());\n+        assert_eq!(encode_component(\",\"), \"%2C\".to_strbuf());\n+        assert_eq!(encode_component(\"/\"), \"%2F\".to_strbuf());\n+        assert_eq!(encode_component(\":\"), \"%3A\".to_strbuf());\n+        assert_eq!(encode_component(\";\"), \"%3B\".to_strbuf());\n+        assert_eq!(encode_component(\"=\"), \"%3D\".to_strbuf());\n+        assert_eq!(encode_component(\"?\"), \"%3F\".to_strbuf());\n+        assert_eq!(encode_component(\"@\"), \"%40\".to_strbuf());\n+        assert_eq!(encode_component(\"[\"), \"%5B\".to_strbuf());\n+        assert_eq!(encode_component(\"]\"), \"%5D\".to_strbuf());\n     }\n \n     #[test]\n     fn test_decode() {\n-        assert_eq!(decode(\"\"), \"\".to_owned());\n-        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_owned());\n-        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_owned());\n-        assert_eq!(decode(\"%20\"), \" \".to_owned());\n-        assert_eq!(decode(\"%21\"), \"%21\".to_owned());\n-        assert_eq!(decode(\"%22\"), \"%22\".to_owned());\n-        assert_eq!(decode(\"%23\"), \"%23\".to_owned());\n-        assert_eq!(decode(\"%24\"), \"%24\".to_owned());\n-        assert_eq!(decode(\"%25\"), \"%\".to_owned());\n-        assert_eq!(decode(\"%26\"), \"%26\".to_owned());\n-        assert_eq!(decode(\"%27\"), \"'\".to_owned());\n-        assert_eq!(decode(\"%28\"), \"%28\".to_owned());\n-        assert_eq!(decode(\"%29\"), \"%29\".to_owned());\n-        assert_eq!(decode(\"%2A\"), \"%2A\".to_owned());\n-        assert_eq!(decode(\"%2B\"), \"%2B\".to_owned());\n-        assert_eq!(decode(\"%2C\"), \"%2C\".to_owned());\n-        assert_eq!(decode(\"%2F\"), \"%2F\".to_owned());\n-        assert_eq!(decode(\"%3A\"), \"%3A\".to_owned());\n-        assert_eq!(decode(\"%3B\"), \"%3B\".to_owned());\n-        assert_eq!(decode(\"%3D\"), \"%3D\".to_owned());\n-        assert_eq!(decode(\"%3F\"), \"%3F\".to_owned());\n-        assert_eq!(decode(\"%40\"), \"%40\".to_owned());\n-        assert_eq!(decode(\"%5B\"), \"%5B\".to_owned());\n-        assert_eq!(decode(\"%5D\"), \"%5D\".to_owned());\n+        assert_eq!(decode(\"\"), \"\".to_strbuf());\n+        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_strbuf());\n+        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_strbuf());\n+        assert_eq!(decode(\"%20\"), \" \".to_strbuf());\n+        assert_eq!(decode(\"%21\"), \"%21\".to_strbuf());\n+        assert_eq!(decode(\"%22\"), \"%22\".to_strbuf());\n+        assert_eq!(decode(\"%23\"), \"%23\".to_strbuf());\n+        assert_eq!(decode(\"%24\"), \"%24\".to_strbuf());\n+        assert_eq!(decode(\"%25\"), \"%\".to_strbuf());\n+        assert_eq!(decode(\"%26\"), \"%26\".to_strbuf());\n+        assert_eq!(decode(\"%27\"), \"'\".to_strbuf());\n+        assert_eq!(decode(\"%28\"), \"%28\".to_strbuf());\n+        assert_eq!(decode(\"%29\"), \"%29\".to_strbuf());\n+        assert_eq!(decode(\"%2A\"), \"%2A\".to_strbuf());\n+        assert_eq!(decode(\"%2B\"), \"%2B\".to_strbuf());\n+        assert_eq!(decode(\"%2C\"), \"%2C\".to_strbuf());\n+        assert_eq!(decode(\"%2F\"), \"%2F\".to_strbuf());\n+        assert_eq!(decode(\"%3A\"), \"%3A\".to_strbuf());\n+        assert_eq!(decode(\"%3B\"), \"%3B\".to_strbuf());\n+        assert_eq!(decode(\"%3D\"), \"%3D\".to_strbuf());\n+        assert_eq!(decode(\"%3F\"), \"%3F\".to_strbuf());\n+        assert_eq!(decode(\"%40\"), \"%40\".to_strbuf());\n+        assert_eq!(decode(\"%5B\"), \"%5B\".to_strbuf());\n+        assert_eq!(decode(\"%5D\"), \"%5D\".to_strbuf());\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert_eq!(decode_component(\"\"), \"\".to_owned());\n-        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_owned());\n-        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_owned());\n-        assert_eq!(decode_component(\"%20\"), \" \".to_owned());\n-        assert_eq!(decode_component(\"%21\"), \"!\".to_owned());\n-        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_owned());\n-        assert_eq!(decode_component(\"%23\"), \"#\".to_owned());\n-        assert_eq!(decode_component(\"%24\"), \"$\".to_owned());\n-        assert_eq!(decode_component(\"%25\"), \"%\".to_owned());\n-        assert_eq!(decode_component(\"%26\"), \"&\".to_owned());\n-        assert_eq!(decode_component(\"%27\"), \"'\".to_owned());\n-        assert_eq!(decode_component(\"%28\"), \"(\".to_owned());\n-        assert_eq!(decode_component(\"%29\"), \")\".to_owned());\n-        assert_eq!(decode_component(\"%2A\"), \"*\".to_owned());\n-        assert_eq!(decode_component(\"%2B\"), \"+\".to_owned());\n-        assert_eq!(decode_component(\"%2C\"), \",\".to_owned());\n-        assert_eq!(decode_component(\"%2F\"), \"/\".to_owned());\n-        assert_eq!(decode_component(\"%3A\"), \":\".to_owned());\n-        assert_eq!(decode_component(\"%3B\"), \";\".to_owned());\n-        assert_eq!(decode_component(\"%3D\"), \"=\".to_owned());\n-        assert_eq!(decode_component(\"%3F\"), \"?\".to_owned());\n-        assert_eq!(decode_component(\"%40\"), \"@\".to_owned());\n-        assert_eq!(decode_component(\"%5B\"), \"[\".to_owned());\n-        assert_eq!(decode_component(\"%5D\"), \"]\".to_owned());\n+        assert_eq!(decode_component(\"\"), \"\".to_strbuf());\n+        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_strbuf());\n+        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_strbuf());\n+        assert_eq!(decode_component(\"%20\"), \" \".to_strbuf());\n+        assert_eq!(decode_component(\"%21\"), \"!\".to_strbuf());\n+        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_strbuf());\n+        assert_eq!(decode_component(\"%23\"), \"#\".to_strbuf());\n+        assert_eq!(decode_component(\"%24\"), \"$\".to_strbuf());\n+        assert_eq!(decode_component(\"%25\"), \"%\".to_strbuf());\n+        assert_eq!(decode_component(\"%26\"), \"&\".to_strbuf());\n+        assert_eq!(decode_component(\"%27\"), \"'\".to_strbuf());\n+        assert_eq!(decode_component(\"%28\"), \"(\".to_strbuf());\n+        assert_eq!(decode_component(\"%29\"), \")\".to_strbuf());\n+        assert_eq!(decode_component(\"%2A\"), \"*\".to_strbuf());\n+        assert_eq!(decode_component(\"%2B\"), \"+\".to_strbuf());\n+        assert_eq!(decode_component(\"%2C\"), \",\".to_strbuf());\n+        assert_eq!(decode_component(\"%2F\"), \"/\".to_strbuf());\n+        assert_eq!(decode_component(\"%3A\"), \":\".to_strbuf());\n+        assert_eq!(decode_component(\"%3B\"), \";\".to_strbuf());\n+        assert_eq!(decode_component(\"%3D\"), \"=\".to_strbuf());\n+        assert_eq!(decode_component(\"%3F\"), \"?\".to_strbuf());\n+        assert_eq!(decode_component(\"%40\"), \"@\".to_strbuf());\n+        assert_eq!(decode_component(\"%5B\"), \"[\".to_strbuf());\n+        assert_eq!(decode_component(\"%5D\"), \"]\".to_strbuf());\n     }\n \n     #[test]\n     fn test_encode_form_urlencoded() {\n         let mut m = HashMap::new();\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_owned());\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_strbuf());\n \n-        m.insert(\"\".to_owned(), vec!());\n-        m.insert(\"foo\".to_owned(), vec!());\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_owned());\n+        m.insert(\"\".to_strbuf(), vec!());\n+        m.insert(\"foo\".to_strbuf(), vec!());\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_strbuf());\n \n         let mut m = HashMap::new();\n-        m.insert(\"foo\".to_owned(), vec!(\"bar\".to_owned(), \"123\".to_owned()));\n-        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_owned());\n+        m.insert(\"foo\".to_strbuf(), vec!(\"bar\".to_strbuf(), \"123\".to_strbuf()));\n+        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_strbuf());\n \n         let mut m = HashMap::new();\n-        m.insert(\"foo bar\".to_owned(), vec!(\"abc\".to_owned(), \"12 = 34\".to_owned()));\n+        m.insert(\"foo bar\".to_strbuf(), vec!(\"abc\".to_strbuf(), \"12 = 34\".to_strbuf()));\n         assert!(encode_form_urlencoded(&m) ==\n-            \"foo+bar=abc&foo+bar=12+%3D+34\".to_owned());\n+            \"foo+bar=abc&foo+bar=12+%3D+34\".to_strbuf());\n     }\n \n     #[test]\n@@ -1282,7 +1294,8 @@ mod tests {\n         let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n         let form = decode_form_urlencoded(s);\n         assert_eq!(form.len(), 2);\n-        assert_eq!(form.get(&\"a\".to_owned()), &vec!(\"1\".to_owned()));\n-        assert_eq!(form.get(&\"foo bar\".to_owned()), &vec!(\"abc\".to_owned(), \"12 = 34\".to_owned()));\n+        assert_eq!(form.get(&\"a\".to_strbuf()), &vec!(\"1\".to_strbuf()));\n+        assert_eq!(form.get(&\"foo bar\".to_strbuf()),\n+                   &vec!(\"abc\".to_strbuf(), \"12 = 34\".to_strbuf()));\n     }\n }"}, {"sha": "d75f967a229b1990f43e9e9b1599f0226cf1966c", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -322,20 +322,20 @@ impl Uuid {\n     /// Returns the UUID as a string of 16 hexadecimal digits\n     ///\n     /// Example: `936DA01F9ABD4d9d80C702AF85C822A8`\n-    pub fn to_simple_str(&self) -> ~str {\n+    pub fn to_simple_str(&self) -> StrBuf {\n         let mut s: Vec<u8> = Vec::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n             let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n             *s.get_mut(i*2+0) = digit[0];\n             *s.get_mut(i*2+1) = digit[1];\n         }\n-        str::from_utf8(s.as_slice()).unwrap().to_str()\n+        str::from_utf8(s.as_slice()).unwrap().to_strbuf()\n     }\n \n     /// Returns a string of hexadecimal digits, separated into groups with a hyphen.\n     ///\n     /// Example: `550e8400-e29b-41d4-a716-446655440000`\n-    pub fn to_hyphenated_str(&self) -> ~str {\n+    pub fn to_hyphenated_str(&self) -> StrBuf {\n         use std::mem::{to_be16, to_be32};\n         // Convert to field-based struct as it matches groups in output.\n         // Ensure fields are in network byte order, as per RFC.\n@@ -346,8 +346,8 @@ impl Uuid {\n         uf.data1 = to_be32(uf.data1);\n         uf.data2 = to_be16(uf.data2);\n         uf.data3 = to_be16(uf.data3);\n-        let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n-                         {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n+        let s = format_strbuf!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n+                                {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n             uf.data1,\n             uf.data2, uf.data3,\n             uf.data4[0], uf.data4[1],\n@@ -361,8 +361,8 @@ impl Uuid {\n     /// This is the same as the hyphenated format, but with the \"urn:uuid:\" prefix.\n     ///\n     /// Example: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n-    pub fn to_urn_str(&self) -> ~str {\n-        \"urn:uuid:\" + self.to_hyphenated_str()\n+    pub fn to_urn_str(&self) -> StrBuf {\n+        format_strbuf!(\"urn:uuid:{}\", self.to_hyphenated_str())\n     }\n \n     /// Parses a UUID from a string of hexadecimal digits with optional hyphens\n@@ -493,7 +493,7 @@ impl TotalEq for Uuid {}\n impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n     /// Encode a UUID as a hypenated string\n     fn encode(&self, e: &mut T) -> Result<(), E> {\n-        e.emit_str(self.to_hyphenated_str())\n+        e.emit_str(self.to_hyphenated_str().as_slice())\n     }\n }\n \n@@ -647,7 +647,7 @@ mod test {\n         let s = uuid1.to_simple_str();\n \n         assert!(s.len() == 32);\n-        assert!(s.chars().all(|c| c.is_digit_radix(16)));\n+        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16)));\n     }\n \n     #[test]\n@@ -656,7 +656,7 @@ mod test {\n         let s = uuid1.to_str();\n \n         assert!(s.len() == 32);\n-        assert!(s.chars().all(|c| c.is_digit_radix(16)));\n+        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16)));\n     }\n \n     #[test]\n@@ -665,18 +665,20 @@ mod test {\n         let s = uuid1.to_hyphenated_str();\n \n         assert!(s.len() == 36);\n-        assert!(s.chars().all(|c| c.is_digit_radix(16) || c == '-'));\n+        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16) || c == '-'));\n     }\n \n     #[test]\n     fn test_to_urn_str() {\n         let uuid1 = Uuid::new_v4();\n         let ss = uuid1.to_urn_str();\n-        let s = ss.slice(9, ss.len());\n+        let s = ss.as_slice().slice(9, ss.len());\n \n-        assert!(ss.starts_with(\"urn:uuid:\"));\n+        assert!(ss.as_slice().starts_with(\"urn:uuid:\"));\n         assert!(s.len() == 36);\n-        assert!(s.chars().all(|c| c.is_digit_radix(16) || c == '-'));\n+        assert!(s.as_slice()\n+                 .chars()\n+                 .all(|c| c.is_digit_radix(16) || c == '-'));\n     }\n \n     #[test]\n@@ -686,7 +688,8 @@ mod test {\n         let hs = uuid1.to_hyphenated_str();\n         let ss = uuid1.to_str();\n \n-        let hsn = str::from_chars(hs.chars()\n+        let hsn = str::from_chars(hs.as_slice()\n+                                    .chars()\n                                     .filter(|&c| c != '-')\n                                     .collect::<Vec<char>>()\n                                     .as_slice());\n@@ -699,7 +702,7 @@ mod test {\n         let uuid = Uuid::new_v4();\n \n         let hs = uuid.to_hyphenated_str();\n-        let uuid_hs = Uuid::parse_string(hs).unwrap();\n+        let uuid_hs = Uuid::parse_string(hs.as_slice()).unwrap();\n         assert!(uuid_hs == uuid);\n \n         let ss = uuid.to_str();\n@@ -727,7 +730,7 @@ mod test {\n \n         let u = Uuid::from_fields(d1, d2, d3, d4.as_slice());\n \n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_owned();\n+        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_strbuf();\n         let result = u.to_simple_str();\n         assert!(result == expected);\n     }\n@@ -738,7 +741,7 @@ mod test {\n                    0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 );\n \n         let u = Uuid::from_bytes(b.as_slice()).unwrap();\n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_owned();\n+        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_strbuf();\n \n         assert!(u.to_simple_str() == expected);\n     }"}, {"sha": "c2dd8459540d89724a7d8d4084445f51c188b196", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -103,31 +103,31 @@ use std::io::{File, MemWriter};\n \n #[deriving(Clone, Eq, Encodable, Decodable, Ord, TotalOrd, TotalEq)]\n struct WorkKey {\n-    kind: ~str,\n-    name: ~str\n+    kind: StrBuf,\n+    name: StrBuf\n }\n \n impl WorkKey {\n     pub fn new(kind: &str, name: &str) -> WorkKey {\n         WorkKey {\n-            kind: kind.to_owned(),\n-            name: name.to_owned(),\n+            kind: kind.to_strbuf(),\n+            name: name.to_strbuf(),\n         }\n     }\n }\n \n-// FIXME #8883: The key should be a WorkKey and not a ~str.\n+// FIXME #8883: The key should be a WorkKey and not a StrBuf.\n // This is working around some JSON weirdness.\n #[deriving(Clone, Eq, Encodable, Decodable)]\n-struct WorkMap(TreeMap<~str, KindMap>);\n+struct WorkMap(TreeMap<StrBuf, KindMap>);\n \n #[deriving(Clone, Eq, Encodable, Decodable)]\n-struct KindMap(TreeMap<~str, ~str>);\n+struct KindMap(TreeMap<StrBuf, StrBuf>);\n \n impl WorkMap {\n     fn new() -> WorkMap { WorkMap(TreeMap::new()) }\n \n-    fn insert_work_key(&mut self, k: WorkKey, val: ~str) {\n+    fn insert_work_key(&mut self, k: WorkKey, val: StrBuf) {\n         let WorkKey { kind, name } = k;\n         let WorkMap(ref mut map) = *self;\n         match map.find_mut(&name) {\n@@ -142,7 +142,7 @@ impl WorkMap {\n \n pub struct Database {\n     db_filename: Path,\n-    db_cache: TreeMap<~str, ~str>,\n+    db_cache: TreeMap<StrBuf, StrBuf>,\n     pub db_dirty: bool,\n }\n \n@@ -163,11 +163,11 @@ impl Database {\n     pub fn prepare(&self,\n                    fn_name: &str,\n                    declared_inputs: &WorkMap)\n-                   -> Option<(WorkMap, WorkMap, ~str)> {\n+                   -> Option<(WorkMap, WorkMap, StrBuf)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n-            Some(v) => Some(json_decode(*v))\n+            Some(v) => Some(json_decode(v.as_slice()))\n         }\n     }\n \n@@ -188,7 +188,14 @@ impl Database {\n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) -> io::IoResult<()> {\n         let mut f = File::create(&self.db_filename);\n-        self.db_cache.to_json().to_pretty_writer(&mut f)\n+\n+        // FIXME(pcwalton): Yuck.\n+        let mut new_db_cache = TreeMap::new();\n+        for (ref k, ref v) in self.db_cache.iter() {\n+            new_db_cache.insert((*k).to_owned(), (*v).to_owned());\n+        }\n+\n+        new_db_cache.to_json().to_pretty_writer(&mut f)\n     }\n \n     fn load(&mut self) {\n@@ -222,7 +229,7 @@ impl Drop for Database {\n     }\n }\n \n-pub type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n+pub type FreshnessMap = TreeMap<StrBuf,extern fn(&str,&str)->bool>;\n \n #[deriving(Clone)]\n pub struct Context {\n@@ -253,11 +260,11 @@ enum Work<'a, T> {\n     WorkFromTask(&'a Prep<'a>, Receiver<(Exec, T)>),\n }\n \n-fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> ~str {\n+fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> StrBuf {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     let _ = t.encode(&mut encoder);\n-    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_owned()\n+    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_strbuf()\n }\n \n // FIXME(#5121)\n@@ -308,19 +315,19 @@ impl Exec {\n                           dependency_val: &str) {\n         debug!(\"Discovering input {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_inputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n-                                 dependency_val.to_owned());\n+                                 dependency_val.to_strbuf());\n     }\n     pub fn discover_output(&mut self,\n                            dependency_kind: &str,\n                            dependency_name: &str,\n                            dependency_val: &str) {\n         debug!(\"Discovering output {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_outputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n-                                 dependency_val.to_owned());\n+                                 dependency_val.to_strbuf());\n     }\n \n     // returns pairs of (kind, name)\n-    pub fn lookup_discovered_inputs(&self) -> Vec<(~str, ~str)> {\n+    pub fn lookup_discovered_inputs(&self) -> Vec<(StrBuf, StrBuf)> {\n         let mut rs = vec![];\n         let WorkMap(ref discovered_inputs) = self.discovered_inputs;\n         for (k, v) in discovered_inputs.iter() {\n@@ -342,7 +349,7 @@ impl<'a> Prep<'a> {\n         }\n     }\n \n-    pub fn lookup_declared_inputs(&self) -> Vec<~str> {\n+    pub fn lookup_declared_inputs(&self) -> Vec<StrBuf> {\n         let mut rs = vec![];\n         let WorkMap(ref declared_inputs) = self.declared_inputs;\n         for (_, v) in declared_inputs.iter() {\n@@ -359,12 +366,11 @@ impl<'a> Prep<'a> {\n     pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n         debug!(\"Declaring input {} {} {}\", kind, name, val);\n         self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n-                                 val.to_owned());\n+                                 val.to_strbuf());\n     }\n \n-    fn is_fresh(&self, cat: &str, kind: &str,\n-                name: &str, val: &str) -> bool {\n-        let k = kind.to_owned();\n+    fn is_fresh(&self, cat: &str, kind: &str, name: &str, val: &str) -> bool {\n+        let k = kind.to_strbuf();\n         let f = self.ctxt.freshness.deref().find(&k);\n         debug!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n@@ -384,7 +390,10 @@ impl<'a> Prep<'a> {\n         for (k_name, kindmap) in map.iter() {\n             let KindMap(ref kindmap_) = *kindmap;\n             for (k_kind, v) in kindmap_.iter() {\n-               if ! self.is_fresh(cat, *k_kind, *k_name, *v) {\n+               if !self.is_fresh(cat,\n+                                 k_kind.as_slice(),\n+                                 k_name.as_slice(),\n+                                 v.as_slice()) {\n                   return false;\n             }\n           }\n@@ -420,7 +429,7 @@ impl<'a> Prep<'a> {\n                 debug!(\"Cache hit!\");\n                 debug!(\"Trying to decode: {:?} / {:?} / {}\",\n                        disc_in, disc_out, *res);\n-                Work::from_value(json_decode(*res))\n+                Work::from_value(json_decode(res.as_slice()))\n             }\n \n             _ => {\n@@ -467,7 +476,7 @@ impl<'a, T:Send +\n                                      &prep.declared_inputs,\n                                      &exe.discovered_inputs,\n                                      &exe.discovered_outputs,\n-                                     s);\n+                                     s.as_slice());\n                 v\n             }\n         }\n@@ -484,18 +493,18 @@ fn test() {\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n-    fn make_path(filename: ~str) -> Path {\n+    fn make_path(filename: StrBuf) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n         if pth.exists() {\n             fs::unlink(&pth).unwrap();\n         }\n         return pth;\n     }\n \n-    let pth = make_path(\"foo.c\".to_owned());\n+    let pth = make_path(\"foo.c\".to_strbuf());\n     File::create(&pth).write(bytes!(\"int main() { return 0; }\")).unwrap();\n \n-    let db_path = make_path(\"db.json\".to_owned());\n+    let db_path = make_path(\"db.json\".to_strbuf());\n \n     let cx = Context::new(Arc::new(RWLock::new(Database::new(db_path))),\n                           Arc::new(TreeMap::new()));\n@@ -511,7 +520,7 @@ fn test() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n         prep.exec(proc(_exe) {\n-            let out = make_path(\"foo.o\".to_owned());\n+            let out = make_path(\"foo.o\".to_strbuf());\n             let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             Process::status(compiler, [pth.as_str().unwrap().to_owned(),"}, {"sha": "67e57de085aaf65e56113d9b0e55d3809514b113", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@ pub mod kitties {\n         meows : uint,\n \n         pub how_hungry : int,\n-        pub name : ~str,\n+        pub name : StrBuf,\n     }\n \n     impl cat {\n@@ -41,7 +41,7 @@ pub mod kitties {\n         }\n     }\n \n-    pub fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+    pub fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "0abacf9ecdd23f8017a71cf2ef691019dee5e72d", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,7 +14,7 @@ pub mod kitty {\n     pub struct cat {\n       meows : uint,\n       pub how_hungry : int,\n-      pub name : ~str,\n+      pub name : StrBuf,\n     }\n \n     impl fmt::Show for cat {\n@@ -50,7 +50,7 @@ pub mod kitty {\n         }\n     }\n \n-    pub fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+    pub fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "36e46f6c8c2863bd6fb78d236d82e840ef9a2c0d", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -17,11 +17,11 @@ pub mod name_pool {\n     pub type name_pool = ();\n \n     pub trait add {\n-        fn add(&self, s: ~str);\n+        fn add(&self, s: StrBuf);\n     }\n \n     impl add for name_pool {\n-        fn add(&self, _s: ~str) {\n+        fn add(&self, _s: StrBuf) {\n         }\n     }\n }"}, {"sha": "ca3cf1bd857ae49023472ccc4a60ded991453031", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,10 +12,10 @@\n \n #![crate_type = \"lib\"]\n \n-pub struct NameVal { pub name: ~str, pub val: int }\n+pub struct NameVal { pub name: StrBuf, pub val: int }\n \n pub fn struct_nameval() -> NameVal {\n-    NameVal { name: \"crateresolve5\".to_owned(), val: 10 }\n+    NameVal { name: \"crateresolve5\".to_strbuf(), val: 10 }\n }\n \n pub enum e {"}, {"sha": "631f68d0b84749a9dbf22a5cf7c5b12580fbed05", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,9 +12,9 @@\n \n #![crate_type = \"lib\"]\n \n-pub struct NameVal { pub name: ~str, pub val: int }\n+pub struct NameVal { pub name: StrBuf, pub val: int }\n pub fn struct_nameval() -> NameVal {\n-    NameVal { name: \"crateresolve5\".to_owned(), val: 10 }\n+    NameVal { name: \"crateresolve5\".to_strbuf(), val: 10 }\n }\n \n pub enum e {"}, {"sha": "c23af84b3f5eeceb0e8e71688438f27d946f3161", "filename": "src/test/auxiliary/explicit_self_xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fexplicit_self_xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fexplicit_self_xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fexplicit_self_xcrate.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,7 +14,7 @@ pub trait Foo {\n }\n \n pub struct Bar {\n-    pub x: ~str\n+    pub x: StrBuf\n }\n \n impl Foo for Bar {"}, {"sha": "7767859144ac94ff1f6b37b14161c3e42d70eadd", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -17,6 +17,6 @@ trait foo {\n     fn foo(&self);\n }\n \n-impl foo for ~str {\n+impl foo for StrBuf {\n     fn foo(&self) {}\n }"}, {"sha": "495999bfcbcbaaefb42a076fa45aa821da104c22", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -17,9 +17,11 @@ extern crate collections;\n use std::cell::RefCell;\n use collections::HashMap;\n \n-pub type header_map = HashMap<~str, @RefCell<Vec<@~str>>>;\n+pub type header_map = HashMap<StrBuf, @RefCell<Vec<@StrBuf>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (**((**req.get(&\"METHOD\".to_owned())).clone()).borrow().clone().get(0)).clone();\n+  let _x = (**((**req.get(&\"METHOD\".to_strbuf())).clone()).borrow()\n+                                                          .clone()\n+                                                          .get(0)).clone();\n }"}, {"sha": "3c860958e2c1008c89eaeac2274db6f1e22f68b5", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -48,7 +48,7 @@ pub mod testtypes {\n     // Tests ty_float (does not test all variants of FloatTy)\n     pub type FooFloat = f64;\n \n-    // For ty_str, what kind of string should I use? &'static str? ~str? Raw str?\n+    // For ty_str, what kind of string should I use? &'static str? StrBuf? Raw str?\n \n     // Tests ty_enum\n     pub enum FooEnum {"}, {"sha": "855e48f3f91a06b442d2543ad7e9e0661755db44", "filename": "src/test/auxiliary/issue_2242_a.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,9 +12,9 @@\n #![crate_type = \"lib\"]\n \n trait to_strz {\n-    fn to_strz() -> ~str;\n+    fn to_strz() -> StrBuf;\n }\n \n-impl to_strz for ~str {\n-    fn to_strz() -> ~str { self.clone() }\n+impl to_strz for StrBuf {\n+    fn to_strz() -> StrBuf { self.clone() }\n }"}, {"sha": "6c04a742efb8d7e4cfe63d5d8c23c55c97930b97", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -16,5 +16,5 @@ extern crate a;\n use a::to_strz;\n \n impl to_strz for bool {\n-    fn to_strz() -> ~str { fmt!(\"%b\", self) }\n+    fn to_strz() -> StrBuf { fmt!(\"%b\", self) }\n }"}, {"sha": "f93bd5e2e497209ccba4300f2b72101ade0337b6", "filename": "src/test/auxiliary/reexported_static_methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -31,7 +31,7 @@ pub mod sub_foo {\n     }\n \n     pub struct Boz {\n-        unused_str: ~str\n+        unused_str: StrBuf\n     }\n \n     impl Boz {\n@@ -46,8 +46,8 @@ pub mod sub_foo {\n     }\n \n     impl Bort {\n-        pub fn bort() -> ~str {\n-            \"bort()\".to_owned()\n+        pub fn bort() -> StrBuf {\n+            \"bort()\".to_strbuf()\n         }\n     }\n }"}, {"sha": "367ab47ceaa1a68e310809fe5c1a0c7cb0d0cd02", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,17 +14,17 @@\n use std::int;\n \n pub trait read {\n-    fn readMaybe(s: ~str) -> Option<Self>;\n+    fn readMaybe(s: StrBuf) -> Option<Self>;\n }\n \n impl read for int {\n-    fn readMaybe(s: ~str) -> Option<int> {\n-        from_str::<int>(s)\n+    fn readMaybe(s: StrBuf) -> Option<int> {\n+        from_str::<int>(s.as_slice())\n     }\n }\n \n impl read for bool {\n-    fn readMaybe(s: ~str) -> Option<bool> {\n+    fn readMaybe(s: StrBuf) -> Option<bool> {\n         match s.as_slice() {\n           \"true\" => Some(true),\n           \"false\" => Some(false),\n@@ -33,7 +33,7 @@ impl read for bool {\n     }\n }\n \n-pub fn read<T:read>(s: ~str) -> T {\n+pub fn read<T:read>(s: StrBuf) -> T {\n     match read::readMaybe(s) {\n       Some(x) => x,\n       _ => fail!(\"read failed!\")"}, {"sha": "757d61f28574692221efacea58c0ab390477901b", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -80,7 +80,7 @@ impl Results {\n         }\n     }\n \n-    pub fn bench_str<T:MutableSet<~str>,\n+    pub fn bench_str<T:MutableSet<StrBuf>,\n                      R:rand::Rng>(\n                      &mut self,\n                      rng: &mut R,\n@@ -90,11 +90,11 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.sequential_strings, || {\n                 for i in range(0u, num_keys) {\n-                    set.insert(i.to_str());\n+                    set.insert(i.to_str().to_strbuf());\n                 }\n \n                 for i in range(0u, num_keys) {\n-                    assert!(set.contains(&i.to_str()));\n+                    assert!(set.contains(&i.to_str().to_strbuf()));\n                 }\n             })\n         }\n@@ -103,7 +103,7 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.random_strings, || {\n                 for _ in range(0, num_keys) {\n-                    let s = rng.gen::<uint>().to_str();\n+                    let s = rng.gen::<uint>().to_str().to_strbuf();\n                     set.insert(s);\n                 }\n             })\n@@ -112,11 +112,11 @@ impl Results {\n         {\n             let mut set = f();\n             for i in range(0u, num_keys) {\n-                set.insert(i.to_str());\n+                set.insert(i.to_str().to_strbuf());\n             }\n             timed(&mut self.delete_strings, || {\n                 for i in range(0u, num_keys) {\n-                    assert!(set.remove(&i.to_str()));\n+                    assert!(set.remove(&i.to_str().to_strbuf()));\n                 }\n             })\n         }\n@@ -175,7 +175,7 @@ fn main() {\n             s\n         });\n         results.bench_str(&mut rng, num_keys, || {\n-            let s: HashSet<~str> = HashSet::new();\n+            let s: HashSet<StrBuf> = HashSet::new();\n             s\n         });\n         write_results(\"collections::HashSet\", &results);\n@@ -189,7 +189,7 @@ fn main() {\n             s\n         });\n         results.bench_str(&mut rng, num_keys, || {\n-            let s: TreeSet<~str> = TreeSet::new();\n+            let s: TreeSet<StrBuf> = TreeSet::new();\n             s\n         });\n         write_results(\"collections::TreeSet\", &results);"}, {"sha": "9c854a31c1e5e70ab1aae796a467e91c7b23050e", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -24,11 +24,13 @@ use std::vec;\n use std::io::File;\n \n macro_rules! bench (\n-    ($argv:expr, $id:ident) => (maybe_run_test($argv.as_slice(), stringify!($id).to_owned(), $id))\n+    ($argv:expr, $id:ident) => (maybe_run_test($argv.as_slice(),\n+                                               stringify!($id).to_strbuf(),\n+                                                          $id))\n )\n \n fn main() {\n-    let argv = os::args();\n+    let argv = os::args().move_iter().map(|x| x.to_strbuf()).collect::<Vec<StrBuf>>();\n     let _tests = argv.slice(1, argv.len());\n \n     bench!(argv, shift_push);\n@@ -40,13 +42,13 @@ fn main() {\n     bench!(argv, is_utf8_multibyte);\n }\n \n-fn maybe_run_test(argv: &[~str], name: ~str, test: ||) {\n+fn maybe_run_test(argv: &[StrBuf], name: StrBuf, test: ||) {\n     let mut run_test = false;\n \n     if os::getenv(\"RUST_BENCH\").is_some() {\n         run_test = true\n     } else if argv.len() > 0 {\n-        run_test = argv.iter().any(|x| x == &\"all\".to_owned()) || argv.iter().any(|x| x == &name)\n+        run_test = argv.iter().any(|x| x == &\"all\".to_strbuf()) || argv.iter().any(|x| x == &name)\n     }\n \n     if !run_test {"}, {"sha": "0135688a81cb5975028d0e2379d23b1abe485553", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -52,12 +52,12 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     //println!(\"server exiting\");\n }\n \n-fn run(args: &[~str]) {\n+fn run(args: &[StrBuf]) {\n     let (to_parent, from_child) = channel();\n     let (to_child, from_parent) = channel();\n \n-    let size = from_str::<uint>(args[1]).unwrap();\n-    let workers = from_str::<uint>(args[2]).unwrap();\n+    let size = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let workers = from_str::<uint>(args[2].as_slice()).unwrap();\n     let num_bytes = 100;\n     let start = time::precise_time_s();\n     let mut worker_results = Vec::new();\n@@ -97,13 +97,13 @@ fn run(args: &[~str]) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"1000000\".to_owned(), \"10000\".to_owned())\n+        vec!(\"\".to_strbuf(), \"1000000\".to_strbuf(), \"10000\".to_strbuf())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"10000\".to_owned(), \"4\".to_owned())\n+        vec!(\"\".to_strbuf(), \"10000\".to_strbuf(), \"4\".to_strbuf())\n     } else {\n-        args.clone().move_iter().collect()\n+        args.move_iter().map(|x| x.to_strbuf()).collect()\n     };\n \n-    println!(\"{:?}\", args);\n+    println!(\"{}\", args);\n     run(args.as_slice());\n }"}, {"sha": "20ed7efcb8316b49e4a4fde29a7e3b5e42591949", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -47,11 +47,11 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     //println!(\"server exiting\");\n }\n \n-fn run(args: &[~str]) {\n+fn run(args: &[StrBuf]) {\n     let (to_parent, from_child) = channel();\n \n-    let size = from_str::<uint>(args[1]).unwrap();\n-    let workers = from_str::<uint>(args[2]).unwrap();\n+    let size = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let workers = from_str::<uint>(args[2].as_slice()).unwrap();\n     let num_bytes = 100;\n     let start = time::precise_time_s();\n     let mut worker_results = Vec::new();\n@@ -107,11 +107,11 @@ fn run(args: &[~str]) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"1000000\".to_owned(), \"8\".to_owned())\n+        vec!(\"\".to_strbuf(), \"1000000\".to_strbuf(), \"8\".to_strbuf())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"10000\".to_owned(), \"4\".to_owned())\n+        vec!(\"\".to_strbuf(), \"10000\".to_strbuf(), \"4\".to_strbuf())\n     } else {\n-        args.clone().move_iter().collect()\n+        args.clone().move_iter().map(|x| x.to_strbuf()).collect()\n     };\n \n     println!(\"{:?}\", args);"}, {"sha": "181d19ade3ab421068e9659f13cc5a2ba6cb1c63", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -74,10 +74,10 @@ fn main() {\n                     let b = bottom_up_tree(&arena, -i, depth);\n                     chk += item_check(a) + item_check(b);\n                 }\n-                format!(\"{}\\t trees of depth {}\\t check: {}\",\n-                        iterations * 2, depth, chk)\n+                format_strbuf!(\"{}\\t trees of depth {}\\t check: {}\",\n+                               iterations * 2, depth, chk)\n             })\n-        }).collect::<Vec<Future<~str>>>();\n+        }).collect::<Vec<Future<StrBuf>>>();\n \n     for message in messages.mut_iter() {\n         println!(\"{}\", *message.get_ref());"}, {"sha": "9db068e56c29af2ff4ee65103e5bec7d807279d2", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -107,7 +107,7 @@ fn creature(\n     mut color: Color,\n     from_rendezvous: Receiver<CreatureInfo>,\n     to_rendezvous: Sender<CreatureInfo>,\n-    to_rendezvous_log: Sender<~str>\n+    to_rendezvous_log: Sender<StrBuf>\n ) {\n     let mut creatures_met = 0;\n     let mut evil_clones_met = 0;\n@@ -132,7 +132,9 @@ fn creature(\n         }\n     }\n     // log creatures met and evil clones of self\n-    let report = format!(\"{}{}\", creatures_met, Number(evil_clones_met));\n+    let report = format_strbuf!(\"{}{}\",\n+                                creatures_met,\n+                                Number(evil_clones_met));\n     to_rendezvous_log.send(report);\n }\n \n@@ -141,7 +143,7 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n     let (to_rendezvous, from_creatures) = channel::<CreatureInfo>();\n \n     // these channels will be passed to the creatures so they can talk to us\n-    let (to_rendezvous_log, from_creatures_log) = channel::<~str>();\n+    let (to_rendezvous_log, from_creatures_log) = channel::<StrBuf>();\n \n     // these channels will allow us to talk to each creature by 'name'/index\n     let mut to_creature: Vec<Sender<CreatureInfo>> ="}, {"sha": "250562a095ea035658372b2d962102d5b2eb5ac6", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -37,7 +37,7 @@ fn f64_cmp(x: f64, y: f64) -> Ordering {\n }\n \n // given a map, print a sorted version of it\n-fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> ~str {\n+fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> StrBuf {\n    fn pct(xx: uint, yy: uint) -> f64 {\n       return (xx as f64) * 100.0 / (yy as f64);\n    }\n@@ -67,12 +67,12 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> ~str {\n                                .into_str(), v));\n    }\n \n-   return buffer.into_owned();\n+   return buffer\n }\n \n // given a map, search for the frequency of a pattern\n-fn find(mm: &HashMap<Vec<u8> , uint>, key: ~str) -> uint {\n-   let key = key.into_ascii().as_slice().to_lower().into_str();\n+fn find(mm: &HashMap<Vec<u8> , uint>, key: StrBuf) -> uint {\n+   let key = key.to_owned().into_ascii().as_slice().to_lower().into_str();\n    match mm.find_equiv(&key.as_bytes()) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }\n@@ -106,7 +106,7 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n \n fn make_sequence_processor(sz: uint,\n                            from_parent: &Receiver<Vec<u8>>,\n-                           to_parent: &Sender<~str>) {\n+                           to_parent: &Sender<StrBuf>) {\n    let mut freqs: HashMap<Vec<u8>, uint> = HashMap::new();\n    let mut carry = Vec::new();\n    let mut total: uint = 0u;\n@@ -129,13 +129,13 @@ fn make_sequence_processor(sz: uint,\n    let buffer = match sz {\n        1u => { sort_and_fmt(&freqs, total) }\n        2u => { sort_and_fmt(&freqs, total) }\n-       3u => { format!(\"{}\\t{}\", find(&freqs, \"GGT\".to_owned()), \"GGT\") }\n-       4u => { format!(\"{}\\t{}\", find(&freqs, \"GGTA\".to_owned()), \"GGTA\") }\n-       6u => { format!(\"{}\\t{}\", find(&freqs, \"GGTATT\".to_owned()), \"GGTATT\") }\n-      12u => { format!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATT\".to_owned()), \"GGTATTTTAATT\") }\n-      18u => { format!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATTTATAGT\".to_owned()),\n+       3u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGT\".to_strbuf()), \"GGT\") }\n+       4u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTA\".to_strbuf()), \"GGTA\") }\n+       6u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATT\".to_strbuf()), \"GGTATT\") }\n+      12u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATT\".to_strbuf()), \"GGTATTTTAATT\") }\n+      18u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATTTATAGT\".to_strbuf()),\n                        \"GGTATTTTAATTTATAGT\") }\n-        _ => { \"\".to_owned() }\n+        _ => { \"\".to_strbuf() }\n    };\n \n     to_parent.send(buffer);\n@@ -155,7 +155,7 @@ fn main() {\n \n     // initialize each sequence sorter\n     let sizes = vec!(1u,2,3,4,6,12,18);\n-    let mut streams = Vec::from_fn(sizes.len(), |_| Some(channel::<~str>()));\n+    let mut streams = Vec::from_fn(sizes.len(), |_| Some(channel::<StrBuf>()));\n     let mut from_child = Vec::new();\n     let to_child  = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n         let sz = *sz;"}, {"sha": "dd795b7faea81456b4f81c2e862efbcb6b525dc4", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -184,7 +184,7 @@ fn get_id(m: u64) -> u8 {\n     fail!(\"{:016x} does not have a valid identifier\", m);\n }\n \n-// Converts a list of mask to a ~str.\n+// Converts a list of mask to a StrBuf.\n fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n     let mut sol = Vec::from_elem(50, '.' as u8);\n     for &m in raw_sol.iter() {\n@@ -198,7 +198,7 @@ fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n     sol\n }\n \n-// Prints a solution in ~str form.\n+// Prints a solution in StrBuf form.\n fn print_sol(sol: &Vec<u8>) {\n     for (i, c) in sol.iter().enumerate() {\n         if (i) % 5 == 0 { println!(\"\"); }"}, {"sha": "a6e579689ed4258bf7cdc444dd49af9303e4ede5", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -52,9 +52,10 @@ struct Config {\n     stress: bool\n }\n \n-fn parse_opts(argv: Vec<~str> ) -> Config {\n+fn parse_opts(argv: Vec<StrBuf> ) -> Config {\n     let opts = vec!(getopts::optflag(\"\", \"stress\", \"\"));\n \n+    let argv = argv.iter().map(|x| x.to_str()).collect::<Vec<_>>();\n     let opt_args = argv.slice(1, argv.len());\n \n     match getopts::getopts(opt_args, opts.as_slice()) {\n@@ -92,11 +93,11 @@ fn stress(num_tasks: int) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"20\".to_owned())\n+        vec!(\"\".to_strbuf(), \"20\".to_strbuf())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"8\".to_owned())\n+        vec!(\"\".to_strbuf(), \"8\".to_strbuf())\n     } else {\n-        args.move_iter().collect()\n+        args.move_iter().map(|x| x.to_strbuf()).collect()\n     };\n \n     let opts = parse_opts(args.clone());"}, {"sha": "ab5735150fdc4666bd103426a14fe70a76e90c16", "filename": "src/test/compile-fail/bad-const-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected `~str` but found `int`\n+// error-pattern:expected `std::strbuf::StrBuf` but found `int`\n \n-static i: ~str = 10i;\n-fn main() { println!(\"{:?}\", i); }\n+static i: StrBuf = 10i;\n+fn main() { println!(\"{}\", i); }"}, {"sha": "0fadbbe785d9076f1e1aa0309b33528276d50f15", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,4 +12,4 @@\n \n mod m1 {}\n \n-fn main(args: Vec<~str>) { log(debug, m1::a); }\n+fn main(args: Vec<StrBuf>) { log(debug, m1::a); }"}, {"sha": "84bdf40dbabead331f0ca57562be326978acc206", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,6 +14,6 @@ mod m1 {\n     pub mod a {}\n }\n \n-fn main(args: Vec<~str>) {\n+fn main(args: Vec<StrBuf>) {\n     log(debug, m1::a);\n }"}, {"sha": "c0da78737ca9f73a60dfb84e028cc96456bc873d", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:`^` cannot be applied to type `~str`\n+// error-pattern:`^` cannot be applied to type `std::strbuf::StrBuf`\n \n-fn main() { let x = \"a\".to_owned() ^ \"b\".to_owned(); }\n+fn main() { let x = \"a\".to_strbuf() ^ \"b\".to_strbuf(); }"}, {"sha": "de77bb8144d8717198ec60028ff125e230f6a2a1", "filename": "src/test/compile-fail/borrowck-move-error-with-note.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -26,15 +26,15 @@ fn blah() {\n }\n \n struct S {\n-    f: ~str,\n-    g: ~str\n+    f: StrBuf,\n+    g: StrBuf\n }\n impl Drop for S {\n     fn drop(&mut self) { println!(\"{}\", self.f); }\n }\n \n fn move_in_match() {\n-    match S {f: \"foo\".to_owned(), g: \"bar\".to_owned()} {\n+    match S {f: \"foo\".to_strbuf(), g: \"bar\".to_strbuf()} {\n         S {         //~ ERROR cannot move out of type `S`, which defines the `Drop` trait\n             f: _s,  //~ NOTE attempting to move value to here\n             g: _t   //~ NOTE and here"}, {"sha": "c65f2523f9bd87794bf0a175b2eb6aed077276f5", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with(f: |&~str|) {}\n+fn with(f: |&StrBuf|) {}\n \n-fn arg_item(&_x: &~str) {}\n+fn arg_item(&_x: &StrBuf) {}\n     //~^ ERROR cannot move out of dereference of `&`-pointer\n \n fn arg_closure() {"}, {"sha": "1de48b61920974c8a94b78915067edbc166de577", "filename": "src/test/compile-fail/borrowck-move-out-of-struct-with-dtor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,20 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S {f:~str}\n+struct S {f:StrBuf}\n impl Drop for S {\n     fn drop(&mut self) { println!(\"{}\", self.f); }\n }\n \n fn move_in_match() {\n-    match S {f:\"foo\".to_owned()} {\n+    match S {f:\"foo\".to_strbuf()} {\n         S {f:_s} => {}\n         //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n     }\n }\n \n fn move_in_let() {\n-    let S {f:_s} = S {f:\"foo\".to_owned()};\n+    let S {f:_s} = S {f:\"foo\".to_strbuf()};\n     //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n }\n "}, {"sha": "0b7939f18980c697c4a2ca7516972dbe5b1f959a", "filename": "src/test/compile-fail/borrowck-move-out-of-tuple-struct-with-dtor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,20 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S(~str);\n+struct S(StrBuf);\n impl Drop for S {\n     fn drop(&mut self) { }\n }\n \n fn move_in_match() {\n-    match S(\"foo\".to_owned()) {\n+    match S(\"foo\".to_strbuf()) {\n         S(_s) => {}\n         //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n     }\n }\n \n fn move_in_let() {\n-    let S(_s) = S(\"foo\".to_owned());\n+    let S(_s) = S(\"foo\".to_strbuf());\n     //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n }\n "}, {"sha": "a30d8d44ca072b051e3e96655e0e07fabcb1fd01", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,14 +12,14 @@\n \n #[deriving(Clone)]\n struct Foo {\n-    string: ~str\n+    string: StrBuf\n }\n \n pub fn main() {\n     let x = vec!(\n-        Foo { string: \"foo\".to_owned() },\n-        Foo { string: \"bar\".to_owned() },\n-        Foo { string: \"baz\".to_owned() }\n+        Foo { string: \"foo\".to_strbuf() },\n+        Foo { string: \"bar\".to_strbuf() },\n+        Foo { string: \"baz\".to_strbuf() }\n     );\n     let x: &[Foo] = x.as_slice();\n     match x {"}, {"sha": "5a5b63ba8466cb7663e8a21025c5399c7af8e2bc", "filename": "src/test/compile-fail/break-outside-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo {\n-    t: ~str\n+    t: StrBuf\n }\n \n fn cond() -> bool { true }"}, {"sha": "12d9e1610a535c5a1eba0667024f4cb6039d7017", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,17 +10,17 @@\n \n enum E {\n     Foo,\n-    Bar(~str)\n+    Bar(StrBuf)\n }\n \n struct S {\n     x: E\n }\n \n-fn f(x: ~str) {}\n+fn f(x: StrBuf) {}\n \n fn main() {\n-    let s = S { x: Bar(\"hello\".to_owned()) };\n+    let s = S { x: Bar(\"hello\".to_strbuf()) };\n     match &s.x {\n         &Foo => {}\n         &Bar(identifier) => f(identifier.clone())  //~ ERROR cannot move"}, {"sha": "06317f06f262db269488acc315dc61192556d0e0", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -27,7 +27,7 @@ enum SafeEnum {\n     Variant1,\n     Variant2(int),\n     Variant3(WithDtor),\n-    Variant4(~str)\n+    Variant4(StrBuf)\n }\n \n // These should be ok\n@@ -106,8 +106,11 @@ static mut STATIC12: UnsafeStruct = UnsafeStruct;\n static mut STATIC13: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(WithDtor)};\n //~^ ERROR mutable static items are not allowed to have destructors\n \n-static mut STATIC14: SafeStruct = SafeStruct{field1: Variant1, field2: Variant4(\"str\".to_owned())};\n+static mut STATIC14: SafeStruct = SafeStruct {\n //~^ ERROR mutable static items are not allowed to have destructors\n+    field1: Variant1,\n+    field2: Variant4(\"str\".to_strbuf())\n+};\n \n static STATIC15: &'static [Box<MyOwned>] = &'static [box MyOwned, box MyOwned];\n //~^ ERROR static items are not allowed to have owned pointers"}, {"sha": "bc9f3247db70670d9cf151b36a1d8606c22fb2fa", "filename": "src/test/compile-fail/circular_modules_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,7 +11,7 @@\n \n mod circular_modules_hello; //~ERROR: circular modules\n \n-pub fn hi_str() -> ~str {\n+pub fn hi_str() -> StrBuf {\n   \"Hi!\".to_owned()\n }\n "}, {"sha": "b28d9dabbb93bdccd073ebaab99457f756de1ff3", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -17,7 +17,7 @@ struct cat {\n   meows : uint,\n \n   how_hungry : int,\n-  name : ~str,\n+  name : StrBuf,\n }\n \n impl cat {\n@@ -49,7 +49,7 @@ impl cat {\n     }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n@@ -58,6 +58,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n fn main() {\n-  let nyan: Box<noisy> = box cat(0, 2, \"nyan\".to_owned()) as Box<noisy>;\n+  let nyan: Box<noisy> = box cat(0, 2, \"nyan\".to_strbuf()) as Box<noisy>;\n   nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n }"}, {"sha": "acf825f8913f6fdaf01d822d42ff4c2e765fb211", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-let.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct X {\n-    x: ~str,\n+    x: StrBuf,\n }\n \n impl Drop for X {\n@@ -18,13 +18,13 @@ impl Drop for X {\n     }\n }\n \n-fn unwrap(x: X) -> ~str {\n+fn unwrap(x: X) -> StrBuf {\n     let X { x: y } = x; //~ ERROR cannot move out of type\n     y\n }\n \n fn main() {\n-    let x = X { x: \"hello\".to_owned() };\n+    let x = X { x: \"hello\".to_strbuf() };\n     let y = unwrap(x);\n     println!(\"contents: {}\", y);\n }"}, {"sha": "80e624afdb876a35628d49482ff5716b0c12f379", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct X {\n-    x: ~str,\n+    x: StrBuf,\n }\n \n impl Drop for X {\n@@ -19,7 +19,7 @@ impl Drop for X {\n }\n \n fn main() {\n-    let x = X { x: \"hello\".to_owned() };\n+    let x = X { x: \"hello\".to_strbuf() };\n \n     match x {\n         X { x: y } => println!(\"contents: {}\", y)"}, {"sha": "b2ac06127847c79b0d637ef28a9deebdf04966e0", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn wants_uniq(x: ~str) { }\n+fn wants_uniq(x: StrBuf) { }\n fn wants_slice(x: &str) { }\n \n-fn has_uniq(x: ~str) {\n+fn has_uniq(x: StrBuf) {\n    wants_uniq(x);\n-   wants_slice(x);\n+   wants_slice(x.as_slice());\n }\n \n fn has_slice(x: &str) {\n-   wants_uniq(x); //~ ERROR mismatched types: expected `~str` but found `&str` (expected box but f\n+   wants_uniq(x); //~ ERROR mismatched types\n    wants_slice(x);\n }\n "}, {"sha": "39b6a276e7075d684522056f729a3ea3e52a8755", "filename": "src/test/compile-fail/generic-type-params-name-repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -28,10 +28,10 @@ fn main() {\n     //~^ ERROR mismatched types: expected `Foo<int>` but found `()`\n \n     // Including cases where the default is using previous type params.\n-    let _: HashMap<~str, int> = ();\n-    //~^ ERROR mismatched types: expected `HashMap<~str,int>` but found `()`\n-    let _: HashMap<~str, int, Hash<~str>> = ();\n-    //~^ ERROR mismatched types: expected `HashMap<~str,int>` but found `()`\n+    let _: HashMap<StrBuf, int> = ();\n+    //~^ ERROR mismatched types: expected `HashMap<std::strbuf::StrBuf,int>` but found `()`\n+    let _: HashMap<StrBuf, int, Hash<StrBuf>> = ();\n+    //~^ ERROR mismatched types: expected `HashMap<std::strbuf::StrBuf,int>` but found `()`\n \n     // But not when there's a different type in between.\n     let _: Foo<A, int, C> = ();"}, {"sha": "654443bde24c96e273bf8599282f33ce8b8e21e9", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -16,4 +16,4 @@ use zed::baz;\n mod zed {\n     pub fn bar() { println!(\"bar\"); }\n }\n-fn main(args: Vec<~str>) { bar(); }\n+fn main(args: Vec<StrBuf>) { bar(); }"}, {"sha": "11e757803065bf9f26115ce9617d21b830d9ff67", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -16,4 +16,4 @@ mod baz {}\n mod zed {\n     pub fn bar() { println!(\"bar3\"); }\n }\n-fn main(args: Vec<~str>) { bar(); }\n+fn main(args: Vec<StrBuf>) { bar(); }"}, {"sha": "d41573b85575ae262fdc5f82573417baaff01c68", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,17 +10,17 @@\n \n pub fn main() {\n     let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n-    let s: ~str = \"abcdef\".to_owned();\n+    let s: StrBuf = \"abcdef\".to_strbuf();\n     assert_eq!(v.as_slice()[3u], 3);\n     assert_eq!(v.as_slice()[3u8], 3); //~ ERROR: mismatched types\n     assert_eq!(v.as_slice()[3i8], 3); //~ ERROR: mismatched types\n     assert_eq!(v.as_slice()[3u32], 3); //~ ERROR: mismatched types\n     assert_eq!(v.as_slice()[3i32], 3); //~ ERROR: mismatched types\n     println!(\"{}\", v.as_slice()[3u8]); //~ ERROR: mismatched types\n-    assert_eq!(s[3u], 'd' as u8);\n-    assert_eq!(s[3u8], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s[3i8], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s[3u32], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s[3i32], 'd' as u8); //~ ERROR: mismatched types\n-    println!(\"{}\", s[3u8]); //~ ERROR: mismatched types\n+    assert_eq!(s.as_slice()[3u], 'd' as u8);\n+    assert_eq!(s.as_slice()[3u8], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s.as_slice()[3i8], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s.as_slice()[3u32], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s.as_slice()[3i32], 'd' as u8); //~ ERROR: mismatched types\n+    println!(\"{}\", s.as_slice()[3u8]); //~ ERROR: mismatched types\n }"}, {"sha": "ab763a2b583caf63ee85fa3969cb611bdd4eb07e", "filename": "src/test/compile-fail/issue-13428.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,16 +10,16 @@\n \n // Regression test for #13428\n \n-fn foo() -> ~str {  //~ ERROR not all control paths return a value\n-    format!(\"Hello {}\",\n-            \"world\")\n+fn foo() -> StrBuf {  //~ ERROR not all control paths return a value\n+    format_strbuf!(\"Hello {}\",\n+                   \"world\")\n     // Put the trailing semicolon on its own line to test that the\n     // note message gets the offending semicolon exactly\n     ;   //~ NOTE consider removing this semicolon\n }\n \n-fn bar() -> ~str {  //~ ERROR not all control paths return a value\n-    \"foobar\".to_owned()\n+fn bar() -> StrBuf {  //~ ERROR not all control paths return a value\n+    \"foobar\".to_strbuf()\n     ;   //~ NOTE consider removing this semicolon\n }\n "}, {"sha": "fcbe8f7b56362a1c8e89cef4069b180573e92d3e", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -16,14 +16,14 @@\n struct t(Box<t>); //~ ERROR this type cannot be instantiated\n \n trait to_str_2 {\n-    fn my_to_str() -> ~str;\n+    fn my_to_str() -> StrBuf;\n }\n \n // I use an impl here because it will cause\n // the compiler to attempt autoderef and then\n // try to resolve the method.\n impl to_str_2 for t {\n-    fn my_to_str() -> ~str { \"t\".to_owned() }\n+    fn my_to_str() -> StrBuf { \"t\".to_strbuf() }\n }\n \n fn new_t(x: t) {"}, {"sha": "365ee54645f2032cdea4709d4dfcc4279d5251a7", "filename": "src/test/compile-fail/issue-3099.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn a(x: ~str) -> ~str {\n+fn a(x: StrBuf) -> StrBuf {\n     format!(\"First function with {}\", x)\n }\n \n-fn a(x: ~str, y: ~str) -> ~str { //~ ERROR duplicate definition of value `a`\n+fn a(x: StrBuf, y: StrBuf) -> StrBuf { //~ ERROR duplicate definition of value `a`\n     format!(\"Second function with {} and {}\", x, y)\n }\n "}, {"sha": "15bcc53b8cec4a6bc72f5bafe7f9bb7b5331d582", "filename": "src/test/compile-fail/issue-3601.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,7 +10,7 @@\n \n \n struct HTMLImageData {\n-    image: Option<~str>\n+    image: Option<StrBuf>\n }\n \n struct ElementData {"}, {"sha": "fdf9a39696352f758f5d470e12bfd9e6d0ae09dc", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -22,7 +22,7 @@ impl ToStr for Point { //~ ERROR implements a method not defined in the trait\n         Point { x: x, y: y }\n     }\n \n-    fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> StrBuf {\n         format!(\"({}, {})\", self.x, self.y)\n     }\n }"}, {"sha": "ebc82ab361d54b25998820b5242d63d714c6c476", "filename": "src/test/compile-fail/issue-5543.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@\n use std::io::ReaderUtil;\n use std::io::Reader;\n \n-fn bar(r:@ReaderUtil) -> ~str { r.read_line() }\n+fn bar(r:@ReaderUtil) -> StrBuf { r.read_line() }\n \n fn main() {\n     let r : @Reader = io::stdin();"}, {"sha": "b12d2be612ec5beed6040bdc40626a12fe3c5104", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(b: bool) -> Result<bool,~str> {\n+fn foo(b: bool) -> Result<bool,StrBuf> {\n     Err(\"bar\".to_owned());\n     //~^ ERROR: cannot determine a type for this expression: unconstrained type\n }"}, {"sha": "d79bc942118d54ce2827c694b6b549aee5a823d8", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,15 +10,15 @@\n \n \n pub struct CrateId {\n-    local_path: ~str,\n-    junk: ~str\n+    local_path: StrBuf,\n+    junk: StrBuf\n }\n \n impl CrateId {\n     fn new(s: &str) -> CrateId {\n         CrateId {\n-            local_path: s.to_owned(),\n-            junk: \"wutevs\".to_owned()\n+            local_path: s.to_strbuf(),\n+            junk: \"wutevs\".to_strbuf()\n         }\n     }\n }"}, {"sha": "f23e398596f009f6ebfdbeb642c157102e20210c", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -51,7 +51,7 @@ trait ManyImplTrait {\n     }\n }\n \n-impl ManyImplTrait for ~str {\n+impl ManyImplTrait for StrBuf {\n     fn is_str() -> bool {\n         true\n     }"}, {"sha": "c5c14005c70a6ca36f7371e10b689ccef942447d", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -39,7 +39,7 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n \n     // ~ pointers are not ok\n     assert_copy::<Box<int>>();   //~ ERROR does not fulfill\n-    assert_copy::<~str>();   //~ ERROR does not fulfill\n+    assert_copy::<StrBuf>();   //~ ERROR does not fulfill\n     assert_copy::<Vec<int> >(); //~ ERROR does not fulfill\n     assert_copy::<Box<&'a mut int>>(); //~ ERROR does not fulfill\n "}, {"sha": "c2c35e05edea4d7faf85f77d40a1ba1d35db9591", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -30,7 +30,7 @@ fn test<'a,T,U:Send>(_: &'a int) {\n \n     // boxes are ok\n     assert_send::<Box<int>>();\n-    assert_send::<~str>();\n+    assert_send::<StrBuf>();\n     assert_send::<Vec<int> >();\n \n     // but not if they own a bad thing"}, {"sha": "c33719a2fc19bc594714648783d7b8672c64b96d", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -51,7 +51,7 @@ fn good2() {\n        sure that when purity is inherited that the source of the unsafe-ness\n        is tracked correctly */\n     unsafe {\n-        unsafe fn what() -> Vec<~str> { fail!() }\n+        unsafe fn what() -> Vec<StrBuf> { fail!() }\n \n         callback(|| {\n             what();"}, {"sha": "fe64551a4b537b8b3a0344aab5d095f8aa7b726c", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,36 +12,36 @@\n // of the various arms, particularly in the case where regions are\n // involved.\n \n-pub fn opt_str0<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+pub fn opt_str0<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     if maybestr.is_none() {\n         \"(none)\"\n     } else {\n-        let s: &'a str = *maybestr.get_ref();\n+        let s: &'a str = maybestr.get_ref().as_slice();\n         s\n     }\n }\n \n-pub fn opt_str1<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+pub fn opt_str1<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     if maybestr.is_some() {\n-        let s: &'a str = *maybestr.get_ref();\n+        let s: &'a str = maybestr.get_ref().as_slice();\n         s\n     } else {\n         \"(none)\"\n     }\n }\n \n-pub fn opt_str2<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+pub fn opt_str2<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n     if maybestr.is_none() { //~ ERROR mismatched types\n         \"(none)\"\n     } else {\n-        let s: &'a str = *maybestr.get_ref();\n+        let s: &'a str = maybestr.get_ref().as_slice();\n         s\n     }\n }\n \n-pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+pub fn opt_str3<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n     if maybestr.is_some() {  //~ ERROR mismatched types\n-        let s: &'a str = *maybestr.get_ref();\n+        let s: &'a str = maybestr.get_ref().as_slice();\n         s\n     } else {\n         \"(none)\""}, {"sha": "932107b78781406d7290420769bea439eea0b0a2", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,40 +12,40 @@\n // of the various arms, particularly in the case where regions are\n // involved.\n \n-pub fn opt_str0<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+pub fn opt_str0<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     match *maybestr {\n         Some(ref s) => {\n-            let s: &'a str = *s;\n+            let s: &'a str = s.as_slice();\n             s\n         }\n         None => \"(none)\",\n     }\n }\n \n-pub fn opt_str1<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+pub fn opt_str1<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     match *maybestr {\n         None => \"(none)\",\n         Some(ref s) => {\n-            let s: &'a str = *s;\n+            let s: &'a str = s.as_slice();\n             s\n         }\n     }\n }\n \n-pub fn opt_str2<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+pub fn opt_str2<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n     match *maybestr { //~ ERROR mismatched types\n         None => \"(none)\",\n         Some(ref s) => {\n-            let s: &'a str = *s;\n+            let s: &'a str = s.as_slice();\n             s\n         }\n     }\n }\n \n-pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+pub fn opt_str3<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n     match *maybestr { //~ ERROR mismatched types\n         Some(ref s) => {\n-            let s: &'a str = *s;\n+            let s: &'a str = s.as_slice();\n             s\n         }\n         None => \"(none)\","}, {"sha": "aa8cb84481f1e887d62ce04eb2d1f9fd456098ef", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,9 +15,9 @@ use collections::HashMap;\n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: Box<HashMap<~str, ~str>> = box HashMap::new();\n-    let x: Box<Map<~str, ~str>> = x;\n-    let y: Box<Map<uint, ~str>> = box x;\n-    //~^ ERROR failed to find an implementation of trait core::container::Map<uint,~str>\n-    //         for ~core::container::Map<~str,~str>:Send\n+    let x: Box<HashMap<int, int>> = box HashMap::new();\n+    let x: Box<Map<int, int>> = x;\n+    let y: Box<Map<uint, int>> = box x;\n+    //~^ ERROR failed to find an implementation of trait core::container::Map<uint,int>\n+    //         for ~core::container::Map<int,int>:Send\n }"}, {"sha": "56d3d76bf7c17338083ec6763d3f3f89fda0f4fc", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    match \"foo\".to_owned() {\n-        ['f', 'o', ..] => { } //~ ERROR mismatched types: expected `~str` but found a vector pattern\n+    match \"foo\".to_strbuf() {\n+        ['f', 'o', ..] => {} //~ ERROR mismatched types\n         _ => { }\n     }\n }"}, {"sha": "128c25889d87b578a043233868052595779b3eac", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -18,8 +18,10 @@ fn main() {\n         _ => ()\n     }\n \n-    let x: Vec<~str> = vec!(\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned());\n-    let x: &[~str] = x.as_slice();\n+    let x: Vec<StrBuf> = vec![\"foo\".to_strbuf(),\n+                              \"bar\".to_strbuf(),\n+                              \"baz\".to_strbuf()];\n+    let x: &[StrBuf] = x.as_slice();\n     match x {\n         [a, _, _, ..] => { println!(\"{}\", a); }\n         [_, _, _, _, _] => { } //~ ERROR unreachable pattern"}, {"sha": "b194b2d833164f2cd55778bbf2b2b8b2db056228", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:cannot apply unary operator `-` to type `~str`\n+// error-pattern:cannot apply unary operator `-` to type `std::strbuf::StrBuf`\n \n-fn main() { -\"foo\".to_owned(); }\n+fn main() { -\"foo\".to_strbuf(); }"}, {"sha": "fcad6469bccf6092d60557cac269f2bf0ca5dcdb", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,18 +11,18 @@\n // Tests that if you move from `x.f` or `x[0]`, `x` is inaccessible.\n // Also tests that we give a more specific error message.\n \n-struct Foo { f: ~str, y: int }\n-fn consume(_s: ~str) {}\n+struct Foo { f: StrBuf, y: int }\n+fn consume(_s: StrBuf) {}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = Foo { f: \"hi\".to_owned(), y: 3 };\n+    let x = Foo { f: \"hi\".to_strbuf(), y: 3 };\n     consume(x.f);\n     touch(&x.y); //~ ERROR use of partially moved value: `x`\n }\n \n fn f20() {\n-    let x = vec!(\"hi\".to_owned());\n+    let x = vec!(\"hi\".to_strbuf());\n     consume(x.move_iter().next().unwrap());\n     touch(x.get(0)); //~ ERROR use of moved value: `x`\n }"}, {"sha": "29b4dc573e3a2b0b99c169895eb0b450c3adbbf4", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,17 +14,17 @@\n #![feature(managed_boxes)]\n \n struct Foo<A> { f: A }\n-fn guard(_s: ~str) -> bool {fail!()}\n+fn guard(_s: StrBuf) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_strbuf();\n     let _y = Foo { f:x };\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f20() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_strbuf();\n     let _y = (x, 3);\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n@@ -36,8 +36,8 @@ fn f21() {\n }\n \n fn f30(cond: bool) {\n-    let x = \"hi\".to_owned();\n-    let y = \"ho\".to_owned();\n+    let x = \"hi\".to_strbuf();\n+    let y = \"ho\".to_strbuf();\n     let _y = if cond {\n         x\n     } else {\n@@ -48,8 +48,8 @@ fn f30(cond: bool) {\n }\n \n fn f40(cond: bool) {\n-    let x = \"hi\".to_owned();\n-    let y = \"ho\".to_owned();\n+    let x = \"hi\".to_strbuf();\n+    let y = \"ho\".to_strbuf();\n     let _y = match cond {\n         true => x,\n         false => y\n@@ -59,8 +59,8 @@ fn f40(cond: bool) {\n }\n \n fn f50(cond: bool) {\n-    let x = \"hi\".to_owned();\n-    let y = \"ho\".to_owned();\n+    let x = \"hi\".to_strbuf();\n+    let y = \"ho\".to_strbuf();\n     let _y = match cond {\n         _ if guard(x) => 10,\n         true => 10,\n@@ -71,31 +71,31 @@ fn f50(cond: bool) {\n }\n \n fn f70() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_strbuf();\n     let _y = [x];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f80() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_strbuf();\n     let _y = vec!(x);\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f100() {\n-    let x = vec!(\"hi\".to_owned());\n+    let x = vec!(\"hi\".to_strbuf());\n     let _y = x.move_iter().next().unwrap();\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f110() {\n-    let x = vec!(\"hi\".to_owned());\n+    let x = vec!(\"hi\".to_strbuf());\n     let _y = [x.move_iter().next().unwrap(), ..1];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f120() {\n-    let mut x = vec!(\"hi\".to_owned(), \"ho\".to_owned());\n+    let mut x = vec!(\"hi\".to_strbuf(), \"ho\".to_strbuf());\n     x.as_mut_slice().swap(0, 1);\n     touch(x.get(0));\n     touch(x.get(1));"}, {"sha": "83b7658a47389420c958b8401f3aac7888547887", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@\n // terms of the binding, not the discriminant.\n \n struct Foo<A> { f: A }\n-fn guard(_s: ~str) -> bool {fail!()}\n+fn guard(_s: StrBuf) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {"}, {"sha": "a0c007a2627e02e676b74fae5ea7d748532ebb32", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,5 +14,5 @@ struct S {\n \n impl Cmp, ToStr for S { //~ ERROR: expected `{` but found `,`\n   fn eq(&&other: S) { false }\n-  fn to_str(&self) -> ~str { \"hi\".to_owned() }\n+  fn to_str(&self) -> StrBuf { \"hi\".to_owned() }\n }"}, {"sha": "a0e3a15dfa5294d8ec01636cd014fec2d2af49fa", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,18 +15,18 @@\n \n struct foo {\n   i: int,\n-  j: @~str,\n+  j: @StrBuf,\n }\n \n-fn foo(i:int, j: @~str) -> foo {\n+fn foo(i:int, j: @StrBuf) -> foo {\n     foo {\n         i: i,\n         j: j\n     }\n }\n \n fn main() {\n-  let cat = \"kitty\".to_owned();\n+  let cat = \"kitty\".to_strbuf();\n   let (tx, _) = channel(); //~ ERROR does not fulfill `Send`\n   tx.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "915ccab7700566b42a8d6fb5e728e9c8fe1ae94a", "filename": "src/test/debuginfo/issue11600.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue11600.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@\n // ignore-test\n \n fn main() {\n-    let args : ~[~str] = ::std::os::args();\n+    let args : ~[StrBuf] = ::std::os::args();\n     ::std::io::println(args[0]);\n }\n \n@@ -25,6 +25,6 @@ fn main() {\n // compile-flags:-g\n // gdb-command:list\n // gdb-check:1[...]fn main() {\n-// gdb-check:2[...]let args : ~[~str] = ::std::os::args();\n+// gdb-check:2[...]let args : ~[StrBuf] = ::std::os::args();\n // gdb-check:3[...]::std::io::println(args[0]);\n // gdb-check:4[...]}"}, {"sha": "d18627c1ba1821f3f020833a2ceb2421fd90d07c", "filename": "src/test/pretty/closure-reform-pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@\n \n // pp-exact\n \n-fn call_it(f: proc(~str) -> ~str) { }\n+fn call_it(f: proc(StrBuf) -> StrBuf) { }\n \n fn call_this(f: |&str|: Send) { }\n "}, {"sha": "680481ad491b90e19d7edcc1531343eda17ac05a", "filename": "src/test/run-fail/binop-fail-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n // error-pattern:quux\n-fn my_err(s: ~str) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { 3u == my_err(\"bye\".to_owned()); }\n+fn my_err(s: StrBuf) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n+fn main() { 3u == my_err(\"bye\".to_strbuf()); }"}, {"sha": "680481ad491b90e19d7edcc1531343eda17ac05a", "filename": "src/test/run-fail/binop-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n // error-pattern:quux\n-fn my_err(s: ~str) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { 3u == my_err(\"bye\".to_owned()); }\n+fn my_err(s: StrBuf) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n+fn main() { 3u == my_err(\"bye\".to_strbuf()); }"}, {"sha": "37955561c08b6b2387157c8c783ab0dfd7efb0a6", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,4 +10,7 @@\n \n // error-pattern:meh\n \n-fn main() { let str_var: ~str = \"meh\".to_owned(); fail!(\"{}\", str_var); }\n+fn main() {\n+    let str_var: StrBuf = \"meh\".to_strbuf();\n+    fail!(\"{}\", str_var);\n+}"}, {"sha": "ef8a38df1781fea88760b97da814321d38b5df22", "filename": "src/test/run-fail/if-cond-bot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n // error-pattern:quux\n-fn my_err(s: ~str) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { if my_err(\"bye\".to_owned()) { } }\n+fn my_err(s: StrBuf) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n+fn main() { if my_err(\"bye\".to_strbuf()) { } }"}, {"sha": "d75466a1738b5230077c74aeaa3b074ae0d708d8", "filename": "src/test/run-fail/match-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@\n #![allow(unreachable_code)]\n #![allow(unused_variable)]\n \n-fn foo(s: ~str) { }\n+fn foo(s: StrBuf) { }\n \n fn main() {\n     let i ="}, {"sha": "613957980de44222ada9b64a0477d6413cdc1ddd", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,5 +13,5 @@\n use std::result;\n \n fn main() {\n-    println!(\"{:?}\", result::Err::<int,~str>(\"kitty\".to_owned()).unwrap());\n+    println!(\"{:?}\", result::Err::<int,StrBuf>(\"kitty\".to_strbuf()).unwrap());\n }"}, {"sha": "d224393b2eaeb1b61605ae09a85bf7976f8d053d", "filename": "src/test/run-fail/rhs-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Frhs-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Frhs-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frhs-type.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,7 +15,7 @@\n #![allow(unreachable_code)]\n #![allow(unused_variable)]\n \n-struct T { t: ~str }\n+struct T { t: StrBuf }\n \n fn main() {\n     let pth = fail!(\"bye\");"}, {"sha": "879a14896d62bdf24ea51eb83ded433e4a48a73d", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,8 +11,8 @@\n \n // error-pattern:index out of bounds: the len is 5 but the index is 5\n fn main() {\n-    let s: ~str = \"hello\".to_owned();\n+    let s: StrBuf = \"hello\".to_strbuf();\n \n     // Bounds-check failure.\n-    assert_eq!(s[5], 0x0 as u8);\n+    assert_eq!(s.as_slice()[5], 0x0 as u8);\n }"}, {"sha": "d3be456f3428df0ca0f1169fe3cb6c4bed751d88", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,17 +13,17 @@\n // error-pattern:fail\n \n fn main() {\n-    let cheese = \"roquefort\".to_owned();\n-    let carrots = @\"crunchy\".to_owned();\n+    let cheese = \"roquefort\".to_strbuf();\n+    let carrots = @\"crunchy\".to_strbuf();\n \n-    let result: |@~str, |~str||: 'static = (|tasties, macerate| {\n+    let result: |@StrBuf, |StrBuf||: 'static = (|tasties, macerate| {\n         macerate((*tasties).clone());\n     });\n     result(carrots, |food| {\n-        let mush = food + cheese;\n+        let mush = format_strbuf!(\"{}{}\", food, cheese);\n         let cheese = cheese.clone();\n         let f: || = || {\n-            let _chew = mush + cheese;\n+            let _chew = format_strbuf!(\"{}{}\", mush, cheese);\n             fail!(\"so yummy\")\n         };\n         f();"}, {"sha": "d56149752155161821870fe6eba580db3339b333", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -48,7 +48,7 @@ fn main() {\n             let _ = write!(&mut File::create(&main_file).unwrap(),\n                            r\"\\#![feature(non_ascii_idents)] fn main() \\{ {} \\}\",\n                            // random string of length n\n-                           range(0, n).map(|_| random_char()).collect::<~str>());\n+                           range(0, n).map(|_| random_char()).collect::<StrBuf>());\n         }\n \n         // rustc is passed to us with --out-dir and -L etc., so we"}, {"sha": "4b8aed0a187383fb6211306305972c8d0046d444", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -75,7 +75,7 @@ fn main() {\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,\n-               expr: T, f: |pprust::ps, T|, expect: ~str) {\n+               expr: T, f: |pprust::ps, T|, expect: StrBuf) {\n     let s = io::with_str_writer(|wr| {\n         let pp = pprust::rust_printer(wr, cx.parse_sess().interner);\n         f(pp, expr);"}, {"sha": "a78622a37a2fd03f110dc9006da783affa89f288", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,10 +14,10 @@\n \n enum sty { ty_nil, }\n \n-struct RawT {struct_: sty, cname: Option<~str>, hash: uint}\n+struct RawT {struct_: sty, cname: Option<StrBuf>, hash: uint}\n \n-fn mk_raw_ty(st: sty, cname: Option<~str>) -> RawT {\n+fn mk_raw_ty(st: sty, cname: Option<StrBuf>) -> RawT {\n     return RawT {struct_: st, cname: cname, hash: 0u};\n }\n \n-pub fn main() { mk_raw_ty(ty_nil, None::<~str>); }\n+pub fn main() { mk_raw_ty(ty_nil, None::<StrBuf>); }"}, {"sha": "445abf4ca4951140de3889fd0c6a21d1a4f72ed5", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,6 +15,7 @@ fn g(act: |Vec<int> | -> int) -> int { return act(vec!(1, 2, 3)); }\n \n pub fn main() {\n     assert_eq!(g(f), 1);\n-    let f1: |Vec<~str> | -> ~str = f;\n-    assert_eq!(f1(vec!(\"x\".to_owned(), \"y\".to_owned(), \"z\".to_owned())), \"x\".to_owned());\n+    let f1: |Vec<StrBuf>| -> StrBuf = f;\n+    assert_eq!(f1(vec![\"x\".to_strbuf(), \"y\".to_strbuf(), \"z\".to_strbuf()]),\n+               \"x\".to_strbuf());\n }"}, {"sha": "778704a4b96e4c3a7d4993cfd66ee4d084128d25", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,22 +11,22 @@\n #![feature(managed_boxes)]\n \n trait Foo {\n-    fn foo(&self) -> ~str;\n+    fn foo(&self) -> StrBuf;\n }\n \n impl<T:Foo> Foo for @T {\n-    fn foo(&self) -> ~str {\n-        format!(\"@{}\", (**self).foo())\n+    fn foo(&self) -> StrBuf {\n+        format_strbuf!(\"@{}\", (**self).foo())\n     }\n }\n \n impl Foo for uint {\n-    fn foo(&self) -> ~str {\n-        format!(\"{}\", *self)\n+    fn foo(&self) -> StrBuf {\n+        format_strbuf!(\"{}\", *self)\n     }\n }\n \n pub fn main() {\n     let x = @3u;\n-    assert_eq!(x.foo(), \"@3\".to_owned());\n+    assert_eq!(x.foo(), \"@3\".to_strbuf());\n }"}, {"sha": "260ce69f821d768847880cc264f7f3d795347e70", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -36,14 +36,21 @@ fn double() {\n }\n \n fn runtest(me: &str) {\n-    let mut env = os::env().move_iter().collect::<Vec<(~str, ~str)>>();\n-    match env.iter().position(|&(ref s, _)| \"RUST_BACKTRACE\" == *s) {\n+    let mut env = os::env().move_iter()\n+                           .map(|(ref k, ref v)| {\n+                               (k.to_strbuf(), v.to_strbuf())\n+                           }).collect::<Vec<(StrBuf,StrBuf)>>();\n+    match env.iter()\n+             .position(|&(ref s, _)| \"RUST_BACKTRACE\" == s.as_slice()) {\n         Some(i) => { env.remove(i); }\n         None => {}\n     }\n-    env.push((\"RUST_BACKTRACE\".to_owned(), \"1\".to_owned()));\n+    env.push((\"RUST_BACKTRACE\".to_strbuf(), \"1\".to_strbuf()));\n \n     // Make sure that the stack trace is printed\n+    let env = env.iter()\n+                 .map(|&(ref k, ref v)| (k.to_owned(), v.to_owned()))\n+                 .collect::<Vec<_>>();\n     let mut p = Process::configure(ProcessConfig {\n         program: me,\n         args: [\"fail\".to_owned()],"}, {"sha": "f60510dc802f3a6e921ed3482b09d563d5d6cb78", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub fn main() {\n-    fn as_buf<T>(s: ~str, f: |~str| -> T) -> T { f(s) }\n-    as_buf(\"foo\".to_owned(), |foo: ~str| -> () println!(\"{}\", foo) );\n+    fn as_buf<T>(s: StrBuf, f: |StrBuf| -> T) -> T { f(s) }\n+    as_buf(\"foo\".to_strbuf(), |foo: StrBuf| -> () println!(\"{}\", foo) );\n }"}, {"sha": "c80246d27e68166162f025987f20d06035e6d5de", "filename": "src/test/run-pass/borrowed-ptr-pattern-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(s: &~str) -> bool {\n+fn foo(s: &StrBuf) -> bool {\n     match s.as_slice() {\n         \"kitty\" => true,\n         _ => false\n     }\n }\n \n pub fn main() {\n-    assert!(foo(&\"kitty\".to_owned()));\n-    assert!(!foo(&\"gata\".to_owned()));\n+    assert!(foo(&\"kitty\".to_strbuf()));\n+    assert!(!foo(&\"gata\".to_strbuf()));\n }"}, {"sha": "5f536026ea62fcee3ad80b35d3a7a3c1d956e87e", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,35 +9,36 @@\n // except according to those terms.\n \n trait Speak {\n-    fn say(&self, s:&str) -> ~str;\n-    fn hi(&self) -> ~str { hello(self) }\n+    fn say(&self, s:&str) -> StrBuf;\n+    fn hi(&self) -> StrBuf { hello(self) }\n }\n \n-fn hello<S:Speak>(s:&S) -> ~str{\n+fn hello<S:Speak>(s:&S) -> StrBuf{\n     s.say(\"hello\")\n }\n \n impl Speak for int {\n-    fn say(&self, s:&str) -> ~str {\n-        format!(\"{}: {}\", s, *self)\n+    fn say(&self, s:&str) -> StrBuf {\n+        format_strbuf!(\"{}: {}\", s, *self)\n     }\n }\n \n impl<T: Speak> Speak for Option<T> {\n-    fn say(&self, s:&str) -> ~str {\n+    fn say(&self, s:&str) -> StrBuf {\n         match *self {\n-            None => format!(\"{} - none\", s),\n-            Some(ref x) => { \"something!\".to_owned() + x.say(s) }\n+            None => format_strbuf!(\"{} - none\", s),\n+            Some(ref x) => { format_strbuf!(\"something!{}\", x.say(s)) }\n         }\n     }\n }\n \n \n pub fn main() {\n-    assert_eq!(3.hi(), \"hello: 3\".to_owned());\n-    assert_eq!(Some(Some(3)).hi(), \"something!something!hello: 3\".to_owned());\n-    assert_eq!(None::<int>.hi(), \"hello - none\".to_owned());\n+    assert_eq!(3.hi(), \"hello: 3\".to_strbuf());\n+    assert_eq!(Some(Some(3)).hi(),\n+               \"something!something!hello: 3\".to_strbuf());\n+    assert_eq!(None::<int>.hi(), \"hello - none\".to_strbuf());\n \n-    assert_eq!(Some(None::<int>).hi(), \"something!hello - none\".to_owned());\n-    assert_eq!(Some(3).hi(), \"something!hello: 3\".to_owned());\n+    assert_eq!(Some(None::<int>).hi(), \"something!hello - none\".to_strbuf());\n+    assert_eq!(Some(3).hi(), \"something!hello: 3\".to_strbuf());\n }"}, {"sha": "501d36886a4851d9ea2925e5fe05763373ccb92b", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -21,15 +21,16 @@ mod mlibc {\n     }\n }\n \n-fn atol(s: ~str) -> int {\n-    s.with_c_str(|x| unsafe { mlibc::atol(x) as int })\n+fn atol(s: StrBuf) -> int {\n+    s.as_slice().with_c_str(|x| unsafe { mlibc::atol(x) as int })\n }\n \n-fn atoll(s: ~str) -> i64 {\n-    s.with_c_str(|x| unsafe { mlibc::atoll(x) as i64 })\n+fn atoll(s: StrBuf) -> i64 {\n+    s.as_slice().with_c_str(|x| unsafe { mlibc::atoll(x) as i64 })\n }\n \n pub fn main() {\n-    assert_eq!(atol(\"1024\".to_owned()) * 10, atol(\"10240\".to_owned()));\n-    assert!((atoll(\"11111111111111111\".to_owned()) * 10) == atoll(\"111111111111111110\".to_owned()));\n+    assert_eq!(atol(\"1024\".to_strbuf()) * 10, atol(\"10240\".to_strbuf()));\n+    assert!((atoll(\"11111111111111111\".to_strbuf()) * 10) ==\n+             atoll(\"111111111111111110\".to_strbuf()));\n }"}, {"sha": "c85b4b06387b3a61adb442138fb1889a04886a04", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,8 +12,8 @@\n \n use std::task;\n \n-fn child2(_s: ~str) { }\n+fn child2(_s: StrBuf) { }\n \n pub fn main() {\n-    let _x = task::spawn(proc() child2(\"hi\".to_owned()));\n+    let _x = task::spawn(proc() child2(\"hi\".to_strbuf()));\n }"}, {"sha": "55cf41d73d5915b5f5c62d1177953374f9e3c8ad", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,7 +11,7 @@\n // pp-exact - Make sure we actually print the attributes\n \n struct cat {\n-    name: ~str,\n+    name: StrBuf,\n }\n \n impl Drop for cat {\n@@ -21,6 +21,6 @@ impl Drop for cat {\n \n \n #[cat_maker]\n-fn cat(name: ~str) -> cat { cat{name: name,} }\n+fn cat(name: StrBuf) -> cat { cat{name: name,} }\n \n-pub fn main() { let _kitty = cat(\"Spotty\".to_owned()); }\n+pub fn main() { let _kitty = cat(\"Spotty\".to_strbuf()); }"}, {"sha": "b1ed70278ef32702f10c61de291edea44f738a54", "filename": "src/test/run-pass/class-attributes-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct cat {\n-  name: ~str,\n+  name: StrBuf,\n }\n \n impl Drop for cat {\n@@ -26,12 +26,12 @@ impl Drop for cat {\n /**\n Maybe it should technically be a kitten_maker.\n */\n-fn cat(name: ~str) -> cat {\n+fn cat(name: StrBuf) -> cat {\n     cat {\n         name: name\n     }\n }\n \n pub fn main() {\n-  let _kitty = cat(\"Spotty\".to_owned());\n+  let _kitty = cat(\"Spotty\".to_strbuf());\n }"}, {"sha": "df9b30697d9437f18ae88529c1b5b542521fa354", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,13 +14,13 @@ extern crate cci_class_cast;\n use std::to_str::ToStr;\n use cci_class_cast::kitty::cat;\n \n-fn print_out(thing: Box<ToStr>, expected: ~str) {\n+fn print_out(thing: Box<ToStr>, expected: StrBuf) {\n   let actual = thing.to_str();\n   println!(\"{}\", actual);\n-  assert_eq!(actual, expected);\n+  assert_eq!(actual.to_strbuf(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_owned()) as Box<ToStr>;\n-  print_out(nyan, \"nyan\".to_owned());\n+  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_strbuf()) as Box<ToStr>;\n+  print_out(nyan, \"nyan\".to_strbuf());\n }"}, {"sha": "486a505350b8b220f4adf136bfd30a9fec672641", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -53,7 +53,7 @@ struct cat {\n   meows: uint,\n \n   how_hungry: int,\n-  name: ~str,\n+  name: StrBuf,\n }\n \n impl noisy for cat {\n@@ -79,7 +79,7 @@ impl cat {\n     }\n }\n \n-fn cat(in_x: uint, in_y: int, in_name: ~str) -> cat {\n+fn cat(in_x: uint, in_y: int, in_name: StrBuf) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n@@ -93,7 +93,7 @@ fn annoy_neighbors(critter: &mut noisy) {\n }\n \n pub fn main() {\n-  let mut nyan: cat = cat(0u, 2, \"nyan\".to_owned());\n+  let mut nyan: cat = cat(0u, 2, \"nyan\".to_strbuf());\n   let mut whitefang: dog = dog();\n   annoy_neighbors(&mut nyan);\n   annoy_neighbors(&mut whitefang);"}, {"sha": "99070b97372596a7a5a3e8dd9887be8de447be42", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -19,7 +19,7 @@ trait noisy {\n struct cat {\n   meows: uint,\n   how_hungry: int,\n-  name: ~str,\n+  name: StrBuf,\n }\n \n impl noisy for cat {\n@@ -50,7 +50,7 @@ impl cat {\n     }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n@@ -60,7 +60,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n+    let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n     let mut nyan: &mut noisy = &mut nyan;\n     nyan.speak();\n }"}, {"sha": "a7039ca708d9669a6baafb8ea6cfa1015aabbbf4", "filename": "src/test/run-pass/class-exports.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-exports.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -17,14 +17,14 @@ use kitty::cat;\n mod kitty {\n     pub struct cat {\n         meows: uint,\n-        name: ~str,\n+        name: StrBuf,\n     }\n \n     impl cat {\n-        pub fn get_name(&self) -> ~str { self.name.clone() }\n+        pub fn get_name(&self) -> StrBuf { self.name.clone() }\n     }\n \n-    pub fn cat(in_name: ~str) -> cat {\n+    pub fn cat(in_name: StrBuf) -> cat {\n         cat {\n             name: in_name,\n             meows: 0u\n@@ -33,5 +33,6 @@ mod kitty {\n }\n \n pub fn main() {\n-  assert_eq!(cat(\"Spreckles\".to_owned()).get_name(), \"Spreckles\".to_owned());\n+  assert_eq!(cat(\"Spreckles\".to_strbuf()).get_name(),\n+                 \"Spreckles\".to_strbuf());\n }"}, {"sha": "f02d41df21e4ba60680c4e274450cdaf3b7ebffa", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -114,9 +114,9 @@ impl<T> cat<T> {\n }\n \n pub fn main() {\n-    let mut nyan: cat<~str> = cat::new(0, 2, \"nyan\".to_owned());\n+    let mut nyan: cat<StrBuf> = cat::new(0, 2, \"nyan\".to_strbuf());\n     for _ in range(1u, 5) { nyan.speak(); }\n-    assert!(*nyan.find(&1).unwrap() == \"nyan\".to_owned());\n+    assert!(*nyan.find(&1).unwrap() == \"nyan\".to_strbuf());\n     assert_eq!(nyan.find(&10), None);\n     let mut spotty: cat<cat_type> = cat::new(2, 57, tuxedo);\n     for _ in range(0u, 6) { spotty.speak(); }"}, {"sha": "e3a1829597ea4f3fc519bcad96740c7e8af4a786", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -16,7 +16,7 @@ struct cat {\n   meows: uint,\n \n   how_hungry : int,\n-  name : ~str,\n+  name : StrBuf,\n }\n \n impl cat {\n@@ -47,7 +47,7 @@ impl cat {\n     }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n@@ -57,7 +57,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-  let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n+  let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n   nyan.eat();\n   assert!((!nyan.eat()));\n   for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "92dc231bf7a5242da3da5b67748dca90cb658fdd", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -18,7 +18,7 @@ struct cat {\n     meows : uint,\n \n     how_hungry : int,\n-    name : ~str,\n+    name : StrBuf,\n }\n \n impl cat {\n@@ -48,7 +48,7 @@ impl noisy for cat {\n     fn speak(&mut self) { self.meow(); }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n@@ -62,7 +62,7 @@ fn make_speak<C:noisy>(mut c: C) {\n }\n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n+    let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n     nyan.eat();\n     assert!((!nyan.eat()));\n     for _ in range(1u, 10u) {"}, {"sha": "874cf1233b8bb61ad5a74f8327a4f08f9e4d0f9e", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,7 +14,7 @@ struct cat {\n     meows : uint,\n \n     how_hungry : int,\n-    name : ~str,\n+    name : StrBuf,\n }\n \n impl cat {\n@@ -43,7 +43,7 @@ impl cat {\n     }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n@@ -57,13 +57,13 @@ impl fmt::Show for cat {\n     }\n }\n \n-fn print_out(thing: Box<ToStr>, expected: ~str) {\n+fn print_out(thing: Box<ToStr>, expected: StrBuf) {\n   let actual = thing.to_str();\n   println!(\"{}\", actual);\n-  assert_eq!(actual, expected);\n+  assert_eq!(actual.to_strbuf(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_owned()) as Box<ToStr>;\n-  print_out(nyan, \"nyan\".to_owned());\n+  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_strbuf()) as Box<ToStr>;\n+  print_out(nyan, \"nyan\".to_strbuf());\n }"}, {"sha": "438020bab297bdad439a7dc80ff44ee72bb7783e", "filename": "src/test/run-pass/class-str-field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-str-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclass-str-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-str-field.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,16 +10,16 @@\n \n struct cat {\n \n-  name : ~str,\n+  name : StrBuf,\n \n }\n \n-fn cat(in_name: ~str) -> cat {\n+fn cat(in_name: StrBuf) -> cat {\n     cat {\n         name: in_name\n     }\n }\n \n pub fn main() {\n-  let _nyan = cat(\"nyan\".to_owned());\n+  let _nyan = cat(\"nyan\".to_strbuf());\n }"}, {"sha": "554fb607b15f3cc6bf2eac3a6ac95154882e6b7d", "filename": "src/test/run-pass/classes-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@ extern crate cci_class_4;\n use cci_class_4::kitties::cat;\n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n+    let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n     nyan.eat();\n     assert!((!nyan.eat()));\n     for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "33360df56e94ad8ee1998b55dbd79a4ea6421b1a", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,7 +12,7 @@ struct cat {\n     meows : uint,\n \n     how_hungry : int,\n-    name : ~str,\n+    name : StrBuf,\n }\n \n impl cat {\n@@ -40,7 +40,7 @@ impl cat {\n     }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n@@ -49,7 +49,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n pub fn main() {\n-  let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n+  let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n   nyan.eat();\n   assert!((!nyan.eat()));\n   for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "47ca20b6ee82404dd34c11d7ef7f2ea0ff16dd25", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,8 +14,8 @@\n use std::mem;\n use std::io::stdio::println;\n \n-fn call_it(f: proc(~str) -> ~str) {\n-    println!(\"{}\", f(\"Fred\".to_owned()))\n+fn call_it(f: proc(StrBuf) -> StrBuf) {\n+    println!(\"{}\", f(\"Fred\".to_strbuf()))\n }\n \n fn call_a_thunk(f: ||) {\n@@ -48,17 +48,17 @@ fn call_bare_again(f: extern \"Rust\" fn(&str)) {\n pub fn main() {\n     // Procs\n \n-    let greeting = \"Hello \".to_owned();\n+    let greeting = \"Hello \".to_strbuf();\n     call_it(proc(s) {\n-        greeting + s\n+        format_strbuf!(\"{}{}\", greeting, s)\n     });\n \n-    let greeting = \"Goodbye \".to_owned();\n-    call_it(proc(s) greeting + s);\n+    let greeting = \"Goodbye \".to_strbuf();\n+    call_it(proc(s) format_strbuf!(\"{}{}\", greeting, s));\n \n-    let greeting = \"How's life, \".to_owned();\n-    call_it(proc(s: ~str) -> ~str {\n-        greeting + s\n+    let greeting = \"How's life, \".to_strbuf();\n+    call_it(proc(s: StrBuf) -> StrBuf {\n+        format_strbuf!(\"{}{}\", greeting, s)\n     });\n \n     // Closures"}, {"sha": "0d06ff9610c9d907c546ba3c92d811b1d8c78594", "filename": "src/test/run-pass/complex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,18 +15,18 @@ type t = int;\n \n fn nothing() { }\n \n-fn putstr(_s: ~str) { }\n+fn putstr(_s: StrBuf) { }\n \n fn putint(_i: int) {\n     let mut i: int = 33;\n-    while i < 36 { putstr(\"hi\".to_owned()); i = i + 1; }\n+    while i < 36 { putstr(\"hi\".to_strbuf()); i = i + 1; }\n }\n \n fn zerg(i: int) -> int { return i; }\n \n fn foo(x: int) -> int {\n     let mut y: t = x + 2;\n-    putstr(\"hello\".to_owned());\n+    putstr(\"hello\".to_strbuf());\n     while y < 10 { putint(y); if y * 3 == 4 { y = y + 2; nothing(); } }\n     let mut z: t;\n     z = 0x55;"}, {"sha": "19ed116cc5c21890aea6471c0f475ac6da43dfb7", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -108,8 +108,8 @@ mod test_foreign_items {\n     pub mod rustrt {\n         extern {\n             #[cfg(bogus)]\n-            pub fn write() -> ~str;\n-            pub fn write() -> ~str;\n+            pub fn write() -> StrBuf;\n+            pub fn write() -> StrBuf;\n         }\n     }\n }"}, {"sha": "712b3344210c3b1b3eaff281f245c4c721236a50", "filename": "src/test/run-pass/const-enum-structlike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,7 +11,7 @@\n #![feature(struct_variant)]\n \n enum E {\n-    S0 { s: ~str },\n+    S0 { s: StrBuf },\n     S1 { u: uint }\n }\n "}, {"sha": "56f6871ed54c3da5d7226159143bf6c890f00f99", "filename": "src/test/run-pass/crate-method-reexport-grrrrrrr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -24,5 +24,5 @@ pub fn main() {\n     let x = @();\n     x.cx();\n     let y = ();\n-    y.add(\"hi\".to_owned());\n+    y.add(\"hi\".to_strbuf());\n }"}, {"sha": "5b61b095fb67d8e4f4e46b00f254839ce8dce756", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,13 +15,21 @@ use std::hash::Hash;\n #[deriving(Hash)]\n struct Person {\n     id: uint,\n-    name: ~str,\n+    name: StrBuf,\n     phone: uint,\n }\n \n fn main() {\n-    let person1 = Person { id: 5, name: \"Janet\".to_owned(), phone: 555_666_7777 };\n-    let person2 = Person { id: 5, name: \"Bob\".to_owned(), phone: 555_666_7777 };\n+    let person1 = Person {\n+        id: 5,\n+        name: \"Janet\".to_strbuf(),\n+        phone: 555_666_7777\n+    };\n+    let person2 = Person {\n+        id: 5,\n+        name: \"Bob\".to_strbuf(),\n+        phone: 555_666_7777\n+    };\n     assert!(hash::hash(&person1) == hash::hash(&person1));\n     assert!(hash::hash(&person1) != hash::hash(&person2));\n }"}, {"sha": "59ab75ddaaf196d841caae2c25967542c1577cb9", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -17,7 +17,7 @@ enum A {}\n #[deriving(Show)]\n enum B { B1, B2, B3 }\n #[deriving(Show)]\n-enum C { C1(int), C2(B), C3(~str) }\n+enum C { C1(int), C2(B), C3(StrBuf) }\n #[deriving(Show)]\n enum D { D1{ a: int } }\n #[deriving(Show)]"}, {"sha": "835741ab7e319eb92f409de35d4f7214c9b56d41", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n #[deriving(Eq, Show)]\n-struct Foo(int, int, ~str);\n+struct Foo(int, int, StrBuf);\n \n pub fn main() {\n-  let a1 = Foo(5, 6, \"abc\".to_owned());\n-  let a2 = Foo(5, 6, \"abc\".to_owned());\n-  let b = Foo(5, 7, \"def\".to_owned());\n+  let a1 = Foo(5, 6, \"abc\".to_strbuf());\n+  let a2 = Foo(5, 6, \"abc\".to_strbuf());\n+  let b = Foo(5, 7, \"def\".to_strbuf());\n \n   assert!(a1 == a1);\n   assert!(a2 == a1);"}, {"sha": "e2d14239598bf3444d653d0e0274dd93f913ba94", "filename": "src/test/run-pass/drop-on-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@\n \n fn f() -> int {\n     if true {\n-        let _s: ~str = \"should not leak\".to_owned();\n+        let _s: StrBuf = \"should not leak\".to_strbuf();\n         return 1;\n     }\n     return 0;"}, {"sha": "26d2fce3fa8ca4921029162dc595b2be46dbd573", "filename": "src/test/run-pass/enum-disr-val-pretty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,13 +13,13 @@\n enum color { red = 1, green, blue, imaginary = -1, }\n \n pub fn main() {\n-    test_color(red, 1, \"red\".to_owned());\n-    test_color(green, 2, \"green\".to_owned());\n-    test_color(blue, 3, \"blue\".to_owned());\n-    test_color(imaginary, -1, \"imaginary\".to_owned());\n+    test_color(red, 1, \"red\".to_strbuf());\n+    test_color(green, 2, \"green\".to_strbuf());\n+    test_color(blue, 3, \"blue\".to_strbuf());\n+    test_color(imaginary, -1, \"imaginary\".to_strbuf());\n }\n \n-fn test_color(color: color, val: int, _name: ~str) {\n+fn test_color(color: color, val: int, _name: StrBuf) {\n     assert!(color as int == val);\n     assert!(color as f64 == val as f64);\n }"}, {"sha": "5327a29733e80db1d2baea9ea11097ca55805f47", "filename": "src/test/run-pass/enum-variants.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-variants.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,13 +13,13 @@\n #![feature(struct_variant)]\n \n enum Animal {\n-    Dog (~str, f64),\n-    Cat { name: ~str, weight: f64 }\n+    Dog (StrBuf, f64),\n+    Cat { name: StrBuf, weight: f64 }\n }\n \n pub fn main() {\n-    let mut a: Animal = Dog(\"Cocoa\".to_owned(), 37.2);\n-    a = Cat{ name: \"Spotty\".to_owned(), weight: 2.7 };\n+    let mut a: Animal = Dog(\"Cocoa\".to_strbuf(), 37.2);\n+    a = Cat{ name: \"Spotty\".to_strbuf(), weight: 2.7 };\n     // permuting the fields should work too\n-    let _c = Cat { weight: 3.1, name: \"Spreckles\".to_owned() };\n+    let _c = Cat { weight: 3.1, name: \"Spreckles\".to_strbuf() };\n }"}, {"sha": "85a796a686b358f47d06f69808b50f5f28112e3f", "filename": "src/test/run-pass/estr-uniq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-uniq.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,10 +11,10 @@\n #![allow(dead_assignment)]\n \n pub fn main() {\n-    let x : ~str = \"hello\".to_owned();\n-    let _y : ~str = \"there\".to_owned();\n-    let mut z = \"thing\".to_owned();\n+    let x : StrBuf = \"hello\".to_strbuf();\n+    let _y : StrBuf = \"there\".to_strbuf();\n+    let mut z = \"thing\".to_strbuf();\n     z = x;\n-    assert_eq!(z[0], ('h' as u8));\n-    assert_eq!(z[4], ('o' as u8));\n+    assert_eq!(z.as_slice()[0], ('h' as u8));\n+    assert_eq!(z.as_slice()[4], ('o' as u8));\n }"}, {"sha": "4e6b038f8ed4ad288b496ec82f5dc2425c9763d6", "filename": "src/test/run-pass/explicit_self_xcrate_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,6 +14,6 @@ extern crate explicit_self_xcrate;\n use explicit_self_xcrate::{Foo, Bar};\n \n pub fn main() {\n-    let x = Bar { x: \"hello\".to_owned() };\n+    let x = Bar { x: \"hello\".to_strbuf() };\n     x.f();\n }"}, {"sha": "d57031c81e784228d0b77bd060f52df073b7356b", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -22,16 +22,16 @@ mod mlibc {\n     }\n }\n \n-fn strlen(str: ~str) -> uint {\n+fn strlen(str: StrBuf) -> uint {\n     // C string is terminated with a zero\n-    str.with_c_str(|buf| {\n+    str.as_slice().with_c_str(|buf| {\n         unsafe {\n             mlibc::my_strlen(buf) as uint\n         }\n     })\n }\n \n pub fn main() {\n-    let len = strlen(\"Rust\".to_owned());\n+    let len = strlen(\"Rust\".to_strbuf());\n     assert_eq!(len, 4u);\n }"}, {"sha": "33a538098562f54d95e84c12e01cce6b445ef446", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -20,33 +20,35 @@ extern crate collections;\n    This originally came from the word-count benchmark.\n */\n \n-pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, \"1\".to_owned()); }\n+pub fn map(filename: StrBuf, emit: map_reduce::putter) {\n+    emit(filename, \"1\".to_strbuf());\n+}\n \n mod map_reduce {\n     use collections::HashMap;\n     use std::str;\n     use std::task;\n \n-    pub type putter<'a> = |~str, ~str|: 'a;\n+    pub type putter<'a> = |StrBuf, StrBuf|: 'a;\n \n-    pub type mapper = extern fn(~str, putter);\n+    pub type mapper = extern fn(StrBuf, putter);\n \n     enum ctrl_proto { find_reducer(Vec<u8>, Sender<int>), mapper_done, }\n \n-    fn start_mappers(ctrl: Sender<ctrl_proto>, inputs: Vec<~str>) {\n+    fn start_mappers(ctrl: Sender<ctrl_proto>, inputs: Vec<StrBuf>) {\n         for i in inputs.iter() {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n             task::spawn(proc() map_task(ctrl.clone(), i.clone()) );\n         }\n     }\n \n-    fn map_task(ctrl: Sender<ctrl_proto>, input: ~str) {\n+    fn map_task(ctrl: Sender<ctrl_proto>, input: StrBuf) {\n         let mut intermediates = HashMap::new();\n \n-        fn emit(im: &mut HashMap<~str, int>,\n-                ctrl: Sender<ctrl_proto>, key: ~str,\n-                _val: ~str) {\n+        fn emit(im: &mut HashMap<StrBuf, int>,\n+                ctrl: Sender<ctrl_proto>, key: StrBuf,\n+                _val: StrBuf) {\n             if im.contains_key(&key) {\n                 return;\n             }\n@@ -64,13 +66,13 @@ mod map_reduce {\n         ctrl_clone.send(mapper_done);\n     }\n \n-    pub fn map_reduce(inputs: Vec<~str>) {\n+    pub fn map_reduce(inputs: Vec<StrBuf>) {\n         let (tx, rx) = channel();\n \n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n \n-        let mut reducers: HashMap<~str, int>;\n+        let mut reducers: HashMap<StrBuf, int>;\n \n         reducers = HashMap::new();\n \n@@ -83,8 +85,8 @@ mod map_reduce {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.find(&str::from_utf8(k.as_slice()).unwrap()\n-                                                                 .to_owned()) {\n+                match reducers.find(&str::from_utf8(\n+                        k.as_slice()).unwrap().to_strbuf()) {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }\n                 }\n@@ -96,5 +98,6 @@ mod map_reduce {\n }\n \n pub fn main() {\n-    map_reduce::map_reduce(vec!(\"../src/test/run-pass/hashmap-memory.rs\".to_owned()));\n+    map_reduce::map_reduce(\n+        vec!(\"../src/test/run-pass/hashmap-memory.rs\".to_strbuf()));\n }"}, {"sha": "13211e0d3d1343f2c8dfc4ee192e566b94e2dea4", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -41,7 +41,7 @@ macro_rules! parse_node (\n     ) => (\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n-            [$(:$head_nodes,)* :tag(stringify!($head).to_owned(),\n+            [$(:$head_nodes,)* :tag(stringify!($head).to_strbuf(),\n                                     vec!($($nodes),*))];\n             $($rest)*\n         )\n@@ -66,7 +66,7 @@ macro_rules! parse_node (\n     ) => (\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n-            [$(:$nodes,)* :text(\".\".to_owned())];\n+            [$(:$nodes,)* :text(\".\".to_strbuf())];\n             $($rest)*\n         )\n     );\n@@ -78,7 +78,7 @@ macro_rules! parse_node (\n     ) => (\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n-            [$(:$nodes,)* :text(stringify!($word).to_owned())];\n+            [$(:$nodes,)* :text(stringify!($word).to_strbuf())];\n             $($rest)*\n         )\n     );\n@@ -98,6 +98,6 @@ pub fn main() {\n }\n \n enum HTMLFragment {\n-    tag(~str, Vec<HTMLFragment> ),\n-    text(~str),\n+    tag(StrBuf, Vec<HTMLFragment> ),\n+    text(StrBuf),\n }"}, {"sha": "ce02f16634f216b16eadde0b7868737a6685ae89", "filename": "src/test/run-pass/issue-10228.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-10228.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-10228.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10228.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,7 +13,7 @@ enum StdioContainer {\n }\n \n struct Test<'a> {\n-    args: &'a [~str],\n+    args: &'a [StrBuf],\n     io: &'a [StdioContainer]\n }\n "}, {"sha": "36db5a64555b59deb0fc03b25b60cf14220cce69", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -35,22 +35,25 @@ fn main() {\n             rx.recv();\n         }\n     } else {\n-        parent(\"green\".to_owned());\n-        parent(\"native\".to_owned());\n+        parent(\"green\".to_strbuf());\n+        parent(\"native\".to_strbuf());\n         let (tx, rx) = channel();\n         native::task::spawn(proc() {\n-            parent(\"green\".to_owned());\n-            parent(\"native\".to_owned());\n+            parent(\"green\".to_strbuf());\n+            parent(\"native\".to_strbuf());\n             tx.send(());\n         });\n         rx.recv();\n     }\n }\n \n-fn parent(flavor: ~str) {\n+fn parent(flavor: StrBuf) {\n     let args = os::args();\n     let args = args.as_slice();\n-    let mut p = io::Process::new(args[0].as_slice(), [\"child\".to_owned(), flavor]).unwrap();\n+    let mut p = io::Process::new(args[0].as_slice(), [\n+        \"child\".to_owned(),\n+        flavor.to_owned()\n+    ]).unwrap();\n     p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(out.status.success());"}, {"sha": "cef46d56b7dd59cdde44adece45aa4595295f158", "filename": "src/test/run-pass/issue-1701.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1701.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,22 +10,22 @@\n \n enum pattern { tabby, tortoiseshell, calico }\n enum breed { beagle, rottweiler, pug }\n-type name = ~str;\n+type name = StrBuf;\n enum ear_kind { lop, upright }\n enum animal { cat(pattern), dog(breed), rabbit(name, ear_kind), tiger }\n \n-fn noise(a: animal) -> Option<~str> {\n+fn noise(a: animal) -> Option<StrBuf> {\n     match a {\n-      cat(..)    => { Some(\"meow\".to_owned()) }\n-      dog(..)    => { Some(\"woof\".to_owned()) }\n+      cat(..)    => { Some(\"meow\".to_strbuf()) }\n+      dog(..)    => { Some(\"woof\".to_strbuf()) }\n       rabbit(..) => { None }\n-      tiger(..)  => { Some(\"roar\".to_owned()) }\n+      tiger(..)  => { Some(\"roar\".to_strbuf()) }\n     }\n }\n \n pub fn main() {\n-    assert_eq!(noise(cat(tabby)), Some(\"meow\".to_owned()));\n-    assert_eq!(noise(dog(pug)), Some(\"woof\".to_owned()));\n-    assert_eq!(noise(rabbit(\"Hilbert\".to_owned(), upright)), None);\n-    assert_eq!(noise(tiger), Some(\"roar\".to_owned()));\n+    assert_eq!(noise(cat(tabby)), Some(\"meow\".to_strbuf()));\n+    assert_eq!(noise(dog(pug)), Some(\"woof\".to_strbuf()));\n+    assert_eq!(noise(rabbit(\"Hilbert\".to_strbuf(), upright)), None);\n+    assert_eq!(noise(tiger), Some(\"roar\".to_strbuf()));\n }"}, {"sha": "8216e341135948a1684d14271732e4e74ed88fd0", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -20,8 +20,8 @@ use std::cell::RefCell;\n use collections::HashMap;\n \n pub fn main() {\n-  let v = vec!(@\"hi\".to_owned());\n+  let v = vec!(@\"hi\".to_strbuf());\n   let mut m: req::header_map = HashMap::new();\n-  m.insert(\"METHOD\".to_owned(), @RefCell::new(v));\n+  m.insert(\"METHOD\".to_strbuf(), @RefCell::new(v));\n   request::<int>(&m);\n }"}, {"sha": "57eb0df560f817f71d2c61e7c9d0a7034dbf1ff3", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -16,8 +16,8 @@ extern crate collections;\n \n use collections::HashMap;\n \n-fn add_interfaces(managed_ip: ~str, device: HashMap<~str, int>)  {\n-     println!(\"{}, {:?}\", managed_ip, device.get(&\"interfaces\".to_owned()));\n+fn add_interfaces(managed_ip: StrBuf, device: HashMap<StrBuf, int>)  {\n+     println!(\"{}, {:?}\", managed_ip, device.get(&\"interfaces\".to_strbuf()));\n }\n \n pub fn main() {}"}, {"sha": "9405c62a184c6a61163c1d594958de64563b57e9", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -21,11 +21,11 @@ enum object {\n     int_value(i64),\n }\n \n-fn lookup(table: Box<json::Object>, key: ~str, default: ~str) -> ~str\n+fn lookup(table: Box<json::Object>, key: StrBuf, default: StrBuf) -> StrBuf\n {\n-    match table.find(&key) {\n+    match table.find(&key.to_owned()) {\n         option::Some(&json::String(ref s)) => {\n-            (*s).clone()\n+            (*s).to_strbuf()\n         }\n         option::Some(value) => {\n             println!(\"{} was expected to be a string but is a {:?}\", key, value);\n@@ -37,25 +37,27 @@ fn lookup(table: Box<json::Object>, key: ~str, default: ~str) -> ~str\n     }\n }\n \n-fn add_interface(_store: int, managed_ip: ~str, data: json::Json) -> (~str, object)\n+fn add_interface(_store: int, managed_ip: StrBuf, data: json::Json) -> (StrBuf, object)\n {\n     match &data {\n         &json::Object(ref interface) => {\n-            let name = lookup((*interface).clone(), \"ifDescr\".to_owned(), \"\".to_owned());\n-            let label = format!(\"{}-{}\", managed_ip, name);\n+            let name = lookup((*interface).clone(),\n+                              \"ifDescr\".to_strbuf(),\n+                              \"\".to_strbuf());\n+            let label = format_strbuf!(\"{}-{}\", managed_ip, name);\n \n             (label, bool_value(false))\n         }\n         _ => {\n             println!(\"Expected dict for {} interfaces but found {:?}\", managed_ip, data);\n-            (\"gnos:missing-interface\".to_owned(), bool_value(true))\n+            (\"gnos:missing-interface\".to_strbuf(), bool_value(true))\n         }\n     }\n }\n \n-fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, json::Json>)\n--> Vec<(~str, object)> {\n-    match device.get(&\"interfaces\".to_owned())\n+fn add_interfaces(store: int, managed_ip: StrBuf, device: HashMap<StrBuf, json::Json>)\n+-> Vec<(StrBuf, object)> {\n+    match device.get(&\"interfaces\".to_strbuf())\n     {\n         &json::List(ref interfaces) =>\n         {\n@@ -66,7 +68,7 @@ fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, json::Json\n         _ =>\n         {\n             println!(\"Expected list for {} interfaces but found {:?}\", managed_ip,\n-                   device.get(&\"interfaces\".to_owned()));\n+                   device.get(&\"interfaces\".to_strbuf()));\n             Vec::new()\n         }\n     }"}, {"sha": "0a6482c26b9fa350e3dc71120a11ddd42cfd6adf", "filename": "src/test/run-pass/issue-3037.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3037.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,7 +10,7 @@\n \n enum what { }\n \n-fn what_to_str(x: what) -> ~str\n+fn what_to_str(x: what) -> StrBuf\n {\n     match x {\n     }"}, {"sha": "5eefd5ef08abe397caa18382c000033bf9671d0c", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,11 +10,11 @@\n \n \n struct trie_node {\n-    content: Vec<~str> ,\n+    content: Vec<StrBuf> ,\n     children: Vec<trie_node> ,\n }\n \n-fn print_str_vector(vector: Vec<~str> ) {\n+fn print_str_vector(vector: Vec<StrBuf> ) {\n     for string in vector.iter() {\n         println!(\"{}\", *string);\n     }\n@@ -25,8 +25,8 @@ pub fn main() {\n         content: Vec::new(),\n         children: Vec::new()\n     };\n-    let v = vec!(\"123\".to_owned(), \"abc\".to_owned());\n-    node.content = vec!(\"123\".to_owned(), \"abc\".to_owned());\n+    let v = vec!(\"123\".to_strbuf(), \"abc\".to_strbuf());\n+    node.content = vec!(\"123\".to_strbuf(), \"abc\".to_strbuf());\n     print_str_vector(v);\n     print_str_vector(node.content.clone());\n "}, {"sha": "6423ab1cb6402af65d17b93f7a254d67e9f18132", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,11 +15,13 @@ use std::path::{Path};\n use std::path;\n use std::result;\n \n-type rsrc_loader = proc(path: &Path) -> result::Result<~str, ~str>;\n+type rsrc_loader = proc(path: &Path) -> result::Result<StrBuf, StrBuf>;\n \n fn tester()\n {\n-    let loader: rsrc_loader = proc(_path) {result::Ok(\"more blah\".to_owned())};\n+    let loader: rsrc_loader = proc(_path) {\n+        result::Ok(\"more blah\".to_strbuf())\n+    };\n \n     let path = path::Path::new(\"blah\");\n     assert!(loader(&path).is_ok());"}, {"sha": "910f7c328a700a54f64ade7eb6139c4193d02476", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,12 +11,12 @@\n #![feature(managed_boxes)]\n \n enum Token {\n-    Text(@~str),\n-    ETag(@Vec<~str> , @~str),\n-    UTag(@Vec<~str> , @~str),\n-    Section(@Vec<~str> , bool, @Vec<Token> , @~str, @~str, @~str, @~str, @~str),\n-    IncompleteSection(@Vec<~str> , bool, @~str, bool),\n-    Partial(@~str, @~str, @~str),\n+    Text(@StrBuf),\n+    ETag(@Vec<StrBuf> , @StrBuf),\n+    UTag(@Vec<StrBuf> , @StrBuf),\n+    Section(@Vec<StrBuf> , bool, @Vec<Token> , @StrBuf, @StrBuf, @StrBuf, @StrBuf, @StrBuf),\n+    IncompleteSection(@Vec<StrBuf> , bool, @StrBuf, bool),\n+    Partial(@StrBuf, @StrBuf, @StrBuf),\n }\n \n fn check_strs(actual: &str, expected: &str) -> bool\n@@ -35,10 +35,13 @@ pub fn main()\n // assert!(check_strs(fmt!(\"%?\", ETag(@~[\"foo\".to_owned()], @\"bar\".to_owned())),\n //                    \"ETag(@~[ ~\\\"foo\\\" ], @~\\\"bar\\\")\"));\n \n-    let t = Text(@\"foo\".to_owned());\n-    let u = Section(@vec!(\"alpha\".to_owned()), true, @vec!(t), @\"foo\".to_owned(),\n-                    @\"foo\".to_owned(), @\"foo\".to_owned(), @\"foo\".to_owned(),\n-                    @\"foo\".to_owned());\n+    let t = Text(@\"foo\".to_strbuf());\n+    let u = Section(@vec!(\"alpha\".to_strbuf()),\n+                          true,\n+                          @vec!(t),\n+                          @\"foo\".to_strbuf(),\n+                    @\"foo\".to_strbuf(), @\"foo\".to_strbuf(), @\"foo\".to_strbuf(),\n+                    @\"foo\".to_strbuf());\n     let v = format!(\"{:?}\", u);    // this is the line that causes the seg fault\n     assert!(v.len() > 0);\n }"}, {"sha": "ac2ce615fee405a06baae8ce328de30ec113f269", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -100,8 +100,10 @@ impl fmt::Show for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Convert each line into a string.\n         let lines = self.lines.iter()\n-                              .map(|line| str::from_chars(line.as_slice()))\n-                              .collect::<Vec<~str>>();\n+                              .map(|line| {\n+                                  str::from_chars(line.as_slice()).to_strbuf()\n+                              })\n+                              .collect::<Vec<StrBuf>>();\n \n         // Concatenate the lines together using a new-line.\n         write!(f.buf, \"{}\", lines.connect(\"\\n\"))"}, {"sha": "f1fd83b179f403d96c6992d65dd5ca00c478f3b7", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,10 +15,10 @@ type SamplesFn = proc(samples: &RingBuffer):Send;\n \n enum Msg\n {\n-    GetSamples(~str, SamplesFn), // sample set name, callback which receives samples\n+    GetSamples(StrBuf, SamplesFn), // sample set name, callback which receives samples\n }\n \n-fn foo(name: ~str, samples_chan: Sender<Msg>) {\n+fn foo(name: StrBuf, samples_chan: Sender<Msg>) {\n     task::spawn(proc() {\n         let mut samples_chan = samples_chan;\n         let callback: SamplesFn = proc(buffer) {"}, {"sha": "9ee34d58c371c5e24fadc28bd915c4e25fc04792", "filename": "src/test/run-pass/issue-3702.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3702.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,7 +11,7 @@\n \n pub fn main() {\n   trait Text {\n-    fn to_str(&self) -> ~str;\n+    fn to_str(&self) -> StrBuf;\n   }\n \n   fn to_string(t: Box<Text>) {"}, {"sha": "ef24a8cd9d15fa4881025f4192088870b2d847ba", "filename": "src/test/run-pass/issue-3935.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-3935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3935.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,12 +10,12 @@\n \n #[deriving(Eq)]\n struct Bike {\n-    name: ~str,\n+    name: StrBuf,\n }\n \n pub fn main() {\n-    let town_bike = Bike { name: \"schwinn\".to_owned() };\n-    let my_bike = Bike { name: \"surly\".to_owned() };\n+    let town_bike = Bike { name: \"schwinn\".to_strbuf() };\n+    let my_bike = Bike { name: \"surly\".to_strbuf() };\n \n     assert!(town_bike != my_bike);\n }"}, {"sha": "0f7219d7901fa9cf4c4b13a259828ec72f89312c", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -24,8 +24,8 @@ enum Result {\n   Int(int),\n   Data(~[u8]),\n   List(~[Result]),\n-  Error(~str),\n-  Status(~str)\n+  Error(StrBuf),\n+  Status(StrBuf)\n }\n \n priv fn parse_data(len: uint, io: @io::Reader) -> Result {\n@@ -55,7 +55,7 @@ priv fn parse_list(len: uint, io: @io::Reader) -> Result {\n     return List(list);\n }\n \n-priv fn chop(s: ~str) -> ~str {\n+priv fn chop(s: StrBuf) -> StrBuf {\n   s.slice(0, s.len() - 1).to_owned()\n }\n \n@@ -96,7 +96,7 @@ priv fn parse_response(io: @io::Reader) -> Result {\n     }\n }\n \n-priv fn cmd_to_str(cmd: ~[~str]) -> ~str {\n+priv fn cmd_to_str(cmd: ~[StrBuf]) -> StrBuf {\n   let mut res = \"*\".to_owned();\n   res.push_str(cmd.len().to_str());\n   res.push_str(\"\\r\\n\");\n@@ -107,15 +107,15 @@ priv fn cmd_to_str(cmd: ~[~str]) -> ~str {\n   res\n }\n \n-fn query(cmd: ~[~str], sb: TcpSocketBuf) -> Result {\n+fn query(cmd: ~[StrBuf], sb: TcpSocketBuf) -> Result {\n   let cmd = cmd_to_str(cmd);\n   //println!(\"{}\", cmd);\n   sb.write_str(cmd);\n   let res = parse_response(@sb as @io::Reader);\n   res\n }\n \n-fn query2(cmd: ~[~str]) -> Result {\n+fn query2(cmd: ~[StrBuf]) -> Result {\n   let _cmd = cmd_to_str(cmd);\n     io::with_str_reader(\"$3\\r\\nXXX\\r\\n\".to_owned())(|sb| {\n     let res = parse_response(@sb as @io::Reader);"}, {"sha": "73df5d206d3676278f96e7cdf1ff26cd1b6119e4", "filename": "src/test/run-pass/issue-4541.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4541.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn parse_args() -> ~str {\n+fn parse_args() -> StrBuf {\n     let args = ::std::os::args();\n     let args = args.as_slice();\n     let mut n = 0;\n@@ -17,13 +17,13 @@ fn parse_args() -> ~str {\n         match args[n].as_slice() {\n             \"-v\" => (),\n             s => {\n-                return s.into_owned();\n+                return s.to_strbuf();\n             }\n         }\n         n += 1;\n     }\n \n-    return \"\".to_owned()\n+    return \"\".to_strbuf()\n }\n \n pub fn main() {"}, {"sha": "57cae2fdf7166823180541ecd028c6f950fb6faf", "filename": "src/test/run-pass/issue-5008-borrowed-traitobject-method-call.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5008-borrowed-traitobject-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5008-borrowed-traitobject-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5008-borrowed-traitobject-method-call.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -16,20 +16,20 @@ It fixes itself if the &Trait is changed to @Trait.\n */\n \n trait Debuggable {\n-    fn debug_name(&self) -> ~str;\n+    fn debug_name(&self) -> StrBuf;\n }\n \n #[deriving(Clone)]\n struct Thing {\n-name: ~str,\n+    name: StrBuf,\n }\n \n impl Thing {\n-    fn new() -> Thing { Thing { name: \"dummy\".to_owned() } }\n+    fn new() -> Thing { Thing { name: \"dummy\".to_strbuf() } }\n }\n \n impl Debuggable for Thing {\n-    fn debug_name(&self) -> ~str { self.name.clone() }\n+    fn debug_name(&self) -> StrBuf { self.name.clone() }\n }\n \n fn print_name(x: &Debuggable)"}, {"sha": "ade2815fd2df8a2ade716a349376616f1a679017", "filename": "src/test/run-pass/issue-5353.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5353.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5353.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5353.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,13 +11,13 @@\n static INVALID_ENUM : u32 = 0;\n static INVALID_VALUE : u32 = 1;\n \n-fn gl_err_str(err: u32) -> ~str\n+fn gl_err_str(err: u32) -> StrBuf\n {\n   match err\n   {\n-    INVALID_ENUM => { \"Invalid enum\".to_owned() },\n-    INVALID_VALUE => { \"Invalid value\".to_owned() },\n-    _ => { \"Unknown error\".to_owned() }\n+    INVALID_ENUM => { \"Invalid enum\".to_strbuf() },\n+    INVALID_VALUE => { \"Invalid value\".to_strbuf() },\n+    _ => { \"Unknown error\".to_strbuf() }\n   }\n }\n "}, {"sha": "d4962784b9ace02d5960d1980ca32917e86294d5", "filename": "src/test/run-pass/issue-5550.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5550.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_assignment)]\n \n pub fn main() {\n-    let s: ~str = \"foobar\".to_owned();\n-    let mut t: &str = s;\n+    let s: StrBuf = \"foobar\".to_strbuf();\n+    let mut t: &str = s.as_slice();\n     t = t.slice(0, 3); // for master: str::view(t, 0, 3) maybe\n }"}, {"sha": "2238c30f6e8cfaa2887e59c470a60d15bb7cc30a", "filename": "src/test/run-pass/issue-5666.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-5666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5666.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,23 +10,23 @@\n \n \n struct Dog {\n-    name : ~str\n+    name : StrBuf\n }\n \n trait Barks {\n-    fn bark(&self) -> ~str;\n+    fn bark(&self) -> StrBuf;\n }\n \n impl Barks for Dog {\n-    fn bark(&self) -> ~str {\n-        return format!(\"woof! (I'm {})\", self.name);\n+    fn bark(&self) -> StrBuf {\n+        return format!(\"woof! (I'm {})\", self.name).to_strbuf();\n     }\n }\n \n \n pub fn main() {\n-    let snoopy = box Dog{name: \"snoopy\".to_owned()};\n-    let bubbles = box Dog{name: \"bubbles\".to_owned()};\n+    let snoopy = box Dog{name: \"snoopy\".to_strbuf()};\n+    let bubbles = box Dog{name: \"bubbles\".to_strbuf()};\n     let barker = [snoopy as Box<Barks>, bubbles as Box<Barks>];\n \n     for pup in barker.iter() {"}, {"sha": "ecf066d86bce20000c9b35b180c12f8f06976e7b", "filename": "src/test/run-pass/issue-8506.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-8506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-8506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8506.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,7 +12,7 @@\n \n enum Either {\n     One,\n-    Other(~str,~str)\n+    Other(StrBuf,StrBuf)\n }\n \n static one : Either = One;"}, {"sha": "383eede5c14af974cda185da3b9bd58c755e033b", "filename": "src/test/run-pass/issue-8578.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-8578.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-8578.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8578.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub struct UninterpretedOption_NamePart {\n-    name_part: Option<~str>,\n+    name_part: Option<StrBuf>,\n }\n \n impl<'a> UninterpretedOption_NamePart {"}, {"sha": "77edc07ace0d6b8bfe9fba3673d0bd4301a7f179", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,8 +10,8 @@\n \n #![feature(managed_boxes)]\n \n-fn assert_repr_eq<T>(obj : T, expected : ~str) {\n-    assert_eq!(expected, format!(\"{:?}\", obj));\n+fn assert_repr_eq<T>(obj : T, expected : StrBuf) {\n+    assert_eq!(expected, format_strbuf!(\"{:?}\", obj));\n }\n \n pub fn main() {\n@@ -21,10 +21,10 @@ pub fn main() {\n     let slice = x.slice(0,1);\n     let z = @x;\n \n-    assert_repr_eq(abc, \"[1, 2, 3]\".to_owned());\n-    assert_repr_eq(tf, \"[true, false]\".to_owned());\n-    assert_repr_eq(x, \"[(), ()]\".to_owned());\n-    assert_repr_eq(slice, \"&[()]\".to_owned());\n-    assert_repr_eq(&x, \"&[(), ()]\".to_owned());\n-    assert_repr_eq(z, \"@[(), ()]\".to_owned());\n+    assert_repr_eq(abc, \"[1, 2, 3]\".to_strbuf());\n+    assert_repr_eq(tf, \"[true, false]\".to_strbuf());\n+    assert_repr_eq(x, \"[(), ()]\".to_strbuf());\n+    assert_repr_eq(slice, \"&[()]\".to_strbuf());\n+    assert_repr_eq(&x, \"&[(), ()]\".to_strbuf());\n+    assert_repr_eq(z, \"@[(), ()]\".to_strbuf());\n }"}, {"sha": "0cdceb2351746ccf9309d14d49813e8b5ce535db", "filename": "src/test/run-pass/issue-9047.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9047.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9047.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9047.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn decode() -> ~str {\n+fn decode() -> StrBuf {\n     'outer: loop {\n         let mut ch_start: uint;\n         break 'outer;\n     }\n-    \"\".to_owned()\n+    \"\".to_strbuf()\n }\n \n pub fn main() {"}, {"sha": "8cdd5d31002a06ef0bfc58ad1913b0aa512d5865", "filename": "src/test/run-pass/issue-9259.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9259.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n struct A<'a> {\n-    a: &'a [~str],\n-    b: Option<&'a [~str]>,\n+    a: &'a [StrBuf],\n+    b: Option<&'a [StrBuf]>,\n }\n \n pub fn main() {\n-    let b = &[\"foo\".to_owned()];\n+    let b = &[\"foo\".to_strbuf()];\n     let a = A {\n-        a: &[\"test\".to_owned()],\n+        a: &[\"test\".to_strbuf()],\n         b: Some(b),\n     };\n     assert_eq!(a.b.get_ref()[0].as_slice(), \"foo\");"}, {"sha": "cd9154f27489dbe79d2f21059fb80b6b2424acb3", "filename": "src/test/run-pass/issue-9394-inherited-trait-calls.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9394-inherited-trait-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9394-inherited-trait-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9394-inherited-trait-calls.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,62 +9,62 @@\n // except according to those terms.\n \n trait Base: Base2 + Base3{\n-    fn foo(&self) -> ~str;\n-    fn foo1(&self) -> ~str;\n-    fn foo2(&self) -> ~str{\n-        \"base foo2\".to_owned()\n+    fn foo(&self) -> StrBuf;\n+    fn foo1(&self) -> StrBuf;\n+    fn foo2(&self) -> StrBuf{\n+        \"base foo2\".to_strbuf()\n     }\n }\n \n trait Base2: Base3{\n-    fn baz(&self) -> ~str;\n+    fn baz(&self) -> StrBuf;\n }\n \n trait Base3{\n-    fn root(&self) -> ~str;\n+    fn root(&self) -> StrBuf;\n }\n \n trait Super: Base{\n-    fn bar(&self) -> ~str;\n+    fn bar(&self) -> StrBuf;\n }\n \n struct X;\n \n impl Base for X {\n-    fn foo(&self) -> ~str{\n-        \"base foo\".to_owned()\n+    fn foo(&self) -> StrBuf{\n+        \"base foo\".to_strbuf()\n     }\n-    fn foo1(&self) -> ~str{\n-        \"base foo1\".to_owned()\n+    fn foo1(&self) -> StrBuf{\n+        \"base foo1\".to_strbuf()\n     }\n \n }\n \n impl Base2 for X {\n-    fn baz(&self) -> ~str{\n-        \"base2 baz\".to_owned()\n+    fn baz(&self) -> StrBuf{\n+        \"base2 baz\".to_strbuf()\n     }\n }\n \n impl Base3 for X {\n-    fn root(&self) -> ~str{\n-        \"base3 root\".to_owned()\n+    fn root(&self) -> StrBuf{\n+        \"base3 root\".to_strbuf()\n     }\n }\n \n impl Super for X {\n-    fn bar(&self) -> ~str{\n-        \"super bar\".to_owned()\n+    fn bar(&self) -> StrBuf{\n+        \"super bar\".to_strbuf()\n     }\n }\n \n pub fn main() {\n     let n = X;\n     let s = &n as &Super;\n-    assert_eq!(s.bar(),\"super bar\".to_owned());\n-    assert_eq!(s.foo(),\"base foo\".to_owned());\n-    assert_eq!(s.foo1(),\"base foo1\".to_owned());\n-    assert_eq!(s.foo2(),\"base foo2\".to_owned());\n-    assert_eq!(s.baz(),\"base2 baz\".to_owned());\n-    assert_eq!(s.root(),\"base3 root\".to_owned());\n+    assert_eq!(s.bar(),\"super bar\".to_strbuf());\n+    assert_eq!(s.foo(),\"base foo\".to_strbuf());\n+    assert_eq!(s.foo1(),\"base foo1\".to_strbuf());\n+    assert_eq!(s.foo2(),\"base foo2\".to_strbuf());\n+    assert_eq!(s.baz(),\"base2 baz\".to_strbuf());\n+    assert_eq!(s.root(),\"base3 root\".to_strbuf());\n }"}, {"sha": "319e67b67a154cea4fdfaa4fc5328583aea2c516", "filename": "src/test/run-pass/issue-9446.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fissue-9446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9446.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Wrapper(~str);\n+struct Wrapper(StrBuf);\n \n impl Wrapper {\n-    pub fn new(wrapped: ~str) -> Wrapper {\n+    pub fn new(wrapped: StrBuf) -> Wrapper {\n         Wrapper(wrapped)\n     }\n \n@@ -28,12 +28,12 @@ impl Drop for Wrapper {\n pub fn main() {\n     {\n         // This runs without complaint.\n-        let x = Wrapper::new(\"Bob\".to_owned());\n+        let x = Wrapper::new(\"Bob\".to_strbuf());\n         x.say_hi();\n     }\n     {\n         // This fails to compile, circa 0.8-89-gc635fba.\n         // error: internal compiler error: drop_ty_immediate: non-box ty\n-        Wrapper::new(\"Bob\".to_owned()).say_hi();\n+        Wrapper::new(\"Bob\".to_strbuf()).say_hi();\n     }\n }"}, {"sha": "e4e7b052cf375a6a07af8f1d39f0464d82f868e7", "filename": "src/test/run-pass/istr.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fistr.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,37 +11,27 @@\n use std::strbuf::StrBuf;\n \n fn test_stack_assign() {\n-    let s: ~str = \"a\".to_owned();\n+    let s: StrBuf = \"a\".to_strbuf();\n     println!(\"{}\", s.clone());\n-    let t: ~str = \"a\".to_owned();\n+    let t: StrBuf = \"a\".to_strbuf();\n     assert!(s == t);\n-    let u: ~str = \"b\".to_owned();\n+    let u: StrBuf = \"b\".to_strbuf();\n     assert!((s != u));\n }\n \n-fn test_heap_lit() { \"a big string\".to_owned(); }\n+fn test_heap_lit() { \"a big string\".to_strbuf(); }\n \n fn test_heap_assign() {\n-    let s: ~str = \"a big ol' string\".to_owned();\n-    let t: ~str = \"a big ol' string\".to_owned();\n+    let s: StrBuf = \"a big ol' string\".to_strbuf();\n+    let t: StrBuf = \"a big ol' string\".to_strbuf();\n     assert!(s == t);\n-    let u: ~str = \"a bad ol' string\".to_owned();\n+    let u: StrBuf = \"a bad ol' string\".to_strbuf();\n     assert!((s != u));\n }\n \n-fn test_heap_log() { let s = \"a big ol' string\".to_owned(); println!(\"{}\", s); }\n-\n-fn test_stack_add() {\n-    assert_eq!(\"a\".to_owned() + \"b\", \"ab\".to_owned());\n-    let s: ~str = \"a\".to_owned();\n-    assert_eq!(s + s, \"aa\".to_owned());\n-    assert_eq!(\"\".to_owned() + \"\", \"\".to_owned());\n-}\n-\n-fn test_stack_heap_add() { assert!((\"a\".to_owned() + \"bracadabra\" == \"abracadabra\".to_owned())); }\n-\n-fn test_heap_add() {\n-    assert_eq!(\"this should\".to_owned() + \" totally work\", \"this should totally work\".to_owned());\n+fn test_heap_log() {\n+    let s = \"a big ol' string\".to_strbuf();\n+    println!(\"{}\", s);\n }\n \n fn test_append() {\n@@ -67,8 +57,5 @@ pub fn main() {\n     test_heap_lit();\n     test_heap_assign();\n     test_heap_log();\n-    test_stack_add();\n-    test_stack_heap_add();\n-    test_heap_add();\n     test_append();\n }"}, {"sha": "1eedaed98bc3212ffee8f7571cd1f0d9cc7f54e4", "filename": "src/test/run-pass/last-use-in-block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,16 +10,16 @@\n \n // Issue #1818\n \n-fn lp<T>(s: ~str, f: |~str| -> T) -> T {\n+fn lp<T>(s: StrBuf, f: |StrBuf| -> T) -> T {\n     while false {\n         let r = f(s);\n         return (r);\n     }\n     fail!();\n }\n \n-fn apply<T>(s: ~str, f: |~str| -> T) -> T {\n-    fn g<T>(s: ~str, f: |~str| -> T) -> T {f(s)}\n+fn apply<T>(s: StrBuf, f: |StrBuf| -> T) -> T {\n+    fn g<T>(s: StrBuf, f: |StrBuf| -> T) -> T {f(s)}\n     g(s, |v| { let r = f(v); r })\n }\n "}, {"sha": "e9e6ab02e9eb2eea3b9efe8e095c32675786b99b", "filename": "src/test/run-pass/log-knows-the-names-of-variants-in-std.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,29 +12,23 @@\n #[deriving(Clone)]\n enum foo {\n   a(uint),\n-  b(~str),\n+  b(StrBuf),\n }\n \n-fn check_log<T>(exp: ~str, v: T) {\n-    assert_eq!(exp, format!(\"{:?}\", v));\n+fn check_log<T>(exp: StrBuf, v: T) {\n+    assert_eq!(exp, format_strbuf!(\"{:?}\", v));\n }\n \n pub fn main() {\n     let mut x = Some(a(22u));\n-    let exp = \"Some(a(22u))\".to_owned();\n-    let act = format!(\"{:?}\", x);\n-    assert_eq!(act, exp);\n-    check_log(exp, x);\n-\n-    x = Some(b(\"hi\".to_owned()));\n-    let exp = \"Some(b(~\\\"hi\\\"))\".to_owned();\n-    let act = format!(\"{:?}\", x);\n+    let exp = \"Some(a(22u))\".to_strbuf();\n+    let act = format_strbuf!(\"{:?}\", x);\n     assert_eq!(act, exp);\n     check_log(exp, x);\n \n     x = None;\n-    let exp = \"None\".to_owned();\n-    let act = format!(\"{:?}\", x);\n+    let exp = \"None\".to_strbuf();\n+    let act = format_strbuf!(\"{:?}\", x);\n     assert_eq!(act, exp);\n     check_log(exp, x);\n }"}, {"sha": "46bdb5eb7660d8d52a3f982ff9123dde89c085d1", "filename": "src/test/run-pass/log-knows-the-names-of-variants.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,7 +10,7 @@\n \n enum foo {\n   a(uint),\n-  b(~str),\n+  b(StrBuf),\n   c,\n }\n \n@@ -19,8 +19,7 @@ enum bar {\n }\n \n pub fn main() {\n-    assert_eq!(\"a(22u)\".to_owned(), format!(\"{:?}\", a(22u)));\n-    assert_eq!(\"b(~\\\"hi\\\")\".to_owned(), format!(\"{:?}\", b(\"hi\".to_owned())));\n-    assert_eq!(\"c\".to_owned(), format!(\"{:?}\", c));\n-    assert_eq!(\"d\".to_owned(), format!(\"{:?}\", d));\n+    assert_eq!(\"a(22u)\".to_strbuf(), format_strbuf!(\"{:?}\", a(22u)));\n+    assert_eq!(\"c\".to_strbuf(), format_strbuf!(\"{:?}\", c));\n+    assert_eq!(\"d\".to_strbuf(), format_strbuf!(\"{:?}\", d));\n }"}, {"sha": "db1db8067a862db54553f6dbd6c45a93b0a8a4d9", "filename": "src/test/run-pass/match-borrowed_str.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,49 +10,49 @@\n \n #![allow(unnecessary_allocation)]\n \n-fn f1(ref_string: &str) -> ~str {\n+fn f1(ref_string: &str) -> StrBuf {\n     match ref_string {\n-        \"a\" => \"found a\".to_owned(),\n-        \"b\" => \"found b\".to_owned(),\n-        _ => \"not found\".to_owned()\n+        \"a\" => \"found a\".to_strbuf(),\n+        \"b\" => \"found b\".to_strbuf(),\n+        _ => \"not found\".to_strbuf()\n     }\n }\n \n-fn f2(ref_string: &str) -> ~str {\n+fn f2(ref_string: &str) -> StrBuf {\n     match ref_string {\n-        \"a\" => \"found a\".to_owned(),\n-        \"b\" => \"found b\".to_owned(),\n-        s => format!(\"not found ({})\", s)\n+        \"a\" => \"found a\".to_strbuf(),\n+        \"b\" => \"found b\".to_strbuf(),\n+        s => format_strbuf!(\"not found ({})\", s)\n     }\n }\n \n-fn g1(ref_1: &str, ref_2: &str) -> ~str {\n+fn g1(ref_1: &str, ref_2: &str) -> StrBuf {\n     match (ref_1, ref_2) {\n-        (\"a\", \"b\") => \"found a,b\".to_owned(),\n-        (\"b\", \"c\") => \"found b,c\".to_owned(),\n-        _ => \"not found\".to_owned()\n+        (\"a\", \"b\") => \"found a,b\".to_strbuf(),\n+        (\"b\", \"c\") => \"found b,c\".to_strbuf(),\n+        _ => \"not found\".to_strbuf()\n     }\n }\n \n-fn g2(ref_1: &str, ref_2: &str) -> ~str {\n+fn g2(ref_1: &str, ref_2: &str) -> StrBuf {\n     match (ref_1, ref_2) {\n-        (\"a\", \"b\") => \"found a,b\".to_owned(),\n-        (\"b\", \"c\") => \"found b,c\".to_owned(),\n-        (s1, s2) => format!(\"not found ({}, {})\", s1, s2)\n+        (\"a\", \"b\") => \"found a,b\".to_strbuf(),\n+        (\"b\", \"c\") => \"found b,c\".to_strbuf(),\n+        (s1, s2) => format_strbuf!(\"not found ({}, {})\", s1, s2)\n     }\n }\n \n pub fn main() {\n-    assert_eq!(f1(\"b\".to_owned()), \"found b\".to_owned());\n-    assert_eq!(f1(\"c\"), \"not found\".to_owned());\n-    assert_eq!(f1(\"d\"), \"not found\".to_owned());\n-    assert_eq!(f2(\"b\".to_owned()), \"found b\".to_owned());\n-    assert_eq!(f2(\"c\"), \"not found (c)\".to_owned());\n-    assert_eq!(f2(\"d\"), \"not found (d)\".to_owned());\n-    assert_eq!(g1(\"b\".to_owned(), \"c\".to_owned()), \"found b,c\".to_owned());\n-    assert_eq!(g1(\"c\", \"d\"), \"not found\".to_owned());\n-    assert_eq!(g1(\"d\", \"e\"), \"not found\".to_owned());\n-    assert_eq!(g2(\"b\".to_owned(), \"c\".to_owned()), \"found b,c\".to_owned());\n-    assert_eq!(g2(\"c\", \"d\"), \"not found (c, d)\".to_owned());\n-    assert_eq!(g2(\"d\", \"e\"), \"not found (d, e)\".to_owned());\n+    assert_eq!(f1(\"b\"), \"found b\".to_strbuf());\n+    assert_eq!(f1(\"c\"), \"not found\".to_strbuf());\n+    assert_eq!(f1(\"d\"), \"not found\".to_strbuf());\n+    assert_eq!(f2(\"b\"), \"found b\".to_strbuf());\n+    assert_eq!(f2(\"c\"), \"not found (c)\".to_strbuf());\n+    assert_eq!(f2(\"d\"), \"not found (d)\".to_strbuf());\n+    assert_eq!(g1(\"b\", \"c\"), \"found b,c\".to_strbuf());\n+    assert_eq!(g1(\"c\", \"d\"), \"not found\".to_strbuf());\n+    assert_eq!(g1(\"d\", \"e\"), \"not found\".to_strbuf());\n+    assert_eq!(g2(\"b\", \"c\"), \"found b,c\".to_strbuf());\n+    assert_eq!(g2(\"c\", \"d\"), \"not found (c, d)\".to_strbuf());\n+    assert_eq!(g2(\"d\", \"e\"), \"not found (d, e)\".to_strbuf());\n }"}, {"sha": "e3060a6b4be675024f40a09d7784c3a18cd35f3a", "filename": "src/test/run-pass/match-str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmatch-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmatch-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-str.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,13 +13,13 @@\n pub fn main() {\n     match \"test\" { \"not-test\" => fail!(), \"test\" => (), _ => fail!() }\n \n-    enum t { tag1(~str), tag2, }\n+    enum t { tag1(StrBuf), tag2, }\n \n \n-    match tag1(\"test\".to_owned()) {\n+    match tag1(\"test\".to_strbuf()) {\n       tag2 => fail!(),\n-      tag1(ref s) if \"test\" != *s => fail!(),\n-      tag1(ref s) if \"test\" == *s => (),\n+      tag1(ref s) if \"test\" != s.as_slice() => fail!(),\n+      tag1(ref s) if \"test\" == s.as_slice() => (),\n       _ => fail!()\n     }\n "}, {"sha": "8b3cb76817ec41dbf2186dc637111384a9deadac", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -37,15 +37,18 @@ impl<A> option_monad<A> for Option<A> {\n     }\n }\n \n-fn transform(x: Option<int>) -> Option<~str> {\n-    x.bind(|n| Some(*n + 1) ).bind(|n| Some(n.to_str()) )\n+fn transform(x: Option<int>) -> Option<StrBuf> {\n+    x.bind(|n| Some(*n + 1) ).bind(|n| Some(n.to_str().to_strbuf()) )\n }\n \n pub fn main() {\n-    assert_eq!(transform(Some(10)), Some(\"11\".to_owned()));\n+    assert_eq!(transform(Some(10)), Some(\"11\".to_strbuf()));\n     assert_eq!(transform(None), None);\n-    assert!((vec!(\"hi\".to_owned()))\n-        .bind(|x| vec!(x.clone(), *x + \"!\") )\n-        .bind(|x| vec!(x.clone(), *x + \"?\") ) ==\n-        vec!(\"hi\".to_owned(), \"hi?\".to_owned(), \"hi!\".to_owned(), \"hi!?\".to_owned()));\n+    assert!((vec!(\"hi\".to_strbuf()))\n+        .bind(|x| vec!(x.clone(), format_strbuf!(\"{}!\", x)) )\n+        .bind(|x| vec!(x.clone(), format_strbuf!(\"{}?\", x)) ) ==\n+        vec!(\"hi\".to_strbuf(),\n+             \"hi?\".to_strbuf(),\n+             \"hi!\".to_strbuf(),\n+             \"hi!?\".to_strbuf()));\n }"}, {"sha": "276aaa3b63f64af0f659d8b7aaef8817774b52c9", "filename": "src/test/run-pass/move-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmove-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fmove-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-self.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct S {\n-    x: ~str\n+    x: StrBuf\n }\n \n impl S {\n@@ -23,6 +23,6 @@ impl S {\n }\n \n pub fn main() {\n-    let x = S { x: \"Hello!\".to_owned() };\n+    let x = S { x: \"Hello!\".to_strbuf() };\n     x.foo();\n }"}, {"sha": "1618f11914bcdf9a3f1f0c7815981e36e5797a1a", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -76,7 +76,7 @@ pub fn main() {\n     check_type!(&17: &int);\n     check_type!(box 18: Box<int>);\n     check_type!(@19: @int);\n-    check_type!(\"foo\".to_owned(): ~str);\n+    check_type!(\"foo\".to_strbuf(): StrBuf);\n     check_type!(vec!(20, 22): Vec<int> );\n     let mint: uint = unsafe { mem::transmute(main) };\n     check_type!(main: fn(), |pthing| {"}, {"sha": "2309984a1f11c761115231c704ac5bf90b56d59a", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -40,6 +40,5 @@ pub fn main() {\n     check_type!(&'static int);\n     check_type!(Box<int>);\n     check_type!(@int);\n-    check_type!(~str);\n     check_type!(extern fn());\n }"}, {"sha": "80f37a0fa3d0ce2e14527babab5ff4507fcc9c0a", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -21,7 +21,4 @@ pub fn main() {\n     assert_eq!(mem::size_of::<S<u8, u8>>(), 3);\n \n     assert_eq!(mem::size_of::<S<u64, u16>>(), 11);\n-\n-    assert_eq!(mem::size_of::<S<~str, Vec<int> >>(),\n-               1 + mem::size_of::<~str>() + mem::size_of::<Vec<int> >());\n }"}, {"sha": "1781f162bc498d003c9e4aea7cc51e7199b60c44", "filename": "src/test/run-pass/packed-struct-size.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -25,11 +25,10 @@ struct S5 {\n }\n \n #[packed]\n-struct S13_str {\n+struct S13 {\n     a: i64,\n     b: f32,\n     c: u8,\n-    d: ~str\n }\n \n enum Foo {\n@@ -61,7 +60,7 @@ static TEST_S3_Foo: S3_Foo = S3_Foo { a: 1, b: 2, c: Baz };\n pub fn main() {\n     assert_eq!(mem::size_of::<S4>(), 4);\n     assert_eq!(mem::size_of::<S5>(), 5);\n-    assert_eq!(mem::size_of::<S13_str>(), 13 + mem::size_of::<~str>());\n+    assert_eq!(mem::size_of::<S13>(), 13);\n     assert_eq!(mem::size_of::<S3_Foo>(), 3 + mem::size_of::<Foo>());\n     assert_eq!(mem::size_of::<S7_Option>(), 7 + mem::size_of::<Option<@f64>>());\n }"}, {"sha": "9036df0bbd1e90ecc2e5cee304a0f4bc7edc5b39", "filename": "src/test/run-pass/packed-tuple-struct-size.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -19,7 +19,7 @@ struct S4(u8,[u8, .. 3]);\n struct S5(u8, u32);\n \n #[packed]\n-struct S13_str(i64, f32, u8, ~str);\n+struct S13(i64, f32, u8);\n \n enum Foo {\n     Bar = 1,\n@@ -37,8 +37,7 @@ pub fn main() {\n \n     assert_eq!(mem::size_of::<S5>(), 5);\n \n-    assert_eq!(mem::size_of::<S13_str>(),\n-               13 + mem::size_of::<~str>());\n+    assert_eq!(mem::size_of::<S13>(), 13);\n \n     assert_eq!(mem::size_of::<S3_Foo>(),\n                3 + mem::size_of::<Foo>());"}, {"sha": "19b5268001d1c754e45654cf0f4fa07f3f59fc1f", "filename": "src/test/run-pass/rec-auto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Frec-auto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Frec-auto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-auto.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -14,10 +14,10 @@\n \n // Issue #50.\n \n-struct X { foo: ~str, bar: ~str }\n+struct X { foo: StrBuf, bar: StrBuf }\n \n pub fn main() {\n-    let x = X {foo: \"hello\".to_owned(), bar: \"world\".to_owned()};\n+    let x = X {foo: \"hello\".to_strbuf(), bar: \"world\".to_strbuf()};\n     println!(\"{}\", x.foo.clone());\n     println!(\"{}\", x.bar.clone());\n }"}, {"sha": "17ed80da03c9798c8fdbdddae3fbbb6700797a21", "filename": "src/test/run-pass/reexported-static-methods-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -20,5 +20,5 @@ pub fn main() {\n     assert_eq!(42, Foo::foo());\n     assert_eq!(84, Baz::bar());\n     assert!(Boz::boz(1));\n-    assert_eq!(\"bort()\".to_owned(), Bort::bort());\n+    assert_eq!(\"bort()\".to_strbuf(), Bort::bort());\n }"}, {"sha": "d05bc5600889bf819954248f87038e5cd8c453e1", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,37 +13,37 @@\n use std::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n \n struct MyVisitor {\n-    types: Vec<~str> ,\n+    types: Vec<StrBuf> ,\n }\n \n impl TyVisitor for MyVisitor {\n     fn visit_bot(&mut self) -> bool {\n-        self.types.push(\"bot\".to_owned());\n+        self.types.push(\"bot\".to_strbuf());\n         println!(\"visited bot type\");\n         true\n     }\n     fn visit_nil(&mut self) -> bool {\n-        self.types.push(\"nil\".to_owned());\n+        self.types.push(\"nil\".to_strbuf());\n         println!(\"visited nil type\");\n         true\n     }\n     fn visit_bool(&mut self) -> bool {\n-        self.types.push(\"bool\".to_owned());\n+        self.types.push(\"bool\".to_strbuf());\n         println!(\"visited bool type\");\n         true\n     }\n     fn visit_int(&mut self) -> bool {\n-        self.types.push(\"int\".to_owned());\n+        self.types.push(\"int\".to_strbuf());\n         println!(\"visited int type\");\n         true\n     }\n     fn visit_i8(&mut self) -> bool {\n-        self.types.push(\"i8\".to_owned());\n+        self.types.push(\"i8\".to_strbuf());\n         println!(\"visited i8 type\");\n         true\n     }\n     fn visit_i16(&mut self) -> bool {\n-        self.types.push(\"i16\".to_owned());\n+        self.types.push(\"i16\".to_strbuf());\n         println!(\"visited i16 type\");\n         true\n     }\n@@ -76,9 +76,9 @@ impl TyVisitor for MyVisitor {\n \n     fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.types.push(\"[\".to_owned());\n+        self.types.push(\"[\".to_strbuf());\n         unsafe { visit_tydesc(inner, &mut *self as &mut TyVisitor); }\n-        self.types.push(\"]\".to_owned());\n+        self.types.push(\"]\".to_strbuf());\n         true\n     }\n     fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n@@ -155,7 +155,7 @@ pub fn main() {\n         println!(\"type: {}\", (*s).clone());\n     }\n \n-    let vec_types: Vec<~str> = v.types.clone().move_iter().collect();\n-    assert_eq!(vec_types, vec!(\"bool\".to_owned(), \"int\".to_owned(),\n-                               \"i8\".to_owned(), \"i16\".to_owned()));\n+    let vec_types: Vec<StrBuf> = v.types.clone().move_iter().collect();\n+    assert_eq!(vec_types, vec!(\"bool\".to_strbuf(), \"int\".to_strbuf(),\n+                               \"i8\".to_strbuf(), \"i16\".to_strbuf()));\n }"}, {"sha": "38f0f12267ba5a403b7d7294f1f50df07b7a5232", "filename": "src/test/run-pass/repeated-vector-syntax.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,11 +10,6 @@\n \n #![feature(managed_boxes)]\n \n-#[deriving(Clone)]\n-struct Foo {\n-    a: ~str,\n-}\n-\n pub fn main() {\n     let x = [ [true], ..512 ];\n     let y = [ 0, ..1 ];"}, {"sha": "fab8998afbe7558e183c7749794c6f01eb7ab55a", "filename": "src/test/run-pass/ret-bang.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fret-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fret-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-bang.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,10 +11,14 @@\n \n \n \n-fn my_err(s: ~str) -> ! { println!(\"{:?}\", s); fail!(); }\n+fn my_err(s: StrBuf) -> ! { println!(\"{}\", s); fail!(); }\n \n fn okay(i: uint) -> int {\n-    if i == 3u { my_err(\"I don't like three\".to_owned()); } else { return 42; }\n+    if i == 3u {\n+        my_err(\"I don't like three\".to_strbuf());\n+    } else {\n+        return 42;\n+    }\n }\n \n pub fn main() { okay(4u); }"}, {"sha": "b6dcf06cae04fb4866e553076e5844be3cd39e8a", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -61,8 +61,8 @@ pub fn main() {\n     assert_eq!(map.find(&Owned(\"def\".to_owned())), Some(&d));\n \n     assert!(map.pop(&Slice(\"foo\")).is_some());\n-    assert_eq!(map.move_iter().map(|(k, v)| k.to_str() + v.to_str())\n-                              .collect::<Vec<~str>>()\n+    assert_eq!(map.move_iter().map(|(k, v)| format_strbuf!(\"{}{}\", k, v))\n+                              .collect::<Vec<StrBuf>>()\n                               .concat(),\n                \"abc50bcd51cde52def53\".to_owned());\n }"}, {"sha": "7f5e92e71f2f486bb3f274a5b9c25b371e6525f7", "filename": "src/test/run-pass/shape_intrinsic_tag_then_rec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -41,7 +41,7 @@ type ty_ = uint;\n #[deriving(Clone)]\n struct Path_ {\n     global: bool,\n-    idents: Vec<~str> ,\n+    idents: Vec<StrBuf> ,\n     types: Vec<@ty>,\n }\n \n@@ -59,7 +59,7 @@ pub fn main() {\n     let t: @ty = @Spanned { data: 3u, span: sp };\n     let p_: Path_ = Path_ {\n         global: true,\n-        idents: vec!(\"hi\".to_owned()),\n+        idents: vec!(\"hi\".to_strbuf()),\n         types: vec!(t),\n     };\n     let p: path = Spanned { data: p_, span: sp };"}, {"sha": "dff99cbe366ba24608cc7990a217e7243cb0c3af", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,15 +10,19 @@\n \n use std::task;\n \n-fn x(s: ~str, n: int) {\n+fn x(s: StrBuf, n: int) {\n     println!(\"{:?}\", s);\n     println!(\"{:?}\", n);\n }\n \n pub fn main() {\n-    task::spawn(proc() x(\"hello from first spawned fn\".to_owned(), 65) );\n-    task::spawn(proc() x(\"hello from second spawned fn\".to_owned(), 66) );\n-    task::spawn(proc() x(\"hello from third spawned fn\".to_owned(), 67) );\n+    task::spawn(proc() x(\"hello from first spawned fn\".to_strbuf(), 65) );\n+    task::spawn(proc() x(\"hello from second spawned fn\".to_strbuf(), 66) );\n+    task::spawn(proc() x(\"hello from third spawned fn\".to_strbuf(), 67) );\n     let mut i: int = 30;\n-    while i > 0 { i = i - 1; println!(\"parent sleeping\"); task::deschedule(); }\n+    while i > 0 {\n+        i = i - 1;\n+        println!(\"parent sleeping\");\n+        task::deschedule();\n+    }\n }"}, {"sha": "b2fc1d272e8c589dd333818dbe702fa6338f95cd", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -18,11 +18,11 @@ use std::task;\n \n type ctx = Sender<int>;\n \n-fn iotask(_tx: &ctx, ip: ~str) {\n-    assert_eq!(ip, \"localhost\".to_owned());\n+fn iotask(_tx: &ctx, ip: StrBuf) {\n+    assert_eq!(ip, \"localhost\".to_strbuf());\n }\n \n pub fn main() {\n     let (tx, _rx) = channel::<int>();\n-    task::spawn(proc() iotask(&tx, \"localhost\".to_owned()) );\n+    task::spawn(proc() iotask(&tx, \"localhost\".to_strbuf()) );\n }"}, {"sha": "2bf3510bce1be4595df0d0e6eb881f26d4749d9e", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -21,16 +21,18 @@ mod a {\n \n mod b {\n     use plus;\n-    impl plus for ~str { fn plus(&self) -> int { 200 } }\n+    impl plus for StrBuf { fn plus(&self) -> int { 200 } }\n }\n \n trait uint_utils {\n-    fn str(&self) -> ~str;\n+    fn str(&self) -> StrBuf;\n     fn multi(&self, f: |uint|);\n }\n \n impl uint_utils for uint {\n-    fn str(&self) -> ~str { self.to_str() }\n+    fn str(&self) -> StrBuf {\n+        self.to_str().to_strbuf()\n+    }\n     fn multi(&self, f: |uint|) {\n         let mut c = 0u;\n         while c < *self { f(c); c += 1u; }\n@@ -57,9 +59,9 @@ impl<T> vec_utils<T> for Vec<T> {\n \n pub fn main() {\n     assert_eq!(10u.plus(), 30);\n-    assert_eq!((\"hi\".to_owned()).plus(), 200);\n+    assert_eq!((\"hi\".to_strbuf()).plus(), 200);\n \n-    assert_eq!((vec!(1)).length_().str(), \"1\".to_owned());\n+    assert_eq!((vec!(1)).length_().str(), \"1\".to_strbuf());\n     let vect = vec!(3, 4).map_(|a| *a + 4);\n     assert_eq!(*vect.get(0), 7);\n     let vect = (vec!(3, 4)).map_::<uint>(|a| *a as uint + 4u);"}, {"sha": "7cf1a15ab3ec358dc291b285d7aa3c4103eb2b60", "filename": "src/test/run-pass/static-method-xcrate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,8 +15,8 @@ extern crate static_methods_crate;\n use static_methods_crate::read;\n \n pub fn main() {\n-    let result: int = read(\"5\".to_owned());\n+    let result: int = read(\"5\".to_strbuf());\n     assert_eq!(result, 5);\n-    assert_eq!(read::readMaybe(\"false\".to_owned()), Some(false));\n-    assert_eq!(read::readMaybe(\"foo\".to_owned()), None::<bool>);\n+    assert_eq!(read::readMaybe(\"false\".to_strbuf()), Some(false));\n+    assert_eq!(read::readMaybe(\"foo\".to_strbuf()), None::<bool>);\n }"}, {"sha": "cecde7f8838d86690fde83bc598642f573ed7589", "filename": "src/test/run-pass/str-concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-concat.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,9 +12,9 @@\n \n \n pub fn main() {\n-    let a: ~str = \"hello\".to_owned();\n-    let b: ~str = \"world\".to_owned();\n-    let s: ~str = a + b;\n+    let a: StrBuf = \"hello\".to_strbuf();\n+    let b: StrBuf = \"world\".to_strbuf();\n+    let s: StrBuf = format_strbuf!(\"{}{}\", a, b);\n     println!(\"{}\", s.clone());\n-    assert_eq!(s[9], 'd' as u8);\n+    assert_eq!(s.as_slice()[9], 'd' as u8);\n }"}, {"sha": "e42c89e67f4e5fe38dbb1cb447963c939cf98307", "filename": "src/test/run-pass/str-multiline.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-multiline.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n pub fn main() {\n-    let a: ~str = \"this \\\n-is a test\".to_owned();\n-    let b: ~str =\n+    let a: StrBuf = \"this \\\n+is a test\".to_strbuf();\n+    let b: StrBuf =\n         \"this \\\n               is \\\n               another \\\n-              test\".to_owned();\n-    assert_eq!(a, \"this is a test\".to_owned());\n-    assert_eq!(b, \"this is another test\".to_owned());\n+              test\".to_strbuf();\n+    assert_eq!(a, \"this is a test\".to_strbuf());\n+    assert_eq!(b, \"this is another test\".to_strbuf());\n }"}, {"sha": "619ee761e9c6aec03f2437dac312486617c5935a", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,13 +10,13 @@\n \n pub fn main() {\n     // Make sure we properly handle repeated self-appends.\n-    let mut a: ~str = \"A\".to_owned();\n+    let mut a: StrBuf = \"A\".to_strbuf();\n     let mut i = 20;\n     let mut expected_len = 1u;\n     while i > 0 {\n         println!(\"{}\", a.len());\n         assert_eq!(a.len(), expected_len);\n-        a = a + a; // FIXME(#3387)---can't write a += a\n+        a = format_strbuf!(\"{}{}\", a, a);\n         i -= 1;\n         expected_len *= 2u;\n     }"}, {"sha": "6f1eec8346a928237c284f51ec16ed3738d2371b", "filename": "src/test/run-pass/struct-literal-dtor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstruct-literal-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstruct-literal-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-literal-dtor.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct foo {\n-    x: ~str,\n+    x: StrBuf,\n }\n \n impl Drop for foo {\n@@ -19,5 +19,7 @@ impl Drop for foo {\n }\n \n pub fn main() {\n-    let _z = foo { x: \"Hello\".to_owned() };\n+    let _z = foo {\n+        x: \"Hello\".to_strbuf()\n+    };\n }"}, {"sha": "e48ad05ef582f8d64339d7968b29aad143da213a", "filename": "src/test/run-pass/struct-order-of-eval-1.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,9 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S { f0: ~str, f1: int }\n+struct S { f0: StrBuf, f1: int }\n \n pub fn main() {\n-    let s = \"Hello, world!\".to_owned();\n-    let _s = S { f0: s.to_owned(), ..S { f0: s, f1: 23 } };\n+    let s = \"Hello, world!\".to_strbuf();\n+    let _s = S {\n+        f0: s.to_strbuf(),\n+        ..S {\n+            f0: s,\n+            f1: 23\n+        }\n+    };\n }"}, {"sha": "9b2414325a58bd178f3c8a9fe3aad23495cf0c7b", "filename": "src/test/run-pass/struct-order-of-eval-2.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -8,9 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S { f0: ~str, f1: ~str }\n+struct S {\n+    f0: StrBuf,\n+    f1: StrBuf,\n+}\n \n pub fn main() {\n-    let s = \"Hello, world!\".to_owned();\n-    let _s = S { f1: s.to_owned(), f0: s };\n+    let s = \"Hello, world!\".to_strbuf();\n+    let _s = S {\n+        f1: s.to_strbuf(),\n+        f0: s\n+    };\n }"}, {"sha": "706f5787c4e590aac4f37c19162e8c57f89e4a06", "filename": "src/test/run-pass/swap-overlapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,7 +15,7 @@ use std::ptr;\n pub fn main() {\n     let mut test = TestDescAndFn {\n         desc: TestDesc {\n-            name: DynTestName(\"test\".to_owned()),\n+            name: DynTestName(\"test\".to_strbuf()),\n             should_fail: false\n         },\n         testfn: DynTestFn(proc() ()),\n@@ -30,7 +30,7 @@ fn do_swap(test: &mut TestDescAndFn) {\n }\n \n pub enum TestName {\n-    DynTestName(~str)\n+    DynTestName(StrBuf)\n }\n \n pub enum TestFn {"}, {"sha": "017b17d0e9c2f6ca3fe7c653a12e321df3f04bee", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -15,7 +15,7 @@\n \n pub mod m1 {\n     pub mod m2 {\n-        pub fn where_am_i() -> ~str { (module_path!()).to_owned() }\n+        pub fn where_am_i() -> StrBuf { (module_path!()).to_strbuf() }\n     }\n }\n \n@@ -26,16 +26,19 @@ pub fn main() {\n     //assert!((col!() == 11));\n     assert_eq!(indirect_line!(), 27);\n     assert!((file!().to_owned().ends_with(\"syntax-extension-source-utils.rs\")));\n-    assert_eq!(stringify!((2*3) + 5).to_owned(), \"( 2 * 3 ) + 5\".to_owned());\n-    assert!(include!(\"syntax-extension-source-utils-files/includeme.fragment\").to_owned()\n-           == \"victory robot 6\".to_owned());\n+    assert_eq!(stringify!((2*3) + 5).to_strbuf(), \"( 2 * 3 ) + 5\".to_strbuf());\n+    assert!(include!(\"syntax-extension-source-utils-files/includeme.\\\n+                      fragment\").to_strbuf()\n+           == \"victory robot 6\".to_strbuf());\n \n     assert!(\n-        include_str!(\"syntax-extension-source-utils-files/includeme.fragment\").to_owned()\n+        include_str!(\"syntax-extension-source-utils-files/includeme.\\\n+                      fragment\").to_strbuf()\n+        .as_slice()\n         .starts_with(\"/* this is for \"));\n     assert!(\n         include_bin!(\"syntax-extension-source-utils-files/includeme.fragment\")\n         [1] == (42 as u8)); // '*'\n     // The Windows tests are wrapped in an extra module for some reason\n-    assert!((m1::m2::where_am_i().ends_with(\"m1::m2\")));\n+    assert!((m1::m2::where_am_i().as_slice().ends_with(\"m1::m2\")));\n }"}, {"sha": "40c5f623986894425b7a98f0a9226d6520ff5446", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -27,45 +27,45 @@ impl Eq for color {\n }\n \n pub fn main() {\n-    test_color(red, 0xff0000, \"red\".to_owned());\n-    test_color(green, 0x00ff00, \"green\".to_owned());\n-    test_color(blue, 0x0000ff, \"blue\".to_owned());\n-    test_color(black, 0x000000, \"black\".to_owned());\n-    test_color(white, 0xFFFFFF, \"white\".to_owned());\n-    test_color(imaginary, -1, \"imaginary\".to_owned());\n-    test_color(purple, 2, \"purple\".to_owned());\n-    test_color(orange, 4, \"orange\".to_owned());\n+    test_color(red, 0xff0000, \"red\".to_strbuf());\n+    test_color(green, 0x00ff00, \"green\".to_strbuf());\n+    test_color(blue, 0x0000ff, \"blue\".to_strbuf());\n+    test_color(black, 0x000000, \"black\".to_strbuf());\n+    test_color(white, 0xFFFFFF, \"white\".to_strbuf());\n+    test_color(imaginary, -1, \"imaginary\".to_strbuf());\n+    test_color(purple, 2, \"purple\".to_strbuf());\n+    test_color(orange, 4, \"orange\".to_strbuf());\n }\n \n-fn test_color(color: color, val: int, name: ~str) {\n+fn test_color(color: color, val: int, name: StrBuf) {\n     //assert!(unsafe::transmute(color) == val);\n     assert_eq!(color as int, val);\n     assert_eq!(color as f64, val as f64);\n     assert!(get_color_alt(color) == name);\n     assert!(get_color_if(color) == name);\n }\n \n-fn get_color_alt(color: color) -> ~str {\n+fn get_color_alt(color: color) -> StrBuf {\n     match color {\n-      red => {\"red\".to_owned()}\n-      green => {\"green\".to_owned()}\n-      blue => {\"blue\".to_owned()}\n-      black => {\"black\".to_owned()}\n-      white => {\"white\".to_owned()}\n-      imaginary => {\"imaginary\".to_owned()}\n-      purple => {\"purple\".to_owned()}\n-      orange => {\"orange\".to_owned()}\n+      red => {\"red\".to_strbuf()}\n+      green => {\"green\".to_strbuf()}\n+      blue => {\"blue\".to_strbuf()}\n+      black => {\"black\".to_strbuf()}\n+      white => {\"white\".to_strbuf()}\n+      imaginary => {\"imaginary\".to_strbuf()}\n+      purple => {\"purple\".to_strbuf()}\n+      orange => {\"orange\".to_strbuf()}\n     }\n }\n \n-fn get_color_if(color: color) -> ~str {\n-    if color == red {\"red\".to_owned()}\n-    else if color == green {\"green\".to_owned()}\n-    else if color == blue {\"blue\".to_owned()}\n-    else if color == black {\"black\".to_owned()}\n-    else if color == white {\"white\".to_owned()}\n-    else if color == imaginary {\"imaginary\".to_owned()}\n-    else if color == purple {\"purple\".to_owned()}\n-    else if color == orange {\"orange\".to_owned()}\n-    else {\"unknown\".to_owned()}\n+fn get_color_if(color: color) -> StrBuf {\n+    if color == red {\"red\".to_strbuf()}\n+    else if color == green {\"green\".to_strbuf()}\n+    else if color == blue {\"blue\".to_strbuf()}\n+    else if color == black {\"black\".to_strbuf()}\n+    else if color == white {\"white\".to_strbuf()}\n+    else if color == imaginary {\"imaginary\".to_strbuf()}\n+    else if color == purple {\"purple\".to_strbuf()}\n+    else if color == orange {\"orange\".to_strbuf()}\n+    else {\"unknown\".to_strbuf()}\n }"}, {"sha": "e90fe27823b645e0c771f4ff824eedd4ade243c2", "filename": "src/test/run-pass/tail-call-arg-leak.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftail-call-arg-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftail-call-arg-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-call-arg-leak.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -12,6 +12,8 @@\n \n \n // use of tail calls causes arg slot leaks, issue #160.\n-fn inner(dummy: ~str, b: bool) { if b { return inner(dummy, false); } }\n+fn inner(dummy: StrBuf, b: bool) { if b { return inner(dummy, false); } }\n \n-pub fn main() { inner(\"hi\".to_owned(), true); }\n+pub fn main() {\n+    inner(\"hi\".to_strbuf(), true);\n+}"}, {"sha": "b298f2edf010c70b3bcde7017dfda55a714a96ce", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,26 +11,26 @@\n \n use std::task;\n \n-fn start(tx: &Sender<Sender<~str>>) {\n+fn start(tx: &Sender<Sender<StrBuf>>) {\n     let (tx2, rx) = channel();\n     tx.send(tx2);\n \n     let mut a;\n     let mut b;\n     a = rx.recv();\n-    assert!(a == \"A\".to_owned());\n-    println!(\"{:?}\", a);\n+    assert!(a == \"A\".to_strbuf());\n+    println!(\"{}\", a);\n     b = rx.recv();\n-    assert!(b == \"B\".to_owned());\n-    println!(\"{:?}\", b);\n+    assert!(b == \"B\".to_strbuf());\n+    println!(\"{}\", b);\n }\n \n pub fn main() {\n     let (tx, rx) = channel();\n     let _child = task::spawn(proc() { start(&tx) });\n \n     let mut c = rx.recv();\n-    c.send(\"A\".to_owned());\n-    c.send(\"B\".to_owned());\n+    c.send(\"A\".to_strbuf());\n+    c.send(\"B\".to_strbuf());\n     task::deschedule();\n }"}, {"sha": "378effa8a1893bfd87233757de31b76b8dafc5c0", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,9 +11,9 @@\n use std::task;\n \n pub fn main() {\n-    task::spawn(proc() child(\"Hello\".to_owned()) );\n+    task::spawn(proc() child(\"Hello\".to_strbuf()) );\n }\n \n-fn child(_s: ~str) {\n+fn child(_s: StrBuf) {\n \n }"}, {"sha": "b5ed021ec6a78f41cde536589db93e2a5b5940ad", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -25,43 +25,54 @@ trait Pet {\n \n struct Catte {\n     num_whiskers: uint,\n-    name: ~str,\n+    name: StrBuf,\n }\n \n struct Dogge {\n     bark_decibels: uint,\n     tricks_known: uint,\n-    name: ~str,\n+    name: StrBuf,\n }\n \n struct Goldfyshe {\n     swim_speed: uint,\n-    name: ~str,\n+    name: StrBuf,\n }\n \n impl Pet for Catte {\n-    fn name(&self, blk: |&str|) { blk(self.name) }\n+    fn name(&self, blk: |&str|) { blk(self.name.as_slice()) }\n     fn num_legs(&self) -> uint { 4 }\n     fn of_good_pedigree(&self) -> bool { self.num_whiskers >= 4 }\n }\n impl Pet for Dogge {\n-    fn name(&self, blk: |&str|) { blk(self.name) }\n+    fn name(&self, blk: |&str|) { blk(self.name.as_slice()) }\n     fn num_legs(&self) -> uint { 4 }\n     fn of_good_pedigree(&self) -> bool {\n         self.bark_decibels < 70 || self.tricks_known > 20\n     }\n }\n impl Pet for Goldfyshe {\n-    fn name(&self, blk: |&str|) { blk(self.name) }\n+    fn name(&self, blk: |&str|) { blk(self.name.as_slice()) }\n     fn num_legs(&self) -> uint { 0 }\n     fn of_good_pedigree(&self) -> bool { self.swim_speed >= 500 }\n }\n \n pub fn main() {\n-    let catte = Catte { num_whiskers: 7, name: \"alonzo_church\".to_owned() };\n-    let dogge1 = Dogge { bark_decibels: 100, tricks_known: 42, name: \"alan_turing\".to_owned() };\n-    let dogge2 = Dogge { bark_decibels: 55,  tricks_known: 11, name: \"albert_einstein\".to_owned() };\n-    let fishe = Goldfyshe { swim_speed: 998, name: \"alec_guinness\".to_owned() };\n+    let catte = Catte { num_whiskers: 7, name: \"alonzo_church\".to_strbuf() };\n+    let dogge1 = Dogge {\n+        bark_decibels: 100,\n+        tricks_known: 42,\n+        name: \"alan_turing\".to_strbuf(),\n+    };\n+    let dogge2 = Dogge {\n+        bark_decibels: 55,\n+        tricks_known: 11,\n+        name: \"albert_einstein\".to_strbuf(),\n+    };\n+    let fishe = Goldfyshe {\n+        swim_speed: 998,\n+        name: \"alec_guinness\".to_strbuf(),\n+    };\n     let arc = Arc::new(vec!(box catte  as Box<Pet:Share+Send>,\n                             box dogge1 as Box<Pet:Share+Send>,\n                             box fishe  as Box<Pet:Share+Send>,"}, {"sha": "d6aaefe868f3f20ac1cdd7adbc898606d5d9a705", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -22,33 +22,38 @@ struct TreeR {\n }\n \n trait to_str {\n-    fn to_str_(&self) -> ~str;\n+    fn to_str_(&self) -> StrBuf;\n }\n \n impl<T:to_str> to_str for Option<T> {\n-    fn to_str_(&self) -> ~str {\n+    fn to_str_(&self) -> StrBuf {\n         match *self {\n-          None => { \"none\".to_owned() }\n-          Some(ref t) => { \"some(\".to_owned() + t.to_str_() + \")\".to_owned() }\n+          None => { \"none\".to_strbuf() }\n+          Some(ref t) => format_strbuf!(\"some({})\", t.to_str_()),\n         }\n     }\n }\n \n impl to_str for int {\n-    fn to_str_(&self) -> ~str { self.to_str() }\n+    fn to_str_(&self) -> StrBuf {\n+        self.to_str().to_strbuf()\n+    }\n }\n \n impl to_str for Tree {\n-    fn to_str_(&self) -> ~str {\n+    fn to_str_(&self) -> StrBuf {\n         let Tree(t) = *self;\n         let this = t.borrow();\n         let (l, r) = (this.left, this.right);\n         let val = &this.val;\n-        format!(\"[{}, {}, {}]\", val.to_str_(), l.to_str_(), r.to_str_())\n+        format_strbuf!(\"[{}, {}, {}]\",\n+                       val.to_str_(),\n+                       l.to_str_(),\n+                       r.to_str_())\n     }\n }\n \n-fn foo<T:to_str>(x: T) -> ~str { x.to_str_() }\n+fn foo<T:to_str>(x: T) -> StrBuf { x.to_str_() }\n \n pub fn main() {\n     let t1 = Tree(@RefCell::new(TreeR{left: None,\n@@ -57,7 +62,8 @@ pub fn main() {\n     let t2 = Tree(@RefCell::new(TreeR{left: Some(t1),\n                                       right: Some(t1),\n                                       val: box 2 as Box<to_str:Send>}));\n-    let expected = \"[2, some([1, none, none]), some([1, none, none])]\".to_owned();\n+    let expected =\n+        \"[2, some([1, none, none]), some([1, none, none])]\".to_strbuf();\n     assert!(t2.to_str_() == expected);\n     assert!(foo(t2) == expected);\n "}, {"sha": "269c1d4094ebb213672129bb4fa5e41b659026b7", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,16 +11,16 @@\n \n \n trait to_str {\n-    fn to_string(&self) -> ~str;\n+    fn to_string(&self) -> StrBuf;\n }\n impl to_str for int {\n-    fn to_string(&self) -> ~str { self.to_str() }\n+    fn to_string(&self) -> StrBuf { self.to_str().to_strbuf() }\n }\n-impl to_str for ~str {\n-    fn to_string(&self) -> ~str { self.clone() }\n+impl to_str for StrBuf {\n+    fn to_string(&self) -> StrBuf { self.clone() }\n }\n impl to_str for () {\n-    fn to_string(&self) -> ~str { \"()\".to_owned() }\n+    fn to_string(&self) -> StrBuf { \"()\".to_strbuf() }\n }\n \n trait map<T> {\n@@ -37,17 +37,17 @@ impl<T> map<T> for Vec<T> {\n     }\n }\n \n-fn foo<U, T: map<U>>(x: T) -> Vec<~str> {\n-    x.map(|_e| \"hi\".to_owned() )\n+fn foo<U, T: map<U>>(x: T) -> Vec<StrBuf> {\n+    x.map(|_e| \"hi\".to_strbuf() )\n }\n-fn bar<U:to_str,T:map<U>>(x: T) -> Vec<~str> {\n+fn bar<U:to_str,T:map<U>>(x: T) -> Vec<StrBuf> {\n     x.map(|_e| _e.to_string() )\n }\n \n pub fn main() {\n-    assert_eq!(foo(vec!(1)), vec!(\"hi\".to_owned()));\n-    assert_eq!(bar::<int, Vec<int> >(vec!(4, 5)), vec!(\"4\".to_owned(), \"5\".to_owned()));\n-    assert_eq!(bar::<~str, Vec<~str> >(vec!(\"x\".to_owned(), \"y\".to_owned())),\n-               vec!(\"x\".to_owned(), \"y\".to_owned()));\n-    assert_eq!(bar::<(), Vec<()>>(vec!(())), vec!(\"()\".to_owned()));\n+    assert_eq!(foo(vec!(1)), vec!(\"hi\".to_strbuf()));\n+    assert_eq!(bar::<int, Vec<int> >(vec!(4, 5)), vec!(\"4\".to_strbuf(), \"5\".to_strbuf()));\n+    assert_eq!(bar::<StrBuf, Vec<StrBuf> >(vec!(\"x\".to_strbuf(), \"y\".to_strbuf())),\n+               vec!(\"x\".to_strbuf(), \"y\".to_strbuf()));\n+    assert_eq!(bar::<(), Vec<()>>(vec!(())), vec!(\"()\".to_strbuf()));\n }"}, {"sha": "5d22199e4a5400befe28294f5444c65d47bda331", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -11,30 +11,34 @@\n \n \n trait to_str {\n-    fn to_string(&self) -> ~str;\n+    fn to_string(&self) -> StrBuf;\n }\n \n impl to_str for int {\n-    fn to_string(&self) -> ~str { self.to_str() }\n+    fn to_string(&self) -> StrBuf { self.to_str().to_strbuf() }\n }\n \n impl<T:to_str> to_str for Vec<T> {\n-    fn to_string(&self) -> ~str {\n-        format!(\"[{}]\", self.iter().map(|e| e.to_string()).collect::<Vec<~str>>().connect(\", \"))\n+    fn to_string(&self) -> StrBuf {\n+        format_strbuf!(\"[{}]\",\n+                       self.iter()\n+                           .map(|e| e.to_string())\n+                           .collect::<Vec<StrBuf>>()\n+                           .connect(\", \"))\n     }\n }\n \n pub fn main() {\n-    assert!(1.to_string() == \"1\".to_owned());\n-    assert!((vec!(2, 3, 4)).to_string() == \"[2, 3, 4]\".to_owned());\n+    assert!(1.to_string() == \"1\".to_strbuf());\n+    assert!((vec!(2, 3, 4)).to_string() == \"[2, 3, 4]\".to_strbuf());\n \n-    fn indirect<T:to_str>(x: T) -> ~str {\n-        x.to_string() + \"!\"\n+    fn indirect<T:to_str>(x: T) -> StrBuf {\n+        format_strbuf!(\"{}!\", x.to_string())\n     }\n-    assert!(indirect(vec!(10, 20)) == \"[10, 20]!\".to_owned());\n+    assert!(indirect(vec!(10, 20)) == \"[10, 20]!\".to_strbuf());\n \n-    fn indirect2<T:to_str>(x: T) -> ~str {\n+    fn indirect2<T:to_str>(x: T) -> StrBuf {\n         indirect(x)\n     }\n-    assert!(indirect2(vec!(1)) == \"[1]!\".to_owned());\n+    assert!(indirect2(vec!(1)) == \"[1]!\".to_strbuf());\n }"}, {"sha": "db5be5f938ae7daf6667c45b05f1b6abd84e96cc", "filename": "src/test/run-pass/traits-default-method-macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftraits-default-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Ftraits-default-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-default-method-macro.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,8 +10,8 @@\n \n \n trait Foo {\n-    fn bar(&self) -> ~str {\n-        format!(\"test\")\n+    fn bar(&self) -> StrBuf {\n+        format_strbuf!(\"test\")\n     }\n }\n \n@@ -24,5 +24,5 @@ impl Foo for Baz {\n \n pub fn main() {\n     let q = Quux;\n-    assert_eq!(q.bar(), \"test\".to_owned());\n+    assert_eq!(q.bar(), \"test\".to_strbuf());\n }"}, {"sha": "a12483c1d78121e4e27ed05d9f9783fa1accb285", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -24,27 +24,27 @@ pub fn main() {\n     assert_eq!(pi as int, '\\u03a0' as int);\n     assert_eq!('\\x0a' as int, '\\n' as int);\n \n-    let bhutan: ~str = \"\u0f60\u0f56\u0fb2\u0f74\u0f42\u0f0b\u0f61\u0f74\u0f63\u0f0d\".to_owned();\n-    let japan: ~str = \"\u65e5\u672c\".to_owned();\n-    let uzbekistan: ~str = \"\u040e\u0437\u0431\u0435\u043a\u0438\u0441\u0442\u043e\u043d\".to_owned();\n-    let austria: ~str = \"\u00d6sterreich\".to_owned();\n-\n-    let bhutan_e: ~str =\n-        \"\\u0f60\\u0f56\\u0fb2\\u0f74\\u0f42\\u0f0b\\u0f61\\u0f74\\u0f63\\u0f0d\".to_owned();\n-    let japan_e: ~str = \"\\u65e5\\u672c\".to_owned();\n-    let uzbekistan_e: ~str =\n-        \"\\u040e\\u0437\\u0431\\u0435\\u043a\\u0438\\u0441\\u0442\\u043e\\u043d\".to_owned();\n-    let austria_e: ~str = \"\\u00d6sterreich\".to_owned();\n+    let bhutan: StrBuf = \"\u0f60\u0f56\u0fb2\u0f74\u0f42\u0f0b\u0f61\u0f74\u0f63\u0f0d\".to_strbuf();\n+    let japan: StrBuf = \"\u65e5\u672c\".to_strbuf();\n+    let uzbekistan: StrBuf = \"\u040e\u0437\u0431\u0435\u043a\u0438\u0441\u0442\u043e\u043d\".to_strbuf();\n+    let austria: StrBuf = \"\u00d6sterreich\".to_strbuf();\n+\n+    let bhutan_e: StrBuf =\n+        \"\\u0f60\\u0f56\\u0fb2\\u0f74\\u0f42\\u0f0b\\u0f61\\u0f74\\u0f63\\u0f0d\".to_strbuf();\n+    let japan_e: StrBuf = \"\\u65e5\\u672c\".to_strbuf();\n+    let uzbekistan_e: StrBuf =\n+        \"\\u040e\\u0437\\u0431\\u0435\\u043a\\u0438\\u0441\\u0442\\u043e\\u043d\".to_strbuf();\n+    let austria_e: StrBuf = \"\\u00d6sterreich\".to_strbuf();\n \n     let oo: char = '\u00d6';\n     assert_eq!(oo as int, 0xd6);\n \n-    fn check_str_eq(a: ~str, b: ~str) {\n+    fn check_str_eq(a: StrBuf, b: StrBuf) {\n         let mut i: int = 0;\n-        for ab in a.bytes() {\n+        for ab in a.as_slice().bytes() {\n             println!(\"{}\", i);\n             println!(\"{}\", ab);\n-            let bb: u8 = b[i as uint];\n+            let bb: u8 = b.as_slice()[i as uint];\n             println!(\"{}\", bb);\n             assert_eq!(ab, bb);\n             i += 1;"}, {"sha": "2e0e1af43b4eb35d1af9bfffeadc28a852004c76", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -13,15 +13,15 @@ use std::str;\n pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: Vec<char> = vec!('e', '\u00e9', '\u20ac', '\\U00010000');\n-    let s: ~str = str::from_chars(chs.as_slice());\n-    let schs: Vec<char> = s.chars().collect();\n+    let s: StrBuf = str::from_chars(chs.as_slice()).to_strbuf();\n+    let schs: Vec<char> = s.as_slice().chars().collect();\n \n     assert!(s.len() == 10u);\n-    assert!(s.char_len() == 4u);\n+    assert!(s.as_slice().char_len() == 4u);\n     assert!(schs.len() == 4u);\n-    assert!(str::from_chars(schs.as_slice()) == s);\n-    assert!(s.char_at(0u) == 'e');\n-    assert!(s.char_at(1u) == '\u00e9');\n+    assert!(str::from_chars(schs.as_slice()).to_strbuf() == s);\n+    assert!(s.as_slice().char_at(0u) == 'e');\n+    assert!(s.as_slice().char_at(1u) == '\u00e9');\n \n     assert!((str::is_utf8(s.as_bytes())));\n     // invalid prefix"}, {"sha": "e26c592a0648725654a4fe91b11fb8ad0b8769f9", "filename": "src/test/run-pass/variant-attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fvariant-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fvariant-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariant-attributes.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -34,6 +34,6 @@ enum crew_of_enterprise_d {\n     geordi_la_forge,\n }\n \n-fn boldly_go(_crew_member: crew_of_enterprise_d, _where: ~str) { }\n+fn boldly_go(_crew_member: crew_of_enterprise_d, _where: StrBuf) { }\n \n-pub fn main() { boldly_go(worf, \"where no one has gone before\".to_owned()); }\n+pub fn main() { boldly_go(worf, \"where no one has gone before\".to_strbuf()); }"}, {"sha": "8d2f29d9b09772b43efdd4e97ac1b67f4ff13cbe", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10fd317211511c3fb4656aee10eb4fd17dc8586/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=e10fd317211511c3fb4656aee10eb4fd17dc8586", "patch": "@@ -10,29 +10,29 @@\n \n \n struct Foo {\n-    string: ~str\n+    string: StrBuf\n }\n \n pub fn main() {\n     let x = [\n-        Foo { string: \"foo\".to_owned() },\n-        Foo { string: \"bar\".to_owned() },\n-        Foo { string: \"baz\".to_owned() }\n+        Foo { string: \"foo\".to_strbuf() },\n+        Foo { string: \"bar\".to_strbuf() },\n+        Foo { string: \"baz\".to_strbuf() }\n     ];\n     match x {\n         [ref first, ..tail] => {\n-            assert!(first.string == \"foo\".to_owned());\n+            assert!(first.string == \"foo\".to_strbuf());\n             assert_eq!(tail.len(), 2);\n-            assert!(tail[0].string == \"bar\".to_owned());\n-            assert!(tail[1].string == \"baz\".to_owned());\n+            assert!(tail[0].string == \"bar\".to_strbuf());\n+            assert!(tail[1].string == \"baz\".to_strbuf());\n \n             match tail {\n                 [Foo { .. }, _, Foo { .. }, .. _tail] => {\n                     unreachable!();\n                 }\n                 [Foo { string: ref a }, Foo { string: ref b }] => {\n-                    assert_eq!(\"bar\", a.slice(0, a.len()));\n-                    assert_eq!(\"baz\", b.slice(0, b.len()));\n+                    assert_eq!(\"bar\", a.as_slice().slice(0, a.len()));\n+                    assert_eq!(\"baz\", b.as_slice().slice(0, b.len()));\n                 }\n                 _ => {\n                     unreachable!();"}]}