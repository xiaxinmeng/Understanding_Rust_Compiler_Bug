{"sha": "d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e", "node_id": "C_kwDOAAsO6NoAKGQ0ZDFjYzRkYjZlMGZiMWY1NDI3ZmNiZWNlN2IwNGJmYjc5NTJkOWU", "commit": {"author": {"name": "Nathan Fenner", "email": "nfenneremail@gmail.com", "date": "2023-03-24T03:24:37Z"}, "committer": {"name": "Nathan Fenner", "email": "nfenneremail@gmail.com", "date": "2023-03-24T03:24:37Z"}, "message": "Make helper functions private", "tree": {"sha": "d3ef727d73209c5410a9e7425679ec87a1c277ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3ef727d73209c5410a9e7425679ec87a1c277ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e", "html_url": "https://github.com/rust-lang/rust/commit/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e/comments", "author": {"login": "Nathan-Fenner", "id": 6179181, "node_id": "MDQ6VXNlcjYxNzkxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6179181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nathan-Fenner", "html_url": "https://github.com/Nathan-Fenner", "followers_url": "https://api.github.com/users/Nathan-Fenner/followers", "following_url": "https://api.github.com/users/Nathan-Fenner/following{/other_user}", "gists_url": "https://api.github.com/users/Nathan-Fenner/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nathan-Fenner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nathan-Fenner/subscriptions", "organizations_url": "https://api.github.com/users/Nathan-Fenner/orgs", "repos_url": "https://api.github.com/users/Nathan-Fenner/repos", "events_url": "https://api.github.com/users/Nathan-Fenner/events{/privacy}", "received_events_url": "https://api.github.com/users/Nathan-Fenner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nathan-Fenner", "id": 6179181, "node_id": "MDQ6VXNlcjYxNzkxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6179181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nathan-Fenner", "html_url": "https://github.com/Nathan-Fenner", "followers_url": "https://api.github.com/users/Nathan-Fenner/followers", "following_url": "https://api.github.com/users/Nathan-Fenner/following{/other_user}", "gists_url": "https://api.github.com/users/Nathan-Fenner/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nathan-Fenner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nathan-Fenner/subscriptions", "organizations_url": "https://api.github.com/users/Nathan-Fenner/orgs", "repos_url": "https://api.github.com/users/Nathan-Fenner/repos", "events_url": "https://api.github.com/users/Nathan-Fenner/events{/privacy}", "received_events_url": "https://api.github.com/users/Nathan-Fenner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7281249a19a9755e9d889ee251ec323629caadab", "url": "https://api.github.com/repos/rust-lang/rust/commits/7281249a19a9755e9d889ee251ec323629caadab", "html_url": "https://github.com/rust-lang/rust/commit/7281249a19a9755e9d889ee251ec323629caadab"}], "stats": {"total": 62, "additions": 30, "deletions": 32}, "files": [{"sha": "a148742c1cb9caeb59b15cf9fac4e1b419fb207b", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e", "patch": "@@ -302,7 +302,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n+                find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -348,7 +348,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n+            .filter(|(_, ty)| find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n@@ -571,8 +571,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Find out which of `in_ty_elements` refer to `param`.\n             // FIXME: It may be better to take the first if there are multiple,\n             // just so that the error points to a smaller expression.\n-            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n-                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            let Some((drill_expr, drill_ty)) = is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                find_param_in_ty((*in_ty_elem).into(), param)\n             })) else {\n                 // The param is not mentioned, or it is mentioned in multiple indexes.\n                 return Err(expr);\n@@ -620,10 +620,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -729,10 +729,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -771,14 +771,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //     outer contextual information.\n \n             // (1) Find the (unique) field index which mentions the type in our constraint:\n-            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+            let Some((field_index, field_type)) = is_iterator_singleton(\n                 in_ty_adt\n                     .variant_with_id(variant_def_id)\n                     .fields\n                     .iter()\n                     .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n                     .enumerate()\n-                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+                    .filter(|(_index, field_type)| find_param_in_ty((*field_type).into(), param))\n             ) else {\n                 return Err(expr);\n             };\n@@ -811,20 +811,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         Err(expr)\n     }\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n-    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n-    pub fn find_param_in_ty(\n-        ty: ty::GenericArg<'tcx>,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-    ) -> bool {\n-        let mut walk = ty.walk();\n-        while let Some(arg) = walk.next() {\n-            if arg == param_to_point_at {\n-                return true;\n-            }\n-            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+/// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+/// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+fn find_param_in_ty<'tcx>(\n+    ty: ty::GenericArg<'tcx>,\n+    param_to_point_at: ty::GenericArg<'tcx>,\n+) -> bool {\n+    let mut walk = ty.walk();\n+    while let Some(arg) = walk.next() {\n+        if arg == param_to_point_at {\n+            return true;\n+        }\n+        if let ty::GenericArgKind::Type(ty) = arg.unpack()\n                 && let ty::Alias(ty::Projection, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n@@ -835,16 +835,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // in some UI tests.\n                 walk.skip_current_subtree();\n             }\n-        }\n-        false\n     }\n+    false\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n-    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n-        match (iterator.next(), iterator.next()) {\n-            (_, Some(_)) => None,\n-            (first, _) => first,\n-        }\n+/// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+    match (iterator.next(), iterator.next()) {\n+        (_, Some(_)) => None,\n+        (first, _) => first,\n     }\n }"}]}