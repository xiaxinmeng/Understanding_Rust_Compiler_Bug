{"sha": "136ab3c6b1efc6605f317280f13d53a940ea7a8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNmFiM2M2YjFlZmM2NjA1ZjMxNzI4MGYxM2Q1M2E5NDBlYTdhOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-04T00:17:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-04T00:17:04Z"}, "message": "auto merge of #17731 : bkoropoff/rust/unboxed-by-ref, r=pcwalton\n\nThis began as an attempt to fix an ICE in borrowck (issue #17655), but the rabbit hole went pretty deep.  I ended up plumbing support for capture-by-reference unboxed closures all the way into trans.\r\n\r\nCloses issue #17655.", "tree": {"sha": "a0cd460c7c3bf082cf843bdfd06848f7aea76e65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0cd460c7c3bf082cf843bdfd06848f7aea76e65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/136ab3c6b1efc6605f317280f13d53a940ea7a8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/136ab3c6b1efc6605f317280f13d53a940ea7a8e", "html_url": "https://github.com/rust-lang/rust/commit/136ab3c6b1efc6605f317280f13d53a940ea7a8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/136ab3c6b1efc6605f317280f13d53a940ea7a8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c348550f4f188bd127b85ed20b1e63fd42622e96", "url": "https://api.github.com/repos/rust-lang/rust/commits/c348550f4f188bd127b85ed20b1e63fd42622e96", "html_url": "https://github.com/rust-lang/rust/commit/c348550f4f188bd127b85ed20b1e63fd42622e96"}, {"sha": "521ca31071c01b21de40ce3477a81972103b3db9", "url": "https://api.github.com/repos/rust-lang/rust/commits/521ca31071c01b21de40ce3477a81972103b3db9", "html_url": "https://github.com/rust-lang/rust/commit/521ca31071c01b21de40ce3477a81972103b3db9"}], "stats": {"total": 185, "additions": 147, "deletions": 38}, "files": [{"sha": "605d3f6d6ced0d1d32d2791e15fa926940a63bda", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -596,17 +596,21 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           ty::FnMutUnboxedClosureKind => ast::Many,\n                           ty::FnOnceUnboxedClosureKind => ast::Once,\n                       };\n-                      Ok(Rc::new(cmt_ {\n-                          id: id,\n-                          span: span,\n-                          cat: cat_copied_upvar(CopiedUpvar {\n-                              upvar_id: var_id,\n-                              onceness: onceness,\n-                              capturing_proc: fn_node_id,\n-                          }),\n-                          mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n-                          ty: expr_ty\n-                      }))\n+                      if self.typer.capture_mode(fn_node_id) == ast::CaptureByRef {\n+                          self.cat_upvar(id, span, var_id, fn_node_id)\n+                      } else {\n+                          Ok(Rc::new(cmt_ {\n+                              id: id,\n+                              span: span,\n+                              cat: cat_copied_upvar(CopiedUpvar {\n+                                  upvar_id: var_id,\n+                                  onceness: onceness,\n+                                  capturing_proc: fn_node_id,\n+                              }),\n+                              mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n+                              ty: expr_ty\n+                          }))\n+                      }\n                   }\n                   _ => {\n                       self.tcx().sess.span_bug("}, {"sha": "1e2e8c589c66345f0092303fc7824846e32c4f3b", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -301,6 +301,7 @@ fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n+                                    freevar_mode: ast::CaptureClause,\n                                     freevars: &Vec<ty::Freevar>,\n                                     closure_id: ast::DefId)\n                                     -> Block<'blk, 'tcx> {\n@@ -326,11 +327,14 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n     };\n \n     for (i, freevar) in freevars.iter().enumerate() {\n-        let upvar_ptr = GEPi(bcx, llenv, [0, i]);\n+        let mut upvar_ptr = GEPi(bcx, llenv, [0, i]);\n+        if freevar_mode == ast::CaptureByRef {\n+            upvar_ptr = Load(bcx, upvar_ptr);\n+        }\n         let def_id = freevar.def.def_id();\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n \n-        if kind == ty::FnOnceUnboxedClosureKind {\n+        if kind == ty::FnOnceUnboxedClosureKind && freevar_mode == ast::CaptureByValue {\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n                                       node_id_type(bcx, def_id.node))\n@@ -477,6 +481,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     let freevars: Vec<ty::Freevar> =\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n     let freevars_ptr = &freevars;\n+    let freevar_mode = bcx.tcx().capture_mode(id);\n \n     trans_closure(bcx.ccx(),\n                   decl,\n@@ -493,6 +498,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   |bcx, arg_scope| {\n                       load_unboxed_closure_environment(bcx,\n                                                        arg_scope,\n+                                                       freevar_mode,\n                                                        freevars_ptr,\n                                                        closure_id)\n                   });\n@@ -518,7 +524,14 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                                                    dest_addr,\n                                                    0,\n                                                    i);\n-        bcx = datum.store_to(bcx, upvar_slot_dest);\n+        match freevar_mode {\n+            ast::CaptureByValue => {\n+                bcx = datum.store_to(bcx, upvar_slot_dest);\n+            }\n+            ast::CaptureByRef => {\n+                Store(bcx, datum.to_llref(), upvar_slot_dest);\n+            }\n+        }\n     }\n     adt::trans_set_discr(bcx, &*repr, dest_addr, 0);\n "}, {"sha": "10bc1da3acb54ae3962b47770806c2f06b0be9ed", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -4634,15 +4634,27 @@ pub struct UnboxedClosureUpvar {\n pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n                               -> Vec<UnboxedClosureUpvar> {\n     if closure_id.krate == ast::LOCAL_CRATE {\n+        let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n         match tcx.freevars.borrow().find(&closure_id.node) {\n             None => vec![],\n             Some(ref freevars) => {\n                 freevars.iter().map(|freevar| {\n                     let freevar_def_id = freevar.def.def_id();\n+                    let mut freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n+                    if capture_mode == ast::CaptureByRef {\n+                        let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n+                            var_id: freevar_def_id.node,\n+                            closure_expr_id: closure_id.node\n+                        });\n+                        freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n+                            ty: freevar_ty,\n+                            mutbl: borrow.kind.to_mutbl_lossy()\n+                        });\n+                    }\n                     UnboxedClosureUpvar {\n                         def: freevar.def,\n                         span: freevar.span,\n-                        ty: node_id_to_type(tcx, freevar_def_id.node),\n+                        ty: freevar_ty\n                     }\n                 }).collect()\n             }"}, {"sha": "058b3ac9e6ec1630d74dc755c60f13085b85fb6b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -836,7 +836,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                     // has static lifetime.\n                 } else {\n                     // Variables being referenced must outlive closure.\n-                    constrain_free_variables_in_stack_closure(\n+                    constrain_free_variables_in_by_ref_closure(\n                         rcx, bounds.region_bound, expr, freevars);\n \n                     // Closure is stack allocated and hence cannot\n@@ -848,20 +848,17 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             });\n         }\n         ty::ty_unboxed_closure(_, region) => {\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                // No free variables means that there is no environment and\n-                // hence the closure has static lifetime. Otherwise, the\n-                // closure must not outlive the variables it closes over\n-                // by-reference.\n-                //\n-                // NDM -- this seems wrong, discuss with pcwalton, should\n-                // be straightforward enough.\n-                if !freevars.is_empty() {\n-                    let bounds = ty::region_existential_bound(region);\n-                    ensure_free_variable_types_outlive_closure_bound(\n-                        rcx, bounds, expr, freevars);\n-                }\n-            })\n+            let bounds = ty::region_existential_bound(region);\n+            if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n+                ty::with_freevars(tcx, expr.id, |freevars| {\n+                    if !freevars.is_empty() {\n+                        // Variables being referenced must be constrained and registered\n+                        // in the upvar borrow map\n+                        constrain_free_variables_in_by_ref_closure(\n+                            rcx, bounds.region_bound, expr, freevars);\n+                    }\n+                })\n+            }\n         }\n         _ => { }\n     }\n@@ -876,6 +873,13 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n             })\n         }\n+        ty::ty_unboxed_closure(..) => {\n+            if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n+                ty::with_freevars(tcx, expr.id, |freevars| {\n+                    propagate_upupvar_borrow_kind(rcx, expr, freevars);\n+                });\n+            }\n+        }\n         _ => {}\n     }\n \n@@ -885,6 +889,12 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n             })\n         }\n+        ty::ty_unboxed_closure(_, region) => {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n+                let bounds = ty::region_existential_bound(region);\n+                ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n+            })\n+        }\n         _ => {}\n     }\n \n@@ -951,7 +961,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         }\n     }\n \n-    fn constrain_free_variables_in_stack_closure(\n+    fn constrain_free_variables_in_by_ref_closure(\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,"}, {"sha": "2a71aeaca5f3546d9d4dea9258b90b27f9b5c849", "filename": "src/test/compile-fail/unboxed-closure-region.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that an unboxed closure that captures a free variable by\n+// reference cannot escape the region of that variable.\n+fn main() {\n+    let _f = {\n+        let x = 0u;\n+        |:| x //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    };\n+}"}, {"sha": "baf7f3f5e58a4f454c83272b30f252fa62bb6f7a", "filename": "src/test/compile-fail/unboxed-closures-borrow-conflict.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-borrow-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-borrow-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-borrow-conflict.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that an unboxed closure that mutates a free variable will\n+// cause borrow conflicts.\n+\n+fn main() {\n+    let mut x = 0u;\n+    let f = |:| x += 1;\n+    let _y = x; //~ ERROR cannot use `x` because it was mutably borrowed\n+}"}, {"sha": "a826f4df5b349f39a9fc8c5826f99eb114d4312a", "filename": "src/test/run-pass/capture-clauses-unboxed-closures.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -8,13 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test\n-//\n-// This is ignored because it depends on #16122.\n-\n #![feature(overloaded_calls, unboxed_closures)]\n \n-fn each<'a,T,F:|&mut: &'a T|>(x: &'a [T], mut f: F) {\n+fn each<'a,T,F:FnMut(&'a T)>(x: &'a [T], mut f: F) {\n     for val in x.iter() {\n         f(val)\n     }\n@@ -23,7 +19,6 @@ fn each<'a,T,F:|&mut: &'a T|>(x: &'a [T], mut f: F) {\n fn main() {\n     let mut sum = 0u;\n     let elems = [ 1u, 2, 3, 4, 5 ];\n-    each(elems, ref |&mut: val: &uint| sum += *val);\n+    each(elems, |&mut: val: &uint| sum += *val);\n     assert_eq!(sum, 15);\n }\n-"}, {"sha": "2ee28d19b75a986fa614c6672f82895f2a4b8cd0", "filename": "src/test/run-pass/unboxed-closures-by-ref.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136ab3c6b1efc6605f317280f13d53a940ea7a8e/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs?ref=136ab3c6b1efc6605f317280f13d53a940ea7a8e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls, unboxed_closures)]\n+\n+// Test by-ref capture of environment in unboxed closure types\n+\n+fn call_fn<F: Fn()>(f: F) {\n+    f()\n+}\n+\n+fn call_fn_mut<F: FnMut()>(mut f: F) {\n+    f()\n+}\n+\n+fn call_fn_once<F: FnOnce()>(f: F) {\n+    f()\n+}\n+\n+fn main() {\n+    let mut x = 0u;\n+    let y = 2u;\n+\n+    call_fn(|&:| x += y);\n+    call_fn_mut(|&mut:| x += y);\n+    call_fn_once(|:| x += y);\n+    assert_eq!(x, y * 3);\n+}"}]}