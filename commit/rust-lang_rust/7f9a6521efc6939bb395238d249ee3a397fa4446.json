{"sha": "7f9a6521efc6939bb395238d249ee3a397fa4446", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOWE2NTIxZWZjNjkzOWJiMzk1MjM4ZDI0OWVlM2EzOTdmYTQ0NDY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-26T23:11:13Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-26T23:11:13Z"}, "message": "Merge #686\n\n686: Handle cycles in type vars r=matklad a=flodiebold\n\nThis might be the cause of #587.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "7a90002872ed3a2ea6d6df369519053e277d1a1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a90002872ed3a2ea6d6df369519053e277d1a1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f9a6521efc6939bb395238d249ee3a397fa4446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9a6521efc6939bb395238d249ee3a397fa4446", "html_url": "https://github.com/rust-lang/rust/commit/7f9a6521efc6939bb395238d249ee3a397fa4446", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f9a6521efc6939bb395238d249ee3a397fa4446/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e40d8d40321b191ee82b8b07910f8a0898c8914c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40d8d40321b191ee82b8b07910f8a0898c8914c", "html_url": "https://github.com/rust-lang/rust/commit/e40d8d40321b191ee82b8b07910f8a0898c8914c"}, {"sha": "94bbb2418aa5201ddf2d5faf01f349896303cb82", "url": "https://api.github.com/repos/rust-lang/rust/commits/94bbb2418aa5201ddf2d5faf01f349896303cb82", "html_url": "https://github.com/rust-lang/rust/commit/94bbb2418aa5201ddf2d5faf01f349896303cb82"}], "stats": {"total": 106, "additions": 97, "deletions": 9}, "files": [{"sha": "d704c3adb8a7163f97d0b4192fc5cebfccc0c73c", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=7f9a6521efc6939bb395238d249ee3a397fa4446", "patch": "@@ -1,4 +1,6 @@\n test_utils::marks!(\n     name_res_works_for_broken_modules\n     item_map_enum_importing\n+    type_var_cycles_resolve_completely\n+    type_var_cycles_resolve_as_possible\n );"}, {"sha": "31ea4570627d57821908abbacceb253695019367", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=7f9a6521efc6939bb395238d249ee3a397fa4446", "patch": "@@ -29,6 +29,8 @@ use ra_arena::map::ArenaMap;\n use join_to_string::join;\n use rustc_hash::FxHashMap;\n \n+use test_utils::tested_by;\n+\n use crate::{\n     Module, Function, Struct, StructField, Enum, EnumVariant, Path, Name, ImplBlock,\n     FnSignature, FnScopes, ModuleDef, AdtDef,\n@@ -862,14 +864,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_all(mut self) -> InferenceResult {\n+        let mut tv_stack = Vec::new();\n         let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n         for ty in expr_types.values_mut() {\n-            let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         let mut pat_types = mem::replace(&mut self.type_of_pat, ArenaMap::default());\n         for ty in pat_types.values_mut() {\n-            let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         InferenceResult {\n@@ -1014,13 +1017,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n-    fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n+    fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_as_possible);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n                 if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n-                    self.resolve_ty_as_possible(known_ty.clone())\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_as_possible(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n                 } else {\n                     ty\n                 }\n@@ -1049,13 +1060,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     /// Resolves the type completely; type variables without known type are\n     /// replaced by Ty::Unknown.\n-    fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n+    fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_completely);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n                 if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n-                    self.resolve_ty_completely(known_ty.clone())\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_completely(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n                 } else {\n                     tv.fallback_value()\n                 }\n@@ -1070,7 +1089,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n             if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n                 let ty = self.type_of_pat.get(scope_entry.pat())?;\n-                let ty = self.resolve_ty_as_possible(ty.clone());\n+                let ty = self.resolve_ty_as_possible(&mut vec![], ty.clone());\n                 return Some(ty);\n             };\n         };\n@@ -1239,7 +1258,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, expected);\n-        let ty = self.resolve_ty_as_possible(ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }\n@@ -1538,7 +1557,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, &expected.ty);\n-        let ty = self.resolve_ty_as_possible(ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }"}, {"sha": "c3227ff7eac45c7fe459c15a8f3c0287461d15b1", "filename": "crates/ra_hir/src/ty/snapshots/tests__recursive_vars.snap", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars.snap", "raw_url": "https://github.com/rust-lang/rust/raw/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars.snap?ref=7f9a6521efc6939bb395238d249ee3a397fa4446", "patch": "@@ -0,0 +1,14 @@\n+---\n+created: \"2019-01-26T22:42:22.329980185+00:00\"\n+creator: insta@0.5.2\n+expression: \"&result\"\n+source: crates/ra_hir/src/ty/tests.rs\n+---\n+[11; 48) '{     ...&y]; }': ()\n+[21; 22) 'y': &[unknown]\n+[25; 32) 'unknown': &[unknown]\n+[38; 45) '[y, &y]': [&&[unknown]]\n+[39; 40) 'y': &[unknown]\n+[42; 44) '&y': &&[unknown]\n+[43; 44) 'y': &[unknown]\n+"}, {"sha": "de124da5b12e4e35e2db37a0a2f36d4903561953", "filename": "crates/ra_hir/src/ty/snapshots/tests__recursive_vars_2.snap", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars_2.snap", "raw_url": "https://github.com/rust-lang/rust/raw/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars_2.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars_2.snap?ref=7f9a6521efc6939bb395238d249ee3a397fa4446", "patch": "@@ -0,0 +1,21 @@\n+---\n+created: \"2019-01-26T22:42:22.331805845+00:00\"\n+creator: insta@0.5.2\n+expression: \"&result\"\n+source: crates/ra_hir/src/ty/tests.rs\n+---\n+[11; 80) '{     ...x)]; }': ()\n+[21; 22) 'x': &&[unknown]\n+[25; 32) 'unknown': &&[unknown]\n+[42; 43) 'y': &&[unknown]\n+[46; 53) 'unknown': &&[unknown]\n+[59; 77) '[(x, y..., &x)]': [(&&[unknown], &&[unknown])]\n+[60; 66) '(x, y)': (&&[unknown], &&[unknown])\n+[61; 62) 'x': &&[unknown]\n+[64; 65) 'y': &&[unknown]\n+[68; 76) '(&y, &x)': (&&&[unknown], &&&[unknown])\n+[69; 71) '&y': &&&[unknown]\n+[70; 71) 'y': &&[unknown]\n+[73; 75) '&x': &&&[unknown]\n+[74; 75) 'x': &&[unknown]\n+"}, {"sha": "f74d6f5ea375126d52487097b3ea75c3153dce8a", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9a6521efc6939bb395238d249ee3a397fa4446/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=7f9a6521efc6939bb395238d249ee3a397fa4446", "patch": "@@ -3,6 +3,7 @@ use std::fmt::Write;\n \n use ra_db::{SourceDatabase, salsa::Database};\n use ra_syntax::ast::{self, AstNode};\n+use test_utils::covers;\n \n use crate::{\n     source_binder,\n@@ -562,6 +563,37 @@ fn quux() {\n     );\n }\n \n+#[test]\n+fn recursive_vars() {\n+    covers!(type_var_cycles_resolve_completely);\n+    covers!(type_var_cycles_resolve_as_possible);\n+    check_inference(\n+        \"recursive_vars\",\n+        r#\"\n+fn test() {\n+    let y = unknown;\n+    [y, &y];\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn recursive_vars_2() {\n+    covers!(type_var_cycles_resolve_completely);\n+    covers!(type_var_cycles_resolve_as_possible);\n+    check_inference(\n+        \"recursive_vars_2\",\n+        r#\"\n+fn test() {\n+    let x = unknown;\n+    let y = unknown;\n+    [(x, y), (&y, &x)];\n+}\n+\"#,\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);"}]}