{"sha": "ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiN2FiZmNmMzQ1N2ViYzY3YWM3ZmVmNWMzMDI4YTZhZTQ0MDIxNTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-21T08:04:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-21T08:04:57Z"}, "message": "Auto merge of #46754 - cramertj:refactor-arg-impl, r=nikomatsakis\n\nRefactor argument-position impl Trait\n\nFixes https://github.com/rust-lang/rust/issues/46685, https://github.com/rust-lang/rust/issues/46470\n\nr? @nikomatsakis\ncc @chrisvittal", "tree": {"sha": "637d0e2be9f929ff04b2360bd14d6802f002fe74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/637d0e2be9f929ff04b2360bd14d6802f002fe74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "html_url": "https://github.com/rust-lang/rust/commit/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "957dc8de634886143195a1e1a1e1a7d047afe164", "url": "https://api.github.com/repos/rust-lang/rust/commits/957dc8de634886143195a1e1a1e1a7d047afe164", "html_url": "https://github.com/rust-lang/rust/commit/957dc8de634886143195a1e1a1e1a7d047afe164"}, {"sha": "e502194e7e2605b461c3e24d30fdc5def4e1c166", "url": "https://api.github.com/repos/rust-lang/rust/commits/e502194e7e2605b461c3e24d30fdc5def4e1c166", "html_url": "https://github.com/rust-lang/rust/commit/e502194e7e2605b461c3e24d30fdc5def4e1c166"}], "stats": {"total": 277, "additions": 92, "deletions": 185}, "files": [{"sha": "3a1b0b8c58ebbf082239b982eba5c78e332def51", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -602,9 +602,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_lifetime, lifetimes);\n         }\n-        TyImplTraitUniversal(_, ref bounds) => {\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n-        }\n         TyTypeof(expression) => {\n             visitor.visit_nested_body(expression)\n         }"}, {"sha": "847cf64ce6a031f75cdae383ca9cec0e3cd37dc5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -61,6 +61,7 @@ use syntax::attr;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::codemap::{self, respan, Spanned, CompilerDesugaringKind};\n use syntax::std_inject;\n@@ -106,6 +107,13 @@ pub struct LoweringContext<'a> {\n     is_in_loop_condition: bool,\n     is_in_trait_impl: bool,\n \n+    // This is a list of in-band type definitions being generated by\n+    // Argument-position `impl Trait`.\n+    // When traversing a signature such as `fn foo(x: impl Trait)`,\n+    // we record `impl Trait` as a new type parameter, then later\n+    // add it on to `foo`s generics.\n+    in_band_ty_params: Vec<hir::TyParam>,\n+\n     // Used to create lifetime definitions from in-band lifetime usages.\n     // e.g. `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n     // When a named lifetime is encountered in a function or impl header and\n@@ -197,6 +205,7 @@ pub fn lower_crate(sess: &Session,\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n         is_in_trait_impl: false,\n+        in_band_ty_params: Vec::new(),\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n@@ -526,20 +535,23 @@ impl<'a> LoweringContext<'a> {\n     // Creates a new hir::LifetimeDef for every new lifetime encountered\n     // while evaluating `f`. Definitions are created with the parent provided.\n     // If no `parent_id` is provided, no definitions will be returned.\n-    fn collect_in_band_lifetime_defs<T, F>(\n+    fn collect_in_band_defs<T, F>(\n         &mut self,\n         parent_id: Option<DefId>,\n         f: F\n-    ) -> (Vec<hir::LifetimeDef>, T) where F: FnOnce(&mut LoweringContext) -> T\n+    ) -> (Vec<hir::TyParam>, Vec<hir::LifetimeDef>, T) where F: FnOnce(&mut LoweringContext) -> T\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n         self.is_collecting_in_band_lifetimes = self.sess.features.borrow().in_band_lifetimes;\n \n+        assert!(self.in_band_ty_params.is_empty());\n+\n         let res = f(self);\n \n         self.is_collecting_in_band_lifetimes = false;\n \n+        let in_band_ty_params = self.in_band_ty_params.split_off(0);\n         let lifetimes_to_define = self.lifetimes_to_define.split_off(0);\n \n         let lifetime_defs = match parent_id {\n@@ -569,7 +581,7 @@ impl<'a> LoweringContext<'a> {\n             None => Vec::new(),\n         };\n \n-        (lifetime_defs, res)\n+        (in_band_ty_params, lifetime_defs, res)\n     }\n \n     // Evaluates `f` with the lifetimes in `lt_defs` in-scope.\n@@ -613,29 +625,33 @@ impl<'a> LoweringContext<'a> {\n         res\n     }\n \n-    // Appends in-band lifetime defs to the existing set of out-of-band lifetime defs.\n-    // Evaluates all within the context of the out-of-band defs.\n-    // If provided, `impl_item_id` is used to find the parent impls of impl items so\n-    // that their generics are not duplicated.\n-    fn add_in_band_lifetime_defs<F, T>(\n+    // Appends in-band lifetime defs and argument-position `impl Trait` defs\n+    // to the existing set of generics.\n+    fn add_in_band_defs<F, T>(\n         &mut self,\n         generics: &Generics,\n         parent_id: Option<DefId>,\n         f: F\n     ) -> (hir::Generics, T)\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n-        let (in_band_defs, (mut lowered_generics, res)) =\n+        let (in_band_ty_defs, in_band_lifetime_defs, (mut lowered_generics, res)) =\n             self.with_in_scope_lifetime_defs(&generics.lifetimes, |this| {\n-                this.collect_in_band_lifetime_defs(parent_id, |this| {\n+                this.collect_in_band_defs(parent_id, |this| {\n                     (this.lower_generics(generics), f(this))\n                 })\n             });\n \n+        lowered_generics.ty_params =\n+            lowered_generics.ty_params\n+                .iter().cloned()\n+                .chain(in_band_ty_defs.into_iter())\n+                .collect();\n+\n         lowered_generics.lifetimes =\n             lowered_generics.lifetimes\n                 .iter().cloned()\n-               .chain(in_band_defs.into_iter())\n+               .chain(in_band_lifetime_defs.into_iter())\n                .collect();\n \n         (lowered_generics, res)\n@@ -922,6 +938,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             TyKind::ImplTrait(ref bounds) => {\n                 use syntax::feature_gate::{emit_feature_err, GateIssue};\n+                let span = t.span;\n                 match itctx {\n                     ImplTraitContext::Existential => {\n                         let has_feature = self.sess.features.borrow().conservative_impl_trait;\n@@ -944,7 +961,7 @@ impl<'a> LoweringContext<'a> {\n                                     id: self.next_id().node_id,\n                                     predicates: Vec::new().into(),\n                                 },\n-                                span: t.span,\n+                                span,\n                             },\n                             bounds: hir_bounds,\n                         }, lifetimes)\n@@ -956,7 +973,35 @@ impl<'a> LoweringContext<'a> {\n                                              t.span, GateIssue::Language,\n                                              \"`impl Trait` in argument position is experimental\");\n                         }\n-                        hir::TyImplTraitUniversal(def_id, self.lower_bounds(bounds, itctx))\n+\n+                        let def_node_id = self.next_id().node_id;\n+\n+                        // Add a definition for the in-band TyParam\n+                        let def_index = self.resolver.definitions().create_def_with_parent(\n+                            def_id.index,\n+                            def_node_id,\n+                            DefPathData::ImplTrait,\n+                            DefIndexAddressSpace::High,\n+                            Mark::root()\n+                        );\n+\n+                        let hir_bounds = self.lower_bounds(bounds, itctx);\n+                        self.in_band_ty_params.push(hir::TyParam {\n+                            // Set the name to `impl Bound1 + Bound2`\n+                            name: Symbol::intern(&pprust::ty_to_string(t)),\n+                            id: def_node_id,\n+                            bounds: hir_bounds,\n+                            default: None,\n+                            span,\n+                            pure_wrt_drop: false,\n+                            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                        });\n+\n+                        hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n+                            span,\n+                            def: Def::TyParam(DefId::local(def_index)),\n+                            segments: vec![].into(),\n+                        })))\n                     },\n                     ImplTraitContext::Disallowed => {\n                         span_err!(self.sess, t.span, E0562,\n@@ -1829,7 +1874,7 @@ impl<'a> LoweringContext<'a> {\n                         this.expr_block(body, ThinVec::new())\n                     });\n                     let (generics, fn_decl) =\n-                        this.add_in_band_lifetime_defs(generics, fn_def_id, |this|\n+                        this.add_in_band_defs(generics, fn_def_id, |this|\n                             this.lower_fn_decl(decl, fn_def_id, true));\n \n                     hir::ItemFn(fn_decl,\n@@ -1883,7 +1928,7 @@ impl<'a> LoweringContext<'a> {\n                            ref impl_items) => {\n                 let def_id = self.resolver.definitions().opt_local_def_id(id);\n                 let (generics, (ifce, lowered_ty)) =\n-                    self.add_in_band_lifetime_defs(ast_generics, def_id, |this| {\n+                    self.add_in_band_defs(ast_generics, def_id, |this| {\n                         let ifce = ifce.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed)\n                         });\n@@ -2059,7 +2104,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 TraitItemKind::Method(ref sig, None) => {\n                     let names = this.lower_fn_args_to_names(&sig.decl);\n-                    this.add_in_band_lifetime_defs(&i.generics, fn_def_id, |this|\n+                    this.add_in_band_defs(&i.generics, fn_def_id, |this|\n                         hir::TraitItemKind::Method(\n                             this.lower_method_sig(sig, fn_def_id, false),\n                             hir::TraitMethod::Required(names)))\n@@ -2070,7 +2115,7 @@ impl<'a> LoweringContext<'a> {\n                         this.expr_block(body, ThinVec::new())\n                     });\n \n-                    this.add_in_band_lifetime_defs(&i.generics, fn_def_id, |this|\n+                    this.add_in_band_defs(&i.generics, fn_def_id, |this|\n                         hir::TraitItemKind::Method(\n                             this.lower_method_sig(sig, fn_def_id, false),\n                            hir::TraitMethod::Provided(body_id)))\n@@ -2147,7 +2192,7 @@ impl<'a> LoweringContext<'a> {\n                     });\n                     let impl_trait_return_allow = !this.is_in_trait_impl;\n \n-                    this.add_in_band_lifetime_defs(&i.generics, fn_def_id, |this|\n+                    this.add_in_band_defs(&i.generics, fn_def_id, |this|\n                         hir::ImplItemKind::Method(\n                             this.lower_method_sig(sig, fn_def_id, impl_trait_return_allow),\n                             body_id))\n@@ -2280,7 +2325,7 @@ impl<'a> LoweringContext<'a> {\n                     ForeignItemKind::Fn(ref fdec, ref generics) => {\n                         // Disallow impl Trait in foreign items\n                         let (generics, (fn_dec, fn_args)) =\n-                            this.add_in_band_lifetime_defs(\n+                            this.add_in_band_defs(\n                                 generics,\n                                 Some(def_id),\n                                 |this| ("}, {"sha": "5e132865ca87d020e76ffc32e056434a75eb865f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -1511,7 +1511,7 @@ pub enum Ty_ {\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// An exsitentially quantified (there exists a type satisfying) `impl\n+    /// An existentially quantified (there exists a type satisfying) `impl\n     /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n     ///\n     /// The `ExistTy` structure emulates an\n@@ -1523,9 +1523,6 @@ pub enum Ty_ {\n     /// because all in-scope type parameters are captured by `impl Trait`,\n     /// so they are resolved directly through the parent `Generics`.\n     TyImplTraitExistential(ExistTy, HirVec<Lifetime>),\n-    /// An universally quantified (for all types satisfying) `impl\n-    /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n-    TyImplTraitUniversal(DefId, TyParamBounds),\n     /// Unused for now\n     TyTypeof(BodyId),\n     /// TyInfer means the type should be inferred instead of it having been"}, {"sha": "77469cb450bfaeffcd1a566604acc5a25ad4fc13", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -425,9 +425,6 @@ impl<'a> State<'a> {\n             hir::TyImplTraitExistential(ref existty, ref _lifetimes) => {\n                 self.print_bounds(\"impl\", &existty.bounds[..])?;\n             }\n-            hir::TyImplTraitUniversal(_, ref bounds) => {\n-                self.print_bounds(\"impl\", &bounds[..])?;\n-            }\n             hir::TyArray(ref ty, v) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;"}, {"sha": "02a394f9634c2da4332fe78341536b311336825e", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -312,7 +312,6 @@ impl_stable_hash_for!(enum hir::Ty_ {\n     TyPath(qpath),\n     TyTraitObject(trait_refs, lifetime),\n     TyImplTraitExistential(existty, lifetimes),\n-    TyImplTraitUniversal(def_id, bounds),\n     TyTypeof(body_id),\n     TyErr,\n     TyInfer"}, {"sha": "e976f08607a896a4dd9eed88d21e513ec93d4e45", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -2212,19 +2212,6 @@ fn insert_late_bound_lifetimes(\n         visit_where_predicate,\n         &generics.where_clause.predicates\n     );\n-    // We need to collect argument impl Trait lifetimes as well,\n-    // we do so here.\n-    walk_list!(\n-        &mut appears_in_where_clause,\n-        visit_ty,\n-        decl.inputs\n-            .iter()\n-            .filter(|ty| if let hir::TyImplTraitUniversal(..) = ty.node {\n-                true\n-            } else {\n-                false\n-            })\n-    );\n     for lifetime_def in &generics.lifetimes {\n         if !lifetime_def.bounds.is_empty() {\n             // `'a: 'b` means both `'a` and `'b` are referenced"}, {"sha": "4616b4cf80c97c676ea15dba22786b000f47fbf1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -30,7 +30,6 @@ use util::nodemap::FxHashSet;\n \n use std::iter;\n use syntax::{abi, ast};\n-use syntax::symbol::Symbol;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n \n@@ -1066,13 +1065,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let def_id = tcx.hir.local_def_id(ast_ty.id);\n                 self.impl_trait_ty_to_ty(def_id, lifetimes)\n             }\n-            hir::TyImplTraitUniversal(fn_def_id, _) => {\n-                let impl_trait_def_id = tcx.hir.local_def_id(ast_ty.id);\n-                let generics = tcx.generics_of(fn_def_id);\n-                let index = generics.type_param_to_index[&impl_trait_def_id.index];\n-                tcx.mk_param(index,\n-                             Symbol::intern(&tcx.hir.node_to_pretty_string(ast_ty.id)))\n-            }\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {"}, {"sha": "f51bdf050c715235cd7794293037132749740492", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 25, "deletions": 130, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -43,7 +43,6 @@ use rustc_const_math::ConstInt;\n use std::collections::BTreeMap;\n \n use syntax::{abi, ast};\n-use syntax::ptr::P;\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -880,32 +879,22 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut allow_defaults = false;\n \n     let no_generics = hir::Generics::empty();\n-    let (ast_generics, opt_inputs) = match node {\n-        NodeTraitItem(item) => {\n-            match item.node {\n-                TraitItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n-                _ => (&item.generics, None)\n-            }\n-        }\n+    let ast_generics = match node {\n+        NodeTraitItem(item) => &item.generics,\n \n-        NodeImplItem(item) => {\n-            match item.node {\n-                ImplItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n-                _ => (&item.generics, None)\n-            }\n-        }\n+        NodeImplItem(item) => &item.generics,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(ref decl, .., ref generics, _) => (generics, Some(&decl.inputs)),\n-                ItemImpl(_, _, _, ref generics, ..) => (generics, None),\n+                ItemFn(.., ref generics, _) |\n+                ItemImpl(_, _, _, ref generics, ..) => generics,\n \n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n                 ItemUnion(_, ref generics) => {\n                     allow_defaults = true;\n-                    (generics, None)\n+                    generics\n                 }\n \n                 ItemTrait(_, _, ref generics, ..) | ItemTraitAlias(ref generics, ..) => {\n@@ -926,26 +915,26 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     });\n \n                     allow_defaults = true;\n-                    (generics, None)\n+                    generics\n                 }\n \n-                _ => (&no_generics, None)\n+                _ => &no_generics,\n             }\n         }\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => (&no_generics, None),\n-                ForeignItemFn(ref decl, _, ref generics) => (generics, Some(&decl.inputs)),\n-                ForeignItemType => (&no_generics, None)\n+                ForeignItemStatic(..) => &no_generics,\n+                ForeignItemFn(_, _, ref generics) => generics,\n+                ForeignItemType => &no_generics,\n             }\n         }\n \n         NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(ref exist_ty, _), .. }) => {\n-            (&exist_ty.generics, None)\n+            &exist_ty.generics\n         }\n \n-        _ => (&no_generics, None)\n+        _ => &no_generics,\n     };\n \n     let has_self = opt_self.is_some();\n@@ -1003,23 +992,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     });\n \n-    let fn_ins = opt_inputs.map(|tys| &tys[..]);\n-    let univ_impl_trait_info = extract_universal_impl_trait_info(tcx, fn_ins);\n-    let other_type_start = type_start + ast_generics.ty_params.len() as u32;\n-    let mut types: Vec<_> = opt_self.into_iter()\n-        .chain(types)\n-        .chain(univ_impl_trait_info.iter().enumerate().map(|(i, info)| {\n-            ty::TypeParameterDef {\n-                index: other_type_start + i as u32,\n-                name: Symbol::intern(&tcx.hir.node_to_pretty_string(info.id)),\n-                def_id: info.def_id,\n-                has_default: false,\n-                object_lifetime_default: rl::Set1::Empty,\n-                pure_wrt_drop: false,\n-                synthetic: Some(SyntheticTyParamKind::ImplTrait),\n-            }\n-        }))\n-        .collect();\n+    let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n \n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n@@ -1419,50 +1392,36 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let no_generics = hir::Generics::empty();\n-    let (ast_generics, opt_inputs) = match node {\n-        NodeTraitItem(item) => {\n-            match item.node {\n-                TraitItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n-                _ => (&item.generics, None)\n-            }\n-        }\n-\n-        NodeImplItem(item) => {\n-            match item.node {\n-                ImplItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n-                _ => (&item.generics, None)\n-            }\n-        }\n+    let ast_generics = match node {\n+        NodeTraitItem(item) => &item.generics,\n+        NodeImplItem(item) => &item.generics,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(ref decl, .., ref generics, _) => (generics, Some(&decl.inputs)),\n-\n+                ItemFn(.., ref generics, _) |\n                 ItemImpl(_, _, _, ref generics, ..) |\n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n-                ItemUnion(_, ref generics) => {\n-                    (generics, None)\n-                }\n+                ItemUnion(_, ref generics) => generics,\n \n                 ItemTrait(_, _, ref generics, .., ref items) => {\n                     is_trait = Some((ty::TraitRef {\n                         def_id,\n                         substs: Substs::identity_for_item(tcx, def_id)\n                     }, items));\n-                    (generics, None)\n+                    generics\n                 }\n \n-                _ => (&no_generics, None)\n+                _ => &no_generics,\n             }\n         }\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => (&no_generics, None),\n-                ForeignItemFn(ref decl, _, ref generics) => (generics, Some(&decl.inputs)),\n-                ForeignItemType => (&no_generics, None),\n+                ForeignItemStatic(..) => &no_generics,\n+                ForeignItemFn(_, _, ref generics) => generics,\n+                ForeignItemType => &no_generics,\n             }\n         }\n \n@@ -1491,7 +1450,7 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n         }\n \n-        _ => (&no_generics, None)\n+        _ => &no_generics,\n     };\n \n     let generics = tcx.generics_of(def_id);\n@@ -1622,19 +1581,6 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }))\n     }\n \n-    // Add predicates from impl Trait arguments\n-    let fn_ins = opt_inputs.map(|tys| &tys[..]);\n-    let univ_impl_trait_info = extract_universal_impl_trait_info(tcx, fn_ins);\n-    for info in univ_impl_trait_info.iter() {\n-        let name = keywords::Invalid.name();\n-        let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n-        index += 1;\n-        let bounds = compute_bounds(&icx, param_ty, info.bounds,\n-                                    SizedByDefault::Yes,\n-                                    info.span);\n-        predicates.extend(bounds.predicates(tcx, param_ty));\n-    }\n-\n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come\n     // before uses of `U`.  This avoids false ambiguity errors\n@@ -1795,54 +1741,3 @@ fn is_auto_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => bug!(\"is_auto_impl applied to non-local def-id {:?}\", def_id)\n     }\n }\n-\n-struct ImplTraitUniversalInfo<'hir> {\n-    id: ast::NodeId,\n-    def_id: DefId,\n-    span: Span,\n-    bounds: &'hir [hir::TyParamBound],\n-}\n-\n-/// Take some possible list of arguments and return the DefIds of the ImplTraitUniversal\n-/// arguments\n-fn extract_universal_impl_trait_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               opt_inputs: Option<&'tcx [P<hir::Ty>]>)\n-                                               -> Vec<ImplTraitUniversalInfo<'tcx>>\n-{\n-    // A visitor for simply collecting Universally quantified impl Trait arguments\n-    struct ImplTraitUniversalVisitor<'tcx> {\n-        items: Vec<&'tcx hir::Ty>\n-    }\n-\n-    impl<'tcx> Visitor<'tcx> for ImplTraitUniversalVisitor<'tcx> {\n-        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-            NestedVisitorMap::None\n-        }\n-\n-        fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-            if let hir::TyImplTraitUniversal(..) = ty.node {\n-                self.items.push(ty);\n-            }\n-            intravisit::walk_ty(self, ty);\n-        }\n-    }\n-\n-    let mut visitor = ImplTraitUniversalVisitor { items: Vec::new() };\n-\n-    if let Some(inputs) = opt_inputs {\n-        for t in inputs.iter() {\n-            visitor.visit_ty(t);\n-        }\n-    }\n-\n-    visitor.items.into_iter().map(|ty| if let hir::TyImplTraitUniversal(_, ref bounds) = ty.node {\n-        ImplTraitUniversalInfo {\n-            id: ty.id,\n-            def_id: tcx.hir.local_def_id(ty.id),\n-            span: ty.span,\n-            bounds: bounds\n-        }\n-    } else {\n-        span_bug!(ty.span, \"this type should be a universally quantified impl trait. this is a bug\")\n-    }).collect()\n-}"}, {"sha": "56c39357f16a347c53aeeff3ed14d95745c69380", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -2154,7 +2154,6 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyImplTraitExistential(ref exist_ty, ref _lts) => ImplTrait(exist_ty.bounds.clean(cx)),\n-            TyImplTraitUniversal(_, ref bounds) => ImplTrait(bounds.clean(cx)),\n             TyInfer | TyErr => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }"}, {"sha": "a56f083e08f2fa5d3748c042a8aebfa6e4093a5b", "filename": "src/test/run-pass/impl-trait/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7abfcf3457ebc67ac7fef5c3028a6ae4402156/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs?ref=ab7abfcf3457ebc67ac7fef5c3028a6ae4402156", "patch": "@@ -57,9 +57,8 @@ fn pass_through_elision_with_fn_path<T: Fn(&u32) -> &u32>(\n     x: &T\n ) -> impl Into<&impl Fn(&u32) -> &u32> { x }\n \n-// FIXME(cramertj) Currently ICEing, part of issue #46685:\n-// fn foo(x: &impl Debug) -> impl Into<&impl Debug> { x }\n-// Works:\n+fn foo(x: &impl Debug) -> impl Into<&impl Debug> { x }\n+fn foo_explicit_lifetime<'a>(x: &'a impl Debug) -> impl Into<&'a impl Debug> { x }\n fn foo_no_outer_impl(x: &impl Debug) -> &impl Debug { x }\n fn foo_explicit_arg<T: Debug>(x: &T) -> impl Into<&impl Debug> { x }\n "}]}