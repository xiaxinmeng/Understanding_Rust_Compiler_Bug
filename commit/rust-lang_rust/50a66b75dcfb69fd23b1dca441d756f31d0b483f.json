{"sha": "50a66b75dcfb69fd23b1dca441d756f31d0b483f", "node_id": "C_kwDOAAsO6NoAKDUwYTY2Yjc1ZGNmYjY5ZmQyM2IxZGNhNDQxZDc1NmYzMWQwYjQ4M2Y", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-04T15:34:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-04T15:34:14Z"}, "message": "Rollup merge of #91754 - Patrick-Poitras:rm-4byte-minimum-stdio-windows, r=Mark-Simulacrum\n\nModifications to `std::io::Stdin` on Windows so that there is no longer a 4-byte buffer minimum in read().\n\nThis is an attempted fix of issue #91722, where a too-small buffer was passed to the read function of stdio on Windows. This caused an error to be returned when `read_to_end` or `read_to_string` were called. Both delegate to `std::io::default_read_to_end`, which creates a buffer that is of length >0, and forwards it to `std::io::Stdin::read()`. The latter method returns an error if the length of the buffer is less than 4, as there might not be enough space to allocate a UTF-16 character. This creates a problem when the buffer length is in `0 < N < 4`, causing the bug.\n\nThe current modification creates an internal buffer, much like the one used for the write functions\n\nI'd also like to acknowledge the help of ``@agausmann`` and ``@hkratz`` in detecting and isolating the bug, and for suggestions that made the fix possible.\n\nCouple disclaimers:\n\n- Firstly, I didn't know where to put code to replicate the bug found in the issue. It would probably be wise to add that case to the testing suite, but I'm afraid that I don't know _where_ that test should be added.\n- Secondly, the code is fairly fundamental to IO operations, so my fears are that this may cause some undesired side effects ~or performance loss in benchmarks.~ The testing suite runs on my computer, and it does fix the issue noted in #91722.\n- Thirdly, I left the \"surrogate\" field in the Stdin struct, but from a cursory glance, it seems to be serving the same purpose for other functions. Perhaps merging the two would be appropriate.\n\nFinally, this is my first pull request to the rust language, and as such some things may be weird/unidiomatic/plain out bad. If there are any obvious improvements I could do to the code, or any other suggestions, I would appreciate them.\n\nEdit: Closes #91722", "tree": {"sha": "79da2fb2fae5a69cd44c8a47985f20592bbd7e61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79da2fb2fae5a69cd44c8a47985f20592bbd7e61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50a66b75dcfb69fd23b1dca441d756f31d0b483f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1Gj2CRBK7hj4Ov3rIwAAgeAIAG93r61FSgexivE6PY6IgVRf\nE0ipllP7oY3dRhtz/SIXKUGYKeb9BF4eWAZ97WmQZJVxVICesSk2FklyGpfAZxNX\nQ45MRQ5Bg+i3HpaubALY88udRYNXJ/ereAQzqnC+vtRC5hIzTBbmavPTH9GjVQoZ\nhzJzoXroxIqwg4n4yWdWbOEb1gPPuvashSpp0K5aW7wvwnWb+Xjs8KZptaDsd7qs\nGQcXAr31cj2HZq4Mzzl6gXpagkRpEp382resAkMItSfvn64LJC01SpzCpqL+Js7A\nrXWFuArfP1VQwF0gLG6yMFpPOyPuKEpwei1mGimYeXPYqgUiIlGhSJeMkU/khuY=\n=OxA6\n-----END PGP SIGNATURE-----\n", "payload": "tree 79da2fb2fae5a69cd44c8a47985f20592bbd7e61\nparent 2b681ac06b1a6b7ea39525e59363ffee0d1a68e5\nparent d49d1d44995a75fd288f860c10b2bc18cfc8a5b4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641310454 +0100\ncommitter GitHub <noreply@github.com> 1641310454 +0100\n\nRollup merge of #91754 - Patrick-Poitras:rm-4byte-minimum-stdio-windows, r=Mark-Simulacrum\n\nModifications to `std::io::Stdin` on Windows so that there is no longer a 4-byte buffer minimum in read().\n\nThis is an attempted fix of issue #91722, where a too-small buffer was passed to the read function of stdio on Windows. This caused an error to be returned when `read_to_end` or `read_to_string` were called. Both delegate to `std::io::default_read_to_end`, which creates a buffer that is of length >0, and forwards it to `std::io::Stdin::read()`. The latter method returns an error if the length of the buffer is less than 4, as there might not be enough space to allocate a UTF-16 character. This creates a problem when the buffer length is in `0 < N < 4`, causing the bug.\n\nThe current modification creates an internal buffer, much like the one used for the write functions\n\nI'd also like to acknowledge the help of ``@agausmann`` and ``@hkratz`` in detecting and isolating the bug, and for suggestions that made the fix possible.\n\nCouple disclaimers:\n\n- Firstly, I didn't know where to put code to replicate the bug found in the issue. It would probably be wise to add that case to the testing suite, but I'm afraid that I don't know _where_ that test should be added.\n- Secondly, the code is fairly fundamental to IO operations, so my fears are that this may cause some undesired side effects ~or performance loss in benchmarks.~ The testing suite runs on my computer, and it does fix the issue noted in #91722.\n- Thirdly, I left the \"surrogate\" field in the Stdin struct, but from a cursory glance, it seems to be serving the same purpose for other functions. Perhaps merging the two would be appropriate.\n\nFinally, this is my first pull request to the rust language, and as such some things may be weird/unidiomatic/plain out bad. If there are any obvious improvements I could do to the code, or any other suggestions, I would appreciate them.\n\nEdit: Closes #91722\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50a66b75dcfb69fd23b1dca441d756f31d0b483f", "html_url": "https://github.com/rust-lang/rust/commit/50a66b75dcfb69fd23b1dca441d756f31d0b483f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50a66b75dcfb69fd23b1dca441d756f31d0b483f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b681ac06b1a6b7ea39525e59363ffee0d1a68e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b681ac06b1a6b7ea39525e59363ffee0d1a68e5", "html_url": "https://github.com/rust-lang/rust/commit/2b681ac06b1a6b7ea39525e59363ffee0d1a68e5"}, {"sha": "d49d1d44995a75fd288f860c10b2bc18cfc8a5b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d49d1d44995a75fd288f860c10b2bc18cfc8a5b4", "html_url": "https://github.com/rust-lang/rust/commit/d49d1d44995a75fd288f860c10b2bc18cfc8a5b4"}], "stats": {"total": 72, "additions": 54, "deletions": 18}, "files": [{"sha": "684b8e3155e84b1a6554424e5bf5afb45748373e", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 54, "deletions": 18, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/50a66b75dcfb69fd23b1dca441d756f31d0b483f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a66b75dcfb69fd23b1dca441d756f31d0b483f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=50a66b75dcfb69fd23b1dca441d756f31d0b483f", "patch": "@@ -15,7 +15,9 @@ use core::str::utf8_char_width;\n // the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\n pub struct Stdin {\n     surrogate: u16,\n+    incomplete_utf8: IncompleteUtf8,\n }\n+\n pub struct Stdout {\n     incomplete_utf8: IncompleteUtf8,\n }\n@@ -29,6 +31,25 @@ struct IncompleteUtf8 {\n     len: u8,\n }\n \n+impl IncompleteUtf8 {\n+    // Implemented for use in Stdin::read.\n+    fn read(&mut self, buf: &mut [u8]) -> usize {\n+        // Write to buffer until the buffer is full or we run out of bytes.\n+        let to_write = cmp::min(buf.len(), self.len as usize);\n+        buf[..to_write].copy_from_slice(&self.bytes[..to_write]);\n+\n+        // Rotate the remaining bytes if not enough remaining space in buffer.\n+        if usize::from(self.len) > buf.len() {\n+            self.bytes.copy_within(to_write.., 0);\n+            self.len -= to_write as u8;\n+        } else {\n+            self.len = 0;\n+        }\n+\n+        to_write\n+    }\n+}\n+\n // Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see\n // #13304 for details).\n //\n@@ -205,7 +226,7 @@ fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n \n impl Stdin {\n     pub const fn new() -> Stdin {\n-        Stdin { surrogate: 0 }\n+        Stdin { surrogate: 0, incomplete_utf8: IncompleteUtf8::new() }\n     }\n }\n \n@@ -221,24 +242,39 @@ impl io::Read for Stdin {\n             }\n         }\n \n-        if buf.len() == 0 {\n-            return Ok(0);\n-        } else if buf.len() < 4 {\n-            return Err(io::Error::new_const(\n-                io::ErrorKind::InvalidInput,\n-                &\"Windows stdin in console mode does not support a buffer too small to \\\n-                 guarantee holding one arbitrary UTF-8 character (4 bytes)\",\n-            ));\n+        // If there are bytes in the incomplete utf-8, start with those.\n+        // (No-op if there is nothing in the buffer.)\n+        let mut bytes_copied = self.incomplete_utf8.read(buf);\n+\n+        if bytes_copied == buf.len() {\n+            return Ok(bytes_copied);\n+        } else if buf.len() - bytes_copied < 4 {\n+            // Not enough space to get a UTF-8 byte. We will use the incomplete UTF8.\n+            let mut utf16_buf = [0u16; 1];\n+            // Read one u16 character.\n+            let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, 1, &mut self.surrogate)?;\n+            // Read bytes, using the (now-empty) self.incomplete_utf8 as extra space.\n+            let read_bytes = utf16_to_utf8(&utf16_buf[..read], &mut self.incomplete_utf8.bytes)?;\n+\n+            // Read in the bytes from incomplete_utf8 until the buffer is full.\n+            self.incomplete_utf8.len = read_bytes as u8;\n+            // No-op if no bytes.\n+            bytes_copied += self.incomplete_utf8.read(&mut buf[bytes_copied..]);\n+            Ok(bytes_copied)\n+        } else {\n+            let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+            // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n+            // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n+            // lost.\n+            let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n+            let read =\n+                read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n+\n+            match utf16_to_utf8(&utf16_buf[..read], buf) {\n+                Ok(value) => return Ok(bytes_copied + value),\n+                Err(e) => return Err(e),\n+            }\n         }\n-\n-        let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n-        // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n-        // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n-        // lost.\n-        let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n-        let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n-\n-        utf16_to_utf8(&utf16_buf[..read], buf)\n     }\n }\n "}]}