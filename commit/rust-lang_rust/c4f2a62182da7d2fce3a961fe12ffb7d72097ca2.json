{"sha": "c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "node_id": "C_kwDOAAsO6NoAKGM0ZjJhNjIxODJkYTdkMmZjZTNhOTYxZmUxMmZmYjdkNzIwOTdjYTI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-05-23T11:14:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-23T11:14:29Z"}, "message": "Rollup merge of #111860 - compiler-errors:issue-111838, r=WaffleLapkin\n\nDon't ICE if method receiver fails to unify with `arbitrary_self_types`\n\nConsider:\n\n```rust\nstruct Foo(u32);\nimpl Foo {\n    fn get<R: Deref<Target=Self>>(self: R) -> u32 {\n        self.0\n    }\n}\n\nfn main() {\n    let mut foo = Foo(1);\n    foo.get::<&Foo>();\n}\n```\n\nThe problem here is that with `arbitrary_self_types`, we're allowed to have a method receiver that mentions generics from the method itself (`fn get<R: Deref<Target=Self>>(self: R)`). Since we don't actually take into account the user-written turbofish generics when doing method lookup (nor do we check that method predicates hold), method probing will happily infer `R = Foo` during the probe. When we later confirm the method, we do use the turbofish'd subst and instead now have that `R = &Foo`. This doesn't unify with the self type we chose during the probe, causing an ICE.\n\nGetting this to work correctly will be difficult. Specifically, we'll need to actually pass in the turbofish generics for the method being probed for and check that the self type unifies considering those generics. This seems like a lot of work, and I'm not actually familiar with the restrictions originally called out for `#![feature(arbitrary_self_types)]`, but I think we should probably instead just deny having receivers that mention (type/const) generics that come from the method itself.\n\nBut I mostly just want to turn this ICE into an error, so I'll leave that up for later PRs.\n\nFixes #111838", "tree": {"sha": "960d3fd83a88d87a7a5a9e043218884a101e2f58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/960d3fd83a88d87a7a5a9e043218884a101e2f58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkbKAVCRBK7hj4Ov3rIwAAXDcIADXd3kTuqX8Z4bMlQsyTW3kp\neFsUJ5hF/htW3DaT1czu+dRqiwew6FUNHB2438dTyaSl50sIcxpztgcs7N8lHgn3\nN0uxJxVAuV5PHAFtu1rCu2Y418d54fkyTD0YGtI0SeTSyUno1+BYSoBhPdCme2Yv\n8L8GtBp6diZImN9b/uLVSus2ZGj3fbiPEAe/gDVU6YFaNXzLr51Kv/+1kwJdtQCS\nre3ZYxy0exyGl8Ypz8RyWK66C6BvxbsZdwNDJ3Nk56BcyaX+pq/u3DHg8hF8OncL\nCZULWGIsFpHRs/oP4PETfQGldWXecTCEqBrZ0Buu8fgtrnvSAQUOg+pVzh/1eqE=\n=BtLS\n-----END PGP SIGNATURE-----\n", "payload": "tree 960d3fd83a88d87a7a5a9e043218884a101e2f58\nparent 32c73c23a4dc447c54f4c4dd35512be519122cf6\nparent 05c5caa5002297d2e3ba31f2ead7556a732a2289\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1684840469 +0530\ncommitter GitHub <noreply@github.com> 1684840469 +0530\n\nRollup merge of #111860 - compiler-errors:issue-111838, r=WaffleLapkin\n\nDon't ICE if method receiver fails to unify with `arbitrary_self_types`\n\nConsider:\n\n```rust\nstruct Foo(u32);\nimpl Foo {\n    fn get<R: Deref<Target=Self>>(self: R) -> u32 {\n        self.0\n    }\n}\n\nfn main() {\n    let mut foo = Foo(1);\n    foo.get::<&Foo>();\n}\n```\n\nThe problem here is that with `arbitrary_self_types`, we're allowed to have a method receiver that mentions generics from the method itself (`fn get<R: Deref<Target=Self>>(self: R)`). Since we don't actually take into account the user-written turbofish generics when doing method lookup (nor do we check that method predicates hold), method probing will happily infer `R = Foo` during the probe. When we later confirm the method, we do use the turbofish'd subst and instead now have that `R = &Foo`. This doesn't unify with the self type we chose during the probe, causing an ICE.\n\nGetting this to work correctly will be difficult. Specifically, we'll need to actually pass in the turbofish generics for the method being probed for and check that the self type unifies considering those generics. This seems like a lot of work, and I'm not actually familiar with the restrictions originally called out for `#![feature(arbitrary_self_types)]`, but I think we should probably instead just deny having receivers that mention (type/const) generics that come from the method itself.\n\nBut I mostly just want to turn this ICE into an error, so I'll leave that up for later PRs.\n\nFixes #111838\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "html_url": "https://github.com/rust-lang/rust/commit/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c73c23a4dc447c54f4c4dd35512be519122cf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/32c73c23a4dc447c54f4c4dd35512be519122cf6", "html_url": "https://github.com/rust-lang/rust/commit/32c73c23a4dc447c54f4c4dd35512be519122cf6"}, {"sha": "05c5caa5002297d2e3ba31f2ead7556a732a2289", "url": "https://api.github.com/repos/rust-lang/rust/commits/05c5caa5002297d2e3ba31f2ead7556a732a2289", "html_url": "https://github.com/rust-lang/rust/commit/05c5caa5002297d2e3ba31f2ead7556a732a2289"}], "stats": {"total": 50, "additions": 42, "deletions": 8}, "files": [{"sha": "98529b66602faa30df3f4bd6a883ab179386a961", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "patch": "@@ -471,7 +471,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             self_ty, method_self_ty, self.span, pick\n         );\n         let cause = self.cause(\n-            self.span,\n+            self.self_expr.span,\n             ObligationCauseCode::UnifyReceiver(Box::new(UnifyReceiverContext {\n                 assoc_item: pick.item,\n                 param_env: self.param_env,\n@@ -482,13 +482,22 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }\n-            Err(_) => {\n-                span_bug!(\n-                    self.span,\n-                    \"{} was a subtype of {} but now is not?\",\n-                    self_ty,\n-                    method_self_ty\n-                );\n+            Err(terr) => {\n+                // FIXME(arbitrary_self_types): We probably should limit the\n+                // situations where this can occur by adding additional restrictions\n+                // to the feature, like the self type can't reference method substs.\n+                if self.tcx.features().arbitrary_self_types {\n+                    self.err_ctxt()\n+                        .report_mismatched_types(&cause, method_self_ty, self_ty, terr)\n+                        .emit();\n+                } else {\n+                    span_bug!(\n+                        self.span,\n+                        \"{} was a subtype of {} but now is not?\",\n+                        self_ty,\n+                        method_self_ty\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "0f911a20842bc4e0fe5650dc119c156cc6dea9d5", "filename": "tests/ui/self/arbitrary-self-from-method-substs.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.rs?ref=c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "patch": "@@ -0,0 +1,16 @@\n+#![feature(arbitrary_self_types)]\n+\n+use std::ops::Deref;\n+\n+struct Foo(u32);\n+impl Foo {\n+    fn get<R: Deref<Target=Self>>(self: R) -> u32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(1);\n+    foo.get::<&Foo>();\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "6c252fadf46573e81167b32d91bf28591a34121a", "filename": "tests/ui/self/arbitrary-self-from-method-substs.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.stderr?ref=c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/arbitrary-self-from-method-substs.rs:14:5\n+   |\n+LL |     foo.get::<&Foo>();\n+   |     ^^^ expected `&Foo`, found `Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}