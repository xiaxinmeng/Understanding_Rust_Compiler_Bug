{"sha": "4af7a35197a1cb159458694e69e17bd83dc9edff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZjdhMzUxOTdhMWNiMTU5NDU4Njk0ZTY5ZTE3YmQ4M2RjOWVkZmY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T15:45:38Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T15:45:38Z"}, "message": "internal: remove def-level diagnostics tests", "tree": {"sha": "e1a50270e17e19d9be974b9ea8516667f17469e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1a50270e17e19d9be974b9ea8516667f17469e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4af7a35197a1cb159458694e69e17bd83dc9edff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4af7a35197a1cb159458694e69e17bd83dc9edff", "html_url": "https://github.com/rust-lang/rust/commit/4af7a35197a1cb159458694e69e17bd83dc9edff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4af7a35197a1cb159458694e69e17bd83dc9edff/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00303284b5cc3a82e32dc3ecbbcfeb2f99de6818", "url": "https://api.github.com/repos/rust-lang/rust/commits/00303284b5cc3a82e32dc3ecbbcfeb2f99de6818", "html_url": "https://github.com/rust-lang/rust/commit/00303284b5cc3a82e32dc3ecbbcfeb2f99de6818"}], "stats": {"total": 192, "additions": 21, "deletions": 171}, "files": [{"sha": "27d837d47f4741e060078318eb885335d15a3a78", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4af7a35197a1cb159458694e69e17bd83dc9edff/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af7a35197a1cb159458694e69e17bd83dc9edff/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=4af7a35197a1cb159458694e69e17bd83dc9edff", "patch": "@@ -3,7 +3,7 @@ mod block;\n use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::Expect;\n \n-use crate::{test_db::TestDB, ModuleDefId};\n+use crate::ModuleDefId;\n \n use super::*;\n \n@@ -28,11 +28,6 @@ fn lower(ra_fixture: &str) -> Arc<Body> {\n     db.body(fn_def.unwrap().into())\n }\n \n-fn check_diagnostics(ra_fixture: &str) {\n-    let db: TestDB = TestDB::with_files(ra_fixture);\n-    db.check_diagnostics();\n-}\n-\n fn block_def_map_at(ra_fixture: &str) -> String {\n     let (db, position) = crate::test_db::TestDB::with_position(ra_fixture);\n \n@@ -57,23 +52,23 @@ fn check_at(ra_fixture: &str, expect: Expect) {\n fn your_stack_belongs_to_me() {\n     cov_mark::check!(your_stack_belongs_to_me);\n     lower(\n-        \"\n+        r#\"\n macro_rules! n_nuple {\n     ($e:tt) => ();\n     ($($rest:tt)*) => {{\n         (n_nuple!($($rest)*)None,)\n     }};\n }\n fn main() { n_nuple!(1,2,3); }\n-\",\n+\"#,\n     );\n }\n \n #[test]\n fn macro_resolve() {\n     // Regression test for a path resolution bug introduced with inner item handling.\n     lower(\n-        r\"\n+        r#\"\n macro_rules! vec {\n     () => { () };\n     ($elem:expr; $n:expr) => { () };\n@@ -84,19 +79,6 @@ mod m {\n         let _ = vec![FileSet::default(); self.len()];\n     }\n }\n-      \",\n+\"#,\n     );\n }\n-\n-#[test]\n-fn unresolved_macro_diag() {\n-    check_diagnostics(\n-        r#\"\n-fn f() {\n-    m!();\n-  //^^^^ UnresolvedMacroCall\n-}\n-      \"#,\n-    );\n-}\n-"}, {"sha": "2635b556e652a0cf5db12ecb835acc3abfb40b78", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 148, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4af7a35197a1cb159458694e69e17bd83dc9edff/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af7a35197a1cb159458694e69e17bd83dc9edff/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=4af7a35197a1cb159458694e69e17bd83dc9edff", "patch": "@@ -6,19 +6,16 @@ use std::{\n };\n \n use base_db::{\n-    salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition, FileRange, Upcast,\n+    salsa, AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition,\n+    SourceDatabase, Upcast,\n };\n-use base_db::{AnchoredPath, SourceDatabase};\n use hir_expand::{db::AstDatabase, InFile};\n-use rustc_hash::FxHashMap;\n use rustc_hash::FxHashSet;\n-use syntax::{algo, ast, AstNode, SyntaxNode, SyntaxNodePtr, TextRange, TextSize};\n-use test_utils::extract_annotations;\n+use syntax::{algo, ast, AstNode};\n \n use crate::{\n-    body::BodyDiagnostic,\n     db::DefDatabase,\n-    nameres::{diagnostics::DefDiagnosticKind, DefMap, ModuleSource},\n+    nameres::{DefMap, ModuleSource},\n     src::HasSource,\n     LocalModuleId, Lookup, ModuleDefId, ModuleId,\n };\n@@ -245,145 +242,4 @@ impl TestDB {\n             })\n             .collect()\n     }\n-\n-    pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n-        let mut files = Vec::new();\n-        let crate_graph = self.crate_graph();\n-        for krate in crate_graph.iter() {\n-            let crate_def_map = self.crate_def_map(krate);\n-            for (module_id, _) in crate_def_map.modules() {\n-                let file_id = crate_def_map[module_id].origin.file_id();\n-                files.extend(file_id)\n-            }\n-        }\n-        assert!(!files.is_empty());\n-        files\n-            .into_iter()\n-            .filter_map(|file_id| {\n-                let text = self.file_text(file_id);\n-                let annotations = extract_annotations(&text);\n-                if annotations.is_empty() {\n-                    return None;\n-                }\n-                Some((file_id, annotations))\n-            })\n-            .collect()\n-    }\n-\n-    pub(crate) fn diagnostics(&self, cb: &mut dyn FnMut(FileRange, String)) {\n-        let crate_graph = self.crate_graph();\n-        for krate in crate_graph.iter() {\n-            let crate_def_map = self.crate_def_map(krate);\n-\n-            for diag in crate_def_map.diagnostics() {\n-                let (node, message): (InFile<SyntaxNode>, &str) = match &diag.kind {\n-                    DefDiagnosticKind::UnresolvedModule { ast, .. } => {\n-                        let node = ast.to_node(self.upcast());\n-                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedModule\")\n-                    }\n-                    DefDiagnosticKind::UnresolvedExternCrate { ast, .. } => {\n-                        let node = ast.to_node(self.upcast());\n-                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedExternCrate\")\n-                    }\n-                    DefDiagnosticKind::UnresolvedImport { id, .. } => {\n-                        let item_tree = id.item_tree(self.upcast());\n-                        let import = &item_tree[id.value];\n-                        let node = InFile::new(id.file_id(), import.ast_id).to_node(self.upcast());\n-                        (InFile::new(id.file_id(), node.syntax().clone()), \"UnresolvedImport\")\n-                    }\n-                    DefDiagnosticKind::UnconfiguredCode { ast, .. } => {\n-                        let node = ast.to_node(self.upcast());\n-                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnconfiguredCode\")\n-                    }\n-                    DefDiagnosticKind::UnresolvedProcMacro { ast, .. } => {\n-                        (ast.to_node(self.upcast()), \"UnresolvedProcMacro\")\n-                    }\n-                    DefDiagnosticKind::UnresolvedMacroCall { ast, .. } => {\n-                        let node = ast.to_node(self.upcast());\n-                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedMacroCall\")\n-                    }\n-                    DefDiagnosticKind::MacroError { ast, message } => {\n-                        (ast.to_node(self.upcast()), message.as_str())\n-                    }\n-                    DefDiagnosticKind::UnimplementedBuiltinMacro { ast } => {\n-                        let node = ast.to_node(self.upcast());\n-                        (\n-                            InFile::new(ast.file_id, node.syntax().clone()),\n-                            \"UnimplementedBuiltinMacro\",\n-                        )\n-                    }\n-                };\n-\n-                let frange = node.as_ref().original_file_range(self);\n-                cb(frange, message.to_string())\n-            }\n-\n-            for (_module_id, module) in crate_def_map.modules() {\n-                for decl in module.scope.declarations() {\n-                    if let ModuleDefId::FunctionId(it) = decl {\n-                        let source_map = self.body_with_source_map(it.into()).1;\n-                        for diag in source_map.diagnostics() {\n-                            let (ptr, message): (InFile<SyntaxNodePtr>, &str) = match diag {\n-                                BodyDiagnostic::InactiveCode { node, .. } => {\n-                                    (node.clone().map(|it| it), \"InactiveCode\")\n-                                }\n-                                BodyDiagnostic::MacroError { node, message } => {\n-                                    (node.clone().map(|it| it.into()), message.as_str())\n-                                }\n-                                BodyDiagnostic::UnresolvedProcMacro { node } => {\n-                                    (node.clone().map(|it| it.into()), \"UnresolvedProcMacro\")\n-                                }\n-                                BodyDiagnostic::UnresolvedMacroCall { node, .. } => {\n-                                    (node.clone().map(|it| it.into()), \"UnresolvedMacroCall\")\n-                                }\n-                            };\n-\n-                            let root = self.parse_or_expand(ptr.file_id).unwrap();\n-                            let node = ptr.map(|ptr| ptr.to_node(&root));\n-                            let frange = node.as_ref().original_file_range(self);\n-                            cb(frange, message.to_string())\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn check_diagnostics(&self) {\n-        let db: &TestDB = self;\n-        let annotations = db.extract_annotations();\n-        assert!(!annotations.is_empty());\n-\n-        let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n-        db.diagnostics(&mut |frange, message| {\n-            actual.entry(frange.file_id).or_default().push((frange.range, message));\n-        });\n-\n-        for (file_id, diags) in actual.iter_mut() {\n-            diags.sort_by_key(|it| it.0.start());\n-            let text = db.file_text(*file_id);\n-            // For multiline spans, place them on line start\n-            for (range, content) in diags {\n-                if text[*range].contains('\\n') {\n-                    *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n-                    *content = format!(\"... {}\", content);\n-                }\n-            }\n-        }\n-\n-        assert_eq!(annotations, actual);\n-    }\n-\n-    pub(crate) fn check_no_diagnostics(&self) {\n-        let db: &TestDB = self;\n-        let annotations = db.extract_annotations();\n-        assert!(annotations.is_empty());\n-\n-        let mut has_diagnostics = false;\n-        db.diagnostics(&mut |_, _| {\n-            has_diagnostics = true;\n-        });\n-\n-        assert!(!has_diagnostics);\n-    }\n }"}, {"sha": "15b6a27308d871a2aa2c35826a3f6269d828d0f9", "filename": "crates/ide/src/diagnostics/unresolved_macro_call.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4af7a35197a1cb159458694e69e17bd83dc9edff/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af7a35197a1cb159458694e69e17bd83dc9edff/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_macro_call.rs?ref=4af7a35197a1cb159458694e69e17bd83dc9edff", "patch": "@@ -34,6 +34,18 @@ pub(super) fn unresolved_macro_call(\n mod tests {\n     use crate::diagnostics::tests::check_diagnostics;\n \n+    #[test]\n+    fn unresolved_macro_diag() {\n+        check_diagnostics(\n+            r#\"\n+fn f() {\n+    m!();\n+} //^ unresolved macro `m!`\n+\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_unresolved_macro_range() {\n         check_diagnostics("}]}