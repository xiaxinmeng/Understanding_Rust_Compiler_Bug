{"sha": "07950e740cb67e8eb9cf7b19b6e99e171943d2f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3OTUwZTc0MGNiNjdlOGViOWNmN2IxOWI2ZTk5ZTE3MTk0M2QyZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-07T05:51:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-07T05:51:38Z"}, "message": "auto merge of #11296 : brson/rust/anti-cond, r=alexcrichton\n\nIn preparation for removing conditions.", "tree": {"sha": "559e8d96fc885c1b160f5d64d6d067c64543e9d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/559e8d96fc885c1b160f5d64d6d067c64543e9d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07950e740cb67e8eb9cf7b19b6e99e171943d2f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07950e740cb67e8eb9cf7b19b6e99e171943d2f9", "html_url": "https://github.com/rust-lang/rust/commit/07950e740cb67e8eb9cf7b19b6e99e171943d2f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07950e740cb67e8eb9cf7b19b6e99e171943d2f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5efac2bee1b47c69cf295f237f7fe1f395ac324a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5efac2bee1b47c69cf295f237f7fe1f395ac324a", "html_url": "https://github.com/rust-lang/rust/commit/5efac2bee1b47c69cf295f237f7fe1f395ac324a"}, {"sha": "d3833c34c5378f5da43df2b28c62e5ad1c8d15ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3833c34c5378f5da43df2b28c62e5ad1c8d15ba", "html_url": "https://github.com/rust-lang/rust/commit/d3833c34c5378f5da43df2b28c62e5ad1c8d15ba"}], "stats": {"total": 82, "additions": 48, "deletions": 34}, "files": [{"sha": "0faf4ee664eaa7dbe40455dfe742aa873f721bf7", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/07950e740cb67e8eb9cf7b19b6e99e171943d2f9/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07950e740cb67e8eb9cf7b19b6e99e171943d2f9/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=07950e740cb67e8eb9cf7b19b6e99e171943d2f9", "patch": "@@ -141,10 +141,6 @@ impl cmp::Ord for Version {\n     }\n }\n \n-condition! {\n-    bad_parse: () -> ();\n-}\n-\n fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n                         -> (~str, Option<char>) {\n     let mut buf = ~\"\";\n@@ -159,53 +155,66 @@ fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n             }\n         }\n     }\n-    if buf.is_empty() {\n-        bad_parse::cond.raise(())\n-    }\n     debug!(\"extracted nonempty prefix: {}\", buf);\n     (buf, ch)\n }\n \n-fn take_num<T: Iterator<char>>(rdr: &mut T) -> (uint, Option<char>) {\n+fn take_num<T: Iterator<char>>(rdr: &mut T) -> Option<(uint, Option<char>)> {\n     let (s, ch) = take_nonempty_prefix(rdr, char::is_digit);\n     match from_str::<uint>(s) {\n-        None => { bad_parse::cond.raise(()); (0, ch) },\n-        Some(i) => (i, ch)\n+        None => None,\n+        Some(i) => Some((i, ch))\n     }\n }\n \n-fn take_ident<T: Iterator<char>>(rdr: &mut T) -> (Identifier, Option<char>) {\n+fn take_ident<T: Iterator<char>>(rdr: &mut T) -> Option<(Identifier, Option<char>)> {\n     let (s,ch) = take_nonempty_prefix(rdr, char::is_alphanumeric);\n     if s.chars().all(char::is_digit) {\n         match from_str::<uint>(s) {\n-            None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n-            Some(i) => (Numeric(i), ch)\n+            None => None,\n+            Some(i) => Some((Numeric(i), ch))\n         }\n     } else {\n-        (AlphaNumeric(s), ch)\n+        Some((AlphaNumeric(s), ch))\n     }\n }\n \n-fn expect(ch: Option<char>, c: char) {\n+fn expect(ch: Option<char>, c: char) -> Option<()> {\n     if ch != Some(c) {\n-        bad_parse::cond.raise(())\n+        None\n+    } else {\n+        Some(())\n     }\n }\n \n-fn parse_iter<T: Iterator<char>>(rdr: &mut T) -> Version {\n-    let (major, ch) = take_num(rdr);\n-    expect(ch, '.');\n-    let (minor, ch) = take_num(rdr);\n-    expect(ch, '.');\n-    let (patch, ch) = take_num(rdr);\n+fn parse_iter<T: Iterator<char>>(rdr: &mut T) -> Option<Version> {\n+    let maybe_vers = take_num(rdr).and_then(|(major, ch)| {\n+        expect(ch, '.').and_then(|_| Some(major))\n+    }).and_then(|major| {\n+        take_num(rdr).and_then(|(minor, ch)| {\n+            expect(ch, '.').and_then(|_| Some((major, minor)))\n+        })\n+    }).and_then(|(major, minor)| {\n+        take_num(rdr).and_then(|(patch, ch)| {\n+           Some((major, minor, patch, ch))\n+        })\n+    });\n+\n+    let (major, minor, patch, ch) = match maybe_vers {\n+        Some((a, b, c, d)) => (a, b, c, d),\n+        None => return None\n+    };\n \n     let mut pre = ~[];\n     let mut build = ~[];\n \n     let mut ch = ch;\n     if ch == Some('-') {\n         loop {\n-            let (id, c) = take_ident(rdr);\n+            let (id, c) = match take_ident(rdr) {\n+                Some((id, c)) => (id, c),\n+                None => return None\n+            };\n             pre.push(id);\n             ch = c;\n             if ch != Some('.') { break; }\n@@ -214,20 +223,23 @@ fn parse_iter<T: Iterator<char>>(rdr: &mut T) -> Version {\n \n     if ch == Some('+') {\n         loop {\n-            let (id, c) = take_ident(rdr);\n+            let (id, c) = match take_ident(rdr) {\n+                Some((id, c)) => (id, c),\n+                None => return None\n+            };\n             build.push(id);\n             ch = c;\n             if ch != Some('.') { break; }\n         }\n     }\n \n-    Version {\n+    Some(Version {\n         major: major,\n         minor: minor,\n         patch: patch,\n         pre: pre,\n         build: build,\n-    }\n+    })\n }\n \n \n@@ -237,15 +249,17 @@ pub fn parse(s: &str) -> Option<Version> {\n         return None;\n     }\n     let s = s.trim();\n-    let mut bad = false;\n-    bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside(|| {\n-        let v = parse_iter(&mut s.chars());\n-        if bad || v.to_str() != s.to_owned() {\n-            None\n-        } else {\n-            Some(v)\n+    let v = parse_iter(&mut s.chars());\n+    match v {\n+        Some(v) => {\n+            if v.to_str().equiv(&s) {\n+                Some(v)\n+            } else {\n+                None\n+            }\n         }\n-    })\n+        None => None\n+    }\n }\n \n #[test]"}]}