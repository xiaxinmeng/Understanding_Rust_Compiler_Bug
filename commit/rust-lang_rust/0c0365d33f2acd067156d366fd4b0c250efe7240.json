{"sha": "0c0365d33f2acd067156d366fd4b0c250efe7240", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMDM2NWQzM2YyYWNkMDY3MTU2ZDM2NmZkNGIwYzI1MGVmZTcyNDA=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-23T20:35:19Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-29T22:55:56Z"}, "message": "Improve the readability of diagnostics that involve unresolved type variables\n\nDiagnostics such as the following\n\n```\nmismatched types: expected `core::result::Result<uint,()>`, found `core::option::Option<<generic #1>>`\n<anon>:6     let a: Result<uint, ()> = None;\n                                       ^~~~\nmismatched types: expected `&mut <generic #2>`, found `uint`\n<anon>:7     f(42u);\n               ^~~\n```\n\ntend to be fairly unappealing to new users. While specific type var IDs are valuable in\ndiagnostics that deal with more than one such variable, in practice many messages\nonly mention one. In those cases, leaving out the specific number makes the messages\nslightly less terrifying.\n\nIn addition, type variables have been changed to use the type hole syntax `_` in diagnostics.\nWith a variable ID, they're printed as `_#id` (e.g. `_#1`). In cases where the ID is left out,\nit's simply `_`. Integer and float variables have an additional suffix after the number, e.g.\n`_#1i` or `_#3f`.", "tree": {"sha": "724db0dce40ec40f59ddaea3dfd35fde3ea354ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/724db0dce40ec40f59ddaea3dfd35fde3ea354ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c0365d33f2acd067156d366fd4b0c250efe7240", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0365d33f2acd067156d366fd4b0c250efe7240", "html_url": "https://github.com/rust-lang/rust/commit/0c0365d33f2acd067156d366fd4b0c250efe7240", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c0365d33f2acd067156d366fd4b0c250efe7240/comments", "author": null, "committer": null, "parents": [{"sha": "77f44d4a7bf14805fda5fc41310a6aeffda30fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f44d4a7bf14805fda5fc41310a6aeffda30fd4", "html_url": "https://github.com/rust-lang/rust/commit/77f44d4a7bf14805fda5fc41310a6aeffda30fd4"}], "stats": {"total": 373, "additions": 210, "deletions": 163}, "files": [{"sha": "3ec1106ff20e002011802902889dc65a32d2a283", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0c0365d33f2acd067156d366fd4b0c250efe7240", "patch": "@@ -1032,10 +1032,8 @@ pub enum type_err {\n     terr_ref_mutability,\n     terr_vec_mutability,\n     terr_tuple_size(expected_found<uint>),\n+    terr_fixed_array_size(expected_found<uint>),\n     terr_ty_param_size(expected_found<uint>),\n-    terr_record_size(expected_found<uint>),\n-    terr_record_mutability,\n-    terr_record_fields(expected_found<Ident>),\n     terr_arg_count,\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n@@ -3790,8 +3788,8 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n         ty_uniq(_) => \"box\".to_string(),\n-        ty_vec(_, Some(_)) => \"array\".to_string(),\n-        ty_vec(_, None) => \"unsized array\".to_string(),\n+        ty_vec(_, Some(n)) => format!(\"array of {} elements\", n),\n+        ty_vec(_, None) => \"slice\".to_string(),\n         ty_ptr(_) => \"*-ptr\".to_string(),\n         ty_rptr(_, _) => \"&-ptr\".to_string(),\n         ty_bare_fn(_) => \"extern fn\".to_string(),\n@@ -3874,27 +3872,18 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n                     values.expected,\n                     values.found)\n         }\n-        terr_tuple_size(values) => {\n-            format!(\"expected a tuple with {} elements, \\\n+        terr_fixed_array_size(values) => {\n+            format!(\"expected an array with a fixed size of {} elements, \\\n                      found one with {} elements\",\n                     values.expected,\n                     values.found)\n         }\n-        terr_record_size(values) => {\n-            format!(\"expected a record with {} fields, \\\n-                     found one with {} fields\",\n+        terr_tuple_size(values) => {\n+            format!(\"expected a tuple with {} elements, \\\n+                     found one with {} elements\",\n                     values.expected,\n                     values.found)\n         }\n-        terr_record_mutability => {\n-            \"record elements differ in mutability\".to_string()\n-        }\n-        terr_record_fields(values) => {\n-            format!(\"expected a record with field `{}`, found one \\\n-                     with field `{}`\",\n-                    token::get_ident(values.expected),\n-                    token::get_ident(values.found))\n-        }\n         terr_arg_count => {\n             \"incorrect number of function parameters\".to_string()\n         }"}, {"sha": "e51eb331cdc37a8797537c747974b787560b7ef5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=0c0365d33f2acd067156d366fd4b0c250efe7240", "patch": "@@ -515,6 +515,16 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n             Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n+      (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n+        this.tys(a_t, b_t).and_then(|t| {\n+            if sz_a == sz_b {\n+                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+            } else {\n+                Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n+            }\n+        })\n+      }\n+\n       (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n         this.tys(a_t, b_t).and_then(|t| {\n             if sz_a == sz_b {"}, {"sha": "0f000e93fc01a27bf800d79151a2588a442789b9", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=0c0365d33f2acd067156d366fd4b0c250efe7240", "patch": "@@ -62,6 +62,7 @@ time of error detection.\n use std::collections::HashSet;\n use middle::def;\n use middle::subst;\n+use middle::ty_fold::{mod, TypeFoldable};\n use middle::ty;\n use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n@@ -111,7 +112,7 @@ pub trait ErrorReporting {\n \n     fn values_str(&self, values: &ValuePairs) -> Option<String>;\n \n-    fn expected_found_str<T:UserString+Resolvable>(\n+    fn expected_found_str<T: UserString + Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n@@ -396,16 +397,12 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n          * or None if this is a derived error.\n          */\n         match *values {\n-            infer::Types(ref exp_found) => {\n-                self.expected_found_str(exp_found)\n-            }\n-            infer::TraitRefs(ref exp_found) => {\n-                self.expected_found_str(exp_found)\n-            }\n+            infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n+            infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n         }\n     }\n \n-    fn expected_found_str<T:UserString+Resolvable>(\n+    fn expected_found_str<T: UserString + Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n@@ -420,9 +417,14 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             return None;\n         }\n \n+        // Only include variable IDs in the diagnostics if there are at least two\n+        // present across both types/traits.\n+        let should_print_var_ids = expected.remaining_type_variables(self.tcx)\n+            .union(&found.remaining_type_variables(self.tcx)).count() > 1;\n+\n         Some(format!(\"expected `{}`, found `{}`\",\n-                     expected.user_string(self.tcx),\n-                     found.user_string(self.tcx)))\n+                     expected.user_string_with_var_ids(self.tcx, should_print_var_ids),\n+                     found.user_string_with_var_ids(self.tcx, should_print_var_ids)))\n     }\n \n     fn report_param_bound_failure(&self,\n@@ -1654,6 +1656,7 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n pub trait Resolvable {\n     fn resolve(&self, infcx: &InferCtxt) -> Self;\n     fn contains_error(&self) -> bool;\n+    fn remaining_type_variables(&self, tcx: &ty::ctxt) -> HashSet<ty::InferTy>;\n }\n \n impl Resolvable for ty::t {\n@@ -1663,6 +1666,22 @@ impl Resolvable for ty::t {\n     fn contains_error(&self) -> bool {\n         ty::type_is_error(*self)\n     }\n+    fn remaining_type_variables(&self, tcx: &ty::ctxt) -> HashSet<ty::InferTy> {\n+        let mut vars = HashSet::new();\n+        {\n+            let mut folder = ty_fold::BottomUpFolder {\n+                tcx: tcx,\n+                fldop: |t| {\n+                    if let ty::ty_infer(var) = ty::get(t).sty {\n+                        vars.insert(var);\n+                    }\n+                    t\n+                }\n+            };\n+            self.fold_with(&mut folder);\n+        }\n+        vars\n+    }\n }\n \n impl Resolvable for Rc<ty::TraitRef> {\n@@ -1672,6 +1691,9 @@ impl Resolvable for Rc<ty::TraitRef> {\n     fn contains_error(&self) -> bool {\n         ty::trait_ref_contains_error(&**self)\n     }\n+    fn remaining_type_variables(&self, _: &ty::ctxt) -> HashSet<ty::InferTy> {\n+        HashSet::new()\n+    }\n }\n \n fn lifetimes_in_scope(tcx: &ty::ctxt,"}, {"sha": "227a9b1bdcc88aea98da657c84cc7eef9dce7b76", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=0c0365d33f2acd067156d366fd4b0c250efe7240", "patch": "@@ -36,7 +36,8 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n use util::common::indent;\n-use util::ppaux::{bound_region_to_string, ty_to_string, trait_ref_to_string, Repr};\n+use util::ppaux::{bound_region_to_string, ty_to_string};\n+use util::ppaux::{trait_ref_to_string, Repr};\n \n use self::coercion::Coerce;\n use self::combine::{Combine, CombineFields};\n@@ -900,32 +901,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let error_str = err.map_or(\"\".to_string(), |t_err| {\n-            format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n-        });\n         let resolved_expected = expected_ty.map(|e_ty| {\n             self.resolve_type_vars_if_possible(e_ty)\n         });\n-        if !resolved_expected.map_or(false, |e| { ty::type_is_error(e) }) {\n-            match resolved_expected {\n-                None => {\n-                    self.tcx\n-                        .sess\n-                        .span_err(sp,\n-                                  format!(\"{}{}\",\n-                                          mk_msg(None, actual_ty),\n-                                          error_str).as_slice())\n-                }\n-                Some(e) => {\n-                    self.tcx.sess.span_err(sp,\n-                        format!(\"{}{}\",\n-                                mk_msg(Some(self.ty_to_string(e)), actual_ty),\n-                                error_str).as_slice());\n+\n+        match resolved_expected {\n+            Some(t) if ty::type_is_error(t) => (),\n+            _ => {\n+                let error_str = err.map_or(\"\".to_string(), |t_err| {\n+                    format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n+                });\n+\n+                self.tcx.sess.span_err(sp, format!(\"{}{}\",\n+                    mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n+                    error_str).as_slice());\n+\n+                for err in err.iter() {\n+                    ty::note_and_explain_type_err(self.tcx, *err)\n                 }\n             }\n-            for err in err.iter() {\n-                ty::note_and_explain_type_err(self.tcx, *err)\n-            }\n         }\n     }\n \n@@ -945,25 +939,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn report_mismatched_types(&self,\n-                                   sp: Span,\n-                                   e: ty::t,\n-                                   a: ty::t,\n+                                   span: Span,\n+                                   expected: ty::t,\n+                                   actual: ty::t,\n                                    err: &ty::type_err) {\n-        let resolved_expected =\n-            self.resolve_type_vars_if_possible(e);\n-        let mk_msg = match ty::get(resolved_expected).sty {\n-            // Don't report an error if expected is ty_err\n-            ty::ty_err => return,\n-            _ => {\n-                // if I leave out : String, it infers &str and complains\n-                |actual: String| {\n-                    format!(\"mismatched types: expected `{}`, found `{}`\",\n-                            self.ty_to_string(resolved_expected),\n-                            actual)\n-                }\n-            }\n+        let trace = TypeTrace {\n+            origin: Misc(span),\n+            values: Types(ty::expected_found {\n+                expected: expected,\n+                found: actual\n+            })\n         };\n-        self.type_error_message(sp, mk_msg, a, Some(err));\n+        self.report_and_explain_type_error(trace, err);\n     }\n \n     pub fn replace_late_bound_regions_with_fresh_regions(&self,"}, {"sha": "572f2c9abf2237623b440294af77121fef991611", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 134, "deletions": 95, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0365d33f2acd067156d366fd4b0c250efe7240/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0c0365d33f2acd067156d366fd4b0c250efe7240", "patch": "@@ -43,6 +43,9 @@ pub trait Repr {\n /// Produces a string suitable for showing to the user.\n pub trait UserString {\n     fn user_string(&self, tcx: &ctxt) -> String;\n+    fn user_string_with_var_ids(&self, tcx: &ctxt, _: bool) -> String {\n+        self.user_string(tcx)\n+    }\n }\n \n pub fn note_and_explain_region(cx: &ctxt,\n@@ -228,8 +231,14 @@ pub fn mutability_to_string(m: ast::Mutability) -> String {\n     }\n }\n \n+pub fn mt_to_string_with_var_ids(cx: &ctxt, m: &mt, print_var_ids: bool) -> String {\n+    format!(\"{}{}\",\n+        mutability_to_string(m.mutbl),\n+        ty_to_string_with_var_ids(cx, m.ty, print_var_ids))\n+}\n+\n pub fn mt_to_string(cx: &ctxt, m: &mt) -> String {\n-    format!(\"{}{}\", mutability_to_string(m.mutbl), ty_to_string(cx, m.ty))\n+    mt_to_string_with_var_ids(cx, m, false)\n }\n \n pub fn trait_store_to_string(cx: &ctxt, s: ty::TraitStore) -> String {\n@@ -256,14 +265,17 @@ pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n }\n \n pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n-    fn fn_input_to_string(cx: &ctxt, input: ty::t) -> String {\n-        ty_to_string(cx, input).to_string()\n-    }\n+    ty_to_string_with_var_ids(cx, typ, true)\n+}\n+\n+pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) -> String {\n+    print_var_ids = print_var_ids || cx.sess.verbose();\n     fn bare_fn_to_string(cx: &ctxt,\n                       fn_style: ast::FnStyle,\n                       abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n-                      sig: &ty::FnSig)\n+                      sig: &ty::FnSig,\n+                      print_var_ids: bool)\n                       -> String {\n         let mut s = String::new();\n         match fn_style {\n@@ -288,12 +300,12 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             _ => { }\n         }\n \n-        push_sig_to_string(cx, &mut s, '(', ')', sig, \"\");\n+        push_sig_to_string(cx, &mut s, '(', ')', sig, \"\", print_var_ids);\n \n         s\n     }\n \n-    fn closure_to_string(cx: &ctxt, cty: &ty::ClosureTy) -> String {\n+    fn closure_to_string(cx: &ctxt, cty: &ty::ClosureTy, print_var_ids: bool) -> String {\n         let mut s = String::new();\n \n         match cty.store {\n@@ -318,15 +330,15 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str.as_slice());\n+                                   bounds_str.as_slice(), print_var_ids);\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str.as_slice());\n+                                   bounds_str.as_slice(), print_var_ids);\n             }\n         }\n \n@@ -338,9 +350,13 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n                        bra: char,\n                        ket: char,\n                        sig: &ty::FnSig,\n-                       bounds: &str) {\n+                       bounds: &str,\n+                       print_var_ids: bool) {\n         s.push(bra);\n-        let strs: Vec<String> = sig.inputs.iter().map(|a| fn_input_to_string(cx, *a)).collect();\n+        let strs = sig.inputs\n+            .iter()\n+            .map(|a| ty_to_string_with_var_ids(cx, *a, print_var_ids))\n+            .collect::<Vec<_>>();\n         s.push_str(strs.connect(\", \").as_slice());\n         if sig.variadic {\n             s.push_str(\", ...\");\n@@ -355,8 +371,8 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         match sig.output {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n-                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string(cx, t).as_slice());\n+                   s.push_str(\" -> \");\n+                   s.push_str(ty_to_string_with_var_ids(cx, t, print_var_ids).as_slice());\n                 }\n             }\n             ty::FnDiverging => {\n@@ -365,82 +381,98 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         }\n     }\n \n-    // if there is an id, print that instead of the structural type:\n-    /*for def_id in ty::type_def_id(typ).iter() {\n-        // note that this typedef cannot have type parameters\n-        return ty::item_path_str(cx, *def_id);\n-    }*/\n+    fn infer_ty_to_string(ty: ty::InferTy, print_var_ids: bool) -> String {\n+        match ty {\n+            ty::TyVar(ty::TyVid { index: vid })\n+              | ty::IntVar(ty::IntVid { index: vid })\n+              | ty::FloatVar(ty::FloatVid { index: vid }) => {\n+                match ty {\n+                    ty::TyVar(_) if print_var_ids => format!(\"_#{}\", vid),\n+                    ty::TyVar(_) => \"_\".to_string(),\n+                    ty::IntVar(_) => format!(\"_#{}i\", vid),\n+                    ty::FloatVar(_) => format!(\"_#{}f\", vid),\n+                    _ => unreachable!()\n+                }\n+            }\n+            ty::SkolemizedTy(v) => format!(\"SkolemizedTy({})\", v),\n+            ty::SkolemizedIntTy(v) => format!(\"SkolemizedIntTy({})\", v),\n+        }\n+    }\n \n     // pretty print the structural type representation:\n-    return match ty::get(typ).sty {\n-      ty_nil => \"()\".to_string(),\n-      ty_bool => \"bool\".to_string(),\n-      ty_char => \"char\".to_string(),\n-      ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n-      ty_uint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n-      ty_float(t) => ast_util::float_ty_to_string(t).to_string(),\n-      ty_uniq(typ) => format!(\"Box<{}>\", ty_to_string(cx, typ)),\n-      ty_ptr(ref tm) => {\n-          format!(\"*{} {}\", match tm.mutbl {\n-              ast::MutMutable => \"mut\",\n-              ast::MutImmutable => \"const\",\n-          }, ty_to_string(cx, tm.ty))\n-      }\n-      ty_rptr(r, ref tm) => {\n-          let mut buf = region_ptr_to_string(cx, r);\n-          buf.push_str(mt_to_string(cx, tm).as_slice());\n-          buf\n-      }\n-      ty_open(typ) => format!(\"opened<{}>\", ty_to_string(cx, typ)),\n-      ty_tup(ref elems) => {\n-        let strs: Vec<String> = elems.iter().map(|elem| ty_to_string(cx, *elem)).collect();\n-        format!(\"({})\", strs.connect(\",\"))\n-      }\n-      ty_closure(ref f) => {\n-          closure_to_string(cx, &**f)\n-      }\n-      ty_bare_fn(ref f) => {\n-          bare_fn_to_string(cx, f.fn_style, f.abi, None, &f.sig)\n-      }\n-      ty_infer(infer_ty) => infer_ty.to_string(),\n-      ty_err => \"[type error]\".to_string(),\n-      ty_param(ref param_ty) => {\n-          param_ty.repr(cx)\n-      }\n-      ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n-          let base = ty::item_path_str(cx, did);\n-          let generics = ty::lookup_item_type(cx, did).generics;\n-          parameterized(cx, base.as_slice(), substs, &generics)\n-      }\n-      ty_trait(box ty::TyTrait {\n-          def_id: did, ref substs, ref bounds\n-      }) => {\n-          let base = ty::item_path_str(cx, did);\n-          let trait_def = ty::lookup_trait_def(cx, did);\n-          let ty = parameterized(cx, base.as_slice(),\n-                                 substs, &trait_def.generics);\n-          let bound_str = bounds.user_string(cx);\n-          let bound_sep = if bound_str.is_empty() { \"\" } else { \"+\" };\n-          format!(\"{}{}{}\",\n-                  ty,\n-                  bound_sep,\n-                  bound_str)\n-      }\n-      ty_str => \"str\".to_string(),\n-      ty_unboxed_closure(ref did, _, ref substs) => {\n-          let unboxed_closures = cx.unboxed_closures.borrow();\n-          unboxed_closures.find(did).map(|cl| {\n-              closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n-          }).unwrap_or_else(|| \"closure\".to_string())\n-      }\n-      ty_vec(t, sz) => {\n-          match sz {\n-              Some(n) => {\n-                  format!(\"[{}, ..{}]\", ty_to_string(cx, t), n)\n-              }\n-              None => format!(\"[{}]\", ty_to_string(cx, t)),\n-          }\n-      }\n+    match ty::get(typ).sty {\n+        ty_nil => \"()\".to_string(),\n+        ty_bool => \"bool\".to_string(),\n+        ty_char => \"char\".to_string(),\n+        ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n+        ty_uint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n+        ty_float(t) => ast_util::float_ty_to_string(t).to_string(),\n+        ty_uniq(typ) => format!(\"Box<{}>\", ty_to_string_with_var_ids(cx, typ, print_var_ids)),\n+        ty_ptr(ref tm) => {\n+            format!(\"*{} {}\", match tm.mutbl {\n+                ast::MutMutable => \"mut\",\n+                ast::MutImmutable => \"const\",\n+            }, ty_to_string(cx, tm.ty))\n+        }\n+        ty_rptr(r, ref tm) => {\n+            let mut buf = region_ptr_to_string(cx, r);\n+            buf.push_str(mt_to_string_with_var_ids(cx, tm, print_var_ids).as_slice());\n+            buf\n+        }\n+        ty_open(typ) =>\n+            format!(\"opened<{}>\", ty_to_string_with_var_ids(cx, typ, print_var_ids)),\n+        ty_tup(ref elems) => {\n+            let strs = elems\n+                .iter()\n+                .map(|elem| ty_to_string_with_var_ids(cx, *elem, print_var_ids))\n+                .collect::<Vec<_>>();\n+            match strs.as_slice() {\n+                [ref string] => format!(\"({},)\", string),\n+                strs => format!(\"({})\", strs.connect(\", \"))\n+            }\n+        }\n+        ty_closure(ref f) => {\n+            closure_to_string(cx, &**f, print_var_ids)\n+        }\n+        ty_bare_fn(ref f) => {\n+            bare_fn_to_string(cx, f.fn_style, f.abi, None, &f.sig, print_var_ids)\n+        }\n+        ty_infer(infer_ty) => infer_ty_to_string(infer_ty, print_var_ids),\n+        ty_err => \"[type error]\".to_string(),\n+        ty_param(ref param_ty) => param_ty.repr(cx),\n+        ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n+            let base = ty::item_path_str(cx, did);\n+            let generics = ty::lookup_item_type(cx, did).generics;\n+            parameterized(cx, base.as_slice(), substs, &generics, print_var_ids)\n+        }\n+        ty_trait(box ty::TyTrait {\n+            def_id: did, ref substs, ref bounds\n+        }) => {\n+            let base = ty::item_path_str(cx, did);\n+            let trait_def = ty::lookup_trait_def(cx, did);\n+            let ty = parameterized(cx, base.as_slice(),\n+                                   substs, &trait_def.generics, print_var_ids);\n+            let bound_str = bounds.user_string(cx);\n+            let bound_sep = if bound_str.is_empty() { \"\" } else { \"+\" };\n+            format!(\"{}{}{}\",\n+                    ty,\n+                    bound_sep,\n+                    bound_str)\n+        }\n+        ty_str => \"str\".to_string(),\n+        ty_unboxed_closure(ref did, _, ref substs) => {\n+            let unboxed_closures = cx.unboxed_closures.borrow();\n+            unboxed_closures.find(did).map(|cl| {\n+                closure_to_string(cx, &cl.closure_type.subst(cx, substs), print_var_ids)\n+            }).unwrap_or_else(|| \"closure\".to_string())\n+        }\n+        ty_vec(t, sz) => {\n+            let inner_str = ty_to_string_with_var_ids(cx, t, print_var_ids);\n+            match sz {\n+                Some(n) => format!(\"[{}, ..{}]\", inner_str, n),\n+                None => format!(\"[{}]\", inner_str),\n+            }\n+        }\n     }\n }\n \n@@ -460,7 +492,8 @@ pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n pub fn parameterized(cx: &ctxt,\n                      base: &str,\n                      substs: &subst::Substs,\n-                     generics: &ty::Generics)\n+                     generics: &ty::Generics,\n+                     print_var_ids: bool)\n                      -> String\n {\n     let mut strs = Vec::new();\n@@ -470,15 +503,15 @@ pub fn parameterized(cx: &ctxt,\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions.iter() {\n                 let s = region_to_string(cx, \"\", false, r);\n-                if !s.is_empty() {\n-                    strs.push(s)\n-                } else {\n+                if s.is_empty() {\n                     // This happens when the value of the region\n                     // parameter is not easily serialized. This may be\n                     // because the user omitted it in the first place,\n                     // or because it refers to some block in the code,\n                     // etc. I'm not sure how best to serialize this.\n                     strs.push(format!(\"'_\"));\n+                } else {\n+                    strs.push(s)\n                 }\n             }\n         }\n@@ -499,7 +532,7 @@ pub fn parameterized(cx: &ctxt,\n     };\n \n     for t in tps[..tps.len() - num_defaults].iter() {\n-        strs.push(ty_to_string(cx, *t))\n+        strs.push(ty_to_string_with_var_ids(cx, *t, print_var_ids))\n     }\n \n     if cx.sess.verbose() {\n@@ -515,7 +548,7 @@ pub fn parameterized(cx: &ctxt,\n     }\n \n     if strs.len() > 0u {\n-        format!(\"{}<{}>\", base, strs.connect(\",\"))\n+        format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n         format!(\"{}\", base)\n     }\n@@ -710,7 +743,7 @@ impl Repr for ty::TraitRef {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"<{} as {}>\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics))\n+                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, false))\n     }\n }\n \n@@ -1095,16 +1128,22 @@ impl UserString for ty::BuiltinBounds {\n \n impl UserString for ty::TraitRef {\n     fn user_string(&self, tcx: &ctxt) -> String {\n+        self.user_string_with_var_ids(tcx, false)\n+    }\n+    fn user_string_with_var_ids(&self, tcx: &ctxt, print_var_ids: bool) -> String {\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics)\n+        parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, print_var_ids)\n     }\n }\n \n impl UserString for ty::t {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         ty_to_string(tcx, *self)\n     }\n+    fn user_string_with_var_ids(&self, tcx: &ctxt, print_var_ids: bool) -> String {\n+        ty_to_string_with_var_ids(tcx, *self, print_var_ids)\n+    }\n }\n \n impl UserString for ast::Ident {"}]}