{"sha": "75f667e00077cf682ff3fdbfcca33943a37ce26f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZjY2N2UwMDA3N2NmNjgyZmYzZmRiZmNjYTMzOTQzYTM3Y2UyNmY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-31T10:19:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-31T10:19:12Z"}, "message": "Merge pull request #502 from RalfJung/debug\n\nImprove debug env var handling", "tree": {"sha": "153888736c9130b4e43239e86e0e9916d77d4eca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/153888736c9130b4e43239e86e0e9916d77d4eca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75f667e00077cf682ff3fdbfcca33943a37ce26f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb2YGgCRBK7hj4Ov3rIwAAdHIIAJJwbiZ2mOo2WLYEOJfAzCGJ\nH6NzMEc9+OYqIzZaAmNsgg9Jw18qit4KuuIzMXmj/pwy2OAK19q/5YT8MKZzSJFp\nWHkS291Yd2xq2nl88UXIMiaN3bH6alplvG4cjHYlRkHa7/Ymbp55s8OsLlhj9AKH\nzFCHm1qaH7Ubb3EQKGxmiOoS6p74uvr2NwH5B1xl/+IcEucXGlacM1VqarUAGqif\nwCInOjjqwHSFZ6wJvm37Am0WfeiL9NcO9hmzXl7jcW7SvkruDDMChoP10UtOZ7Wd\nFIDpvnwWzDDqR7k8si88m3YNefV1tkHVkGGjW2cD4yYTg55GIZ8qsh0lNZrSsBE=\n=nA8A\n-----END PGP SIGNATURE-----\n", "payload": "tree 153888736c9130b4e43239e86e0e9916d77d4eca\nparent f0c1f18314bc20c95a46246c9a67d688ef3c0ed2\nparent 016009a3016dde768806a352aaa5da9c852d9dc5\nauthor Ralf Jung <post@ralfj.de> 1540981152 +0100\ncommitter GitHub <noreply@github.com> 1540981152 +0100\n\nMerge pull request #502 from RalfJung/debug\n\nImprove debug env var handling"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75f667e00077cf682ff3fdbfcca33943a37ce26f", "html_url": "https://github.com/rust-lang/rust/commit/75f667e00077cf682ff3fdbfcca33943a37ce26f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75f667e00077cf682ff3fdbfcca33943a37ce26f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0c1f18314bc20c95a46246c9a67d688ef3c0ed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0c1f18314bc20c95a46246c9a67d688ef3c0ed2", "html_url": "https://github.com/rust-lang/rust/commit/f0c1f18314bc20c95a46246c9a67d688ef3c0ed2"}, {"sha": "016009a3016dde768806a352aaa5da9c852d9dc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/016009a3016dde768806a352aaa5da9c852d9dc5", "html_url": "https://github.com/rust-lang/rust/commit/016009a3016dde768806a352aaa5da9c852d9dc5"}], "stats": {"total": 119, "additions": 72, "deletions": 47}, "files": [{"sha": "a905c2aeffb72f2f2a8603481173ed5477866d21", "filename": "README.md", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/75f667e00077cf682ff3fdbfcca33943a37ce26f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/75f667e00077cf682ff3fdbfcca33943a37ce26f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=75f667e00077cf682ff3fdbfcca33943a37ce26f", "patch": "@@ -114,7 +114,7 @@ Several `-Z` flags are relevant for miri:\n \n Since the heart of Miri (the main interpreter engine) lives in rustc, working on\n Miri will often require using a locally built rustc. This includes getting a\n-trace of the execution, as distributed rustc has `trace!` disabled.\n+trace of the execution, as distributed rustc has `debug!` and `trace!` disabled.\n \n The first-time setup for a local rustc looks as follows:\n ```\n@@ -130,14 +130,28 @@ rustup override set custom\n ```\n The `build` step can take 30 minutes and more.\n \n-Now you can `cargo build` Miri, and you can `cargo test --tests`.  (`--tests`\n-is needed to skip doctests because we have not built rustdoc for your custom\n-toolchain.) You can also set `RUST_LOG=rustc_mir::interpret=trace` as\n-environment variable to get a step-by-step trace.\n+Now you can `cargo build` Miri, and you can `cargo test` it.  But the key point\n+is, you can now run Miri with a trace of all execution steps:\n+\n+```sh\n+MIRI_LOG=debug cargo run tests/run-pass/vecs.rs\n+```\n+\n+Setting `MIRI_LOG` like this will configure logging for miri itself as well as\n+the `rustc::mir::interpret` and `rustc_mir::interpret` modules in rustc.  You\n+can also do more targeted configuration, e.g. to debug the stacked borrows\n+implementation:\n+\n+```sh\n+MIRI_LOG=miri::stacked_borrows=trace,rustc_mir::interpret=debug cargo run tests/run-pass/vecs.rs\n+```\n+\n+In addition, you can set `MIRI_BACKTRACE=1` to get a backtrace of where an\n+evaluation error was originally created.\n \n If you changed something in rustc and want to re-build, run\n ```\n-./x.py build src/rustc --keep-stage 0\n+./x.py --keep-stage 0 build src/rustc\n ```\n This avoids rebuilding the entire stage 0, which can save a lot of time.\n "}, {"sha": "bacea04c976865a3a31a6b409eafb5d8ecad9d77", "filename": "src/bin/miri.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/75f667e00077cf682ff3fdbfcca33943a37ce26f/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f667e00077cf682ff3fdbfcca33943a37ce26f/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=75f667e00077cf682ff3fdbfcca33943a37ce26f", "patch": "@@ -12,6 +12,10 @@ extern crate log_settings;\n extern crate syntax;\n extern crate log;\n \n+use std::path::PathBuf;\n+use std::str::FromStr;\n+use std::env;\n+\n use rustc::session::Session;\n use rustc_metadata::cstore::CStore;\n use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n@@ -21,7 +25,6 @@ use rustc::hir::{self, itemlikevisit};\n use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use syntax::ast;\n-use std::path::PathBuf;\n \n struct MiriCompilerCalls {\n     default: Box<RustcDefaultCalls>,\n@@ -105,6 +108,7 @@ fn after_analysis<'a, 'tcx>(\n     state: &mut CompileState<'a, 'tcx>,\n     validate: bool,\n ) {\n+    init_late_loggers();\n     state.session.abort_if_errors();\n \n     let tcx = state.tcx.unwrap();\n@@ -148,42 +152,39 @@ fn after_analysis<'a, 'tcx>(\n     }\n }\n \n-fn init_logger() {\n-    let format = |formatter: &mut env_logger::fmt::Formatter, record: &log::Record| {\n-        use std::io::Write;\n-        if record.level() == log::Level::Trace {\n-            // prepend frame number\n-            let indentation = log_settings::settings().indentation;\n-            writeln!(\n-                formatter,\n-                \"{indentation}:{lvl}:{module}: {text}\",\n-                lvl = record.level(),\n-                module = record.module_path().unwrap_or(\"<unknown module>\"),\n-                indentation = indentation,\n-                text = record.args(),\n-            )\n-        } else {\n-            writeln!(\n-                formatter,\n-                \"{lvl}:{module}: {text}\",\n-                lvl = record.level(),\n-                module = record.module_path().unwrap_or(\"<unknown_module>\"),\n-                text = record.args(),\n-            )\n-        }\n-    };\n-\n-    let mut builder = env_logger::Builder::new();\n-    builder.format(format).filter(\n-        None,\n-        log::LevelFilter::Info,\n-    );\n-\n-    if std::env::var(\"MIRI_LOG\").is_ok() {\n-        builder.parse(&std::env::var(\"MIRI_LOG\").unwrap());\n+fn init_early_loggers() {\n+    // Notice that our `extern crate log` is NOT the same as rustc's!  So we have to initialize\n+    // them both.  We always initialize miri early.\n+    let env = env_logger::Env::new().filter(\"MIRI_LOG\").write_style(\"MIRI_LOG_STYLE\");\n+    env_logger::init_from_env(env);\n+    // We only initialize rustc if the env var is set (so the user asked for it).\n+    // If it is not set, we avoid initializing now so that we can initialize\n+    // later with our custom settings, and NOT log anything for what happens before\n+    // miri gets started.\n+    if env::var(\"RUST_LOG\").is_ok() {\n+        rustc_driver::init_rustc_env_logger();\n     }\n+}\n \n-    builder.init();\n+fn init_late_loggers() {\n+    // Initializing loggers right before we start evaluation.  We overwrite the RUST_LOG\n+    // env var if it is not set, control it based on MIRI_LOG.\n+    if let Ok(var) = env::var(\"MIRI_LOG\") {\n+        if env::var(\"RUST_LOG\").is_err() {\n+            // We try to be a bit clever here: If MIRI_LOG is just a single level\n+            // used for everything, we only apply it to the parts of rustc that are\n+            // CTFE-related.  Otherwise, we use it verbatim for RUST_LOG.\n+            // This way, if you set `MIRI_LOG=trace`, you get only the right parts of\n+            // rustc traced, but you can also do `MIRI_LOG=miri=trace,rustc_mir::interpret=debug`.\n+            if log::Level::from_str(&var).is_ok() {\n+                env::set_var(\"RUST_LOG\",\n+                    &format!(\"rustc::mir::interpret={0},rustc_mir::interpret={0}\", var));\n+            } else {\n+                env::set_var(\"RUST_LOG\", &var);\n+            }\n+            rustc_driver::init_rustc_env_logger();\n+        }\n+    }\n }\n \n fn find_sysroot() -> String {\n@@ -208,8 +209,7 @@ fn find_sysroot() -> String {\n }\n \n fn main() {\n-    rustc_driver::init_rustc_env_logger();\n-    init_logger();\n+    init_early_loggers();\n     let mut args: Vec<String> = std::env::args().collect();\n \n     let sysroot_flag = String::from(\"--sysroot\");"}, {"sha": "650998c3e16c82dad8b996db81d4bd9e2ed48481", "filename": "src/lib.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/75f667e00077cf682ff3fdbfcca33943a37ce26f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f667e00077cf682ff3fdbfcca33943a37ce26f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=75f667e00077cf682ff3fdbfcca33943a37ce26f", "patch": "@@ -6,15 +6,16 @@\n extern crate log;\n \n // From rustc.\n+extern crate syntax;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate rustc_target;\n-extern crate syntax;\n \n use std::collections::HashMap;\n use std::borrow::Cow;\n+use std::env;\n \n use rustc::ty::{self, Ty, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n@@ -157,11 +158,21 @@ pub fn eval_main<'a, 'tcx: 'a>(\n ) {\n     let mut ecx = create_ecx(tcx, main_id, validate).expect(\"Couldn't create ecx\");\n \n+    // If MIRI_BACKTRACE is set and RUST_CTFE_BACKTRACE is not, set RUST_CTFE_BACKTRACE.\n+    // Do this late, so we really only apply this to miri's errors.\n+    if let Ok(var) = env::var(\"MIRI_BACKTRACE\") {\n+        if env::var(\"RUST_CTFE_BACKTRACE\") == Err(env::VarError::NotPresent) {\n+            env::set_var(\"RUST_CTFE_BACKTRACE\", &var);\n+        }\n+    }\n+\n+    // Run! The main execution.\n     let res: EvalResult = (|| {\n         ecx.run()?;\n         ecx.run_tls_dtors()\n     })();\n \n+    // Process the result.\n     match res {\n         Ok(()) => {\n             let leaks = ecx.memory().leak_report();\n@@ -173,7 +184,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 tcx.sess.err(\"the evaluated program leaked memory\");\n             }\n         }\n-        Err(e) => {\n+        Err(mut e) => {\n+            e.print_backtrace();\n             if let Some(frame) = ecx.stack().last() {\n                 let block = &frame.mir.basic_blocks()[frame.block];\n                 let span = if frame.stmt < block.statements.len() {\n@@ -195,7 +207,6 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 ecx.tcx.sess.err(&e.to_string());\n             }\n \n-            /* Nice try, but with MIRI_BACKTRACE this shows 100s of backtraces.\n             for (i, frame) in ecx.stack().iter().enumerate() {\n                 trace!(\"-------------------\");\n                 trace!(\"Frame {}\", i);\n@@ -205,7 +216,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                         trace!(\"    local {}: {:?}\", i, local);\n                     }\n                 }\n-            }*/\n+            }\n         }\n     }\n }"}]}