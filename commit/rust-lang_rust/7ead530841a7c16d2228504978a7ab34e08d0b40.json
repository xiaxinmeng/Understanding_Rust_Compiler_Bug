{"sha": "7ead530841a7c16d2228504978a7ab34e08d0b40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYWQ1MzA4NDFhN2MxNmQyMjI4NTA0OTc4YTdhYjM0ZTA4ZDBiNDA=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-23T11:56:23Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-23T11:56:23Z"}, "message": "Rustfmt all the things", "tree": {"sha": "707952ccd06b59e1b560ab1d701284766c5a047c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/707952ccd06b59e1b560ab1d701284766c5a047c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ead530841a7c16d2228504978a7ab34e08d0b40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ead530841a7c16d2228504978a7ab34e08d0b40", "html_url": "https://github.com/rust-lang/rust/commit/7ead530841a7c16d2228504978a7ab34e08d0b40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ead530841a7c16d2228504978a7ab34e08d0b40/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3ea1cb4581970396635fce82182555003083b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ea1cb4581970396635fce82182555003083b62", "html_url": "https://github.com/rust-lang/rust/commit/a3ea1cb4581970396635fce82182555003083b62"}], "stats": {"total": 1795, "additions": 901, "deletions": 894}, "files": [{"sha": "ebb1b5fd0b185cc9f410420f81de780eee151664", "filename": "benches/fibonacci.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/benches%2Ffibonacci.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/benches%2Ffibonacci.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Ffibonacci.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -7,7 +7,7 @@ use crate::helpers::*;\n \n #[bench]\n fn fib(bencher: &mut Bencher) {\n-    bencher.iter(|| { fibonacci_helper::main(); })\n+    bencher.iter(|| fibonacci_helper::main())\n }\n \n #[bench]\n@@ -17,7 +17,7 @@ fn fib_miri(bencher: &mut Bencher) {\n \n #[bench]\n fn fib_iter(bencher: &mut Bencher) {\n-    bencher.iter(|| { fibonacci_helper_iterative::main(); })\n+    bencher.iter(|| fibonacci_helper_iterative::main())\n }\n \n #[bench]"}, {"sha": "92aedcc4244a96f44f3a9fe5e6fe3227dbeec203", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -6,23 +6,26 @@ extern crate rustc_interface;\n extern crate test;\n \n use self::miri::eval_main;\n+use crate::test::Bencher;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc_interface::{interface, Queries};\n use rustc_driver::Compilation;\n-use crate::test::Bencher;\n+use rustc_interface::{interface, Queries};\n \n struct MiriCompilerCalls<'a> {\n     bencher: &'a mut Bencher,\n }\n \n impl rustc_driver::Callbacks for MiriCompilerCalls<'_> {\n-    fn after_analysis<'tcx>(&mut self, compiler: &interface::Compiler, queries: &'tcx Queries<'tcx>) -> Compilation {\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        compiler: &interface::Compiler,\n+        queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n         compiler.session().abort_if_errors();\n \n         queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n-            let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\n-                \"no main or start function found\",\n-            );\n+            let (entry_def_id, _) =\n+                tcx.entry_fn(LOCAL_CRATE).expect(\"no main or start function found\");\n \n             self.bencher.iter(|| {\n                 let config = miri::MiriConfig {\n@@ -50,13 +53,9 @@ fn find_sysroot() -> String {\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n     match (home, toolchain) {\n         (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n-        _ => {\n-            option_env!(\"RUST_SYSROOT\")\n-                .expect(\n-                    \"need to specify RUST_SYSROOT env var or use rustup or multirust\",\n-                )\n-                .to_owned()\n-        }\n+        _ => option_env!(\"RUST_SYSROOT\")\n+            .expect(\"need to specify RUST_SYSROOT env var or use rustup or multirust\")\n+            .to_owned(),\n     }\n }\n "}, {"sha": "9229e972d7f3ba9f492aef10a01aeec9ff5e39cf", "filename": "benches/smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/benches%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/benches%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fsmoke.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -7,7 +7,7 @@ use crate::helpers::*;\n \n #[bench]\n fn noop(bencher: &mut Bencher) {\n-    bencher.iter(|| { smoke_helper::main(); })\n+    bencher.iter(|| smoke_helper::main())\n }\n \n /*"}, {"sha": "a0d494b335a888f94e8bf5ff3cf7b2d5f6db4533", "filename": "rustfmt.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -0,0 +1,3 @@\n+use_small_heuristics = \"Max\"\n+version = \"Two\"\n+match_arm_blocks = false"}, {"sha": "955167bc425dbfda3b75b934f30fc7516430a7a0", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 105, "deletions": 90, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,10 +1,10 @@\n #![feature(inner_deref)]\n \n use std::fs::{self, File};\n-use std::io::{self, Write, BufRead};\n-use std::path::{PathBuf, Path};\n-use std::process::Command;\n+use std::io::{self, BufRead, Write};\n use std::ops::Not;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n \n const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 17);\n \n@@ -40,8 +40,12 @@ fn show_help() {\n }\n \n fn show_version() {\n-    println!(\"miri {} ({} {})\",\n-        env!(\"CARGO_PKG_VERSION\"), env!(\"VERGEN_SHA_SHORT\"), env!(\"VERGEN_COMMIT_DATE\"));\n+    println!(\n+        \"miri {} ({} {})\",\n+        env!(\"CARGO_PKG_VERSION\"),\n+        env!(\"VERGEN_SHA_SHORT\"),\n+        env!(\"VERGEN_COMMIT_DATE\")\n+    );\n }\n \n fn show_error(msg: String) -> ! {\n@@ -80,11 +84,10 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n     }\n }\n \n-fn list_targets() -> impl Iterator<Item=cargo_metadata::Target> {\n+fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     // We need to get the manifest, and then the metadata, to enumerate targets.\n-    let manifest_path = get_arg_flag_value(\"--manifest-path\").map(|m|\n-        Path::new(&m).canonicalize().unwrap()\n-    );\n+    let manifest_path =\n+        get_arg_flag_value(\"--manifest-path\").map(|m| Path::new(&m).canonicalize().unwrap());\n \n     let mut cmd = cargo_metadata::MetadataCommand::new();\n     if let Some(ref manifest_path) = manifest_path {\n@@ -106,16 +109,18 @@ fn list_targets() -> impl Iterator<Item=cargo_metadata::Target> {\n             if let Some(ref manifest_path) = manifest_path {\n                 package_manifest_path == manifest_path\n             } else {\n-                let current_dir = current_dir.as_ref().expect(\n-                    \"could not read current directory\",\n-                );\n-                let package_manifest_directory = package_manifest_path.parent().expect(\n-                    \"could not find parent directory of package manifest\",\n-                );\n+                let current_dir = current_dir.as_ref().expect(\"could not read current directory\");\n+                let package_manifest_directory = package_manifest_path\n+                    .parent()\n+                    .expect(\"could not find parent directory of package manifest\");\n                 package_manifest_directory == current_dir\n             }\n         })\n-        .unwrap_or_else(|| show_error(format!(\"This seems to be a workspace, which is not supported by cargo-miri\")));\n+        .unwrap_or_else(|| {\n+            show_error(format!(\n+                \"This seems to be a workspace, which is not supported by cargo-miri\"\n+            ))\n+        });\n     let package = metadata.packages.remove(package_index);\n \n     // Finally we got the list of targets to build\n@@ -134,17 +139,24 @@ fn find_miri() -> PathBuf {\n /// toolchain than what is used when `cargo miri` is run.\n fn test_sysroot_consistency() {\n     fn get_sysroot(mut cmd: Command) -> PathBuf {\n-        let out = cmd.arg(\"--print\").arg(\"sysroot\")\n-            .output().expect(\"Failed to run rustc to get sysroot info\");\n+        let out = cmd\n+            .arg(\"--print\")\n+            .arg(\"sysroot\")\n+            .output()\n+            .expect(\"Failed to run rustc to get sysroot info\");\n         let stdout = String::from_utf8(out.stdout).expect(\"stdout is not valid UTF-8\");\n         let stderr = String::from_utf8(out.stderr).expect(\"stderr is not valid UTF-8\");\n         assert!(\n             out.status.success(),\n             \"Bad status code {} when getting sysroot info via {:?}.\\nstdout:\\n{}\\nstderr:\\n{}\",\n-            out.status, cmd, stdout, stderr,\n+            out.status,\n+            cmd,\n+            stdout,\n+            stderr,\n         );\n         let stdout = stdout.trim();\n-        PathBuf::from(stdout).canonicalize()\n+        PathBuf::from(stdout)\n+            .canonicalize()\n             .unwrap_or_else(|_| panic!(\"Failed to canonicalize sysroot: {}\", stdout))\n     }\n \n@@ -164,7 +176,8 @@ fn test_sysroot_consistency() {\n              Make sure you use the same toolchain to run miri that you used to build it!\\n\\\n              rustc sysroot: `{}`\\n\\\n              miri sysroot: `{}`\",\n-             rustc_sysroot.display(), miri_sysroot.display()\n+            rustc_sysroot.display(),\n+            miri_sysroot.display()\n         ));\n     }\n }\n@@ -193,28 +206,36 @@ fn xargo_version() -> Option<(u32, u32, u32)> {\n         return None;\n     }\n     // Parse output. The first line looks like \"xargo 0.3.12 (b004f1c 2018-12-13)\".\n-    let line = out.stderr.lines().nth(0)\n+    let line = out\n+        .stderr\n+        .lines()\n+        .nth(0)\n         .expect(\"malformed `xargo --version` output: not at least one line\")\n         .expect(\"malformed `xargo --version` output: error reading first line\");\n     let (name, version) = {\n         let mut split = line.split(' ');\n-        (split.next().expect(\"malformed `xargo --version` output: empty\"),\n-         split.next().expect(\"malformed `xargo --version` output: not at least two words\"))\n+        (\n+            split.next().expect(\"malformed `xargo --version` output: empty\"),\n+            split.next().expect(\"malformed `xargo --version` output: not at least two words\"),\n+        )\n     };\n     if name != \"xargo\" {\n         // This is some fork of xargo\n         return None;\n     }\n     let mut version_pieces = version.split('.');\n-    let major = version_pieces.next()\n+    let major = version_pieces\n+        .next()\n         .expect(\"malformed `xargo --version` output: not a major version piece\")\n         .parse()\n         .expect(\"malformed `xargo --version` output: major version is not an integer\");\n-    let minor = version_pieces.next()\n+    let minor = version_pieces\n+        .next()\n         .expect(\"malformed `xargo --version` output: not a minor version piece\")\n         .parse()\n         .expect(\"malformed `xargo --version` output: minor version is not an integer\");\n-    let patch = version_pieces.next()\n+    let patch = version_pieces\n+        .next()\n         .expect(\"malformed `xargo --version` output: not a patch version piece\")\n         .parse()\n         .expect(\"malformed `xargo --version` output: patch version is not an integer\");\n@@ -232,18 +253,15 @@ fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n         io::stdin().read_line(&mut buf).unwrap();\n         match buf.trim().to_lowercase().as_ref() {\n             // Proceed.\n-            \"\" | \"y\" | \"yes\" => {},\n+            \"\" | \"y\" | \"yes\" => {}\n             \"n\" | \"no\" => show_error(format!(\"Aborting as per your request\")),\n-            a => show_error(format!(\"I do not understand `{}`\", a))\n+            a => show_error(format!(\"I do not understand `{}`\", a)),\n         };\n     } else {\n         println!(\"Running `{:?}` to {}.\", cmd, text);\n     }\n \n-    if cmd.status()\n-        .expect(&format!(\"failed to execute {:?}\", cmd))\n-        .success().not()\n-    {\n+    if cmd.status().expect(&format!(\"failed to execute {:?}\", cmd)).success().not() {\n         show_error(format!(\"Failed to {}\", text));\n     }\n }\n@@ -275,7 +293,9 @@ fn setup(ask_user: bool) {\n         Ok(val) => PathBuf::from(val),\n         Err(_) => {\n             // Check for `rust-src` rustup component.\n-            let sysroot = Command::new(\"rustc\").args(&[\"--print\", \"sysroot\"]).output()\n+            let sysroot = Command::new(\"rustc\")\n+                .args(&[\"--print\", \"sysroot\"])\n+                .output()\n                 .expect(\"failed to get rustc sysroot\")\n                 .stdout;\n             let sysroot = std::str::from_utf8(&sysroot).unwrap();\n@@ -298,7 +318,11 @@ fn setup(ask_user: bool) {\n                         // Fallback: Ask the user to install the `rust-src` component, and use that.\n                         let mut cmd = Command::new(\"rustup\");\n                         cmd.args(&[\"component\", \"add\", \"rust-src\"]);\n-                        ask_to_run(cmd, ask_user, \"install the rustc-src component for the selected toolchain\");\n+                        ask_to_run(\n+                            cmd,\n+                            ask_user,\n+                            \"install the rustc-src component for the selected toolchain\",\n+                        );\n                         rustup_src\n                     }\n                 }\n@@ -317,27 +341,35 @@ fn setup(ask_user: bool) {\n         fs::create_dir_all(&dir).unwrap();\n     }\n     // The interesting bit: Xargo.toml\n-    File::create(dir.join(\"Xargo.toml\")).unwrap()\n-        .write_all(br#\"\n+    File::create(dir.join(\"Xargo.toml\"))\n+        .unwrap()\n+        .write_all(\n+            br#\"\n [dependencies.std]\n default_features = false\n # We need the `panic_unwind` feature because we use the `unwind` panic strategy.\n # Using `abort` works for libstd, but then libtest will not compile.\n features = [\"panic_unwind\"]\n \n [dependencies.test]\n-        \"#).unwrap();\n+        \"#,\n+        )\n+        .unwrap();\n     // The boring bits: a dummy project for xargo.\n-    File::create(dir.join(\"Cargo.toml\")).unwrap()\n-        .write_all(br#\"\n+    File::create(dir.join(\"Cargo.toml\"))\n+        .unwrap()\n+        .write_all(\n+            br#\"\n [package]\n name = \"miri-xargo\"\n description = \"A dummy project for building libstd with xargo.\"\n version = \"0.0.0\"\n \n [lib]\n path = \"lib.rs\"\n-        \"#).unwrap();\n+        \"#,\n+        )\n+        .unwrap();\n     File::create(dir.join(\"lib.rs\")).unwrap();\n     // Prepare xargo invocation.\n     let target = get_arg_flag_value(\"--target\");\n@@ -355,10 +387,7 @@ path = \"lib.rs\"\n         command.arg(\"--target\").arg(&target);\n     }\n     // Finally run it!\n-    if command.status()\n-        .expect(\"failed to run xargo\")\n-        .success().not()\n-    {\n+    if command.status().expect(\"failed to run xargo\").success().not() {\n         show_error(format!(\"Failed to run xargo\"));\n     }\n \n@@ -413,9 +442,7 @@ fn in_cargo_miri() {\n         Some(s) if s.starts_with(\"-\") => (MiriCommand::Run, 2),\n         None => (MiriCommand::Run, 2),\n         // Invalid command.\n-        Some(s) => {\n-            show_error(format!(\"Unknown command `{}`\", s))\n-        }\n+        Some(s) => show_error(format!(\"Unknown command `{}`\", s)),\n     };\n     let verbose = has_arg_flag(\"-v\");\n \n@@ -433,9 +460,10 @@ fn in_cargo_miri() {\n     // Now run the command.\n     for target in list_targets() {\n         let mut args = std::env::args().skip(skip);\n-        let kind = target.kind.get(0).expect(\n-            \"badly formatted cargo metadata: target::kind is an empty array\",\n-        );\n+        let kind = target\n+            .kind\n+            .get(0)\n+            .expect(\"badly formatted cargo metadata: target::kind is an empty array\");\n         // Now we run `cargo rustc $FLAGS $ARGS`, giving the user the\n         // change to add additional arguments. `FLAGS` is set to identify\n         // this target.  The user gets to control what gets actually passed to Miri.\n@@ -470,22 +498,15 @@ fn in_cargo_miri() {\n         // Add `--` (to end the `cargo` flags), and then the user flags. We add markers around the\n         // user flags to be able to identify them later.  \"cargo rustc\" adds more stuff after this,\n         // so we have to mark both the beginning and the end.\n-        cmd\n-            .arg(\"--\")\n-            .arg(\"cargo-miri-marker-begin\")\n-            .args(args)\n-            .arg(\"cargo-miri-marker-end\");\n+        cmd.arg(\"--\").arg(\"cargo-miri-marker-begin\").args(args).arg(\"cargo-miri-marker-end\");\n         let path = std::env::current_exe().expect(\"current executable path invalid\");\n         cmd.env(\"RUSTC_WRAPPER\", path);\n         if verbose {\n             eprintln!(\"+ {:?}\", cmd);\n         }\n \n-        let exit_status = cmd\n-            .spawn()\n-            .expect(\"could not run cargo\")\n-            .wait()\n-            .expect(\"failed to wait for cargo?\");\n+        let exit_status =\n+            cmd.spawn().expect(\"could not run cargo\").wait().expect(\"failed to wait for cargo?\");\n \n         if !exit_status.success() {\n             std::process::exit(exit_status.code().unwrap_or(-1))\n@@ -497,49 +518,43 @@ fn inside_cargo_rustc() {\n     let sysroot = std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n \n     let rustc_args = std::env::args().skip(2); // skip `cargo rustc`\n-    let mut args: Vec<String> = rustc_args\n-        .chain(Some(\"--sysroot\".to_owned()))\n-        .chain(Some(sysroot))\n-        .collect();\n+    let mut args: Vec<String> =\n+        rustc_args.chain(Some(\"--sysroot\".to_owned())).chain(Some(sysroot)).collect();\n     args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n \n     // See if we can find the `cargo-miri` markers. Those only get added to the binary we want to\n     // run. They also serve to mark the user-defined arguments, which we have to move all the way\n     // to the end (they get added somewhere in the middle).\n-    let needs_miri = if let Some(begin) = args.iter().position(|arg| arg == \"cargo-miri-marker-begin\") {\n-        let end = args\n-            .iter()\n-            .position(|arg| arg == \"cargo-miri-marker-end\")\n-            .expect(\"cannot find end marker\");\n-        // These mark the user arguments. We remove the first and last as they are the markers.\n-        let mut user_args = args.drain(begin..=end);\n-        assert_eq!(user_args.next().unwrap(), \"cargo-miri-marker-begin\");\n-        assert_eq!(user_args.next_back().unwrap(), \"cargo-miri-marker-end\");\n-        // Collect the rest and add it back at the end.\n-        let mut user_args = user_args.collect::<Vec<String>>();\n-        args.append(&mut user_args);\n-        // Run this in Miri.\n-        true\n-    } else {\n-        false\n-    };\n+    let needs_miri =\n+        if let Some(begin) = args.iter().position(|arg| arg == \"cargo-miri-marker-begin\") {\n+            let end = args\n+                .iter()\n+                .position(|arg| arg == \"cargo-miri-marker-end\")\n+                .expect(\"cannot find end marker\");\n+            // These mark the user arguments. We remove the first and last as they are the markers.\n+            let mut user_args = args.drain(begin..=end);\n+            assert_eq!(user_args.next().unwrap(), \"cargo-miri-marker-begin\");\n+            assert_eq!(user_args.next_back().unwrap(), \"cargo-miri-marker-end\");\n+            // Collect the rest and add it back at the end.\n+            let mut user_args = user_args.collect::<Vec<String>>();\n+            args.append(&mut user_args);\n+            // Run this in Miri.\n+            true\n+        } else {\n+            false\n+        };\n \n-    let mut command = if needs_miri {\n-        Command::new(find_miri())\n-    } else {\n-        Command::new(\"rustc\")\n-    };\n+    let mut command = if needs_miri { Command::new(find_miri()) } else { Command::new(\"rustc\") };\n     command.args(&args);\n     if has_arg_flag(\"-v\") {\n         eprintln!(\"+ {:?}\", command);\n     }\n \n     match command.status() {\n-        Ok(exit) => {\n+        Ok(exit) =>\n             if !exit.success() {\n                 std::process::exit(exit.code().unwrap_or(42));\n-            }\n-        }\n+            },\n         Err(ref e) if needs_miri => panic!(\"error during miri run: {:?}\", e),\n         Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n     }"}, {"sha": "19816fe008f5d12e8e0b12c80d3f21b73647db29", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,25 +1,24 @@\n #![feature(rustc_private)]\n-extern crate miri;\n extern crate getopts;\n+extern crate miri;\n extern crate rustc;\n-extern crate rustc_metadata;\n+extern crate rustc_codegen_utils;\n extern crate rustc_driver;\n extern crate rustc_errors;\n-extern crate rustc_codegen_utils;\n extern crate rustc_interface;\n+extern crate rustc_metadata;\n extern crate syntax;\n \n-use std::path::Path;\n-use std::io::Write;\n-use std::sync::{Mutex, Arc};\n use std::io;\n+use std::io::Write;\n+use std::path::Path;\n+use std::sync::{Arc, Mutex};\n \n-\n-use rustc_interface::{interface, Queries};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::{self, itemlikevisit};\n use rustc::ty::TyCtxt;\n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc_driver::Compilation;\n+use rustc_interface::{interface, Queries};\n \n use miri::MiriConfig;\n \n@@ -29,15 +28,20 @@ struct MiriCompilerCalls {\n }\n \n impl rustc_driver::Callbacks for MiriCompilerCalls {\n-    fn after_analysis<'tcx>(&mut self, compiler: &interface::Compiler, queries: &'tcx Queries<'tcx>) -> Compilation {\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        compiler: &interface::Compiler,\n+        queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n         compiler.session().abort_if_errors();\n         queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n             if std::env::args().any(|arg| arg == \"--test\") {\n                 struct Visitor<'tcx>(TyCtxt<'tcx>);\n                 impl<'tcx, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'tcx> {\n                     fn visit_item(&mut self, i: &'hir hir::Item) {\n                         if let hir::ItemKind::Fn(.., body_id) = i.kind {\n-                            if i.attrs.iter().any(|attr| attr.check_name(syntax::symbol::sym::test)) {\n+                            if i.attrs.iter().any(|attr| attr.check_name(syntax::symbol::sym::test))\n+                            {\n                                 let config = MiriConfig {\n                                     validate: true,\n                                     communicate: false,\n@@ -82,12 +86,10 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n }\n \n fn main() {\n-    let path = option_env!(\"MIRI_RUSTC_TEST\")\n-        .map(String::from)\n-        .unwrap_or_else(|| {\n-            std::env::var(\"MIRI_RUSTC_TEST\")\n-                .expect(\"need to set MIRI_RUSTC_TEST to path of rustc tests\")\n-        });\n+    let path = option_env!(\"MIRI_RUSTC_TEST\").map(String::from).unwrap_or_else(|| {\n+        std::env::var(\"MIRI_RUSTC_TEST\")\n+            .expect(\"need to set MIRI_RUSTC_TEST to path of rustc tests\")\n+    });\n \n     let mut mir_not_found = Vec::new();\n     let mut crate_not_found = Vec::new();\n@@ -115,22 +117,30 @@ fn main() {\n         let stderr = std::io::stderr();\n         write!(stderr.lock(), \"test [miri-pass] {} ... \", path.display()).unwrap();\n         let mut host_target = false;\n-        let mut args: Vec<String> = std::env::args().filter(|arg| {\n-            if arg == \"--miri_host_target\" {\n-                host_target = true;\n-                false // remove the flag, rustc doesn't know it\n-            } else {\n-                true\n-            }\n-        }).collect();\n+        let mut args: Vec<String> = std::env::args()\n+            .filter(|arg| {\n+                if arg == \"--miri_host_target\" {\n+                    host_target = true;\n+                    false // remove the flag, rustc doesn't know it\n+                } else {\n+                    true\n+                }\n+            })\n+            .collect();\n         args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n         // file to process\n         args.push(path.display().to_string());\n \n         let sysroot_flag = String::from(\"--sysroot\");\n         if !args.contains(&sysroot_flag) {\n             args.push(sysroot_flag);\n-            args.push(Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\").display().to_string());\n+            args.push(\n+                Path::new(&std::env::var(\"HOME\").unwrap())\n+                    .join(\".xargo\")\n+                    .join(\"HOST\")\n+                    .display()\n+                    .to_string(),\n+            );\n         }\n \n         // A threadsafe buffer for writing.\n@@ -148,14 +158,19 @@ fn main() {\n         let buf = BufWriter::default();\n         let output = buf.clone();\n         let result = std::panic::catch_unwind(|| {\n-            let _ = rustc_driver::run_compiler(&args, &mut MiriCompilerCalls { host_target }, None, Some(Box::new(buf)));\n+            let _ = rustc_driver::run_compiler(\n+                &args,\n+                &mut MiriCompilerCalls { host_target },\n+                None,\n+                Some(Box::new(buf)),\n+            );\n         });\n \n         match result {\n             Ok(()) => {\n                 success += 1;\n                 writeln!(stderr.lock(), \"ok\").unwrap()\n-            },\n+            }\n             Err(_) => {\n                 let output = output.0.lock().unwrap();\n                 let output_err = std::str::from_utf8(&output).unwrap();\n@@ -178,7 +193,8 @@ fn main() {\n                         if text.starts_with(c_abi) {\n                             c_abi_fns.push(text[c_abi.len()..end].to_string());\n                         } else if text.starts_with(unimplemented_intrinsic_s) {\n-                            unimplemented_intrinsic.push(text[unimplemented_intrinsic_s.len()..end].to_string());\n+                            unimplemented_intrinsic\n+                                .push(text[unimplemented_intrinsic_s.len()..end].to_string());\n                         } else if text.starts_with(unsupported_s) {\n                             unsupported.push(text[unsupported_s.len()..end].to_string());\n                         } else if text.starts_with(abi_s) {\n@@ -196,10 +212,19 @@ fn main() {\n     }\n     let stderr = std::io::stderr();\n     let mut stderr = stderr.lock();\n-    writeln!(stderr, \"{} success, {} no mir, {} crate not found, {} failed, \\\n-                        {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n-                        success, mir_not_found.len(), crate_not_found.len(), failed.len(),\n-                        c_abi_fns.len(), abi.len(), unsupported.len(), unimplemented_intrinsic.len()).unwrap();\n+    writeln!(\n+        stderr,\n+        \"{} success, {} no mir, {} crate not found, {} failed, {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n+        success,\n+        mir_not_found.len(),\n+        crate_not_found.len(),\n+        failed.len(),\n+        c_abi_fns.len(),\n+        abi.len(),\n+        unsupported.len(),\n+        unimplemented_intrinsic.len()\n+    )\n+    .unwrap();\n     writeln!(stderr, \"# The \\\"other reasons\\\" errors\").unwrap();\n     writeln!(stderr, \"(sorted, deduplicated)\").unwrap();\n     print_vec(&mut stderr, failed);"}, {"sha": "1af79b259613d913e5ba10352a4908fc803c5071", "filename": "src/bin/miri.rs", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -7,29 +7,33 @@ extern crate log;\n extern crate log_settings;\n extern crate miri;\n extern crate rustc;\n-extern crate rustc_metadata;\n+extern crate rustc_codegen_utils;\n extern crate rustc_driver;\n extern crate rustc_errors;\n-extern crate rustc_codegen_utils;\n extern crate rustc_interface;\n+extern crate rustc_metadata;\n extern crate syntax;\n \n-use std::str::FromStr;\n use std::convert::TryFrom;\n use std::env;\n+use std::str::FromStr;\n \n use hex::FromHexError;\n \n-use rustc_interface::{interface, Queries};\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc_driver::Compilation;\n+use rustc_interface::{interface, Queries};\n \n struct MiriCompilerCalls {\n     miri_config: miri::MiriConfig,\n }\n \n impl rustc_driver::Callbacks for MiriCompilerCalls {\n-    fn after_analysis<'tcx>(&mut self, compiler: &interface::Compiler, queries: &'tcx Queries<'tcx>) -> Compilation {\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        compiler: &interface::Compiler,\n+        queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n         init_late_loggers();\n         compiler.session().abort_if_errors();\n \n@@ -41,7 +45,9 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n             config.args.insert(0, compiler.input().filestem().to_string());\n \n             if let Some(return_code) = miri::eval_main(tcx, entry_def_id, config) {\n-                std::process::exit(i32::try_from(return_code).expect(\"Return value was too large!\"));\n+                std::process::exit(\n+                    i32::try_from(return_code).expect(\"Return value was too large!\"),\n+                );\n             }\n         });\n \n@@ -76,8 +82,10 @@ fn init_late_loggers() {\n             // This way, if you set `MIRI_LOG=trace`, you get only the right parts of\n             // rustc traced, but you can also do `MIRI_LOG=miri=trace,rustc_mir::interpret=debug`.\n             if log::Level::from_str(&var).is_ok() {\n-                env::set_var(\"RUSTC_LOG\",\n-                    &format!(\"rustc::mir::interpret={0},rustc_mir::interpret={0}\", var));\n+                env::set_var(\n+                    \"RUSTC_LOG\",\n+                    &format!(\"rustc::mir::interpret={0},rustc_mir::interpret={0}\", var),\n+                );\n             } else {\n                 env::set_var(\"RUSTC_LOG\", &var);\n             }\n@@ -110,11 +118,9 @@ fn compile_time_sysroot() -> Option<String> {\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n     Some(match (home, toolchain) {\n         (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n-        _ => {\n-            option_env!(\"RUST_SYSROOT\")\n-                .expect(\"To build Miri without rustup, set the `RUST_SYSROOT` env var at build time\")\n-                .to_owned()\n-        }\n+        _ => option_env!(\"RUST_SYSROOT\")\n+            .expect(\"To build Miri without rustup, set the `RUST_SYSROOT` env var at build time\")\n+            .to_owned(),\n     })\n }\n \n@@ -135,21 +141,20 @@ fn main() {\n         if rustc_args.is_empty() {\n             // Very first arg: for `rustc`.\n             rustc_args.push(arg);\n-        }\n-        else if after_dashdash {\n+        } else if after_dashdash {\n             // Everything that comes after are `miri` args.\n             miri_args.push(arg);\n         } else {\n             match arg.as_str() {\n                 \"-Zmiri-disable-validation\" => {\n                     validate = false;\n-                },\n+                }\n                 \"-Zmiri-disable-isolation\" => {\n                     communicate = true;\n-                },\n+                }\n                 \"-Zmiri-ignore-leaks\" => {\n                     ignore_leaks = true;\n-                },\n+                }\n                 \"--\" => {\n                     after_dashdash = true;\n                 }\n@@ -162,32 +167,40 @@ fn main() {\n                             FromHexError::InvalidHexCharacter { .. } => panic!(\n                                 \"-Zmiri-seed should only contain valid hex digits [0-9a-fA-F]\"\n                             ),\n-                            FromHexError::OddLength => panic!(\"-Zmiri-seed should have an even number of digits\"),\n+                            FromHexError::OddLength =>\n+                                panic!(\"-Zmiri-seed should have an even number of digits\"),\n                             err => panic!(\"Unknown error decoding -Zmiri-seed as hex: {:?}\", err),\n                         });\n                     if seed_raw.len() > 8 {\n-                        panic!(format!(\"-Zmiri-seed must be at most 8 bytes, was {}\", seed_raw.len()));\n+                        panic!(format!(\n+                            \"-Zmiri-seed must be at most 8 bytes, was {}\",\n+                            seed_raw.len()\n+                        ));\n                     }\n \n                     let mut bytes = [0; 8];\n                     bytes[..seed_raw.len()].copy_from_slice(&seed_raw);\n                     seed = Some(u64::from_be_bytes(bytes));\n-\n-                },\n+                }\n                 arg if arg.starts_with(\"-Zmiri-env-exclude=\") => {\n-                    excluded_env_vars.push(arg.trim_start_matches(\"-Zmiri-env-exclude=\").to_owned());\n-                },\n+                    excluded_env_vars\n+                        .push(arg.trim_start_matches(\"-Zmiri-env-exclude=\").to_owned());\n+                }\n                 arg if arg.starts_with(\"-Zmiri-track-pointer-tag=\") => {\n-                    let id: u64 = match arg.trim_start_matches(\"-Zmiri-track-pointer-tag=\").parse() {\n+                    let id: u64 = match arg.trim_start_matches(\"-Zmiri-track-pointer-tag=\").parse()\n+                    {\n                         Ok(id) => id,\n-                        Err(err) => panic!(\"-Zmiri-track-pointer-tag requires a valid `u64` as the argument: {}\", err),\n+                        Err(err) => panic!(\n+                            \"-Zmiri-track-pointer-tag requires a valid `u64` as the argument: {}\",\n+                            err\n+                        ),\n                     };\n                     if let Some(id) = miri::PtrId::new(id) {\n                         tracked_pointer_tag = Some(id);\n                     } else {\n                         panic!(\"-Zmiri-track-pointer-tag must be a nonzero id\");\n                     }\n-                },\n+                }\n                 _ => {\n                     rustc_args.push(arg);\n                 }\n@@ -225,6 +238,7 @@ fn main() {\n     rustc_driver::install_ice_hook();\n     let result = rustc_driver::catch_fatal_errors(move || {\n         rustc_driver::run_compiler(&rustc_args, &mut MiriCompilerCalls { miri_config }, None, None)\n-    }).and_then(|result| result);\n+    })\n+    .and_then(|result| result);\n     std::process::exit(result.is_err() as i32);\n }"}, {"sha": "4ed1b272b2288642864dda83efdc85ccbf127ab6", "filename": "src/eval.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -50,7 +50,11 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(config.communicate),\n-        MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate, config.tracked_pointer_tag),\n+        MemoryExtra::new(\n+            StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n+            config.validate,\n+            config.tracked_pointer_tag,\n+        ),\n     );\n     // Complete initialization.\n     EnvVars::init(&mut ecx, config.excluded_env_vars);\n@@ -75,9 +79,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     .unwrap();\n \n     // First argument: pointer to `main()`.\n-    let main_ptr = ecx\n-        .memory\n-        .create_fn_alloc(FnVal::Instance(main_instance));\n+    let main_ptr = ecx.memory.create_fn_alloc(FnVal::Instance(main_instance));\n     // Second argument (argc): length of `config.args`.\n     let argc = Scalar::from_uint(config.args.len() as u128, ecx.pointer_size());\n     // Third argument (`argv`): created from `config.args`.\n@@ -93,24 +95,20 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             argvs.push(arg_place.ptr);\n         }\n         // Make an array with all these pointers, in the Miri memory.\n-        let argvs_layout = ecx.layout_of(\n-            tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), argvs.len() as u64),\n-        )?;\n+        let argvs_layout =\n+            ecx.layout_of(tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), argvs.len() as u64))?;\n         let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n         for (idx, arg) in argvs.into_iter().enumerate() {\n             let place = ecx.mplace_field(argvs_place, idx as u64)?;\n             ecx.write_scalar(arg, place.into())?;\n         }\n-        ecx.memory\n-            .mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n+        ecx.memory.mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n         // A pointer to that place is the 3rd argument for main.\n         let argv = argvs_place.ptr;\n         // Store `argc` and `argv` for macOS `_NSGetArg{c,v}`.\n         {\n-            let argc_place = ecx.allocate(\n-                ecx.layout_of(tcx.types.isize)?,\n-                MiriMemoryKind::Env.into(),\n-            );\n+            let argc_place =\n+                ecx.allocate(ecx.layout_of(tcx.types.isize)?, MiriMemoryKind::Env.into());\n             ecx.write_scalar(argc, argc_place.into())?;\n             ecx.machine.argc = Some(argc_place.ptr);\n \n@@ -149,10 +147,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     };\n \n     // Return place (in static memory so that it does not count as leak).\n-    let ret_place = ecx.allocate(\n-        ecx.layout_of(tcx.types.isize)?,\n-        MiriMemoryKind::Env.into(),\n-    );\n+    let ret_place = ecx.allocate(ecx.layout_of(tcx.types.isize)?, MiriMemoryKind::Env.into());\n     // Call start function.\n     ecx.call_function(\n         start_instance,\n@@ -209,27 +204,30 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     return None;\n                 }\n             }\n-            return Some(return_code)\n+            return Some(return_code);\n         }\n         Err(mut e) => {\n             // Special treatment for some error kinds\n             let msg = match e.kind {\n                 InterpError::MachineStop(ref info) => {\n-                    let info = info.downcast_ref::<TerminationInfo>()\n+                    let info = info\n+                        .downcast_ref::<TerminationInfo>()\n                         .expect(\"invalid MachineStop payload\");\n                     match info {\n                         TerminationInfo::Exit(code) => return Some(*code),\n                         TerminationInfo::PoppedTrackedPointerTag(item) =>\n                             format!(\"popped tracked tag for item {:?}\", item),\n                         TerminationInfo::Abort =>\n-                            format!(\"the evaluated program aborted execution\")\n+                            format!(\"the evaluated program aborted execution\"),\n                     }\n                 }\n-                err_unsup!(NoMirFor(..)) =>\n-                    format!(\"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\", e),\n+                err_unsup!(NoMirFor(..)) => format!(\n+                    \"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\",\n+                    e\n+                ),\n                 InterpError::InvalidProgram(_) =>\n                     bug!(\"This error should be impossible in Miri: {}\", e),\n-                _ => e.to_string()\n+                _ => e.to_string(),\n             };\n             e.print_backtrace();\n             if let Some(frame) = ecx.stack().last() {\n@@ -242,9 +240,9 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                 // We iterate with indices because we need to look at the next frame (the caller).\n                 for idx in 0..frames.len() {\n                     let frame_info = &frames[idx];\n-                    let call_site_is_local = frames.get(idx + 1).map_or(false, |caller_info| {\n-                        caller_info.instance.def_id().is_local()\n-                    });\n+                    let call_site_is_local = frames\n+                        .get(idx + 1)\n+                        .map_or(false, |caller_info| caller_info.instance.def_id().is_local());\n                     if call_site_is_local {\n                         err.span_note(frame_info.call_site, &frame_info.to_string());\n                     } else {"}, {"sha": "b6391ce2fde018258f5a72a5d8d2ae7c4c3c8015", "filename": "src/helpers.rs", "status": "modified", "additions": 61, "deletions": 79, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,15 +1,14 @@\n-use std::{mem, iter};\n use std::ffi::OsStr;\n+use std::{iter, mem};\n \n-use syntax::source_map::DUMMY_SP;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use rustc::ty::{\n     self,\n-    List,\n-    TyCtxt,\n     layout::{self, LayoutOf, Size, TyLayout},\n+    List, TyCtxt,\n };\n+use syntax::source_map::DUMMY_SP;\n \n use rand::RngCore;\n \n@@ -19,23 +18,19 @@ impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tc\n \n /// Gets an instance for a path.\n fn resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> InterpResult<'tcx, DefId> {\n-    tcx\n-        .crates()\n+    tcx.crates()\n         .iter()\n         .find(|&&krate| tcx.original_crate_name(krate).as_str() == path[0])\n         .and_then(|krate| {\n-            let krate = DefId {\n-                krate: *krate,\n-                index: CRATE_DEF_INDEX,\n-            };\n+            let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n             let mut items = tcx.item_children(krate);\n             let mut path_it = path.iter().skip(1).peekable();\n \n             while let Some(segment) = path_it.next() {\n                 for item in mem::replace(&mut items, Default::default()).iter() {\n                     if item.ident.name.as_str() == *segment {\n                         if path_it.peek().is_none() {\n-                            return Some(item.res.def_id())\n+                            return Some(item.res.def_id());\n                         }\n \n                         items = tcx.item_children(item.res.def_id());\n@@ -51,12 +46,13 @@ fn resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> InterpResult<'tc\n         })\n }\n \n-\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-\n     /// Gets an instance for a path.\n     fn resolve_path(&self, path: &[&str]) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n-        Ok(ty::Instance::mono(self.eval_context_ref().tcx.tcx, resolve_did(self.eval_context_ref().tcx.tcx, path)?))\n+        Ok(ty::Instance::mono(\n+            self.eval_context_ref().tcx.tcx,\n+            resolve_did(self.eval_context_ref().tcx.tcx, path)?,\n+        ))\n     }\n \n     /// Write a 0 of the appropriate size to `dest`.\n@@ -74,11 +70,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Turn a Scalar into an Option<NonNullScalar>\n     fn test_null(&self, val: Scalar<Tag>) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n         let this = self.eval_context_ref();\n-        Ok(if this.is_null(val)? {\n-            None\n-        } else {\n-            Some(val)\n-        })\n+        Ok(if this.is_null(val)? { None } else { Some(val) })\n     }\n \n     /// Get the `Place` for a local\n@@ -89,11 +81,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Generate some random bytes, and write them to `dest`.\n-    fn gen_random(\n-        &mut self,\n-        ptr: Scalar<Tag>,\n-        len: usize,\n-    ) -> InterpResult<'tcx>  {\n+    fn gen_random(&mut self, ptr: Scalar<Tag>, len: usize) -> InterpResult<'tcx> {\n         // Some programs pass in a null pointer and a length of 0\n         // to their platform's random-generation function (e.g. getrandom())\n         // on Linux. For compatibility with these programs, we don't perform\n@@ -110,8 +98,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Fill the buffer using the host's rng.\n             getrandom::getrandom(&mut data)\n                 .map_err(|err| err_unsup_format!(\"getrandom failed: {}\", err))?;\n-        }\n-        else {\n+        } else {\n             let rng = this.memory.extra.rng.get_mut();\n             rng.fill_bytes(&mut data);\n         }\n@@ -132,23 +119,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Push frame.\n         let mir = &*this.load_mir(f.def, None)?;\n-        let span = this.stack().last()\n+        let span = this\n+            .stack()\n+            .last()\n             .and_then(Frame::current_source_info)\n             .map(|si| si.span)\n             .unwrap_or(DUMMY_SP);\n-        this.push_stack_frame(\n-            f,\n-            span,\n-            mir,\n-            dest,\n-            stack_pop,\n-        )?;\n+        this.push_stack_frame(f, span, mir, dest, stack_pop)?;\n \n         // Initialize arguments.\n         let mut callee_args = this.frame().body.args_iter();\n         for arg in args {\n             let callee_arg = this.local_place(\n-                callee_args.next().expect(\"callee has fewer arguments than expected\")\n+                callee_args.next().expect(\"callee has fewer arguments than expected\"),\n             )?;\n             this.write_immediate(*arg, callee_arg)?;\n         }\n@@ -167,10 +150,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         trace!(\"visit_frozen(place={:?}, size={:?})\", *place, size);\n-        debug_assert_eq!(size,\n+        debug_assert_eq!(\n+            size,\n             this.size_and_align_of_mplace(place)?\n-            .map(|(size, _)| size)\n-            .unwrap_or_else(|| place.layout.size)\n+                .map(|(size, _)| size)\n+                .unwrap_or_else(|| place.layout.size)\n         );\n         // Store how far we proceeded into the place so far. Everything to the left of\n         // this offset has already been handled, in the sense that the frozen parts\n@@ -190,11 +174,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let frozen_size = unsafe_cell_offset - end_offset;\n             // Everything between the end_ptr and this `UnsafeCell` is frozen.\n             if frozen_size != Size::ZERO {\n-                action(end_ptr, frozen_size, /*frozen*/true)?;\n+                action(end_ptr, frozen_size, /*frozen*/ true)?;\n             }\n             // This `UnsafeCell` is NOT frozen.\n             if unsafe_cell_size != Size::ZERO {\n-                action(unsafe_cell_ptr, unsafe_cell_size, /*frozen*/false)?;\n+                action(unsafe_cell_ptr, unsafe_cell_size, /*frozen*/ false)?;\n             }\n             // Update end end_ptr.\n             end_ptr = unsafe_cell_ptr.wrapping_offset(unsafe_cell_size, this);\n@@ -208,7 +192,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 unsafe_cell_action: |place| {\n                     trace!(\"unsafe_cell_action on {:?}\", place.ptr);\n                     // We need a size to go on.\n-                    let unsafe_cell_size = this.size_and_align_of_mplace(place)?\n+                    let unsafe_cell_size = this\n+                        .size_and_align_of_mplace(place)?\n                         .map(|(size, _)| size)\n                         // for extern types, just cover what we can\n                         .unwrap_or_else(|| place.layout.size);\n@@ -231,18 +216,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         /// Visiting the memory covered by a `MemPlace`, being aware of\n         /// whether we are inside an `UnsafeCell` or not.\n         struct UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n-            where F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n+        where\n+            F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n         {\n             ecx: &'ecx MiriEvalContext<'mir, 'tcx>,\n             unsafe_cell_action: F,\n         }\n \n-        impl<'ecx, 'mir, 'tcx, F>\n-            ValueVisitor<'mir, 'tcx, Evaluator<'tcx>>\n-        for\n-            UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n+        impl<'ecx, 'mir, 'tcx, F> ValueVisitor<'mir, 'tcx, Evaluator<'tcx>>\n+            for UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n         where\n-            F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n+            F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n         {\n             type V = MPlaceTy<'tcx, Tag>;\n \n@@ -252,11 +236,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Hook to detect `UnsafeCell`.\n-            fn visit_value(&mut self, v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n-            {\n+            fn visit_value(&mut self, v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n                 let is_unsafe_cell = match v.layout.ty.kind {\n-                    ty::Adt(adt, _) => Some(adt.did) == self.ecx.tcx.lang_items().unsafe_cell_type(),\n+                    ty::Adt(adt, _) =>\n+                        Some(adt.did) == self.ecx.tcx.lang_items().unsafe_cell_type(),\n                     _ => false,\n                 };\n                 if is_unsafe_cell {\n@@ -293,7 +277,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             fn visit_aggregate(\n                 &mut self,\n                 place: MPlaceTy<'tcx, Tag>,\n-                fields: impl Iterator<Item=InterpResult<'tcx, MPlaceTy<'tcx, Tag>>>,\n+                fields: impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>>,\n             ) -> InterpResult<'tcx> {\n                 match place.layout.fields {\n                     layout::FieldPlacement::Array { .. } => {\n@@ -303,7 +287,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     }\n                     layout::FieldPlacement::Arbitrary { .. } => {\n                         // Gather the subplaces and sort them before visiting.\n-                        let mut places = fields.collect::<InterpResult<'tcx, Vec<MPlaceTy<'tcx, Tag>>>>()?;\n+                        let mut places =\n+                            fields.collect::<InterpResult<'tcx, Vec<MPlaceTy<'tcx, Tag>>>>()?;\n                         places.sort_by_key(|place| place.ptr.assert_ptr().offset);\n                         self.walk_aggregate(place, places.into_iter().map(Ok))\n                     }\n@@ -315,22 +300,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // We have to do *something* for unions.\n-            fn visit_union(&mut self, v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n-            {\n+            fn visit_union(&mut self, v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 // With unions, we fall back to whatever the type says, to hopefully be consistent\n                 // with LLVM IR.\n                 // FIXME: are we consistent, and is this really the behavior we want?\n                 let frozen = self.ecx.type_is_freeze(v.layout.ty);\n-                if frozen {\n-                    Ok(())\n-                } else {\n-                    (self.unsafe_cell_action)(v)\n-                }\n+                if frozen { Ok(()) } else { (self.unsafe_cell_action)(v) }\n             }\n \n             // We should never get to a primitive, but always short-circuit somewhere above.\n-            fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n-            {\n+            fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 bug!(\"we should always short-circuit before coming to a primitive\")\n             }\n         }\n@@ -382,7 +361,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// case.\n     fn check_no_isolation(&mut self, name: &str) -> InterpResult<'tcx> {\n         if !self.eval_context_mut().machine.communicate {\n-            throw_unsup_format!(\"`{}` not available when isolation is enabled. Pass the flag `-Zmiri-disable-isolation` to disable it.\", name)\n+            throw_unsup_format!(\n+                \"`{}` not available when isolation is enabled. Pass the flag `-Zmiri-disable-isolation` to disable it.\",\n+                name\n+            )\n         }\n         Ok(())\n     }\n@@ -423,11 +405,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 TimedOut => \"ETIMEDOUT\",\n                 AlreadyExists => \"EEXIST\",\n                 WouldBlock => \"EWOULDBLOCK\",\n-                _ => throw_unsup_format!(\"The {} error cannot be transformed into a raw os error\", e)\n+                _ => {\n+                    throw_unsup_format!(\"The {} error cannot be transformed into a raw os error\", e)\n+                }\n             })?\n         } else {\n             // FIXME: we have to implement the Windows equivalent of this.\n-            throw_unsup_format!(\"Setting the last OS error from an io::Error is unsupported for {}.\", target.target_os)\n+            throw_unsup_format!(\n+                \"Setting the last OS error from an io::Error is unsupported for {}.\",\n+                target.target_os\n+            )\n         };\n         this.set_last_error(last_error)\n     }\n@@ -454,7 +441,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle.\n     fn read_os_str_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n-        where 'tcx: 'a, 'mir: 'a\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n     {\n         let this = self.eval_context_ref();\n         let bytes = this.memory.read_c_str(scalar)?;\n@@ -469,15 +458,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         os_str: &OsStr,\n         scalar: Scalar<Tag>,\n-        size: u64\n+        size: u64,\n     ) -> InterpResult<'tcx, bool> {\n         let bytes = os_str_to_bytes(os_str)?;\n         // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n         // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n         if size <= bytes.len() as u64 {\n             return Ok(false);\n         }\n-        self.eval_context_mut().memory.write_bytes(scalar, bytes.iter().copied().chain(iter::once(0u8)))?;\n+        self.eval_context_mut()\n+            .memory\n+            .write_bytes(scalar, bytes.iter().copied().chain(iter::once(0u8)))?;\n         Ok(true)\n     }\n }\n@@ -488,7 +479,7 @@ fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]>\n }\n \n #[cfg(target_os = \"unix\")]\n-fn bytes_to_os_str<'tcx, 'a>(bytes: &'a[u8]) -> InterpResult<'tcx, &'a OsStr> {\n+fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n     Ok(std::os::unix::ffi::OsStringExt::from_bytes(bytes))\n }\n \n@@ -522,11 +513,7 @@ pub fn immty_from_int_checked<'tcx>(\n     let size = layout.size;\n     let truncated = truncate(int as u128, size);\n     if sign_extend(truncated, size) as i128 != int {\n-        throw_unsup_format!(\n-            \"Signed value {:#x} does not fit in {} bits\",\n-            int,\n-            size.bits()\n-        )\n+        throw_unsup_format!(\"Signed value {:#x} does not fit in {} bits\", int, size.bits())\n     }\n     Ok(ImmTy::from_int(int, layout))\n }\n@@ -542,12 +529,7 @@ pub fn immty_from_uint_checked<'tcx>(\n     // `ImmTy::from_int` panic.\n     let size = layout.size;\n     if truncate(int, size) != int {\n-        throw_unsup_format!(\n-            \"Unsigned value {:#x} does not fit in {} bits\",\n-            int,\n-            size.bits()\n-        )\n+        throw_unsup_format!(\"Unsigned value {:#x} does not fit in {} bits\", int, size.bits())\n     }\n     Ok(ImmTy::from_uint(int, layout))\n }\n-"}, {"sha": "059d8217fabb4e235e07d85f01fd409380a5e044", "filename": "src/intptrcast.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,11 +1,11 @@\n use std::cell::RefCell;\n-use std::collections::{HashMap, hash_map::Entry};\n use std::cmp::max;\n+use std::collections::{hash_map::Entry, HashMap};\n \n use rand::Rng;\n \n use rustc::ty::layout::HasDataLayout;\n-use rustc_mir::interpret::{AllocId, Pointer, InterpResult, Memory, AllocCheck, PointerArithmetic};\n+use rustc_mir::interpret::{AllocCheck, AllocId, InterpResult, Memory, Pointer, PointerArithmetic};\n use rustc_target::abi::Size;\n \n use crate::{Evaluator, Tag, STACK_ADDR};\n@@ -47,14 +47,15 @@ impl<'mir, 'tcx> GlobalState {\n         }\n \n         let global_state = memory.extra.intptrcast.borrow();\n+        let pos = global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr);\n \n-        Ok(match global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr) {\n+        Ok(match pos {\n             Ok(pos) => {\n                 let (_, alloc_id) = global_state.int_to_ptr_map[pos];\n                 // `int` is equal to the starting address for an allocation, the offset should be\n                 // zero. The pointer is untagged because it was created from a cast\n                 Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged)\n-            },\n+            }\n             Err(0) => throw_unsup!(DanglingPointerDeref),\n             Err(pos) => {\n                 // This is the largest of the adresses smaller than `int`,\n@@ -100,7 +101,10 @@ impl<'mir, 'tcx> GlobalState {\n                 entry.insert(base_addr);\n                 trace!(\n                     \"Assigning base address {:#x} to allocation {:?} (slack: {}, align: {})\",\n-                    base_addr, ptr.alloc_id, slack, align.bytes(),\n+                    base_addr,\n+                    ptr.alloc_id,\n+                    slack,\n+                    align.bytes(),\n                 );\n \n                 // Remember next base address.  If this allocation is zero-sized, leave a gap\n@@ -114,7 +118,8 @@ impl<'mir, 'tcx> GlobalState {\n             }\n         };\n \n-        debug_assert_eq!(base_addr % align.bytes(), 0); // sanity check\n+        // Sanity check that the base address is aligned.\n+        debug_assert_eq!(base_addr % align.bytes(), 0);\n         // Add offset with the right kind of pointer-overflowing arithmetic.\n         let dl = memory.data_layout();\n         Ok(dl.overflowing_offset(base_addr, ptr.offset.bytes()).0)\n@@ -125,7 +130,7 @@ impl<'mir, 'tcx> GlobalState {\n     fn align_addr(addr: u64, align: u64) -> u64 {\n         match addr % align {\n             0 => addr,\n-            rem => addr.checked_add(align).unwrap() - rem\n+            rem => addr.checked_add(align).unwrap() - rem,\n         }\n     }\n }"}, {"sha": "32d2bda719ea020e868cabec564f28ed545ab1e1", "filename": "src/lib.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,57 +1,57 @@\n #![feature(rustc_private)]\n #![feature(option_expect_none, option_unwrap_none)]\n-\n #![warn(rust_2018_idioms)]\n #![allow(clippy::cast_lossless)]\n \n #[macro_use]\n extern crate log;\n // From rustc.\n-extern crate syntax;\n extern crate rustc_apfloat;\n-#[macro_use] extern crate rustc;\n+extern crate syntax;\n+#[macro_use]\n+extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate rustc_target;\n \n-mod shims;\n-mod operator;\n+mod eval;\n mod helpers;\n-mod range_map;\n-mod mono_hash_map;\n-mod stacked_borrows;\n mod intptrcast;\n mod machine;\n-mod eval;\n+mod mono_hash_map;\n+mod operator;\n+mod range_map;\n+mod shims;\n+mod stacked_borrows;\n \n // Make all those symbols available in the same place as our own.\n pub use rustc_mir::interpret::*;\n // Resolve ambiguity.\n pub use rustc_mir::interpret::{self, AllocMap, PlaceTy};\n \n-pub use crate::shims::{EvalContextExt as ShimsEvalContextExt};\n-pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextExt;\n-pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n-pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n-pub use crate::shims::time::{EvalContextExt as TimeEvalContextExt};\n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n-pub use crate::shims::fs::{FileHandler, EvalContextExt as FileEvalContextExt};\n+pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextExt;\n+pub use crate::shims::fs::{EvalContextExt as FileEvalContextExt, FileHandler};\n+pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as PanicEvalContextExt};\n+pub use crate::shims::time::EvalContextExt as TimeEvalContextExt;\n+pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n+pub use crate::shims::EvalContextExt as ShimsEvalContextExt;\n \n+pub use crate::eval::{create_ecx, eval_main, MiriConfig, TerminationInfo};\n+pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n+pub use crate::machine::{\n+    AllocExtra, Evaluator, FrameData, MemoryExtra, MiriEvalContext, MiriEvalContextExt,\n+    MiriMemoryKind, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+};\n+pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n-pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n-pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::stacked_borrows::{\n-    EvalContextExt as StackedBorEvalContextExt, Tag, Permission, Stack, Stacks, Item, PtrId,\n-    GlobalState,\n-};\n-pub use crate::machine::{\n-    PAGE_SIZE, STACK_ADDR, STACK_SIZE, NUM_CPUS,\n-    MemoryExtra, AllocExtra, FrameData, MiriMemoryKind, Evaluator, MiriEvalContext, MiriEvalContextExt,\n+    EvalContextExt as StackedBorEvalContextExt, GlobalState, Item, Permission, PtrId, Stack,\n+    Stacks, Tag,\n };\n-pub use crate::eval::{eval_main, create_ecx, MiriConfig, TerminationInfo};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "37253a260de7f848b9b13ca9d2a12bbe5d01f7de", "filename": "src/machine.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -8,8 +8,12 @@ use std::rc::Rc;\n use rand::rngs::StdRng;\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, layout::{Size, LayoutOf}, Ty, TyCtxt};\n use rustc::mir;\n+use rustc::ty::{\n+    self,\n+    layout::{LayoutOf, Size},\n+    Ty, TyCtxt,\n+};\n use syntax::{attr, source_map::Span, symbol::sym};\n \n use crate::*;\n@@ -33,7 +37,6 @@ pub struct FrameData<'tcx> {\n     pub catch_panic: Option<CatchUnwindData<'tcx>>,\n }\n \n-\n /// Extra memory kinds\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MiriMemoryKind {\n@@ -114,7 +117,7 @@ pub struct Evaluator<'tcx> {\n \n     /// The temporary used for storing the argument of\n     /// the call to `miri_start_panic` (the panic payload) when unwinding.\n-    pub(crate) panic_payload: Option<ImmTy<'tcx, Tag>>\n+    pub(crate) panic_payload: Option<ImmTy<'tcx, Tag>>,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n@@ -130,7 +133,7 @@ impl<'tcx> Evaluator<'tcx> {\n             tls: TlsData::default(),\n             communicate,\n             file_handler: Default::default(),\n-            panic_payload: None\n+            panic_payload: None,\n         }\n     }\n }\n@@ -164,13 +167,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type PointerTag = Tag;\n     type ExtraFnVal = Dlsym;\n \n-    type MemoryMap = MonoHashMap<\n-        AllocId,\n-        (\n-            MemoryKind<MiriMemoryKind>,\n-            Allocation<Tag, Self::AllocExtra>,\n-        ),\n-    >;\n+    type MemoryMap =\n+        MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n \n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n \n@@ -322,9 +320,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                     stacked_borrows.static_base_ptr(alloc)\n                 }\n             },\n-            AllocExtra {\n-                stacked_borrows: stacks,\n-            },\n+            AllocExtra { stacked_borrows: stacks },\n         );\n         (Cow::Owned(alloc), base_tag)\n     }\n@@ -334,10 +330,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         if !memory_extra.validate {\n             Tag::Untagged\n         } else {\n-            memory_extra\n-                .stacked_borrows\n-                .borrow_mut()\n-                .static_base_ptr(id)\n+            memory_extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n         }\n     }\n \n@@ -356,9 +349,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn stack_push(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, FrameData<'tcx>> {\n+    fn stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, FrameData<'tcx>> {\n         Ok(FrameData {\n             call_id: ecx.memory.extra.stacked_borrows.borrow_mut().new_call(),\n             catch_panic: None,\n@@ -369,7 +360,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     fn stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: FrameData<'tcx>,\n-        unwinding: bool\n+        unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopInfo> {\n         ecx.handle_stack_pop(extra, unwinding)\n     }"}, {"sha": "124ae68760260b93ca6aa76f0b0d030c9cb4935d", "filename": "src/mono_hash_map.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_hash_map.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -5,10 +5,10 @@\n //! The API is is completely tailored to what `memory.rs` needs. It is still in\n //! a separate file to minimize the amount of code that has to care about the unsafety.\n \n-use std::collections::hash_map::Entry;\n+use std::borrow::Borrow;\n use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n use std::hash::Hash;\n-use std::borrow::Borrow;\n \n use rustc_data_structures::fx::FxHashMap;\n \n@@ -26,7 +26,7 @@ impl<K: Hash + Eq, V> MonoHashMap<K, V> {\n     /// as long as the `Ref` returned by `RefCell::borrow()` is alive. So we can't return the\n     /// iterator, as that would drop the `Ref`. We can't return both, as it's not possible in Rust\n     /// to have a struct/tuple with a field that refers to another field.\n-    pub fn iter<T>(&self, f: impl FnOnce(&mut dyn Iterator<Item=(&K, &V)>) -> T) -> T {\n+    pub fn iter<T>(&self, f: impl FnOnce(&mut dyn Iterator<Item = (&K, &V)>) -> T) -> T {\n         f(&mut self.0.borrow().iter().map(|(k, v)| (k, &**v)))\n     }\n }\n@@ -40,30 +40,28 @@ impl<K: Hash + Eq, V> Default for MonoHashMap<K, V> {\n impl<K: Hash + Eq, V> AllocMap<K, V> for MonoHashMap<K, V> {\n     #[inline(always)]\n     fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n-        where K: Borrow<Q>\n+    where\n+        K: Borrow<Q>,\n     {\n         self.0.get_mut().contains_key(k)\n     }\n \n     #[inline(always)]\n-    fn insert(&mut self, k: K, v: V) -> Option<V>\n-    {\n+    fn insert(&mut self, k: K, v: V) -> Option<V> {\n         self.0.get_mut().insert(k, Box::new(v)).map(|x| *x)\n     }\n \n     #[inline(always)]\n     fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>\n+    where\n+        K: Borrow<Q>,\n     {\n         self.0.get_mut().remove(k).map(|x| *x)\n     }\n \n     #[inline(always)]\n     fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n-        self.0.borrow()\n-            .iter()\n-            .filter_map(move |(k, v)| f(k, &*v))\n-            .collect()\n+        self.0.borrow().iter().filter_map(move |(k, v)| f(k, &*v)).collect()\n     }\n \n     /// The most interesting method: Providing a shared ref without\n@@ -73,11 +71,7 @@ impl<K: Hash + Eq, V> AllocMap<K, V> for MonoHashMap<K, V> {\n     /// if it returns a reference, that is used directly, if it\n     /// returns owned data, that is put into the map and returned.\n     #[inline(always)]\n-    fn get_or<E>(\n-        &self,\n-        k: K,\n-        vacant: impl FnOnce() -> Result<V, E>\n-    ) -> Result<&V, E> {\n+    fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n         let val: *const V = match self.0.borrow_mut().entry(k) {\n             Entry::Occupied(entry) => &**entry.get(),\n             Entry::Vacant(entry) => &**entry.insert(Box::new(vacant()?)),\n@@ -88,12 +82,7 @@ impl<K: Hash + Eq, V> AllocMap<K, V> for MonoHashMap<K, V> {\n     }\n \n     #[inline(always)]\n-    fn get_mut_or<E>(\n-        &mut self,\n-        k: K,\n-        vacant: impl FnOnce() -> Result<V, E>\n-    ) -> Result<&mut V, E>\n-    {\n+    fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n         match self.0.get_mut().entry(k) {\n             Entry::Occupied(e) => Ok(e.into_mut()),\n             Entry::Vacant(e) => {"}, {"sha": "7c932a907e725ed40c465cbc8b75681c9dd16a65", "filename": "src/operator.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,7 +1,10 @@\n use std::convert::TryFrom;\n \n-use rustc::ty::{Ty, layout::{Size, LayoutOf}};\n use rustc::mir;\n+use rustc::ty::{\n+    layout::{LayoutOf, Size},\n+    Ty,\n+};\n \n use crate::*;\n \n@@ -13,11 +16,7 @@ pub trait EvalContextExt<'tcx> {\n         right: ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool, Ty<'tcx>)>;\n \n-    fn ptr_eq(\n-        &self,\n-        left: Scalar<Tag>,\n-        right: Scalar<Tag>,\n-    ) -> InterpResult<'tcx, bool>;\n+    fn ptr_eq(&self, left: Scalar<Tag>, right: Scalar<Tag>) -> InterpResult<'tcx, bool>;\n \n     fn pointer_offset_inbounds(\n         &self,\n@@ -41,12 +40,15 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         Ok(match bin_op {\n             Eq | Ne => {\n                 // This supports fat pointers.\n+                #[rustfmt::skip]\n                 let eq = match (*left, *right) {\n-                    (Immediate::Scalar(left), Immediate::Scalar(right)) =>\n-                        self.ptr_eq(left.not_undef()?, right.not_undef()?)?,\n-                    (Immediate::ScalarPair(left1, left2), Immediate::ScalarPair(right1, right2)) =>\n-                        self.ptr_eq(left1.not_undef()?, right1.not_undef()?)? &&\n-                        self.ptr_eq(left2.not_undef()?, right2.not_undef()?)?,\n+                    (Immediate::Scalar(left), Immediate::Scalar(right)) => {\n+                        self.ptr_eq(left.not_undef()?, right.not_undef()?)?\n+                    }\n+                    (Immediate::ScalarPair(left1, left2), Immediate::ScalarPair(right1, right2)) => {\n+                        self.ptr_eq(left1.not_undef()?, right1.not_undef()?)?\n+                            && self.ptr_eq(left2.not_undef()?, right2.not_undef()?)?\n+                    }\n                     _ => bug!(\"Type system should not allow comparing Scalar with ScalarPair\"),\n                 };\n                 (Scalar::from_bool(if bin_op == Eq { eq } else { !eq }), false, self.tcx.types.bool)\n@@ -68,10 +70,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n             }\n \n             Offset => {\n-                let pointee_ty = left.layout.ty\n-                    .builtin_deref(true)\n-                    .expect(\"Offset called on non-ptr type\")\n-                    .ty;\n+                let pointee_ty =\n+                    left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n                 let ptr = self.pointer_offset_inbounds(\n                     left.to_scalar()?,\n                     pointee_ty,\n@@ -80,15 +80,11 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 (ptr, false, left.layout.ty)\n             }\n \n-            _ => bug!(\"Invalid operator on pointers: {:?}\", bin_op)\n+            _ => bug!(\"Invalid operator on pointers: {:?}\", bin_op),\n         })\n     }\n \n-    fn ptr_eq(\n-        &self,\n-        left: Scalar<Tag>,\n-        right: Scalar<Tag>,\n-    ) -> InterpResult<'tcx, bool> {\n+    fn ptr_eq(&self, left: Scalar<Tag>, right: Scalar<Tag>) -> InterpResult<'tcx, bool> {\n         let size = self.pointer_size();\n         // Just compare the integers.\n         // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?"}, {"sha": "01abaef27fd2d6294f03e4e9e5fbec15fc13521b", "filename": "src/range_map.rs", "status": "modified", "additions": 95, "deletions": 111, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -29,10 +29,7 @@ impl<T> RangeMap<T> {\n         let size = size.bytes();\n         let mut map = RangeMap { v: Vec::new() };\n         if size > 0 {\n-            map.v.push(Elem {\n-                range: 0..size,\n-                data: init\n-            });\n+            map.v.push(Elem { range: 0..size, data: init });\n         }\n         map\n     }\n@@ -53,7 +50,7 @@ impl<T> RangeMap<T> {\n             } else if offset >= elem.range.end {\n                 // We are too far left (offset is further right).\n                 debug_assert!(candidate >= left); // we are making progress\n-                left = candidate+1;\n+                left = candidate + 1;\n             } else {\n                 // This is it!\n                 return candidate;\n@@ -69,18 +66,16 @@ impl<T> RangeMap<T> {\n         let len = len.bytes();\n         // Compute a slice starting with the elements we care about.\n         let slice: &[Elem<T>] = if len == 0 {\n-                // We just need any empty iterator. We don't even want to\n-                // yield the element that surrounds this position.\n-                &[]\n-            } else {\n-                let first_idx = self.find_offset(offset);\n-                &self.v[first_idx..]\n-            };\n+            // We just need any empty iterator. We don't even want to\n+            // yield the element that surrounds this position.\n+            &[]\n+        } else {\n+            let first_idx = self.find_offset(offset);\n+            &self.v[first_idx..]\n+        };\n         // The first offset that is not included any more.\n         let end = offset + len;\n-        slice.iter()\n-            .take_while(move |elem| elem.range.start < end)\n-            .map(|elem| &elem.data)\n+        slice.iter().take_while(move |elem| elem.range.start < end).map(|elem| &elem.data)\n     }\n \n     pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n@@ -99,18 +94,17 @@ impl<T> RangeMap<T> {\n             // Nothing to do.\n             return false;\n         }\n-        debug_assert!(elem.range.contains(&split_offset),\n-            \"the `split_offset` is not in the element to be split\");\n+        debug_assert!(\n+            elem.range.contains(&split_offset),\n+            \"the `split_offset` is not in the element to be split\"\n+        );\n \n         // Now we really have to split. Reduce length of first element.\n         let second_range = split_offset..elem.range.end;\n         elem.range.end = split_offset;\n         // Copy the data, and insert second element.\n-        let second = Elem {\n-            range: second_range,\n-            data: elem.data.clone(),\n-        };\n-        self.v.insert(index+1, second);\n+        let second = Elem { range: second_range, data: elem.data.clone() };\n+        self.v.insert(index + 1, second);\n         return true;\n     }\n \n@@ -130,73 +124,79 @@ impl<T> RangeMap<T> {\n         let len = len.bytes();\n         // Compute a slice containing exactly the elements we care about\n         let slice: &mut [Elem<T>] = if len == 0 {\n-                // We just need any empty iterator. We don't even want to\n-                // yield the element that surrounds this position, nor do\n-                // any splitting.\n-                &mut []\n-            } else {\n-                // Make sure we got a clear beginning\n-                let mut first_idx = self.find_offset(offset);\n-                if self.split_index(first_idx, offset) {\n-                    // The newly created 2nd element is ours\n-                    first_idx += 1;\n-                }\n-                let first_idx = first_idx; // no more mutation\n-                // Find our end. Linear scan, but that's ok because the iteration\n-                // is doing the same linear scan anyway -- no increase in complexity.\n-                // We combine this scan with a scan for duplicates that we can merge, to reduce\n-                // the number of elements.\n-                // We stop searching after the first \"block\" of size 1, to avoid spending excessive\n-                // amounts of time on the merging.\n-                let mut equal_since_idx = first_idx;\n-                // Once we see too many non-mergeable blocks, we stop.\n-                // The initial value is chosen via... magic. Benchmarking and magic.\n-                let mut successful_merge_count = 3usize;\n-                let mut end_idx = first_idx; // when the loop is done, this is the first excluded element.\n-                loop {\n-                    // Compute if `end` is the last element we need to look at.\n-                    let done = self.v[end_idx].range.end >= offset+len;\n-                    // We definitely need to include `end`, so move the index.\n-                    end_idx += 1;\n-                    debug_assert!(done || end_idx < self.v.len(), \"iter_mut: end-offset {} is out-of-bounds\", offset+len);\n-                    // see if we want to merge everything in `equal_since..end` (exclusive at the end!)\n-                    if successful_merge_count > 0 {\n-                        if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n-                            // Everything in `equal_since..end` was equal. Make them just one element covering\n-                            // the entire range.\n-                            let removed_elems = end_idx - equal_since_idx - 1; // number of elements that we would remove\n-                            if removed_elems > 0 {\n-                                // Adjust the range of the first element to cover all of them.\n-                                let equal_until = self.v[end_idx - 1].range.end; // end of range of last of the equal elements\n-                                self.v[equal_since_idx].range.end = equal_until;\n-                                // Delete the rest of them.\n-                                self.v.splice(equal_since_idx+1..end_idx, std::iter::empty());\n-                                // Adjust `end_idx` because we made the list shorter.\n-                                end_idx -= removed_elems;\n-                                // Adjust the count for the cutoff.\n-                                successful_merge_count += removed_elems;\n-                            } else {\n-                                // Adjust the count for the cutoff.\n-                                successful_merge_count -= 1;\n-                            }\n-                            // Go on scanning for the next block starting here.\n-                            equal_since_idx = end_idx;\n+            // We just need any empty iterator. We don't even want to\n+            // yield the element that surrounds this position, nor do\n+            // any splitting.\n+            &mut []\n+        } else {\n+            // Make sure we got a clear beginning\n+            let mut first_idx = self.find_offset(offset);\n+            if self.split_index(first_idx, offset) {\n+                // The newly created 2nd element is ours\n+                first_idx += 1;\n+            }\n+            // No more mutation.\n+            let first_idx = first_idx;\n+            // Find our end. Linear scan, but that's ok because the iteration\n+            // is doing the same linear scan anyway -- no increase in complexity.\n+            // We combine this scan with a scan for duplicates that we can merge, to reduce\n+            // the number of elements.\n+            // We stop searching after the first \"block\" of size 1, to avoid spending excessive\n+            // amounts of time on the merging.\n+            let mut equal_since_idx = first_idx;\n+            // Once we see too many non-mergeable blocks, we stop.\n+            // The initial value is chosen via... magic. Benchmarking and magic.\n+            let mut successful_merge_count = 3usize;\n+            // When the loop is done, this is the first excluded element.\n+            let mut end_idx = first_idx;\n+            loop {\n+                // Compute if `end` is the last element we need to look at.\n+                let done = self.v[end_idx].range.end >= offset + len;\n+                // We definitely need to include `end`, so move the index.\n+                end_idx += 1;\n+                debug_assert!(\n+                    done || end_idx < self.v.len(),\n+                    \"iter_mut: end-offset {} is out-of-bounds\",\n+                    offset + len\n+                );\n+                // see if we want to merge everything in `equal_since..end` (exclusive at the end!)\n+                if successful_merge_count > 0 {\n+                    if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n+                        // Everything in `equal_since..end` was equal. Make them just one element covering\n+                        // the entire range.\n+                        let removed_elems = end_idx - equal_since_idx - 1; // number of elements that we would remove\n+                        if removed_elems > 0 {\n+                            // Adjust the range of the first element to cover all of them.\n+                            let equal_until = self.v[end_idx - 1].range.end; // end of range of last of the equal elements\n+                            self.v[equal_since_idx].range.end = equal_until;\n+                            // Delete the rest of them.\n+                            self.v.splice(equal_since_idx + 1..end_idx, std::iter::empty());\n+                            // Adjust `end_idx` because we made the list shorter.\n+                            end_idx -= removed_elems;\n+                            // Adjust the count for the cutoff.\n+                            successful_merge_count += removed_elems;\n+                        } else {\n+                            // Adjust the count for the cutoff.\n+                            successful_merge_count -= 1;\n                         }\n-                    }\n-                    // Leave loop if this is the last element.\n-                    if done {\n-                        break;\n+                        // Go on scanning for the next block starting here.\n+                        equal_since_idx = end_idx;\n                     }\n                 }\n-                // Move to last included instead of first excluded index.\n-                let end_idx = end_idx-1;\n-                // We need to split the end as well. Even if this performs a\n-                // split, we don't have to adjust our index as we only care about\n-                // the first part of the split.\n-                self.split_index(end_idx, offset+len);\n-                // Now we yield the slice. `end` is inclusive.\n-                &mut self.v[first_idx..=end_idx]\n-            };\n+                // Leave loop if this is the last element.\n+                if done {\n+                    break;\n+                }\n+            }\n+            // Move to last included instead of first excluded index.\n+            let end_idx = end_idx - 1;\n+            // We need to split the end as well. Even if this performs a\n+            // split, we don't have to adjust our index as we only care about\n+            // the first part of the split.\n+            self.split_index(end_idx, offset + len);\n+            // Now we yield the slice. `end` is inclusive.\n+            &mut self.v[first_idx..=end_idx]\n+        };\n         slice.iter_mut().map(|elem| &mut elem.data)\n     }\n }\n@@ -209,12 +209,7 @@ mod tests {\n     fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n         (offset..offset + len)\n             .into_iter()\n-            .map(|i| map\n-                .iter(Size::from_bytes(i), Size::from_bytes(1))\n-                .next()\n-                .map(|&t| t)\n-                .unwrap()\n-            )\n+            .map(|i| map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|&t| t).unwrap())\n             .collect()\n     }\n \n@@ -250,42 +245,31 @@ mod tests {\n             *x = 43;\n         }\n         assert_eq!(map.v.len(), 5);\n-        assert_eq!(\n-            to_vec(&map, 10, 10),\n-            vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]\n-        );\n+        assert_eq!(to_vec(&map, 10, 10), vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]);\n \n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n             if *x < 42 {\n                 *x = 23;\n             }\n         }\n         assert_eq!(map.v.len(), 6);\n-        assert_eq!(\n-            to_vec(&map, 10, 10),\n-            vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]\n-        );\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]);\n         assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n \n-\n         for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n             *x = 19;\n         }\n         assert_eq!(map.v.len(), 6);\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]);\n+        // Should be seeing two blocks with 19.\n         assert_eq!(\n-            to_vec(&map, 10, 10),\n-            vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]\n+            map.iter(Size::from_bytes(15), Size::from_bytes(2)).map(|&t| t).collect::<Vec<_>>(),\n+            vec![19, 19]\n         );\n-        // Should be seeing two blocks with 19.\n-        assert_eq!(map.iter(Size::from_bytes(15), Size::from_bytes(2))\n-            .map(|&t| t).collect::<Vec<_>>(), vec![19, 19]);\n \n         // A NOP `iter_mut` should trigger merging.\n-        for _ in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) { }\n+        for _ in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {}\n         assert_eq!(map.v.len(), 5);\n-        assert_eq!(\n-            to_vec(&map, 10, 10),\n-            vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]\n-        );\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]);\n     }\n }"}, {"sha": "0069f8cc80870c649db70e1f1fc80c6fc8e92123", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -15,8 +15,7 @@ impl Dlsym {\n         Ok(match name {\n             \"getentropy\" => Some(GetEntropy),\n             \"__pthread_get_minstack\" => None,\n-            _ =>\n-                throw_unsup_format!(\"Unsupported dlsym: {}\", name),\n+            _ => throw_unsup_format!(\"Unsupported dlsym: {}\", name),\n         })\n     }\n }"}, {"sha": "1a52d8721470f20e2ddeb1ae5e3491c120e8db0a", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 94, "deletions": 66, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,10 +1,10 @@\n-use std::{iter, convert::TryInto};\n+use std::{convert::TryInto, iter};\n \n+use rustc::hir::def_id::DefId;\n use rustc::mir;\n+use rustc::ty;\n use rustc::ty::layout::{Align, LayoutOf, Size};\n-use rustc::hir::def_id::DefId;\n use rustc_apfloat::Float;\n-use rustc::ty;\n use syntax::attr;\n use syntax::symbol::sym;\n \n@@ -47,14 +47,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Scalar::from_int(0, this.pointer_size())\n         } else {\n             let align = this.min_align(size, kind);\n-            let ptr = this\n-                .memory\n-                .allocate(Size::from_bytes(size), align, kind.into());\n+            let ptr = this.memory.allocate(Size::from_bytes(size), align, kind.into());\n             if zero_init {\n                 // We just allocated this, the access is definitely in-bounds.\n-                this.memory\n-                    .write_bytes(ptr.into(), iter::repeat(0u8).take(size as usize))\n-                    .unwrap();\n+                this.memory.write_bytes(ptr.into(), iter::repeat(0u8).take(size as usize)).unwrap();\n             }\n             Scalar::Ptr(ptr)\n         }\n@@ -82,8 +78,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr =\n-                    this.memory\n-                        .allocate(Size::from_bytes(new_size), new_align, kind.into());\n+                    this.memory.allocate(Size::from_bytes(new_size), new_align, kind.into());\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n         } else {\n@@ -110,12 +105,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// by this function.\n     /// Returns Ok(Some(body)) if processing the foreign item\n     /// is delegated to another function.\n+    #[rustfmt::skip]\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>\n+        _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n@@ -136,11 +132,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // also be a custom user-provided implementation via `#![feature(panic_runtime)]`\n             \"__rust_start_panic\" => {\n                 // FIXME we might want to cache this... but it's not really performance-critical.\n-                let panic_runtime = tcx.crates().iter()\n+                let panic_runtime = tcx\n+                    .crates()\n+                    .iter()\n                     .find(|cnum| tcx.is_panic_runtime(**cnum))\n                     .expect(\"No panic runtime found!\");\n                 let panic_runtime = tcx.crate_name(*panic_runtime);\n-                let start_panic_instance = this.resolve_path(&[&*panic_runtime.as_str(), \"__rust_start_panic\"])?;\n+                let start_panic_instance =\n+                    this.resolve_path(&[&*panic_runtime.as_str(), \"__rust_start_panic\"])?;\n                 return Ok(Some(&*this.load_mir(start_panic_instance.def, None)?));\n             }\n             // Similarly, we forward calls to the `panic_impl` foreign item to its implementation.\n@@ -151,7 +150,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 return Ok(Some(&*this.load_mir(panic_impl_instance.def, None)?));\n             }\n \n-            \"exit\" | \"ExitProcess\" => {\n+            | \"exit\"\n+            | \"ExitProcess\"\n+            => {\n                 // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n                 let code = this.read_scalar(args[0])?.to_i32()?;\n                 throw_machine_stop!(TerminationInfo::Exit(code.into()));\n@@ -175,9 +176,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_machine_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-                let size = items\n-                    .checked_mul(len)\n-                    .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n+                let size =\n+                    items.checked_mul(len).ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n                 let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n@@ -250,9 +250,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     MiriMemoryKind::Rust.into(),\n                 );\n                 // We just allocated this, the access is definitely in-bounds.\n-                this.memory\n-                    .write_bytes(ptr.into(), iter::repeat(0u8).take(size as usize))\n-                    .unwrap();\n+                this.memory.write_bytes(ptr.into(), iter::repeat(0u8).take(size as usize)).unwrap();\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_dealloc\" => {\n@@ -268,10 +266,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ptr = this.force_ptr(ptr)?;\n                 this.memory.deallocate(\n                     ptr,\n-                    Some((\n-                        Size::from_bytes(old_size),\n-                        Align::from_bytes(align).unwrap(),\n-                    )),\n+                    Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n             }\n@@ -346,7 +341,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             \"__rust_maybe_catch_panic\" => {\n                 this.handle_catch_panic(args, dest, ret)?;\n-                return Ok(None)\n+                return Ok(None);\n             }\n \n             \"memcmp\" => {\n@@ -404,7 +399,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n-            \"__errno_location\" | \"__error\" => {\n+            | \"__errno_location\"\n+            | \"__error\"\n+            => {\n                 let errno_place = this.machine.last_error.unwrap();\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n@@ -434,7 +431,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n-            \"open\" | \"open64\" => {\n+            | \"open\"\n+            | \"open64\"\n+            => {\n                 let result = this.open(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n@@ -444,7 +443,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n-            \"close\" | \"close$NOCANCEL\" => {\n+            | \"close\"\n+            | \"close$NOCANCEL\"\n+            => {\n                 let result = this.close(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n@@ -510,7 +511,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // math functions\n-            \"cbrtf\" | \"coshf\" | \"sinhf\" | \"tanf\" | \"acosf\" | \"asinf\" | \"atanf\" => {\n+            | \"cbrtf\"\n+            | \"coshf\"\n+            | \"sinhf\"\n+            | \"tanf\"\n+            | \"acosf\"\n+            | \"asinf\"\n+            | \"atanf\"\n+            => {\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n                 let f = match link_name {\n@@ -526,7 +534,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_u32(f.to_bits()), dest)?;\n             }\n             // underscore case for windows\n-            \"_hypotf\" | \"hypotf\" | \"atan2f\" => {\n+            | \"_hypotf\"\n+            | \"hypotf\"\n+            | \"atan2f\"\n+            => {\n                 // FIXME: Using host floats.\n                 let f1 = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(args[1])?.to_u32()?);\n@@ -538,7 +549,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_u32(n.to_bits()), dest)?;\n             }\n \n-            \"cbrt\" | \"cosh\" | \"sinh\" | \"tan\" | \"acos\" | \"asin\" | \"atan\" => {\n+            | \"cbrt\"\n+            | \"cosh\"\n+            | \"sinh\"\n+            | \"tan\"\n+            | \"acos\"\n+            | \"asin\"\n+            | \"atan\"\n+            => {\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n                 let f = match link_name {\n@@ -555,7 +573,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             // underscore case for windows, here and below\n             // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n-            \"_hypot\" | \"hypot\" | \"atan2\" => {\n+            | \"_hypot\"\n+            | \"hypot\"\n+            | \"atan2\"\n+            => {\n                 // FIXME: Using host floats.\n                 let f1 = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(args[1])?.to_u64()?);\n@@ -567,7 +588,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_u64(n.to_bits()), dest)?;\n             }\n             // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n-            \"_ldexp\" | \"ldexp\" | \"scalbn\" => {\n+            | \"_ldexp\"\n+            | \"ldexp\"\n+            | \"scalbn\"\n+            => {\n                 let x = this.read_scalar(args[0])?.to_f64()?;\n                 let exp = this.read_scalar(args[1])?.to_i32()?;\n \n@@ -586,7 +610,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Some things needed for `sys::thread` initialization to go through.\n-            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n+            | \"signal\"\n+            | \"sigaction\"\n+            | \"sigaltstack\"\n+            => {\n                 this.write_scalar(Scalar::from_int(0, dest.layout.size), dest)?;\n             }\n \n@@ -596,14 +623,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 trace!(\"sysconf() called with name {}\", name);\n                 // TODO: Cache the sysconf integers via Miri's global cache.\n                 let paths = &[\n-                    (\n-                        &[\"libc\", \"_SC_PAGESIZE\"],\n-                        Scalar::from_int(PAGE_SIZE, dest.layout.size),\n-                    ),\n-                    (\n-                        &[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"],\n-                        Scalar::from_int(-1, dest.layout.size),\n-                    ),\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_int(PAGE_SIZE, dest.layout.size)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_int(-1, dest.layout.size)),\n                     (\n                         &[\"libc\", \"_SC_NPROCESSORS_ONLN\"],\n                         Scalar::from_int(NUM_CPUS, dest.layout.size),\n@@ -688,7 +709,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Stack size/address stuff.\n-            \"pthread_attr_init\"\n+            | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             | \"pthread_self\"\n             | \"pthread_attr_setstacksize\" => {\n@@ -712,12 +733,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // We don't support threading. (Also for Windows.)\n-            \"pthread_create\" | \"CreateThread\" => {\n+            | \"pthread_create\"\n+            | \"CreateThread\"\n+            => {\n                 throw_unsup_format!(\"Miri does not support threading\");\n             }\n \n             // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n-            \"pthread_mutexattr_init\"\n+            | \"pthread_mutexattr_init\"\n             | \"pthread_mutexattr_settype\"\n             | \"pthread_mutex_init\"\n             | \"pthread_mutexattr_destroy\"\n@@ -732,7 +755,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"pthread_condattr_setclock\"\n             | \"pthread_cond_init\"\n             | \"pthread_condattr_destroy\"\n-            | \"pthread_cond_destroy\" => {\n+            | \"pthread_cond_destroy\"\n+            => {\n                 this.write_null(dest)?;\n             }\n \n@@ -751,7 +775,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // macOS API stubs.\n-            \"pthread_attr_get_np\" | \"pthread_getattr_np\" => {\n+            | \"pthread_attr_get_np\"\n+            | \"pthread_getattr_np\"\n+            => {\n                 this.write_null(dest)?;\n             }\n             \"pthread_get_stackaddr_np\" => {\n@@ -822,32 +848,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n             }\n-            \"InitializeCriticalSection\"\n+\n+            | \"InitializeCriticalSection\"\n             | \"EnterCriticalSection\"\n             | \"LeaveCriticalSection\"\n-            | \"DeleteCriticalSection\" => {\n+            | \"DeleteCriticalSection\"\n+            => {\n                 // Nothing to do, not even a return value.\n             }\n-            \"GetModuleHandleW\"\n+\n+            | \"GetModuleHandleW\"\n             | \"GetProcAddress\"\n             | \"TryEnterCriticalSection\"\n             | \"GetConsoleScreenBufferInfo\"\n-            | \"SetConsoleTextAttribute\" => {\n+            | \"SetConsoleTextAttribute\"\n+            => {\n                 // Pretend these do not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n+\n             \"GetSystemInfo\" => {\n                 let system_info = this.deref_operand(args[0])?;\n                 // Initialize with `0`.\n-                this.memory\n-                    .write_bytes(system_info.ptr, iter::repeat(0u8).take(system_info.layout.size.bytes() as usize))?;\n+                this.memory.write_bytes(\n+                    system_info.ptr,\n+                    iter::repeat(0u8).take(system_info.layout.size.bytes() as usize),\n+                )?;\n                 // Set number of processors.\n                 let dword_size = Size::from_bytes(4);\n                 let num_cpus = this.mplace_field(system_info, 6)?;\n-                this.write_scalar(\n-                    Scalar::from_int(NUM_CPUS, dword_size),\n-                    num_cpus.into(),\n-                )?;\n+                this.write_scalar(Scalar::from_int(NUM_CPUS, dword_size), num_cpus.into())?;\n             }\n \n             \"TlsAlloc\" => {\n@@ -894,9 +924,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = this\n-                        .memory\n-                        .read_bytes(buf, Size::from_bytes(u64::from(n)))?;\n+                    let buf_cont = this.memory.read_bytes(buf, Size::from_bytes(u64::from(n)))?;\n                     let res = if handle == -11 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -928,7 +956,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"GetCommandLineW\" => {\n-                this.write_scalar(this.machine.cmd_line.expect(\"machine must be initialized\"), dest)?;\n+                this.write_scalar(\n+                    this.machine.cmd_line.expect(\"machine must be initialized\"),\n+                    dest,\n+                )?;\n             }\n             // The actual name of 'RtlGenRandom'\n             \"SystemFunction036\" => {\n@@ -955,10 +986,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, Option<ScalarMaybeUndef<Tag>>> {\n         let this = self.eval_context_mut();\n         if let Ok(instance) = this.resolve_path(path) {\n-            let cid = GlobalId {\n-                instance,\n-                promoted: None,\n-            };\n+            let cid = GlobalId { instance, promoted: None };\n             let const_val = this.const_eval_raw(cid)?;\n             let const_val = this.read_scalar(const_val.into())?;\n             return Ok(Some(const_val));"}, {"sha": "0b78111533a59cb5f8b0aef82b2a01124f6a170e", "filename": "src/shims/fs.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,11 +1,11 @@\n use std::collections::HashMap;\n-use std::convert::{TryInto, TryFrom};\n+use std::convert::{TryFrom, TryInto};\n use std::fs::{remove_file, File, OpenOptions};\n use std::io::{Read, Write};\n use std::path::PathBuf;\n use std::time::SystemTime;\n \n-use rustc::ty::layout::{Size, Align, LayoutOf};\n+use rustc::ty::layout::{Align, LayoutOf, Size};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n@@ -172,18 +172,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let buf = this.read_scalar(buf_op)?.not_undef()?;\n-        let count = this\n-            .read_scalar(count_op)?\n-            .to_machine_usize(&*this.tcx)?;\n+        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n \n         // Check that the *entire* buffer is actually valid memory.\n-        this.memory.check_ptr_access(buf, Size::from_bytes(count), Align::from_bytes(1).unwrap())?;\n+        this.memory.check_ptr_access(\n+            buf,\n+            Size::from_bytes(count),\n+            Align::from_bytes(1).unwrap(),\n+        )?;\n \n         // We cap the number of read bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n-        let count = count\n-            .min(this.isize_max() as u64)\n-            .min(isize::max_value() as u64);\n+        let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n         if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n             // This can never fail because `count` was capped to be smaller than\n@@ -227,18 +227,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let buf = this.read_scalar(buf_op)?.not_undef()?;\n-        let count = this\n-            .read_scalar(count_op)?\n-            .to_machine_usize(&*this.tcx)?;\n+        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n \n         // Check that the *entire* buffer is actually valid memory.\n-        this.memory.check_ptr_access(buf, Size::from_bytes(count), Align::from_bytes(1).unwrap())?;\n+        this.memory.check_ptr_access(\n+            buf,\n+            Size::from_bytes(count),\n+            Align::from_bytes(1).unwrap(),\n+        )?;\n \n         // We cap the number of written bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n-        let count = count\n-            .min(this.isize_max() as u64)\n-            .min(isize::max_value() as u64);\n+        let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n         if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n@@ -263,11 +263,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn statx(\n         &mut self,\n-        dirfd_op: OpTy<'tcx, Tag>, // Should be an `int`\n+        dirfd_op: OpTy<'tcx, Tag>,    // Should be an `int`\n         pathname_op: OpTy<'tcx, Tag>, // Should be a `const char *`\n-        flags_op: OpTy<'tcx, Tag>, // Should be an `int`\n-        _mask_op: OpTy<'tcx, Tag>, // Should be an `unsigned int`\n-        statxbuf_op: OpTy<'tcx, Tag> // Should be a `struct statx *`\n+        flags_op: OpTy<'tcx, Tag>,    // Should be an `int`\n+        _mask_op: OpTy<'tcx, Tag>,    // Should be an `unsigned int`\n+        statxbuf_op: OpTy<'tcx, Tag>, // Should be a `struct statx *`\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -302,29 +302,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let path: PathBuf = this.read_os_str_from_c_str(pathname_scalar)?.into();\n         // `flags` should be a `c_int` but the `syscall` function provides an `isize`.\n-        let flags: i32 = this\n-            .read_scalar(flags_op)?\n-            .to_machine_isize(&*this.tcx)?\n-            .try_into()\n-            .map_err(|e| err_unsup_format!(\n-                \"Failed to convert pointer sized operand to integer: {}\",\n-                e\n-            ))?;\n+        let flags: i32 =\n+            this.read_scalar(flags_op)?.to_machine_isize(&*this.tcx)?.try_into().map_err(|e| {\n+                err_unsup_format!(\"Failed to convert pointer sized operand to integer: {}\", e)\n+            })?;\n         // `dirfd` should be a `c_int` but the `syscall` function provides an `isize`.\n-        let dirfd: i32 = this\n-            .read_scalar(dirfd_op)?\n-            .to_machine_isize(&*this.tcx)?\n-            .try_into()\n-            .map_err(|e| err_unsup_format!(\n-                \"Failed to convert pointer sized operand to integer: {}\",\n-                e\n-            ))?;\n+        let dirfd: i32 =\n+            this.read_scalar(dirfd_op)?.to_machine_isize(&*this.tcx)?.try_into().map_err(|e| {\n+                err_unsup_format!(\"Failed to convert pointer sized operand to integer: {}\", e)\n+            })?;\n         // we only support interpreting `path` as an absolute directory or as a directory relative\n         // to `dirfd` when the latter is `AT_FDCWD`. The behavior of `statx` with a relative path\n         // and a directory file descriptor other than `AT_FDCWD` is specified but it cannot be\n         // tested from `libstd`. If you found this error, please open an issue reporting it.\n-        if !(path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\")?)\n-        {\n+        if !(path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\")?) {\n             throw_unsup_format!(\n                 \"Using statx with a relative path and a file descriptor different from `AT_FDCWD` is not supported\"\n             )\n@@ -368,29 +359,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // the owner, its group and other users. Given that we can only provide the file type\n         // without using platform specific methods, we only set the bits corresponding to the file\n         // type. This should be an `__u16` but `libc` provides its values as `u32`.\n-        let mode: u16 = this.eval_libc(mode_name)?\n-                .to_u32()?\n-                .try_into()\n-                .unwrap_or_else(|_| bug!(\"libc contains bad value for `{}` constant\", mode_name));\n+        let mode: u16 = this\n+            .eval_libc(mode_name)?\n+            .to_u32()?\n+            .try_into()\n+            .unwrap_or_else(|_| bug!(\"libc contains bad value for `{}` constant\", mode_name));\n \n         let size = metadata.len();\n \n         let (access_sec, access_nsec) = extract_sec_and_nsec(\n             metadata.accessed(),\n             &mut mask,\n-            this.eval_libc(\"STATX_ATIME\")?.to_u32()?\n+            this.eval_libc(\"STATX_ATIME\")?.to_u32()?,\n         )?;\n \n         let (created_sec, created_nsec) = extract_sec_and_nsec(\n             metadata.created(),\n             &mut mask,\n-            this.eval_libc(\"STATX_BTIME\")?.to_u32()?\n+            this.eval_libc(\"STATX_BTIME\")?.to_u32()?,\n         )?;\n \n         let (modified_sec, modified_nsec) = extract_sec_and_nsec(\n             metadata.modified(),\n             &mut mask,\n-            this.eval_libc(\"STATX_MTIME\")?.to_u32()?\n+            this.eval_libc(\"STATX_MTIME\")?.to_u32()?,\n         )?;\n \n         let __u32_layout = this.libc_ty_layout(\"__u32\")?;\n@@ -401,16 +393,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // zero for the unavailable fields.\n         // FIXME: Provide more fields using platform specific methods.\n         let imms = [\n-            immty_from_uint_checked(mask, __u32_layout)?,  // stx_mask\n+            immty_from_uint_checked(mask, __u32_layout)?, // stx_mask\n             immty_from_uint_checked(0u128, __u32_layout)?, // stx_blksize\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n             immty_from_uint_checked(0u128, __u32_layout)?, // stx_nlink\n             immty_from_uint_checked(0u128, __u32_layout)?, // stx_uid\n             immty_from_uint_checked(0u128, __u32_layout)?, // stx_gid\n-            immty_from_uint_checked(mode, __u16_layout)?,  // stx_mode\n+            immty_from_uint_checked(mode, __u16_layout)?, // stx_mode\n             immty_from_uint_checked(0u128, __u16_layout)?, // statx padding\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_ino\n-            immty_from_uint_checked(size, __u64_layout)?,  // stx_size\n+            immty_from_uint_checked(size, __u64_layout)?, // stx_size\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_blocks\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n             immty_from_uint_checked(access_sec, __u64_layout)?, // stx_atime.tv_sec\n@@ -451,7 +443,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n // Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch, and\n // then sets the `mask` bits determined by `flag` when `time` is Ok. If `time` is an error, it\n // returns `(0, 0)` without setting any bits.\n-fn extract_sec_and_nsec<'tcx>(time: std::io::Result<SystemTime>, mask: &mut u32, flag: u32) -> InterpResult<'tcx, (u64, u32)> {\n+fn extract_sec_and_nsec<'tcx>(\n+    time: std::io::Result<SystemTime>,\n+    mask: &mut u32,\n+    flag: u32,\n+) -> InterpResult<'tcx, (u64, u32)> {\n     if let Ok(time) = time {\n         let duration = system_time_to_duration(&time)?;\n         *mask |= flag;"}, {"sha": "bde2dd4655bf7c852a66a2e0f4efae9635221b5b", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 149, "deletions": 124, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,10 +1,10 @@\n use std::iter;\n \n-use rustc_apfloat::Float;\n use rustc::mir;\n use rustc::mir::interpret::{InterpResult, PointerArithmetic};\n-use rustc::ty::layout::{self, LayoutOf, Size, Align};\n use rustc::ty;\n+use rustc::ty::layout::{self, Align, LayoutOf, Size};\n+use rustc_apfloat::Float;\n use syntax::source_map::Span;\n \n use crate::*;\n@@ -17,13 +17,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n-        unwind: Option<mir::BasicBlock>\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if this.emulate_intrinsic(span, instance, args, ret)? {\n             return Ok(());\n         }\n-        let tcx = &{this.tcx.tcx};\n+        let tcx = &{ this.tcx.tcx };\n         let substs = instance.substs;\n \n         // All these intrinsics take raw pointers, so if we access memory directly\n@@ -37,13 +37,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 throw_machine_stop!(TerminationInfo::Abort);\n             }\n             \"miri_start_panic\" => return this.handle_miri_start_panic(args, unwind),\n-            _ => {\n+            _ =>\n                 if let Some(p) = ret {\n                     p\n                 } else {\n                     throw_unsup_format!(\"unimplemented (diverging) intrinsic: {}\", intrinsic_name);\n-                }\n-            }\n+                },\n         };\n \n         match intrinsic_name {\n@@ -75,9 +74,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.copy_op(args[1], place.into())?;\n             }\n \n-            \"atomic_load\" |\n-            \"atomic_load_relaxed\" |\n-            \"atomic_load_acq\" => {\n+            #[rustfmt::skip]\n+            | \"atomic_load\"\n+            | \"atomic_load_relaxed\"\n+            | \"atomic_load_acq\"\n+            => {\n                 let place = this.deref_operand(args[0])?;\n                 let val = this.read_scalar(place.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n@@ -90,9 +91,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(val, dest)?;\n             }\n \n-            \"atomic_store\" |\n-            \"atomic_store_relaxed\" |\n-            \"atomic_store_rel\" => {\n+            #[rustfmt::skip]\n+            | \"atomic_store\"\n+            | \"atomic_store_relaxed\"\n+            | \"atomic_store_rel\"\n+            => {\n                 let place = this.deref_operand(args[0])?;\n                 let val = this.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n@@ -105,10 +108,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(val, place.into())?;\n             }\n \n-            \"atomic_fence_acq\" |\n-            \"atomic_fence_rel\" |\n-            \"atomic_fence_acqrel\" |\n-            \"atomic_fence\" => {\n+            #[rustfmt::skip]\n+            | \"atomic_fence_acq\"\n+            | \"atomic_fence_rel\"\n+            | \"atomic_fence_acqrel\"\n+            | \"atomic_fence\"\n+            => {\n                 // we are inherently singlethreaded and singlecored, this is a nop\n             }\n \n@@ -139,46 +144,49 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n                 this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n-                // binary_op will bail if either of them is not a scalar\n+                // `binary_op` will bail if either of them is not a scalar.\n                 let eq = this.overflowing_binary_op(mir::BinOp::Eq, old, expect_old)?.0;\n                 let res = Immediate::ScalarPair(old.to_scalar_or_undef(), eq.into());\n-                this.write_immediate(res, dest)?; // old value is returned\n-                // update ptr depending on comparison\n+                // Return old value.\n+                this.write_immediate(res, dest)?;\n+                // Update ptr depending on comparison.\n                 if eq.to_bool()? {\n                     this.write_scalar(new, place.into())?;\n                 }\n             }\n \n-            \"atomic_or\" |\n-            \"atomic_or_acq\" |\n-            \"atomic_or_rel\" |\n-            \"atomic_or_acqrel\" |\n-            \"atomic_or_relaxed\" |\n-            \"atomic_xor\" |\n-            \"atomic_xor_acq\" |\n-            \"atomic_xor_rel\" |\n-            \"atomic_xor_acqrel\" |\n-            \"atomic_xor_relaxed\" |\n-            \"atomic_and\" |\n-            \"atomic_and_acq\" |\n-            \"atomic_and_rel\" |\n-            \"atomic_and_acqrel\" |\n-            \"atomic_and_relaxed\" |\n-            \"atomic_nand\" |\n-            \"atomic_nand_acq\" |\n-            \"atomic_nand_rel\" |\n-            \"atomic_nand_acqrel\" |\n-            \"atomic_nand_relaxed\" |\n-            \"atomic_xadd\" |\n-            \"atomic_xadd_acq\" |\n-            \"atomic_xadd_rel\" |\n-            \"atomic_xadd_acqrel\" |\n-            \"atomic_xadd_relaxed\" |\n-            \"atomic_xsub\" |\n-            \"atomic_xsub_acq\" |\n-            \"atomic_xsub_rel\" |\n-            \"atomic_xsub_acqrel\" |\n-            \"atomic_xsub_relaxed\" => {\n+            #[rustfmt::skip]\n+            | \"atomic_or\"\n+            | \"atomic_or_acq\"\n+            | \"atomic_or_rel\"\n+            | \"atomic_or_acqrel\"\n+            | \"atomic_or_relaxed\"\n+            | \"atomic_xor\"\n+            | \"atomic_xor_acq\"\n+            | \"atomic_xor_rel\"\n+            | \"atomic_xor_acqrel\"\n+            | \"atomic_xor_relaxed\"\n+            | \"atomic_and\"\n+            | \"atomic_and_acq\"\n+            | \"atomic_and_rel\"\n+            | \"atomic_and_acqrel\"\n+            | \"atomic_and_relaxed\"\n+            | \"atomic_nand\"\n+            | \"atomic_nand_acq\"\n+            | \"atomic_nand_rel\"\n+            | \"atomic_nand_acqrel\"\n+            | \"atomic_nand_relaxed\"\n+            | \"atomic_xadd\"\n+            | \"atomic_xadd_acq\"\n+            | \"atomic_xadd_rel\"\n+            | \"atomic_xadd_acqrel\"\n+            | \"atomic_xadd_relaxed\"\n+            | \"atomic_xsub\"\n+            | \"atomic_xsub_acq\"\n+            | \"atomic_xsub_rel\"\n+            | \"atomic_xsub_acqrel\"\n+            | \"atomic_xsub_relaxed\"\n+            => {\n                 let place = this.deref_operand(args[0])?;\n                 if !place.layout.ty.is_integral() {\n                     bug!(\"Atomic arithmetic operations only work on integer types\");\n@@ -204,18 +212,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 // Atomics wrap around on overflow.\n                 let val = this.binary_op(op, old, rhs)?;\n-                let val = if neg {\n-                    this.unary_op(mir::UnOp::Not, val)?\n-                } else {\n-                    val\n-                };\n+                let val = if neg { this.unary_op(mir::UnOp::Not, val)? } else { val };\n                 this.write_immediate(*val, place.into())?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n \n-            \"copy\" |\n-            \"copy_nonoverlapping\" => {\n+            #[rustfmt::skip]\n+            | \"copy\"\n+            | \"copy_nonoverlapping\"\n+            => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_layout = this.layout_of(elem_ty)?;\n                 let elem_size = elem_layout.size.bytes();\n@@ -244,8 +250,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_uint(discr_val, dest.layout.size), dest)?;\n             }\n \n-            \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n-            \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" | \"roundf32\" => {\n+            #[rustfmt::skip]\n+            | \"sinf32\"\n+            | \"fabsf32\"\n+            | \"cosf32\"\n+            | \"sqrtf32\"\n+            | \"expf32\"\n+            | \"exp2f32\"\n+            | \"logf32\"\n+            | \"log10f32\"\n+            | \"log2f32\"\n+            | \"floorf32\"\n+            | \"ceilf32\"\n+            | \"truncf32\"\n+            | \"roundf32\"\n+            => {\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n                 let f = match intrinsic_name {\n@@ -267,8 +286,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_u32(f.to_bits()), dest)?;\n             }\n \n-            \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n-            \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" | \"roundf64\" => {\n+            #[rustfmt::skip]\n+            | \"sinf64\"\n+            | \"fabsf64\"\n+            | \"cosf64\"\n+            | \"sqrtf64\"\n+            | \"expf64\"\n+            | \"exp2f64\"\n+            | \"logf64\"\n+            | \"log10f64\"\n+            | \"log2f64\"\n+            | \"floorf64\"\n+            | \"ceilf64\"\n+            | \"truncf64\"\n+            | \"roundf64\"\n+            => {\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n                 let f = match intrinsic_name {\n@@ -290,7 +322,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_u64(f.to_bits()), dest)?;\n             }\n \n-            \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n+            #[rustfmt::skip]\n+            | \"fadd_fast\"\n+            | \"fsub_fast\"\n+            | \"fmul_fast\"\n+            | \"fdiv_fast\"\n+            | \"frem_fast\"\n+            => {\n                 let a = this.read_immediate(args[0])?;\n                 let b = this.read_immediate(args[1])?;\n                 let op = match intrinsic_name {\n@@ -304,7 +342,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.binop_ignore_overflow(op, a, b, dest)?;\n             }\n \n-            \"minnumf32\" | \"maxnumf32\" | \"copysignf32\" => {\n+            #[rustfmt::skip]\n+            | \"minnumf32\"\n+            | \"maxnumf32\"\n+            | \"copysignf32\"\n+            => {\n                 let a = this.read_scalar(args[0])?.to_f32()?;\n                 let b = this.read_scalar(args[1])?.to_f32()?;\n                 let res = match intrinsic_name {\n@@ -316,7 +358,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_f32(res), dest)?;\n             }\n \n-            \"minnumf64\" | \"maxnumf64\" | \"copysignf64\" => {\n+            #[rustfmt::skip]\n+            | \"minnumf64\"\n+            | \"maxnumf64\"\n+            | \"copysignf64\"\n+            => {\n                 let a = this.read_scalar(args[0])?.to_f64()?;\n                 let b = this.read_scalar(args[1])?.to_f64()?;\n                 let res = match intrinsic_name {\n@@ -329,15 +375,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"exact_div\" =>\n-                this.exact_div(\n-                    this.read_immediate(args[0])?,\n-                    this.read_immediate(args[1])?,\n-                    dest,\n-                )?,\n+                this.exact_div(this.read_immediate(args[0])?, this.read_immediate(args[1])?, dest)?,\n \n             \"forget\" => {}\n \n-            \"likely\" | \"unlikely\" => {\n+            #[rustfmt::skip]\n+            | \"likely\"\n+            | \"unlikely\"\n+            => {\n                 // These just return their argument\n                 let b = this.read_immediate(args[0])?;\n                 this.write_immediate(*b, dest)?;\n@@ -365,7 +410,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             // Do it in memory\n                             let mplace = this.force_allocation(dest)?;\n                             mplace.meta.unwrap_none(); // must be sized\n-                            this.memory.write_bytes(mplace.ptr, iter::repeat(0u8).take(dest.layout.size.bytes() as usize))?;\n+                            this.memory.write_bytes(\n+                                mplace.ptr,\n+                                iter::repeat(0u8).take(dest.layout.size.bytes() as usize),\n+                            )?;\n                         }\n                     }\n                 }\n@@ -405,85 +453,65 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(args[1])?.to_u32()?);\n-                this.write_scalar(\n-                    Scalar::from_u32(f.powf(f2).to_bits()),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_u32(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"powf64\" => {\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(args[1])?.to_u64()?);\n-                this.write_scalar(\n-                    Scalar::from_u64(f.powf(f2).to_bits()),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_u64(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"fmaf32\" => {\n                 let a = this.read_scalar(args[0])?.to_f32()?;\n                 let b = this.read_scalar(args[1])?.to_f32()?;\n                 let c = this.read_scalar(args[2])?.to_f32()?;\n                 let res = a.mul_add(b, c).value;\n-                this.write_scalar(\n-                    Scalar::from_f32(res),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_f32(res), dest)?;\n             }\n \n             \"fmaf64\" => {\n                 let a = this.read_scalar(args[0])?.to_f64()?;\n                 let b = this.read_scalar(args[1])?.to_f64()?;\n                 let c = this.read_scalar(args[2])?.to_f64()?;\n                 let res = a.mul_add(b, c).value;\n-                this.write_scalar(\n-                    Scalar::from_f64(res),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_f64(res), dest)?;\n             }\n \n             \"powif32\" => {\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n                 let i = this.read_scalar(args[1])?.to_i32()?;\n-                this.write_scalar(\n-                    Scalar::from_u32(f.powi(i).to_bits()),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_u32(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"powif64\" => {\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n                 let i = this.read_scalar(args[1])?.to_i32()?;\n-                this.write_scalar(\n-                    Scalar::from_u64(f.powi(i).to_bits()),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"size_of_val\" => {\n                 let mplace = this.deref_operand(args[0])?;\n-                let (size, _) = this.size_and_align_of_mplace(mplace)?\n+                let (size, _) = this\n+                    .size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = this.pointer_size();\n-                this.write_scalar(\n-                    Scalar::from_uint(size.bytes() as u128, ptr_size),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_uint(size.bytes() as u128, ptr_size), dest)?;\n             }\n \n-            \"min_align_of_val\" |\n-            \"align_of_val\" => {\n+            #[rustfmt::skip]\n+            | \"min_align_of_val\"\n+            | \"align_of_val\"\n+            => {\n                 let mplace = this.deref_operand(args[0])?;\n-                let (_, align) = this.size_and_align_of_mplace(mplace)?\n+                let (_, align) = this\n+                    .size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = this.pointer_size();\n-                this.write_scalar(\n-                    Scalar::from_uint(align.bytes(), ptr_size),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_uint(align.bytes(), ptr_size), dest)?;\n             }\n \n             \"unchecked_div\" => {\n@@ -493,12 +521,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if rval == 0 {\n                     throw_ub_format!(\"Division by 0 in unchecked_div\");\n                 }\n-                this.binop_ignore_overflow(\n-                    mir::BinOp::Div,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n+                this.binop_ignore_overflow(mir::BinOp::Div, l, r, dest)?;\n             }\n \n             \"unchecked_rem\" => {\n@@ -508,15 +531,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if rval == 0 {\n                     throw_ub_format!(\"Division by 0 in unchecked_rem\");\n                 }\n-                this.binop_ignore_overflow(\n-                    mir::BinOp::Rem,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n+                this.binop_ignore_overflow(mir::BinOp::Rem, l, r, dest)?;\n             }\n \n-            \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" => {\n+            #[rustfmt::skip]\n+            | \"unchecked_add\"\n+            | \"unchecked_sub\"\n+            | \"unchecked_mul\"\n+            => {\n                 let l = this.read_immediate(args[0])?;\n                 let r = this.read_immediate(args[1])?;\n                 let op = match intrinsic_name {\n@@ -555,9 +577,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             mplace.meta.unwrap_none();\n                             let ptr = mplace.ptr.to_ptr()?;\n                             // We know the return place is in-bounds\n-                            this.memory\n-                                .get_raw_mut(ptr.alloc_id)?\n-                                .mark_definedness(ptr, dest.layout.size, false);\n+                            this.memory.get_raw_mut(ptr.alloc_id)?.mark_definedness(\n+                                ptr,\n+                                dest.layout.size,\n+                                false,\n+                            );\n                         }\n                     }\n                 }\n@@ -570,7 +594,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let count = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let byte_count = ty_layout.size * count;\n-                this.memory.write_bytes(ptr, iter::repeat(val_byte).take(byte_count.bytes() as usize))?;\n+                this.memory\n+                    .write_bytes(ptr, iter::repeat(val_byte).take(byte_count.bytes() as usize))?;\n             }\n \n             name => throw_unsup_format!(\"unimplemented intrinsic: {}\", name),"}, {"sha": "2889807bf76aa1837d53eeed9c36bfc25b72a617", "filename": "src/shims/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -1,14 +1,14 @@\n pub mod dlsym;\n pub mod env;\n pub mod foreign_items;\n-pub mod intrinsics;\n-pub mod tls;\n pub mod fs;\n-pub mod time;\n+pub mod intrinsics;\n pub mod panic;\n+pub mod time;\n+pub mod tls;\n \n-use rustc::{mir, ty};\n use crate::*;\n+use rustc::{mir, ty};\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -17,14 +17,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n-        unwind: Option<mir::BasicBlock>\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n-        trace!(\n-            \"eval_fn_call: {:#?}, {:?}\",\n-            instance,\n-            ret.map(|p| *p.0)\n-        );\n+        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, ret.map(|p| *p.0));\n \n         // There are some more lang items we want to hook that CTFE does not hook (yet).\n         if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n@@ -59,10 +55,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, Option<u128>> {\n         let this = self.eval_context_mut();\n \n-        let req_align = this.force_bits(\n-            this.read_scalar(align_op)?.not_undef()?,\n-            this.pointer_size(),\n-        )? as usize;\n+        let req_align = this\n+            .force_bits(this.read_scalar(align_op)?.not_undef()?, this.pointer_size())?\n+            as usize;\n \n         // FIXME: This should actually panic in the interpreted program\n         if !req_align.is_power_of_two() {\n@@ -72,7 +67,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ptr_scalar = this.read_scalar(ptr_op)?.not_undef()?;\n \n         if let Ok(ptr) = this.force_ptr(ptr_scalar) {\n-            let cur_align = this.memory.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)?.1.bytes() as usize;\n+            let cur_align =\n+                this.memory.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)?.1.bytes()\n+                    as usize;\n             if cur_align >= req_align {\n                 // if the allocation alignment is at least the required alignment we use the\n                 // libcore implementation"}, {"sha": "f242f41f6f96ff2ea630149ceac34092faab3606", "filename": "src/shims/panic.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -11,10 +11,10 @@\n //!   gets popped *during unwinding*, we take the panic payload and store it according to the extra\n //!   metadata we remembered when pushing said frame.\n \n-use syntax::source_map::Span;\n use rustc::mir;\n use rustc::ty::{self, layout::LayoutOf};\n use rustc_target::spec::PanicStrategy;\n+use syntax::source_map::Span;\n \n use crate::*;\n \n@@ -35,26 +35,28 @@ pub struct CatchUnwindData<'tcx> {\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-\n     /// Handles the special \"miri_start_panic\" intrinsic, which is called\n     /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n     fn handle_miri_start_panic(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        unwind: Option<mir::BasicBlock>\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         trace!(\"miri_start_panic: {:?}\", this.frame().span);\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n         let scalar = this.read_immediate(args[0])?;\n-        assert!(this.machine.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n+        assert!(\n+            this.machine.panic_payload.is_none(),\n+            \"the panic runtime should avoid double-panics\"\n+        );\n         this.machine.panic_payload = Some(scalar);\n \n         // Jump to the unwind block to begin unwinding.\n         this.unwind_to_block(unwind);\n-        return Ok(())\n+        return Ok(());\n     }\n \n     fn handle_catch_panic(\n@@ -64,7 +66,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let tcx = &{this.tcx.tcx};\n+        let tcx = &{ this.tcx.tcx };\n \n         // fn __rust_maybe_catch_panic(\n         //     f: fn(*mut u8),\n@@ -82,8 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Now we make a function call, and pass `f_arg` as first and only argument.\n         let f_instance = this.memory.get_fn(f)?.as_instance()?;\n         trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n-        let ret_place =\n-            MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n+        let ret_place = MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n         this.call_function(\n             f_instance,\n             &[f_arg.into()],\n@@ -99,11 +100,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // This lets `handle_stack_pop` (below) know that we should stop unwinding\n         // when we pop this frame.\n         if this.tcx.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n-            this.frame_mut().extra.catch_panic = Some(CatchUnwindData {\n-                data_place,\n-                vtable_place,\n-                dest,\n-            })\n+            this.frame_mut().extra.catch_panic =\n+                Some(CatchUnwindData { data_place, vtable_place, dest })\n         }\n \n         return Ok(());\n@@ -112,7 +110,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn handle_stack_pop(\n         &mut self,\n         mut extra: FrameData<'tcx>,\n-        unwinding: bool\n+        unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopInfo> {\n         let this = self.eval_context_mut();\n "}, {"sha": "a7d51eaa2e0f7a2006d5192bde1dbbfa511b9822", "filename": "src/shims/time.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -9,10 +9,9 @@ fn get_time<'tcx>() -> InterpResult<'tcx, Duration> {\n     system_time_to_duration(&SystemTime::now())\n }\n \n-// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n+/// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n pub fn system_time_to_duration<'tcx>(time: &SystemTime) -> InterpResult<'tcx, Duration> {\n-    time\n-        .duration_since(SystemTime::UNIX_EPOCH)\n+    time.duration_since(SystemTime::UNIX_EPOCH)\n         .map_err(|_| err_unsup_format!(\"Times before the Unix epoch are not supported\").into())\n }\n "}, {"sha": "cdfc0bcda8b6343a45fdbb93f2427b7a6cf09424", "filename": "src/shims/tls.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -2,14 +2,10 @@\n \n use std::collections::BTreeMap;\n \n-use rustc_target::abi::LayoutOf;\n use rustc::{ty, ty::layout::HasDataLayout};\n+use rustc_target::abi::LayoutOf;\n \n-use crate::{\n-    InterpResult, StackPopCleanup,\n-    MPlaceTy, Scalar, Tag,\n-    HelpersEvalContextExt,\n-};\n+use crate::{HelpersEvalContextExt, InterpResult, MPlaceTy, Scalar, StackPopCleanup, Tag};\n \n pub type TlsKey = u128;\n \n@@ -41,19 +37,10 @@ impl<'tcx> Default for TlsData<'tcx> {\n }\n \n impl<'tcx> TlsData<'tcx> {\n-    pub fn create_tls_key(\n-        &mut self,\n-        dtor: Option<ty::Instance<'tcx>>,\n-    ) -> TlsKey {\n+    pub fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_key;\n         self.next_key += 1;\n-        self.keys.insert(\n-            new_key,\n-            TlsEntry {\n-                data: None,\n-                dtor,\n-            },\n-        ).unwrap_none();\n+        self.keys.insert(new_key, TlsEntry { data: None, dtor }).unwrap_none();\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         new_key\n     }"}, {"sha": "fb68f46d379e1b7c06d6d08d3592721f9069cf86", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 82, "deletions": 111, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -3,17 +3,17 @@\n \n use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n-use std::rc::Rc;\n use std::fmt;\n use std::num::NonZeroU64;\n+use std::rc::Rc;\n \n-use rustc::ty::{self, layout::Size};\n-use rustc::hir::Mutability::{Mutable, Immutable};\n+use rustc::hir::Mutability::{Immutable, Mutable};\n use rustc::mir::RetagKind;\n+use rustc::ty::{self, layout::Size};\n \n use crate::{\n-    InterpResult, HelpersEvalContextExt, TerminationInfo,\n-    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n+    AllocId, HelpersEvalContextExt, ImmTy, Immediate, InterpResult, MPlaceTy, MemoryKind,\n+    MiriMemoryKind, PlaceTy, Pointer, RangeMap, TerminationInfo,\n };\n \n pub type PtrId = NonZeroU64;\n@@ -82,7 +82,6 @@ pub struct Stack {\n     borrows: Vec<Item>,\n }\n \n-\n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n pub struct Stacks {\n@@ -217,7 +216,8 @@ impl Permission {\n     /// This defines for a given permission, whether it permits the given kind of access.\n     fn grants(self, access: AccessKind) -> bool {\n         // Disabled grants nothing. Otherwise, all items grant read access, and except for SharedReadOnly they grant write access.\n-        self != Permission::Disabled && (access == AccessKind::Read || self != Permission::SharedReadOnly)\n+        self != Permission::Disabled\n+            && (access == AccessKind::Read || self != Permission::SharedReadOnly)\n     }\n }\n \n@@ -226,17 +226,16 @@ impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and return where\n     /// it is on the stack.\n     fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<usize> {\n-        self.borrows.iter()\n+        self.borrows\n+            .iter()\n             .enumerate() // we also need to know *where* in the stack\n             .rev() // search top-to-bottom\n             // Return permission of first item that grants access.\n             // We require a permission with the right tag, ensuring U3 and F3.\n-            .find_map(|(idx, item)|\n-                if tag == item.tag && item.perm.grants(access) {\n-                    Some(idx)\n-                } else {\n-                    None\n-                }\n+            .find_map(\n+                |(idx, item)| {\n+                    if tag == item.tag && item.perm.grants(access) { Some(idx) } else { None }\n+                },\n             )\n     }\n \n@@ -245,13 +244,10 @@ impl<'tcx> Stack {\n     fn find_first_write_incompatible(&self, granting: usize) -> usize {\n         let perm = self.borrows[granting].perm;\n         match perm {\n-            Permission::SharedReadOnly =>\n-                bug!(\"Cannot use SharedReadOnly for writing\"),\n-            Permission::Disabled =>\n-                bug!(\"Cannot use Disabled for anything\"),\n-            Permission::Unique =>\n-                // On a write, everything above us is incompatible.\n-                granting + 1,\n+            Permission::SharedReadOnly => bug!(\"Cannot use SharedReadOnly for writing\"),\n+            Permission::Disabled => bug!(\"Cannot use Disabled for anything\"),\n+            // On a write, everything above us is incompatible.\n+            Permission::Unique => granting + 1,\n             Permission::SharedReadWrite => {\n                 // The SharedReadWrite *just* above us are compatible, to skip those.\n                 let mut idx = granting + 1;\n@@ -285,7 +281,8 @@ impl<'tcx> Stack {\n                     )));\n                 } else {\n                     throw_ub!(UbExperimental(format!(\n-                        \"deallocating while item is protected: {:?}\", item\n+                        \"deallocating while item is protected: {:?}\",\n+                        item\n                     )));\n                 }\n             }\n@@ -295,20 +292,16 @@ impl<'tcx> Stack {\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n-    fn access(\n-        &mut self,\n-        access: AccessKind,\n-        tag: Tag,\n-        global: &GlobalState,\n-    ) -> InterpResult<'tcx> {\n+    fn access(&mut self, access: AccessKind, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag)\n-            .ok_or_else(|| err_ub!(UbExperimental(format!(\n+        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+            err_ub!(UbExperimental(format!(\n                 \"no item granting {} to tag {:?} found in borrow stack\",\n                 access, tag,\n-            ))))?;\n+            )))\n+        })?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -329,7 +322,7 @@ impl<'tcx> Stack {\n             // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n             // reference and use that.\n             // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n-            for idx in (granting_idx+1 .. self.borrows.len()).rev() {\n+            for idx in ((granting_idx + 1)..self.borrows.len()).rev() {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n@@ -345,17 +338,14 @@ impl<'tcx> Stack {\n \n     /// Deallocate a location: Like a write access, but also there must be no\n     /// active protectors at all because we will remove all items.\n-    fn dealloc(\n-        &mut self,\n-        tag: Tag,\n-        global: &GlobalState,\n-    ) -> InterpResult<'tcx> {\n+    fn dealloc(&mut self, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, tag)\n-            .ok_or_else(|| err_ub!(UbExperimental(format!(\n+        self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n+            err_ub!(UbExperimental(format!(\n                 \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n                 tag,\n-            ))))?;\n+            )))\n+        })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n@@ -369,18 +359,10 @@ impl<'tcx> Stack {\n     /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n     /// an access, and they add the new item directly on top of the one it is derived\n     /// from instead of all the way at the top of the stack.\n-    fn grant(\n-        &mut self,\n-        derived_from: Tag,\n-        new: Item,\n-        global: &GlobalState,\n-    ) -> InterpResult<'tcx> {\n+    fn grant(&mut self, derived_from: Tag, new: Item, global: &GlobalState) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n-        let access = if new.perm.grants(AccessKind::Write) {\n-            AccessKind::Write\n-        } else {\n-            AccessKind::Read\n-        };\n+        let access =\n+            if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n         let granting_idx = self.find_granting(access, derived_from)\n@@ -392,7 +374,10 @@ impl<'tcx> Stack {\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n         let new_idx = if new.perm == Permission::SharedReadWrite {\n-            assert!(access == AccessKind::Write, \"this case only makes sense for stack-like accesses\");\n+            assert!(\n+                access == AccessKind::Write,\n+                \"this case only makes sense for stack-like accesses\"\n+            );\n             // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n             // access.  Instead of popping the stack, we insert the item at the place the stack would\n             // be popped to (i.e., we insert it above all the write-compatible items).\n@@ -412,7 +397,7 @@ impl<'tcx> Stack {\n         };\n \n         // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n-        if self.borrows[new_idx-1] == new || self.borrows.get(new_idx) == Some(&new) {\n+        if self.borrows[new_idx - 1] == new || self.borrows.get(new_idx) == Some(&new) {\n             // Optimization applies, done.\n             trace!(\"reborrow: avoiding adding redundant item {:?}\", new);\n         } else {\n@@ -428,21 +413,11 @@ impl<'tcx> Stack {\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n-    fn new(\n-        size: Size,\n-        perm: Permission,\n-        tag: Tag,\n-        extra: MemoryExtra,\n-    ) -> Self {\n+    fn new(size: Size, perm: Permission, tag: Tag, extra: MemoryExtra) -> Self {\n         let item = Item { perm, tag, protector: None };\n-        let stack = Stack {\n-            borrows: vec![item],\n-        };\n+        let stack = Stack { borrows: vec![item] };\n \n-        Stacks {\n-            stacks: RefCell::new(RangeMap::new(size, stack)),\n-            global: extra,\n-        }\n+        Stacks { stacks: RefCell::new(RangeMap::new(size, stack)), global: extra }\n     }\n \n     /// Call `f` on every stack in the range.\n@@ -470,33 +445,27 @@ impl Stacks {\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> (Self, Tag) {\n         let (tag, perm) = match kind {\n-            MemoryKind::Stack =>\n-                // New unique borrow. This tag is not accessible by the program,\n-                // so it will only ever be used when using the local directly (i.e.,\n-                // not through a pointer). That is, whenever we directly write to a local, this will pop\n-                // everything else off the stack, invalidating all previous pointers,\n-                // and in particular, *all* raw pointers.\n-                (Tag::Tagged(extra.borrow_mut().new_ptr()), Permission::Unique),\n+            // New unique borrow. This tag is not accessible by the program,\n+            // so it will only ever be used when using the local directly (i.e.,\n+            // not through a pointer). That is, whenever we directly write to a local, this will pop\n+            // everything else off the stack, invalidating all previous pointers,\n+            // and in particular, *all* raw pointers.\n+            MemoryKind::Stack => (Tag::Tagged(extra.borrow_mut().new_ptr()), Permission::Unique),\n+            // Static memory can be referenced by \"global\" pointers from `tcx`.\n+            // Thus we call `static_base_ptr` such that the global pointers get the same tag\n+            // as what we use here.\n+            // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n             MemoryKind::Machine(MiriMemoryKind::Static) =>\n-                // Static memory can be referenced by \"global\" pointers from `tcx`.\n-                // Thus we call `static_base_ptr` such that the global pointers get the same tag\n-                // as what we use here.\n-                // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n                 (extra.borrow_mut().static_base_ptr(id), Permission::SharedReadWrite),\n-            _ =>\n-                // Everything else we handle entirely untagged for now.\n-                // FIXME: experiment with more precise tracking.\n-                (Tag::Untagged, Permission::SharedReadWrite),\n+            // Everything else we handle entirely untagged for now.\n+            // FIXME: experiment with more precise tracking.\n+            _ => (Tag::Untagged, Permission::SharedReadWrite),\n         };\n         (Stacks::new(size, perm, tag, extra), tag)\n     }\n \n     #[inline(always)]\n-    pub fn memory_read<'tcx>(\n-        &self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n+    pub fn memory_read<'tcx>(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         self.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Read, ptr.tag, global)?;\n@@ -505,11 +474,7 @@ impl Stacks {\n     }\n \n     #[inline(always)]\n-    pub fn memory_written<'tcx>(\n-        &mut self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n+    pub fn memory_written<'tcx>(&mut self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         self.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Write, ptr.tag, global)?;\n@@ -524,9 +489,7 @@ impl Stacks {\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |stack, global| {\n-            stack.dealloc(ptr.tag, global)\n-        })\n+        self.for_each(ptr, size, |stack, global| stack.dealloc(ptr.tag, global))\n     }\n }\n \n@@ -545,12 +508,20 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra.call_id) } else { None };\n         let ptr = place.ptr.to_ptr().expect(\"we should have a proper pointer\");\n-        trace!(\"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n-            kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());\n+        trace!(\n+            \"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n+            kind,\n+            new_tag,\n+            ptr.tag,\n+            place.layout.ty,\n+            ptr.erase_tag(),\n+            size.bytes()\n+        );\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let extra = &this.memory.get_raw(ptr.alloc_id)?.extra;\n-        let stacked_borrows = extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+        let stacked_borrows =\n+            extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -564,7 +535,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We need a frozen-sensitive reborrow.\n                 return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n+                    let perm = if frozen {\n+                        Permission::SharedReadOnly\n+                    } else {\n+                        Permission::SharedReadWrite\n+                    };\n                     let item = Item { perm, tag: new_tag, protector };\n                     stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n                         stack.grant(cur_ptr.tag, item, global)\n@@ -573,9 +548,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows.for_each(ptr, size, |stack, global| {\n-            stack.grant(ptr.tag, item, global)\n-        })\n+        stacked_borrows.for_each(ptr, size, |stack, global| stack.grant(ptr.tag, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n@@ -589,7 +562,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n-        let size = this.size_and_align_of_mplace(place)?\n+        let size = this\n+            .size_and_align_of_mplace(place)?\n             .map(|(size, _)| size)\n             .unwrap_or_else(|| place.layout.size);\n         // We can see dangling ptrs in here e.g. after a Box's `Unique` was\n@@ -622,22 +596,19 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn retag(\n-        &mut self,\n-        kind: RetagKind,\n-        place: PlaceTy<'tcx, Tag>\n-    ) -> InterpResult<'tcx> {\n+    fn retag(&mut self, kind: RetagKind, place: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // Determine mutability and whether to add a protector.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n         // making it useless.\n         fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(RefKind, bool)> {\n             match ty.kind {\n                 // References are simple.\n-                ty::Ref(_, _, Mutable) =>\n-                    Some((RefKind::Unique { two_phase: kind == RetagKind::TwoPhase}, kind == RetagKind::FnEntry)),\n-                ty::Ref(_, _, Immutable) =>\n-                    Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n+                ty::Ref(_, _, Mutable) => Some((\n+                    RefKind::Unique { two_phase: kind == RetagKind::TwoPhase },\n+                    kind == RetagKind::FnEntry,\n+                )),\n+                ty::Ref(_, _, Immutable) => Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n                 // Raw pointers need to be enabled.\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == Mutable }, false)),"}, {"sha": "eaaa87464dbf6b89e546f4858d2418fd7c4d19b5", "filename": "tests/compiletest.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7ead530841a7c16d2228504978a7ab34e08d0b40/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ead530841a7c16d2228504978a7ab34e08d0b40/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=7ead530841a7c16d2228504978a7ab34e08d0b40", "patch": "@@ -2,11 +2,11 @@\n // Custom test runner, to avoid libtest being wrapped around compiletest which wraps libtest.\n #![test_runner(test_runner)]\n \n-use std::path::PathBuf;\n use std::env;\n+use std::path::PathBuf;\n \n-use compiletest_rs as compiletest;\n use colored::*;\n+use compiletest_rs as compiletest;\n \n fn miri_path() -> PathBuf {\n     if rustc_test_suite().is_some() {\n@@ -57,12 +57,15 @@ fn run_tests(mode: &str, path: &str, target: &str, mut flags: Vec<String>) {\n \n fn compile_fail(path: &str, target: &str, opt: bool) {\n     let opt_str = if opt { \" with optimizations\" } else { \"\" };\n-    eprintln!(\"{}\", format!(\n-        \"## Running compile-fail tests in {} against miri for target {}{}\",\n-        path,\n-        target,\n-        opt_str\n-    ).green().bold());\n+    eprintln!(\n+        \"{}\",\n+        format!(\n+            \"## Running compile-fail tests in {} against miri for target {}{}\",\n+            path, target, opt_str\n+        )\n+        .green()\n+        .bold()\n+    );\n \n     let mut flags = Vec::new();\n     if opt {\n@@ -76,12 +79,15 @@ fn compile_fail(path: &str, target: &str, opt: bool) {\n \n fn miri_pass(path: &str, target: &str, opt: bool) {\n     let opt_str = if opt { \" with optimizations\" } else { \"\" };\n-    eprintln!(\"{}\", format!(\n-        \"## Running run-pass tests in {} against miri for target {}{}\",\n-        path,\n-        target,\n-        opt_str\n-    ).green().bold());\n+    eprintln!(\n+        \"{}\",\n+        format!(\n+            \"## Running run-pass tests in {} against miri for target {}{}\",\n+            path, target, opt_str\n+        )\n+        .green()\n+        .bold()\n+    );\n \n     let mut flags = Vec::new();\n     if opt {"}]}