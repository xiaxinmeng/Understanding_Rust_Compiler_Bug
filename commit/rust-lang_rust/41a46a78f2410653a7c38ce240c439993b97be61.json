{"sha": "41a46a78f2410653a7c38ce240c439993b97be61", "node_id": "C_kwDOAAsO6NoAKDQxYTQ2YTc4ZjI0MTA2NTNhN2MzOGNlMjQwYzQzOTk5M2I5N2JlNjE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-31T10:49:49Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-31T13:58:16Z"}, "message": "Make tt generic over the span data", "tree": {"sha": "3bfae26da80a96b5071e24f6da5eee5a0b4a1d54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bfae26da80a96b5071e24f6da5eee5a0b4a1d54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41a46a78f2410653a7c38ce240c439993b97be61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41a46a78f2410653a7c38ce240c439993b97be61", "html_url": "https://github.com/rust-lang/rust/commit/41a46a78f2410653a7c38ce240c439993b97be61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41a46a78f2410653a7c38ce240c439993b97be61/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d805c74c51888b3308c7577e747d50d6a6f1dc9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d805c74c51888b3308c7577e747d50d6a6f1dc9b", "html_url": "https://github.com/rust-lang/rust/commit/d805c74c51888b3308c7577e747d50d6a6f1dc9b"}], "stats": {"total": 1371, "additions": 804, "deletions": 567}, "files": [{"sha": "60d1e488d8a4341ca4c6854280e2ad9ca317713e", "filename": "crates/base-db/src/fixture.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -6,7 +6,7 @@ use rustc_hash::FxHashMap;\n use test_utils::{\n     extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER, ESCAPED_CURSOR_MARKER,\n };\n-use tt::Subtree;\n+use tt::token_id::Subtree;\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n@@ -495,16 +495,15 @@ impl ProcMacroExpander for MirrorProcMacroExpander {\n         _: &Env,\n     ) -> Result<Subtree, ProcMacroExpansionError> {\n         fn traverse(input: &Subtree) -> Subtree {\n-            let mut res = Subtree::default();\n-            res.delimiter = input.delimiter;\n+            let mut token_trees = vec![];\n             for tt in input.token_trees.iter().rev() {\n                 let tt = match tt {\n                     tt::TokenTree::Leaf(leaf) => tt::TokenTree::Leaf(leaf.clone()),\n                     tt::TokenTree::Subtree(sub) => tt::TokenTree::Subtree(traverse(sub)),\n                 };\n-                res.token_trees.push(tt);\n+                token_trees.push(tt);\n             }\n-            res\n+            Subtree { delimiter: input.delimiter, token_trees }\n         }\n         Ok(traverse(input))\n     }"}, {"sha": "43388e915b5d3defb514554e39b660bc3ed8ab01", "filename": "crates/base-db/src/input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Finput.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -12,7 +12,7 @@ use cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::SmolStr;\n-use tt::Subtree;\n+use tt::token_id::Subtree;\n use vfs::{file_set::FileSet, AnchoredPath, FileId, VfsPath};\n \n /// Files are grouped into source roots. A source root is a directory on the"}, {"sha": "fb7505ba2dd5b0c9558e3b44f758b4ba61633de7", "filename": "crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -66,7 +66,7 @@ impl From<CfgAtom> for CfgExpr {\n }\n \n impl CfgExpr {\n-    pub fn parse(tt: &tt::Subtree) -> CfgExpr {\n+    pub fn parse<S>(tt: &tt::Subtree<S>) -> CfgExpr {\n         next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n     }\n     /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n@@ -85,7 +85,7 @@ impl CfgExpr {\n     }\n }\n \n-fn next_cfg_expr(it: &mut SliceIter<'_, tt::TokenTree>) -> Option<CfgExpr> {\n+fn next_cfg_expr<S>(it: &mut SliceIter<'_, tt::TokenTree<S>>) -> Option<CfgExpr> {\n     let name = match it.next() {\n         None => return None,\n         Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),"}, {"sha": "dcea679567a53a8c9937b904c32d99afb3693ce9", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -2,6 +2,7 @@\n \n use std::sync::Arc;\n \n+use crate::tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n@@ -12,7 +13,6 @@ use intern::Interned;\n use la_arena::{Arena, ArenaMap};\n use rustc_abi::{Integer, IntegerType};\n use syntax::ast::{self, HasName, HasVisibility};\n-use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n@@ -82,7 +82,7 @@ fn repr_from_value(\n \n fn parse_repr_tt(tt: &Subtree) -> Option<ReprOptions> {\n     match tt.delimiter {\n-        Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n+        Delimiter { kind: DelimiterKind::Parenthesis, .. } => {}\n         _ => return None,\n     }\n "}, {"sha": "fcd92ad338583923b5522a324fe22e83dc1a8423", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -16,7 +16,6 @@ use syntax::{\n     ast::{self, HasAttrs, IsString},\n     AstPtr, AstToken, SmolStr, TextRange, TextSize,\n };\n-use tt::Subtree;\n \n use crate::{\n     db::DefDatabase,\n@@ -234,7 +233,7 @@ impl Attrs {\n \n     pub fn has_doc_hidden(&self) -> bool {\n         self.by_key(\"doc\").tt_values().any(|tt| {\n-            tt.delimiter_kind() == Some(DelimiterKind::Parenthesis) &&\n+            tt.delimiter.kind == DelimiterKind::Parenthesis &&\n                 matches!(&*tt.token_trees, [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] if ident.text == \"hidden\")\n         })\n     }\n@@ -628,7 +627,7 @@ pub struct AttrQuery<'attr> {\n }\n \n impl<'attr> AttrQuery<'attr> {\n-    pub fn tt_values(self) -> impl Iterator<Item = &'attr Subtree> {\n+    pub fn tt_values(self) -> impl Iterator<Item = &'attr crate::tt::Subtree> {\n         self.attrs().filter_map(|attr| attr.token_tree_value())\n     }\n "}, {"sha": "c3c1dfd39ac0b0c4ebca76b89485574d66100eb8", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -142,7 +142,7 @@ impl FunctionData {\n     }\n }\n \n-fn parse_rustc_legacy_const_generics(tt: &tt::Subtree) -> Box<[u32]> {\n+fn parse_rustc_legacy_const_generics(tt: &crate::tt::Subtree) -> Box<[u32]> {\n     let mut indices = Vec::new();\n     for args in tt.token_trees.chunks(2) {\n         match &args[0] {"}, {"sha": "d07c5fb67c6f605bc2dc60be7339cd1e07b2c9df", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -79,6 +79,8 @@ use nameres::DefMap;\n use stdx::impl_from;\n use syntax::ast;\n \n+use ::tt::token_id as tt;\n+\n use crate::{\n     adt::VariantData,\n     builtin_type::BuiltinType,\n@@ -973,15 +975,19 @@ fn attr_macro_as_call_id(\n     def: MacroDefId,\n     is_derive: bool,\n ) -> MacroCallId {\n-    let mut arg = match macro_attr.input.as_deref() {\n-        Some(AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n-        _ => Default::default(),\n+    let arg = match macro_attr.input.as_deref() {\n+        Some(AttrInput::TokenTree(tt, map)) => (\n+            {\n+                let mut tt = tt.clone();\n+                tt.delimiter = tt::Delimiter::UNSPECIFIED;\n+                tt\n+            },\n+            map.clone(),\n+        ),\n+        _ => (tt::Subtree::empty(), Default::default()),\n     };\n \n-    // The parentheses are always disposed here.\n-    arg.0.delimiter = None;\n-\n-    let res = def.as_lazy_macro(\n+    def.as_lazy_macro(\n         db.upcast(),\n         krate,\n         MacroCallKind::Attr {\n@@ -990,8 +996,7 @@ fn attr_macro_as_call_id(\n             invoc_attr_index: macro_attr.id,\n             is_derive,\n         },\n-    );\n-    res\n+    )\n }\n intern::impl_internable!(\n     crate::type_ref::TypeRef,"}, {"sha": "5ab90d92d9bd1e7fd3710300fdf5bb514b1530d0", "filename": "crates/hir-def/src/macro_expansion_tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -30,7 +30,7 @@ use syntax::{\n     SyntaxKind::{self, COMMENT, EOF, IDENT, LIFETIME_IDENT},\n     SyntaxNode, TextRange, T,\n };\n-use tt::{Subtree, TokenId};\n+use tt::token_id::{Subtree, TokenId};\n \n use crate::{\n     db::DefDatabase, macro_id_to_def_id, nameres::ModuleSource, resolver::HasResolver,\n@@ -253,9 +253,9 @@ fn extract_id_ranges(ranges: &mut Vec<(TextRange, TokenId)>, map: &TokenMap, tre\n     tree.token_trees.iter().for_each(|tree| match tree {\n         tt::TokenTree::Leaf(leaf) => {\n             let id = match leaf {\n-                tt::Leaf::Literal(it) => it.id,\n-                tt::Leaf::Punct(it) => it.id,\n-                tt::Leaf::Ident(it) => it.id,\n+                tt::Leaf::Literal(it) => it.span,\n+                tt::Leaf::Punct(it) => it.span,\n+                tt::Leaf::Ident(it) => it.span,\n             };\n             ranges.extend(map.ranges_by_token(id, SyntaxKind::ERROR).map(|range| (range, id)));\n         }"}, {"sha": "4b39a20d86c6ef9563dbef3f5640892b93abdffa", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -46,6 +46,7 @@ use crate::{\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n+    tt,\n     visibility::{RawVisibility, Visibility},\n     AdtId, AstId, AstIdWithPath, ConstLoc, EnumLoc, EnumVariantId, ExternBlockLoc, FunctionId,\n     FunctionLoc, ImplLoc, Intern, ItemContainerId, LocalModuleId, Macro2Id, Macro2Loc,\n@@ -83,7 +84,8 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n                 .enumerate()\n                 .map(|(idx, it)| {\n                     // FIXME: a hacky way to create a Name from string.\n-                    let name = tt::Ident { text: it.name.clone(), id: tt::TokenId::unspecified() };\n+                    let name =\n+                        tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n                     (\n                         name.as_name(),\n                         ProcMacroExpander::new(def_map.krate, base_db::ProcMacroId(idx as u32)),\n@@ -451,7 +453,10 @@ impl DefCollector<'_> {\n                         directive.module_id,\n                         MacroCallKind::Attr {\n                             ast_id: ast_id.ast_id,\n-                            attr_args: Default::default(),\n+                            attr_args: std::sync::Arc::new((\n+                                tt::Subtree::empty(),\n+                                Default::default(),\n+                            )),\n                             invoc_attr_index: attr.id,\n                             is_derive: false,\n                         },\n@@ -1947,7 +1952,8 @@ impl ModCollector<'_, '_> {\n             let name = match attrs.by_key(\"rustc_builtin_macro\").string_value() {\n                 Some(it) => {\n                     // FIXME: a hacky way to create a Name from string.\n-                    name = tt::Ident { text: it.clone(), id: tt::TokenId::unspecified() }.as_name();\n+                    name =\n+                        tt::Ident { text: it.clone(), span: tt::TokenId::unspecified() }.as_name();\n                     &name\n                 }\n                 None => {"}, {"sha": "caad4a1f381721629cccf8245a04b2a564393c3c", "filename": "crates/hir-def/src/nameres/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -1,9 +1,9 @@\n //! Nameres-specific procedural macro data and helpers.\n \n use hir_expand::name::{AsName, Name};\n-use tt::{Leaf, TokenTree};\n \n use crate::attr::Attrs;\n+use crate::tt::{Leaf, TokenTree};\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct ProcMacroDef {"}, {"sha": "5c04f8e8b8f3718033d61ad9ec87039a9cccf750", "filename": "crates/hir-expand/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -8,13 +8,13 @@ use intern::Interned;\n use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n use smallvec::{smallvec, SmallVec};\n use syntax::{ast, match_ast, AstNode, SmolStr, SyntaxNode};\n-use tt::Subtree;\n \n use crate::{\n     db::AstDatabase,\n     hygiene::Hygiene,\n     mod_path::{ModPath, PathKind},\n     name::AsName,\n+    tt::{self, Subtree},\n     InFile,\n };\n \n@@ -117,7 +117,10 @@ impl RawAttrs {\n                 let index = attr.id;\n                 let attrs =\n                     parts.enumerate().take(1 << AttrId::CFG_ATTR_BITS).filter_map(|(idx, attr)| {\n-                        let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n+                        let tree = Subtree {\n+                            delimiter: tt::Delimiter::unspecified(),\n+                            token_trees: attr.to_vec(),\n+                        };\n                         // FIXME hygiene\n                         let hygiene = Hygiene::new_unhygienic();\n                         Attr::from_tt(db, &tree, &hygiene, index.with_cfg_attr(idx))\n@@ -266,7 +269,7 @@ impl Attr {\n     pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n         let args = self.token_tree_value()?;\n \n-        if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n+        if args.delimiter.kind != DelimiterKind::Parenthesis {\n             return None;\n         }\n         let paths = args"}, {"sha": "906ca991d73be7d4129be6d5928f20128bf3c78d", "filename": "crates/hir-expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -1,6 +1,6 @@\n //! Builtin attributes.\n \n-use crate::{db::AstDatabase, name, ExpandResult, MacroCallId, MacroCallKind};\n+use crate::{db::AstDatabase, name, tt, ExpandResult, MacroCallId, MacroCallKind};\n \n macro_rules! register_builtin {\n     ( $(($name:ident, $variant:ident) => $expand:ident),* ) => {\n@@ -97,7 +97,7 @@ fn derive_attr_expand(\n     let loc = db.lookup_intern_macro_call(id);\n     let derives = match &loc.kind {\n         MacroCallKind::Attr { attr_args, is_derive: true, .. } => &attr_args.0,\n-        _ => return ExpandResult::ok(Default::default()),\n+        _ => return ExpandResult::ok(tt::Subtree::empty()),\n     };\n     pseudo_derive_attr_expansion(tt, derives)\n }\n@@ -110,7 +110,7 @@ pub fn pseudo_derive_attr_expansion(\n         tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n             char,\n             spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))\n     };\n "}, {"sha": "060a680542fd9b2ad42c0c52f1352f7beda01fb0", "filename": "crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -3,11 +3,11 @@\n use base_db::{CrateOrigin, LangCrateOrigin};\n use tracing::debug;\n \n+use crate::tt::{self, TokenId};\n use syntax::{\n     ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName},\n     match_ast,\n };\n-use tt::TokenId;\n \n use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId};\n \n@@ -92,7 +92,7 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n     })?;\n     let name_token_id =\n         token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n-    let name_token = tt::Ident { id: name_token_id, text: name.text().into() };\n+    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n     let param_types = params\n         .into_iter()\n         .flat_map(|param_list| param_list.type_or_const_params())\n@@ -101,7 +101,7 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n                 let ty = param\n                     .ty()\n                     .map(|ty| mbe::syntax_node_to_token_tree(ty.syntax()).0)\n-                    .unwrap_or_default();\n+                    .unwrap_or_else(tt::Subtree::empty);\n                 Some(ty)\n             } else {\n                 None\n@@ -114,15 +114,15 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => return ExpandResult::with_err(tt::Subtree::empty(), e),\n     };\n     let (params, args): (Vec<_>, Vec<_>) = info\n         .param_types\n         .into_iter()\n         .enumerate()\n         .map(|(idx, param_ty)| {\n             let ident = tt::Leaf::Ident(tt::Ident {\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n                 text: format!(\"T{idx}\").into(),\n             });\n             let ident_ = ident.clone();"}, {"sha": "9f3fa73d4e60edadac66107ceb7743eacfc816fd", "filename": "crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -9,7 +9,9 @@ use syntax::{\n     SmolStr,\n };\n \n-use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId, MacroCallLoc};\n+use crate::{\n+    db::AstDatabase, name, quote, tt, ExpandError, ExpandResult, MacroCallId, MacroCallLoc,\n+};\n \n macro_rules! register_builtin {\n     ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n@@ -61,7 +63,7 @@ macro_rules! register_builtin {\n     };\n }\n \n-#[derive(Debug, Default)]\n+#[derive(Debug)]\n pub struct ExpandedEager {\n     pub(crate) subtree: tt::Subtree,\n     /// The included file ID of the include macro.\n@@ -116,7 +118,7 @@ register_builtin! {\n }\n \n const DOLLAR_CRATE: tt::Ident =\n-    tt::Ident { text: SmolStr::new_inline(\"$crate\"), id: tt::TokenId::unspecified() };\n+    tt::Ident { text: SmolStr::new_inline(\"$crate\"), span: tt::TokenId::unspecified() };\n \n fn module_path_expand(\n     _db: &dyn AstDatabase,\n@@ -162,7 +164,7 @@ fn stringify_expand(\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let pretty = tt::pretty(&tt.token_trees);\n+    let pretty = ::tt::pretty(&tt.token_trees);\n \n     let expanded = quote! {\n         #pretty\n@@ -194,11 +196,11 @@ fn assert_expand(\n     let expanded = match &*args {\n         [cond, panic_args @ ..] => {\n             let comma = tt::Subtree {\n-                delimiter: None,\n+                delimiter: tt::Delimiter::unspecified(),\n                 token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n                     char: ',',\n                     spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n+                    span: tt::TokenId::unspecified(),\n                 }))],\n             };\n             let cond = cond.clone();\n@@ -247,7 +249,10 @@ fn format_args_expand(\n     let mut args = parse_exprs_with_sep(tt, ',');\n \n     if args.is_empty() {\n-        return ExpandResult::only_err(mbe::ExpandError::NoMatchingRule.into());\n+        return ExpandResult::with_err(\n+            tt::Subtree::empty(),\n+            mbe::ExpandError::NoMatchingRule.into(),\n+        );\n     }\n     for arg in &mut args {\n         // Remove `key =`.\n@@ -282,7 +287,7 @@ fn asm_expand(\n     for tt in tt.token_trees.chunks(2) {\n         match tt {\n             [tt::TokenTree::Leaf(tt::Leaf::Literal(lit))]\n-            | [tt::TokenTree::Leaf(tt::Leaf::Literal(lit)), tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', id: _, spacing: _ }))] =>\n+            | [tt::TokenTree::Leaf(tt::Leaf::Literal(lit)), tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', span: _, spacing: _ }))] =>\n             {\n                 let krate = DOLLAR_CRATE.clone();\n                 literals.push(quote!(#krate::format_args!(#lit);));\n@@ -400,7 +405,7 @@ fn concat_expand(\n         // FIXME: hack on top of a hack: `$e:expr` captures get surrounded in parentheses\n         // to ensure the right parsing order, so skip the parentheses here. Ideally we'd\n         // implement rustc's model. cc https://github.com/rust-lang/rust-analyzer/pull/10623\n-        if let tt::TokenTree::Subtree(tt::Subtree { delimiter: Some(delim), token_trees }) = t {\n+        if let tt::TokenTree::Subtree(tt::Subtree { delimiter: delim, token_trees }) = t {\n             if let [tt] = &**token_trees {\n                 if delim.kind == tt::DelimiterKind::Parenthesis {\n                     t = tt;\n@@ -459,9 +464,7 @@ fn concat_bytes_expand(\n                 }\n             }\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if i % 2 == 1 && punct.char == ',' => (),\n-            tt::TokenTree::Subtree(tree)\n-                if tree.delimiter_kind() == Some(tt::DelimiterKind::Bracket) =>\n-            {\n+            tt::TokenTree::Subtree(tree) if tree.delimiter.kind == tt::DelimiterKind::Bracket => {\n                 if let Err(e) = concat_bytes_expand_subtree(tree, &mut bytes) {\n                     err.get_or_insert(e);\n                     break;\n@@ -473,7 +476,7 @@ fn concat_bytes_expand(\n             }\n         }\n     }\n-    let ident = tt::Ident { text: bytes.join(\", \").into(), id: tt::TokenId::unspecified() };\n+    let ident = tt::Ident { text: bytes.join(\", \").into(), span: tt::TokenId::unspecified() };\n     ExpandResult { value: ExpandedEager::new(quote!([#ident])), err }\n }\n \n@@ -521,7 +524,7 @@ fn concat_idents_expand(\n             }\n         }\n     }\n-    let ident = tt::Ident { text: ident.into(), id: tt::TokenId::unspecified() };\n+    let ident = tt::Ident { text: ident.into(), span: tt::TokenId::unspecified() };\n     ExpandResult { value: ExpandedEager::new(quote!(#ident)), err }\n }\n \n@@ -572,7 +575,10 @@ fn include_expand(\n         Ok((subtree, file_id)) => {\n             ExpandResult::ok(ExpandedEager { subtree, included_file: Some(file_id) })\n         }\n-        Err(e) => ExpandResult::only_err(e),\n+        Err(e) => ExpandResult::with_err(\n+            ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+            e,\n+        ),\n     }\n }\n \n@@ -582,15 +588,18 @@ fn include_bytes_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n     if let Err(e) = parse_string(tt) {\n-        return ExpandResult::only_err(e);\n+        return ExpandResult::with_err(\n+            ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+            e,\n+        );\n     }\n \n     // FIXME: actually read the file here if the user asked for macro expansion\n     let res = tt::Subtree {\n-        delimiter: None,\n+        delimiter: tt::Delimiter::unspecified(),\n         token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Literal(tt::Literal {\n             text: r#\"b\"\"\"#.into(),\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))],\n     };\n     ExpandResult::ok(ExpandedEager::new(res))\n@@ -603,7 +612,12 @@ fn include_str_expand(\n ) -> ExpandResult<ExpandedEager> {\n     let path = match parse_string(tt) {\n         Ok(it) => it,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => {\n+            return ExpandResult::with_err(\n+                ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+                e,\n+            )\n+        }\n     };\n \n     // FIXME: we're not able to read excluded files (which is most of them because\n@@ -635,7 +649,12 @@ fn env_expand(\n ) -> ExpandResult<ExpandedEager> {\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => {\n+            return ExpandResult::with_err(\n+                ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+                e,\n+            )\n+        }\n     };\n \n     let mut err = None;\n@@ -666,7 +685,12 @@ fn option_env_expand(\n ) -> ExpandResult<ExpandedEager> {\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => {\n+            return ExpandResult::with_err(\n+                ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+                e,\n+            )\n+        }\n     };\n \n     let expanded = match get_env_inner(db, arg_id, &key) {"}, {"sha": "76016274f0e85a971373d1ad5962da93d10013b6", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n \n use crate::{\n     ast_id_map::AstIdMap, builtin_attr_macro::pseudo_derive_attr_expansion, fixup,\n-    hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n+    hygiene::HygieneFrame, tt, BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n     ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind,\n     MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n@@ -175,7 +175,7 @@ pub fn expand_speculative(\n             match attr.token_tree() {\n                 Some(token_tree) => {\n                     let (mut tree, map) = syntax_node_to_token_tree(attr.token_tree()?.syntax());\n-                    tree.delimiter = None;\n+                    tree.delimiter = tt::Delimiter::unspecified();\n \n                     let shift = mbe::Shift::new(&tt);\n                     shift.shift_all(&mut tree);\n@@ -210,7 +210,7 @@ pub fn expand_speculative(\n     // Otherwise the expand query will fetch the non speculative attribute args and pass those instead.\n     let mut speculative_expansion = match loc.def.kind {\n         MacroDefKind::ProcMacro(expander, ..) => {\n-            tt.delimiter = None;\n+            tt.delimiter = tt::Delimiter::unspecified();\n             expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n         }\n         MacroDefKind::BuiltInAttr(BuiltinAttrExpander::Derive, _) => {\n@@ -316,9 +316,8 @@ fn macro_arg(\n \n     if loc.def.is_proc_macro() {\n         // proc macros expect their inputs without parentheses, MBEs expect it with them included\n-        tt.delimiter = None;\n+        tt.delimiter = tt::Delimiter::unspecified();\n     }\n-\n     Some(Arc::new((tt, tmap, fixups.undo_info)))\n }\n \n@@ -479,7 +478,10 @@ fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::\n     let macro_arg = match db.macro_arg(id) {\n         Some(it) => it,\n         None => {\n-            return ExpandResult::only_err(ExpandError::Other(\"No arguments for proc-macro\".into()))\n+            return ExpandResult::with_err(\n+                tt::Subtree::empty(),\n+                ExpandError::Other(\"No arguments for proc-macro\".into()),\n+            )\n         }\n     };\n "}, {"sha": "dfab7ec92c763c00aa73fa56fa8d45446cf44eb1", "filename": "crates/hir-expand/src/eager.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Feager.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -108,7 +108,7 @@ pub fn expand_eager_macro(\n         .value\n         .token_tree()\n         .map(|tt| mbe::syntax_node_to_token_tree(tt.syntax()).0)\n-        .unwrap_or_default();\n+        .unwrap_or_else(tt::Subtree::empty);\n \n     let ast_map = db.ast_id_map(macro_call.file_id);\n     let call_id = InFile::new(macro_call.file_id, ast_map.ast_id(&macro_call.value));\n@@ -165,9 +165,9 @@ pub fn expand_eager_macro(\n     }\n }\n \n-fn to_subtree(node: &SyntaxNode) -> tt::Subtree {\n+fn to_subtree(node: &SyntaxNode) -> crate::tt::Subtree {\n     let mut subtree = mbe::syntax_node_to_token_tree(node).0;\n-    subtree.delimiter = None;\n+    subtree.delimiter = crate::tt::Delimiter::unspecified();\n     subtree\n }\n "}, {"sha": "c811d1c66a82daa069d8b466c352da7dc2cd98d7", "filename": "crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -9,7 +9,7 @@ use syntax::{\n     ast::{self, AstNode, HasLoopBody},\n     match_ast, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n };\n-use tt::Subtree;\n+use tt::token_id::Subtree;\n \n /// The result of calculating fixes for a syntax node -- a bunch of changes\n /// (appending to and replacing nodes), the information that is needed to\n@@ -297,9 +297,11 @@ pub(crate) fn reverse_fixups(\n     tt.token_trees = tts\n         .into_iter()\n         .filter(|tt| match tt {\n-            tt::TokenTree::Leaf(leaf) => token_map.synthetic_token_id(leaf.id()) != Some(EMPTY_ID),\n+            tt::TokenTree::Leaf(leaf) => {\n+                token_map.synthetic_token_id(*leaf.span()) != Some(EMPTY_ID)\n+            }\n             tt::TokenTree::Subtree(st) => {\n-                st.delimiter.map_or(true, |d| token_map.synthetic_token_id(d.id) != Some(EMPTY_ID))\n+                token_map.synthetic_token_id(st.delimiter.open) != Some(EMPTY_ID)\n             }\n         })\n         .flat_map(|tt| match tt {\n@@ -308,9 +310,9 @@ pub(crate) fn reverse_fixups(\n                 SmallVec::from_const([tt.into()])\n             }\n             tt::TokenTree::Leaf(leaf) => {\n-                if let Some(id) = token_map.synthetic_token_id(leaf.id()) {\n+                if let Some(id) = token_map.synthetic_token_id(*leaf.span()) {\n                     let original = undo_info.original[id.0 as usize].clone();\n-                    if original.delimiter.is_none() {\n+                    if original.delimiter.kind == tt::DelimiterKind::Invisible {\n                         original.token_trees.into()\n                     } else {\n                         SmallVec::from_const([original.into()])\n@@ -327,6 +329,8 @@ pub(crate) fn reverse_fixups(\n mod tests {\n     use expect_test::{expect, Expect};\n \n+    use crate::tt;\n+\n     use super::reverse_fixups;\n \n     // The following three functions are only meant to check partial structural equivalence of\n@@ -341,7 +345,7 @@ mod tests {\n     }\n \n     fn check_subtree_eq(a: &tt::Subtree, b: &tt::Subtree) -> bool {\n-        a.delimiter.map(|it| it.kind) == b.delimiter.map(|it| it.kind)\n+        a.delimiter.kind == b.delimiter.kind\n             && a.token_trees.len() == b.token_trees.len()\n             && a.token_trees.iter().zip(&b.token_trees).all(|(a, b)| check_tt_eq(a, b))\n     }\n@@ -386,7 +390,7 @@ mod tests {\n         let (original_as_tt, _) = mbe::syntax_node_to_token_tree(&parsed.syntax_node());\n         assert!(\n             check_subtree_eq(&tt, &original_as_tt),\n-            \"different token tree: {tt:?}, {original_as_tt:?}\"\n+            \"different token tree: {tt:?},\\n{original_as_tt:?}\"\n         );\n     }\n "}, {"sha": "2300ee9d089983ec7affd1cd2f97d5b58e914f88", "filename": "crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -128,7 +128,7 @@ struct HygieneInfo {\n     attr_input_or_mac_def_start: Option<InFile<TextSize>>,\n \n     macro_def: Arc<TokenExpander>,\n-    macro_arg: Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupUndoInfo)>,\n+    macro_arg: Arc<(crate::tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupUndoInfo)>,\n     macro_arg_shift: mbe::Shift,\n     exp_map: Arc<mbe::TokenMap>,\n }"}, {"sha": "bc941b541724271b88c90f551d39ba42396bb50b", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -22,6 +22,8 @@ mod fixup;\n \n pub use mbe::{Origin, ValueResult};\n \n+use ::tt::token_id as tt;\n+\n use std::{fmt, hash::Hash, iter, sync::Arc};\n \n use base_db::{"}, {"sha": "b51547250134587a0a4e49ea79c5542bac09cf3c", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -191,7 +191,7 @@ impl AsName for ast::NameOrNameRef {\n     }\n }\n \n-impl AsName for tt::Ident {\n+impl<Span> AsName for tt::Ident<Span> {\n     fn as_name(&self) -> Name {\n         Name::resolve(&self.text)\n     }"}, {"sha": "3f4d2540c099a9f66ffae8fafccb176ccc8ce89a", "filename": "crates/hir-expand/src/proc_macro.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fproc_macro.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -3,7 +3,7 @@\n use base_db::{CrateId, ProcMacroExpansionError, ProcMacroId, ProcMacroKind};\n use stdx::never;\n \n-use crate::{db::AstDatabase, ExpandError, ExpandResult};\n+use crate::{db::AstDatabase, tt, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n@@ -39,7 +39,10 @@ impl ProcMacroExpander {\n                     Ok(proc_macros) => proc_macros,\n                     Err(_) => {\n                         never!(\"Non-dummy expander even though there are no proc macros\");\n-                        return ExpandResult::only_err(ExpandError::Other(\"Internal error\".into()));\n+                        return ExpandResult::with_err(\n+                            tt::Subtree::empty(),\n+                            ExpandError::Other(\"Internal error\".into()),\n+                        );\n                     }\n                 };\n                 let proc_macro = match proc_macros.get(id.0 as usize) {\n@@ -50,7 +53,10 @@ impl ProcMacroExpander {\n                             proc_macros.len(),\n                             id.0\n                         );\n-                        return ExpandResult::only_err(ExpandError::Other(\"Internal error\".into()));\n+                        return ExpandResult::with_err(\n+                            tt::Subtree::empty(),\n+                            ExpandError::Other(\"Internal error\".into()),\n+                        );\n                     }\n                 };\n \n@@ -69,13 +75,17 @@ impl ProcMacroExpander {\n                             }\n                         }\n                         ProcMacroExpansionError::System(text)\n-                        | ProcMacroExpansionError::Panic(text) => {\n-                            ExpandResult::only_err(ExpandError::Other(text.into()))\n-                        }\n+                        | ProcMacroExpansionError::Panic(text) => ExpandResult::with_err(\n+                            tt::Subtree::empty(),\n+                            ExpandError::Other(text.into()),\n+                        ),\n                     },\n                 }\n             }\n-            None => ExpandResult::only_err(ExpandError::UnresolvedProcMacro(self.krate)),\n+            None => ExpandResult::with_err(\n+                tt::Subtree::empty(),\n+                ExpandError::UnresolvedProcMacro(self.krate),\n+            ),\n         }\n     }\n }"}, {"sha": "63586f9daf0695b4a5538666b075ab96bbcd34f6", "filename": "crates/hir-expand/src/quote.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fhir-expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fquote.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -9,17 +9,18 @@\n #[macro_export]\n macro_rules! __quote {\n     () => {\n-        Vec::<tt::TokenTree>::new()\n+        Vec::<crate::tt::TokenTree>::new()\n     };\n \n     ( @SUBTREE $delim:ident $($tt:tt)* ) => {\n         {\n             let children = $crate::__quote!($($tt)*);\n-            tt::Subtree {\n-                delimiter: Some(tt::Delimiter {\n-                    kind: tt::DelimiterKind::$delim,\n-                    id: tt::TokenId::unspecified(),\n-                }),\n+            crate::tt::Subtree {\n+                delimiter: crate::tt::Delimiter {\n+                    kind: crate::tt::DelimiterKind::$delim,\n+                    open: crate::tt::TokenId::unspecified(),\n+                    close: crate::tt::TokenId::unspecified(),\n+                },\n                 token_trees: $crate::quote::IntoTt::to_tokens(children),\n             }\n         }\n@@ -28,10 +29,10 @@ macro_rules! __quote {\n     ( @PUNCT $first:literal ) => {\n         {\n             vec![\n-                tt::Leaf::Punct(tt::Punct {\n+                crate::tt::Leaf::Punct(crate::tt::Punct {\n                     char: $first,\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n+                    spacing: crate::tt::Spacing::Alone,\n+                    span: crate::tt::TokenId::unspecified(),\n                 }).into()\n             ]\n         }\n@@ -40,15 +41,15 @@ macro_rules! __quote {\n     ( @PUNCT $first:literal, $sec:literal ) => {\n         {\n             vec![\n-                tt::Leaf::Punct(tt::Punct {\n+                crate::tt::Leaf::Punct(crate::tt::Punct {\n                     char: $first,\n-                    spacing: tt::Spacing::Joint,\n-                    id: tt::TokenId::unspecified(),\n+                    spacing: crate::tt::Spacing::Joint,\n+                    span: crate::tt::TokenId::unspecified(),\n                 }).into(),\n-                tt::Leaf::Punct(tt::Punct {\n+                crate::tt::Leaf::Punct(crate::tt::Punct {\n                     char: $sec,\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n+                    spacing: crate::tt::Spacing::Alone,\n+                    span: crate::tt::TokenId::unspecified(),\n                 }).into()\n             ]\n         }\n@@ -67,7 +68,7 @@ macro_rules! __quote {\n \n     ( ## $first:ident $($tail:tt)* ) => {\n         {\n-            let mut tokens = $first.into_iter().map($crate::quote::ToTokenTree::to_token).collect::<Vec<tt::TokenTree>>();\n+            let mut tokens = $first.into_iter().map($crate::quote::ToTokenTree::to_token).collect::<Vec<crate::tt::TokenTree>>();\n             let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n             tokens.append(&mut tail_tokens);\n             tokens\n@@ -86,9 +87,9 @@ macro_rules! __quote {\n     // Ident\n     ( $tt:ident ) => {\n         vec![ {\n-            tt::Leaf::Ident(tt::Ident {\n+            crate::tt::Leaf::Ident(crate::tt::Ident {\n                 text: stringify!($tt).into(),\n-                id: tt::TokenId::unspecified(),\n+                span: crate::tt::TokenId::unspecified(),\n             }).into()\n         }]\n     };\n@@ -127,42 +128,42 @@ macro_rules! quote {\n }\n \n pub(crate) trait IntoTt {\n-    fn to_subtree(self) -> tt::Subtree;\n-    fn to_tokens(self) -> Vec<tt::TokenTree>;\n+    fn to_subtree(self) -> crate::tt::Subtree;\n+    fn to_tokens(self) -> Vec<crate::tt::TokenTree>;\n }\n \n-impl IntoTt for Vec<tt::TokenTree> {\n-    fn to_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: None, token_trees: self }\n+impl IntoTt for Vec<crate::tt::TokenTree> {\n+    fn to_subtree(self) -> crate::tt::Subtree {\n+        crate::tt::Subtree { delimiter: crate::tt::Delimiter::unspecified(), token_trees: self }\n     }\n \n-    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+    fn to_tokens(self) -> Vec<crate::tt::TokenTree> {\n         self\n     }\n }\n \n-impl IntoTt for tt::Subtree {\n-    fn to_subtree(self) -> tt::Subtree {\n+impl IntoTt for crate::tt::Subtree {\n+    fn to_subtree(self) -> crate::tt::Subtree {\n         self\n     }\n \n-    fn to_tokens(self) -> Vec<tt::TokenTree> {\n-        vec![tt::TokenTree::Subtree(self)]\n+    fn to_tokens(self) -> Vec<crate::tt::TokenTree> {\n+        vec![crate::tt::TokenTree::Subtree(self)]\n     }\n }\n \n pub(crate) trait ToTokenTree {\n-    fn to_token(self) -> tt::TokenTree;\n+    fn to_token(self) -> crate::tt::TokenTree;\n }\n \n-impl ToTokenTree for tt::TokenTree {\n-    fn to_token(self) -> tt::TokenTree {\n+impl ToTokenTree for crate::tt::TokenTree {\n+    fn to_token(self) -> crate::tt::TokenTree {\n         self\n     }\n }\n \n-impl ToTokenTree for tt::Subtree {\n-    fn to_token(self) -> tt::TokenTree {\n+impl ToTokenTree for crate::tt::Subtree {\n+    fn to_token(self) -> crate::tt::TokenTree {\n         self.into()\n     }\n }\n@@ -171,15 +172,15 @@ macro_rules! impl_to_to_tokentrees {\n     ($($ty:ty => $this:ident $im:block);*) => {\n         $(\n             impl ToTokenTree for $ty {\n-                fn to_token($this) -> tt::TokenTree {\n-                    let leaf: tt::Leaf = $im.into();\n+                fn to_token($this) -> crate::tt::TokenTree {\n+                    let leaf: crate::tt::Leaf = $im.into();\n                     leaf.into()\n                 }\n             }\n \n             impl ToTokenTree for &$ty {\n-                fn to_token($this) -> tt::TokenTree {\n-                    let leaf: tt::Leaf = $im.clone().into();\n+                fn to_token($this) -> crate::tt::TokenTree {\n+                    let leaf: crate::tt::Leaf = $im.clone().into();\n                     leaf.into()\n                 }\n             }\n@@ -188,16 +189,16 @@ macro_rules! impl_to_to_tokentrees {\n }\n \n impl_to_to_tokentrees! {\n-    u32 => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    usize => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    i32 => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    bool => self { tt::Ident{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    tt::Leaf => self { self };\n-    tt::Literal => self { self };\n-    tt::Ident => self { self };\n-    tt::Punct => self { self };\n-    &str => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), id: tt::TokenId::unspecified()}};\n-    String => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), id: tt::TokenId::unspecified()}}\n+    u32 => self { crate::tt::Literal{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    usize => self { crate::tt::Literal{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    i32 => self { crate::tt::Literal{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    bool => self { crate::tt::Ident{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    crate::tt::Leaf => self { self };\n+    crate::tt::Literal => self { self };\n+    crate::tt::Ident => self { self };\n+    crate::tt::Punct => self { self };\n+    &str => self { crate::tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), span: crate::tt::TokenId::unspecified()}};\n+    String => self { crate::tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), span: crate::tt::TokenId::unspecified()}}\n }\n \n #[cfg(test)]\n@@ -223,8 +224,8 @@ mod tests {\n         assert_eq!(quote!(#s).to_string(), \"\\\"hello\\\"\");\n     }\n \n-    fn mk_ident(name: &str) -> tt::Ident {\n-        tt::Ident { text: name.into(), id: tt::TokenId::unspecified() }\n+    fn mk_ident(name: &str) -> crate::tt::Ident {\n+        crate::tt::Ident { text: name.into(), span: crate::tt::TokenId::unspecified() }\n     }\n \n     #[test]\n@@ -234,7 +235,7 @@ mod tests {\n         let quoted = quote!(#a);\n         assert_eq!(quoted.to_string(), \"hello\");\n         let t = format!(\"{quoted:?}\");\n-        assert_eq!(t, \"SUBTREE $\\n  IDENT   hello 4294967295\");\n+        assert_eq!(t, \"SUBTREE $$ 4294967295 4294967295\\n  IDENT   hello 4294967295\");\n     }\n \n     #[test]\n@@ -263,11 +264,12 @@ mod tests {\n         let fields = [mk_ident(\"name\"), mk_ident(\"id\")];\n         let fields = fields.iter().flat_map(|it| quote!(#it: self.#it.clone(), ).token_trees);\n \n-        let list = tt::Subtree {\n-            delimiter: Some(tt::Delimiter {\n-                kind: tt::DelimiterKind::Brace,\n-                id: tt::TokenId::unspecified(),\n-            }),\n+        let list = crate::tt::Subtree {\n+            delimiter: crate::tt::Delimiter {\n+                kind: crate::tt::DelimiterKind::Brace,\n+                open: crate::tt::TokenId::unspecified(),\n+                close: crate::tt::TokenId::unspecified(),\n+            },\n             token_trees: fields.collect(),\n         };\n "}, {"sha": "894355fcbc9b32c0cde5a7c4d5e858dea9b1a8ad", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -9,7 +9,7 @@ use test_utils::{bench, bench_fixture, skip_slow_tests};\n \n use crate::{\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n-    syntax_node_to_token_tree, DeclarativeMacro,\n+    syntax_node_to_token_tree, tt, DeclarativeMacro,\n };\n \n #[test]\n@@ -91,7 +91,14 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n                 // So we just skip any error cases and try again\n                 let mut try_cnt = 0;\n                 loop {\n-                    let mut subtree = tt::Subtree::default();\n+                    let mut subtree = tt::Subtree {\n+                        delimiter: tt::Delimiter {\n+                            open: tt::TokenId::UNSPECIFIED,\n+                            close: tt::TokenId::UNSPECIFIED,\n+                            kind: tt::DelimiterKind::Invisible,\n+                        },\n+                        token_trees: vec![],\n+                    };\n                     for op in rule.lhs.iter() {\n                         collect_from_op(op, &mut subtree, &mut seed);\n                     }\n@@ -196,20 +203,23 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n             *seed\n         }\n         fn make_ident(ident: &str) -> tt::TokenTree {\n-            tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), text: SmolStr::new(ident) })\n-                .into()\n+            tt::Leaf::Ident(tt::Ident {\n+                span: tt::TokenId::unspecified(),\n+                text: SmolStr::new(ident),\n+            })\n+            .into()\n         }\n         fn make_punct(char: char) -> tt::TokenTree {\n             tt::Leaf::Punct(tt::Punct {\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n                 char,\n                 spacing: tt::Spacing::Alone,\n             })\n             .into()\n         }\n         fn make_literal(lit: &str) -> tt::TokenTree {\n             tt::Leaf::Literal(tt::Literal {\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n                 text: SmolStr::new(lit),\n             })\n             .into()\n@@ -219,7 +229,11 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n             token_trees: Option<Vec<tt::TokenTree>>,\n         ) -> tt::TokenTree {\n             tt::Subtree {\n-                delimiter: Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind }),\n+                delimiter: tt::Delimiter {\n+                    open: tt::TokenId::unspecified(),\n+                    close: tt::TokenId::unspecified(),\n+                    kind,\n+                },\n                 token_trees: token_trees.unwrap_or_default(),\n             }\n             .into()"}, {"sha": "7537dc32261491485a39ea2ccba980bee9784729", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -8,7 +8,7 @@ mod transcriber;\n use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n-use crate::{parser::MetaVarKind, ExpandError, ExpandResult};\n+use crate::{parser::MetaVarKind, tt, ExpandError, ExpandResult};\n \n pub(crate) fn expand_rules(\n     rules: &[crate::Rule],\n@@ -45,7 +45,10 @@ pub(crate) fn expand_rules(\n             transcriber::transcribe(&rule.rhs, &match_.bindings);\n         ExpandResult { value, err: match_.err.or(transcribe_err) }\n     } else {\n-        ExpandResult::only_err(ExpandError::NoMatchingRule)\n+        ExpandResult::with_err(\n+            tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] },\n+            ExpandError::NoMatchingRule,\n+        )\n     }\n }\n "}, {"sha": "f4ea9e5c8165807e6e5a3dabee76413c7bb3ce27", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -67,6 +67,7 @@ use syntax::SmolStr;\n use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n+    tt,\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate, ValueResult,\n };\n@@ -75,7 +76,8 @@ impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n         // FIXME: Do we have a better way to represent an empty token ?\n         // Insert an empty subtree for empty token\n-        let tt = tt::Subtree::default().into();\n+        let tt =\n+            tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] }.into();\n         self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n     }\n \n@@ -462,9 +464,9 @@ fn match_loop_inner<'t>(\n             }\n             OpDelimited::Op(Op::Subtree { tokens, delimiter }) => {\n                 if let Ok(subtree) = src.clone().expect_subtree() {\n-                    if subtree.delimiter_kind() == delimiter.map(|it| it.kind) {\n+                    if subtree.delimiter.kind == delimiter.kind {\n                         item.stack.push(item.dot);\n-                        item.dot = tokens.iter_delimited(delimiter.as_ref());\n+                        item.dot = tokens.iter_delimited(Some(delimiter));\n                         cur_items.push(item);\n                     }\n                 }\n@@ -663,8 +665,8 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n             }\n             res.add_err(ExpandError::LeftoverTokens);\n \n-            if let Some(error_reover_item) = error_recover_item {\n-                res.bindings = bindings_builder.build(&error_reover_item);\n+            if let Some(error_recover_item) = error_recover_item {\n+                res.bindings = bindings_builder.build(&error_recover_item);\n             }\n             return res;\n         }\n@@ -782,7 +784,7 @@ fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Opt\n                             match neg {\n                                 None => lit.into(),\n                                 Some(neg) => tt::TokenTree::Subtree(tt::Subtree {\n-                                    delimiter: None,\n+                                    delimiter: tt::Delimiter::unspecified(),\n                                     token_trees: vec![neg, lit.into()],\n                                 }),\n                             }\n@@ -810,7 +812,11 @@ fn collect_vars(collector_fun: &mut impl FnMut(SmolStr), pattern: &MetaTemplate)\n }\n impl MetaTemplate {\n     fn iter_delimited<'a>(&'a self, delimited: Option<&'a tt::Delimiter>) -> OpDelimitedIter<'a> {\n-        OpDelimitedIter { inner: &self.0, idx: 0, delimited }\n+        OpDelimitedIter {\n+            inner: &self.0,\n+            idx: 0,\n+            delimited: delimited.unwrap_or(&tt::Delimiter::UNSPECIFIED),\n+        }\n     }\n }\n \n@@ -824,20 +830,21 @@ enum OpDelimited<'a> {\n #[derive(Debug, Clone, Copy)]\n struct OpDelimitedIter<'a> {\n     inner: &'a [Op],\n-    delimited: Option<&'a tt::Delimiter>,\n+    delimited: &'a tt::Delimiter,\n     idx: usize,\n }\n \n impl<'a> OpDelimitedIter<'a> {\n     fn is_eof(&self) -> bool {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        let len = self.inner.len()\n+            + if self.delimited.kind != tt::DelimiterKind::Invisible { 2 } else { 0 };\n         self.idx >= len\n     }\n \n     fn peek(&self) -> Option<OpDelimited<'a>> {\n-        match self.delimited {\n-            None => self.inner.get(self.idx).map(OpDelimited::Op),\n-            Some(_) => match self.idx {\n+        match self.delimited.kind {\n+            tt::DelimiterKind::Invisible => self.inner.get(self.idx).map(OpDelimited::Op),\n+            _ => match self.idx {\n                 0 => Some(OpDelimited::Open),\n                 i if i == self.inner.len() + 1 => Some(OpDelimited::Close),\n                 i => self.inner.get(i - 1).map(OpDelimited::Op),\n@@ -860,7 +867,8 @@ impl<'a> Iterator for OpDelimitedIter<'a> {\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        let len = self.inner.len()\n+            + if self.delimited.kind != tt::DelimiterKind::Invisible { 2 } else { 0 };\n         let remain = len.saturating_sub(self.idx);\n         (remain, Some(remain))\n     }\n@@ -904,7 +912,10 @@ impl<'a> TtIter<'a> {\n             } else {\n                 let puncts = self.expect_glued_punct()?;\n                 let token_trees = puncts.into_iter().map(|p| tt::Leaf::Punct(p).into()).collect();\n-                Ok(tt::TokenTree::Subtree(tt::Subtree { delimiter: None, token_trees }))\n+                Ok(tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: tt::Delimiter::unspecified(),\n+                    token_trees,\n+                }))\n             }\n         } else {\n             self.next().ok_or(()).cloned()\n@@ -919,7 +930,7 @@ impl<'a> TtIter<'a> {\n         let ident = self.expect_ident_or_underscore()?;\n \n         Ok(tt::Subtree {\n-            delimiter: None,\n+            delimiter: tt::Delimiter::unspecified(),\n             token_trees: vec![\n                 tt::Leaf::Punct(*punct).into(),\n                 tt::Leaf::Ident(ident.clone()).into(),"}, {"sha": "dffb40d4bc8867de5d5b92b40034395046bb7caa", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -2,11 +2,11 @@\n //! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n \n use syntax::SmolStr;\n-use tt::{Delimiter, Subtree};\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n+    tt::{self, Delimiter},\n     ExpandError, ExpandResult, MetaTemplate,\n };\n \n@@ -44,22 +44,23 @@ impl Bindings {\n             Binding::Missing(it) => Ok(match it {\n                 MetaVarKind::Stmt => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                         char: ';',\n                         spacing: tt::Spacing::Alone,\n                     })))\n                 }\n                 MetaVarKind::Block => Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: Some(tt::Delimiter {\n-                        id: tt::TokenId::unspecified(),\n+                    delimiter: tt::Delimiter {\n+                        open: tt::TokenId::unspecified(),\n+                        close: tt::TokenId::unspecified(),\n                         kind: tt::DelimiterKind::Brace,\n-                    }),\n+                    },\n                     token_trees: vec![],\n                 })),\n                 // FIXME: Meta and Item should get proper defaults\n                 MetaVarKind::Meta | MetaVarKind::Item | MetaVarKind::Tt | MetaVarKind::Vis => {\n                     Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n-                        delimiter: None,\n+                        delimiter: tt::Delimiter::UNSPECIFIED,\n                         token_trees: vec![],\n                     }))\n                 }\n@@ -71,19 +72,19 @@ impl Bindings {\n                 | MetaVarKind::Ident => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                         text: SmolStr::new_inline(\"missing\"),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })))\n                 }\n                 MetaVarKind::Lifetime => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                         text: SmolStr::new_inline(\"'missing\"),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })))\n                 }\n                 MetaVarKind::Literal => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                         text: SmolStr::new_inline(\"\\\"missing\\\"\"),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })))\n                 }\n             }),\n@@ -143,7 +144,7 @@ fn expand_subtree(\n             }\n             Op::Subtree { tokens, delimiter } => {\n                 let ExpandResult { value: tt, err: e } =\n-                    expand_subtree(ctx, tokens, *delimiter, arena);\n+                    expand_subtree(ctx, tokens, Some(*delimiter), arena);\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n@@ -170,7 +171,7 @@ fn expand_subtree(\n                 arena.push(\n                     tt::Leaf::Literal(tt::Literal {\n                         text: index.to_string().into(),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })\n                     .into(),\n                 );\n@@ -179,7 +180,13 @@ fn expand_subtree(\n     }\n     // drain the elements added in this instance of expand_subtree\n     let tts = arena.drain(start_elements..).collect();\n-    ExpandResult { value: tt::Subtree { delimiter, token_trees: tts }, err }\n+    ExpandResult {\n+        value: tt::Subtree {\n+            delimiter: delimiter.unwrap_or_else(tt::Delimiter::unspecified),\n+            token_trees: tts,\n+        },\n+        err,\n+    }\n }\n \n fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n@@ -201,17 +208,24 @@ fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandRe\n         // ```\n         // We just treat it a normal tokens\n         let tt = tt::Subtree {\n-            delimiter: None,\n+            delimiter: tt::Delimiter::UNSPECIFIED,\n             token_trees: vec![\n-                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone, id }).into(),\n-                tt::Leaf::from(tt::Ident { text: v.clone(), id }).into(),\n+                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone, span: id })\n+                    .into(),\n+                tt::Leaf::from(tt::Ident { text: v.clone(), span: id }).into(),\n             ],\n         }\n         .into();\n         ExpandResult::ok(Fragment::Tokens(tt))\n     } else {\n         ctx.bindings.get(v, &mut ctx.nesting).map_or_else(\n-            |e| ExpandResult { value: Fragment::Tokens(tt::TokenTree::empty()), err: Some(e) },\n+            |e| ExpandResult {\n+                value: Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: tt::Delimiter::unspecified(),\n+                    token_trees: vec![],\n+                })),\n+                err: Some(e),\n+            },\n             ExpandResult::ok,\n         )\n     }\n@@ -249,7 +263,10 @@ fn expand_repeat(\n                 ctx\n             );\n             return ExpandResult {\n-                value: Fragment::Tokens(Subtree::default().into()),\n+                value: Fragment::Tokens(\n+                    tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] }\n+                        .into(),\n+                ),\n                 err: Some(ExpandError::LimitExceeded),\n             };\n         }\n@@ -258,7 +275,7 @@ fn expand_repeat(\n             continue;\n         }\n \n-        t.delimiter = None;\n+        t.delimiter = tt::Delimiter::unspecified();\n         push_subtree(&mut buf, t);\n \n         if let Some(sep) = separator {\n@@ -292,7 +309,7 @@ fn expand_repeat(\n \n     // Check if it is a single token subtree without any delimiter\n     // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n-    let tt = tt::Subtree { delimiter: None, token_trees: buf }.into();\n+    let tt = tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: buf }.into();\n \n     if RepeatKind::OneOrMore == kind && counter == 0 {\n         return ExpandResult {\n@@ -307,11 +324,12 @@ fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n     match fragment {\n         Fragment::Tokens(tt::TokenTree::Subtree(tt)) => push_subtree(buf, tt),\n         Fragment::Expr(tt::TokenTree::Subtree(mut tt)) => {\n-            if tt.delimiter.is_none() {\n-                tt.delimiter = Some(tt::Delimiter {\n-                    id: tt::TokenId::unspecified(),\n+            if tt.delimiter.kind == tt::DelimiterKind::Invisible {\n+                tt.delimiter = tt::Delimiter {\n+                    open: tt::TokenId::UNSPECIFIED,\n+                    close: tt::TokenId::UNSPECIFIED,\n                     kind: tt::DelimiterKind::Parenthesis,\n-                })\n+                };\n             }\n             buf.push(tt.into())\n         }\n@@ -320,8 +338,8 @@ fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n }\n \n fn push_subtree(buf: &mut Vec<tt::TokenTree>, tt: tt::Subtree) {\n-    match tt.delimiter {\n-        None => buf.extend(tt.token_trees),\n-        Some(_) => buf.push(tt.into()),\n+    match tt.delimiter.kind {\n+        tt::DelimiterKind::Invisible => buf.extend(tt.token_trees),\n+        _ => buf.push(tt.into()),\n     }\n }"}, {"sha": "ac107a0d6d6d1a723b12afcc67f239c477f1e067", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -18,6 +18,8 @@ mod to_parser_input;\n mod benchmark;\n mod token_map;\n \n+use ::tt::token_id as tt;\n+\n use std::fmt;\n \n use crate::{\n@@ -26,8 +28,8 @@ use crate::{\n };\n \n // FIXME: we probably should re-think  `token_tree_to_syntax_node` interfaces\n+pub use self::tt::{Delimiter, DelimiterKind, Punct};\n pub use ::parser::TopEntryPoint;\n-pub use tt::{Delimiter, DelimiterKind, Punct};\n \n pub use crate::{\n     syntax_bridge::{\n@@ -125,24 +127,26 @@ impl Shift {\n \n         // Find the max token id inside a subtree\n         fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n-            let filter = |tt: &_| match tt {\n-                tt::TokenTree::Subtree(subtree) => {\n-                    let tree_id = max_id(subtree);\n-                    match subtree.delimiter {\n-                        Some(it) if it.id != tt::TokenId::unspecified() => {\n-                            Some(tree_id.map_or(it.id.0, |t| t.max(it.id.0)))\n+            let filter =\n+                |tt: &_| match tt {\n+                    tt::TokenTree::Subtree(subtree) => {\n+                        let tree_id = max_id(subtree);\n+                        if subtree.delimiter.open != tt::TokenId::unspecified() {\n+                            Some(tree_id.map_or(subtree.delimiter.open.0, |t| {\n+                                t.max(subtree.delimiter.open.0)\n+                            }))\n+                        } else {\n+                            tree_id\n                         }\n-                        _ => tree_id,\n                     }\n-                }\n-                tt::TokenTree::Leaf(leaf) => {\n-                    let &(tt::Leaf::Ident(tt::Ident { id, .. })\n-                    | tt::Leaf::Punct(tt::Punct { id, .. })\n-                    | tt::Leaf::Literal(tt::Literal { id, .. })) = leaf;\n+                    tt::TokenTree::Leaf(leaf) => {\n+                        let &(tt::Leaf::Ident(tt::Ident { span, .. })\n+                        | tt::Leaf::Punct(tt::Punct { span, .. })\n+                        | tt::Leaf::Literal(tt::Literal { span, .. })) = leaf;\n \n-                    (id != tt::TokenId::unspecified()).then_some(id.0)\n-                }\n-            };\n+                        (span != tt::TokenId::unspecified()).then_some(span.0)\n+                    }\n+                };\n             subtree.token_trees.iter().filter_map(filter).max()\n         }\n     }\n@@ -152,14 +156,13 @@ impl Shift {\n         for t in &mut tt.token_trees {\n             match t {\n                 tt::TokenTree::Leaf(\n-                    tt::Leaf::Ident(tt::Ident { id, .. })\n-                    | tt::Leaf::Punct(tt::Punct { id, .. })\n-                    | tt::Leaf::Literal(tt::Literal { id, .. }),\n-                ) => *id = self.shift(*id),\n+                    tt::Leaf::Ident(tt::Ident { span, .. })\n+                    | tt::Leaf::Punct(tt::Punct { span, .. })\n+                    | tt::Leaf::Literal(tt::Literal { span, .. }),\n+                ) => *span = self.shift(*span),\n                 tt::TokenTree::Subtree(tt) => {\n-                    if let Some(it) = tt.delimiter.as_mut() {\n-                        it.id = self.shift(it.id);\n-                    }\n+                    tt.delimiter.open = self.shift(tt.delimiter.open);\n+                    tt.delimiter.close = self.shift(tt.delimiter.close);\n                     self.shift_all(tt)\n                 }\n             }\n@@ -216,7 +219,7 @@ impl DeclarativeMacro {\n         let mut src = TtIter::new(tt);\n         let mut rules = Vec::new();\n \n-        if Some(tt::DelimiterKind::Brace) == tt.delimiter_kind() {\n+        if tt::DelimiterKind::Brace == tt.delimiter.kind {\n             cov_mark::hit!(parse_macro_def_rules);\n             while src.len() > 0 {\n                 let rule = Rule::parse(&mut src, true)?;\n@@ -325,6 +328,10 @@ impl<T, E> ValueResult<T, E> {\n         Self { value, err: None }\n     }\n \n+    pub fn with_err(value: T, err: E) -> Self {\n+        Self { value, err: Some(err) }\n+    }\n+\n     pub fn only_err(err: E) -> Self\n     where\n         T: Default,"}, {"sha": "fd3d64719ac9a38ab329f762643a8d894b164608", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -4,7 +4,7 @@\n use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n-use crate::{tt_iter::TtIter, ParseError};\n+use crate::{tt, tt_iter::TtIter, ParseError};\n \n /// Consider\n ///\n@@ -54,7 +54,7 @@ pub(crate) enum Op {\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n-    Subtree { tokens: MetaTemplate, delimiter: Option<tt::Delimiter> },\n+    Subtree { tokens: MetaTemplate, delimiter: tt::Delimiter },\n     Literal(tt::Literal),\n     Punct(SmallVec<[tt::Punct; 3]>),\n     Ident(tt::Ident),\n@@ -130,13 +130,13 @@ fn next_op(\n                 Some(it) => it,\n             };\n             match second {\n-                tt::TokenTree::Subtree(subtree) => match subtree.delimiter_kind() {\n-                    Some(tt::DelimiterKind::Parenthesis) => {\n+                tt::TokenTree::Subtree(subtree) => match subtree.delimiter.kind {\n+                    tt::DelimiterKind::Parenthesis => {\n                         let (separator, kind) = parse_repeat(src)?;\n                         let tokens = MetaTemplate::parse(subtree, mode)?;\n                         Op::Repeat { tokens, separator, kind }\n                     }\n-                    Some(tt::DelimiterKind::Brace) => match mode {\n+                    tt::DelimiterKind::Brace => match mode {\n                         Mode::Template => {\n                             parse_metavar_expr(&mut TtIter::new(subtree)).map_err(|()| {\n                                 ParseError::unexpected(\"invalid metavariable expression\")\n@@ -157,18 +157,18 @@ fn next_op(\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n                     tt::Leaf::Ident(ident) if ident.text == \"crate\" => {\n                         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-                        Op::Ident(tt::Ident { text: \"$crate\".into(), id: ident.id })\n+                        Op::Ident(tt::Ident { text: \"$crate\".into(), span: ident.span })\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let kind = eat_fragment_kind(src, mode)?;\n                         let name = ident.text.clone();\n-                        let id = ident.id;\n+                        let id = ident.span;\n                         Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Literal(lit) if is_boolean_literal(lit) => {\n                         let kind = eat_fragment_kind(src, mode)?;\n                         let name = lit.text.clone();\n-                        let id = lit.id;\n+                        let id = lit.span;\n                         Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Punct(punct @ tt::Punct { char: '$', .. }) => match mode {\n@@ -284,7 +284,7 @@ fn parse_metavar_expr(src: &mut TtIter<'_>) -> Result<Op, ()> {\n     let func = src.expect_ident()?;\n     let args = src.expect_subtree()?;\n \n-    if args.delimiter_kind() != Some(tt::DelimiterKind::Parenthesis) {\n+    if args.delimiter.kind != tt::DelimiterKind::Parenthesis {\n         return Err(());\n     }\n \n@@ -293,7 +293,7 @@ fn parse_metavar_expr(src: &mut TtIter<'_>) -> Result<Op, ()> {\n     let op = match &*func.text {\n         \"ignore\" => {\n             let ident = args.expect_ident()?;\n-            Op::Ignore { name: ident.text.clone(), id: ident.id }\n+            Op::Ignore { name: ident.text.clone(), id: ident.span }\n         }\n         \"index\" => {\n             let depth = if args.len() == 0 { 0 } else { args.expect_u32_literal()? };"}, {"sha": "fbf6b53006ad1b05e566aad437a63ff6c1d80df9", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 79, "deletions": 47, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -8,9 +8,16 @@ use syntax::{\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, SyntaxTreeBuilder, TextRange, TextSize, WalkEvent, T,\n };\n-use tt::buffer::{Cursor, TokenBuffer};\n \n-use crate::{to_parser_input::to_parser_input, tt_iter::TtIter, TokenMap};\n+use crate::{\n+    to_parser_input::to_parser_input,\n+    tt::{\n+        self,\n+        buffer::{Cursor, TokenBuffer},\n+    },\n+    tt_iter::TtIter,\n+    TokenMap,\n+};\n \n #[cfg(test)]\n mod tests;\n@@ -74,9 +81,10 @@ pub fn token_tree_to_syntax_node(\n     entry_point: parser::TopEntryPoint,\n ) -> (Parse<SyntaxNode>, TokenMap) {\n     let buffer = match tt {\n-        tt::Subtree { delimiter: None, token_trees } => {\n-            TokenBuffer::from_tokens(token_trees.as_slice())\n-        }\n+        tt::Subtree {\n+            delimiter: tt::Delimiter { kind: tt::DelimiterKind::Invisible, .. },\n+            token_trees,\n+        } => TokenBuffer::from_tokens(token_trees.as_slice()),\n         _ => TokenBuffer::from_subtree(tt),\n     };\n     let parser_input = to_parser_input(&buffer);\n@@ -92,8 +100,7 @@ pub fn token_tree_to_syntax_node(\n             parser::Step::Error { msg } => tree_sink.error(msg.to_string()),\n         }\n     }\n-    let (parse, range_map) = tree_sink.finish();\n-    (parse, range_map)\n+    tree_sink.finish()\n }\n \n /// Convert a string to a `TokenTree`\n@@ -132,7 +139,7 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n         res.push(match expanded.value {\n             None => break,\n             Some(tt @ tt::TokenTree::Leaf(_)) => {\n-                tt::Subtree { delimiter: None, token_trees: vec![tt] }\n+                tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![tt] }\n             }\n             Some(tt::TokenTree::Subtree(tt)) => tt,\n         });\n@@ -145,7 +152,10 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n     }\n \n     if iter.peek_n(0).is_some() {\n-        res.push(tt::Subtree { delimiter: None, token_trees: iter.cloned().collect() });\n+        res.push(tt::Subtree {\n+            delimiter: tt::Delimiter::unspecified(),\n+            token_trees: iter.cloned().collect(),\n+        });\n     }\n \n     res\n@@ -159,7 +169,7 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n     }\n \n     let entry = StackEntry {\n-        subtree: tt::Subtree { delimiter: None, ..Default::default() },\n+        subtree: tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] },\n         // never used (delimiter is `None`)\n         idx: !0,\n         open_range: TextRange::empty(TextSize::of('.')),\n@@ -186,7 +196,7 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                         if let Some(tt::TokenTree::Leaf(tt::Leaf::Literal(lit))) =\n                             sub.token_trees.get_mut(2)\n                         {\n-                            lit.id = id\n+                            lit.span = id\n                         }\n                     }\n                     tt\n@@ -199,13 +209,14 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                 assert_eq!(range.len(), TextSize::of('.'));\n             }\n \n-            if let Some(delim) = subtree.delimiter {\n-                let expected = match delim.kind {\n-                    tt::DelimiterKind::Parenthesis => T![')'],\n-                    tt::DelimiterKind::Brace => T!['}'],\n-                    tt::DelimiterKind::Bracket => T![']'],\n-                };\n+            let expected = match subtree.delimiter.kind {\n+                tt::DelimiterKind::Parenthesis => Some(T![')']),\n+                tt::DelimiterKind::Brace => Some(T!['}']),\n+                tt::DelimiterKind::Bracket => Some(T![']']),\n+                tt::DelimiterKind::Invisible => None,\n+            };\n \n+            if let Some(expected) = expected {\n                 if kind == expected {\n                     if let Some(entry) = stack.pop() {\n                         conv.id_alloc().close_delim(entry.idx, Some(range));\n@@ -223,9 +234,11 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n             };\n \n             if let Some(kind) = delim {\n-                let mut subtree = tt::Subtree::default();\n                 let (id, idx) = conv.id_alloc().open_delim(range, synth_id);\n-                subtree.delimiter = Some(tt::Delimiter { id, kind });\n+                let subtree = tt::Subtree {\n+                    delimiter: tt::Delimiter { open: id, close: tt::TokenId::UNSPECIFIED, kind },\n+                    token_trees: vec![],\n+                };\n                 stack.push(StackEntry { subtree, idx, open_range: range });\n                 continue;\n             }\n@@ -240,13 +253,20 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                     panic!(\"Token from lexer must be single char: token = {token:#?}\");\n                 }\n             };\n-            tt::Leaf::from(tt::Punct { char, spacing, id: conv.id_alloc().alloc(range, synth_id) })\n-                .into()\n+            tt::Leaf::from(tt::Punct {\n+                char,\n+                spacing,\n+                span: conv.id_alloc().alloc(range, synth_id),\n+            })\n+            .into()\n         } else {\n             macro_rules! make_leaf {\n                 ($i:ident) => {\n-                    tt::$i { id: conv.id_alloc().alloc(range, synth_id), text: token.to_text(conv) }\n-                        .into()\n+                    tt::$i {\n+                        span: conv.id_alloc().alloc(range, synth_id),\n+                        text: token.to_text(conv),\n+                    }\n+                    .into()\n                 };\n             }\n             let leaf: tt::Leaf = match kind {\n@@ -261,14 +281,14 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                     let apostrophe = tt::Leaf::from(tt::Punct {\n                         char: '\\'',\n                         spacing: tt::Spacing::Joint,\n-                        id: conv.id_alloc().alloc(r, synth_id),\n+                        span: conv.id_alloc().alloc(r, synth_id),\n                     });\n                     result.push(apostrophe.into());\n \n                     let r = TextRange::at(range.start() + char_unit, range.len() - char_unit);\n                     let ident = tt::Leaf::from(tt::Ident {\n                         text: SmolStr::new(&token.to_text(conv)[1..]),\n-                        id: conv.id_alloc().alloc(r, synth_id),\n+                        span: conv.id_alloc().alloc(r, synth_id),\n                     });\n                     result.push(ident.into());\n                     continue;\n@@ -289,11 +309,12 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n \n         conv.id_alloc().close_delim(entry.idx, None);\n         let leaf: tt::Leaf = tt::Punct {\n-            id: conv.id_alloc().alloc(entry.open_range, None),\n-            char: match entry.subtree.delimiter.unwrap().kind {\n+            span: conv.id_alloc().alloc(entry.open_range, None),\n+            char: match entry.subtree.delimiter.kind {\n                 tt::DelimiterKind::Parenthesis => '(',\n                 tt::DelimiterKind::Brace => '{',\n                 tt::DelimiterKind::Bracket => '[',\n+                tt::DelimiterKind::Invisible => '$',\n             },\n             spacing: tt::Spacing::Alone,\n         }\n@@ -373,10 +394,11 @@ fn convert_doc_comment(token: &syntax::SyntaxToken) -> Option<Vec<tt::TokenTree>\n         token_trees.push(mk_punct('!'));\n     }\n     token_trees.push(tt::TokenTree::from(tt::Subtree {\n-        delimiter: Some(tt::Delimiter {\n+        delimiter: tt::Delimiter {\n+            open: tt::TokenId::UNSPECIFIED,\n+            close: tt::TokenId::UNSPECIFIED,\n             kind: tt::DelimiterKind::Bracket,\n-            id: tt::TokenId::unspecified(),\n-        }),\n+        },\n         token_trees: meta_tkns,\n     }));\n \n@@ -386,20 +408,20 @@ fn convert_doc_comment(token: &syntax::SyntaxToken) -> Option<Vec<tt::TokenTree>\n     fn mk_ident(s: &str) -> tt::TokenTree {\n         tt::TokenTree::from(tt::Leaf::from(tt::Ident {\n             text: s.into(),\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))\n     }\n \n     fn mk_punct(c: char) -> tt::TokenTree {\n         tt::TokenTree::from(tt::Leaf::from(tt::Punct {\n             char: c,\n             spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))\n     }\n \n     fn mk_doc_literal(comment: &ast::Comment) -> tt::TokenTree {\n-        let lit = tt::Literal { text: doc_comment_text(comment), id: tt::TokenId::unspecified() };\n+        let lit = tt::Literal { text: doc_comment_text(comment), span: tt::TokenId::unspecified() };\n \n         tt::TokenTree::from(tt::Leaf::from(lit))\n     }\n@@ -761,15 +783,16 @@ impl<'a> TtTreeSink<'a> {\n     }\n }\n \n-fn delim_to_str(d: tt::DelimiterKind, closing: bool) -> &'static str {\n+fn delim_to_str(d: tt::DelimiterKind, closing: bool) -> Option<&'static str> {\n     let texts = match d {\n         tt::DelimiterKind::Parenthesis => \"()\",\n         tt::DelimiterKind::Brace => \"{}\",\n         tt::DelimiterKind::Bracket => \"[]\",\n+        tt::DelimiterKind::Invisible => return None,\n     };\n \n     let idx = closing as usize;\n-    &texts[idx..texts.len() - (1 - idx)]\n+    Some(&texts[idx..texts.len() - (1 - idx)])\n }\n \n impl<'a> TtTreeSink<'a> {\n@@ -790,13 +813,16 @@ impl<'a> TtTreeSink<'a> {\n                     Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n                         // Mark the range if needed\n                         let (text, id) = match leaf {\n-                            tt::Leaf::Ident(ident) => (ident.text.as_str(), ident.id),\n+                            tt::Leaf::Ident(ident) => (ident.text.as_str(), ident.span),\n                             tt::Leaf::Punct(punct) => {\n                                 assert!(punct.char.is_ascii());\n                                 tmp = punct.char as u8;\n-                                (std::str::from_utf8(std::slice::from_ref(&tmp)).unwrap(), punct.id)\n+                                (\n+                                    std::str::from_utf8(std::slice::from_ref(&tmp)).unwrap(),\n+                                    punct.span,\n+                                )\n                             }\n-                            tt::Leaf::Literal(lit) => (lit.text.as_str(), lit.id),\n+                            tt::Leaf::Literal(lit) => (lit.text.as_str(), lit.span),\n                         };\n                         let range = TextRange::at(self.text_pos, TextSize::of(text));\n                         self.token_map.insert(id, range);\n@@ -805,26 +831,32 @@ impl<'a> TtTreeSink<'a> {\n                     }\n                     Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n                         self.cursor = self.cursor.subtree().unwrap();\n-                        match subtree.delimiter {\n-                            Some(d) => {\n-                                self.open_delims.insert(d.id, self.text_pos);\n-                                delim_to_str(d.kind, false)\n+                        match delim_to_str(subtree.delimiter.kind, false) {\n+                            Some(it) => {\n+                                self.open_delims.insert(subtree.delimiter.open, self.text_pos);\n+                                it\n                             }\n                             None => continue,\n                         }\n                     }\n                     None => {\n                         let parent = self.cursor.end().unwrap();\n                         self.cursor = self.cursor.bump();\n-                        match parent.delimiter {\n-                            Some(d) => {\n-                                if let Some(open_delim) = self.open_delims.get(&d.id) {\n+                        match delim_to_str(parent.delimiter.kind, true) {\n+                            Some(it) => {\n+                                if let Some(open_delim) =\n+                                    self.open_delims.get(&parent.delimiter.open)\n+                                {\n                                     let open_range = TextRange::at(*open_delim, TextSize::of('('));\n                                     let close_range =\n                                         TextRange::at(self.text_pos, TextSize::of('('));\n-                                    self.token_map.insert_delim(d.id, open_range, close_range);\n+                                    self.token_map.insert_delim(\n+                                        parent.delimiter.open,\n+                                        open_range,\n+                                        close_range,\n+                                    );\n                                 }\n-                                delim_to_str(d.kind, true)\n+                                it\n                             }\n                             None => continue,\n                         }"}, {"sha": "fa0125f3e9e04d8c2f91b0615378c7cb60e58123", "filename": "crates/mbe/src/syntax_bridge/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -29,8 +29,8 @@ fn check_punct_spacing(fixture: &str) {\n     let mut cursor = buf.begin();\n     while !cursor.eof() {\n         while let Some(token_tree) = cursor.token_tree() {\n-            if let TokenTreeRef::Leaf(Leaf::Punct(Punct { spacing, id, .. }), _) = token_tree {\n-                if let Some(expected) = annotations.remove(id) {\n+            if let TokenTreeRef::Leaf(Leaf::Punct(Punct { spacing, span, .. }), _) = token_tree {\n+                if let Some(expected) = annotations.remove(span) {\n                     assert_eq!(expected, *spacing);\n                 }\n             }"}, {"sha": "d4c19b3ab8cd134a8edbc202339f27c674111ece", "filename": "crates/mbe/src/to_parser_input.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -2,7 +2,8 @@\n //! format that works for our parser.\n \n use syntax::{SyntaxKind, SyntaxKind::*, T};\n-use tt::buffer::TokenBuffer;\n+\n+use crate::tt::buffer::TokenBuffer;\n \n pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n     let mut res = parser::Input::default();\n@@ -70,23 +71,25 @@ pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n                 cursor.bump()\n             }\n             Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n-                if let Some(d) = subtree.delimiter_kind() {\n-                    res.push(match d {\n-                        tt::DelimiterKind::Parenthesis => T!['('],\n-                        tt::DelimiterKind::Brace => T!['{'],\n-                        tt::DelimiterKind::Bracket => T!['['],\n-                    });\n+                if let Some(kind) = match subtree.delimiter.kind {\n+                    tt::DelimiterKind::Parenthesis => Some(T!['(']),\n+                    tt::DelimiterKind::Brace => Some(T!['{']),\n+                    tt::DelimiterKind::Bracket => Some(T!['[']),\n+                    tt::DelimiterKind::Invisible => None,\n+                } {\n+                    res.push(kind);\n                 }\n                 cursor.subtree().unwrap()\n             }\n             None => match cursor.end() {\n                 Some(subtree) => {\n-                    if let Some(d) = subtree.delimiter_kind() {\n-                        res.push(match d {\n-                            tt::DelimiterKind::Parenthesis => T![')'],\n-                            tt::DelimiterKind::Brace => T!['}'],\n-                            tt::DelimiterKind::Bracket => T![']'],\n-                        })\n+                    if let Some(kind) = match subtree.delimiter.kind {\n+                        tt::DelimiterKind::Parenthesis => Some(T![')']),\n+                        tt::DelimiterKind::Brace => Some(T!['}']),\n+                        tt::DelimiterKind::Bracket => Some(T![']']),\n+                        tt::DelimiterKind::Invisible => None,\n+                    } {\n+                        res.push(kind);\n                     }\n                     cursor.bump()\n                 }"}, {"sha": "e5f6b1372209f81b611e689fd379935da77fb02b", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -3,9 +3,8 @@\n \n use smallvec::{smallvec, SmallVec};\n use syntax::SyntaxKind;\n-use tt::buffer::TokenBuffer;\n \n-use crate::{to_parser_input::to_parser_input, ExpandError, ExpandResult};\n+use crate::{to_parser_input::to_parser_input, tt, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone)]\n pub(crate) struct TtIter<'a> {\n@@ -135,7 +134,7 @@ impl<'a> TtIter<'a> {\n         &mut self,\n         entry_point: parser::PrefixEntryPoint,\n     ) -> ExpandResult<Option<tt::TokenTree>> {\n-        let buffer = TokenBuffer::from_tokens(self.inner.as_slice());\n+        let buffer = tt::buffer::TokenBuffer::from_tokens(self.inner.as_slice());\n         let parser_input = to_parser_input(&buffer);\n         let tree_traversal = entry_point.parse(&parser_input);\n \n@@ -178,7 +177,7 @@ impl<'a> TtIter<'a> {\n             1 => Some(res[0].cloned()),\n             0 => None,\n             _ => Some(tt::TokenTree::Subtree(tt::Subtree {\n-                delimiter: None,\n+                delimiter: tt::Delimiter::unspecified(),\n                 token_trees: res.into_iter().map(|it| it.cloned()).collect(),\n             })),\n         };"}, {"sha": "bb381c4d44e9dd8d0f207df1c04150c788f48bac", "filename": "crates/proc-macro-api/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-api%2Fsrc%2Flib.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -19,7 +19,8 @@ use std::{\n };\n \n use serde::{Deserialize, Serialize};\n-use tt::Subtree;\n+\n+use ::tt::token_id as tt;\n \n use crate::{\n     msg::{ExpandMacro, FlatTree, PanicMessage},\n@@ -151,10 +152,10 @@ impl ProcMacro {\n \n     pub fn expand(\n         &self,\n-        subtree: &Subtree,\n-        attr: Option<&Subtree>,\n+        subtree: &tt::Subtree,\n+        attr: Option<&tt::Subtree>,\n         env: Vec<(String, String)>,\n-    ) -> Result<Result<Subtree, PanicMessage>, ServerError> {\n+    ) -> Result<Result<tt::Subtree, PanicMessage>, ServerError> {\n         let current_dir = env\n             .iter()\n             .find(|(name, _)| name == \"CARGO_MANIFEST_DIR\")"}, {"sha": "9b7bcaeffe7f748cda3d2dbf55722b888ca5bd65", "filename": "crates/proc-macro-api/src/msg.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-api%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-api%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-api%2Fsrc%2Fmsg.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -107,27 +107,31 @@ fn write_json(out: &mut impl Write, msg: &str) -> io::Result<()> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use tt::*;\n+    use crate::tt::*;\n \n     fn fixture_token_tree() -> Subtree {\n-        let mut subtree = Subtree::default();\n+        let mut subtree = Subtree { delimiter: Delimiter::unspecified(), token_trees: Vec::new() };\n         subtree\n             .token_trees\n-            .push(TokenTree::Leaf(Ident { text: \"struct\".into(), id: TokenId(0) }.into()));\n+            .push(TokenTree::Leaf(Ident { text: \"struct\".into(), span: TokenId(0) }.into()));\n         subtree\n             .token_trees\n-            .push(TokenTree::Leaf(Ident { text: \"Foo\".into(), id: TokenId(1) }.into()));\n+            .push(TokenTree::Leaf(Ident { text: \"Foo\".into(), span: TokenId(1) }.into()));\n         subtree.token_trees.push(TokenTree::Leaf(Leaf::Literal(Literal {\n             text: \"Foo\".into(),\n-            id: TokenId::unspecified(),\n+            span: TokenId::unspecified(),\n         })));\n         subtree.token_trees.push(TokenTree::Leaf(Leaf::Punct(Punct {\n             char: '@',\n-            id: TokenId::unspecified(),\n+            span: TokenId::unspecified(),\n             spacing: Spacing::Joint,\n         })));\n         subtree.token_trees.push(TokenTree::Subtree(Subtree {\n-            delimiter: Some(Delimiter { id: TokenId(2), kind: DelimiterKind::Brace }),\n+            delimiter: Delimiter {\n+                open: TokenId(2),\n+                close: TokenId::UNSPECIFIED,\n+                kind: DelimiterKind::Brace,\n+            },\n             token_trees: vec![],\n         }));\n         subtree"}, {"sha": "fd3202e0b284c3794897a84894bfee5f481f9609", "filename": "crates/proc-macro-api/src/msg/flat.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -38,7 +38,8 @@\n use std::collections::{HashMap, VecDeque};\n \n use serde::{Deserialize, Serialize};\n-use tt::TokenId;\n+\n+use crate::tt::{self, TokenId};\n \n #[derive(Serialize, Deserialize, Debug)]\n pub struct FlatTree {\n@@ -52,7 +53,7 @@ pub struct FlatTree {\n \n struct SubtreeRepr {\n     id: tt::TokenId,\n-    kind: Option<tt::DelimiterKind>,\n+    kind: tt::DelimiterKind,\n     tt: [u32; 2],\n }\n \n@@ -124,19 +125,19 @@ impl FlatTree {\n impl SubtreeRepr {\n     fn write(self) -> [u32; 4] {\n         let kind = match self.kind {\n-            None => 0,\n-            Some(tt::DelimiterKind::Parenthesis) => 1,\n-            Some(tt::DelimiterKind::Brace) => 2,\n-            Some(tt::DelimiterKind::Bracket) => 3,\n+            tt::DelimiterKind::Invisible => 0,\n+            tt::DelimiterKind::Parenthesis => 1,\n+            tt::DelimiterKind::Brace => 2,\n+            tt::DelimiterKind::Bracket => 3,\n         };\n         [self.id.0, kind, self.tt[0], self.tt[1]]\n     }\n     fn read([id, kind, lo, len]: [u32; 4]) -> SubtreeRepr {\n         let kind = match kind {\n-            0 => None,\n-            1 => Some(tt::DelimiterKind::Parenthesis),\n-            2 => Some(tt::DelimiterKind::Brace),\n-            3 => Some(tt::DelimiterKind::Bracket),\n+            0 => tt::DelimiterKind::Invisible,\n+            1 => tt::DelimiterKind::Parenthesis,\n+            2 => tt::DelimiterKind::Brace,\n+            3 => tt::DelimiterKind::Bracket,\n             other => panic!(\"bad kind {other}\"),\n         };\n         SubtreeRepr { id: TokenId(id), kind, tt: [lo, len] }\n@@ -216,22 +217,22 @@ impl<'a> Writer<'a> {\n                     tt::Leaf::Literal(lit) => {\n                         let idx = self.literal.len() as u32;\n                         let text = self.intern(&lit.text);\n-                        self.literal.push(LiteralRepr { id: lit.id, text });\n+                        self.literal.push(LiteralRepr { id: lit.span, text });\n                         idx << 2 | 0b01\n                     }\n                     tt::Leaf::Punct(punct) => {\n                         let idx = self.punct.len() as u32;\n                         self.punct.push(PunctRepr {\n                             char: punct.char,\n                             spacing: punct.spacing,\n-                            id: punct.id,\n+                            id: punct.span,\n                         });\n                         idx << 2 | 0b10\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let idx = self.ident.len() as u32;\n                         let text = self.intern(&ident.text);\n-                        self.ident.push(IdentRepr { id: ident.id, text });\n+                        self.ident.push(IdentRepr { id: ident.span, text });\n                         idx << 2 | 0b11\n                     }\n                 },\n@@ -243,8 +244,8 @@ impl<'a> Writer<'a> {\n \n     fn enqueue(&mut self, subtree: &'a tt::Subtree) -> u32 {\n         let idx = self.subtree.len();\n-        let delimiter_id = subtree.delimiter.map_or(TokenId::unspecified(), |it| it.id);\n-        let delimiter_kind = subtree.delimiter.map(|it| it.kind);\n+        let delimiter_id = subtree.delimiter.open;\n+        let delimiter_kind = subtree.delimiter.kind;\n         self.subtree.push(SubtreeRepr { id: delimiter_id, kind: delimiter_kind, tt: [!0, !0] });\n         self.work.push_back((idx, subtree));\n         idx as u32\n@@ -276,7 +277,11 @@ impl Reader {\n             let repr = &self.subtree[i];\n             let token_trees = &self.token_tree[repr.tt[0] as usize..repr.tt[1] as usize];\n             let s = tt::Subtree {\n-                delimiter: repr.kind.map(|kind| tt::Delimiter { id: repr.id, kind }),\n+                delimiter: tt::Delimiter {\n+                    open: repr.id,\n+                    close: TokenId::UNSPECIFIED,\n+                    kind: repr.kind,\n+                },\n                 token_trees: token_trees\n                     .iter()\n                     .copied()\n@@ -291,7 +296,7 @@ impl Reader {\n                                 let repr = &self.literal[idx];\n                                 tt::Leaf::Literal(tt::Literal {\n                                     text: self.text[repr.text as usize].as_str().into(),\n-                                    id: repr.id,\n+                                    span: repr.id,\n                                 })\n                                 .into()\n                             }\n@@ -300,15 +305,15 @@ impl Reader {\n                                 tt::Leaf::Punct(tt::Punct {\n                                     char: repr.char,\n                                     spacing: repr.spacing,\n-                                    id: repr.id,\n+                                    span: repr.id,\n                                 })\n                                 .into()\n                             }\n                             0b11 => {\n                                 let repr = &self.ident[idx];\n                                 tt::Leaf::Ident(tt::Ident {\n                                     text: self.text[repr.text as usize].as_str().into(),\n-                                    id: repr.id,\n+                                    span: repr.id,\n                                 })\n                                 .into()\n                             }"}, {"sha": "93805c89354a5d7fff1b4463e1776c0d8083bfa5", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -11,6 +11,7 @@ mod ra_server;\n use libloading::Library;\n use proc_macro_api::ProcMacroKind;\n \n+use super::tt;\n use super::PanicMessage;\n \n pub use ra_server::TokenStream;"}, {"sha": "30baf3a13f57f5399857619510ac6ed8cd37e5be", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/ra_server.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -15,6 +15,8 @@ use std::hash::Hash;\n use std::ops::Bound;\n use std::{ascii, vec::IntoIter};\n \n+use crate::tt;\n+\n type Group = tt::Subtree;\n type TokenTree = tt::TokenTree;\n type Punct = tt::Punct;\n@@ -33,15 +35,15 @@ impl TokenStream {\n     }\n \n     pub fn with_subtree(subtree: tt::Subtree) -> Self {\n-        if subtree.delimiter.is_some() {\n+        if subtree.delimiter.kind != tt::DelimiterKind::Invisible {\n             TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n         } else {\n             TokenStream { token_trees: subtree.token_trees }\n         }\n     }\n \n     pub fn into_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n+        tt::Subtree { delimiter: tt::Delimiter::UNSPECIFIED, token_trees: self.token_trees }\n     }\n \n     pub fn is_empty(&self) -> bool {\n@@ -84,7 +86,9 @@ impl Extend<TokenStream> for TokenStream {\n         for item in streams {\n             for tkn in item {\n                 match tkn {\n-                    tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n+                    tt::TokenTree::Subtree(subtree)\n+                        if subtree.delimiter.kind == tt::DelimiterKind::Invisible =>\n+                    {\n                         self.token_trees.extend(subtree.token_trees);\n                     }\n                     _ => {\n@@ -165,7 +169,7 @@ pub struct TokenStreamBuilder {\n pub mod token_stream {\n     use std::str::FromStr;\n \n-    use super::{TokenStream, TokenTree};\n+    use super::{tt, TokenStream, TokenTree};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n     /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n@@ -202,15 +206,17 @@ pub mod token_stream {\n \n     impl ToString for TokenStream {\n         fn to_string(&self) -> String {\n-            tt::pretty(&self.token_trees)\n+            ::tt::pretty(&self.token_trees)\n         }\n     }\n \n     fn subtree_replace_token_ids_with_unspecified(subtree: tt::Subtree) -> tt::Subtree {\n         tt::Subtree {\n-            delimiter: subtree\n-                .delimiter\n-                .map(|d| tt::Delimiter { id: tt::TokenId::unspecified(), ..d }),\n+            delimiter: tt::Delimiter {\n+                open: tt::TokenId::UNSPECIFIED,\n+                close: tt::TokenId::UNSPECIFIED,\n+                ..subtree.delimiter\n+            },\n             token_trees: subtree\n                 .token_trees\n                 .into_iter()\n@@ -233,13 +239,13 @@ pub mod token_stream {\n     fn leaf_replace_token_ids_with_unspecified(leaf: tt::Leaf) -> tt::Leaf {\n         match leaf {\n             tt::Leaf::Literal(lit) => {\n-                tt::Leaf::Literal(tt::Literal { id: tt::TokenId::unspecified(), ..lit })\n+                tt::Leaf::Literal(tt::Literal { span: tt::TokenId::unspecified(), ..lit })\n             }\n             tt::Leaf::Punct(punct) => {\n-                tt::Leaf::Punct(tt::Punct { id: tt::TokenId::unspecified(), ..punct })\n+                tt::Leaf::Punct(tt::Punct { span: tt::TokenId::unspecified(), ..punct })\n             }\n             tt::Leaf::Ident(ident) => {\n-                tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), ..ident })\n+                tt::Leaf::Ident(tt::Ident { span: tt::TokenId::unspecified(), ..ident })\n             }\n         }\n     }\n@@ -389,22 +395,22 @@ impl server::TokenStream for RustAnalyzer {\n     }\n }\n \n-fn delim_to_internal(d: bridge::Delimiter) -> Option<tt::Delimiter> {\n+fn delim_to_internal(d: bridge::Delimiter) -> tt::Delimiter {\n     let kind = match d {\n         bridge::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n         bridge::Delimiter::Brace => tt::DelimiterKind::Brace,\n         bridge::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n-        bridge::Delimiter::None => return None,\n+        bridge::Delimiter::None => tt::DelimiterKind::Invisible,\n     };\n-    Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n+    tt::Delimiter { open: tt::TokenId::unspecified(), close: tt::TokenId::unspecified(), kind }\n }\n \n-fn delim_to_external(d: Option<tt::Delimiter>) -> bridge::Delimiter {\n-    match d.map(|it| it.kind) {\n-        Some(tt::DelimiterKind::Parenthesis) => bridge::Delimiter::Parenthesis,\n-        Some(tt::DelimiterKind::Brace) => bridge::Delimiter::Brace,\n-        Some(tt::DelimiterKind::Bracket) => bridge::Delimiter::Bracket,\n-        None => bridge::Delimiter::None,\n+fn delim_to_external(d: tt::Delimiter) -> bridge::Delimiter {\n+    match d.kind {\n+        tt::DelimiterKind::Parenthesis => bridge::Delimiter::Parenthesis,\n+        tt::DelimiterKind::Brace => bridge::Delimiter::Brace,\n+        tt::DelimiterKind::Bracket => bridge::Delimiter::Bracket,\n+        tt::DelimiterKind::Invisible => bridge::Delimiter::None,\n     }\n }\n \n@@ -443,23 +449,19 @@ impl server::Group for RustAnalyzer {\n     }\n \n     fn span(&mut self, group: &Self::Group) -> Self::Span {\n-        group.delimiter.map(|it| it.id).unwrap_or_else(tt::TokenId::unspecified)\n+        group.delimiter.open\n     }\n \n     fn set_span(&mut self, group: &mut Self::Group, span: Self::Span) {\n-        if let Some(delim) = &mut group.delimiter {\n-            delim.id = span;\n-        }\n+        group.delimiter.open = span;\n     }\n \n     fn span_open(&mut self, group: &Self::Group) -> Self::Span {\n-        // FIXME we only store one `TokenId` for the delimiters\n-        group.delimiter.map(|it| it.id).unwrap_or_else(tt::TokenId::unspecified)\n+        group.delimiter.open\n     }\n \n     fn span_close(&mut self, group: &Self::Group) -> Self::Span {\n-        // FIXME we only store one `TokenId` for the delimiters\n-        group.delimiter.map(|it| it.id).unwrap_or_else(tt::TokenId::unspecified)\n+        group.delimiter.close\n     }\n }\n \n@@ -468,7 +470,7 @@ impl server::Punct for RustAnalyzer {\n         tt::Punct {\n             char: ch,\n             spacing: spacing_to_internal(spacing),\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }\n     }\n     fn as_char(&mut self, punct: Self::Punct) -> char {\n@@ -478,28 +480,27 @@ impl server::Punct for RustAnalyzer {\n         spacing_to_external(punct.spacing)\n     }\n     fn span(&mut self, punct: Self::Punct) -> Self::Span {\n-        punct.id\n+        punct.span\n     }\n     fn with_span(&mut self, punct: Self::Punct, span: Self::Span) -> Self::Punct {\n-        tt::Punct { id: span, ..punct }\n+        tt::Punct { span: span, ..punct }\n     }\n }\n \n impl server::Ident for RustAnalyzer {\n     fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n-        IdentId(self.ident_interner.intern(&IdentData(tt::Ident::new_with_is_raw(\n-            string.into(),\n+        IdentId(self.ident_interner.intern(&IdentData(tt::Ident {\n+            text: if is_raw { ::tt::SmolStr::from_iter([\"r#\", string]) } else { string.into() },\n             span,\n-            is_raw,\n-        ))))\n+        })))\n     }\n \n     fn span(&mut self, ident: Self::Ident) -> Self::Span {\n-        self.ident_interner.get(ident.0).0.id\n+        self.ident_interner.get(ident.0).0.span\n     }\n     fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n         let data = self.ident_interner.get(ident.0);\n-        let new = IdentData(tt::Ident { id: span, ..data.0.clone() });\n+        let new = IdentData(tt::Ident { span: span, ..data.0.clone() });\n         IdentId(self.ident_interner.intern(&new))\n     }\n }\n@@ -511,7 +512,7 @@ impl server::Literal for RustAnalyzer {\n         \"\".to_owned()\n     }\n     fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        Ok(Literal { text: s.into(), id: tt::TokenId::unspecified() })\n+        Ok(Literal { text: s.into(), span: tt::TokenId::unspecified() })\n     }\n     fn symbol(&mut self, literal: &Self::Literal) -> String {\n         literal.text.to_string()\n@@ -529,7 +530,7 @@ impl server::Literal for RustAnalyzer {\n             Ok(n) => n.to_string(),\n             Err(_) => n.parse::<u128>().unwrap().to_string(),\n         };\n-        Literal { text: n.into(), id: tt::TokenId::unspecified() }\n+        Literal { text: n.into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n@@ -549,7 +550,7 @@ impl server::Literal for RustAnalyzer {\n \n         let text = def_suffixed_integer! {kind, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize};\n \n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn float(&mut self, n: &str) -> Self::Literal {\n@@ -558,31 +559,31 @@ impl server::Literal for RustAnalyzer {\n         if !text.contains('.') {\n             text += \".0\"\n         }\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn f32(&mut self, n: &str) -> Self::Literal {\n         let n: f32 = n.parse().unwrap();\n         let text = format!(\"{n}f32\");\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn f64(&mut self, n: &str) -> Self::Literal {\n         let n: f64 = n.parse().unwrap();\n         let text = format!(\"{n}f64\");\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn string(&mut self, string: &str) -> Self::Literal {\n         let mut escaped = String::new();\n         for ch in string.chars() {\n             escaped.extend(ch.escape_debug());\n         }\n-        Literal { text: format!(\"\\\"{escaped}\\\"\").into(), id: tt::TokenId::unspecified() }\n+        Literal { text: format!(\"\\\"{escaped}\\\"\").into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn character(&mut self, ch: char) -> Self::Literal {\n-        Literal { text: format!(\"'{ch}'\").into(), id: tt::TokenId::unspecified() }\n+        Literal { text: format!(\"'{ch}'\").into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n@@ -593,15 +594,15 @@ impl server::Literal for RustAnalyzer {\n             .map(Into::<char>::into)\n             .collect::<String>();\n \n-        Literal { text: format!(\"b\\\"{string}\\\"\").into(), id: tt::TokenId::unspecified() }\n+        Literal { text: format!(\"b\\\"{string}\\\"\").into(), span: tt::TokenId::unspecified() }\n     }\n \n     fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n-        literal.id\n+        literal.span\n     }\n \n     fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n-        literal.id = span;\n+        literal.span = span;\n     }\n \n     fn subspan(\n@@ -784,17 +785,18 @@ mod tests {\n             token_trees: vec![\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                     text: \"struct\".into(),\n-                    id: tt::TokenId::unspecified(),\n+                    span: tt::TokenId::unspecified(),\n                 })),\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                     text: \"T\".into(),\n-                    id: tt::TokenId::unspecified(),\n+                    span: tt::TokenId::unspecified(),\n                 })),\n                 tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: Some(tt::Delimiter {\n-                        id: tt::TokenId::unspecified(),\n+                    delimiter: tt::Delimiter {\n+                        open: tt::TokenId::unspecified(),\n+                        close: tt::TokenId::unspecified(),\n                         kind: tt::DelimiterKind::Brace,\n-                    }),\n+                    },\n                     token_trees: vec![],\n                 }),\n             ],\n@@ -807,13 +809,14 @@ mod tests {\n     fn test_ra_server_from_str() {\n         use std::str::FromStr;\n         let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n-            delimiter: Some(tt::Delimiter {\n-                id: tt::TokenId::unspecified(),\n+            delimiter: tt::Delimiter {\n+                open: tt::TokenId::unspecified(),\n+                close: tt::TokenId::unspecified(),\n                 kind: tt::DelimiterKind::Parenthesis,\n-            }),\n+            },\n             token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                 text: \"a\".into(),\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n             }))],\n         });\n \n@@ -830,7 +833,7 @@ mod tests {\n             underscore.token_trees[0],\n             tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                 text: \"_\".into(),\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n             }))\n         );\n     }"}, {"sha": "0a3b8866a7fd5c2e1f872b7259ee3a85d455beec", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -9,7 +9,7 @@ mod ra_server;\n use libloading::Library;\n use proc_macro_api::ProcMacroKind;\n \n-use super::PanicMessage;\n+use super::{tt, PanicMessage};\n \n pub use ra_server::TokenStream;\n "}, {"sha": "d258a02472909c878dc044e1e2007c5f6b048d98", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -22,6 +22,8 @@ pub use symbol::*;\n \n use std::ops::Bound;\n \n+use crate::tt;\n+\n type Group = tt::Subtree;\n type TokenTree = tt::TokenTree;\n type Punct = tt::Punct;\n@@ -108,8 +110,9 @@ impl server::TokenStream for RustAnalyzer {\n \n             bridge::TokenTree::Ident(ident) => {\n                 let text = ident.sym.text();\n-                let text = if ident.is_raw { tt::SmolStr::from_iter([\"r#\", &text]) } else { text };\n-                let ident: tt::Ident = tt::Ident { text, id: ident.span };\n+                let text =\n+                    if ident.is_raw { ::tt::SmolStr::from_iter([\"r#\", &text]) } else { text };\n+                let ident: tt::Ident = tt::Ident { text, span: ident.span };\n                 let leaf = tt::Leaf::from(ident);\n                 let tree = TokenTree::from(leaf);\n                 Self::TokenStream::from_iter(vec![tree])\n@@ -118,9 +121,9 @@ impl server::TokenStream for RustAnalyzer {\n             bridge::TokenTree::Literal(literal) => {\n                 let literal = LiteralFormatter(literal);\n                 let text = literal\n-                    .with_stringify_parts(|parts| tt::SmolStr::from_iter(parts.iter().copied()));\n+                    .with_stringify_parts(|parts| ::tt::SmolStr::from_iter(parts.iter().copied()));\n \n-                let literal = tt::Literal { text, id: literal.0.span };\n+                let literal = tt::Literal { text, span: literal.0.span };\n                 let leaf = tt::Leaf::from(literal);\n                 let tree = TokenTree::from(leaf);\n                 Self::TokenStream::from_iter(vec![tree])\n@@ -130,7 +133,7 @@ impl server::TokenStream for RustAnalyzer {\n                 let punct = tt::Punct {\n                     char: p.ch as char,\n                     spacing: if p.joint { Spacing::Joint } else { Spacing::Alone },\n-                    id: p.span,\n+                    span: p.span,\n                 };\n                 let leaf = tt::Leaf::from(punct);\n                 let tree = TokenTree::from(leaf);\n@@ -184,7 +187,7 @@ impl server::TokenStream for RustAnalyzer {\n                     bridge::TokenTree::Ident(bridge::Ident {\n                         sym: Symbol::intern(ident.text.trim_start_matches(\"r#\")),\n                         is_raw: ident.text.starts_with(\"r#\"),\n-                        span: ident.id,\n+                        span: ident.span,\n                     })\n                 }\n                 tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => {\n@@ -194,14 +197,14 @@ impl server::TokenStream for RustAnalyzer {\n                         symbol: Symbol::intern(&lit.text),\n                         // FIXME: handle suffixes\n                         suffix: None,\n-                        span: lit.id,\n+                        span: lit.span,\n                     })\n                 }\n                 tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n                     bridge::TokenTree::Punct(bridge::Punct {\n                         ch: punct.char as u8,\n                         joint: punct.spacing == Spacing::Joint,\n-                        span: punct.id,\n+                        span: punct.span,\n                     })\n                 }\n                 tt::TokenTree::Subtree(subtree) => bridge::TokenTree::Group(bridge::Group {\n@@ -211,31 +214,29 @@ impl server::TokenStream for RustAnalyzer {\n                     } else {\n                         Some(subtree.token_trees.into_iter().collect())\n                     },\n-                    span: bridge::DelimSpan::from_single(\n-                        subtree.delimiter.map_or(Span::unspecified(), |del| del.id),\n-                    ),\n+                    span: bridge::DelimSpan::from_single(subtree.delimiter.open),\n                 }),\n             })\n             .collect()\n     }\n }\n \n-fn delim_to_internal(d: proc_macro::Delimiter) -> Option<tt::Delimiter> {\n+fn delim_to_internal(d: proc_macro::Delimiter) -> tt::Delimiter {\n     let kind = match d {\n         proc_macro::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n         proc_macro::Delimiter::Brace => tt::DelimiterKind::Brace,\n         proc_macro::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n-        proc_macro::Delimiter::None => return None,\n+        proc_macro::Delimiter::None => tt::DelimiterKind::Invisible,\n     };\n-    Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n+    tt::Delimiter { open: tt::TokenId::unspecified(), close: tt::TokenId::unspecified(), kind }\n }\n \n-fn delim_to_external(d: Option<tt::Delimiter>) -> proc_macro::Delimiter {\n-    match d.map(|it| it.kind) {\n-        Some(tt::DelimiterKind::Parenthesis) => proc_macro::Delimiter::Parenthesis,\n-        Some(tt::DelimiterKind::Brace) => proc_macro::Delimiter::Brace,\n-        Some(tt::DelimiterKind::Bracket) => proc_macro::Delimiter::Bracket,\n-        None => proc_macro::Delimiter::None,\n+fn delim_to_external(d: tt::Delimiter) -> proc_macro::Delimiter {\n+    match d.kind {\n+        tt::DelimiterKind::Parenthesis => proc_macro::Delimiter::Parenthesis,\n+        tt::DelimiterKind::Brace => proc_macro::Delimiter::Brace,\n+        tt::DelimiterKind::Bracket => proc_macro::Delimiter::Bracket,\n+        tt::DelimiterKind::Invisible => proc_macro::Delimiter::None,\n     }\n }\n \n@@ -349,7 +350,7 @@ impl server::Server for RustAnalyzer {\n     }\n \n     fn intern_symbol(ident: &str) -> Self::Symbol {\n-        Symbol::intern(&tt::SmolStr::from(ident))\n+        Symbol::intern(&::tt::SmolStr::from(ident))\n     }\n \n     fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n@@ -413,17 +414,18 @@ mod tests {\n             token_trees: vec![\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                     text: \"struct\".into(),\n-                    id: tt::TokenId::unspecified(),\n+                    span: tt::TokenId::unspecified(),\n                 })),\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                     text: \"T\".into(),\n-                    id: tt::TokenId::unspecified(),\n+                    span: tt::TokenId::unspecified(),\n                 })),\n                 tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: Some(tt::Delimiter {\n-                        id: tt::TokenId::unspecified(),\n+                    delimiter: tt::Delimiter {\n+                        open: tt::TokenId::unspecified(),\n+                        close: tt::TokenId::unspecified(),\n                         kind: tt::DelimiterKind::Brace,\n-                    }),\n+                    },\n                     token_trees: vec![],\n                 }),\n             ],\n@@ -436,13 +438,14 @@ mod tests {\n     fn test_ra_server_from_str() {\n         use std::str::FromStr;\n         let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n-            delimiter: Some(tt::Delimiter {\n-                id: tt::TokenId::unspecified(),\n+            delimiter: tt::Delimiter {\n+                open: tt::TokenId::unspecified(),\n+                close: tt::TokenId::unspecified(),\n                 kind: tt::DelimiterKind::Parenthesis,\n-            }),\n+            },\n             token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                 text: \"a\".into(),\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n             }))],\n         });\n \n@@ -459,7 +462,7 @@ mod tests {\n             underscore.token_trees[0],\n             tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                 text: \"_\".into(),\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n             }))\n         );\n     }"}, {"sha": "7de30e73928a30b0f61ec2f1988d34618c4d337c", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server/token_stream.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -1,6 +1,6 @@\n //! TokenStream implementation used by sysroot ABI\n \n-use tt::TokenTree;\n+use crate::tt::{self, TokenTree};\n \n #[derive(Debug, Default, Clone)]\n pub struct TokenStream {\n@@ -13,15 +13,15 @@ impl TokenStream {\n     }\n \n     pub fn with_subtree(subtree: tt::Subtree) -> Self {\n-        if subtree.delimiter.is_some() {\n+        if subtree.delimiter.kind != tt::DelimiterKind::Invisible {\n             TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n         } else {\n             TokenStream { token_trees: subtree.token_trees }\n         }\n     }\n \n     pub fn into_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n+        tt::Subtree { delimiter: tt::Delimiter::UNSPECIFIED, token_trees: self.token_trees }\n     }\n \n     pub fn is_empty(&self) -> bool {\n@@ -64,7 +64,9 @@ impl Extend<TokenStream> for TokenStream {\n         for item in streams {\n             for tkn in item {\n                 match tkn {\n-                    tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n+                    tt::TokenTree::Subtree(subtree)\n+                        if subtree.delimiter.kind != tt::DelimiterKind::Invisible =>\n+                    {\n                         self.token_trees.extend(subtree.token_trees);\n                     }\n                     _ => {\n@@ -84,7 +86,7 @@ pub struct TokenStreamBuilder {\n pub mod token_stream {\n     use std::str::FromStr;\n \n-    use super::{TokenStream, TokenTree};\n+    use super::{tt, TokenStream, TokenTree};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n     /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n@@ -121,15 +123,17 @@ pub mod token_stream {\n \n     impl ToString for TokenStream {\n         fn to_string(&self) -> String {\n-            tt::pretty(&self.token_trees)\n+            ::tt::pretty(&self.token_trees)\n         }\n     }\n \n     fn subtree_replace_token_ids_with_unspecified(subtree: tt::Subtree) -> tt::Subtree {\n         tt::Subtree {\n-            delimiter: subtree\n-                .delimiter\n-                .map(|d| tt::Delimiter { id: tt::TokenId::unspecified(), ..d }),\n+            delimiter: tt::Delimiter {\n+                open: tt::TokenId::UNSPECIFIED,\n+                close: tt::TokenId::UNSPECIFIED,\n+                ..subtree.delimiter\n+            },\n             token_trees: subtree\n                 .token_trees\n                 .into_iter()\n@@ -152,13 +156,13 @@ pub mod token_stream {\n     fn leaf_replace_token_ids_with_unspecified(leaf: tt::Leaf) -> tt::Leaf {\n         match leaf {\n             tt::Leaf::Literal(lit) => {\n-                tt::Leaf::Literal(tt::Literal { id: tt::TokenId::unspecified(), ..lit })\n+                tt::Leaf::Literal(tt::Literal { span: tt::TokenId::unspecified(), ..lit })\n             }\n             tt::Leaf::Punct(punct) => {\n-                tt::Leaf::Punct(tt::Punct { id: tt::TokenId::unspecified(), ..punct })\n+                tt::Leaf::Punct(tt::Punct { span: tt::TokenId::unspecified(), ..punct })\n             }\n             tt::Leaf::Ident(ident) => {\n-                tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), ..ident })\n+                tt::Leaf::Ident(tt::Ident { span: tt::TokenId::unspecified(), ..ident })\n             }\n         }\n     }"}, {"sha": "04be39cffa4adbba3b179dc9a9cf872553c719a8", "filename": "crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -41,6 +41,8 @@ pub(crate) use abi_sysroot::Abi as Abi_Sysroot;\n use libloading::Library;\n use proc_macro_api::{ProcMacroKind, RustCInfo};\n \n+use crate::tt;\n+\n pub struct PanicMessage {\n     message: Option<String>,\n }"}, {"sha": "89ffd1f493e29fb97c24e872f56df897e3e8f261", "filename": "crates/proc-macro-srv/src/dylib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -13,6 +13,8 @@ use object::Object;\n use paths::AbsPath;\n use proc_macro_api::{read_dylib_info, ProcMacroKind};\n \n+use crate::tt;\n+\n use super::abis::Abi;\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";"}, {"sha": "ee70fe7d4f54140f95e033f09ab572e276a59550", "filename": "crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -37,6 +37,8 @@ use proc_macro_api::{\n     ProcMacroKind,\n };\n \n+use ::tt::token_id as tt;\n+\n #[derive(Default)]\n pub(crate) struct ProcMacroSrv {\n     expanders: HashMap<(PathBuf, SystemTime), dylib::Expander>,"}, {"sha": "04a0ae7bc72017a3f34709e1ece9f01364ef97b4", "filename": "crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -8,7 +8,7 @@ use expect_test::expect;\n \n #[test]\n fn test_derive_empty() {\n-    assert_expand(\"DeriveEmpty\", r#\"struct S;\"#, expect![[r#\"SUBTREE $\"#]]);\n+    assert_expand(\"DeriveEmpty\", r#\"struct S;\"#, expect![\"SUBTREE $$ 4294967295 4294967295\"]);\n }\n \n #[test]\n@@ -17,10 +17,10 @@ fn test_derive_error() {\n         \"DeriveError\",\n         r#\"struct S;\"#,\n         expect![[r##\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               IDENT   compile_error 4294967295\n               PUNCH   ! [alone] 4294967295\n-              SUBTREE () 4294967295\n+              SUBTREE () 4294967295 4294967295\n                 LITERAL \"#[derive(DeriveError)] struct S ;\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],\n     );\n@@ -32,14 +32,14 @@ fn test_fn_like_macro_noop() {\n         \"fn_like_noop\",\n         r#\"ident, 0, 1, []\"#,\n         expect![[r#\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               IDENT   ident 4294967295\n               PUNCH   , [alone] 4294967295\n               LITERAL 0 4294967295\n               PUNCH   , [alone] 4294967295\n               LITERAL 1 4294967295\n               PUNCH   , [alone] 4294967295\n-              SUBTREE [] 4294967295\"#]],\n+              SUBTREE [] 4294967295 4294967295\"#]],\n     );\n }\n \n@@ -49,10 +49,10 @@ fn test_fn_like_macro_clone_ident_subtree() {\n         \"fn_like_clone_tokens\",\n         r#\"ident, []\"#,\n         expect![[r#\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               IDENT   ident 4294967295\n               PUNCH   , [alone] 4294967295\n-              SUBTREE [] 4294967295\"#]],\n+              SUBTREE [] 4294967295 4294967295\"#]],\n     );\n }\n \n@@ -62,7 +62,7 @@ fn test_fn_like_macro_clone_raw_ident() {\n         \"fn_like_clone_tokens\",\n         \"r#async\",\n         expect![[r#\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               IDENT   r#async 4294967295\"#]],\n     );\n }\n@@ -73,7 +73,7 @@ fn test_fn_like_mk_literals() {\n         \"fn_like_mk_literals\",\n         r#\"\"#,\n         expect![[r#\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               LITERAL b\"byte_string\" 4294967295\n               LITERAL 'c' 4294967295\n               LITERAL \"string\" 4294967295\n@@ -90,7 +90,7 @@ fn test_fn_like_mk_idents() {\n         \"fn_like_mk_idents\",\n         r#\"\"#,\n         expect![[r#\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               IDENT   standard 4294967295\n               IDENT   r#raw 4294967295\"#]],\n     );\n@@ -102,7 +102,7 @@ fn test_fn_like_macro_clone_literals() {\n         \"fn_like_clone_tokens\",\n         r#\"1u16, 2_u32, -4i64, 3.14f32, \"hello bridge\"\"#,\n         expect![[r#\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               LITERAL 1u16 4294967295\n               PUNCH   , [alone] 4294967295\n               LITERAL 2_u32 4294967295\n@@ -126,10 +126,10 @@ fn test_attr_macro() {\n         r#\"mod m {}\"#,\n         r#\"some arguments\"#,\n         expect![[r##\"\n-            SUBTREE $\n+            SUBTREE $$ 4294967295 4294967295\n               IDENT   compile_error 4294967295\n               PUNCH   ! [alone] 4294967295\n-              SUBTREE () 4294967295\n+              SUBTREE () 4294967295 4294967295\n                 LITERAL \"#[attr_error(some arguments)] mod m {}\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],\n     );"}, {"sha": "5ac5af94f5aefd1a37b81f8acbdd1d4f0e714163", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -34,6 +34,8 @@ use crate::{\n     op_queue::Cause,\n };\n \n+use ::tt::token_id as tt;\n+\n #[derive(Debug)]\n pub(crate) enum ProjectWorkspaceProgress {\n     Begin,\n@@ -656,7 +658,7 @@ pub(crate) fn load_proc_macro(\n             _: Option<&tt::Subtree>,\n             _: &Env,\n         ) -> Result<tt::Subtree, ProcMacroExpansionError> {\n-            Ok(tt::Subtree::default())\n+            Ok(tt::Subtree::empty())\n         }\n     }\n }"}, {"sha": "1a9982fa8b2a7f9d6e14f01ca5d5e35c4d8c7476", "filename": "crates/stdx/src/macros.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fstdx%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Fstdx%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fmacros.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -43,5 +43,14 @@ macro_rules! impl_from {\n                 }\n             )*)?\n         )*\n+    };\n+    ($($variant:ident$(<$V:ident>)?),* for $enum:ident) => {\n+        $(\n+            impl$(<$V>)? From<$variant$(<$V>)?> for $enum$(<$V>)? {\n+                fn from(it: $variant$(<$V>)?) -> $enum$(<$V>)? {\n+                    $enum::$variant(it)\n+                }\n+            }\n+        )*\n     }\n }"}, {"sha": "4484431124e13fce817eef9e8f8686fb311beae9", "filename": "crates/tt/src/buffer.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Ftt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Ftt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Fbuffer.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -12,10 +12,10 @@ struct EntryPtr(EntryId, usize);\n /// Internal type which is used instead of `TokenTree` to represent a token tree\n /// within a `TokenBuffer`.\n #[derive(Debug)]\n-enum Entry<'t> {\n+enum Entry<'t, Span> {\n     // Mimicking types from proc-macro.\n-    Subtree(Option<&'t TokenTree>, &'t Subtree, EntryId),\n-    Leaf(&'t TokenTree),\n+    Subtree(Option<&'t TokenTree<Span>>, &'t Subtree<Span>, EntryId),\n+    Leaf(&'t TokenTree<Span>),\n     // End entries contain a pointer to the entry from the containing\n     // token tree, or None if this is the outermost level.\n     End(Option<EntryPtr>),\n@@ -24,16 +24,21 @@ enum Entry<'t> {\n /// A token tree buffer\n /// The safe version of `syn` [`TokenBuffer`](https://github.com/dtolnay/syn/blob/6533607f91686545cb034d2838beea338d9d0742/src/buffer.rs#L41)\n #[derive(Debug)]\n-pub struct TokenBuffer<'t> {\n-    buffers: Vec<Box<[Entry<'t>]>>,\n+pub struct TokenBuffer<'t, Span> {\n+    buffers: Vec<Box<[Entry<'t, Span>]>>,\n }\n \n-trait TokenList<'a> {\n-    fn entries(&self) -> (Vec<(usize, (&'a Subtree, Option<&'a TokenTree>))>, Vec<Entry<'a>>);\n+trait TokenList<'a, Span> {\n+    fn entries(\n+        &self,\n+    ) -> (Vec<(usize, (&'a Subtree<Span>, Option<&'a TokenTree<Span>>))>, Vec<Entry<'a, Span>>);\n }\n \n-impl<'a> TokenList<'a> for &'a [TokenTree] {\n-    fn entries(&self) -> (Vec<(usize, (&'a Subtree, Option<&'a TokenTree>))>, Vec<Entry<'a>>) {\n+impl<'a, Span> TokenList<'a, Span> for &'a [TokenTree<Span>] {\n+    fn entries(\n+        &self,\n+    ) -> (Vec<(usize, (&'a Subtree<Span>, Option<&'a TokenTree<Span>>))>, Vec<Entry<'a, Span>>)\n+    {\n         // Must contain everything in tokens and then the Entry::End\n         let start_capacity = self.len() + 1;\n         let mut entries = Vec::with_capacity(start_capacity);\n@@ -53,8 +58,11 @@ impl<'a> TokenList<'a> for &'a [TokenTree] {\n     }\n }\n \n-impl<'a> TokenList<'a> for &'a Subtree {\n-    fn entries(&self) -> (Vec<(usize, (&'a Subtree, Option<&'a TokenTree>))>, Vec<Entry<'a>>) {\n+impl<'a, Span> TokenList<'a, Span> for &'a Subtree<Span> {\n+    fn entries(\n+        &self,\n+    ) -> (Vec<(usize, (&'a Subtree<Span>, Option<&'a TokenTree<Span>>))>, Vec<Entry<'a, Span>>)\n+    {\n         // Must contain everything in tokens and then the Entry::End\n         let mut entries = vec![];\n         let mut children = vec![];\n@@ -64,25 +72,25 @@ impl<'a> TokenList<'a> for &'a Subtree {\n     }\n }\n \n-impl<'t> TokenBuffer<'t> {\n-    pub fn from_tokens(tokens: &'t [TokenTree]) -> TokenBuffer<'t> {\n+impl<'t, Span> TokenBuffer<'t, Span> {\n+    pub fn from_tokens(tokens: &'t [TokenTree<Span>]) -> TokenBuffer<'t, Span> {\n         Self::new(tokens)\n     }\n \n-    pub fn from_subtree(subtree: &'t Subtree) -> TokenBuffer<'t> {\n+    pub fn from_subtree(subtree: &'t Subtree<Span>) -> TokenBuffer<'t, Span> {\n         Self::new(subtree)\n     }\n \n-    fn new<T: TokenList<'t>>(tokens: T) -> TokenBuffer<'t> {\n+    fn new<T: TokenList<'t, Span>>(tokens: T) -> TokenBuffer<'t, Span> {\n         let mut buffers = vec![];\n         let idx = TokenBuffer::new_inner(tokens, &mut buffers, None);\n         assert_eq!(idx, 0);\n         TokenBuffer { buffers }\n     }\n \n-    fn new_inner<T: TokenList<'t>>(\n+    fn new_inner<T: TokenList<'t, Span>>(\n         tokens: T,\n-        buffers: &mut Vec<Box<[Entry<'t>]>>,\n+        buffers: &mut Vec<Box<[Entry<'t, Span>]>>,\n         next: Option<EntryPtr>,\n     ) -> usize {\n         let (children, mut entries) = tokens.entries();\n@@ -105,25 +113,25 @@ impl<'t> TokenBuffer<'t> {\n \n     /// Creates a cursor referencing the first token in the buffer and able to\n     /// traverse until the end of the buffer.\n-    pub fn begin(&self) -> Cursor<'_> {\n+    pub fn begin(&self) -> Cursor<'_, Span> {\n         Cursor::create(self, EntryPtr(EntryId(0), 0))\n     }\n \n-    fn entry(&self, ptr: &EntryPtr) -> Option<&Entry<'_>> {\n+    fn entry(&self, ptr: &EntryPtr) -> Option<&Entry<'_, Span>> {\n         let id = ptr.0;\n         self.buffers[id.0].get(ptr.1)\n     }\n }\n \n #[derive(Debug)]\n-pub enum TokenTreeRef<'a> {\n-    Subtree(&'a Subtree, Option<&'a TokenTree>),\n-    Leaf(&'a Leaf, &'a TokenTree),\n+pub enum TokenTreeRef<'a, Span> {\n+    Subtree(&'a Subtree<Span>, Option<&'a TokenTree<Span>>),\n+    Leaf(&'a Leaf<Span>, &'a TokenTree<Span>),\n }\n \n-impl<'a> TokenTreeRef<'a> {\n-    pub fn cloned(&self) -> TokenTree {\n-        match &self {\n+impl<'a, Span: Clone> TokenTreeRef<'a, Span> {\n+    pub fn cloned(&self) -> TokenTree<Span> {\n+        match self {\n             TokenTreeRef::Subtree(subtree, tt) => match tt {\n                 Some(it) => (*it).clone(),\n                 None => (*subtree).clone().into(),\n@@ -135,28 +143,28 @@ impl<'a> TokenTreeRef<'a> {\n \n /// A safe version of `Cursor` from `syn` crate <https://github.com/dtolnay/syn/blob/6533607f91686545cb034d2838beea338d9d0742/src/buffer.rs#L125>\n #[derive(Copy, Clone, Debug)]\n-pub struct Cursor<'a> {\n-    buffer: &'a TokenBuffer<'a>,\n+pub struct Cursor<'a, Span> {\n+    buffer: &'a TokenBuffer<'a, Span>,\n     ptr: EntryPtr,\n }\n \n-impl<'a> PartialEq for Cursor<'a> {\n-    fn eq(&self, other: &Cursor<'_>) -> bool {\n+impl<'a, Span> PartialEq for Cursor<'a, Span> {\n+    fn eq(&self, other: &Cursor<'_, Span>) -> bool {\n         self.ptr == other.ptr && std::ptr::eq(self.buffer, other.buffer)\n     }\n }\n \n-impl<'a> Eq for Cursor<'a> {}\n+impl<'a, Span> Eq for Cursor<'a, Span> {}\n \n-impl<'a> Cursor<'a> {\n+impl<'a, Span> Cursor<'a, Span> {\n     /// Check whether it is eof\n     pub fn eof(self) -> bool {\n         matches!(self.buffer.entry(&self.ptr), None | Some(Entry::End(None)))\n     }\n \n     /// If the cursor is pointing at the end of a subtree, returns\n     /// the parent subtree\n-    pub fn end(self) -> Option<&'a Subtree> {\n+    pub fn end(self) -> Option<&'a Subtree<Span>> {\n         match self.entry() {\n             Some(Entry::End(Some(ptr))) => {\n                 let idx = ptr.1;\n@@ -171,13 +179,13 @@ impl<'a> Cursor<'a> {\n         }\n     }\n \n-    fn entry(self) -> Option<&'a Entry<'a>> {\n+    fn entry(&self) -> Option<&'a Entry<'a, Span>> {\n         self.buffer.entry(&self.ptr)\n     }\n \n     /// If the cursor is pointing at a `Subtree`, returns\n     /// a cursor into that subtree\n-    pub fn subtree(self) -> Option<Cursor<'a>> {\n+    pub fn subtree(self) -> Option<Cursor<'a, Span>> {\n         match self.entry() {\n             Some(Entry::Subtree(_, _, entry_id)) => {\n                 Some(Cursor::create(self.buffer, EntryPtr(*entry_id, 0)))\n@@ -187,7 +195,7 @@ impl<'a> Cursor<'a> {\n     }\n \n     /// If the cursor is pointing at a `TokenTree`, returns it\n-    pub fn token_tree(self) -> Option<TokenTreeRef<'a>> {\n+    pub fn token_tree(self) -> Option<TokenTreeRef<'a, Span>> {\n         match self.entry() {\n             Some(Entry::Leaf(tt)) => match tt {\n                 TokenTree::Leaf(leaf) => Some(TokenTreeRef::Leaf(leaf, tt)),\n@@ -198,12 +206,12 @@ impl<'a> Cursor<'a> {\n         }\n     }\n \n-    fn create(buffer: &'a TokenBuffer<'_>, ptr: EntryPtr) -> Cursor<'a> {\n+    fn create(buffer: &'a TokenBuffer<'_, Span>, ptr: EntryPtr) -> Cursor<'a, Span> {\n         Cursor { buffer, ptr }\n     }\n \n     /// Bump the cursor\n-    pub fn bump(self) -> Cursor<'a> {\n+    pub fn bump(self) -> Cursor<'a, Span> {\n         if let Some(Entry::End(exit)) = self.buffer.entry(&self.ptr) {\n             match exit {\n                 Some(exit) => Cursor::create(self.buffer, *exit),\n@@ -216,7 +224,7 @@ impl<'a> Cursor<'a> {\n \n     /// Bump the cursor, if it is a subtree, returns\n     /// a cursor into that subtree\n-    pub fn bump_subtree(self) -> Cursor<'a> {\n+    pub fn bump_subtree(self) -> Cursor<'a, Span> {\n         match self.entry() {\n             Some(Entry::Subtree(_, _, _)) => self.subtree().unwrap(),\n             _ => self.bump(),"}, {"sha": "b7dbc82e1d66e2ec14859448168c189d867fdb56", "filename": "crates/tt/src/lib.rs", "status": "modified", "additions": 138, "deletions": 90, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Ftt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a46a78f2410653a7c38ce240c439993b97be61/crates%2Ftt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Flib.rs?ref=41a46a78f2410653a7c38ce240c439993b97be61", "patch": "@@ -16,45 +16,106 @@ pub use smol_str::SmolStr;\n /// which source tokens. We do it by assigning an distinct identity to each\n /// source token and making sure that identities are preserved during macro\n /// expansion.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TokenId(pub u32);\n \n+impl fmt::Debug for TokenId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n impl TokenId {\n+    pub const UNSPECIFIED: TokenId = TokenId(!0);\n     pub const fn unspecified() -> TokenId {\n-        TokenId(!0)\n+        Self::UNSPECIFIED\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum TokenTree {\n-    Leaf(Leaf),\n-    Subtree(Subtree),\n-}\n-impl_from!(Leaf, Subtree for TokenTree);\n+pub mod token_id {\n+    pub use crate::{DelimiterKind, Spacing, TokenId};\n+    pub type Span = crate::TokenId;\n+    pub type Subtree = crate::Subtree<Span>;\n+    pub type Punct = crate::Punct<Span>;\n+    pub type Delimiter = crate::Delimiter<Span>;\n+    pub type Leaf = crate::Leaf<Span>;\n+    pub type Ident = crate::Ident<Span>;\n+    pub type Literal = crate::Literal<Span>;\n+    pub type TokenTree = crate::TokenTree<Span>;\n+    pub mod buffer {\n+        pub type TokenBuffer<'a> = crate::buffer::TokenBuffer<'a, super::Span>;\n+        pub type Cursor<'a> = crate::buffer::Cursor<'a, super::Span>;\n+        pub type TokenTreeRef<'a> = crate::buffer::TokenTreeRef<'a, super::Span>;\n+    }\n \n-impl TokenTree {\n-    pub fn empty() -> Self {\n-        TokenTree::Subtree(Subtree::default())\n+    impl Delimiter {\n+        pub const UNSPECIFIED: Self = Self {\n+            open: TokenId::UNSPECIFIED,\n+            close: TokenId::UNSPECIFIED,\n+            kind: DelimiterKind::Invisible,\n+        };\n+        pub const fn unspecified() -> Self {\n+            Self::UNSPECIFIED\n+        }\n+    }\n+    impl Subtree {\n+        pub const fn empty() -> Self {\n+            Subtree { delimiter: Delimiter::unspecified(), token_trees: vec![] }\n+        }\n+    }\n+    impl TokenTree {\n+        pub const fn empty() -> Self {\n+            Self::Subtree(Subtree { delimiter: Delimiter::unspecified(), token_trees: vec![] })\n+        }\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SyntaxContext(pub u32);\n+\n+// #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+// pub struct Span {\n+//     pub id: TokenId,\n+//     pub ctx: SyntaxContext,\n+// }\n+// pub type Span = (TokenId, SyntaxContext);\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum Leaf {\n-    Literal(Literal),\n-    Punct(Punct),\n-    Ident(Ident),\n+pub enum TokenTree<Span> {\n+    Leaf(Leaf<Span>),\n+    Subtree(Subtree<Span>),\n }\n-impl_from!(Literal, Punct, Ident for Leaf);\n+impl_from!(Leaf<Span>, Subtree<Span> for TokenTree);\n \n-#[derive(Clone, PartialEq, Eq, Hash, Default)]\n-pub struct Subtree {\n-    pub delimiter: Option<Delimiter>,\n-    pub token_trees: Vec<TokenTree>,\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum Leaf<Span> {\n+    Literal(Literal<Span>),\n+    Punct(Punct<Span>),\n+    Ident(Ident<Span>),\n+}\n+\n+impl<Span> Leaf<Span> {\n+    pub fn span(&self) -> &Span {\n+        match self {\n+            Leaf::Literal(it) => &it.span,\n+            Leaf::Punct(it) => &it.span,\n+            Leaf::Ident(it) => &it.span,\n+        }\n+    }\n+}\n+impl_from!(Literal<Span>, Punct<Span>, Ident<Span> for Leaf);\n+\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct Subtree<Span> {\n+    // FIXME, this should not be Option\n+    pub delimiter: Delimiter<Span>,\n+    pub token_trees: Vec<TokenTree<Span>>,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct Delimiter {\n-    pub id: TokenId,\n+pub struct Delimiter<Span> {\n+    pub open: Span,\n+    pub close: Span,\n     pub kind: DelimiterKind,\n }\n \n@@ -63,19 +124,20 @@ pub enum DelimiterKind {\n     Parenthesis,\n     Brace,\n     Bracket,\n+    Invisible,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Literal {\n+pub struct Literal<Span> {\n     pub text: SmolStr,\n-    pub id: TokenId,\n+    pub span: Span,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Punct {\n+pub struct Punct<Span> {\n     pub char: char,\n     pub spacing: Spacing,\n-    pub id: TokenId,\n+    pub span: Span,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -85,39 +147,25 @@ pub enum Spacing {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Ident {\n-    /// Identifier or keyword. Unlike rustc, we keep \"r#\" prefix when it represents a raw identifier.\n+/// Identifier or keyword. Unlike rustc, we keep \"r#\" prefix when it represents a raw identifier.\n+pub struct Ident<Span> {\n     pub text: SmolStr,\n-    pub id: TokenId,\n+    pub span: Span,\n }\n \n-impl Ident {\n-    /// Constructor intended to be used only by proc macro server. `text` should not contain raw\n-    /// identifier prefix.\n-    pub fn new_with_is_raw(text: SmolStr, id: TokenId, is_raw: bool) -> Self {\n-        let text = if is_raw { SmolStr::from_iter([\"r#\", &text]) } else { text };\n-        Ident { text, id }\n-    }\n-}\n-\n-impl Leaf {\n-    pub fn id(&self) -> TokenId {\n-        match self {\n-            Leaf::Literal(l) => l.id,\n-            Leaf::Punct(p) => p.id,\n-            Leaf::Ident(i) => i.id,\n-        }\n-    }\n-}\n-\n-fn print_debug_subtree(f: &mut fmt::Formatter<'_>, subtree: &Subtree, level: usize) -> fmt::Result {\n+fn print_debug_subtree<Span: fmt::Debug>(\n+    f: &mut fmt::Formatter<'_>,\n+    subtree: &Subtree<Span>,\n+    level: usize,\n+) -> fmt::Result {\n     let align = \"  \".repeat(level);\n \n-    let aux = match subtree.delimiter.map(|it| (it.kind, it.id.0)) {\n-        None => \"$\".to_string(),\n-        Some((DelimiterKind::Parenthesis, id)) => format!(\"() {id}\"),\n-        Some((DelimiterKind::Brace, id)) => format!(\"{{}} {id}\"),\n-        Some((DelimiterKind::Bracket, id)) => format!(\"[] {id}\"),\n+    let Delimiter { kind, open, close } = &subtree.delimiter;\n+    let aux = match kind {\n+        DelimiterKind::Invisible => format!(\"$$ {:?} {:?}\", open, close),\n+        DelimiterKind::Parenthesis => format!(\"() {:?} {:?}\", open, close),\n+        DelimiterKind::Brace => format!(\"{{}} {:?} {:?}\", open, close),\n+        DelimiterKind::Bracket => format!(\"[] {:?} {:?}\", open, close),\n     };\n \n     if subtree.token_trees.is_empty() {\n@@ -135,21 +183,25 @@ fn print_debug_subtree(f: &mut fmt::Formatter<'_>, subtree: &Subtree, level: usi\n     Ok(())\n }\n \n-fn print_debug_token(f: &mut fmt::Formatter<'_>, tkn: &TokenTree, level: usize) -> fmt::Result {\n+fn print_debug_token<Span: fmt::Debug>(\n+    f: &mut fmt::Formatter<'_>,\n+    tkn: &TokenTree<Span>,\n+    level: usize,\n+) -> fmt::Result {\n     let align = \"  \".repeat(level);\n \n     match tkn {\n         TokenTree::Leaf(leaf) => match leaf {\n-            Leaf::Literal(lit) => write!(f, \"{align}LITERAL {} {}\", lit.text, lit.id.0)?,\n+            Leaf::Literal(lit) => write!(f, \"{}LITERAL {} {:?}\", align, lit.text, lit.span)?,\n             Leaf::Punct(punct) => write!(\n                 f,\n-                \"{}PUNCH   {} [{}] {}\",\n+                \"{}PUNCH   {} [{}] {:?}\",\n                 align,\n                 punct.char,\n                 if punct.spacing == Spacing::Alone { \"alone\" } else { \"joint\" },\n-                punct.id.0\n+                punct.span\n             )?,\n-            Leaf::Ident(ident) => write!(f, \"{align}IDENT   {} {}\", ident.text, ident.id.0)?,\n+            Leaf::Ident(ident) => write!(f, \"{}IDENT   {} {:?}\", align, ident.text, ident.span)?,\n         },\n         TokenTree::Subtree(subtree) => {\n             print_debug_subtree(f, subtree, level)?;\n@@ -159,13 +211,13 @@ fn print_debug_token(f: &mut fmt::Formatter<'_>, tkn: &TokenTree, level: usize)\n     Ok(())\n }\n \n-impl fmt::Debug for Subtree {\n+impl<Span: fmt::Debug> fmt::Debug for Subtree<Span> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         print_debug_subtree(f, self, 0)\n     }\n }\n \n-impl fmt::Display for TokenTree {\n+impl<Span> fmt::Display for TokenTree<Span> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             TokenTree::Leaf(it) => fmt::Display::fmt(it, f),\n@@ -174,13 +226,13 @@ impl fmt::Display for TokenTree {\n     }\n }\n \n-impl fmt::Display for Subtree {\n+impl<Span> fmt::Display for Subtree<Span> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (l, r) = match self.delimiter_kind() {\n-            Some(DelimiterKind::Parenthesis) => (\"(\", \")\"),\n-            Some(DelimiterKind::Brace) => (\"{\", \"}\"),\n-            Some(DelimiterKind::Bracket) => (\"[\", \"]\"),\n-            None => (\"\", \"\"),\n+        let (l, r) = match self.delimiter.kind {\n+            DelimiterKind::Parenthesis => (\"(\", \")\"),\n+            DelimiterKind::Brace => (\"{\", \"}\"),\n+            DelimiterKind::Bracket => (\"[\", \"]\"),\n+            DelimiterKind::Invisible => (\"\", \"\"),\n         };\n         f.write_str(l)?;\n         let mut needs_space = false;\n@@ -202,7 +254,7 @@ impl fmt::Display for Subtree {\n     }\n }\n \n-impl fmt::Display for Leaf {\n+impl<Span> fmt::Display for Leaf<Span> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Leaf::Ident(it) => fmt::Display::fmt(it, f),\n@@ -212,25 +264,25 @@ impl fmt::Display for Leaf {\n     }\n }\n \n-impl fmt::Display for Ident {\n+impl<Span> fmt::Display for Ident<Span> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.text, f)\n     }\n }\n \n-impl fmt::Display for Literal {\n+impl<Span> fmt::Display for Literal<Span> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.text, f)\n     }\n }\n \n-impl fmt::Display for Punct {\n+impl<Span> fmt::Display for Punct<Span> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.char, f)\n     }\n }\n \n-impl Subtree {\n+impl<Span> Subtree<Span> {\n     /// Count the number of tokens recursively\n     pub fn count(&self) -> usize {\n         let children_count = self\n@@ -244,20 +296,16 @@ impl Subtree {\n \n         self.token_trees.len() + children_count\n     }\n-\n-    pub fn delimiter_kind(&self) -> Option<DelimiterKind> {\n-        self.delimiter.map(|it| it.kind)\n-    }\n }\n \n-impl Subtree {\n+impl<Span> Subtree<Span> {\n     /// A simple line string used for debugging\n     pub fn as_debug_string(&self) -> String {\n-        let delim = match self.delimiter_kind() {\n-            Some(DelimiterKind::Brace) => (\"{\", \"}\"),\n-            Some(DelimiterKind::Bracket) => (\"[\", \"]\"),\n-            Some(DelimiterKind::Parenthesis) => (\"(\", \")\"),\n-            None => (\" \", \" \"),\n+        let delim = match self.delimiter.kind {\n+            DelimiterKind::Brace => (\"{\", \"}\"),\n+            DelimiterKind::Bracket => (\"[\", \"]\"),\n+            DelimiterKind::Parenthesis => (\"(\", \")\"),\n+            DelimiterKind::Invisible => (\"$\", \"$\"),\n         };\n \n         let mut res = String::new();\n@@ -275,7 +323,7 @@ impl Subtree {\n                         (Leaf::Ident(_), Some(&TokenTree::Leaf(Leaf::Ident(_)))) => {\n                             \" \".to_string() + &s\n                         }\n-                        (Leaf::Punct(_), Some(&TokenTree::Leaf(Leaf::Punct(punct)))) => {\n+                        (Leaf::Punct(_), Some(TokenTree::Leaf(Leaf::Punct(punct)))) => {\n                             if punct.spacing == Spacing::Alone {\n                                 \" \".to_string() + &s\n                             } else {\n@@ -298,19 +346,19 @@ impl Subtree {\n \n pub mod buffer;\n \n-pub fn pretty(tkns: &[TokenTree]) -> String {\n-    fn tokentree_to_text(tkn: &TokenTree) -> String {\n+pub fn pretty<Span>(tkns: &[TokenTree<Span>]) -> String {\n+    fn tokentree_to_text<Span>(tkn: &TokenTree<Span>) -> String {\n         match tkn {\n             TokenTree::Leaf(Leaf::Ident(ident)) => ident.text.clone().into(),\n             TokenTree::Leaf(Leaf::Literal(literal)) => literal.text.clone().into(),\n             TokenTree::Leaf(Leaf::Punct(punct)) => format!(\"{}\", punct.char),\n             TokenTree::Subtree(subtree) => {\n                 let content = pretty(&subtree.token_trees);\n-                let (open, close) = match subtree.delimiter.map(|it| it.kind) {\n-                    None => (\"\", \"\"),\n-                    Some(DelimiterKind::Brace) => (\"{\", \"}\"),\n-                    Some(DelimiterKind::Parenthesis) => (\"(\", \")\"),\n-                    Some(DelimiterKind::Bracket) => (\"[\", \"]\"),\n+                let (open, close) = match subtree.delimiter.kind {\n+                    DelimiterKind::Brace => (\"{\", \"}\"),\n+                    DelimiterKind::Bracket => (\"[\", \"]\"),\n+                    DelimiterKind::Parenthesis => (\"(\", \")\"),\n+                    DelimiterKind::Invisible => (\"\", \"\"),\n                 };\n                 format!(\"{open}{content}{close}\")\n             }"}]}