{"sha": "ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "node_id": "C_kwDOAAsO6NoAKGVjZGRjMjZiMGVjNGZjZjIzZTA2NmYyZjg5MmM0MGMxYmViMmY1YWQ", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2022-06-13T03:03:05Z"}, "committer": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2022-06-13T03:03:05Z"}, "message": "Merge commit '7b73b60faca71d01d900e49831fcb84553e93019' into sync-rustfmt", "tree": {"sha": "1b94fc48d14662c5c21e1fe5ccc614a197a6da16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b94fc48d14662c5c21e1fe5ccc614a197a6da16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "html_url": "https://github.com/rust-lang/rust/commit/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fb9603022fe20814d3b7980a3c88299b8e1f747", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb9603022fe20814d3b7980a3c88299b8e1f747", "html_url": "https://github.com/rust-lang/rust/commit/1fb9603022fe20814d3b7980a3c88299b8e1f747"}, {"sha": "7b73b60faca71d01d900e49831fcb84553e93019", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b73b60faca71d01d900e49831fcb84553e93019", "html_url": "https://github.com/rust-lang/rust/commit/7b73b60faca71d01d900e49831fcb84553e93019"}], "stats": {"total": 14076, "additions": 12890, "deletions": 1186}, "files": [{"sha": "4d8899b434bbe8c03abd5bd09cb576f7af460a07", "filename": "src/tools/rustfmt/.github/workflows/integration.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fintegration.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fintegration.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fintegration.yml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -69,7 +69,7 @@ jobs:\n \n     steps:\n     - name: checkout\n-      uses: actions/checkout@v2\n+      uses: actions/checkout@v3\n \n       # Run build\n     - name: install rustup"}, {"sha": "6a3f9d89d98fc0420eb2683e4ee5bf6325466eb0", "filename": "src/tools/rustfmt/.github/workflows/linux.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Flinux.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Flinux.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Flinux.yml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -26,7 +26,7 @@ jobs:\n \n     steps:\n     - name: checkout\n-      uses: actions/checkout@v2\n+      uses: actions/checkout@v3\n \n       # Run build\n     - name: install rustup"}, {"sha": "7dfda3142ca9deee9543ac954b07b314a931f197", "filename": "src/tools/rustfmt/.github/workflows/mac.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fmac.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fmac.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fmac.yml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -23,7 +23,7 @@ jobs:\n \n     steps:\n     - name: checkout\n-      uses: actions/checkout@v2\n+      uses: actions/checkout@v3\n \n       # Run build\n     - name: install rustup"}, {"sha": "cd0c3218971e2edfd8bc99b32f863f92b14c144d", "filename": "src/tools/rustfmt/.github/workflows/rustdoc_check.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Frustdoc_check.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Frustdoc_check.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Frustdoc_check.yml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -11,7 +11,7 @@ jobs:\n     name: rustdoc check\n     steps:\n     - name: checkout\n-      uses: actions/checkout@v2\n+      uses: actions/checkout@v3\n \n     - name: install rustup\n       run: |"}, {"sha": "25699234a1ec357938d2efe2b5164add20758f5d", "filename": "src/tools/rustfmt/.github/workflows/upload-assets.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fupload-assets.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fupload-assets.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fupload-assets.yml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -31,7 +31,7 @@ jobs:\n             target: x86_64-pc-windows-msvc\n     runs-on: ${{ matrix.os }}\n     steps:\n-      - uses: actions/checkout@v2\n+      - uses: actions/checkout@v3\n \n         # Run build\n       - name: install rustup"}, {"sha": "4ebc2963849058f9ef2b859ec4559f8cd9c1b4c7", "filename": "src/tools/rustfmt/.github/workflows/windows.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fwindows.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fwindows.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fwindows.yml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -33,7 +33,7 @@ jobs:\n     - name: disable git eol translation\n       run: git config --global core.autocrlf false\n     - name: checkout\n-      uses: actions/checkout@v2\n+      uses: actions/checkout@v3\n \n       # Run build\n     - name: Install Rustup using win.rustup.rs"}, {"sha": "bfc155cd656a6f1d624d2bb5b54b489d95968fed", "filename": "src/tools/rustfmt/CHANGELOG.md", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FCHANGELOG.md?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -2,9 +2,82 @@\n \n ## [Unreleased]\n \n-### Fixed\n+## [1.5.0] 2022-06-13\n+\n+### Changed\n+\n+- Simplify the rustfmt help text by eliding the full path to the rustfmt binary path from the usage string when running `rustfmt --help` [#5214](https://github.com/rust-lang/rustfmt/issues/5214)\n+\n+### Fixed\n+\n+- Remove duplicate imports when `imports_granularity` is set to `Item` [#4725](https://github.com/rust-lang/rustfmt/issues/4725)\n+- Properly handle stdin input containing an inner skip attribute [#5368](https://github.com/rust-lang/rustfmt/issues/5368)\n+- Maintain attributes on imports when `imports_granularity` is set to `Item` [#5030](https://github.com/rust-lang/rustfmt/issues/5030)\n+- Format empty trait definitions as a single line when both `empty_item_single_line` is enabled and `brace_style` is set to `AlwaysNextLine` [#5047](https://github.com/rust-lang/rustfmt/issues/5047)\n+- Don't change granularity of imports containing comments with `imports_granularity` if doing so could lose or misplace those comments [#5311](https://github.com/rust-lang/rustfmt/pull/5311)\n+- Prevent rustfmt from removing trailing comments at the end of files annotated with inner `#![rustfmt::skip]` attributes [#5033](https://github.com/rust-lang/rustfmt/issues/5033)\n+- Fixed various `error[internal]: left behind trailing whitespace\"` issues:\n+  - Remove trailing whitespace when formatting a where clause who's bounds have an empty right hand side [#5012](https://github.com/rust-lang/rustfmt/issues/5012) [#4850](https://github.com/rust-lang/rustfmt/issues/4850)\n+  - Prevent rustfmt from adding an empty comment line when rewriting markdown lists at the start of doc comments. This issue was triggered when `wrap_comments=true` [#5088](https://github.com/rust-lang/rustfmt/issues/5088)\n+- Prevent adding a block indented newline before a function parameter with a complex type that was formatted over multiple lines [#5125](https://github.com/rust-lang/rustfmt/issues/5125)\n+- Fix various module resolution issues preventing rustfmt from finding modules that should be formatted:\n+  - Handle external mods imported via external->inline load hierarchy [#5063](https://github.com/rust-lang/rustfmt/issues/5063)\n+  - Resolve sub modules of integration tests [#5119](https://github.com/rust-lang/rustfmt/issues/5119)\n+  - Module resolution will fallback to the current search directory if a relative directory search results in a `FileNotFound` error [#5198](https://github.com/rust-lang/rustfmt/issues/5198)\n+- Give users a clearer error message when resolving a module who's file path is ambiguous (e.g `x.rs` and `x/mod.rs`). Before users were given a `File not found` error message which was confusing [#5167](https://github.com/rust-lang/rustfmt/issues/5167)\n+- Fix various issues related to type aliases:\n+  - Prevent rustfmt from adding `= impl` to associated types defined in macro bodies [#4823](https://github.com/rust-lang/rustfmt/issues/4823)\n+  - Properly block indent type alias impl traits (TAITs) that wrap to the next line when `version=Two` is set. Before any trait bounds that wrapped to the next line would not be indented [#5027](https://github.com/rust-lang/rustfmt/issues/5027)\n+  - Prevent rustfmt from adding an `impl Trait` definition into types [#5086](https://github.com/rust-lang/rustfmt/issues/5086)\n+- Fix cases where `normalize_comments=true` would de-normalizes some comments by changing inline comments into block comments [#4909](https://github.com/rust-lang/rustfmt/issues/4909)\n+- Prevent rustfmt from wrapping the content of markdown [reference-style links](https://www.markdownguide.org/basic-syntax/#reference-style-links) in doc comments [#5095](https://github.com/rust-lang/rustfmt/issues/5095) [#4933](https://github.com/rust-lang/rustfmt/issues/4933)\n+- Don't format files annotated with inner `#![rustfmt::skip]` attribute [PR #5094](https://github.com/rust-lang/rustfmt/pull/5094)\n+- Prevent duplicate comma when struct pattern ends with `..` and `trailing_comma=Always`. For example, `let Foo { a, .. } = b;` would become `let Foo { a,, .. } = b;` [#5066](https://github.com/rust-lang/rustfmt/issues/5066)\n+- Fix the order of `static` and `async` keywords when rewriting static async closures. The correct order is `static` and then `async` (e.g `static async || {}`) [#5149](https://github.com/rust-lang/rustfmt/issues/5149)\n+- Retain the fully qualified path segment when rewriting struct literals in expression position. Now `<Struct as Trait>::Type` is not rewritten as `Trait::Type` [#5151](https://github.com/rust-lang/rustfmt/issues/5151)\n+- Do not remove match arm braces from a match arm with a single `ast::ExprKind::Block` that has leading attributes. Removing the braces could lead to code that does not compile. Now rustfmt will leave the outer `{}` in place when formatting `=> {#[allow(unsafe_code)]unsafe {}}` [#4109](https://github.com/rust-lang/rustfmt/issues/4109)\n+- Backport json emitter and stdin changes [PR #5054](https://github.com/rust-lang/rustfmt/pull/5054)\n+  - Make `--check` work when running rustfmt with input from stdin [PR #3896](https://github.com/rust-lang/rustfmt/pull/3896)\n+  - Fix `--check` with the `--files-with-diff` flag [PR #3910](https://github.com/rust-lang/rustfmt/pull/3910)\n+  - Produce valid JSON when using the JSON emitter [PR #3953](https://github.com/rust-lang/rustfmt/pull/3953)\n+  - Fix newlines in JSON output [PR #4262](https://github.com/rust-lang/rustfmt/pull/4262)\n+  - Use `<stdin>` when emitting stdin as filename [PR #4298](https://github.com/rust-lang/rustfmt/pull/4298)\n+- Always generate some output when formatting `@generated` files via stdin even when `format_generated_files=false`. Not producing output caused rust-analyzer to delete the file content [rust-lang/rust-analyzer](https://github.com/rust-lang/rust-analyzer/issues/11285) [#5172](https://github.com/rust-lang/rustfmt/issues/5172)\n+- Properly block indent multi-line comments in empty struct definitions. Previously, only the first comment line would be block indented. All other comment lines would be aligned with the struct definition [#4854](https://github.com/rust-lang/rustfmt/issues/4854)\n+- Prevent rustfmt from wrapping a comment at a byte position inside a non-ascii character when `wrap_comments=true`. This prevents rustfmt from panicking when breaking on the invalid position [#5023](https://github.com/rust-lang/rustfmt/issues/5023)\n+- Prevent rustfmt from removing commented out trailing separators (e.g commas) when rewriting lists. For example, remove the comma from a comment like this `// ...,` would lead to a scenario where the entire list could not be rewritten because the content of the comment changed [#5042](https://github.com/rust-lang/rustfmt/issues/5042)\n+- Fix panic when `import_granularity` was set to `Module`, `One`, or `Crate` and the import use declaration contained an alias `use crate a::b as b1` [#5131](https://github.com/rust-lang/rustfmt/issues/5131)\n+- Add a newline between generic parameters and their doc comments to prevent the generic parameters from being merged into their doc comments [#5122](https://github.com/rust-lang/rustfmt/issues/5122)\n+- Fixes indentation issue where string literals manually broken with line continuation characters (`\\`) would be incorrectly indented in macro definitions when setting `format_strings=true`[#4036](https://github.com/rust-lang/rustfmt/issues/4036)\n+- Properly wrap and format long markdown block quotes when `wrap_comments=true` [#5157](https://github.com/rust-lang/rustfmt/issues/5157)\n+- Prevent rustfmt from wrapping markdown headers even when `wrap_comments=true`. Wrapping the markdown headers would prevent them from being properly rendered with rustdoc [#5238](https://github.com/rust-lang/rustfmt/issues/5238)\n+- Prevent rustfmt from removing commas between struct fields when those fields were also separated by an empty line [#4791](https://github.com/rust-lang/rustfmt/issues/4791) [#4928](https://github.com/rust-lang/rustfmt/issues/4928)\n+- Fix compiler error caused when formatting imports with `imports_granularity=Module` and a path containing `self`. Given the following import `use crate::lexer::{self, tokens::TokenData};`, rustfmt would transform the `self` import into `use crate::lexer::self;`. Now rustfmt produces `use crate::lexer::{self};` [#4681](https://github.com/rust-lang/rustfmt/issues/4681)\n+- Prevent rustfmt from breaking long type links in doc comments on namespace qualifiers (`::`) when `wrap_comments=true`. Breaking these long type links over multiple lines prevented them from being properly rendered in rustdoc [#5260](https://github.com/rust-lang/rustfmt/issues/5260)\n+- Correctly find the start of struct bodies after any generic `const` parameters. Naively searching for an opening `{` lead to issues since generic `const` parameters are also defined with `{}` (e.g. `struct Example<const N: usize = { 1048576 }> {}`) [#5273](https://github.com/rust-lang/rustfmt/issues/5273)\n+- Prevent rustfmt from merging derives when using inner or outer `rustfmt::skip::attributes` attributes. For example, `#[rustfmt::skip::attributes(derive)]` [#5270](https://github.com/rust-lang/rustfmt/issues/5270)\n+- Retain trailing `;` when rewriting macro calls in extern blocks. For example, `extern \"C\" { x!(-); }`[#5281](https://github.com/rust-lang/rustfmt/issues/5281)\n+- Add a newline when formatting struct fields preceded by both doc comments and inline comments to prevent the field from being merged into the inline comment. This was not an issue when a struct was preceded by just a doc comment or just an inline comment [#5215](https://github.com/rust-lang/rustfmt/issues/5215)\n+\n+### Added\n+\n+- Added `One` as a new [group_imports](https://rust-lang.github.io/rustfmt/?version=v1.4.38&search=#group_imports) option to create a single group for all imports [PR #4966](https://github.com/rust-lang/rustfmt/pull/4966)\n+- Add [short_array_element_width_threshold](https://rust-lang.github.io/rustfmt/?version=v1.4.38&search=#short_array_element_width_threshold) config option to give users more control over when `Mixed` list formatting is used [PR #5228](https://github.com/rust-lang/rustfmt/pull/5228)\n \n-- Fixes issue where wrapped strings would be incorrectly indented in macro defs when `format_strings` was enabled [#4036](https://github.com/rust-lang/rustfmt/issues/4036)\n+### Removed\n+\n+- Removed unstable, nightly-only config option `report_todo` [#5101](https://github.com/rust-lang/rustfmt/issues/5101)\n+- Removed unstable, nightly-only config option `report_fixme` [#5102](https://github.com/rust-lang/rustfmt/issues/5102)\n+- Removed unstable, nightly-only config option `license_template_path` [#5103](https://github.com/rust-lang/rustfmt/issues/5103)\n+\n+### Misc\n+\n+- Improved performance when formatting large and deeply nested expression trees, often found in generated code, which have many expressions that exceed `max_width` [#5128](https://github.com/rust-lang/rustfmt/issues/5128), [#4867](https://github.com/rust-lang/rustfmt/issues/4867), [#4476](https://github.com/rust-lang/rustfmt/issues/4476), [#5139](https://github.com/rust-lang/rustfmt/pull/5139)\n+\n+### Install/Download Options\n+- **rustup (nightly)** - *pending*\n+- **GitHub Release Binaries** - [Release v1.5.0](https://github.com/rust-lang/rustfmt/releases/tag/v1.5.0)\n+- **Build from source** - [Tag v1.5.0](https://github.com/rust-lang/rustfmt/tree/v1.5.0), see instructions for how to [install rustfmt from source][install-from-source]\n \n ## [1.4.38] 2021-10-20\n "}, {"sha": "639d35886dcda98c799a6b74a575115608dbf21b", "filename": "src/tools/rustfmt/Cargo.lock", "status": "modified", "additions": 212, "deletions": 203, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FCargo.lock?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -4,64 +4,57 @@ version = 3\n \n [[package]]\n name = \"aho-corasick\"\n-version = \"0.7.6\"\n+version = \"0.7.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"58fb5e95d83b38284460a5fda7d6470aa0b8844d283a0b614b8535e880800d2d\"\n+checksum = \"1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f\"\n dependencies = [\n  \"memchr\",\n ]\n \n [[package]]\n name = \"annotate-snippets\"\n-version = \"0.8.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n+checksum = \"c3b9d411ecbaf79885c6df4d75fff75858d5995ff25385657a28af47e82f9c36\"\n dependencies = [\n+ \"unicode-width\",\n  \"yansi-term\",\n ]\n \n-[[package]]\n-name = \"ansi_term\"\n-version = \"0.11.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"anyhow\"\n-version = \"1.0.25\"\n+version = \"1.0.56\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9267dff192e68f3399525901e709a48c1d3982c9c072fa32f2127a0cb0babf14\"\n+checksum = \"4361135be9122e0870de935d7c439aef945b9f9ddd4199a553b5270b49c82a27\"\n \n [[package]]\n name = \"atty\"\n-version = \"0.2.13\"\n+version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1803c647a3ec87095e7ae7acfca019e98de5ec9a7d01343f611cf3152ed71a90\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n dependencies = [\n+ \"hermit-abi\",\n  \"libc\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"autocfg\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n+checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n \n [[package]]\n name = \"bitflags\"\n-version = \"1.2.1\"\n+version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"bstr\"\n-version = \"0.2.8\"\n+version = \"0.2.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d6c2c5b58ab920a4f5aeaaca34b4488074e8cc7596af94e6f8c6ff247c60245\"\n+checksum = \"ba3569f383e8f1598449f1a423e72e99569137b47740b1da11ef19af3d5c3223\"\n dependencies = [\n  \"memchr\",\n ]\n@@ -77,27 +70,27 @@ dependencies = [\n \n [[package]]\n name = \"camino\"\n-version = \"1.0.5\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"52d74260d9bf6944e2208aa46841b4b8f0d7ffc0849a06837b2f510337f86b2b\"\n+checksum = \"6f3132262930b0522068049f5870a856ab8affc80c70d08b6ecb785771a6fc23\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"cargo-platform\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0226944a63d1bf35a3b5f948dd7c59e263db83695c9e8bffc4037de02e30f1d7\"\n+checksum = \"cbdb825da8a5df079a43676dbe042702f1707b1109f713a01420fbb4cc71fa27\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.14.0\"\n+version = \"0.14.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c297bd3135f558552f99a0daa180876984ea2c4ffa7470314540dff8c654109a\"\n+checksum = \"4acbb09d9ee8e23699b9634375c72795d095bf268439da88562cf9b501f181fa\"\n dependencies = [\n  \"camino\",\n  \"cargo-platform\",\n@@ -106,12 +99,6 @@ dependencies = [\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n@@ -120,35 +107,49 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.33.0\"\n+version = \"3.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n+checksum = \"71c47df61d9e16dc010b55dba1952a57d8c215dbb533fd13cdd13369aac73b1c\"\n dependencies = [\n- \"ansi_term\",\n  \"atty\",\n  \"bitflags\",\n+ \"clap_derive\",\n+ \"indexmap\",\n+ \"lazy_static\",\n+ \"os_str_bytes\",\n  \"strsim\",\n+ \"termcolor\",\n  \"textwrap\",\n- \"unicode-width\",\n- \"vec_map\",\n+]\n+\n+[[package]]\n+name = \"clap_derive\"\n+version = \"3.1.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a3aab4734e083b809aaf5794e14e756d1c798d2c69c7f7de7a09a2f5214993c1\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.3\"\n+version = \"0.8.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e7e9d99fa91428effe99c5c6d4634cdeba32b8cf784fc428a2a687f61a952c49\"\n+checksum = \"0bf124c720b7686e3c2663cf54062ab0f68a88af2fb6a030e87e30bf721fcb38\"\n dependencies = [\n- \"autocfg\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"derive-new\"\n-version = \"0.5.8\"\n+version = \"0.5.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n+checksum = \"3418329ca0ad70234b9735dc4ceed10af4df60eff9c8e7b06cb5e520d92c3535\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -157,25 +158,45 @@ dependencies = [\n \n [[package]]\n name = \"diff\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a\"\n+checksum = \"0e25ea47919b1560c4e3b7fe0aaab9becf5b84a10325ddf7db0f0ba5e1026499\"\n \n [[package]]\n name = \"dirs\"\n-version = \"2.0.2\"\n+version = \"4.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"13aea89a5c93364a98e9b37b2fa237effbb694d5cfe01c5b70941f7eb087d5e3\"\n+checksum = \"ca3aa72a6f96ea37bbc5aa912f6788242832f75369bdfdadcb0e38423f100059\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n  \"dirs-sys\",\n ]\n \n+[[package]]\n+name = \"dirs-next\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"dirs-sys-next\",\n+]\n+\n [[package]]\n name = \"dirs-sys\"\n-version = \"0.3.6\"\n+version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"03d86534ed367a67548dc68113a0f5db55432fdfbb6e6f9d77704397d95d5780\"\n+checksum = \"1b1d1d91c932ef41c0f2663aa8b0ca0342d444d842c06914aa0a7e352d0bada6\"\n+dependencies = [\n+ \"libc\",\n+ \"redox_users\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"dirs-sys-next\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d\"\n dependencies = [\n  \"libc\",\n  \"redox_users\",\n@@ -184,15 +205,15 @@ dependencies = [\n \n [[package]]\n name = \"either\"\n-version = \"1.5.3\"\n+version = \"1.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb1f6b1ce1c140482ea30ddd3335fc0024ac7ee112895426e0a629a6c20adfe3\"\n+checksum = \"e78d4f1cc4ae33bbfc157ed5d5a5ef3bc29227303d595861deb238fcec4e9457\"\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.8.1\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54532e3223c5af90a6a757c90b5c5521564b07e5e7a958681bcd2afad421cdcd\"\n+checksum = \"0b2cf0344971ee6c64c31be0d530793fba457d322dfec2810c453d0ef228f9c3\"\n dependencies = [\n  \"atty\",\n  \"humantime\",\n@@ -203,9 +224,9 @@ dependencies = [\n \n [[package]]\n name = \"fnv\"\n-version = \"1.0.6\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n+checksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n \n [[package]]\n name = \"getopts\"\n@@ -218,20 +239,20 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.3\"\n+version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n+checksum = \"9be70c98951c83b8d2f8f60d7065fa6d5146873094452a1008da8c2f1e4205ad\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"libc\",\n  \"wasi\",\n ]\n \n [[package]]\n name = \"globset\"\n-version = \"0.4.6\"\n+version = \"0.4.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c152169ef1e421390738366d2f796655fec62621dabbd0fd476f905934061e4a\"\n+checksum = \"10463d9ff00a2a068db14231982f5132edebad0d7660cd956a1c30292dbcbfbd\"\n dependencies = [\n  \"aho-corasick\",\n  \"bstr\",\n@@ -240,13 +261,25 @@ dependencies = [\n  \"regex\",\n ]\n \n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.11.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+\n [[package]]\n name = \"heck\"\n-version = \"0.3.1\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n+checksum = \"2540771e65fc8cb83cd6e8a237f70c319bd5c29f78ed1084ba5d50eeac86f7f9\"\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n dependencies = [\n- \"unicode-segmentation\",\n+ \"libc\",\n ]\n \n [[package]]\n@@ -257,9 +290,9 @@ checksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n \n [[package]]\n name = \"ignore\"\n-version = \"0.4.17\"\n+version = \"0.4.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b287fb45c60bb826a0dc68ff08742b9d88a2fea13d6e0c286b3172065aaf878c\"\n+checksum = \"713f1b139373f96a2e0ce3ac931cd01ee973c3c5dd7c40c0c2efe96ad2b6751d\"\n dependencies = [\n  \"crossbeam-utils\",\n  \"globset\",\n@@ -273,6 +306,16 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"indexmap\"\n+version = \"1.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0f647032dfaa1f8b6dc29bd3edb7bbef4861b8b8007ebb118d6db284fd59f6ee\"\n+dependencies = [\n+ \"autocfg\",\n+ \"hashbrown\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.10.3\"\n@@ -284,9 +327,9 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"0.4.4\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"501266b7edd0174f8530248f87f99c88fbe60ca4ef3dd486835b8d8d53136f7f\"\n+checksum = \"1aab8fc367588b89dcee83ab0fd66b72b50b72fa1904d7095045ace2b0c81c35\"\n \n [[package]]\n name = \"lazy_static\"\n@@ -296,9 +339,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.77\"\n+version = \"0.2.122\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f2f96b10ec2560088a8e76961b00d47107b3a625fecb76dedb29ee7ccbf98235\"\n+checksum = \"ec647867e2bf0772e28c8bcde4f0d19a9216916e890543b5a03ed8ef27b8f259\"\n \n [[package]]\n name = \"libm\"\n@@ -308,34 +351,49 @@ checksum = \"7fc7aa29613bd6a620df431842069224d8bc9011086b1db4c0e0cd47fa03ec9a\"\n \n [[package]]\n name = \"log\"\n-version = \"0.4.14\"\n+version = \"0.4.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n+checksum = \"6389c490849ff5bc16be905ae24bc913a9c8892e19b2341dbc175e14c341c2b8\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n name = \"memchr\"\n-version = \"2.2.1\"\n+version = \"2.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+\n+[[package]]\n+name = \"once_cell\"\n+version = \"1.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"\n+\n+[[package]]\n+name = \"os_str_bytes\"\n+version = \"6.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"88579771288728879b57485cc7d6b07d648c9f0141eb955f8ab7f9d45394468e\"\n+checksum = \"8e22443d1643a904602595ba1cd8f7d896afe56d26712531c5ff73a15b2fbf64\"\n+dependencies = [\n+ \"memchr\",\n+]\n \n [[package]]\n name = \"packed_simd_2\"\n-version = \"0.3.4\"\n+version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3278e0492f961fd4ae70909f56b2723a7e8d01a228427294e19cdfdebda89a17\"\n+checksum = \"defdcfef86dcc44ad208f71d9ff4ce28df6537a4e0d6b0e8e845cb8ca10059a6\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"libm\",\n ]\n \n [[package]]\n name = \"proc-macro-error\"\n-version = \"0.4.11\"\n+version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e7959c6467d962050d639361f7703b2051c43036d03493c36f01d440fdd3138a\"\n+checksum = \"da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c\"\n dependencies = [\n  \"proc-macro-error-attr\",\n  \"proc-macro2\",\n@@ -346,71 +404,69 @@ dependencies = [\n \n [[package]]\n name = \"proc-macro-error-attr\"\n-version = \"0.4.11\"\n+version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e4002d9f55991d5e019fb940a90e1a95eb80c24e77cb2462dd4dc869604d543a\"\n+checksum = \"a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n- \"syn-mid\",\n  \"version_check\",\n ]\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.26\"\n+version = \"1.0.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a152013215dca273577e18d2bf00fa862b89b24169fb78c4c95aeb07992c9cec\"\n+checksum = \"ec757218438d5fda206afc041538b2f6d889286160d649a86a24d37e1235afd1\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.6\"\n+version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54a21852a652ad6f610c9510194f398ff6f8692e334fd1145fed931f7fbe44ea\"\n+checksum = \"632d02bff7f874a36f33ea8bb416cd484b90cc66c1194b1a1110d067a7013f58\"\n dependencies = [\n  \"proc-macro2\",\n ]\n \n [[package]]\n name = \"redox_syscall\"\n-version = \"0.2.4\"\n+version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"05ec8ca9416c5ea37062b502703cd7fcb207736bc294f6e0cf367ac6fc234570\"\n+checksum = \"62f25bc4c7e55e0b0b7a1d43fb893f4fa1361d0abe38b9ce4f323c2adfe6ef42\"\n dependencies = [\n  \"bitflags\",\n ]\n \n [[package]]\n name = \"redox_users\"\n-version = \"0.4.0\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n+checksum = \"b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b\"\n dependencies = [\n  \"getrandom\",\n  \"redox_syscall\",\n+ \"thiserror\",\n ]\n \n [[package]]\n name = \"regex\"\n-version = \"1.4.3\"\n+version = \"1.5.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9251239e129e16308e70d853559389de218ac275b515068abc96829d05b948a\"\n+checksum = \"1a11647b6b25ff05a515cb92c365cec08801e83423a235b51e231e1808747286\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n  \"regex-syntax\",\n- \"thread_local\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.22\"\n+version = \"0.6.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b5eb417147ba9860a96cfe72a0b93bf88fee1744b5636ec99ab20c1aa9376581\"\n+checksum = \"f497285884f3fcff424ffc933e56d7cbca511def0c9831a7f9b5f6153e3cc89b\"\n \n [[package]]\n name = \"rustc-workspace-hack\"\n@@ -429,12 +485,13 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.38\"\n+version = \"1.5.0\"\n dependencies = [\n  \"annotate-snippets\",\n  \"anyhow\",\n  \"bytecount\",\n  \"cargo_metadata\",\n+ \"clap\",\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n@@ -449,7 +506,6 @@ dependencies = [\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n  \"serde_json\",\n- \"structopt\",\n  \"term\",\n  \"thiserror\",\n  \"toml\",\n@@ -458,44 +514,50 @@ dependencies = [\n  \"unicode_categories\",\n ]\n \n+[[package]]\n+name = \"rustversion\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f2cc38e8fa666e2de3c4aba7edeb5ffc5246c1c2ed0e3d17e560aeeba736b23f\"\n+\n [[package]]\n name = \"ryu\"\n-version = \"1.0.2\"\n+version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bfa8506c1de11c9c4e4c38863ccbe02a305c8188e85a05a784c9e11e1c3910c8\"\n+checksum = \"73b4b750c782965c211b42f022f59af1fbceabdd026623714f104152f1ec149f\"\n \n [[package]]\n name = \"same-file\"\n-version = \"1.0.5\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"585e8ddcedc187886a30fa705c47985c3fa88d06624095856b36ca0b82ff4421\"\n+checksum = \"93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502\"\n dependencies = [\n  \"winapi-util\",\n ]\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.4\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"568a8e6258aa33c13358f81fd834adb854c6f7c9468520910a9b1e8fac068012\"\n+checksum = \"d65bd28f48be7196d222d95b9243287f48d27aca604e08497513019ff0502cc4\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.126\"\n+version = \"1.0.136\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec7505abeacaec74ae4778d9d9328fe5a5d04253220a85c4ee022239fc996d03\"\n+checksum = \"ce31e24b01e1e524df96f1c2fdd054405f8d7376249a5110886fb4b658484789\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.126\"\n+version = \"1.0.136\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"963a7dbc9895aeac7ac90e74f34a5d5261828f79df35cbed41e10189d3804d43\"\n+checksum = \"08597e7152fcd306f41838ed3e37be9eaeed2b61c42e2117266a554fab4662f9\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -504,9 +566,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.59\"\n+version = \"1.0.79\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dcac07dbffa1c65e7f816ab9eba78eb142c6d44410f4eeba1e26e4f5dfa56b95\"\n+checksum = \"8e8d9fa5c3b304765ce1fd9c4c8a3de2c8db365a5b91be52f186efc675681d95\"\n dependencies = [\n  \"itoa\",\n  \"ryu\",\n@@ -515,98 +577,61 @@ dependencies = [\n \n [[package]]\n name = \"strsim\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n-\n-[[package]]\n-name = \"structopt\"\n-version = \"0.3.11\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3fe43617218c0805c6eb37160119dc3c548110a67786da7218d1c6555212f073\"\n-dependencies = [\n- \"clap\",\n- \"lazy_static\",\n- \"structopt-derive\",\n-]\n-\n-[[package]]\n-name = \"structopt-derive\"\n-version = \"0.4.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c6e79c80e0f4efd86ca960218d4e056249be189ff1c42824dcd9a7f51a56f0bd\"\n-dependencies = [\n- \"heck\",\n- \"proc-macro-error\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n+checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.65\"\n+version = \"1.0.91\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f3a1d708c221c5a612956ef9f75b37e454e88d1f7b899fbd3a18d4252012d663\"\n+checksum = \"b683b2b825c8eef438b77c36a06dc262294da3d5a5813fac20da149241dcd44d\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"unicode-xid\",\n ]\n \n-[[package]]\n-name = \"syn-mid\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7be3539f6c128a931cf19dcee741c1af532c7fd387baa739c03dd2e96479338a\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"term\"\n-version = \"0.6.1\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c0863a3345e70f61d613eab32ee046ccd1bcc5f9105fe402c61fcd0c13eeb8b5\"\n+checksum = \"c59df8ac95d96ff9bede18eb7300b0fda5e5d8d90960e76f8e14ae765eedbf1f\"\n dependencies = [\n- \"dirs\",\n+ \"dirs-next\",\n+ \"rustversion\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"termcolor\"\n-version = \"1.0.5\"\n+version = \"1.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"96d6098003bde162e4277c70665bd87c326f5a0c3f3fbfb285787fa482d54e6e\"\n+checksum = \"bab24d30b911b2376f3a13cc2cd443142f0c81dda04c118693e35b3835757755\"\n dependencies = [\n- \"wincolor\",\n+ \"winapi-util\",\n ]\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.11.0\"\n+version = \"0.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n-dependencies = [\n- \"unicode-width\",\n-]\n+checksum = \"b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.6\"\n+version = \"1.0.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc6b305ec0e323c7b6cfff6098a22516e0063d0bb7c3d88660a890217dca099a\"\n+checksum = \"854babe52e4df1653706b98fcfc05843010039b406875930a70e4d9644e5c417\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.6\"\n+version = \"1.0.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45ba8d810d9c48fc456b7ad54574e8bfb7c7918a57ad7a6e6a0985d7959e8597\"\n+checksum = \"aa32fd3f627f367fe16f893e2597ae3c05020f8bba2666a4e6ea73d377e5714b\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -615,63 +640,57 @@ dependencies = [\n \n [[package]]\n name = \"thread_local\"\n-version = \"1.0.1\"\n+version = \"1.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14\"\n+checksum = \"5516c27b78311c50bf42c071425c560ac799b11c30b31f87e3081965fe5e0180\"\n dependencies = [\n- \"lazy_static\",\n+ \"once_cell\",\n ]\n \n [[package]]\n name = \"toml\"\n-version = \"0.5.3\"\n+version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c7aabe75941d914b72bf3e5d3932ed92ce0664d49d8432305a8b547c37227724\"\n+checksum = \"a31142970826733df8241ef35dc040ef98c679ab14d7c3e54d827099b3acecaa\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.3.0\"\n+version = \"1.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1967f4cdfc355b37fd76d2a954fb2ed3871034eb4f26d60537d88795cfc332a9\"\n+checksum = \"7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99\"\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.6\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n+checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n \n [[package]]\n name = \"unicode-xid\"\n-version = \"0.2.0\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n+checksum = \"8ccb82d61f80a663efe1f787a51b16b5a51e3314d6ac365b08639f52387b33f3\"\n \n [[package]]\n name = \"unicode_categories\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"39ec24b3121d976906ece63c9daad25b85969647682eee313cb5779fdd69e14e\"\n \n-[[package]]\n-name = \"vec_map\"\n-version = \"0.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n-\n [[package]]\n name = \"version_check\"\n-version = \"0.9.1\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"078775d0255232fb988e6fccf26ddc9d1ac274299aaedcedce21c6f72cc533ce\"\n+checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n [[package]]\n name = \"walkdir\"\n-version = \"2.2.9\"\n+version = \"2.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9658c94fa8b940eab2250bd5a457f9c48b748420d71293b165c8cdbe2f55f71e\"\n+checksum = \"808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56\"\n dependencies = [\n  \"same-file\",\n  \"winapi\",\n@@ -686,9 +705,9 @@ checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n \n [[package]]\n name = \"winapi\"\n-version = \"0.3.8\"\n+version = \"0.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8093091eeb260906a183e6ae1abdba2ef5ef2257a21801128899c3fc699229c6\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n dependencies = [\n  \"winapi-i686-pc-windows-gnu\",\n  \"winapi-x86_64-pc-windows-gnu\",\n@@ -702,9 +721,9 @@ checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n \n [[package]]\n name = \"winapi-util\"\n-version = \"0.1.2\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7168bab6e1daee33b4557efd0e95d5ca70a03706d39fa5f3fe7a236f584b03c9\"\n+checksum = \"70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178\"\n dependencies = [\n  \"winapi\",\n ]\n@@ -715,16 +734,6 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"wincolor\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"96f5016b18804d24db43cebf3c77269e7569b8954a8464501c216cc5e070eaa9\"\n-dependencies = [\n- \"winapi\",\n- \"winapi-util\",\n-]\n-\n [[package]]\n name = \"yansi-term\"\n version = \"0.1.2\""}, {"sha": "f26e982406234a1bf022a3bce7ca6064ad10d955", "filename": "src/tools/rustfmt/Cargo.toml", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FCargo.toml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -1,7 +1,7 @@\n [package]\n \n name = \"rustfmt-nightly\"\n-version = \"1.4.38\"\n+version = \"1.5.0\"\n description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang/rustfmt\"\n readme = \"README.md\"\n@@ -33,30 +33,31 @@ rustfmt-format-diff = []\n generic-simd = [\"bytecount/generic-simd\"]\n \n [dependencies]\n-itertools = \"0.10.1\"\n-toml = \"0.5\"\n-serde = { version = \"1.0\", features = [\"derive\"] }\n-serde_json = \"1.0\"\n-unicode-segmentation = \"1.0.0\"\n-regex = \"1.0\"\n-term = \"0.6\"\n+annotate-snippets = { version = \"0.9\", features = [\"color\"] }\n+anyhow = \"1.0\"\n+bytecount = \"0.6\"\n+cargo_metadata = \"0.14\"\n+clap = { version = \"3.1\", features = [\"derive\"] }\n+derive-new = \"0.5\"\n diff = \"0.1\"\n-log = \"0.4.14\"\n-env_logger = \"0.8\"\n+dirs = \"4.0\"\n+env_logger = \"0.9\"\n getopts = \"0.2\"\n-derive-new = \"0.5\"\n-cargo_metadata = \"0.14\"\n-bytecount = \"0.6\"\n-unicode-width = \"0.1.5\"\n-unicode_categories = \"0.1.1\"\n-dirs = \"2.0.1\"\n-ignore = \"0.4.17\"\n-annotate-snippets = { version = \"0.8\", features = [\"color\"] }\n-structopt = \"0.3\"\n-rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n-lazy_static = \"1.0.0\"\n-anyhow = \"1.0\"\n+ignore = \"0.4\"\n+itertools = \"0.10\"\n+lazy_static = \"1.4\"\n+log = \"0.4\"\n+regex = \"1.5\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\"\n+term = \"0.7\"\n thiserror = \"1.0\"\n+toml = \"0.5\"\n+unicode-segmentation = \"1.9\"\n+unicode-width = \"0.1\"\n+unicode_categories = \"0.1\"\n+\n+rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`"}, {"sha": "8c84614352ca24f1764f87c9295122b868a1c38b", "filename": "src/tools/rustfmt/Configurations.md", "status": "modified", "additions": 9, "deletions": 52, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FConfigurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2FConfigurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FConfigurations.md?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -10,7 +10,7 @@ reorder_imports = false\n ```\n \n Each configuration option is either stable or unstable.\n-Stable options can be used directly, while unstable options are opt-in.\n+Stable options can always be used, while unstable options are only available on a nightly toolchain and must be opted into.\n To enable unstable options, set `unstable_features = true` in `rustfmt.toml` or pass `--unstable-features` to rustfmt.\n \n # Configuration Options\n@@ -1065,7 +1065,7 @@ See also: [`tab_spaces`](#tab_spaces).\n Control the case of the letters in hexadecimal literal values\n \n - **Default value**: `Preserve`\n-- **Possible values**: `Upper`, `Lower`\n+- **Possible values**: `Preserve`, `Upper`, `Lower`\n - **Stable**: No (tracking issue: [#5081](https://github.com/rust-lang/rustfmt/issues/5081))\n \n ## `hide_parse_errors`\n@@ -1473,26 +1473,6 @@ use core::slice;\n #[cfg(feature = \"alloc\")] use core::slice;\n ```\n \n-## `license_template_path`\n-\n-Check whether beginnings of files match a license template.\n-\n-- **Default value**: `\"\"`\n-- **Possible values**: path to a license template file\n-- **Stable**: No (tracking issue: [#3352](https://github.com/rust-lang/rustfmt/issues/3352))\n-\n-A license template is a plain text file which is matched literally against the\n-beginning of each source file, except for `{}`-delimited blocks, which are\n-matched as regular expressions. The following license template therefore\n-matches strings like `// Copyright 2017 The Rust Project Developers.`, `//\n-Copyright 2018 The Rust Project Developers.`, etc.:\n-\n-```\n-// Copyright {\\d+} The Rust Project Developers.\n-```\n-\n-`\\{`, `\\}` and `\\\\` match literal braces / backslashes.\n-\n ## `match_arm_blocks`\n \n Controls whether arm bodies are wrapped in cases where the first line of the body cannot fit on the same line as the `=>` operator.\n@@ -1705,6 +1685,8 @@ How imports should be grouped into `use` statements. Imports will be merged or s\n - **Possible values**: `Preserve`, `Crate`, `Module`, `Item`, `One`\n - **Stable**: No (tracking issue: [#4991](https://github.com/rust-lang/rustfmt/issues/4991))\n \n+Note that rustfmt will not modify the granularity of imports containing comments if doing so could potentially lose or misplace said comments.\n+\n #### `Preserve` (default):\n \n Do not change the granularity of any imports and preserve the original structure written by the developer.\n@@ -2061,12 +2043,16 @@ use sit;\n \n ## `group_imports`\n \n-Controls the strategy for how imports are grouped together.\n+Controls the strategy for how consecutive imports are grouped together.\n+\n+Controls the strategy for grouping sets of consecutive imports. Imports may contain newlines between imports and still be grouped together as a single set, but other statements between imports will result in different grouping sets.\n \n - **Default value**: `Preserve`\n - **Possible values**: `Preserve`, `StdExternalCrate`, `One`\n - **Stable**: No (tracking issue: [#5083](https://github.com/rust-lang/rustfmt/issues/5083))\n \n+Each set of imports (one or more `use` statements, optionally separated by newlines) will be formatted independently. Other statements such as `mod ...` or `extern crate ...` will cause imports to not be grouped together.\n+\n #### `Preserve` (default):\n \n Preserve the source file's import groups.\n@@ -2162,35 +2148,6 @@ mod sit;\n **Note** `mod` with `#[macro_export]` will not be reordered since that could change the semantics\n of the original source code.\n \n-## `report_fixme`\n-\n-Report `FIXME` items in comments.\n-\n-- **Default value**: `\"Never\"`\n-- **Possible values**: `\"Always\"`, `\"Unnumbered\"`, `\"Never\"`\n-- **Stable**: No (tracking issue: [#3394](https://github.com/rust-lang/rustfmt/issues/3394))\n-\n-Warns about any comments containing `FIXME` in them when set to `\"Always\"`. If\n-it contains a `#X` (with `X` being a number) in parentheses following the\n-`FIXME`, `\"Unnumbered\"` will ignore it.\n-\n-See also [`report_todo`](#report_todo).\n-\n-\n-## `report_todo`\n-\n-Report `TODO` items in comments.\n-\n-- **Default value**: `\"Never\"`\n-- **Possible values**: `\"Always\"`, `\"Unnumbered\"`, `\"Never\"`\n-- **Stable**: No (tracking issue: [#3393](https://github.com/rust-lang/rustfmt/issues/3393))\n-\n-Warns about any comments containing `TODO` in them when set to `\"Always\"`. If\n-it contains a `#X` (with `X` being a number) in parentheses following the\n-`TODO`, `\"Unnumbered\"` will ignore it.\n-\n-See also [`report_fixme`](#report_fixme).\n-\n ## `required_version`\n \n Require a specific version of rustfmt. If you want to make sure that the"}, {"sha": "813e5e2c10feae1d7c3290c8cc8bc8cab78d0bd0", "filename": "src/tools/rustfmt/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Frust-toolchain?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-03-27\"\n+channel = \"nightly-2022-06-06\"\n components = [\"rustc-dev\"]"}, {"sha": "55fd75f6de9b831d8870c7fd5aff4fbfbbb346b4", "filename": "src/tools/rustfmt/src/cargo-fmt/main.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Fmain.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -10,59 +10,63 @@ use std::ffi::OsStr;\n use std::fs;\n use std::hash::{Hash, Hasher};\n use std::io::{self, Write};\n-use std::iter::FromIterator;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n \n-use structopt::StructOpt;\n+use clap::{CommandFactory, Parser};\n \n #[path = \"test/mod.rs\"]\n #[cfg(test)]\n mod cargo_fmt_tests;\n \n-#[derive(StructOpt, Debug)]\n-#[structopt(\n+#[derive(Parser)]\n+#[clap(\n     bin_name = \"cargo fmt\",\n     about = \"This utility formats all bin and lib files of \\\n              the current crate using rustfmt.\"\n )]\n pub struct Opts {\n     /// No output printed to stdout\n-    #[structopt(short = \"q\", long = \"quiet\")]\n+    #[clap(short = 'q', long = \"quiet\")]\n     quiet: bool,\n \n     /// Use verbose output\n-    #[structopt(short = \"v\", long = \"verbose\")]\n+    #[clap(short = 'v', long = \"verbose\")]\n     verbose: bool,\n \n     /// Print rustfmt version and exit\n-    #[structopt(long = \"version\")]\n+    #[clap(long = \"version\")]\n     version: bool,\n \n     /// Specify package to format\n-    #[structopt(short = \"p\", long = \"package\", value_name = \"package\")]\n+    #[clap(\n+        short = 'p',\n+        long = \"package\",\n+        value_name = \"package\",\n+        multiple_values = true\n+    )]\n     packages: Vec<String>,\n \n     /// Specify path to Cargo.toml\n-    #[structopt(long = \"manifest-path\", value_name = \"manifest-path\")]\n+    #[clap(long = \"manifest-path\", value_name = \"manifest-path\")]\n     manifest_path: Option<String>,\n \n     /// Specify message-format: short|json|human\n-    #[structopt(long = \"message-format\", value_name = \"message-format\")]\n+    #[clap(long = \"message-format\", value_name = \"message-format\")]\n     message_format: Option<String>,\n \n     /// Options passed to rustfmt\n     // 'raw = true' to make `--` explicit.\n-    #[structopt(name = \"rustfmt_options\", raw(true))]\n+    #[clap(name = \"rustfmt_options\", raw(true))]\n     rustfmt_options: Vec<String>,\n \n     /// Format all packages, and also their local path-based dependencies\n-    #[structopt(long = \"all\")]\n+    #[clap(long = \"all\")]\n     format_all: bool,\n \n     /// Run rustfmt in check mode\n-    #[structopt(long = \"check\")]\n+    #[clap(long = \"check\")]\n     check: bool,\n }\n \n@@ -87,7 +91,7 @@ fn execute() -> i32 {\n         }\n     });\n \n-    let opts = Opts::from_iter(args);\n+    let opts = Opts::parse_from(args);\n \n     let verbosity = match (opts.verbose, opts.quiet) {\n         (false, false) => Verbosity::Normal,\n@@ -204,7 +208,7 @@ fn convert_message_format_to_rustfmt_args(\n \n fn print_usage_to_stderr(reason: &str) {\n     eprintln!(\"{}\", reason);\n-    let app = Opts::clap();\n+    let app = Opts::command();\n     app.after_help(\"\")\n         .write_help(&mut io::stderr())\n         .expect(\"failed to write to stderr\");"}, {"sha": "56e52fbabb68b4876308b011d955a6de71c78c49", "filename": "src/tools/rustfmt/src/cargo-fmt/test/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Ftest%2Fmod.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -6,7 +6,7 @@ mod targets;\n #[test]\n fn default_options() {\n     let empty: Vec<String> = vec![];\n-    let o = Opts::from_iter(&empty);\n+    let o = Opts::parse_from(&empty);\n     assert_eq!(false, o.quiet);\n     assert_eq!(false, o.verbose);\n     assert_eq!(false, o.version);\n@@ -20,7 +20,7 @@ fn default_options() {\n \n #[test]\n fn good_options() {\n-    let o = Opts::from_iter(&[\n+    let o = Opts::parse_from(&[\n         \"test\",\n         \"-q\",\n         \"-p\",\n@@ -47,38 +47,38 @@ fn good_options() {\n #[test]\n fn unexpected_option() {\n     assert!(\n-        Opts::clap()\n-            .get_matches_from_safe(&[\"test\", \"unexpected\"])\n+        Opts::command()\n+            .try_get_matches_from(&[\"test\", \"unexpected\"])\n             .is_err()\n     );\n }\n \n #[test]\n fn unexpected_flag() {\n     assert!(\n-        Opts::clap()\n-            .get_matches_from_safe(&[\"test\", \"--flag\"])\n+        Opts::command()\n+            .try_get_matches_from(&[\"test\", \"--flag\"])\n             .is_err()\n     );\n }\n \n #[test]\n fn mandatory_separator() {\n     assert!(\n-        Opts::clap()\n-            .get_matches_from_safe(&[\"test\", \"--emit\"])\n+        Opts::command()\n+            .try_get_matches_from(&[\"test\", \"--emit\"])\n             .is_err()\n     );\n     assert!(\n-        !Opts::clap()\n-            .get_matches_from_safe(&[\"test\", \"--\", \"--emit\"])\n+        !Opts::command()\n+            .try_get_matches_from(&[\"test\", \"--\", \"--emit\"])\n             .is_err()\n     );\n }\n \n #[test]\n fn multiple_packages_one_by_one() {\n-    let o = Opts::from_iter(&[\n+    let o = Opts::parse_from(&[\n         \"test\",\n         \"-p\",\n         \"package1\",\n@@ -92,7 +92,7 @@ fn multiple_packages_one_by_one() {\n \n #[test]\n fn multiple_packages_grouped() {\n-    let o = Opts::from_iter(&[\n+    let o = Opts::parse_from(&[\n         \"test\",\n         \"--package\",\n         \"package1\",\n@@ -106,32 +106,36 @@ fn multiple_packages_grouped() {\n \n #[test]\n fn empty_packages_1() {\n-    assert!(Opts::clap().get_matches_from_safe(&[\"test\", \"-p\"]).is_err());\n+    assert!(\n+        Opts::command()\n+            .try_get_matches_from(&[\"test\", \"-p\"])\n+            .is_err()\n+    );\n }\n \n #[test]\n fn empty_packages_2() {\n     assert!(\n-        Opts::clap()\n-            .get_matches_from_safe(&[\"test\", \"-p\", \"--\", \"--check\"])\n+        Opts::command()\n+            .try_get_matches_from(&[\"test\", \"-p\", \"--\", \"--check\"])\n             .is_err()\n     );\n }\n \n #[test]\n fn empty_packages_3() {\n     assert!(\n-        Opts::clap()\n-            .get_matches_from_safe(&[\"test\", \"-p\", \"--verbose\"])\n+        Opts::command()\n+            .try_get_matches_from(&[\"test\", \"-p\", \"--verbose\"])\n             .is_err()\n     );\n }\n \n #[test]\n fn empty_packages_4() {\n     assert!(\n-        Opts::clap()\n-            .get_matches_from_safe(&[\"test\", \"-p\", \"--check\"])\n+        Opts::command()\n+            .try_get_matches_from(&[\"test\", \"-p\", \"--check\"])\n             .is_err()\n     );\n }"}, {"sha": "eb195b1f7628f70037e06e8184ea47c6844befc3", "filename": "src/tools/rustfmt/src/comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fcomment.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -796,7 +796,7 @@ impl<'a> CommentRewrite<'a> {\n         // 1) wrap_comments = true is configured\n         // 2) The comment is not the start of a markdown header doc comment\n         // 3) The comment width exceeds the shape's width\n-        // 4) No URLS were found in the commnet\n+        // 4) No URLS were found in the comment\n         let should_wrap_comment = self.fmt.config.wrap_comments()\n             && !is_markdown_header_doc_comment\n             && unicode_str_width(line) > self.fmt.shape.width"}, {"sha": "e37ed798cb55985943b58dd1d6ec69a79e610801", "filename": "src/tools/rustfmt/src/config/config_type.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fconfig_type.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -61,9 +61,6 @@ macro_rules! create_config {\n         #[derive(Clone)]\n         #[allow(unreachable_pub)]\n         pub struct Config {\n-            // if a license_template_path has been specified, successfully read, parsed and compiled\n-            // into a regex, it will be stored here\n-            pub license_template: Option<Regex>,\n             // For each config item, we store a bool indicating whether it has\n             // been accessed and the value, and a bool whether the option was\n             // manually initialised, or taken from the default,\n@@ -104,7 +101,6 @@ macro_rules! create_config {\n                     | \"struct_variant_width\"\n                     | \"array_width\"\n                     | \"chain_width\" => self.0.set_heuristics(),\n-                    \"license_template_path\" => self.0.set_license_template(),\n                     \"merge_imports\" => self.0.set_merge_imports(),\n                     &_ => (),\n                 }\n@@ -163,7 +159,6 @@ macro_rules! create_config {\n                 }\n             )+\n                 self.set_heuristics();\n-                self.set_license_template();\n                 self.set_ignore(dir);\n                 self.set_merge_imports();\n                 self\n@@ -247,7 +242,6 @@ macro_rules! create_config {\n                     | \"struct_variant_width\"\n                     | \"array_width\"\n                     | \"chain_width\" => self.set_heuristics(),\n-                    \"license_template_path\" => self.set_license_template(),\n                     \"merge_imports\" => self.set_merge_imports(),\n                     &_ => (),\n                 }\n@@ -386,21 +380,6 @@ macro_rules! create_config {\n                 };\n             }\n \n-            fn set_license_template(&mut self) {\n-                if self.was_set().license_template_path() {\n-                    let lt_path = self.license_template_path();\n-                    if lt_path.len() > 0 {\n-                        match license::load_and_compile_template(&lt_path) {\n-                            Ok(re) => self.license_template = Some(re),\n-                            Err(msg) => eprintln!(\"Warning for license template file {:?}: {}\",\n-                                                lt_path, msg),\n-                        }\n-                    } else {\n-                        self.license_template = None;\n-                    }\n-                }\n-            }\n-\n             fn set_ignore(&mut self, dir: &Path) {\n                 self.ignore.2.add_prefix(dir);\n             }\n@@ -437,7 +416,6 @@ macro_rules! create_config {\n         impl Default for Config {\n             fn default() -> Config {\n                 Config {\n-                    license_template: None,\n                     $(\n                         $i: (Cell::new(false), false, $def, $stb),\n                     )+"}, {"sha": "c7feb502ea91e5786790aaf0c2f46d12eabd0207", "filename": "src/tools/rustfmt/src/config/license.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flicense.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,265 +0,0 @@\n-use std::fmt;\n-use std::fs::File;\n-use std::io;\n-use std::io::Read;\n-\n-use regex::Regex;\n-\n-#[derive(Debug)]\n-pub(crate) enum LicenseError {\n-    IO(io::Error),\n-    Regex(regex::Error),\n-    Parse(String),\n-}\n-\n-impl fmt::Display for LicenseError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            LicenseError::IO(ref err) => err.fmt(f),\n-            LicenseError::Regex(ref err) => err.fmt(f),\n-            LicenseError::Parse(ref err) => write!(f, \"parsing failed, {}\", err),\n-        }\n-    }\n-}\n-\n-impl From<io::Error> for LicenseError {\n-    fn from(err: io::Error) -> LicenseError {\n-        LicenseError::IO(err)\n-    }\n-}\n-\n-impl From<regex::Error> for LicenseError {\n-    fn from(err: regex::Error) -> LicenseError {\n-        LicenseError::Regex(err)\n-    }\n-}\n-\n-// the template is parsed using a state machine\n-enum ParsingState {\n-    Lit,\n-    LitEsc,\n-    // the u32 keeps track of brace nesting\n-    Re(u32),\n-    ReEsc(u32),\n-    Abort(String),\n-}\n-\n-use self::ParsingState::*;\n-\n-pub(crate) struct TemplateParser {\n-    parsed: String,\n-    buffer: String,\n-    state: ParsingState,\n-    linum: u32,\n-    open_brace_line: u32,\n-}\n-\n-impl TemplateParser {\n-    fn new() -> Self {\n-        Self {\n-            parsed: \"^\".to_owned(),\n-            buffer: String::new(),\n-            state: Lit,\n-            linum: 1,\n-            // keeps track of last line on which a regex placeholder was started\n-            open_brace_line: 0,\n-        }\n-    }\n-\n-    /// Converts a license template into a string which can be turned into a regex.\n-    ///\n-    /// The license template could use regex syntax directly, but that would require a lot of manual\n-    /// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n-    /// subparts delimited by `{` and `}`. Additionally:\n-    ///\n-    /// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n-    /// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n-    ///\n-    /// This function parses this input format and builds a properly escaped *string* representation\n-    /// of the equivalent regular expression. It **does not** however guarantee that the returned\n-    /// string is a syntactically valid regular expression.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```text\n-    /// assert_eq!(\n-    ///     TemplateParser::parse(\n-    ///         r\"\n-    /// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n-    /// // file at the top-level directory of this distribution and at\n-    /// // {}.\n-    /// //\n-    /// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-    /// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-    /// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-    /// // option. This file may not be copied, modified, or distributed\n-    /// // except according to those terms.\n-    /// \"\n-    ///     ).unwrap(),\n-    ///     r\"^\n-    /// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n-    /// // file at the top\\-level directory of this distribution and at\n-    /// // .*?\\.\n-    /// //\n-    /// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n-    /// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n-    /// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n-    /// // option\\. This file may not be copied, modified, or distributed\n-    /// // except according to those terms\\.\n-    /// \"\n-    /// );\n-    /// ```\n-    pub(crate) fn parse(template: &str) -> Result<String, LicenseError> {\n-        let mut parser = Self::new();\n-        for chr in template.chars() {\n-            if chr == '\\n' {\n-                parser.linum += 1;\n-            }\n-            parser.state = match parser.state {\n-                Lit => parser.trans_from_lit(chr),\n-                LitEsc => parser.trans_from_litesc(chr),\n-                Re(brace_nesting) => parser.trans_from_re(chr, brace_nesting),\n-                ReEsc(brace_nesting) => parser.trans_from_reesc(chr, brace_nesting),\n-                Abort(msg) => return Err(LicenseError::Parse(msg)),\n-            };\n-        }\n-        // check if we've ended parsing in a valid state\n-        match parser.state {\n-            Abort(msg) => return Err(LicenseError::Parse(msg)),\n-            Re(_) | ReEsc(_) => {\n-                return Err(LicenseError::Parse(format!(\n-                    \"escape or balance opening brace on l. {}\",\n-                    parser.open_brace_line\n-                )));\n-            }\n-            LitEsc => {\n-                return Err(LicenseError::Parse(format!(\n-                    \"incomplete escape sequence on l. {}\",\n-                    parser.linum\n-                )));\n-            }\n-            _ => (),\n-        }\n-        parser.parsed.push_str(&regex::escape(&parser.buffer));\n-\n-        Ok(parser.parsed)\n-    }\n-\n-    fn trans_from_lit(&mut self, chr: char) -> ParsingState {\n-        match chr {\n-            '{' => {\n-                self.parsed.push_str(&regex::escape(&self.buffer));\n-                self.buffer.clear();\n-                self.open_brace_line = self.linum;\n-                Re(1)\n-            }\n-            '}' => Abort(format!(\n-                \"escape or balance closing brace on l. {}\",\n-                self.linum\n-            )),\n-            '\\\\' => LitEsc,\n-            _ => {\n-                self.buffer.push(chr);\n-                Lit\n-            }\n-        }\n-    }\n-\n-    fn trans_from_litesc(&mut self, chr: char) -> ParsingState {\n-        self.buffer.push(chr);\n-        Lit\n-    }\n-\n-    fn trans_from_re(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n-        match chr {\n-            '{' => {\n-                self.buffer.push(chr);\n-                Re(brace_nesting + 1)\n-            }\n-            '}' => {\n-                match brace_nesting {\n-                    1 => {\n-                        // default regex for empty placeholder {}\n-                        if self.buffer.is_empty() {\n-                            self.parsed.push_str(\".*?\");\n-                        } else {\n-                            self.parsed.push_str(&self.buffer);\n-                        }\n-                        self.buffer.clear();\n-                        Lit\n-                    }\n-                    _ => {\n-                        self.buffer.push(chr);\n-                        Re(brace_nesting - 1)\n-                    }\n-                }\n-            }\n-            '\\\\' => {\n-                self.buffer.push(chr);\n-                ReEsc(brace_nesting)\n-            }\n-            _ => {\n-                self.buffer.push(chr);\n-                Re(brace_nesting)\n-            }\n-        }\n-    }\n-\n-    fn trans_from_reesc(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n-        self.buffer.push(chr);\n-        Re(brace_nesting)\n-    }\n-}\n-\n-pub(crate) fn load_and_compile_template(path: &str) -> Result<Regex, LicenseError> {\n-    let mut lt_file = File::open(&path)?;\n-    let mut lt_str = String::new();\n-    lt_file.read_to_string(&mut lt_str)?;\n-    let lt_parsed = TemplateParser::parse(&lt_str)?;\n-    Ok(Regex::new(&lt_parsed)?)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::TemplateParser;\n-\n-    #[test]\n-    fn test_parse_license_template() {\n-        assert_eq!(\n-            TemplateParser::parse(\"literal (.*)\").unwrap(),\n-            r\"^literal \\(\\.\\*\\)\"\n-        );\n-        assert_eq!(\n-            TemplateParser::parse(r\"escaping \\}\").unwrap(),\n-            r\"^escaping \\}\"\n-        );\n-        assert!(TemplateParser::parse(\"unbalanced } without escape\").is_err());\n-        assert_eq!(\n-            TemplateParser::parse(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n-            r\"^\\d+ place-?holders?\"\n-        );\n-        assert_eq!(TemplateParser::parse(\"default {}\").unwrap(), \"^default .*?\");\n-        assert_eq!(\n-            TemplateParser::parse(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n-            r\"^unbalanced nested braces \\{{3}\"\n-        );\n-        assert_eq!(\n-            &TemplateParser::parse(\"parsing error }\")\n-                .unwrap_err()\n-                .to_string(),\n-            \"parsing failed, escape or balance closing brace on l. 1\"\n-        );\n-        assert_eq!(\n-            &TemplateParser::parse(\"parsing error {\\nsecond line\")\n-                .unwrap_err()\n-                .to_string(),\n-            \"parsing failed, escape or balance opening brace on l. 1\"\n-        );\n-        assert_eq!(\n-            &TemplateParser::parse(r\"parsing error \\\")\n-                .unwrap_err()\n-                .to_string(),\n-            \"parsing failed, incomplete escape sequence on l. 1\"\n-        );\n-    }\n-}"}, {"sha": "a5169528187834046e13ef5c8f6de8fa9fde1511", "filename": "src/tools/rustfmt/src/config/mod.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fmod.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -5,7 +5,6 @@ use std::io::{Error, ErrorKind, Read};\n use std::path::{Path, PathBuf};\n use std::{env, fs};\n \n-use regex::Regex;\n use thiserror::Error;\n \n use crate::config::config_type::ConfigType;\n@@ -22,7 +21,6 @@ pub(crate) mod config_type;\n pub(crate) mod options;\n \n pub(crate) mod file_lines;\n-pub(crate) mod license;\n pub(crate) mod lists;\n \n // This macro defines configuration options used in rustfmt. Each option\n@@ -63,8 +61,6 @@ create_config! {\n         \"Maximum length of comments. No effect unless wrap_comments = true\";\n     normalize_comments: bool, false, false, \"Convert /* */ comments to // comments where possible\";\n     normalize_doc_attributes: bool, false, false, \"Normalize doc attributes as doc comments\";\n-    license_template_path: String, String::default(), false,\n-        \"Beginning of file must match license template\";\n     format_strings: bool, false, false, \"Format string literals where necessary\";\n     format_macro_matchers: bool, false, false,\n         \"Format the metavariable matching patterns in macros\";\n@@ -164,10 +160,6 @@ create_config! {\n     error_on_unformatted: bool, false, false,\n         \"Error if unable to get comments or string literals within max_width, \\\n          or they are left with trailing whitespaces\";\n-    report_todo: ReportTactic, ReportTactic::Never, false,\n-        \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n-    report_fixme: ReportTactic, ReportTactic::Never, false,\n-        \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n     ignore: IgnoreList, IgnoreList::default(), false,\n         \"Skip formatting the specified files and directories\";\n \n@@ -418,8 +410,6 @@ mod test {\n         create_config! {\n             // Options that are used by the generated functions\n             max_width: usize, 100, true, \"Maximum width of each line\";\n-            license_template_path: String, String::default(), false,\n-                \"Beginning of file must match license template\";\n             required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n                 \"Require a specific version of rustfmt.\";\n             ignore: IgnoreList, IgnoreList::default(), false,\n@@ -524,31 +514,6 @@ mod test {\n         assert_eq!(s.contains(\"(unstable)\"), true);\n     }\n \n-    #[test]\n-    fn test_empty_string_license_template_path() {\n-        let toml = r#\"license_template_path = \"\"\"#;\n-        let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n-        assert!(config.license_template.is_none());\n-    }\n-\n-    #[nightly_only_test]\n-    #[test]\n-    fn test_valid_license_template_path() {\n-        let toml = r#\"license_template_path = \"tests/license-template/lt.txt\"\"#;\n-        let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n-        assert!(config.license_template.is_some());\n-    }\n-\n-    #[nightly_only_test]\n-    #[test]\n-    fn test_override_existing_license_with_no_license() {\n-        let toml = r#\"license_template_path = \"tests/license-template/lt.txt\"\"#;\n-        let mut config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n-        assert!(config.license_template.is_some());\n-        config.override_value(\"license_template_path\", \"\");\n-        assert!(config.license_template.is_none());\n-    }\n-\n     #[test]\n     fn test_dump_default_config() {\n         let default_config = format!(\n@@ -570,7 +535,6 @@ format_code_in_doc_comments = false\n comment_width = 80\n normalize_comments = false\n normalize_doc_attributes = false\n-license_template_path = \"\"\n format_strings = false\n format_macro_matchers = false\n format_macro_bodies = true\n@@ -625,8 +589,6 @@ skip_children = false\n hide_parse_errors = false\n error_on_line_overflow = false\n error_on_unformatted = false\n-report_todo = \"Never\"\n-report_fixme = \"Never\"\n ignore = []\n emit_mode = \"Files\"\n make_backup = false"}, {"sha": "4ccf1ca70c9d99c1a129c89f29fc5fa48f4afb35", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -1,5 +1,6 @@\n use std::borrow::Cow;\n use std::cmp::min;\n+use std::collections::HashMap;\n \n use itertools::Itertools;\n use rustc_ast::token::{Delimiter, LitKind};\n@@ -22,7 +23,7 @@ use crate::macros::{rewrite_macro, MacroPosition};\n use crate::matches::rewrite_match;\n use crate::overflow::{self, IntoOverflowableItem, OverflowableItem};\n use crate::pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n-use crate::rewrite::{Rewrite, RewriteContext};\n+use crate::rewrite::{QueryId, Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n@@ -53,6 +54,54 @@ pub(crate) fn format_expr(\n     expr_type: ExprType,\n     context: &RewriteContext<'_>,\n     shape: Shape,\n+) -> Option<String> {\n+    // when max_width is tight, we should check all possible formattings, in order to find\n+    // if we can fit expression in the limit. Doing it recursively takes exponential time\n+    // relative to input size, and people hit it with rustfmt takes minutes in #4476 #4867 #5128\n+    // By memoization of format_expr function, we format each pair of expression and shape\n+    // only once, so worst case execution time becomes O(n*max_width^3).\n+    if context.inside_macro() || context.is_macro_def {\n+        // span ids are not unique in macros, so we don't memoize result of them.\n+        return format_expr_inner(expr, expr_type, context, shape);\n+    }\n+    let clean;\n+    let query_id = QueryId {\n+        shape,\n+        span: expr.span,\n+    };\n+    if let Some(map) = context.memoize.take() {\n+        if let Some(r) = map.get(&query_id) {\n+            let r = r.clone();\n+            context.memoize.set(Some(map)); // restore map in the memoize cell for other users\n+            return r;\n+        }\n+        context.memoize.set(Some(map));\n+        clean = false;\n+    } else {\n+        context.memoize.set(Some(HashMap::default()));\n+        clean = true; // We got None, so we are the top level called function. When\n+        // this function finishes, no one is interested in what is in the map, because\n+        // all of them are sub expressions of this top level expression, and this is\n+        // done. So we should clean up memoize map to save some memory.\n+    }\n+\n+    let r = format_expr_inner(expr, expr_type, context, shape);\n+    if clean {\n+        context.memoize.set(None);\n+    } else {\n+        if let Some(mut map) = context.memoize.take() {\n+            map.insert(query_id, r.clone()); // insert the result in the memoize map\n+            context.memoize.set(Some(map)); // so it won't be computed again\n+        }\n+    }\n+    r\n+}\n+\n+fn format_expr_inner(\n+    expr: &ast::Expr,\n+    expr_type: ExprType,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n ) -> Option<String> {\n     skip_out_of_file_lines_range!(context, expr.span);\n "}, {"sha": "f6b739e1c2a370b50697591d2b845b13faed86ba", "filename": "src/tools/rustfmt/src/format-diff/main.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Fmain.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -19,8 +19,7 @@ use std::process;\n \n use regex::Regex;\n \n-use structopt::clap::AppSettings;\n-use structopt::StructOpt;\n+use clap::{CommandFactory, Parser};\n \n /// The default pattern of files to format.\n ///\n@@ -37,25 +36,25 @@ enum FormatDiffError {\n     IoError(#[from] io::Error),\n }\n \n-#[derive(StructOpt, Debug)]\n-#[structopt(\n+#[derive(Parser, Debug)]\n+#[clap(\n     name = \"rustfmt-format-diff\",\n-    setting = AppSettings::DisableVersion,\n-    setting = AppSettings::NextLineHelp\n+    disable_version_flag = true,\n+    next_line_help = true\n )]\n pub struct Opts {\n     /// Skip the smallest prefix containing NUMBER slashes\n-    #[structopt(\n-        short = \"p\",\n+    #[clap(\n+        short = 'p',\n         long = \"skip-prefix\",\n         value_name = \"NUMBER\",\n         default_value = \"0\"\n     )]\n     skip_prefix: u32,\n \n     /// Custom pattern selecting file paths to reformat\n-    #[structopt(\n-        short = \"f\",\n+    #[clap(\n+        short = 'f',\n         long = \"filter\",\n         value_name = \"PATTERN\",\n         default_value = DEFAULT_PATTERN\n@@ -65,10 +64,12 @@ pub struct Opts {\n \n fn main() {\n     env_logger::Builder::from_env(\"RUSTFMT_LOG\").init();\n-    let opts = Opts::from_args();\n+    let opts = Opts::parse();\n     if let Err(e) = run(opts) {\n         println!(\"{}\", e);\n-        Opts::clap().print_help().expect(\"cannot write to stdout\");\n+        Opts::command()\n+            .print_help()\n+            .expect(\"cannot write to stdout\");\n         process::exit(1);\n     }\n }\n@@ -230,50 +231,50 @@ mod cmd_line_tests {\n     #[test]\n     fn default_options() {\n         let empty: Vec<String> = vec![];\n-        let o = Opts::from_iter(&empty);\n+        let o = Opts::parse_from(&empty);\n         assert_eq!(DEFAULT_PATTERN, o.filter);\n         assert_eq!(0, o.skip_prefix);\n     }\n \n     #[test]\n     fn good_options() {\n-        let o = Opts::from_iter(&[\"test\", \"-p\", \"10\", \"-f\", r\".*\\.hs\"]);\n+        let o = Opts::parse_from(&[\"test\", \"-p\", \"10\", \"-f\", r\".*\\.hs\"]);\n         assert_eq!(r\".*\\.hs\", o.filter);\n         assert_eq!(10, o.skip_prefix);\n     }\n \n     #[test]\n     fn unexpected_option() {\n         assert!(\n-            Opts::clap()\n-                .get_matches_from_safe(&[\"test\", \"unexpected\"])\n+            Opts::command()\n+                .try_get_matches_from(&[\"test\", \"unexpected\"])\n                 .is_err()\n         );\n     }\n \n     #[test]\n     fn unexpected_flag() {\n         assert!(\n-            Opts::clap()\n-                .get_matches_from_safe(&[\"test\", \"--flag\"])\n+            Opts::command()\n+                .try_get_matches_from(&[\"test\", \"--flag\"])\n                 .is_err()\n         );\n     }\n \n     #[test]\n     fn overridden_option() {\n         assert!(\n-            Opts::clap()\n-                .get_matches_from_safe(&[\"test\", \"-p\", \"10\", \"-p\", \"20\"])\n+            Opts::command()\n+                .try_get_matches_from(&[\"test\", \"-p\", \"10\", \"-p\", \"20\"])\n                 .is_err()\n         );\n     }\n \n     #[test]\n     fn negative_filter() {\n         assert!(\n-            Opts::clap()\n-                .get_matches_from_safe(&[\"test\", \"-p\", \"-1\"])\n+            Opts::command()\n+                .try_get_matches_from(&[\"test\", \"-p\", \"-1\"])\n                 .is_err()\n         );\n     }"}, {"sha": "fd536d4df41a27a0896351497d9a54c0057f2563", "filename": "src/tools/rustfmt/src/format_report_formatter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fformat_report_formatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fformat_report_formatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformat_report_formatter.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -142,10 +142,9 @@ fn error_kind_to_snippet_annotation_type(error_kind: &ErrorKind) -> AnnotationTy\n         | ErrorKind::ModuleResolutionError(_)\n         | ErrorKind::ParseError\n         | ErrorKind::LostComment\n-        | ErrorKind::LicenseCheck\n         | ErrorKind::BadAttr\n         | ErrorKind::InvalidGlobPattern(_)\n         | ErrorKind::VersionMismatch => AnnotationType::Error,\n-        ErrorKind::BadIssue(_) | ErrorKind::DeprecatedAttr => AnnotationType::Warning,\n+        ErrorKind::DeprecatedAttr => AnnotationType::Warning,\n     }\n }"}, {"sha": "e644ea50effd76c40184525ff6f1e5544cfcaa4a", "filename": "src/tools/rustfmt/src/formatting.rs", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -2,6 +2,7 @@\n \n use std::collections::HashMap;\n use std::io::{self, Write};\n+use std::rc::Rc;\n use std::time::{Duration, Instant};\n \n use rustc_ast::ast;\n@@ -11,7 +12,6 @@ use self::newline_style::apply_newline_style;\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n use crate::formatting::generated::is_generated_file;\n-use crate::issues::BadIssueSeeker;\n use crate::modules::Module;\n use crate::parse::parser::{DirectoryOwnership, Parser, ParserError};\n use crate::parse::session::ParseSess;\n@@ -39,12 +39,10 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n         rustc_span::create_session_if_not_set_then(self.config.edition().into(), |_| {\n             if self.config.disable_all_formatting() {\n                 // When the input is from stdin, echo back the input.\n-                if let Input::Text(ref buf) = input {\n-                    if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n-                        return Err(From::from(e));\n-                    }\n-                }\n-                return Ok(FormatReport::new());\n+                return match input {\n+                    Input::Text(ref buf) => echo_back_stdin(buf),\n+                    _ => Ok(FormatReport::new()),\n+                };\n             }\n \n             let config = &self.config.clone();\n@@ -93,6 +91,13 @@ fn should_skip_module<T: FormatHandler>(\n     false\n }\n \n+fn echo_back_stdin(input: &str) -> Result<FormatReport, ErrorKind> {\n+    if let Err(e) = io::stdout().write_all(input.as_bytes()) {\n+        return Err(From::from(e));\n+    }\n+    Ok(FormatReport::new())\n+}\n+\n // Format an entire crate (or subset of the module tree).\n fn format_project<T: FormatHandler>(\n     input: Input,\n@@ -135,7 +140,8 @@ fn format_project<T: FormatHandler>(\n     .visit_crate(&krate)?\n     .into_iter()\n     .filter(|(path, module)| {\n-        !should_skip_module(config, &context, input_is_stdin, &main_file, path, module)\n+        input_is_stdin\n+            || !should_skip_module(config, &context, input_is_stdin, &main_file, path, module)\n     })\n     .collect::<Vec<_>>();\n \n@@ -145,6 +151,14 @@ fn format_project<T: FormatHandler>(\n     context.parse_session.set_silent_emitter();\n \n     for (path, module) in files {\n+        if input_is_stdin && contains_skip(module.attrs()) {\n+            return echo_back_stdin(\n+                context\n+                    .parse_session\n+                    .snippet_provider(module.span)\n+                    .entire_snippet(),\n+            );\n+        }\n         should_emit_verbose(input_is_stdin, config, || println!(\"Formatting {}\", path));\n         context.format_file(path, &module, is_macro_def)?;\n     }\n@@ -189,6 +203,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             self.config,\n             &snippet_provider,\n             self.report.clone(),\n+            Rc::default(),\n         );\n         visitor.skip_context.update_with_attrs(&self.krate.attrs);\n         visitor.is_macro_def = is_macro_def;\n@@ -329,10 +344,8 @@ impl FormattingError {\n             ErrorKind::LineOverflow(found, max) => (max, found - max),\n             ErrorKind::TrailingWhitespace\n             | ErrorKind::DeprecatedAttr\n-            | ErrorKind::BadIssue(_)\n             | ErrorKind::BadAttr\n-            | ErrorKind::LostComment\n-            | ErrorKind::LicenseCheck => {\n+            | ErrorKind::LostComment => {\n                 let trailing_ws_start = self\n                     .line_buffer\n                     .rfind(|c: char| !c.is_whitespace())\n@@ -364,7 +377,7 @@ pub(crate) struct ReportedErrors {\n     // Code contains macro call that was unable to format.\n     pub(crate) has_macro_format_failure: bool,\n \n-    // Failed a check, such as the license check or other opt-in checking.\n+    // Failed an opt-in checking.\n     pub(crate) has_check_errors: bool,\n \n     /// Formatted code differs from existing code (--check only).\n@@ -460,7 +473,6 @@ fn format_lines(\n     report: &FormatReport,\n ) {\n     let mut formatter = FormatLines::new(name, skipped_range, config);\n-    formatter.check_license(text);\n     formatter.iterate(text);\n \n     if formatter.newline_count > 1 {\n@@ -480,11 +492,9 @@ struct FormatLines<'a> {\n     cur_line: usize,\n     newline_count: usize,\n     errors: Vec<FormattingError>,\n-    issue_seeker: BadIssueSeeker,\n     line_buffer: String,\n     current_line_contains_string_literal: bool,\n     format_line: bool,\n-    allow_issue_seek: bool,\n     config: &'a Config,\n }\n \n@@ -494,7 +504,6 @@ impl<'a> FormatLines<'a> {\n         skipped_range: &'a [(usize, usize)],\n         config: &'a Config,\n     ) -> FormatLines<'a> {\n-        let issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n         FormatLines {\n             name,\n             skipped_range,\n@@ -503,43 +512,20 @@ impl<'a> FormatLines<'a> {\n             cur_line: 1,\n             newline_count: 0,\n             errors: vec![],\n-            allow_issue_seek: !issue_seeker.is_disabled(),\n-            issue_seeker,\n             line_buffer: String::with_capacity(config.max_width() * 2),\n             current_line_contains_string_literal: false,\n             format_line: config.file_lines().contains_line(name, 1),\n             config,\n         }\n     }\n \n-    fn check_license(&mut self, text: &mut String) {\n-        if let Some(ref license_template) = self.config.license_template {\n-            if !license_template.is_match(text) {\n-                self.errors.push(FormattingError {\n-                    line: self.cur_line,\n-                    kind: ErrorKind::LicenseCheck,\n-                    is_comment: false,\n-                    is_string: false,\n-                    line_buffer: String::new(),\n-                });\n-            }\n-        }\n-    }\n-\n     // Iterate over the chars in the file map.\n     fn iterate(&mut self, text: &mut String) {\n         for (kind, c) in CharClasses::new(text.chars()) {\n             if c == '\\r' {\n                 continue;\n             }\n \n-            if self.allow_issue_seek && self.format_line {\n-                // Add warnings for bad todos/ fixmes\n-                if let Some(issue) = self.issue_seeker.inspect(c) {\n-                    self.push_err(ErrorKind::BadIssue(issue), false, false);\n-                }\n-            }\n-\n             if c == '\\n' {\n                 self.new_line(kind);\n             } else {"}, {"sha": "559ed3917dba7bc2e99f4276471c812d4228e4d5", "filename": "src/tools/rustfmt/src/imports.rs", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -2,6 +2,10 @@ use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::fmt;\n \n+use core::hash::{Hash, Hasher};\n+\n+use itertools::Itertools;\n+\n use rustc_ast::ast::{self, UseTreeKind};\n use rustc_span::{\n     symbol::{self, sym},\n@@ -10,6 +14,7 @@ use rustc_span::{\n \n use crate::comment::combine_strs_with_missing_comments;\n use crate::config::lists::*;\n+use crate::config::ImportGranularity;\n use crate::config::{Edition, IndentStyle};\n use crate::lists::{\n     definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator,\n@@ -86,7 +91,7 @@ impl<'a> FmtVisitor<'a> {\n // sorting.\n \n // FIXME we do a lot of allocation to make our own representation.\n-#[derive(Clone, Eq, PartialEq)]\n+#[derive(Clone, Eq, Hash, PartialEq)]\n pub(crate) enum UseSegment {\n     Ident(String, Option<String>),\n     Slf(Option<String>),\n@@ -180,17 +185,36 @@ impl UseSegment {\n             }\n         })\n     }\n+\n+    fn contains_comment(&self) -> bool {\n+        if let UseSegment::List(list) = self {\n+            list.iter().any(|subtree| subtree.contains_comment())\n+        } else {\n+            false\n+        }\n+    }\n }\n \n-pub(crate) fn merge_use_trees(use_trees: Vec<UseTree>, merge_by: SharedPrefix) -> Vec<UseTree> {\n+pub(crate) fn normalize_use_trees_with_granularity(\n+    use_trees: Vec<UseTree>,\n+    import_granularity: ImportGranularity,\n+) -> Vec<UseTree> {\n+    let merge_by = match import_granularity {\n+        ImportGranularity::Item => return flatten_use_trees(use_trees, ImportGranularity::Item),\n+        ImportGranularity::Preserve => return use_trees,\n+        ImportGranularity::Crate => SharedPrefix::Crate,\n+        ImportGranularity::Module => SharedPrefix::Module,\n+        ImportGranularity::One => SharedPrefix::One,\n+    };\n+\n     let mut result = Vec::with_capacity(use_trees.len());\n     for use_tree in use_trees {\n-        if use_tree.has_comment() || use_tree.attrs.is_some() {\n+        if use_tree.contains_comment() || use_tree.attrs.is_some() {\n             result.push(use_tree);\n             continue;\n         }\n \n-        for mut flattened in use_tree.flatten() {\n+        for mut flattened in use_tree.flatten(import_granularity) {\n             if let Some(tree) = result\n                 .iter_mut()\n                 .find(|tree| tree.share_prefix(&flattened, merge_by))\n@@ -208,11 +232,17 @@ pub(crate) fn merge_use_trees(use_trees: Vec<UseTree>, merge_by: SharedPrefix) -\n     result\n }\n \n-pub(crate) fn flatten_use_trees(use_trees: Vec<UseTree>) -> Vec<UseTree> {\n+fn flatten_use_trees(\n+    use_trees: Vec<UseTree>,\n+    import_granularity: ImportGranularity,\n+) -> Vec<UseTree> {\n+    // Return non-sorted single occurance of the use-trees text string;\n+    // order is by first occurance of the use-tree.\n     use_trees\n         .into_iter()\n-        .flat_map(UseTree::flatten)\n+        .flat_map(|tree| tree.flatten(import_granularity))\n         .map(UseTree::nest_trailing_self)\n+        .unique()\n         .collect()\n }\n \n@@ -541,6 +571,10 @@ impl UseTree {\n         self.list_item.as_ref().map_or(false, ListItem::has_comment)\n     }\n \n+    fn contains_comment(&self) -> bool {\n+        self.has_comment() || self.path.iter().any(|path| path.contains_comment())\n+    }\n+\n     fn same_visibility(&self, other: &UseTree) -> bool {\n         match (&self.visibility, &other.visibility) {\n             (\n@@ -567,6 +601,7 @@ impl UseTree {\n         if self.path.is_empty()\n             || other.path.is_empty()\n             || self.attrs.is_some()\n+            || self.contains_comment()\n             || !self.same_visibility(other)\n         {\n             false\n@@ -581,8 +616,8 @@ impl UseTree {\n         }\n     }\n \n-    fn flatten(self) -> Vec<UseTree> {\n-        if self.path.is_empty() {\n+    fn flatten(self, import_granularity: ImportGranularity) -> Vec<UseTree> {\n+        if self.path.is_empty() || self.contains_comment() {\n             return vec![self];\n         }\n         match self.path.clone().last().unwrap() {\n@@ -595,15 +630,19 @@ impl UseTree {\n                 let prefix = &self.path[..self.path.len() - 1];\n                 let mut result = vec![];\n                 for nested_use_tree in list {\n-                    for flattend in &mut nested_use_tree.clone().flatten() {\n+                    for flattend in &mut nested_use_tree.clone().flatten(import_granularity) {\n                         let mut new_path = prefix.to_vec();\n                         new_path.append(&mut flattend.path);\n                         result.push(UseTree {\n                             path: new_path,\n                             span: self.span,\n                             list_item: None,\n                             visibility: self.visibility.clone(),\n-                            attrs: None,\n+                            // only retain attributes for `ImportGranularity::Item`\n+                            attrs: match import_granularity {\n+                                ImportGranularity::Item => self.attrs.clone(),\n+                                _ => None,\n+                            },\n                         });\n                     }\n                 }\n@@ -748,6 +787,12 @@ fn merge_use_trees_inner(trees: &mut Vec<UseTree>, use_tree: UseTree, merge_by:\n     trees.sort();\n }\n \n+impl Hash for UseTree {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.path.hash(state);\n+    }\n+}\n+\n impl PartialOrd for UseSegment {\n     fn partial_cmp(&self, other: &UseSegment) -> Option<Ordering> {\n         Some(self.cmp(other))\n@@ -951,7 +996,7 @@ impl Rewrite for UseTree {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum SharedPrefix {\n+enum SharedPrefix {\n     Crate,\n     Module,\n     One,\n@@ -1106,7 +1151,10 @@ mod test {\n     macro_rules! test_merge {\n         ($by:ident, [$($input:expr),* $(,)*], [$($output:expr),* $(,)*]) => {\n             assert_eq!(\n-                merge_use_trees(parse_use_trees!($($input,)*), SharedPrefix::$by),\n+                normalize_use_trees_with_granularity(\n+                    parse_use_trees!($($input,)*),\n+                    ImportGranularity::$by,\n+                ),\n                 parse_use_trees!($($output,)*),\n             );\n         }\n@@ -1215,12 +1263,18 @@ mod test {\n     #[test]\n     fn test_flatten_use_trees() {\n         assert_eq!(\n-            flatten_use_trees(parse_use_trees![\"foo::{a::{b, c}, d::e}\"]),\n+            flatten_use_trees(\n+                parse_use_trees![\"foo::{a::{b, c}, d::e}\"],\n+                ImportGranularity::Item\n+            ),\n             parse_use_trees![\"foo::a::b\", \"foo::a::c\", \"foo::d::e\"]\n         );\n \n         assert_eq!(\n-            flatten_use_trees(parse_use_trees![\"foo::{self, a, b::{c, d}, e::*}\"]),\n+            flatten_use_trees(\n+                parse_use_trees![\"foo::{self, a, b::{c, d}, e::*}\"],\n+                ImportGranularity::Item\n+            ),\n             parse_use_trees![\n                 \"foo::{self}\",\n                 \"foo::a\",\n@@ -1234,12 +1288,13 @@ mod test {\n     #[test]\n     fn test_use_tree_flatten() {\n         assert_eq!(\n-            parse_use_tree(\"a::b::{c, d, e, f}\").flatten(),\n+            parse_use_tree(\"a::b::{c, d, e, f}\").flatten(ImportGranularity::Item),\n             parse_use_trees!(\"a::b::c\", \"a::b::d\", \"a::b::e\", \"a::b::f\",)\n         );\n \n         assert_eq!(\n-            parse_use_tree(\"a::b::{c::{d, e, f}, g, h::{i, j, k}}\").flatten(),\n+            parse_use_tree(\"a::b::{c::{d, e, f}, g, h::{i, j, k}}\")\n+                .flatten(ImportGranularity::Item),\n             parse_use_trees![\n                 \"a::b::c::d\",\n                 \"a::b::c::e\","}, {"sha": "33fb5522aeae53e757fd244592e9d90a678208fc", "filename": "src/tools/rustfmt/src/issues.rs", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Fsrc%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Fsrc%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fissues.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,309 +0,0 @@\n-// Objects for seeking through a char stream for occurrences of TODO and FIXME.\n-// Depending on the loaded configuration, may also check that these have an\n-// associated issue number.\n-\n-use std::fmt;\n-\n-use crate::config::ReportTactic;\n-\n-const TO_DO_CHARS: &[char] = &['t', 'o', 'd', 'o'];\n-const FIX_ME_CHARS: &[char] = &['f', 'i', 'x', 'm', 'e'];\n-\n-// Enabled implementation detail is here because it is\n-// irrelevant outside the issues module\n-fn is_enabled(report_tactic: ReportTactic) -> bool {\n-    report_tactic != ReportTactic::Never\n-}\n-\n-#[derive(Clone, Copy)]\n-enum Seeking {\n-    Issue { todo_idx: usize, fixme_idx: usize },\n-    Number { issue: Issue, part: NumberPart },\n-}\n-\n-#[derive(Clone, Copy)]\n-enum NumberPart {\n-    OpenParen,\n-    Pound,\n-    Number,\n-    CloseParen,\n-}\n-\n-#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-pub struct Issue {\n-    issue_type: IssueType,\n-    // Indicates whether we're looking for issues with missing numbers, or\n-    // all issues of this type.\n-    missing_number: bool,\n-}\n-\n-impl fmt::Display for Issue {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n-        let msg = match self.issue_type {\n-            IssueType::Todo => \"TODO\",\n-            IssueType::Fixme => \"FIXME\",\n-        };\n-        let details = if self.missing_number {\n-            \" without issue number\"\n-        } else {\n-            \"\"\n-        };\n-\n-        write!(fmt, \"{}{}\", msg, details)\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-enum IssueType {\n-    Todo,\n-    Fixme,\n-}\n-\n-enum IssueClassification {\n-    Good,\n-    Bad(Issue),\n-    None,\n-}\n-\n-pub(crate) struct BadIssueSeeker {\n-    state: Seeking,\n-    report_todo: ReportTactic,\n-    report_fixme: ReportTactic,\n-}\n-\n-impl BadIssueSeeker {\n-    pub(crate) fn new(report_todo: ReportTactic, report_fixme: ReportTactic) -> BadIssueSeeker {\n-        BadIssueSeeker {\n-            state: Seeking::Issue {\n-                todo_idx: 0,\n-                fixme_idx: 0,\n-            },\n-            report_todo,\n-            report_fixme,\n-        }\n-    }\n-\n-    pub(crate) fn is_disabled(&self) -> bool {\n-        !is_enabled(self.report_todo) && !is_enabled(self.report_fixme)\n-    }\n-\n-    // Check whether or not the current char is conclusive evidence for an\n-    // unnumbered TO-DO or FIX-ME.\n-    pub(crate) fn inspect(&mut self, c: char) -> Option<Issue> {\n-        match self.state {\n-            Seeking::Issue {\n-                todo_idx,\n-                fixme_idx,\n-            } => {\n-                self.state = self.inspect_issue(c, todo_idx, fixme_idx);\n-            }\n-            Seeking::Number { issue, part } => {\n-                let result = self.inspect_number(c, issue, part);\n-\n-                if let IssueClassification::None = result {\n-                    return None;\n-                }\n-\n-                self.state = Seeking::Issue {\n-                    todo_idx: 0,\n-                    fixme_idx: 0,\n-                };\n-\n-                if let IssueClassification::Bad(issue) = result {\n-                    return Some(issue);\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn inspect_issue(&mut self, c: char, mut todo_idx: usize, mut fixme_idx: usize) -> Seeking {\n-        if let Some(lower_case_c) = c.to_lowercase().next() {\n-            if is_enabled(self.report_todo) && lower_case_c == TO_DO_CHARS[todo_idx] {\n-                todo_idx += 1;\n-                if todo_idx == TO_DO_CHARS.len() {\n-                    return Seeking::Number {\n-                        issue: Issue {\n-                            issue_type: IssueType::Todo,\n-                            missing_number: matches!(self.report_todo, ReportTactic::Unnumbered),\n-                        },\n-                        part: NumberPart::OpenParen,\n-                    };\n-                }\n-                fixme_idx = 0;\n-            } else if is_enabled(self.report_fixme) && lower_case_c == FIX_ME_CHARS[fixme_idx] {\n-                // Exploit the fact that the character sets of todo and fixme\n-                // are disjoint by adding else.\n-                fixme_idx += 1;\n-                if fixme_idx == FIX_ME_CHARS.len() {\n-                    return Seeking::Number {\n-                        issue: Issue {\n-                            issue_type: IssueType::Fixme,\n-                            missing_number: matches!(self.report_fixme, ReportTactic::Unnumbered),\n-                        },\n-                        part: NumberPart::OpenParen,\n-                    };\n-                }\n-                todo_idx = 0;\n-            } else {\n-                todo_idx = 0;\n-                fixme_idx = 0;\n-            }\n-        }\n-\n-        Seeking::Issue {\n-            todo_idx,\n-            fixme_idx,\n-        }\n-    }\n-\n-    fn inspect_number(\n-        &mut self,\n-        c: char,\n-        issue: Issue,\n-        mut part: NumberPart,\n-    ) -> IssueClassification {\n-        if !issue.missing_number || c == '\\n' {\n-            return IssueClassification::Bad(issue);\n-        } else if c == ')' {\n-            return if let NumberPart::CloseParen = part {\n-                IssueClassification::Good\n-            } else {\n-                IssueClassification::Bad(issue)\n-            };\n-        }\n-\n-        match part {\n-            NumberPart::OpenParen => {\n-                if c != '(' {\n-                    return IssueClassification::Bad(issue);\n-                } else {\n-                    part = NumberPart::Pound;\n-                }\n-            }\n-            NumberPart::Pound => {\n-                if c == '#' {\n-                    part = NumberPart::Number;\n-                }\n-            }\n-            NumberPart::Number => {\n-                if ('0'..='9').contains(&c) {\n-                    part = NumberPart::CloseParen;\n-                } else {\n-                    return IssueClassification::Bad(issue);\n-                }\n-            }\n-            NumberPart::CloseParen => {}\n-        }\n-\n-        self.state = Seeking::Number { part, issue };\n-\n-        IssueClassification::None\n-    }\n-}\n-\n-#[test]\n-fn find_unnumbered_issue() {\n-    fn check_fail(text: &str, failing_pos: usize) {\n-        let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n-        assert_eq!(\n-            Some(failing_pos),\n-            text.find(|c| seeker.inspect(c).is_some())\n-        );\n-    }\n-\n-    fn check_pass(text: &str) {\n-        let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n-        assert_eq!(None, text.find(|c| seeker.inspect(c).is_some()));\n-    }\n-\n-    check_fail(\"TODO\\n\", 4);\n-    check_pass(\" TO FIX DOME\\n\");\n-    check_fail(\" \\n FIXME\\n\", 8);\n-    check_fail(\"FIXME(\\n\", 6);\n-    check_fail(\"FIXME(#\\n\", 7);\n-    check_fail(\"FIXME(#1\\n\", 8);\n-    check_fail(\"FIXME(#)1\\n\", 7);\n-    check_pass(\"FIXME(#1222)\\n\");\n-    check_fail(\"FIXME(#12\\n22)\\n\", 9);\n-    check_pass(\"FIXME(@maintainer, #1222, hello)\\n\");\n-    check_fail(\"TODO(#22) FIXME\\n\", 15);\n-}\n-\n-#[test]\n-fn find_issue() {\n-    fn is_bad_issue(text: &str, report_todo: ReportTactic, report_fixme: ReportTactic) -> bool {\n-        let mut seeker = BadIssueSeeker::new(report_todo, report_fixme);\n-        text.chars().any(|c| seeker.inspect(c).is_some())\n-    }\n-\n-    assert!(is_bad_issue(\n-        \"TODO(@maintainer, #1222, hello)\\n\",\n-        ReportTactic::Always,\n-        ReportTactic::Never,\n-    ));\n-\n-    assert!(!is_bad_issue(\n-        \"TODO: no number\\n\",\n-        ReportTactic::Never,\n-        ReportTactic::Always,\n-    ));\n-\n-    assert!(!is_bad_issue(\n-        \"Todo: mixed case\\n\",\n-        ReportTactic::Never,\n-        ReportTactic::Always,\n-    ));\n-\n-    assert!(is_bad_issue(\n-        \"This is a FIXME(#1)\\n\",\n-        ReportTactic::Never,\n-        ReportTactic::Always,\n-    ));\n-\n-    assert!(is_bad_issue(\n-        \"This is a FixMe(#1) mixed case\\n\",\n-        ReportTactic::Never,\n-        ReportTactic::Always,\n-    ));\n-\n-    assert!(!is_bad_issue(\n-        \"bad FIXME\\n\",\n-        ReportTactic::Always,\n-        ReportTactic::Never,\n-    ));\n-}\n-\n-#[test]\n-fn issue_type() {\n-    let mut seeker = BadIssueSeeker::new(ReportTactic::Always, ReportTactic::Never);\n-    let expected = Some(Issue {\n-        issue_type: IssueType::Todo,\n-        missing_number: false,\n-    });\n-\n-    assert_eq!(\n-        expected,\n-        \"TODO(#100): more awesomeness\"\n-            .chars()\n-            .map(|c| seeker.inspect(c))\n-            .find(Option::is_some)\n-            .unwrap()\n-    );\n-\n-    let mut seeker = BadIssueSeeker::new(ReportTactic::Never, ReportTactic::Unnumbered);\n-    let expected = Some(Issue {\n-        issue_type: IssueType::Fixme,\n-        missing_number: true,\n-    });\n-\n-    assert_eq!(\n-        expected,\n-        \"Test. FIXME: bad, bad, not good\"\n-            .chars()\n-            .map(|c| seeker.inspect(c))\n-            .find(Option::is_some)\n-            .unwrap()\n-    );\n-}"}, {"sha": "bab881f4b4e8dceedfa31c2b6ed9834810fe3455", "filename": "src/tools/rustfmt/src/items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -1770,7 +1770,7 @@ pub(crate) fn rewrite_struct_field(\n         .offset_left(overhead + spacing.len())\n         .and_then(|ty_shape| field.ty.rewrite(context, ty_shape));\n     if let Some(ref ty) = orig_ty {\n-        if !ty.contains('\\n') {\n+        if !ty.contains('\\n') && !contains_comment(context.snippet(missing_span)) {\n             return Some(attr_prefix + &spacing + ty);\n         }\n     }"}, {"sha": "1d1ef525f23fa38ba259bdd45ea0e0e6e86a8549", "filename": "src/tools/rustfmt/src/lib.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -40,7 +40,6 @@ use thiserror::Error;\n use crate::comment::LineClasses;\n use crate::emitter::Emitter;\n use crate::formatting::{FormatErrorMap, FormattingError, ReportedErrors, SourceFile};\n-use crate::issues::Issue;\n use crate::modules::ModuleResolutionError;\n use crate::parse::parser::DirectoryOwnership;\n use crate::shape::Indent;\n@@ -70,7 +69,6 @@ mod format_report_formatter;\n pub(crate) mod formatting;\n mod ignore_path;\n mod imports;\n-mod issues;\n mod items;\n mod lists;\n mod macros;\n@@ -111,12 +109,6 @@ pub enum ErrorKind {\n     /// Line ends in whitespace.\n     #[error(\"left behind trailing whitespace\")]\n     TrailingWhitespace,\n-    /// TODO or FIXME item without an issue number.\n-    #[error(\"found {0}\")]\n-    BadIssue(Issue),\n-    /// License check has failed.\n-    #[error(\"license check failed\")]\n-    LicenseCheck,\n     /// Used deprecated skip attribute.\n     #[error(\"`rustfmt_skip` is deprecated; use `rustfmt::skip`\")]\n     DeprecatedAttr,\n@@ -237,11 +229,7 @@ impl FormatReport {\n                 ErrorKind::LostComment => {\n                     errs.has_unformatted_code_errors = true;\n                 }\n-                ErrorKind::BadIssue(_)\n-                | ErrorKind::LicenseCheck\n-                | ErrorKind::DeprecatedAttr\n-                | ErrorKind::BadAttr\n-                | ErrorKind::VersionMismatch => {\n+                ErrorKind::DeprecatedAttr | ErrorKind::BadAttr | ErrorKind::VersionMismatch => {\n                     errs.has_check_errors = true;\n                 }\n                 _ => {}"}, {"sha": "6bf8cd0c70be0653b5bb4d8904c0d2749925a3c3", "filename": "src/tools/rustfmt/src/overflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -32,7 +32,7 @@ use crate::utils::{count_newlines, extra_offset, first_line_width, last_line_wid\n /// Organized as a list of `(&str, usize)` tuples, giving the name of the macro and the number of\n /// arguments before the format string (none for `format!(\"format\", ...)`, one for `assert!(result,\n /// \"format\", ...)`, two for `assert_eq!(left, right, \"format\", ...)`).\n-const SPECIAL_MACRO_WHITELIST: &[(&str, usize)] = &[\n+const SPECIAL_CASE_MACROS: &[(&str, usize)] = &[\n     // format! like macros\n     // From the Rust Standard Library.\n     (\"eprint!\", 0),\n@@ -60,7 +60,7 @@ const SPECIAL_MACRO_WHITELIST: &[(&str, usize)] = &[\n     (\"debug_assert_ne!\", 2),\n ];\n \n-const SPECIAL_ATTR_WHITELIST: &[(&str, usize)] = &[\n+const SPECIAL_CASE_ATTR: &[(&str, usize)] = &[\n     // From the `failure` crate.\n     (\"fail\", 0),\n ];\n@@ -182,10 +182,10 @@ impl<'a> OverflowableItem<'a> {\n         }\n     }\n \n-    fn whitelist(&self) -> &'static [(&'static str, usize)] {\n+    fn special_cases(&self) -> &'static [(&'static str, usize)] {\n         match self {\n-            OverflowableItem::MacroArg(..) => SPECIAL_MACRO_WHITELIST,\n-            OverflowableItem::NestedMetaItem(..) => SPECIAL_ATTR_WHITELIST,\n+            OverflowableItem::MacroArg(..) => SPECIAL_CASE_MACROS,\n+            OverflowableItem::NestedMetaItem(..) => SPECIAL_CASE_ATTR,\n             _ => &[],\n         }\n     }\n@@ -770,7 +770,7 @@ pub(crate) fn maybe_get_args_offset(\n ) -> Option<(bool, usize)> {\n     if let Some(&(_, num_args_before)) = args\n         .get(0)?\n-        .whitelist()\n+        .special_cases()\n         .iter()\n         .find(|&&(s, _)| s == callee_str)\n     {"}, {"sha": "a0f71c2b8ba939325ac09d6d9ade34ac15bca2d6", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -170,7 +170,7 @@ impl ParseSess {\n     /// * `relative` - If Some(symbol), the symbol name is a directory relative to the dir_path.\n     ///   If relative is Some, resolve the submodle at {dir_path}/{symbol}/{id}.rs\n     ///   or {dir_path}/{symbol}/{id}/mod.rs. if None, resolve the module at {dir_path}/{id}.rs.\n-    /// *  `dir_path` - Module resolution will occur relative to this direcotry.\n+    /// *  `dir_path` - Module resolution will occur relative to this directory.\n     pub(crate) fn default_submod_path(\n         &self,\n         id: symbol::Ident,"}, {"sha": "8ae297de25bc22299b3be888d0aa2ee123223a02", "filename": "src/tools/rustfmt/src/reorder.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -11,8 +11,8 @@ use std::cmp::{Ord, Ordering};\n use rustc_ast::ast;\n use rustc_span::{symbol::sym, Span};\n \n-use crate::config::{Config, GroupImportsTactic, ImportGranularity};\n-use crate::imports::{flatten_use_trees, merge_use_trees, SharedPrefix, UseSegment, UseTree};\n+use crate::config::{Config, GroupImportsTactic};\n+use crate::imports::{normalize_use_trees_with_granularity, UseSegment, UseTree};\n use crate::items::{is_mod_decl, rewrite_extern_crate, rewrite_mod};\n use crate::lists::{itemize_list, write_list, ListFormatting, ListItem};\n use crate::rewrite::RewriteContext;\n@@ -107,15 +107,10 @@ fn rewrite_reorderable_or_regroupable_items(\n             for (item, list_item) in normalized_items.iter_mut().zip(list_items) {\n                 item.list_item = Some(list_item.clone());\n             }\n-            normalized_items = match context.config.imports_granularity() {\n-                ImportGranularity::Crate => merge_use_trees(normalized_items, SharedPrefix::Crate),\n-                ImportGranularity::Module => {\n-                    merge_use_trees(normalized_items, SharedPrefix::Module)\n-                }\n-                ImportGranularity::Item => flatten_use_trees(normalized_items),\n-                ImportGranularity::One => merge_use_trees(normalized_items, SharedPrefix::One),\n-                ImportGranularity::Preserve => normalized_items,\n-            };\n+            normalized_items = normalize_use_trees_with_granularity(\n+                normalized_items,\n+                context.config.imports_granularity(),\n+            );\n \n             let mut regrouped_items = match context.config.group_imports() {\n                 GroupImportsTactic::Preserve | GroupImportsTactic::One => {"}, {"sha": "f97df70cc6a7b3f3688d586e657637d2fab1889b", "filename": "src/tools/rustfmt/src/rewrite.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -12,6 +12,7 @@ use crate::shape::Shape;\n use crate::skip::SkipContext;\n use crate::visitor::SnippetProvider;\n use crate::FormatReport;\n+use rustc_data_structures::stable_map::FxHashMap;\n \n pub(crate) trait Rewrite {\n     /// Rewrite self into shape.\n@@ -24,10 +25,22 @@ impl<T: Rewrite> Rewrite for ptr::P<T> {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct QueryId {\n+    pub(crate) shape: Shape,\n+    pub(crate) span: Span,\n+}\n+\n+// We use Option<HashMap> instead of HashMap, because in case of `None`\n+// the function clean the memoize map, but it doesn't clean when\n+// there is `Some(empty)`, so they are different.\n+pub(crate) type Memoize = Rc<Cell<Option<FxHashMap<QueryId, Option<String>>>>>;\n+\n #[derive(Clone)]\n pub(crate) struct RewriteContext<'a> {\n     pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) config: &'a Config,\n+    pub(crate) memoize: Memoize,\n     pub(crate) inside_macro: Rc<Cell<bool>>,\n     // Force block indent style even if we are using visual indent style.\n     pub(crate) use_block: Cell<bool>,"}, {"sha": "b3f785a9470ee879e5aa527cb9b9d33a75a7fe33", "filename": "src/tools/rustfmt/src/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fshape.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -4,7 +4,7 @@ use std::ops::{Add, Sub};\n \n use crate::Config;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub(crate) struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of\n     // Config::tab_spaces.\n@@ -139,7 +139,7 @@ impl Sub<usize> for Indent {\n // 8096 is close enough to infinite for rustfmt.\n const INFINITE_SHAPE_WIDTH: usize = 8096;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub(crate) struct Shape {\n     pub(crate) width: usize,\n     // The current indentation of code."}, {"sha": "78b72a50cb2f96250ec94b1c86579d1246798424", "filename": "src/tools/rustfmt/src/string.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -315,27 +315,45 @@ fn break_string(max_width: usize, trim_end: bool, line_end: &str, input: &[&str]\n         // Found a whitespace and what is on its left side is big enough.\n         Some(index) if index >= MIN_STRING => break_at(index),\n         // No whitespace found, try looking for a punctuation instead\n-        _ => match input[0..max_width_index_in_input]\n-            .iter()\n-            .rposition(|grapheme| is_punctuation(grapheme))\n+        _ => match (0..max_width_index_in_input)\n+            .rev()\n+            .skip_while(|pos| !is_valid_linebreak(input, *pos))\n+            .next()\n         {\n             // Found a punctuation and what is on its left side is big enough.\n             Some(index) if index >= MIN_STRING => break_at(index),\n             // Either no boundary character was found to the left of `input[max_chars]`, or the line\n             // got too small. We try searching for a boundary character to the right.\n-            _ => match input[max_width_index_in_input..]\n-                .iter()\n-                .position(|grapheme| is_whitespace(grapheme) || is_punctuation(grapheme))\n+            _ => match (max_width_index_in_input..input.len())\n+                .skip_while(|pos| !is_valid_linebreak(input, *pos))\n+                .next()\n             {\n                 // A boundary was found after the line limit\n-                Some(index) => break_at(max_width_index_in_input + index),\n+                Some(index) => break_at(index),\n                 // No boundary to the right, the input cannot be broken\n                 None => SnippetState::EndOfInput(input.concat()),\n             },\n         },\n     }\n }\n \n+fn is_valid_linebreak(input: &[&str], pos: usize) -> bool {\n+    let is_whitespace = is_whitespace(input[pos]);\n+    if is_whitespace {\n+        return true;\n+    }\n+    let is_punctuation = is_punctuation(input[pos]);\n+    if is_punctuation && !is_part_of_type(input, pos) {\n+        return true;\n+    }\n+    false\n+}\n+\n+fn is_part_of_type(input: &[&str], pos: usize) -> bool {\n+    input.get(pos..=pos + 1) == Some(&[\":\", \":\"])\n+        || input.get(pos.saturating_sub(1)..=pos) == Some(&[\":\", \":\"])\n+}\n+\n fn is_new_line(grapheme: &str) -> bool {\n     let bytes = grapheme.as_bytes();\n     bytes.starts_with(b\"\\n\") || bytes.starts_with(b\"\\r\\n\")\n@@ -369,6 +387,19 @@ mod test {\n         rewrite_string(\"eq_\", &fmt, 2);\n     }\n \n+    #[test]\n+    fn line_break_at_valid_points_test() {\n+        let string = \"[TheName](Dont::break::my::type::That::would::be::very::nice) break here\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(\n+            break_string(20, false, \"\", &graphemes[..]),\n+            SnippetState::LineEnd(\n+                \"[TheName](Dont::break::my::type::That::would::be::very::nice) \".to_string(),\n+                62\n+            )\n+        );\n+    }\n+\n     #[test]\n     fn should_break_on_whitespace() {\n         let string = \"Placerat felis. Mauris porta ante sagittis purus.\";"}, {"sha": "6b5bc2b30dd5ad5895cdbec355ad7421212a0959", "filename": "src/tools/rustfmt/src/test/mod.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -9,7 +9,7 @@ use std::process::{Command, Stdio};\n use std::str::Chars;\n use std::thread;\n \n-use crate::config::{Color, Config, EmitMode, FileName, NewlineStyle, ReportTactic};\n+use crate::config::{Color, Config, EmitMode, FileName, NewlineStyle};\n use crate::formatting::{ReportedErrors, SourceFile};\n use crate::rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, ModifiedChunk, OutputWriter};\n use crate::source_file;\n@@ -24,7 +24,7 @@ mod parser;\n const DIFF_CONTEXT_SIZE: usize = 3;\n \n // A list of files on which we want to skip testing.\n-const SKIP_FILE_WHITE_LIST: &[&str] = &[\n+const FILE_SKIP_LIST: &[&str] = &[\n     // We want to make sure that the `skip_children` is correctly working,\n     // so we do not want to test this file directly.\n     \"configs/skip_children/foo/mod.rs\",\n@@ -90,7 +90,7 @@ where\n }\n \n fn is_file_skip(path: &Path) -> bool {\n-    SKIP_FILE_WHITE_LIST\n+    FILE_SKIP_LIST\n         .iter()\n         .any(|file_path| is_subpath(path, file_path))\n }\n@@ -578,6 +578,30 @@ fn stdin_generated_files_issue_5172() {\n     );\n }\n \n+#[test]\n+fn stdin_handles_mod_inner_ignore_attr() {\n+    // see https://github.com/rust-lang/rustfmt/issues/5368\n+    init_log();\n+    let input = String::from(\"#![rustfmt::skip]\\n\\nfn    main() {  }\");\n+    let mut child = Command::new(rustfmt().to_str().unwrap())\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .spawn()\n+        .expect(\"failed to execute child\");\n+\n+    {\n+        let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\n+        stdin\n+            .write_all(input.as_bytes())\n+            .expect(\"failed to write stdin\");\n+    }\n+\n+    let output = child.wait_with_output().expect(\"failed to wait on child\");\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(input, String::from_utf8(output.stdout).unwrap());\n+}\n+\n #[test]\n fn format_lines_errors_are_reported() {\n     init_log();\n@@ -688,9 +712,6 @@ fn read_config(filename: &Path) -> Config {\n         }\n     }\n \n-    // Don't generate warnings for to-do items.\n-    config.set().report_todo(ReportTactic::Never);\n-\n     config\n }\n \n@@ -957,12 +978,6 @@ fn rustfmt() -> PathBuf {\n     // Chop off `deps`.\n     me.pop();\n \n-    // If we run `cargo test --release`, we might only have a release build.\n-    if cfg!(release) {\n-        // `../release/`\n-        me.pop();\n-        me.push(\"release\");\n-    }\n     me.push(\"rustfmt\");\n     assert!(\n         me.is_file() || me.with_extension(\"exe\").is_file(),"}, {"sha": "3ff56d52f92d6e813c14fbc210119a4a85dae538", "filename": "src/tools/rustfmt/src/visitor.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -17,7 +17,7 @@ use crate::items::{\n use crate::macros::{macro_style, rewrite_macro, rewrite_macro_def, MacroPosition};\n use crate::modules::Module;\n use crate::parse::session::ParseSess;\n-use crate::rewrite::{Rewrite, RewriteContext};\n+use crate::rewrite::{Memoize, Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::skip::{is_skip_attr, SkipContext};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n@@ -71,6 +71,7 @@ impl SnippetProvider {\n \n pub(crate) struct FmtVisitor<'a> {\n     parent_context: Option<&'a RewriteContext<'a>>,\n+    pub(crate) memoize: Memoize,\n     pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) buffer: String,\n     pub(crate) last_pos: BytePos,\n@@ -758,6 +759,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ctx.config,\n             ctx.snippet_provider,\n             ctx.report.clone(),\n+            ctx.memoize.clone(),\n         );\n         visitor.skip_context.update(ctx.skip_context.clone());\n         visitor.set_parent_context(ctx);\n@@ -769,10 +771,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         config: &'a Config,\n         snippet_provider: &'a SnippetProvider,\n         report: FormatReport,\n+        memoize: Memoize,\n     ) -> FmtVisitor<'a> {\n         FmtVisitor {\n             parent_context: None,\n             parse_sess: parse_session,\n+            memoize,\n             buffer: String::with_capacity(snippet_provider.big_snippet.len() * 2),\n             last_pos: BytePos(0),\n             block_indent: Indent::empty(),\n@@ -995,6 +999,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         RewriteContext {\n             parse_sess: self.parse_sess,\n             config: self.config,\n+            memoize: self.memoize.clone(),\n             inside_macro: Rc::new(Cell::new(false)),\n             use_block: Cell::new(false),\n             is_if_else_block: Cell::new(false),"}, {"sha": "74ee8b010dd054ec1bdf80f0ca81f87a67cbf669", "filename": "src/tools/rustfmt/tests/config/issue-3802.toml", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3802.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3802.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3802.toml?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,2 +0,0 @@\n-unstable_features = true\n-license_template_path = \"\""}, {"sha": "c3cfd34317a377132f034e8a22c028bfac0a932d", "filename": "src/tools/rustfmt/tests/config/small_tabs.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fsmall_tabs.toml?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -6,7 +6,5 @@ brace_style = \"SameLineWhere\"\n fn_args_layout = \"Tall\"\n trailing_comma = \"Vertical\"\n indent_style = \"Block\"\n-report_todo = \"Always\"\n-report_fixme = \"Never\"\n reorder_imports = false\n format_strings = true"}, {"sha": "ea4390371a09adad8f9b2cc69af1ee917afb0b54", "filename": "src/tools/rustfmt/tests/license-template/lt.txt", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Flicense-template%2Flt.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Flicense-template%2Flt.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Flicense-template%2Flt.txt?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,2 +0,0 @@\n-// rustfmt-license_template_path: tests/license-template/lt.txt\n-// Copyright {\\d+} The rustfmt developers."}, {"sha": "4c6d52726f3fe0525d391642570583e6997cec44", "filename": "src/tools/rustfmt/tests/rustfmt/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Frustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Frustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Frustfmt%2Fmain.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -143,7 +143,7 @@ fn mod_resolution_error_relative_module_not_found() {\n     let args = [\"tests/mod-resolver/module-not-found/relative_module/lib.rs\"];\n     let (_stdout, stderr) = rustfmt(&args);\n     // The file `./a.rs` and directory `./a` both exist.\n-    // Module resolution fails becuase we're unable to find `./a/b.rs`\n+    // Module resolution fails because we're unable to find `./a/b.rs`\n     #[cfg(not(windows))]\n     assert!(stderr.contains(\"a/b.rs does not exist\"));\n     #[cfg(windows)]"}, {"sha": "f239a0efa08552076307ae7c30dfa6c122581fe0", "filename": "src/tools/rustfmt/tests/source/configs/group_imports/StdExternalCrate-non_consecutive.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-non_consecutive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-non_consecutive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-non_consecutive.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,27 @@\n+// rustfmt-group_imports: StdExternalCrate\n+use chrono::Utc;\n+use super::update::convert_publish_payload;\n+\n+\n+\n+\n+\n+use juniper::{FieldError, FieldResult};\n+\n+use uuid::Uuid;\n+use alloc::alloc::Layout;\n+\n+extern crate uuid;\n+\n+\n+\n+\n+\n+use std::sync::Arc;\n+\n+\n+use broker::database::PooledConnection;\n+\n+use super::schema::{Context, Payload};\n+use core::f32;\n+use crate::models::Event;"}, {"sha": "d290d8d91858d9ba7ff970619a5107bca90a61fe", "filename": "src/tools/rustfmt/tests/source/imports/imports-impl-only-use.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-impl-only-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-impl-only-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-impl-only-use.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/source/imports-impl-only-use.rs"}, {"sha": "b6380f31c6104117067a1e72098389ef838d11d0", "filename": "src/tools/rustfmt/tests/source/imports/imports-reorder-lines-and-items.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder-lines-and-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder-lines-and-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder-lines-and-items.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/source/imports-reorder-lines-and-items.rs"}, {"sha": "2b018544eaeb259150cb7086a0220fadf30a10aa", "filename": "src/tools/rustfmt/tests/source/imports/imports-reorder-lines.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder-lines.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/source/imports-reorder-lines.rs"}, {"sha": "cbe9d6ca78ad7dbf8ce5152cba81ebd417a7946d", "filename": "src/tools/rustfmt/tests/source/imports/imports-reorder.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports-reorder.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/source/imports-reorder.rs"}, {"sha": "4dfc6ed94e34f1acf717436dc73429980d01916a", "filename": "src/tools/rustfmt/tests/source/imports/imports.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/source/imports.rs"}, {"sha": "016deefe58c0fcda3271ac58b33186caed12d564", "filename": "src/tools/rustfmt/tests/source/imports/imports_block_indent.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_block_indent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_block_indent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_block_indent.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/source/imports_block_indent.rs"}, {"sha": "f6f7761e82ee79dcb55b2a23aa89253e6a468885", "filename": "src/tools/rustfmt/tests/source/imports/imports_granularity_crate.rs", "status": "renamed", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_crate.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -35,3 +35,31 @@ use j::{a::{self}};\n \n use {k::{a, b}, l::{a, b}};\n use {k::{c, d}, l::{c, d}};\n+\n+use b::{f::g, h::{i, j} /* After b::h group */};\n+use b::e;\n+use b::{/* Before b::l group */ l::{self, m, n::o, p::*}, q};\n+use b::d;\n+use b::r; // After b::r\n+use b::q::{self /* After b::q::self */};\n+use b::u::{\n+    a,\n+    b,\n+};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::c;", "previous_filename": "src/tools/rustfmt/tests/source/imports_granularity_crate.rs"}, {"sha": "cbb21a9f1b38c27b8d1f8e8710d4453cc6660dd3", "filename": "src/tools/rustfmt/tests/source/imports/imports_granularity_default-with-dups.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_default-with-dups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_default-with-dups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_default-with-dups.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,6 @@\n+use crate::lexer;\n+use crate::lexer::tokens::TokenData;\n+use crate::lexer::{tokens::TokenData};\n+use crate::lexer::self;\n+use crate::lexer::{self};\n+use crate::lexer::{self, tokens::TokenData};"}, {"sha": "e23705a884fef985d7324e04b9adaaab08b95203", "filename": "src/tools/rustfmt/tests/source/imports/imports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,13 @@\n+// rustfmt-imports_granularity: Item\n+// rustfmt-reorder_imports: false\n+// rustfmt-group_imports: StdExternalCrate\n+\n+use crate::lexer;\n+use crate::lexer;\n+use crate::lexer::tokens::TokenData;\n+use crate::lexer::{tokens::TokenData};\n+use crate::lexer::self;\n+use crate::lexer;\n+use crate::lexer;\n+use crate::lexer::{self};\n+use crate::lexer::{self, tokens::TokenData};"}, {"sha": "3e9589c299f68bfa7fbdbee71f2e91a185742aa2", "filename": "src/tools/rustfmt/tests/source/imports/imports_granularity_item-with-dups.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item-with-dups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item-with-dups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item-with-dups.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,11 @@\n+// rustfmt-imports_granularity: Item\n+\n+use crate::lexer;\n+use crate::lexer;\n+use crate::lexer::tokens::TokenData;\n+use crate::lexer::{tokens::TokenData};\n+use crate::lexer::self;\n+use crate::lexer;\n+use crate::lexer;\n+use crate::lexer::{self};\n+use crate::lexer::{self, tokens::TokenData};"}, {"sha": "b82c0d33cafded60dc04b1458cff622fe3797970", "filename": "src/tools/rustfmt/tests/source/imports/imports_granularity_item.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_item.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,34 @@\n+// rustfmt-imports_granularity: Item\n+\n+use a::{b, c, d};\n+use a::{f::g, h::{i, j}};\n+use a::{l::{self, m, n::o, p::*}};\n+use a::q::{self};\n+\n+use b::{f::g, h::{i, j} /* After b::h group */};\n+use b::e;\n+use b::{/* Before b::l group */ l::{self, m, n::o, p::*}, q};\n+use b::d;\n+use b::r; // After b::r\n+use b::q::{self /* After b::q::self */};\n+use b::u::{\n+    a,\n+    b,\n+};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::c;"}, {"sha": "c7f68cea6d47af472caacf61f70f648b0f47edc8", "filename": "src/tools/rustfmt/tests/source/imports/imports_granularity_module.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports%2Fimports_granularity_module.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,47 @@\n+// rustfmt-imports_granularity: Module\n+\n+use a::{b::c, d::e};\n+use a::{f, g::{h, i}};\n+use a::{j::{self, k::{self, l}, m}, n::{o::p, q}};\n+pub use a::{r::s, t};\n+use b::{c::d, self};\n+\n+#[cfg(test)]\n+use foo::{a::b, c::d};\n+use foo::e;\n+\n+use bar::{\n+    // comment\n+    a::b,\n+    // more comment\n+    c::d,\n+    e::f,\n+};\n+\n+use b::{f::g, h::{i, j} /* After b::h group */};\n+use b::e;\n+use b::{/* Before b::l group */ l::{self, m, n::o, p::*}, q};\n+use b::d;\n+use b::r; // After b::r\n+use b::q::{self /* After b::q::self */};\n+use b::u::{\n+    a,\n+    b,\n+};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::c;"}, {"sha": "d0e94df66ae2a25b620b09fc7b646c63036f8d8b", "filename": "src/tools/rustfmt/tests/source/imports_granularity_item.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_item.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,6 +0,0 @@\n-// rustfmt-imports_granularity: Item\n-\n-use a::{b, c, d};\n-use a::{f::g, h::{i, j}};\n-use a::{l::{self, m, n::o, p::*}};\n-use a::q::{self};"}, {"sha": "2d7bb299aaacef723e33266587af6c1dca936d6a", "filename": "src/tools/rustfmt/tests/source/imports_granularity_module.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_module.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,19 +0,0 @@\n-// rustfmt-imports_granularity: Module\n-\n-use a::{b::c, d::e};\n-use a::{f, g::{h, i}};\n-use a::{j::{self, k::{self, l}, m}, n::{o::p, q}};\n-pub use a::{r::s, t};\n-use b::{c::d, self};\n-\n-#[cfg(test)]\n-use foo::{a::b, c::d};\n-use foo::e;\n-\n-use bar::{\n-    // comment\n-    a::b,\n-    // more comment\n-    c::d,\n-    e::f,\n-};"}, {"sha": "4d5a47956413229bb42ccd4eac5e2ee5a9413610", "filename": "src/tools/rustfmt/tests/source/imports_granularity_one.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fimports_granularity_one.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -58,3 +58,31 @@ use a::{\n };\n use b as x;\n use a::ad::ada;\n+\n+use b::{f::g, h::{i, j} /* After b::h group */};\n+use b::e;\n+use b::{/* Before b::l group */ l::{self, m, n::o, p::*}, q};\n+use b::d;\n+use b::r; // After b::r\n+use b::q::{self /* After b::q::self */};\n+use b::u::{\n+    a,\n+    b,\n+};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::c;"}, {"sha": "08ffaac7d1dc2a77f4cf202db2a02828328daa5e", "filename": "src/tools/rustfmt/tests/source/issue-5030.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-5030.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-5030.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-5030.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,22 @@\n+// rustfmt-imports_granularity: Item\n+// rustfmt-group_imports: One\n+\n+// Confirm that attributes are duplicated to all items in the use statement\n+#[cfg(feature = \"foo\")]\n+use std::collections::{\n+    HashMap,\n+    HashSet,\n+};\n+\n+// Separate the imports below from the ones above\n+const A: usize = 0;\n+\n+// Copying attrs works with import grouping as well\n+#[cfg(feature = \"foo\")]\n+use std::collections::{\n+    HashMap,\n+    HashSet,\n+};\n+\n+#[cfg(feature = \"spam\")]\n+use qux::{bar, baz};"}, {"sha": "c0606817290cde01b0455d168b5e7f0fc5d78800", "filename": "src/tools/rustfmt/tests/source/issue-5260.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-5260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-5260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-5260.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,14 @@\n+// rustfmt-wrap_comments: true\n+\n+/// [MyType](VeryLongPathToMyType::NoLineBreak::Here::Okay::ThatWouldBeNice::Thanks)\n+fn documented_with_longtype() {\n+    // # We're using a long type link, rustfmt should not break line\n+    // on the type when `wrap_comments = true`\n+}\n+\n+/// VeryLongPathToMyType::JustMyType::But::VeryVery::Long::NoLineBreak::Here::Okay::ThatWouldBeNice::Thanks\n+fn documented_with_verylongtype() {\n+    // # We're using a long type link, rustfmt should not break line\n+    // on the type when `wrap_comments = true`\n+}\n+"}, {"sha": "d3a91e4231d195930c3d60c2ab3111fb55064a3a", "filename": "src/tools/rustfmt/tests/source/license-templates/empty_license_path.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flicense-templates%2Fempty_license_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flicense-templates%2Fempty_license_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flicense-templates%2Fempty_license_path.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,5 +0,0 @@\n-// rustfmt-config: issue-3802.toml\n-\n-fn main() {\n-println!(\"Hello world!\");\n-}"}, {"sha": "6816011c60dc519377d8a66ab66ce13224400171", "filename": "src/tools/rustfmt/tests/source/license-templates/license.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flicense-templates%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flicense-templates%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flicense-templates%2Flicense.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,6 +0,0 @@\n-// rustfmt-license_template_path: tests/license-template/lt.txt\n-// Copyright 2019 The rustfmt developers.\n-\n-fn main() {\n-println!(\"Hello world!\");\n-}"}, {"sha": "8da3f19b62d6004b3faf6439f65dec1bc07a0b7d", "filename": "src/tools/rustfmt/tests/source/performance/issue-4476.rs", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fperformance%2Fissue-4476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fperformance%2Fissue-4476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fperformance%2Fissue-4476.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,638 @@\n+use super::SemverParser;\n+\n+#[allow(dead_code, non_camel_case_types)]\n+#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub enum Rule {\n+  EOI,\n+  range_set,\n+  logical_or,\n+  range,\n+  empty,\n+  hyphen,\n+  simple,\n+  primitive,\n+  primitive_op,\n+  partial,\n+  xr,\n+  xr_op,\n+  nr,\n+  tilde,\n+  caret,\n+  qualifier,\n+  parts,\n+  part,\n+  space,\n+}\n+#[allow(clippy::all)]\n+impl ::pest::Parser<Rule> for SemverParser {\n+  fn parse<'i>(\n+    rule: Rule,\n+    input: &'i str,\n+  ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>> {\n+    mod rules {\n+      pub mod hidden {\n+        use super::super::Rule;\n+        #[inline]\n+        #[allow(dead_code, non_snake_case, unused_variables)]\n+        pub fn skip(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          Ok(state)\n+        }\n+      }\n+      pub mod visible {\n+        use super::super::Rule;\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn range_set(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::range_set, |state| {\n+            state.sequence(|state| {\n+              self::SOI(state)\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      self::space(state).and_then(|state| {\n+                        state.repeat(|state| {\n+                          state.sequence(|state| {\n+                            super::hidden::skip(state).and_then(|state| self::space(state))\n+                          })\n+                        })\n+                      })\n+                    })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| self::range(state))\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      state\n+                        .sequence(|state| {\n+                          self::logical_or(state)\n+                            .and_then(|state| super::hidden::skip(state))\n+                            .and_then(|state| self::range(state))\n+                        })\n+                        .and_then(|state| {\n+                          state.repeat(|state| {\n+                            state.sequence(|state| {\n+                              super::hidden::skip(state).and_then(|state| {\n+                                state.sequence(|state| {\n+                                  self::logical_or(state)\n+                                    .and_then(|state| super::hidden::skip(state))\n+                                    .and_then(|state| self::range(state))\n+                                })\n+                              })\n+                            })\n+                          })\n+                        })\n+                    })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      self::space(state).and_then(|state| {\n+                        state.repeat(|state| {\n+                          state.sequence(|state| {\n+                            super::hidden::skip(state).and_then(|state| self::space(state))\n+                          })\n+                        })\n+                      })\n+                    })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| self::EOI(state))\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn logical_or(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::logical_or, |state| {\n+            state.sequence(|state| {\n+              state\n+                .sequence(|state| {\n+                  state.optional(|state| {\n+                    self::space(state).and_then(|state| {\n+                      state.repeat(|state| {\n+                        state.sequence(|state| {\n+                          super::hidden::skip(state).and_then(|state| self::space(state))\n+                        })\n+                      })\n+                    })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| state.match_string(\"||\"))\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      self::space(state).and_then(|state| {\n+                        state.repeat(|state| {\n+                          state.sequence(|state| {\n+                            super::hidden::skip(state).and_then(|state| self::space(state))\n+                          })\n+                        })\n+                      })\n+                    })\n+                  })\n+                })\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn range(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::range, |state| {\n+            self::hyphen(state)\n+              .or_else(|state| {\n+                state.sequence(|state| {\n+                  self::simple(state)\n+                    .and_then(|state| super::hidden::skip(state))\n+                    .and_then(|state| {\n+                      state.sequence(|state| {\n+                        state.optional(|state| {\n+                          state\n+                            .sequence(|state| {\n+                              state\n+                                .optional(|state| state.match_string(\",\"))\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                  state.sequence(|state| {\n+                                    self::space(state)\n+                                      .and_then(|state| super::hidden::skip(state))\n+                                      .and_then(|state| {\n+                                        state.sequence(|state| {\n+                                          state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                              state.repeat(|state| {\n+                                                state.sequence(|state| {\n+                                                  super::hidden::skip(state)\n+                                                    .and_then(|state| self::space(state))\n+                                                })\n+                                              })\n+                                            })\n+                                          })\n+                                        })\n+                                      })\n+                                  })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::simple(state))\n+                            })\n+                            .and_then(|state| {\n+                              state.repeat(|state| {\n+                                state.sequence(|state| {\n+                                  super::hidden::skip(state).and_then(|state| {\n+                                    state.sequence(|state| {\n+                                      state\n+                                        .optional(|state| state.match_string(\",\"))\n+                                        .and_then(|state| super::hidden::skip(state))\n+                                        .and_then(|state| {\n+                                          state.sequence(|state| {\n+                                            self::space(state)\n+                                              .and_then(|state| super::hidden::skip(state))\n+                                              .and_then(|state| {\n+                                                state.sequence(|state| {\n+                                                  state.optional(|state| {\n+                                                    self::space(state).and_then(|state| {\n+                                                      state.repeat(|state| {\n+                                                        state.sequence(|state| {\n+                                                          super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                        })\n+                                                      })\n+                                                    })\n+                                                  })\n+                                                })\n+                                              })\n+                                          })\n+                                        })\n+                                        .and_then(|state| super::hidden::skip(state))\n+                                        .and_then(|state| self::simple(state))\n+                                    })\n+                                  })\n+                                })\n+                              })\n+                            })\n+                        })\n+                      })\n+                    })\n+                })\n+              })\n+              .or_else(|state| self::empty(state))\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn empty(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::empty, |state| state.match_string(\"\"))\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn hyphen(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::hyphen, |state| {\n+            state.sequence(|state| {\n+              self::partial(state)\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    self::space(state)\n+                      .and_then(|state| super::hidden::skip(state))\n+                      .and_then(|state| {\n+                        state.sequence(|state| {\n+                          state.optional(|state| {\n+                            self::space(state).and_then(|state| {\n+                              state.repeat(|state| {\n+                                state.sequence(|state| {\n+                                  super::hidden::skip(state).and_then(|state| self::space(state))\n+                                })\n+                              })\n+                            })\n+                          })\n+                        })\n+                      })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| state.match_string(\"-\"))\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    self::space(state)\n+                      .and_then(|state| super::hidden::skip(state))\n+                      .and_then(|state| {\n+                        state.sequence(|state| {\n+                          state.optional(|state| {\n+                            self::space(state).and_then(|state| {\n+                              state.repeat(|state| {\n+                                state.sequence(|state| {\n+                                  super::hidden::skip(state).and_then(|state| self::space(state))\n+                                })\n+                              })\n+                            })\n+                          })\n+                        })\n+                      })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| self::partial(state))\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn simple(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::simple, |state| {\n+            self::primitive(state)\n+              .or_else(|state| self::partial(state))\n+              .or_else(|state| self::tilde(state))\n+              .or_else(|state| self::caret(state))\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn primitive(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::primitive, |state| {\n+            state.sequence(|state| {\n+              self::primitive_op(state)\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      self::space(state).and_then(|state| {\n+                        state.repeat(|state| {\n+                          state.sequence(|state| {\n+                            super::hidden::skip(state).and_then(|state| self::space(state))\n+                          })\n+                        })\n+                      })\n+                    })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| self::partial(state))\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn primitive_op(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::primitive_op, |state| {\n+            state\n+              .match_string(\"<=\")\n+              .or_else(|state| state.match_string(\">=\"))\n+              .or_else(|state| state.match_string(\">\"))\n+              .or_else(|state| state.match_string(\"<\"))\n+              .or_else(|state| state.match_string(\"=\"))\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn partial(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::partial, |state| {\n+            state.sequence(|state| {\n+              self::xr(state)\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.optional(|state| {\n+                    state.sequence(|state| {\n+                      state\n+                        .match_string(\".\")\n+                        .and_then(|state| super::hidden::skip(state))\n+                        .and_then(|state| self::xr(state))\n+                        .and_then(|state| super::hidden::skip(state))\n+                        .and_then(|state| {\n+                          state.optional(|state| {\n+                            state.sequence(|state| {\n+                              state\n+                                .match_string(\".\")\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::xr(state))\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| state.optional(|state| self::qualifier(state)))\n+                            })\n+                          })\n+                        })\n+                    })\n+                  })\n+                })\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn xr(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::xr, |state| {\n+            self::xr_op(state).or_else(|state| self::nr(state))\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn xr_op(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::xr_op, |state| {\n+            state\n+              .match_string(\"x\")\n+              .or_else(|state| state.match_string(\"X\"))\n+              .or_else(|state| state.match_string(\"*\"))\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn nr(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::nr, |state| {\n+            state.match_string(\"0\").or_else(|state| {\n+              state.sequence(|state| {\n+                state\n+                  .match_range('1'..'9')\n+                  .and_then(|state| super::hidden::skip(state))\n+                  .and_then(|state| {\n+                    state.sequence(|state| {\n+                      state.optional(|state| {\n+                        state.match_range('0'..'9').and_then(|state| {\n+                          state.repeat(|state| {\n+                            state.sequence(|state| {\n+                              super::hidden::skip(state)\n+                                .and_then(|state| state.match_range('0'..'9'))\n+                            })\n+                          })\n+                        })\n+                      })\n+                    })\n+                  })\n+              })\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn tilde(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::tilde, |state| {\n+            state.sequence(|state| {\n+              state\n+                .match_string(\"~>\")\n+                .or_else(|state| state.match_string(\"~\"))\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      self::space(state).and_then(|state| {\n+                        state.repeat(|state| {\n+                          state.sequence(|state| {\n+                            super::hidden::skip(state).and_then(|state| self::space(state))\n+                          })\n+                        })\n+                      })\n+                    })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| self::partial(state))\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn caret(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::caret, |state| {\n+            state.sequence(|state| {\n+              state\n+                .match_string(\"^\")\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      self::space(state).and_then(|state| {\n+                        state.repeat(|state| {\n+                          state.sequence(|state| {\n+                            super::hidden::skip(state).and_then(|state| self::space(state))\n+                          })\n+                        })\n+                      })\n+                    })\n+                  })\n+                })\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| self::partial(state))\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn qualifier(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::qualifier, |state| {\n+            state.sequence(|state| {\n+              state\n+                .match_string(\"-\")\n+                .or_else(|state| state.match_string(\"+\"))\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| self::parts(state))\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn parts(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::parts, |state| {\n+            state.sequence(|state| {\n+              self::part(state)\n+                .and_then(|state| super::hidden::skip(state))\n+                .and_then(|state| {\n+                  state.sequence(|state| {\n+                    state.optional(|state| {\n+                      state\n+                        .sequence(|state| {\n+                          state\n+                            .match_string(\".\")\n+                            .and_then(|state| super::hidden::skip(state))\n+                            .and_then(|state| self::part(state))\n+                        })\n+                        .and_then(|state| {\n+                          state.repeat(|state| {\n+                            state.sequence(|state| {\n+                              super::hidden::skip(state).and_then(|state| {\n+                                state.sequence(|state| {\n+                                  state\n+                                    .match_string(\".\")\n+                                    .and_then(|state| super::hidden::skip(state))\n+                                    .and_then(|state| self::part(state))\n+                                })\n+                              })\n+                            })\n+                          })\n+                        })\n+                    })\n+                  })\n+                })\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn part(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::part, |state| {\n+            self::nr(state).or_else(|state| {\n+              state.sequence(|state| {\n+                state\n+                  .match_string(\"-\")\n+                  .or_else(|state| state.match_range('0'..'9'))\n+                  .or_else(|state| state.match_range('A'..'Z'))\n+                  .or_else(|state| state.match_range('a'..'z'))\n+                  .and_then(|state| super::hidden::skip(state))\n+                  .and_then(|state| {\n+                    state.sequence(|state| {\n+                      state.optional(|state| {\n+                        state\n+                          .match_string(\"-\")\n+                          .or_else(|state| state.match_range('0'..'9'))\n+                          .or_else(|state| state.match_range('A'..'Z'))\n+                          .or_else(|state| state.match_range('a'..'z'))\n+                          .and_then(|state| {\n+                            state.repeat(|state| {\n+                              state.sequence(|state| {\n+                                super::hidden::skip(state).and_then(|state| {\n+                                  state\n+                                    .match_string(\"-\")\n+                                    .or_else(|state| state.match_range('0'..'9'))\n+                                    .or_else(|state| state.match_range('A'..'Z'))\n+                                    .or_else(|state| state.match_range('a'..'z'))\n+                                })\n+                              })\n+                            })\n+                          })\n+                      })\n+                    })\n+                  })\n+              })\n+            })\n+          })\n+        }\n+        #[inline]\n+        #[allow(non_snake_case, unused_variables)]\n+        pub fn space(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state\n+            .match_string(\" \")\n+            .or_else(|state| state.match_string(\"\\t\"))\n+        }\n+        #[inline]\n+        #[allow(dead_code, non_snake_case, unused_variables)]\n+        pub fn EOI(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.rule(Rule::EOI, |state| state.end_of_input())\n+        }\n+        #[inline]\n+        #[allow(dead_code, non_snake_case, unused_variables)]\n+        pub fn SOI(\n+          state: Box<::pest::ParserState<Rule>>,\n+        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+          state.start_of_input()\n+        }\n+      }\n+      pub use self::visible::*;\n+    }\n+    ::pest::state(input, |state| match rule {\n+      Rule::range_set => rules::range_set(state),\n+      Rule::logical_or => rules::logical_or(state),\n+      Rule::range => rules::range(state),\n+      Rule::empty => rules::empty(state),\n+      Rule::hyphen => rules::hyphen(state),\n+      Rule::simple => rules::simple(state),\n+      Rule::primitive => rules::primitive(state),\n+      Rule::primitive_op => rules::primitive_op(state),\n+      Rule::partial => rules::partial(state),\n+      Rule::xr => rules::xr(state),\n+      Rule::xr_op => rules::xr_op(state),\n+      Rule::nr => rules::nr(state),\n+      Rule::tilde => rules::tilde(state),\n+      Rule::caret => rules::caret(state),\n+      Rule::qualifier => rules::qualifier(state),\n+      Rule::parts => rules::parts(state),\n+      Rule::part => rules::part(state),\n+      Rule::space => rules::space(state),\n+      Rule::EOI => rules::EOI(state),\n+    })\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "3adce49601c0ca0805daed8cba5dc8e7edcf118e", "filename": "src/tools/rustfmt/tests/source/performance/issue-5128.rs", "status": "added", "additions": 5127, "deletions": 0, "changes": 5127, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fperformance%2Fissue-5128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fperformance%2Fissue-5128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fperformance%2Fissue-5128.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad"}, {"sha": "191a621004593a42711affddb1941db393602576", "filename": "src/tools/rustfmt/tests/source/struct_field_doc_comment.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fstruct_field_doc_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fstruct_field_doc_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fstruct_field_doc_comment.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,72 @@\n+// #5215\n+struct MyTuple(\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */ u32,\n+    /// Doc Comments\n+    // TODO note\n+    u64,\n+);\n+\n+struct MyTuple(\n+    #[cfg(unix)] // some comment\n+    u64,\n+    #[cfg(not(unix))] /*block comment */\n+    u32,\n+);\n+\n+struct MyTuple(\n+    #[cfg(unix)]\n+    // some comment\n+    u64,\n+    #[cfg(not(unix))]\n+    /*block comment */\n+    u32,\n+);\n+\n+struct MyTuple(\n+    #[cfg(unix)] // some comment\n+    pub u64,\n+    #[cfg(not(unix))] /*block comment */\n+    pub(crate) u32,\n+);\n+\n+struct MyTuple(\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */\n+    pub u32,\n+    /// Doc Comments\n+    // TODO note\n+    pub(crate) u64,\n+);\n+\n+struct MyStruct {\n+    #[cfg(unix)] // some comment\n+    a: u64,\n+    #[cfg(not(unix))] /*block comment */\n+    b: u32,\n+}\n+\n+struct MyStruct {\n+    #[cfg(unix)] // some comment\n+    pub a: u64,\n+    #[cfg(not(unix))] /*block comment */\n+    pub(crate) b: u32,\n+}\n+\n+struct MyStruct {\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */\n+    a: u32,\n+    /// Doc Comments\n+    // TODO note\n+    b: u64,\n+}\n+\n+struct MyStruct {\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */\n+    pub a: u32,\n+    /// Doc Comments\n+    // TODO note\n+    pub(crate) b: u64,\n+}"}, {"sha": "ecc8ede02cc612961f00f5740e716b9b210b7bb5", "filename": "src/tools/rustfmt/tests/target/configs/group_imports/StdExternalCrate-non_consecutive.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-non_consecutive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-non_consecutive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-non_consecutive.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,18 @@\n+// rustfmt-group_imports: StdExternalCrate\n+use alloc::alloc::Layout;\n+\n+use chrono::Utc;\n+use juniper::{FieldError, FieldResult};\n+use uuid::Uuid;\n+\n+use super::update::convert_publish_payload;\n+\n+extern crate uuid;\n+\n+use core::f32;\n+use std::sync::Arc;\n+\n+use broker::database::PooledConnection;\n+\n+use super::schema::{Context, Payload};\n+use crate::models::Event;"}, {"sha": "fd09d50d72d9a525365050f3c08a1105db79b83d", "filename": "src/tools/rustfmt/tests/target/imports/import-fencepost-length.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimport-fencepost-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimport-fencepost-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimport-fencepost-length.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/import-fencepost-length.rs"}, {"sha": "d290d8d91858d9ba7ff970619a5107bca90a61fe", "filename": "src/tools/rustfmt/tests/target/imports/imports-impl-only-use.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-impl-only-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-impl-only-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-impl-only-use.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/imports-impl-only-use.rs"}, {"sha": "98a5afe43480a9e2ee85311a3ea1ed00f078bcdc", "filename": "src/tools/rustfmt/tests/target/imports/imports-reorder-lines-and-items.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder-lines-and-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder-lines-and-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder-lines-and-items.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/imports-reorder-lines-and-items.rs"}, {"sha": "5b85503b55d0b49b17168dee7aa01fbd74bcea3d", "filename": "src/tools/rustfmt/tests/target/imports/imports-reorder-lines.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder-lines.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/imports-reorder-lines.rs"}, {"sha": "84e97c0224f831209afc9ca395cf4e3901ec31be", "filename": "src/tools/rustfmt/tests/target/imports/imports-reorder.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports-reorder.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/imports-reorder.rs"}, {"sha": "87584d89f6637f3dfd6046e99cb12e9c7bfbe3bf", "filename": "src/tools/rustfmt/tests/target/imports/imports.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/imports.rs"}, {"sha": "34dcc866a0bda150ecc8319e7a5096264e9dd473", "filename": "src/tools/rustfmt/tests/target/imports/imports_2021_edition.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_2021_edition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_2021_edition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_2021_edition.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/imports_2021_edition.rs"}, {"sha": "8c90f7ce29c812b4c5b80730005898ebaeff1448", "filename": "src/tools/rustfmt/tests/target/imports/imports_block_indent.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_block_indent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_block_indent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_block_indent.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "previous_filename": "src/tools/rustfmt/tests/target/imports_block_indent.rs"}, {"sha": "36e01558ff041f693defdf638800a887951b344a", "filename": "src/tools/rustfmt/tests/target/imports/imports_granularity_crate.rs", "status": "renamed", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_crate.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -26,3 +26,34 @@ use j::a::{self};\n \n use k::{a, b, c, d};\n use l::{a, b, c, d};\n+\n+use b::q::{self /* After b::q::self */};\n+use b::r; // After b::r\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::{\n+    c, d, e,\n+    u::{a, b},\n+};\n+use b::{\n+    f::g,\n+    h::{i, j}, /* After b::h group */\n+};\n+use b::{\n+    /* Before b::l group */ l::{self, m, n::o, p::*},\n+    q,\n+};", "previous_filename": "src/tools/rustfmt/tests/target/imports_granularity_crate.rs"}, {"sha": "5da6d588e6dd6580091028686940750a2c68309e", "filename": "src/tools/rustfmt/tests/target/imports/imports_granularity_default-with-dups.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_default-with-dups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_default-with-dups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_default-with-dups.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,6 @@\n+use crate::lexer;\n+use crate::lexer;\n+use crate::lexer::tokens::TokenData;\n+use crate::lexer::tokens::TokenData;\n+use crate::lexer::{self};\n+use crate::lexer::{self, tokens::TokenData};"}, {"sha": "ed4df544d6f9f9cfe485621a84f81d9db610d198", "filename": "src/tools/rustfmt/tests/target/imports/imports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item-with-dups-StdExternalCrate-no-reorder.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,7 @@\n+// rustfmt-imports_granularity: Item\n+// rustfmt-reorder_imports: false\n+// rustfmt-group_imports: StdExternalCrate\n+\n+use crate::lexer;\n+use crate::lexer::tokens::TokenData;\n+use crate::lexer::{self};"}, {"sha": "00df37f933220bc3b8411080c8e4b9dd48abe785", "filename": "src/tools/rustfmt/tests/target/imports/imports_granularity_item-with-dups.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item-with-dups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item-with-dups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item-with-dups.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-imports_granularity: Item\n+\n+use crate::lexer;\n+use crate::lexer::tokens::TokenData;\n+use crate::lexer::{self};"}, {"sha": "d2f5496fdacadc1a1c2d3b42e1a11e85356313be", "filename": "src/tools/rustfmt/tests/target/imports/imports_granularity_item.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_item.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,45 @@\n+// rustfmt-imports_granularity: Item\n+\n+use a::b;\n+use a::c;\n+use a::d;\n+use a::f::g;\n+use a::h::i;\n+use a::h::j;\n+use a::l::m;\n+use a::l::n::o;\n+use a::l::p::*;\n+use a::l::{self};\n+use a::q::{self};\n+\n+use b::c;\n+use b::d;\n+use b::e;\n+use b::q::{self /* After b::q::self */};\n+use b::r; // After b::r\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::u::a;\n+use b::u::b;\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::{\n+    f::g,\n+    h::{i, j}, /* After b::h group */\n+};\n+use b::{\n+    /* Before b::l group */ l::{self, m, n::o, p::*},\n+    q,\n+};"}, {"sha": "14f341016ff9172af2d8200ac3f868dd64f83039", "filename": "src/tools/rustfmt/tests/target/imports/imports_granularity_module.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports%2Fimports_granularity_module.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,55 @@\n+// rustfmt-imports_granularity: Module\n+\n+use a::b::c;\n+use a::d::e;\n+use a::f;\n+use a::g::{h, i};\n+use a::j::k::{self, l};\n+use a::j::{self, m};\n+use a::n::o::p;\n+use a::n::q;\n+pub use a::r::s;\n+pub use a::t;\n+use b::c::d;\n+use b::{self};\n+\n+use foo::e;\n+#[cfg(test)]\n+use foo::{a::b, c::d};\n+\n+use bar::{\n+    // comment\n+    a::b,\n+    // more comment\n+    c::d,\n+    e::f,\n+};\n+\n+use b::q::{self /* After b::q::self */};\n+use b::r; // After b::r\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::u::{a, b};\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::{c, d, e};\n+use b::{\n+    f::g,\n+    h::{i, j}, /* After b::h group */\n+};\n+use b::{\n+    /* Before b::l group */ l::{self, m, n::o, p::*},\n+    q,\n+};"}, {"sha": "eace785e6705e9e1c170d429248eeb63b345c976", "filename": "src/tools/rustfmt/tests/target/imports_granularity_item.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_item.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,13 +0,0 @@\n-// rustfmt-imports_granularity: Item\n-\n-use a::b;\n-use a::c;\n-use a::d;\n-use a::f::g;\n-use a::h::i;\n-use a::h::j;\n-use a::l::m;\n-use a::l::n::o;\n-use a::l::p::*;\n-use a::l::{self};\n-use a::q::{self};"}, {"sha": "e4e1a299e58669f809ae8f9826776c9a6466f43b", "filename": "src/tools/rustfmt/tests/target/imports_granularity_module.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_module.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,22 +0,0 @@\n-// rustfmt-imports_granularity: Module\n-\n-use a::b::c;\n-use a::d::e;\n-use a::f;\n-use a::g::{h, i};\n-use a::j::k::{self, l};\n-use a::j::{self, m};\n-use a::n::o::p;\n-use a::n::q;\n-pub use a::r::s;\n-pub use a::t;\n-use b::c::d;\n-use b::{self};\n-\n-use foo::e;\n-#[cfg(test)]\n-use foo::{a::b, c::d};\n-\n-use bar::a::b;\n-use bar::c::d;\n-use bar::e::f;"}, {"sha": "da4c6678db149bf6c2f3c5ba82c3161aaec43764", "filename": "src/tools/rustfmt/tests/target/imports_granularity_one.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fimports_granularity_one.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -68,12 +68,42 @@ use {\n     c::{self, ca},\n };\n \n-use {\n-    a::{\n-        aa::{aaa, aab},\n-        ab,\n-        ac::aca,\n-        ad::ada,\n-    },\n-    b as x,\n+use a::{\n+    // some comment\n+    aa::{aaa, aab},\n+    ab,\n+    // another comment\n+    ac::aca,\n+};\n+use {a::ad::ada, b as x};\n+\n+use b::q::{self /* After b::q::self */};\n+use b::r; // After b::r\n+use b::s::{\n+    a,\n+    b, // After b::s::b\n+};\n+use b::t::{/* Before b::t::self */ self};\n+use b::t::{\n+    // Before b::t::a\n+    a,\n+    b,\n+};\n+use b::v::{\n+    // Before b::v::a\n+    a,\n+    // Before b::v::b\n+    b,\n+};\n+use b::{\n+    c, d, e,\n+    u::{a, b},\n+};\n+use b::{\n+    f::g,\n+    h::{i, j}, /* After b::h group */\n+};\n+use b::{\n+    /* Before b::l group */ l::{self, m, n::o, p::*},\n+    q,\n };"}, {"sha": "8ac3888bdbee0b1fd998e18959b118940c6bb2f3", "filename": "src/tools/rustfmt/tests/target/issue-5030.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5030.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5030.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5030.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,21 @@\n+// rustfmt-imports_granularity: Item\n+// rustfmt-group_imports: One\n+\n+// Confirm that attributes are duplicated to all items in the use statement\n+#[cfg(feature = \"foo\")]\n+use std::collections::HashMap;\n+#[cfg(feature = \"foo\")]\n+use std::collections::HashSet;\n+\n+// Separate the imports below from the ones above\n+const A: usize = 0;\n+\n+// Copying attrs works with import grouping as well\n+#[cfg(feature = \"spam\")]\n+use qux::bar;\n+#[cfg(feature = \"spam\")]\n+use qux::baz;\n+#[cfg(feature = \"foo\")]\n+use std::collections::HashMap;\n+#[cfg(feature = \"foo\")]\n+use std::collections::HashSet;"}, {"sha": "171f6fa51b78ee068a37ee18d84861b8e1ac8bde", "filename": "src/tools/rustfmt/tests/target/issue-5260.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5260.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,13 @@\n+// rustfmt-wrap_comments: true\n+\n+/// [MyType](VeryLongPathToMyType::NoLineBreak::Here::Okay::ThatWouldBeNice::Thanks)\n+fn documented_with_longtype() {\n+    // # We're using a long type link, rustfmt should not break line\n+    // on the type when `wrap_comments = true`\n+}\n+\n+/// VeryLongPathToMyType::JustMyType::But::VeryVery::Long::NoLineBreak::Here::Okay::ThatWouldBeNice::Thanks\n+fn documented_with_verylongtype() {\n+    // # We're using a long type link, rustfmt should not break line\n+    // on the type when `wrap_comments = true`\n+}"}, {"sha": "8067310850053c4520f40a3360eea4f8b1863bbe", "filename": "src/tools/rustfmt/tests/target/issue_3937.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_3937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_3937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_3937.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,13 @@\n+// rustfmt-format_code_in_doc_comments:true\n+\n+struct Foo {\n+    // a: i32,\n+    //\n+    // b: i32,\n+}\n+\n+struct Foo {\n+    a: i32,\n+    //\n+    // b: i32,\n+}"}, {"sha": "82cfe4f535981cde155774e16cac9bb0588094cc", "filename": "src/tools/rustfmt/tests/target/issue_4573.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_4573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_4573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_4573.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,245 @@\n+// rustmft-version:Two\n+// rustmft-use_small_heuristics:Max\n+// rustmft-merge_derives:false\n+// These are the same rustfmt configuration options that are used\n+// in the comiler as of ce39461ca75a and 8eb7c58dbb7b\n+// These are commits in https://github.com/rust-lang/rust\n+\n+#![no_std] // inner attribute comment\n+// inner attribute comment\n+#![no_implicit_prelude]\n+// post inner attribute comment\n+\n+#[cfg(not(miri))] // inline comment\n+#[no_link]\n+extern crate foo;\n+\n+// before attributes\n+#[no_link]\n+// between attributes\n+#[cfg(not(miri))] // inline comment\n+extern crate foo as bar;\n+\n+#[cfg(not(miri))] // inline comment\n+// between attribute and use\n+use foo;\n+\n+#[cfg(not(miri))] // inline comment\n+use foo;\n+\n+/* pre attributre */\n+#[cfg(not(miri))]\n+use foo::bar;\n+\n+#[cfg(not(miri))] // inline comment\n+use foo::bar as FooBar;\n+\n+#[cfg(not(miri))] // inline comment\n+#[allow(unused)]\n+#[deprecated(\n+    since = \"5.2\",  // inline inner comment\n+    note = \"FOO was rarely used. Users should instead use BAR\"\n+)]\n+#[allow(unused)]\n+static FOO: i32 = 42;\n+\n+#[used]\n+#[export_name = \"FOO\"]\n+#[cfg(not(miri))] // inline comment\n+#[deprecated(\n+    since = \"5.2\",\n+    note = \"FOO was rarely used. Users should instead use BAR\"\n+)]\n+static FOO: i32 = 42;\n+\n+#[cfg(not(miri))] // inline comment\n+#[export_name = \"FOO\"]\n+static BAR: &'static str = \"bar\";\n+\n+#[cfg(not(miri))] // inline comment\n+const BAR: i32 = 42;\n+\n+#[cfg(not(miri))] // inline comment\n+#[no_mangle]\n+#[link_section = \".example_section\"]\n+fn foo(bar: usize) {\n+    #[cfg(not(miri))] // inline comment\n+    println!(\"hello world!\");\n+}\n+\n+#[cfg(not(miri))] // inline comment\n+mod foo {}\n+\n+#[cfg(not(miri))] // inline comment\n+extern \"C\" {\n+    fn my_c_function(x: i32) -> bool;\n+}\n+\n+#[cfg(not(miri))] // inline comment\n+#[link(name = \"CoreFoundation\", kind = \"framework\")]\n+extern \"C\" {\n+\n+    #[link_name = \"actual_symbol_name\"] // inline comment\n+    // between attribute and function\n+    fn my_c_function(x: i32) -> bool;\n+}\n+\n+#[cfg(not(miri))] // inline comment\n+pub extern \"C\" fn callable_from_c(x: i32) -> bool {\n+    x % 3 == 0\n+}\n+\n+#[cfg(not(miri))] // inline comment\n+/* between attribute block comment */\n+#[no_mangle]\n+/* between attribute and type */\n+type Foo = Bar<u8>;\n+\n+#[no_mangle]\n+#[cfg(not(miri))] // inline comment\n+#[non_exhaustive] // inline comment\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\n+#[no_mangle]\n+#[cfg(not(miri))] /* inline comment */\n+struct Foo<A> {\n+    x: A,\n+}\n+\n+#[cfg(not(miri))] // inline comment\n+union Foo<A, B> {\n+    x: A,\n+    y: B,\n+}\n+\n+#[cfg(not(miri))] // inline comment\n+trait Foo {}\n+\n+#[cfg(not(miri))] // inline comment\n+trait Foo = Bar + Quux;\n+\n+#[cfg(not(miri))] // inline comment\n+impl Foo {}\n+\n+#[cfg(not(miri))] // inline comment\n+macro_rules! bar {\n+    (3) => {};\n+}\n+\n+mod nested {\n+    #[cfg(not(miri))] // inline comment\n+    // between attribute and use\n+    use foo;\n+\n+    #[cfg(not(miri))] // inline comment\n+    use foo;\n+\n+    #[cfg(not(miri))] // inline comment\n+    use foo::bar;\n+\n+    #[cfg(not(miri))] // inline comment\n+    use foo::bar as FooBar;\n+\n+    #[cfg(not(miri))] // inline comment\n+    static FOO: i32 = 42;\n+\n+    #[cfg(not(miri))] // inline comment\n+    static FOO: i32 = 42;\n+\n+    #[cfg(not(miri))] // inline comment\n+    static FOO: &'static str = \"bar\";\n+\n+    #[cfg(not(miri))] // inline comment\n+    const FOO: i32 = 42;\n+\n+    #[cfg(not(miri))] // inline comment\n+    fn foo(bar: usize) {\n+        #[cfg(not(miri))] // inline comment\n+        println!(\"hello world!\");\n+    }\n+\n+    #[cfg(not(miri))] // inline comment\n+    mod foo {}\n+\n+    #[cfg(not(miri))] // inline comment\n+    mod foo {}\n+\n+    #[cfg(not(miri))] // inline comment\n+    extern \"C\" {\n+        fn my_c_function(x: i32) -> bool;\n+    }\n+\n+    #[cfg(not(miri))] // inline comment\n+    #[link(name = \"CoreFoundation\", kind = \"framework\")]\n+    extern \"C\" {\n+\n+        #[link_name = \"actual_symbol_name\"] // inline comment\n+        // between attribute and function\n+        fn my_c_function(x: i32) -> bool;\n+    }\n+\n+    #[cfg(not(miri))] // inline comment\n+    pub extern \"C\" fn callable_from_c(x: i32) -> bool {\n+        x % 3 == 0\n+    }\n+\n+    #[cfg(not(miri))] // inline comment\n+    type Foo = Bar<u8>;\n+\n+    #[cfg(not(miri))] // inline comment\n+    #[non_exhaustive] // inline comment\n+    enum Foo {\n+        // comment\n+        #[attribute_1]\n+        #[attribute_2] // comment\n+        // comment!\n+        Bar,\n+        /* comment */\n+        #[attribute_1]\n+        #[attribute_2] /* comment */\n+        #[attribute_3]\n+        #[attribute_4]\n+        /* comment! */\n+        Baz,\n+    }\n+\n+    #[cfg(not(miri))] // inline comment\n+    struct Foo<A> {\n+        x: A,\n+    }\n+\n+    #[cfg(not(miri))] // inline comment\n+    union Foo<A, B> {\n+        #[attribute_1]\n+        #[attribute_2] /* comment */\n+        #[attribute_3]\n+        #[attribute_4] // comment\n+        x: A,\n+        y: B,\n+    }\n+\n+    #[cfg(not(miri))] // inline comment\n+    #[allow(missing_docs)]\n+    trait Foo {\n+        #[must_use] /* comment\n+                     * that wrappes to\n+                     * the next line */\n+        fn bar() {}\n+    }\n+\n+    #[allow(missing_docs)]\n+    #[cfg(not(miri))] // inline comment\n+    trait Foo = Bar + Quux;\n+\n+    #[allow(missing_docs)]\n+    #[cfg(not(miri))] // inline comment\n+    impl Foo {}\n+\n+    #[cfg(not(miri))] // inline comment\n+    macro_rules! bar {\n+        (3) => {};\n+    }\n+}"}, {"sha": "950f103ed3922532460694fd8c0ee838121b2b03", "filename": "src/tools/rustfmt/tests/target/license-templates/empty_license_path.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flicense-templates%2Fempty_license_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flicense-templates%2Fempty_license_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flicense-templates%2Fempty_license_path.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,5 +0,0 @@\n-// rustfmt-config: issue-3802.toml\n-\n-fn main() {\n-    println!(\"Hello world!\");\n-}"}, {"sha": "7169c7b2576155e3b016f76148c2abdfd61e11e0", "filename": "src/tools/rustfmt/tests/target/license-templates/license.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flicense-templates%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9603022fe20814d3b7980a3c88299b8e1f747/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flicense-templates%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flicense-templates%2Flicense.rs?ref=1fb9603022fe20814d3b7980a3c88299b8e1f747", "patch": "@@ -1,6 +0,0 @@\n-// rustfmt-license_template_path: tests/license-template/lt.txt\n-// Copyright 2019 The rustfmt developers.\n-\n-fn main() {\n-    println!(\"Hello world!\");\n-}"}, {"sha": "30567f2644b749bb019da54f7b36f938c8fcd78e", "filename": "src/tools/rustfmt/tests/target/performance/issue-4476.rs", "status": "added", "additions": 705, "deletions": 0, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-4476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-4476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-4476.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,705 @@\n+use super::SemverParser;\n+\n+#[allow(dead_code, non_camel_case_types)]\n+#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub enum Rule {\n+    EOI,\n+    range_set,\n+    logical_or,\n+    range,\n+    empty,\n+    hyphen,\n+    simple,\n+    primitive,\n+    primitive_op,\n+    partial,\n+    xr,\n+    xr_op,\n+    nr,\n+    tilde,\n+    caret,\n+    qualifier,\n+    parts,\n+    part,\n+    space,\n+}\n+#[allow(clippy::all)]\n+impl ::pest::Parser<Rule> for SemverParser {\n+    fn parse<'i>(\n+        rule: Rule,\n+        input: &'i str,\n+    ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>> {\n+        mod rules {\n+            pub mod hidden {\n+                use super::super::Rule;\n+                #[inline]\n+                #[allow(dead_code, non_snake_case, unused_variables)]\n+                pub fn skip(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    Ok(state)\n+                }\n+            }\n+            pub mod visible {\n+                use super::super::Rule;\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn range_set(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::range_set, |state| {\n+                        state.sequence(|state| {\n+                            self::SOI(state)\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                                state.repeat(|state| {\n+                                                    state.sequence(|state| {\n+                                                        super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                    })\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::range(state))\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            state\n+                                                .sequence(|state| {\n+                                                    self::logical_or(state)\n+                                                        .and_then(|state| {\n+                                                            super::hidden::skip(state)\n+                                                        })\n+                                                        .and_then(|state| self::range(state))\n+                                                })\n+                                                .and_then(|state| {\n+                                                    state.repeat(|state| {\n+                                                        state.sequence(|state| {\n+                                                            super::hidden::skip(state).and_then(\n+                                                                |state| {\n+                                                                    state.sequence(|state| {\n+                                                                        self::logical_or(state)\n+                                                                            .and_then(|state| {\n+                                                                                super::hidden::skip(\n+                                                                                    state,\n+                                                                                )\n+                                                                            })\n+                                                                            .and_then(|state| {\n+                                                                                self::range(state)\n+                                                                            })\n+                                                                    })\n+                                                                },\n+                                                            )\n+                                                        })\n+                                                    })\n+                                                })\n+                                        })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                                state.repeat(|state| {\n+                                                    state.sequence(|state| {\n+                                                        super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                    })\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::EOI(state))\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn logical_or(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::logical_or, |state| {\n+                        state.sequence(|state| {\n+                            state\n+                                .sequence(|state| {\n+                                    state.optional(|state| {\n+                                        self::space(state).and_then(|state| {\n+                                            state.repeat(|state| {\n+                                                state.sequence(|state| {\n+                                                    super::hidden::skip(state)\n+                                                        .and_then(|state| self::space(state))\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| state.match_string(\"||\"))\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                                state.repeat(|state| {\n+                                                    state.sequence(|state| {\n+                                                        super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                    })\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                                })\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn range(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::range, |state| {\n+                        self::hyphen(state)\n+                            .or_else(|state| {\n+                                state.sequence(|state| {\n+                                    self::simple(state)\n+                                        .and_then(|state| super::hidden::skip(state))\n+                                        .and_then(|state| {\n+                                            state.sequence(|state| {\n+                                                state.optional(|state| {\n+                                                    state\n+                                                        .sequence(|state| {\n+                                                            state\n+                                                                .optional(|state| {\n+                                                                    state.match_string(\",\")\n+                                                                })\n+                                                                .and_then(|state| {\n+                                                                    super::hidden::skip(state)\n+                                                                })\n+                                                                .and_then(|state| {\n+                                                                    state.sequence(|state| {\n+                                                                        self::space(state)\n+                                      .and_then(|state| super::hidden::skip(state))\n+                                      .and_then(|state| {\n+                                        state.sequence(|state| {\n+                                          state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                              state.repeat(|state| {\n+                                                state.sequence(|state| {\n+                                                  super::hidden::skip(state)\n+                                                    .and_then(|state| self::space(state))\n+                                                })\n+                                              })\n+                                            })\n+                                          })\n+                                        })\n+                                      })\n+                                                                    })\n+                                                                })\n+                                                                .and_then(|state| {\n+                                                                    super::hidden::skip(state)\n+                                                                })\n+                                                                .and_then(|state| {\n+                                                                    self::simple(state)\n+                                                                })\n+                                                        })\n+                                                        .and_then(|state| {\n+                                                            state.repeat(|state| {\n+                                                                state.sequence(|state| {\n+                                                                    super::hidden::skip(state)\n+                                                                        .and_then(|state| {\n+                                                                            state.sequence(\n+                                                                                |state| {\n+                                                                                    state\n+                                        .optional(|state| state.match_string(\",\"))\n+                                        .and_then(|state| super::hidden::skip(state))\n+                                        .and_then(|state| {\n+                                          state.sequence(|state| {\n+                                            self::space(state)\n+                                              .and_then(|state| super::hidden::skip(state))\n+                                              .and_then(|state| {\n+                                                state.sequence(|state| {\n+                                                  state.optional(|state| {\n+                                                    self::space(state).and_then(|state| {\n+                                                      state.repeat(|state| {\n+                                                        state.sequence(|state| {\n+                                                          super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                        })\n+                                                      })\n+                                                    })\n+                                                  })\n+                                                })\n+                                              })\n+                                          })\n+                                        })\n+                                        .and_then(|state| super::hidden::skip(state))\n+                                        .and_then(|state| self::simple(state))\n+                                                                                },\n+                                                                            )\n+                                                                        })\n+                                                                })\n+                                                            })\n+                                                        })\n+                                                })\n+                                            })\n+                                        })\n+                                })\n+                            })\n+                            .or_else(|state| self::empty(state))\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn empty(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::empty, |state| state.match_string(\"\"))\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn hyphen(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::hyphen, |state| {\n+                        state.sequence(|state| {\n+                            self::partial(state)\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        self::space(state)\n+                                            .and_then(|state| super::hidden::skip(state))\n+                                            .and_then(|state| {\n+                                                state.sequence(|state| {\n+                                                    state.optional(|state| {\n+                                                        self::space(state).and_then(|state| {\n+                                                            state.repeat(|state| {\n+                                                                state.sequence(|state| {\n+                                                                    super::hidden::skip(state)\n+                                                                        .and_then(|state| {\n+                                                                            self::space(state)\n+                                                                        })\n+                                                                })\n+                                                            })\n+                                                        })\n+                                                    })\n+                                                })\n+                                            })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| state.match_string(\"-\"))\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        self::space(state)\n+                                            .and_then(|state| super::hidden::skip(state))\n+                                            .and_then(|state| {\n+                                                state.sequence(|state| {\n+                                                    state.optional(|state| {\n+                                                        self::space(state).and_then(|state| {\n+                                                            state.repeat(|state| {\n+                                                                state.sequence(|state| {\n+                                                                    super::hidden::skip(state)\n+                                                                        .and_then(|state| {\n+                                                                            self::space(state)\n+                                                                        })\n+                                                                })\n+                                                            })\n+                                                        })\n+                                                    })\n+                                                })\n+                                            })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::partial(state))\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn simple(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::simple, |state| {\n+                        self::primitive(state)\n+                            .or_else(|state| self::partial(state))\n+                            .or_else(|state| self::tilde(state))\n+                            .or_else(|state| self::caret(state))\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn primitive(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::primitive, |state| {\n+                        state.sequence(|state| {\n+                            self::primitive_op(state)\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                                state.repeat(|state| {\n+                                                    state.sequence(|state| {\n+                                                        super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                    })\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::partial(state))\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn primitive_op(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::primitive_op, |state| {\n+                        state\n+                            .match_string(\"<=\")\n+                            .or_else(|state| state.match_string(\">=\"))\n+                            .or_else(|state| state.match_string(\">\"))\n+                            .or_else(|state| state.match_string(\"<\"))\n+                            .or_else(|state| state.match_string(\"=\"))\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn partial(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::partial, |state| {\n+                        state.sequence(|state| {\n+                            self::xr(state)\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.optional(|state| {\n+                                        state.sequence(|state| {\n+                                            state\n+                                                .match_string(\".\")\n+                                                .and_then(|state| super::hidden::skip(state))\n+                                                .and_then(|state| self::xr(state))\n+                                                .and_then(|state| super::hidden::skip(state))\n+                                                .and_then(|state| {\n+                                                    state.optional(|state| {\n+                                                        state.sequence(|state| {\n+                                                            state\n+                                                                .match_string(\".\")\n+                                                                .and_then(|state| {\n+                                                                    super::hidden::skip(state)\n+                                                                })\n+                                                                .and_then(|state| self::xr(state))\n+                                                                .and_then(|state| {\n+                                                                    super::hidden::skip(state)\n+                                                                })\n+                                                                .and_then(|state| {\n+                                                                    state.optional(|state| {\n+                                                                        self::qualifier(state)\n+                                                                    })\n+                                                                })\n+                                                        })\n+                                                    })\n+                                                })\n+                                        })\n+                                    })\n+                                })\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn xr(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::xr, |state| {\n+                        self::xr_op(state).or_else(|state| self::nr(state))\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn xr_op(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::xr_op, |state| {\n+                        state\n+                            .match_string(\"x\")\n+                            .or_else(|state| state.match_string(\"X\"))\n+                            .or_else(|state| state.match_string(\"*\"))\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn nr(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::nr, |state| {\n+                        state.match_string(\"0\").or_else(|state| {\n+                            state.sequence(|state| {\n+                                state\n+                                    .match_range('1'..'9')\n+                                    .and_then(|state| super::hidden::skip(state))\n+                                    .and_then(|state| {\n+                                        state.sequence(|state| {\n+                                            state.optional(|state| {\n+                                                state.match_range('0'..'9').and_then(|state| {\n+                                                    state.repeat(|state| {\n+                                                        state.sequence(|state| {\n+                                                            super::hidden::skip(state).and_then(\n+                                                                |state| state.match_range('0'..'9'),\n+                                                            )\n+                                                        })\n+                                                    })\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                            })\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn tilde(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::tilde, |state| {\n+                        state.sequence(|state| {\n+                            state\n+                                .match_string(\"~>\")\n+                                .or_else(|state| state.match_string(\"~\"))\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                                state.repeat(|state| {\n+                                                    state.sequence(|state| {\n+                                                        super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                    })\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::partial(state))\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn caret(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::caret, |state| {\n+                        state.sequence(|state| {\n+                            state\n+                                .match_string(\"^\")\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            self::space(state).and_then(|state| {\n+                                                state.repeat(|state| {\n+                                                    state.sequence(|state| {\n+                                                        super::hidden::skip(state)\n+                                                            .and_then(|state| self::space(state))\n+                                                    })\n+                                                })\n+                                            })\n+                                        })\n+                                    })\n+                                })\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::partial(state))\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn qualifier(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::qualifier, |state| {\n+                        state.sequence(|state| {\n+                            state\n+                                .match_string(\"-\")\n+                                .or_else(|state| state.match_string(\"+\"))\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| self::parts(state))\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn parts(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::parts, |state| {\n+                        state.sequence(|state| {\n+                            self::part(state)\n+                                .and_then(|state| super::hidden::skip(state))\n+                                .and_then(|state| {\n+                                    state.sequence(|state| {\n+                                        state.optional(|state| {\n+                                            state\n+                                                .sequence(|state| {\n+                                                    state\n+                                                        .match_string(\".\")\n+                                                        .and_then(|state| {\n+                                                            super::hidden::skip(state)\n+                                                        })\n+                                                        .and_then(|state| self::part(state))\n+                                                })\n+                                                .and_then(|state| {\n+                                                    state.repeat(|state| {\n+                                                        state.sequence(|state| {\n+                                                            super::hidden::skip(state).and_then(\n+                                                                |state| {\n+                                                                    state.sequence(|state| {\n+                                                                        state\n+                                                                            .match_string(\".\")\n+                                                                            .and_then(|state| {\n+                                                                                super::hidden::skip(\n+                                                                                    state,\n+                                                                                )\n+                                                                            })\n+                                                                            .and_then(|state| {\n+                                                                                self::part(state)\n+                                                                            })\n+                                                                    })\n+                                                                },\n+                                                            )\n+                                                        })\n+                                                    })\n+                                                })\n+                                        })\n+                                    })\n+                                })\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn part(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::part, |state| {\n+                        self::nr(state).or_else(|state| {\n+                            state.sequence(|state| {\n+                                state\n+                                    .match_string(\"-\")\n+                                    .or_else(|state| state.match_range('0'..'9'))\n+                                    .or_else(|state| state.match_range('A'..'Z'))\n+                                    .or_else(|state| state.match_range('a'..'z'))\n+                                    .and_then(|state| super::hidden::skip(state))\n+                                    .and_then(|state| {\n+                                        state.sequence(|state| {\n+                                            state.optional(|state| {\n+                                                state\n+                                                    .match_string(\"-\")\n+                                                    .or_else(|state| state.match_range('0'..'9'))\n+                                                    .or_else(|state| state.match_range('A'..'Z'))\n+                                                    .or_else(|state| state.match_range('a'..'z'))\n+                                                    .and_then(|state| {\n+                                                        state.repeat(|state| {\n+                                                            state.sequence(|state| {\n+                                                                super::hidden::skip(state).and_then(\n+                                                                    |state| {\n+                                                                        state\n+                                                                            .match_string(\"-\")\n+                                                                            .or_else(|state| {\n+                                                                                state.match_range(\n+                                                                                    '0'..'9',\n+                                                                                )\n+                                                                            })\n+                                                                            .or_else(|state| {\n+                                                                                state.match_range(\n+                                                                                    'A'..'Z',\n+                                                                                )\n+                                                                            })\n+                                                                            .or_else(|state| {\n+                                                                                state.match_range(\n+                                                                                    'a'..'z',\n+                                                                                )\n+                                                                            })\n+                                                                    },\n+                                                                )\n+                                                            })\n+                                                        })\n+                                                    })\n+                                            })\n+                                        })\n+                                    })\n+                            })\n+                        })\n+                    })\n+                }\n+                #[inline]\n+                #[allow(non_snake_case, unused_variables)]\n+                pub fn space(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state\n+                        .match_string(\" \")\n+                        .or_else(|state| state.match_string(\"\\t\"))\n+                }\n+                #[inline]\n+                #[allow(dead_code, non_snake_case, unused_variables)]\n+                pub fn EOI(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.rule(Rule::EOI, |state| state.end_of_input())\n+                }\n+                #[inline]\n+                #[allow(dead_code, non_snake_case, unused_variables)]\n+                pub fn SOI(\n+                    state: Box<::pest::ParserState<Rule>>,\n+                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n+                    state.start_of_input()\n+                }\n+            }\n+            pub use self::visible::*;\n+        }\n+        ::pest::state(input, |state| match rule {\n+            Rule::range_set => rules::range_set(state),\n+            Rule::logical_or => rules::logical_or(state),\n+            Rule::range => rules::range(state),\n+            Rule::empty => rules::empty(state),\n+            Rule::hyphen => rules::hyphen(state),\n+            Rule::simple => rules::simple(state),\n+            Rule::primitive => rules::primitive(state),\n+            Rule::primitive_op => rules::primitive_op(state),\n+            Rule::partial => rules::partial(state),\n+            Rule::xr => rules::xr(state),\n+            Rule::xr_op => rules::xr_op(state),\n+            Rule::nr => rules::nr(state),\n+            Rule::tilde => rules::tilde(state),\n+            Rule::caret => rules::caret(state),\n+            Rule::qualifier => rules::qualifier(state),\n+            Rule::parts => rules::parts(state),\n+            Rule::part => rules::part(state),\n+            Rule::space => rules::space(state),\n+            Rule::EOI => rules::EOI(state),\n+        })\n+    }\n+}"}, {"sha": "336dae1b64ab804be11155e53d1da099877e277b", "filename": "src/tools/rustfmt/tests/target/performance/issue-4867.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-4867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-4867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-4867.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,13 @@\n+mod modA {\n+    mod modB {\n+        mod modC {\n+            mod modD {\n+                mod modE {\n+                    fn func() {\n+                        state . rule (Rule :: myrule , | state | { state . sequence (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) }) }) }) }) }) }) }) }) });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "ba9ebfc6243f21f225639c0b0b7c32e9a3566a4a", "filename": "src/tools/rustfmt/tests/target/performance/issue-5128.rs", "status": "added", "additions": 4898, "deletions": 0, "changes": 4898, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-5128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-5128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fperformance%2Fissue-5128.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad"}, {"sha": "ebb01a668f4c93d668fd9173e234953aef967f9b", "filename": "src/tools/rustfmt/tests/target/struct_field_doc_comment.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fstruct_field_doc_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fstruct_field_doc_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fstruct_field_doc_comment.rs?ref=ecddc26b0ec4fcf23e066f2f892c40c1beb2f5ad", "patch": "@@ -0,0 +1,69 @@\n+// #5215\n+struct MyTuple(\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */\n+    u32,\n+    /// Doc Comments\n+    // TODO note\n+    u64,\n+);\n+\n+struct MyTuple(\n+    #[cfg(unix)] // some comment\n+    u64,\n+    #[cfg(not(unix))] /*block comment */ u32,\n+);\n+\n+struct MyTuple(\n+    #[cfg(unix)]\n+    // some comment\n+    u64,\n+    #[cfg(not(unix))]\n+    /*block comment */\n+    u32,\n+);\n+\n+struct MyTuple(\n+    #[cfg(unix)] // some comment\n+    pub  u64,\n+    #[cfg(not(unix))] /*block comment */ pub(crate)  u32,\n+);\n+\n+struct MyTuple(\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */\n+    pub  u32,\n+    /// Doc Comments\n+    // TODO note\n+    pub(crate)  u64,\n+);\n+\n+struct MyStruct {\n+    #[cfg(unix)] // some comment\n+    a: u64,\n+    #[cfg(not(unix))] /*block comment */ b: u32,\n+}\n+\n+struct MyStruct {\n+    #[cfg(unix)] // some comment\n+    pub a: u64,\n+    #[cfg(not(unix))] /*block comment */ pub(crate) b: u32,\n+}\n+\n+struct MyStruct {\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */\n+    a: u32,\n+    /// Doc Comments\n+    // TODO note\n+    b: u64,\n+}\n+\n+struct MyStruct {\n+    /// Doc Comments\n+    /* TODO note to add more to Doc Comments */\n+    pub a: u32,\n+    /// Doc Comments\n+    // TODO note\n+    pub(crate) b: u64,\n+}"}]}