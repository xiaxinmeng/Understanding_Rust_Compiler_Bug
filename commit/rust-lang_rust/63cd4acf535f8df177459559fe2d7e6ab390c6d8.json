{"sha": "63cd4acf535f8df177459559fe2d7e6ab390c6d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzY2Q0YWNmNTM1ZjhkZjE3NzQ1OTU1OWZlMmQ3ZTZhYjM5MGM2ZDg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-31T03:07:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:47Z"}, "message": "std: Clarify what timers do with zero and negative durations\n\nAdd tests. Also fix a bunch of broken time tests.", "tree": {"sha": "4f10ee436e87176f9141071d2a7a13d5ee499ba8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f10ee436e87176f9141071d2a7a13d5ee499ba8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63cd4acf535f8df177459559fe2d7e6ab390c6d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63cd4acf535f8df177459559fe2d7e6ab390c6d8", "html_url": "https://github.com/rust-lang/rust/commit/63cd4acf535f8df177459559fe2d7e6ab390c6d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63cd4acf535f8df177459559fe2d7e6ab390c6d8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "734834c7d6e4862c8348a8c9660bb338773047ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/734834c7d6e4862c8348a8c9660bb338773047ca", "html_url": "https://github.com/rust-lang/rust/commit/734834c7d6e4862c8348a8c9660bb338773047ca"}], "stats": {"total": 142, "additions": 111, "deletions": 31}, "files": [{"sha": "3dd4343c5f4fcd4070f05f720ec91f45ac0fc468", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=63cd4acf535f8df177459559fe2d7e6ab390c6d8", "patch": "@@ -976,7 +976,7 @@ mod tests {\n                 assert!(!p.wait().unwrap().success());\n                 return\n             }\n-            timer::sleep_ms(100);\n+            timer::sleep(Duration::milliseconds(100));\n         }\n         fail!(\"never saw the child go away\");\n     })"}, {"sha": "10739c70143cd3b610fafc39f32cb26af2358643", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=63cd4acf535f8df177459559fe2d7e6ab390c6d8", "patch": "@@ -167,6 +167,7 @@ mod test_unix {\n     use comm::Empty;\n     use io::timer;\n     use super::{Listener, Interrupt};\n+    use time::Duration;\n \n     fn sigint() {\n         unsafe {\n@@ -179,7 +180,7 @@ mod test_unix {\n         let mut signal = Listener::new();\n         signal.register(Interrupt).unwrap();\n         sigint();\n-        timer::sleep_ms(10);\n+        timer::sleep(Duration::milliseconds(10));\n         match signal.rx.recv() {\n             Interrupt => (),\n             s => fail!(\"Expected Interrupt, got {:?}\", s),\n@@ -193,7 +194,7 @@ mod test_unix {\n         s1.register(Interrupt).unwrap();\n         s2.register(Interrupt).unwrap();\n         sigint();\n-        timer::sleep_ms(10);\n+        timer::sleep(Duration::milliseconds(10));\n         match s1.rx.recv() {\n             Interrupt => (),\n             s => fail!(\"Expected Interrupt, got {:?}\", s),\n@@ -212,7 +213,7 @@ mod test_unix {\n         s2.register(Interrupt).unwrap();\n         s2.unregister(Interrupt);\n         sigint();\n-        timer::sleep_ms(10);\n+        timer::sleep(Duration::milliseconds(10));\n         assert_eq!(s2.rx.try_recv(), Err(Empty));\n     }\n }"}, {"sha": "079a9aef648aa77e7480eaf57bbfbe1d80c7959d", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=63cd4acf535f8df177459559fe2d7e6ab390c6d8", "patch": "@@ -39,6 +39,7 @@ macro_rules! iotest (\n             use io::process::*;\n             use rt::running_on_valgrind;\n             use str;\n+            use time::Duration;\n \n             fn f() $b\n "}, {"sha": "0d3f932f4292de03c07b82a0f2882a8ceb515ee4", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 77, "deletions": 12, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=63cd4acf535f8df177459559fe2d7e6ab390c6d8", "patch": "@@ -17,6 +17,8 @@ and create receivers which will receive notifications after a period of time.\n \n */\n \n+// FIXME: These functions take Durations but only pass ms to the backend impls.\n+\n use comm::{Receiver, Sender, channel};\n use time::Duration;\n use io::{IoResult, IoError};\n@@ -71,13 +73,15 @@ pub struct Timer {\n struct TimerCallback { tx: Sender<()> }\n \n fn in_ms(d: Duration) -> u64 {\n-    // FIXME: Do we really want to fail on negative duration?\n     let ms = d.num_milliseconds();\n-    if ms < 0 { fail!(\"negative duration\") }\n+    if ms < 0 { return 0 };\n     return ms as u64;\n }\n \n /// Sleep the current task for the specified duration.\n+///\n+/// When provided a zero or negative `duration`, the function will\n+/// return immediately.\n pub fn sleep(duration: Duration) {\n     let timer = Timer::new();\n     let mut timer = timer.ok().expect(\"timer::sleep: could not create a Timer\");\n@@ -99,8 +103,14 @@ impl Timer {\n     ///\n     /// Note that this function will cause any other receivers for this timer to\n     /// be invalidated (the other end will be closed).\n+    ///\n+    /// When provided a zero or negative `duration`, the function will\n+    /// return immediately.\n     pub fn sleep(&mut self, duration: Duration) {\n-        self.obj.sleep(in_ms(duration));\n+        // Short-circuit the timer backend for 0 duration\n+        let ms = in_ms(duration);\n+        if ms == 0 { return }\n+        self.obj.sleep(ms);\n     }\n \n     /// Creates a oneshot receiver which will have a notification sent when\n@@ -137,9 +147,17 @@ impl Timer {\n     /// // The timer object was destroyed, so this will always fail:\n     /// // five_ms.recv()\n     /// ```\n+    ///\n+    /// When provided a zero or negative `duration`, the message will\n+    /// be sent immediately.\n     pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> {\n         let (tx, rx) = channel();\n-        self.obj.oneshot(in_ms(duration), box TimerCallback { tx: tx });\n+        // Short-circuit the timer backend for 0 duration\n+        if in_ms(duration) != 0 {\n+            self.obj.oneshot(in_ms(duration), box TimerCallback { tx: tx });\n+        } else {\n+            tx.send(());\n+        }\n         return rx\n     }\n \n@@ -185,9 +203,17 @@ impl Timer {\n     /// // The timer object was destroyed, so this will always fail:\n     /// // five_ms.recv()\n     /// ```\n+    ///\n+    /// When provided a zero or negative `duration`, the messages will\n+    /// be sent without delay.\n     pub fn periodic(&mut self, duration: Duration) -> Receiver<()> {\n+        let ms = in_ms(duration);\n+        // FIXME: The backend implementations don't ever send a message\n+        // if given a 0 ms duration. Temporarily using 1ms. It's\n+        // not clear what use a 0ms period is anyway...\n+        let ms = if ms == 0 { 1 } else { ms };\n         let (tx, rx) = channel();\n-        self.obj.period(in_ms(duration), box TimerCallback { tx: tx });\n+        self.obj.period(ms, box TimerCallback { tx: tx });\n         return rx\n     }\n }\n@@ -200,8 +226,6 @@ impl Callback for TimerCallback {\n \n #[cfg(test)]\n mod test {\n-    use time::Duration;\n-\n     iotest!(fn test_io_timer_sleep_simple() {\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(1));\n@@ -214,20 +238,20 @@ mod test {\n \n     iotest!(fn test_io_timer_sleep_oneshot_forget() {\n         let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::milliseconds(100000000000));\n+        timer.oneshot(Duration::milliseconds(100000000));\n     })\n \n     iotest!(fn oneshot_twice() {\n         let mut timer = Timer::new().unwrap();\n         let rx1 = timer.oneshot(Duration::milliseconds(10000));\n-        let rx = timer.oneshot(1);\n+        let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert_eq!(rx1.recv_opt(), Err(()));\n     })\n \n     iotest!(fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(Duration::milliseconds(100000000000));\n+        let rx = timer.oneshot(Duration::milliseconds(100000000));\n         timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n \n         assert_eq!(rx.recv_opt(), Err(()));\n@@ -243,7 +267,7 @@ mod test {\n \n     iotest!(fn test_io_timer_sleep_periodic_forget() {\n         let mut timer = Timer::new().unwrap();\n-        timer.periodic(Duration::milliseconds(100000000000));\n+        timer.periodic(Duration::milliseconds(100000000));\n     })\n \n     iotest!(fn test_io_timer_sleep_standalone() {\n@@ -277,7 +301,7 @@ mod test {\n         let rx = timer.periodic(Duration::milliseconds(1));\n         rx.recv();\n         rx.recv();\n-        let rx2 = timer.periodic(Durtion::milliseconds(1));\n+        let rx2 = timer.periodic(Duration::milliseconds(1));\n         rx2.recv();\n         rx2.recv();\n     })\n@@ -375,4 +399,45 @@ mod test {\n         // callback do something terrible.\n         timer2.sleep(Duration::milliseconds(2));\n     })\n+\n+    iotest!(fn sleep_zero() {\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(Duration::milliseconds(0));\n+    })\n+\n+    iotest!(fn sleep_negative() {\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(Duration::milliseconds(-1000000));\n+    })\n+\n+    iotest!(fn oneshot_zero() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.oneshot(Duration::milliseconds(0));\n+        rx.recv();\n+    })\n+\n+    iotest!(fn oneshot_negative() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.oneshot(Duration::milliseconds(-1000000));\n+        rx.recv();\n+    })\n+\n+    iotest!(fn periodic_zero() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.periodic(Duration::milliseconds(0));\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+    })\n+\n+    iotest!(fn periodic_negative() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.periodic(Duration::milliseconds(-1000000));\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+    })\n+\n }"}, {"sha": "9cace9c80ef5ad1a5dd60f1a7dcd923c32bb38c0", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=63cd4acf535f8df177459559fe2d7e6ab390c6d8", "patch": "@@ -664,10 +664,11 @@ mod test {\n #[test]\n fn task_abort_no_kill_runtime() {\n     use std::io::timer;\n+    use time::Duration;\n     use mem;\n \n     let tb = TaskBuilder::new();\n     let rx = tb.try_future(proc() {});\n     mem::drop(rx);\n-    timer::sleep_ms(1000);\n+    timer::sleep(Duration::milliseconds(1000));\n }"}, {"sha": "5a374c37cd87baf9516682ef5b63eaeacf3c5728", "filename": "src/libstd/time.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63cd4acf535f8df177459559fe2d7e6ab390c6d8/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=63cd4acf535f8df177459559fe2d7e6ab390c6d8", "patch": "@@ -497,12 +497,16 @@ fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n #[cfg(test)]\n mod tests {\n     use super::{Duration, MIN_DAYS, MAX_DAYS, MIN_DURATION, MAX_DURATION};\n-    use std::{i32, i64};\n+    use {i32, i64};\n+    use num::{Zero, CheckedAdd, CheckedSub};\n+    use option::{Some, None};\n+    use to_string::ToString;\n \n     #[test]\n     fn test_duration() {\n-        assert_eq!(Duration::zero(), Duration::zero());\n-        assert!(Duration::zero() != Duration::seconds(1));\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d, Zero::zero());\n+        assert!(Duration::seconds(1) != Zero::zero());\n         assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n         assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n                    Duration::days(1) + Duration::seconds(3));\n@@ -517,7 +521,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_days() {\n-        assert_eq!(Duration::zero().num_days(), 0);\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_days(), 0);\n         assert_eq!(Duration::days(1).num_days(), 1);\n         assert_eq!(Duration::days(-1).num_days(), -1);\n         assert_eq!(Duration::seconds(86399).num_days(), 0);\n@@ -534,7 +539,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_seconds() {\n-        assert_eq!(Duration::zero().num_seconds(), 0);\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_seconds(), 0);\n         assert_eq!(Duration::seconds(1).num_seconds(), 1);\n         assert_eq!(Duration::seconds(-1).num_seconds(), -1);\n         assert_eq!(Duration::milliseconds(999).num_seconds(), 0);\n@@ -551,7 +557,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_milliseconds() {\n-        assert_eq!(Duration::zero().num_milliseconds(), 0);\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_milliseconds(), 0);\n         assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n         assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n         assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n@@ -568,7 +575,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_microseconds() {\n-        assert_eq!(Duration::zero().num_microseconds(), Some(0));\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_microseconds(), Some(0));\n         assert_eq!(Duration::microseconds(1).num_microseconds(), Some(1));\n         assert_eq!(Duration::microseconds(-1).num_microseconds(), Some(-1));\n         assert_eq!(Duration::nanoseconds(999).num_microseconds(), Some(0));\n@@ -594,7 +602,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_nanoseconds() {\n-        assert_eq!(Duration::zero().num_nanoseconds(), Some(0));\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_nanoseconds(), Some(0));\n         assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n         assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n         assert_eq!(Duration::new(1, 2, 3_004_005).num_nanoseconds(), Some(86402_003_004_005));\n@@ -627,9 +636,10 @@ mod tests {\n \n     #[test]\n     fn test_duration_mul() {\n-        assert_eq!(Duration::zero() * i32::MAX, Duration::zero());\n-        assert_eq!(Duration::zero() * i32::MIN, Duration::zero());\n-        assert_eq!(Duration::nanoseconds(1) * 0, Duration::zero());\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d * i32::MAX, d);\n+        assert_eq!(d * i32::MIN, d);\n+        assert_eq!(Duration::nanoseconds(1) * 0, Zero::zero());\n         assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n         assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n         assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n@@ -642,8 +652,9 @@ mod tests {\n \n     #[test]\n     fn test_duration_div() {\n-        assert_eq!(Duration::zero() / i32::MAX, Duration::zero());\n-        assert_eq!(Duration::zero() / i32::MIN, Duration::zero());\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d / i32::MAX, d);\n+        assert_eq!(d / i32::MIN, d);\n         assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n         assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n         assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n@@ -652,7 +663,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_fmt() {\n-        assert_eq!(Duration::zero().to_string(), \"PT0S\".to_string());\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.to_string(), \"PT0S\".to_string());\n         assert_eq!(Duration::days(42).to_string(), \"P42D\".to_string());\n         assert_eq!(Duration::days(-42).to_string(), \"P-42D\".to_string());\n         assert_eq!(Duration::seconds(42).to_string(), \"PT42S\".to_string());"}]}