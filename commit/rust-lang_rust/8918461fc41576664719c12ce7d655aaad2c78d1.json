{"sha": "8918461fc41576664719c12ce7d655aaad2c78d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MTg0NjFmYzQxNTc2NjY0NzE5YzEyY2U3ZDY1NWFhYWQyYzc4ZDE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-18T00:46:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-26T22:18:36Z"}, "message": "rt: Release big stacks immediately after use to avoid holding on to them through yields\n\nThis avoids the following pathological scenario that makes threadring OOM:\n\n1) task calls C using fast_ffi, borrowing a big stack from the scheduler.\n2) task returns from C and places the big stack on the task-local stack segment list\n3) task calls further Rust functions that require growing the stack, and for this reuses the big stack\n4) task yields, failing to return the big stack to the scheduler.\n5) repeat 500+ times and OOM\n\nConflicts:\n\tsrc/rt/rust_task.cpp", "tree": {"sha": "6c922dababfdb6562b503421dfc4639962b68faf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c922dababfdb6562b503421dfc4639962b68faf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8918461fc41576664719c12ce7d655aaad2c78d1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8918461fc41576664719c12ce7d655aaad2c78d1", "html_url": "https://github.com/rust-lang/rust/commit/8918461fc41576664719c12ce7d655aaad2c78d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8918461fc41576664719c12ce7d655aaad2c78d1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ac7194ff31792e2eca2c745fbef309a2daba86", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ac7194ff31792e2eca2c745fbef309a2daba86", "html_url": "https://github.com/rust-lang/rust/commit/e9ac7194ff31792e2eca2c745fbef309a2daba86"}], "stats": {"total": 96, "additions": 40, "deletions": 56}, "files": [{"sha": "e0101c46fb9903cf3509d7eab88fa52832cbf65f", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=8918461fc41576664719c12ce7d655aaad2c78d1", "patch": "@@ -211,12 +211,13 @@ rust_sched_loop::return_c_stack(stk_seg *stack) {\n // NB: Runs on the Rust stack. Might return NULL!\n inline stk_seg *\n rust_sched_loop::borrow_big_stack() {\n-    assert(cached_big_stack);\n     stk_seg *your_stack;\n     if (extra_big_stack) {\n         your_stack = extra_big_stack;\n         extra_big_stack = NULL;\n     } else {\n+        // NB: This may be null if we're asking for a *second*\n+        // big stack, in which case the caller will fall back to a slow path\n         your_stack = cached_big_stack;\n         cached_big_stack = NULL;\n     }"}, {"sha": "4d6d2567cd4525bb532d4f130d0d268466eedd9e", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 14, "deletions": 42, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=8918461fc41576664719c12ce7d655aaad2c78d1", "patch": "@@ -54,8 +54,7 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     disallow_yield(0),\n     c_stack(NULL),\n     next_c_sp(0),\n-    next_rust_sp(0),\n-    big_stack(NULL)\n+    next_rust_sp(0)\n {\n     LOGPTR(sched_loop, \"new task\", (uintptr_t)this);\n     DLOG(sched_loop, task, \"sizeof(task) = %d (0x%x)\",\n@@ -566,14 +565,8 @@ rust_task::cleanup_after_turn() {\n \n     while (stk->next) {\n         stk_seg *new_next = stk->next->next;\n-\n-        if (stk->next->is_big) {\n-            assert (big_stack == stk->next);\n-            sched_loop->return_big_stack(big_stack);\n-            big_stack = NULL;\n-        } else {\n-            free_stack(stk->next);\n-        }\n+        assert (!stk->next->is_big);\n+        free_stack(stk->next);\n \n         stk->next = new_next;\n     }\n@@ -584,38 +577,20 @@ rust_task::cleanup_after_turn() {\n bool\n rust_task::new_big_stack() {\n     assert(stk);\n-    // If we have a cached big stack segment, use it.\n-    if (big_stack) {\n-        // Check to see if we're already on the big stack.\n-        stk_seg *ss = stk;\n-        while (ss != NULL) {\n-            if (ss == big_stack)\n-                return false;\n-            ss = ss->prev;\n-        }\n \n-        // Unlink the big stack.\n-        if (big_stack->next)\n-            big_stack->next->prev = big_stack->prev;\n-        if (big_stack->prev)\n-            big_stack->prev->next = big_stack->next;\n-    } else {\n-        stk_seg *borrowed_big_stack = sched_loop->borrow_big_stack();\n-        if (!borrowed_big_stack) {\n-            abort();\n-        } else {\n-            big_stack = borrowed_big_stack;\n-        }\n+    stk_seg *borrowed_big_stack = sched_loop->borrow_big_stack();\n+    if (!borrowed_big_stack) {\n+        return false;\n     }\n \n-    big_stack->task = this;\n-    big_stack->next = stk->next;\n-    if (big_stack->next)\n-        big_stack->next->prev = big_stack;\n-    big_stack->prev = stk;\n-    stk->next = big_stack;\n+    borrowed_big_stack->task = this;\n+    borrowed_big_stack->next = stk->next;\n+    if (borrowed_big_stack->next)\n+        borrowed_big_stack->next->prev = borrowed_big_stack;\n+    borrowed_big_stack->prev = stk;\n+    stk->next = borrowed_big_stack;\n \n-    stk = big_stack;\n+    stk = borrowed_big_stack;\n \n     return true;\n }\n@@ -640,10 +615,9 @@ void\n rust_task::reset_stack_limit() {\n     uintptr_t sp = get_sp();\n     while (!sp_in_stk_seg(sp, stk)) {\n-        stk = stk->prev;\n+        prev_stack();\n         assert(stk != NULL && \"Failed to find the current stack\");\n     }\n-    record_stack_limit();\n }\n \n void\n@@ -667,8 +641,6 @@ rust_task::delete_all_stacks() {\n \n         stk = prev;\n     }\n-\n-    big_stack = NULL;\n }\n \n /*"}, {"sha": "1735d35b0652366a33d7ae91177cadadd7de913a", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=8918461fc41576664719c12ce7d655aaad2c78d1", "patch": "@@ -278,9 +278,6 @@ rust_task : public kernel_owned<rust_task>\n     uintptr_t next_c_sp;\n     uintptr_t next_rust_sp;\n \n-    // The big stack.\n-    stk_seg *big_stack;\n-\n     // Called when the atomic refcount reaches zero\n     void delete_this();\n \n@@ -607,7 +604,21 @@ rust_task::prev_stack() {\n     // require switching to the C stack and be costly. Instead we'll just move\n     // up the link list and clean up later, either in new_stack or after our\n     // turn ends on the scheduler.\n-    stk = stk->prev;\n+    if (stk->is_big) {\n+        stk_seg *ss = stk;\n+        stk = stk->prev;\n+\n+        // Unlink the big stack.\n+        if (ss->next)\n+            ss->next->prev = ss->prev;\n+        if (ss->prev)\n+            ss->prev->next = ss->next;\n+\n+        sched_loop->return_big_stack(ss);\n+    } else {\n+        stk = stk->prev;\n+    }\n+\n     record_stack_limit();\n }\n "}, {"sha": "a67bbb05dfb51886ee7d4cae3789488b61f755f4", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918461fc41576664719c12ce7d655aaad2c78d1/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=8918461fc41576664719c12ce7d655aaad2c78d1", "patch": "@@ -10,35 +10,35 @@\n \n // Based on threadring.erlang by Jira Isa\n \n-// xfail-test FIXME #5985 OOM's on the mac bot\n+use std::os;\n \n fn start(n_tasks: int, token: int) {\n-    let mut (p, ch1) = comm::stream();\n+    let mut (p, ch1) = stream();\n     ch1.send(token);\n     //  XXX could not get this to work with a range closure\n     let mut i = 2;\n     while i <= n_tasks {\n-        let (next_p, ch) = comm::stream();\n+        let (next_p, ch) = stream();\n         let imm_i = i;\n         let imm_p = p;\n-        do task::spawn {\n+        do spawn {\n             roundtrip(imm_i, n_tasks, &imm_p, &ch);\n         };\n         p = next_p;\n         i += 1;\n     }\n     let imm_p = p;\n     let imm_ch = ch1;\n-    do task::spawn {\n+    do spawn {\n         roundtrip(1, n_tasks, &imm_p, &imm_ch);\n     }\n }\n \n-fn roundtrip(id: int, n_tasks: int, p: &comm::Port<int>, ch: &comm::Chan<int>) {\n+fn roundtrip(id: int, n_tasks: int, p: &Port<int>, ch: &Chan<int>) {\n     while (true) {\n         match p.recv() {\n           1 => {\n-            io::println(fmt!(\"%d\\n\", id));\n+            println(fmt!(\"%d\\n\", id));\n             return;\n           }\n           token => {\n@@ -60,13 +60,13 @@ fn main() {\n         os::args()\n     };\n     let token = if args.len() > 1u {\n-        int::from_str(args[1]).get()\n+        FromStr::from_str(args[1]).get()\n     }\n     else {\n         1000\n     };\n     let n_tasks = if args.len() > 2u {\n-        int::from_str(args[2]).get()\n+        FromStr::from_str(args[2]).get()\n     }\n     else {\n         503"}]}