{"sha": "a33a7d20de35febdb697ca93d3c36b78930dde8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzM2E3ZDIwZGUzNWZlYmRiNjk3Y2E5M2QzYzM2Yjc4OTMwZGRlOGQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-12-04T20:06:42Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-12-29T12:55:24Z"}, "message": "Switch Region information from uint to u32.\n\nThis reduces memory use for building librustc with -O from 1.88 to 1.76\nGB.", "tree": {"sha": "1f0786b714239ddd8054dade8efe1e6ef9a45d4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f0786b714239ddd8054dade8efe1e6ef9a45d4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a33a7d20de35febdb697ca93d3c36b78930dde8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a33a7d20de35febdb697ca93d3c36b78930dde8d", "html_url": "https://github.com/rust-lang/rust/commit/a33a7d20de35febdb697ca93d3c36b78930dde8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a33a7d20de35febdb697ca93d3c36b78930dde8d/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a548f8917b21c1932f568576b9604119156f37d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a548f8917b21c1932f568576b9604119156f37d6", "html_url": "https://github.com/rust-lang/rust/commit/a548f8917b21c1932f568576b9604119156f37d6"}], "stats": {"total": 295, "additions": 157, "deletions": 138}, "files": [{"sha": "4447af809e4b208ae461a2926d59561a9e062b78", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -1449,7 +1449,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as uint);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n-        let index = reader::doc_as_u64(doc) as uint;\n+        let index = reader::doc_as_u64(doc) as u32;\n \n         let mut bounds = Vec::new();\n         reader::tagged_docs(rp_doc, tag_items_data_region, |p| {"}, {"sha": "b623fa2102349055f779fcafedca2d5b9455dcae", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -281,7 +281,7 @@ fn parse_region_substs(st: &mut PState, conv: conv_did) -> subst::RegionSubsts {\n fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n     match next(st) {\n         'a' => {\n-            let id = parse_uint(st);\n+            let id = parse_u32(st);\n             assert_eq!(next(st), '|');\n             ty::BrAnon(id)\n         }\n@@ -291,7 +291,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n-            let id = parse_uint(st);\n+            let id = parse_u32(st);\n             assert_eq!(next(st), '|');\n             ty::BrFresh(id)\n         }\n@@ -304,7 +304,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     match next(st) {\n       'b' => {\n         assert_eq!(next(st), '[');\n-        let id = ty::DebruijnIndex::new(parse_uint(st));\n+        let id = ty::DebruijnIndex::new(parse_u32(st));\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n@@ -316,7 +316,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let index = parse_uint(st);\n+        let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n         let nm = token::str_to_ident(parse_str(st, ']')[]);\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n@@ -421,7 +421,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         debug!(\"parsed ty_param: did={}\", did);\n-        let index = parse_uint(st);\n+        let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n@@ -535,6 +535,13 @@ fn parse_uint(st: &mut PState) -> uint {\n     };\n }\n \n+fn parse_u32(st: &mut PState) -> u32 {\n+    let n = parse_uint(st);\n+    let m = n as u32;\n+    assert_eq!(m as uint, n);\n+    m\n+}\n+\n fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n     subst::ParamSpace::from_uint(parse_uint(st))\n }\n@@ -697,7 +704,7 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n     let space = parse_param_space(st);\n     assert_eq!(next(st), '|');\n-    let index = parse_uint(st);\n+    let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n     let associated_with = parse_opt(st, |st| {\n         parse_def(st, NominalType, |x,y| conv(x,y))"}, {"sha": "023182df336528b9ac91c2298f3f8eca7d3dae8a", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -39,7 +39,7 @@ pub enum Def {\n     DefAssociatedPath(TyParamProvenance, ast::Ident),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n-    DefTyParam(ParamSpace, ast::DefId, uint),\n+    DefTyParam(ParamSpace, ast::DefId, u32),\n     DefUse(ast::DefId),\n     DefUpvar(ast::NodeId,  // id of closed over local\n              ast::NodeId,  // expr node that creates the closure"}, {"sha": "2f62858071f6a9204f4e9119ba03bbae9d8c7a98", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -870,11 +870,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n struct RebuildPathInfo<'a> {\n     path: &'a ast::Path,\n     // indexes to insert lifetime on path.lifetimes\n-    indexes: Vec<uint>,\n+    indexes: Vec<u32>,\n     // number of lifetimes we expect to see on the type referred by `path`\n     // (e.g., expected=1 for struct Foo<'a>)\n-    expected: uint,\n-    anon_nums: &'a HashSet<uint>,\n+    expected: u32,\n+    anon_nums: &'a HashSet<u32>,\n     region_names: &'a HashSet<ast::Name>\n }\n \n@@ -885,8 +885,8 @@ struct Rebuilder<'a, 'tcx: 'a> {\n     generics: &'a ast::Generics,\n     same_regions: &'a [SameRegions],\n     life_giver: &'a LifeGiver,\n-    cur_anon: Cell<uint>,\n-    inserted_anons: RefCell<HashSet<uint>>,\n+    cur_anon: Cell<u32>,\n+    inserted_anons: RefCell<HashSet<u32>>,\n }\n \n enum FreshOrKept {\n@@ -976,7 +976,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn extract_anon_nums_and_names(&self, same_regions: &SameRegions)\n-                                   -> (HashSet<uint>, HashSet<ast::Name>) {\n+                                   -> (HashSet<u32>, HashSet<ast::Name>) {\n         let mut anon_nums = HashSet::new();\n         let mut region_names = HashSet::new();\n         for br in same_regions.regions.iter() {\n@@ -1008,7 +1008,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         all_region_names\n     }\n \n-    fn inc_cur_anon(&self, n: uint) {\n+    fn inc_cur_anon(&self, n: u32) {\n         let anon = self.cur_anon.get();\n         self.cur_anon.set(anon+n);\n     }\n@@ -1021,12 +1021,12 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         self.cur_anon.set(anon);\n     }\n \n-    fn inc_and_offset_cur_anon(&self, n: uint) {\n+    fn inc_and_offset_cur_anon(&self, n: u32) {\n         self.inc_cur_anon(n);\n         self.offset_cur_anon();\n     }\n \n-    fn track_anon(&self, anon: uint) {\n+    fn track_anon(&self, anon: u32) {\n         self.inserted_anons.borrow_mut().insert(anon);\n     }\n \n@@ -1070,13 +1070,13 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     let lifetimes = last_seg.parameters.lifetimes();\n                     for (i, lt) in lifetimes.iter().enumerate() {\n                         if region_names.contains(&lt.name) {\n-                            insert.push(i);\n+                            insert.push(i as u32);\n                         }\n                     }\n                     let rebuild_info = RebuildPathInfo {\n                         path: &tr.path,\n                         indexes: insert,\n-                        expected: lifetimes.len(),\n+                        expected: lifetimes.len() as u32,\n                         anon_nums: &HashSet::new(),\n                         region_names: region_names\n                     };\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_expl_self(&self,\n                          expl_self_opt: Option<ast::ExplicitSelf_>,\n                          lifetime: ast::Lifetime,\n-                         anon_nums: &HashSet<uint>,\n+                         anon_nums: &HashSet<u32>,\n                          region_names: &HashSet<ast::Name>)\n                          -> Option<ast::ExplicitSelf_> {\n         match expl_self_opt {\n@@ -1150,7 +1150,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_args_ty(&self,\n                        inputs: &[ast::Arg],\n                        lifetime: ast::Lifetime,\n-                       anon_nums: &HashSet<uint>,\n+                       anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n                        -> Vec<ast::Arg> {\n         let mut new_inputs = Vec::new();\n@@ -1169,7 +1169,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn rebuild_output(&self, ty: &ast::FunctionRetTy,\n                       lifetime: ast::Lifetime,\n-                      anon_nums: &HashSet<uint>,\n+                      anon_nums: &HashSet<u32>,\n                       region_names: &HashSet<ast::Name>) -> ast::FunctionRetTy {\n         match *ty {\n             ast::Return(ref ret_ty) => ast::Return(\n@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_arg_ty_or_output(&self,\n                                 ty: &ast::Ty,\n                                 lifetime: ast::Lifetime,\n-                                anon_nums: &HashSet<uint>,\n+                                anon_nums: &HashSet<u32>,\n                                 region_names: &HashSet<ast::Name>)\n                                 -> P<ast::Ty> {\n         let mut new_ty = P(ty.clone());\n@@ -1229,7 +1229,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let generics = ty::lookup_item_type(self.tcx, did).generics;\n \n                             let expected =\n-                                generics.regions.len(subst::TypeSpace);\n+                                generics.regions.len(subst::TypeSpace) as u32;\n                             let lifetimes =\n                                 path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();\n@@ -1238,15 +1238,15 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 for (i, a) in range(anon,\n                                                     anon+expected).enumerate() {\n                                     if anon_nums.contains(&a) {\n-                                        insert.push(i);\n+                                        insert.push(i as u32);\n                                     }\n                                     self.track_anon(a);\n                                 }\n                                 self.inc_and_offset_cur_anon(expected);\n                             } else {\n                                 for (i, lt) in lifetimes.iter().enumerate() {\n                                     if region_names.contains(&lt.name) {\n-                                        insert.push(i);\n+                                        insert.push(i as u32);\n                                     }\n                                 }\n                             }\n@@ -1363,7 +1363,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                 } else {\n                     for (i, lt) in data.lifetimes.iter().enumerate() {\n-                        if indexes.contains(&i) {\n+                        if indexes.contains(&(i as u32)) {\n                             new_lts.push(lifetime);\n                         } else {\n                             new_lts.push(*lt);"}, {"sha": "d8455b8db71ed511df34c0e515cb19ac66f90034", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -41,7 +41,7 @@ use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    freshen_count: uint,\n+    freshen_count: u32,\n     freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n@@ -59,7 +59,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n                   key: ty::InferTy,\n                   freshener: F)\n                   -> Ty<'tcx> where\n-        F: FnOnce(uint) -> ty::InferTy,\n+        F: FnOnce(u32) -> ty::InferTy,\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }"}, {"sha": "14a0933ed1c06e3e5b925a65273a5ea1116778a4", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -33,7 +33,7 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n-use std::uint;\n+use std::u32;\n use syntax::ast;\n \n mod doc;\n@@ -196,8 +196,8 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n \n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n-    skolemization_count: Cell<uint>,\n-    bound_count: Cell<uint>,\n+    skolemization_count: Cell<u32>,\n+    bound_count: Cell<u32>,\n \n     // The undo log records actions that might later be undone.\n     //\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n                     var_origins.pop().unwrap();\n-                    assert_eq!(var_origins.len(), vid.index);\n+                    assert_eq!(var_origins.len(), vid.index as uint);\n                 }\n                 AddConstraint(ref constraint) => {\n                     self.constraints.borrow_mut().remove(constraint);\n@@ -303,8 +303,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n     }\n \n-    pub fn num_vars(&self) -> uint {\n-        self.var_origins.borrow().len()\n+    pub fn num_vars(&self) -> u32 {\n+        let len = self.var_origins.borrow().len();\n+        // enforce no overflow\n+        assert!(len as u32 as uint == len);\n+        len as u32\n     }\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> RegionVid {\n@@ -547,7 +550,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[rid.index].span(),\n+                    (*self.var_origins.borrow())[rid.index as uint].span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n@@ -737,7 +740,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                (*self.var_origins.borrow())[v_id.index].span(),\n+                (*self.var_origins.borrow())[v_id.index as uint].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {}, {}\",\n                         a,\n@@ -840,7 +843,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[v_id.index].span(),\n+                    (*self.var_origins.borrow())[v_id.index as uint].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {}, {}\",\n                             a,\n@@ -972,7 +975,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        Vec::from_fn(self.num_vars(), |_| {\n+        Vec::from_fn(self.num_vars() as uint, |_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -1001,14 +1004,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                    .repr(self.tcx));\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_data = &mut var_data[b_vid.index];\n+                let b_data = &mut var_data[b_vid.index as uint];\n                 self.expand_node(a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[a_vid.index].value {\n+                match var_data[a_vid.index as uint].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut var_data[b_vid.index];\n+                    let b_node = &mut var_data[b_vid.index as uint];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1089,16 +1092,16 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[b_vid.index].value {\n+                match var_data[b_vid.index as uint].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_data = &mut var_data[a_vid.index];\n+                    let a_data = &mut var_data[a_vid.index as uint];\n                     self.contract_node(a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_data = &mut var_data[a_vid.index];\n+                let a_data = &mut var_data[a_vid.index as uint];\n                 self.contract_node(a_vid, a_data, b_region)\n               }\n             }\n@@ -1244,11 +1247,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = Vec::from_elem(self.num_vars(), uint::MAX);\n+        let mut dup_vec = Vec::from_elem(self.num_vars() as uint, u32::MAX);\n \n         let mut opt_graph = None;\n \n-        for idx in range(0u, self.num_vars()) {\n+        for idx in range(0u, self.num_vars() as uint) {\n             match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1288,7 +1291,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     }\n                     let graph = opt_graph.as_ref().unwrap();\n \n-                    let node_vid = RegionVid { index: idx };\n+                    let node_vid = RegionVid { index: idx as u32 };\n                     match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n@@ -1305,7 +1308,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        Vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n+        Vec::from_fn(self.num_vars() as uint, |idx| var_data[idx].value)\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1314,28 +1317,28 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let constraints = self.constraints.borrow();\n         let num_edges = constraints.len();\n \n-        let mut graph = graph::Graph::with_capacity(num_vars + 1,\n+        let mut graph = graph::Graph::with_capacity(num_vars as uint + 1,\n                                                     num_edges);\n \n-        for _ in range(0u, num_vars) {\n+        for _ in range(0, num_vars) {\n             graph.add_node(());\n         }\n         let dummy_idx = graph.add_node(());\n \n         for (constraint, _) in constraints.iter() {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.index),\n-                                   NodeIndex(b_id.index),\n+                    graph.add_edge(NodeIndex(a_id.index as uint),\n+                                   NodeIndex(b_id.index as uint),\n                                    *constraint);\n                 }\n                 ConstrainRegSubVar(_, b_id) => {\n                     graph.add_edge(dummy_idx,\n-                                   NodeIndex(b_id.index),\n+                                   NodeIndex(b_id.index as uint),\n                                    *constraint);\n                 }\n                 ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index),\n+                    graph.add_edge(NodeIndex(a_id.index as uint),\n                                    dummy_idx,\n                                    *constraint);\n                 }\n@@ -1349,7 +1352,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         &self,\n         graph: &RegionGraph,\n         var_data: &[VarData],\n-        dup_vec: &mut [uint],\n+        dup_vec: &mut [u32],\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n@@ -1387,7 +1390,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1398,7 +1401,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index].span(),\n+            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n@@ -1410,7 +1413,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         &self,\n         graph: &RegionGraph,\n         var_data: &[VarData],\n-        dup_vec: &mut [uint],\n+        dup_vec: &mut [u32],\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n@@ -1431,7 +1434,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n                         upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n                         upper_bound_2.origin.clone(),\n@@ -1443,7 +1446,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index].span(),\n+            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {}, upper_bounds={}\",\n                     node_idx,\n@@ -1455,7 +1458,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                 var_data: &[VarData],\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n-                                dup_vec: &mut [uint])\n+                                dup_vec: &mut [u32])\n                                 -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n         struct WalkState<'tcx> {\n             set: FnvHashSet<RegionVid>,\n@@ -1477,12 +1480,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop().unwrap();\n-            let classification = var_data[node_idx.index].classification;\n+            let classification = var_data[node_idx.index as uint].classification;\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index] == uint::MAX {\n-                dup_vec[node_idx.index] = orig_node_idx.index;\n-            } else if dup_vec[node_idx.index] != orig_node_idx.index {\n+            if dup_vec[node_idx.index as uint] == u32::MAX {\n+                dup_vec[node_idx.index as uint] = orig_node_idx.index;\n+            } else if dup_vec[node_idx.index as uint] != orig_node_idx.index {\n                 state.dup_found = true;\n             }\n \n@@ -1510,7 +1513,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid={}, dir={})\", source_vid, dir);\n \n-            let source_node_index = NodeIndex(source_vid.index);\n+            let source_node_index = NodeIndex(source_vid.index as uint);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n@@ -1595,7 +1598,7 @@ fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n }\n \n fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n-    match values[rid.index] {\n+    match values[rid.index as uint] {\n         Value(r) => r,\n         NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n         ErrorValue => ReStatic, // Previously reported error."}, {"sha": "b670dd1b54df4769621a746114c858276bbc02a3", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -67,11 +67,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n-        relations(self.values.get_mut(a.index))\n+        relations(self.values.get_mut(a.index as uint))\n     }\n \n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index).diverging\n+        self.values.get(vid.index as uint).diverging\n     }\n \n     /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n@@ -95,7 +95,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n         let old_value = {\n-            let value_ptr = &mut self.values.get_mut(vid.index).value;\n+            let value_ptr = &mut self.values.get_mut(vid.index as uint).value;\n             mem::replace(value_ptr, Known(ty))\n         };\n \n@@ -117,11 +117,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             value: Bounded(vec![]),\n             diverging: diverging\n         });\n-        ty::TyVid { index: index }\n+        ty::TyVid { index: index as u32 }\n     }\n \n     pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        match self.values.get(vid.index).value {\n+        match self.values.get(vid.index as uint).value {\n             Bounded(..) => None,\n             Known(t) => Some(t)\n         }\n@@ -201,12 +201,12 @@ impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegat\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {\n-                values[vid.index].value = Bounded(relations);\n+                values[vid.index as uint].value = Bounded(relations);\n             }\n \n             Relate(a, b) => {\n-                relations(&mut (*values)[a.index]).pop();\n-                relations(&mut (*values)[b.index]).pop();\n+                relations(&mut (*values)[a.index as uint]).pop();\n+                relations(&mut (*values)[b.index as uint]).pop();\n             }\n         }\n     }\n@@ -218,4 +218,3 @@ fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n         Bounded(ref mut relations) => relations\n     }\n }\n-"}, {"sha": "dcf70263c0a43b281973630c4c3dc68e68223de1", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -347,9 +347,9 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n // Integral type keys\n \n impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n-    fn index(&self) -> uint { self.index }\n+    fn index(&self) -> uint { self.index as uint }\n \n-    fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i } }\n+    fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt)\n         -> &'v RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>\n@@ -380,9 +380,9 @@ impl<'tcx> UnifyValue<'tcx> for Option<IntVarValue> { }\n // Floating point type keys\n \n impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n-    fn index(&self) -> uint { self.index }\n+    fn index(&self) -> uint { self.index as uint }\n \n-    fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i } }\n+    fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt)\n         -> &'v RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>"}, {"sha": "22dea3be1d4b65a236d5e19a19518a5517405f1d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -37,7 +37,7 @@ use util::nodemap::NodeMap;\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n-                        /* index */ uint,\n+                        /* index */ u32,\n                         /* lifetime decl */ ast::NodeId),\n     DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n@@ -508,10 +508,10 @@ impl<'a> LifetimeContext<'a> {\n \n fn search_lifetimes<'a>(lifetimes: &'a Vec<ast::LifetimeDef>,\n                     lifetime_ref: &ast::Lifetime)\n-                    -> Option<(uint, &'a ast::Lifetime)> {\n+                    -> Option<(u32, &'a ast::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n         if lifetime_decl.lifetime.name == lifetime_ref.name {\n-            return Some((i, &lifetime_decl.lifetime));\n+            return Some((i as u32, &lifetime_decl.lifetime));\n         }\n     }\n     return None;"}, {"sha": "abacad7d37c90f58bc07a7f9902d730a9524cf7c", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -98,10 +98,10 @@ impl<'tcx> Substs<'tcx> {\n     }\n \n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        *self.types.get(ty_param_def.space, ty_param_def.index)\n+        *self.types.get(ty_param_def.space, ty_param_def.index as uint)\n     }\n \n-    pub fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    pub fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n             match self.regions {\n                 ErasedRegions =>\n@@ -582,7 +582,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n     ty_stack_depth: uint,\n \n     // Number of region binders we have passed through while doing the substitution\n-    region_binders_passed: uint,\n+    region_binders_passed: u32,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                 match self.substs.regions {\n                     ErasedRegions => ty::ReStatic,\n                     NonerasedRegions(ref regions) =>\n-                        match regions.opt_get(space, i) {\n+                        match regions.opt_get(space, i as uint) {\n                             Some(&r) => {\n                                 self.shift_region_through_binders(r)\n                             }\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.opt_get(p.space, p.idx);\n+        let opt_ty = self.substs.types.opt_get(p.space, p.idx as uint);\n         let ty = match opt_ty {\n             Some(t) => *t,\n             None => {"}, {"sha": "670603cf311d4bf3bca0d5c5791f21c4a7db5035", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -862,7 +862,7 @@ pub struct TyS<'tcx> {\n     pub flags: TypeFlags,\n \n     // the maximal depth of any bound regions appearing in this type.\n-    region_depth: uint,\n+    region_depth: u32,\n }\n \n impl fmt::Show for TypeFlags {\n@@ -955,7 +955,7 @@ pub fn type_has_escaping_regions(ty: Ty) -> bool {\n     type_escapes_depth(ty, 0)\n }\n \n-pub fn type_escapes_depth(ty: Ty, depth: uint) -> bool {\n+pub fn type_escapes_depth(ty: Ty, depth: u32) -> bool {\n     ty.region_depth > depth\n }\n \n@@ -1009,7 +1009,7 @@ pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n #[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n-    pub idx: uint,\n+    pub idx: u32,\n     pub def_id: DefId\n }\n \n@@ -1056,7 +1056,7 @@ pub struct ParamTy {\n pub struct DebruijnIndex {\n     // We maintain the invariant that this is never 0. So 1 indicates\n     // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n-    pub depth: uint,\n+    pub depth: u32,\n }\n \n /// Representation of regions:\n@@ -1067,7 +1067,7 @@ pub enum Region {\n     // parameters are substituted.\n     ReEarlyBound(/* param id */ ast::NodeId,\n                  subst::ParamSpace,\n-                 /*index*/ uint,\n+                 /*index*/ u32,\n                  ast::Name),\n \n     // Region bound in a function scope, which will be substituted when the\n@@ -1217,7 +1217,7 @@ impl Region {\n         }\n     }\n \n-    pub fn escapes_depth(&self, depth: uint) -> bool {\n+    pub fn escapes_depth(&self, depth: u32) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n             _ => false,\n@@ -1238,7 +1238,7 @@ pub struct FreeRegion {\n            RustcEncodable, RustcDecodable, Show, Copy)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n-    BrAnon(uint),\n+    BrAnon(u32),\n \n     /// Named region parameters for functions (a in &'a T)\n     ///\n@@ -1247,7 +1247,7 @@ pub enum BoundRegion {\n     BrNamed(ast::DefId, ast::Name),\n \n     /// Fresh bound identifiers created during GLB computations.\n-    BrFresh(uint),\n+    BrFresh(u32),\n \n     // Anonymous region for the implicit env pointer parameter\n     // to a closure\n@@ -1538,22 +1538,22 @@ impl CLike for BuiltinBound {\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TyVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct IntVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FloatVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct RegionVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n@@ -1565,18 +1565,18 @@ pub enum InferTy {\n     /// A `FreshTy` is one that is generated as a replacement for an\n     /// unbound type variable. This is convenient for caching etc. See\n     /// `middle::infer::freshen` for more details.\n-    FreshTy(uint),\n+    FreshTy(u32),\n \n     // FIXME -- once integral fallback is impl'd, we should remove\n     // this type. It's only needed to prevent spurious errors for\n     // integers whose type winds up never being constrained.\n-    FreshIntTy(uint),\n+    FreshIntTy(u32),\n }\n \n #[deriving(Clone, RustcEncodable, RustcDecodable, Eq, Hash, Show, Copy)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n-    ReSkolemized(uint, BoundRegion)\n+    ReSkolemized(u32, BoundRegion)\n }\n \n impl cmp::PartialEq for InferRegion {\n@@ -1653,7 +1653,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n-    pub index: uint,\n+    pub index: u32,\n     pub associated_with: Option<ast::DefId>,\n     pub bounds: ParamBounds<'tcx>,\n     pub default: Option<Ty<'tcx>>,\n@@ -1664,7 +1664,7 @@ pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n-    pub index: uint,\n+    pub index: u32,\n     pub bounds: Vec<ty::Region>,\n }\n \n@@ -2176,7 +2176,7 @@ struct FlagComputation {\n     flags: TypeFlags,\n \n     // maximum depth of any bound region that we have seen thus far\n-    depth: uint,\n+    depth: u32,\n }\n \n impl FlagComputation {\n@@ -2194,7 +2194,7 @@ impl FlagComputation {\n         self.flags = self.flags | flags;\n     }\n \n-    fn add_depth(&mut self, depth: uint) {\n+    fn add_depth(&mut self, depth: u32) {\n         if depth > self.depth {\n             self.depth = depth;\n         }\n@@ -2508,7 +2508,7 @@ pub fn mk_infer<'tcx>(cx: &ctxt<'tcx>, it: InferTy) -> Ty<'tcx> {\n }\n \n pub fn mk_param<'tcx>(cx: &ctxt<'tcx>, space: subst::ParamSpace,\n-                      n: uint, k: DefId) -> Ty<'tcx> {\n+                      n: u32, k: DefId) -> Ty<'tcx> {\n     mk_t(cx, ty_param(ParamTy { space: space, idx: n, def_id: k }))\n }\n \n@@ -2580,7 +2580,7 @@ pub fn fold_ty<'tcx, F>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n \n impl ParamTy {\n     pub fn new(space: subst::ParamSpace,\n-               index: uint,\n+               index: u32,\n                def_id: ast::DefId)\n                -> ParamTy {\n         ParamTy { space: space, idx: index, def_id: def_id }\n@@ -4823,7 +4823,7 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n                                        -> uint {\n     for type_parameter_def in trait_def.generics.types.iter() {\n         if type_parameter_def.def_id == associated_type_id {\n-            return type_parameter_def.index\n+            return type_parameter_def.index as uint\n         }\n     }\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n@@ -6188,7 +6188,7 @@ pub fn construct_parameter_environment<'tcx>(\n                    space,\n                    def.repr(tcx),\n                    i);\n-            let ty = ty::mk_param(tcx, space, i, def.def_id);\n+            let ty = ty::mk_param(tcx, space, i as u32, def.def_id);\n             types.push(space, ty);\n         }\n     }\n@@ -6509,12 +6509,12 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n }\n \n impl DebruijnIndex {\n-    pub fn new(depth: uint) -> DebruijnIndex {\n+    pub fn new(depth: u32) -> DebruijnIndex {\n         assert!(depth > 0);\n         DebruijnIndex { depth: depth }\n     }\n \n-    pub fn shifted(&self, amount: uint) -> DebruijnIndex {\n+    pub fn shifted(&self, amount: u32) -> DebruijnIndex {\n         DebruijnIndex { depth: self.depth + amount }\n     }\n }"}, {"sha": "d42744fbc7b3861ffcd6bb6adafe1c774ed045b5", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -717,13 +717,13 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n \n pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    current_depth: uint,\n-    fld_r: &'a mut (FnMut(ty::Region, uint) -> ty::Region + 'a),\n+    current_depth: u32,\n+    fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     pub fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n-        where F : FnMut(ty::Region, uint) -> ty::Region\n+        where F : FnMut(ty::Region, u32) -> ty::Region\n     {\n         RegionFolder {\n             tcx: tcx,\n@@ -813,7 +813,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n // regions. See comment on `shift_regions_through_binders` method in\n // `subst.rs` for more details.\n \n-pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n+pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     match region {\n         ty::ReLateBound(debruijn, br) => {\n             ty::ReLateBound(debruijn.shifted(amount), br)\n@@ -825,7 +825,7 @@ pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n }\n \n pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>,\n-                                                            amount: uint, value: &T) -> T {\n+                                                            amount: u32, value: &T) -> T {\n     debug!(\"shift_regions(value={}, amount={})\",\n            value.repr(tcx), amount);\n "}, {"sha": "c168709eec5b91c213d0e793917347fa87aa17f9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -4254,7 +4254,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     let def_like = DlDef(DefTyParam(space,\n                                                     local_def(type_parameter.id),\n-                                                    index));\n+                                                    index as u32));\n                     // Associate this type parameter with\n                     // the item that bound it\n                     self.record_def(type_parameter.id,"}, {"sha": "4ffbd4df6e7875fd8f7990ade75f2ea469f4f1e6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -5502,7 +5502,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             match t.sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n-                    tps_used[idx] = true;\n+                    tps_used[idx as uint] = true;\n                 }\n                 _ => ()\n             }\n@@ -5518,7 +5518,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n-    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: uint) -> Ty<'tcx> {\n+    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         ty::mk_param(ccx.tcx, subst::FnSpace, n, local_def(0))\n     }\n \n@@ -5561,16 +5561,16 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n-            \"init\" => (1u, Vec::new(), param(ccx, 0u)),\n-            \"uninit\" => (1u, Vec::new(), param(ccx, 0u)),\n+            \"init\" => (1u, Vec::new(), param(ccx, 0)),\n+            \"uninit\" => (1u, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1u,\n                  vec!(\n                     ty::mk_mut_rptr(tcx, ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(0)),\n                                     param(ccx, 0)),\n-                    param(ccx, 0u)\n+                    param(ccx, 0)\n                   ),\n                ty::mk_nil(tcx))\n             }"}, {"sha": "fc21dce18996b7af45e9058f806f6a6a30a33602", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -651,7 +651,7 @@ fn is_associated_type_valid_for_param(ty: Ty,\n                                       generics: &ty::Generics)\n                                       -> bool {\n     if let ty::ty_param(param_ty) = ty.sty {\n-        let type_parameter = generics.types.get(param_ty.space, param_ty.idx);\n+        let type_parameter = generics.types.get(param_ty.space, param_ty.idx as uint);\n         for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n             if trait_bound.def_id() == trait_id {\n                 return true\n@@ -1397,7 +1397,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .enumerate()\n                     .map(|(i, def)| ty::ReEarlyBound(def.lifetime.id,\n                                                      subst::TypeSpace,\n-                                                     i,\n+                                                     i as u32,\n                                                      def.lifetime.name))\n                     .collect();\n \n@@ -1407,7 +1407,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n-                                                 i, local_def(def.id)))\n+                                                 i as u32, local_def(def.id)))\n                     .collect();\n \n         // ...and also create generics synthesized from the associated types.\n@@ -1419,7 +1419,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     index += 1;\n                     Some(ty::mk_param(ccx.tcx,\n                                       subst::AssocSpace,\n-                                      index - 1,\n+                                      index as u32 - 1,\n                                       local_def(trait_item.ty_param.id))).into_iter()\n                 }\n                 ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n@@ -1621,7 +1621,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ccx,\n                         subst::AssocSpace,\n                         &associated_type.ty_param,\n-                        generics.types.len(subst::AssocSpace),\n+                        generics.types.len(subst::AssocSpace) as u32,\n                         Some(local_def(trait_id)));\n                 ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n                                                           def.clone());\n@@ -1746,7 +1746,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                              .collect();\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n-                                           index: i,\n+                                           index: i as u32,\n                                            def_id: local_def(l.lifetime.id),\n                                            bounds: bounds };\n         debug!(\"ty_generics: def for region param: {}\", def);\n@@ -1775,7 +1775,12 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         let def = get_or_create_type_parameter_def(&gcx,\n                                                    space,\n                                                    param,\n+<<<<<<< HEAD\n                                                    i,\n+=======\n+                                                   i as u32,\n+                                                   where_clause,\n+>>>>>>> Switch Region information from uint to u32.\n                                                    None);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n                def.repr(this.tcx()),\n@@ -1788,7 +1793,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                                                           .get_slice(space)\n                                                           .iter() {\n         assert!(result.types.get_slice(space).len() ==\n-                associated_type_param.index);\n+                associated_type_param.index as uint);\n         debug!(\"ty_generics: def for associated type: {}, {}\",\n                associated_type_param.repr(this.tcx()),\n                space);\n@@ -1915,7 +1920,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                         name: associated_type_def.name,\n                         def_id: associated_type_def.def_id,\n                         space: space,\n-                        index: types.len() + index,\n+                        index: types.len() as u32 + index,\n                         bounds: ty::ParamBounds {\n                             builtin_bounds: associated_type_def.bounds.builtin_bounds,\n \n@@ -1963,7 +1968,12 @@ fn ty_generics<'tcx,AC>(this: &AC,\n fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n+<<<<<<< HEAD\n                                              index: uint,\n+=======\n+                                             index: u32,\n+                                             where_clause: &ast::WhereClause,\n+>>>>>>> Switch Region information from uint to u32.\n                                              associated_with: Option<ast::DefId>)\n                                              -> ty::TypeParameterDef<'tcx>\n     where AC: AstConv<'tcx>"}, {"sha": "a97dce88a57628d78c01bda81d2c23fc62625a34", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -106,7 +106,7 @@ impl RegionScope for SpecificRscope {\n /// A scope in which we generate anonymous, late-bound regions for\n /// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n-    anon_bindings: Cell<uint>,\n+    anon_bindings: Cell<u32>,\n }\n \n impl BindingRscope {"}, {"sha": "b4409a61ece5470af3e1f547bffd397a4a04214a", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33a7d20de35febdb697ca93d3c36b78930dde8d/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=a33a7d20de35febdb697ca93d3c36b78930dde8d", "patch": "@@ -854,18 +854,18 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for p in type_param_defs.iter() {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n-                                       p.space, p.index);\n+                                       p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = *substs.types.get(p.space, p.index);\n+            let substs_ty = *substs.types.get(p.space, p.index as uint);\n             self.add_constraints_from_ty(substs_ty, variance_i);\n         }\n \n         for p in region_param_defs.iter() {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id,\n-                                       RegionParam, p.space, p.index);\n+                                       RegionParam, p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions().get(p.space, p.index);\n+            let substs_r = *substs.regions().get(p.space, p.index as uint);\n             self.add_constraints_from_region(substs_r, variance_i);\n         }\n     }"}]}