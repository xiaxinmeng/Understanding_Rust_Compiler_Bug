{"sha": "f96243295a297e8e64e0d7cf9c349f69cd7dcc56", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NjI0MzI5NWEyOTdlOGU2NGUwZDdjZjljMzQ5ZjY5Y2Q3ZGNjNTY=", "commit": {"author": {"name": "Nicholas Mazzuca", "email": "npmazzuca@gmail.com", "date": "2016-01-01T12:28:26Z"}, "committer": {"name": "Nicholas Mazzuca", "email": "npmazzuca@gmail.com", "date": "2016-01-01T12:28:26Z"}, "message": "In the middle of the implementation", "tree": {"sha": "c7a3a111f19060d1697e943ef781b70bc142814a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7a3a111f19060d1697e943ef781b70bc142814a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f96243295a297e8e64e0d7cf9c349f69cd7dcc56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f96243295a297e8e64e0d7cf9c349f69cd7dcc56", "html_url": "https://github.com/rust-lang/rust/commit/f96243295a297e8e64e0d7cf9c349f69cd7dcc56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f96243295a297e8e64e0d7cf9c349f69cd7dcc56/comments", "author": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfb4212ee2ae658dfd4feb5991ebff55e9ac5240", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb4212ee2ae658dfd4feb5991ebff55e9ac5240", "html_url": "https://github.com/rust-lang/rust/commit/bfb4212ee2ae658dfd4feb5991ebff55e9ac5240"}], "stats": {"total": 941, "additions": 727, "deletions": 214}, "files": [{"sha": "637e99672aecad5a7ae154da091ec69c3188603b", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 316, "deletions": 208, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/f96243295a297e8e64e0d7cf9c349f69cd7dcc56/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96243295a297e8e64e0d7cf9c349f69cd7dcc56/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=f96243295a297e8e64e0d7cf9c349f69cd7dcc56", "patch": "@@ -12,13 +12,13 @@\n #![unstable(feature = \"wrapping\", reason = \"may be removed or relocated\",\n             issue = \"27755\")]\n \n-pub use intrinsics::{add_with_overflow, sub_with_overflow, mul_with_overflow};\n+use intrinsics::{add_with_overflow, sub_with_overflow, mul_with_overflow};\n \n use super::Wrapping;\n \n use ops::*;\n \n-use ::{i8,i16,i32,i64};\n+use ::{i8, i16, i32, i64, isize};\n \n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n@@ -33,15 +33,71 @@ pub trait OverflowingOps {\n     fn overflowing_shr(self, rhs: u32) -> (Self, bool);\n }\n \n-macro_rules! sh_impl {\n-    ($t:ty, $f:ty) => (\n+macro_rules! sh_impl_signed {\n+    ($t:ident, $f:ident) => (\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline(always)]\n             fn shl(self, other: $f) -> Wrapping<$t> {\n-                Wrapping(self.0 << other)\n+                if other < 0 {\n+                    Wrapping(self.0 >> (-other & self::shift_max::$t as $f))\n+                } else {\n+                    Wrapping(self.0 << (other & self::shift_max::$t as $f))\n+                }\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShlAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self = *self << other;\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shr<$f> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn shr(self, other: $f) -> Wrapping<$t> {\n+                if other < 0 {\n+                    Wrapping(self.0 << (-other & self::shift_max::$t as $f))\n+                } else {\n+                    Wrapping(self.0 >> (other & self::shift_max::$t as $f))\n+                }\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShrAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self = *self >> other;\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! sh_impl_unsigned {\n+    ($t:ident, $f:ident) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shl<$f> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn shl(self, other: $f) -> Wrapping<$t> {\n+                Wrapping(self.0 << (other & self::shift_max::$t as $f))\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShlAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self = *self << other;\n             }\n         }\n \n@@ -51,26 +107,34 @@ macro_rules! sh_impl {\n \n             #[inline(always)]\n             fn shr(self, other: $f) -> Wrapping<$t> {\n-                Wrapping(self.0 >> other)\n+                Wrapping(self.0 >> (other & self::shift_max::$t as $f))\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShrAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self = *self >> other;\n             }\n         }\n     )\n }\n \n // FIXME (#23545): uncomment the remaining impls\n macro_rules! sh_impl_all {\n-    ($($t:ty)*) => ($(\n-        // sh_impl! { $t, u8 }\n-        // sh_impl! { $t, u16 }\n-        // sh_impl! { $t, u32 }\n-        // sh_impl! { $t, u64 }\n-        sh_impl! { $t, usize }\n-\n-        // sh_impl! { $t, i8 }\n-        // sh_impl! { $t, i16 }\n-        // sh_impl! { $t, i32 }\n-        // sh_impl! { $t, i64 }\n-        // sh_impl! { $t, isize }\n+    ($($t:ident)*) => ($(\n+        sh_impl_unsigned! { $t, u8 }\n+        sh_impl_unsigned! { $t, u16 }\n+        sh_impl_unsigned! { $t, u32 }\n+        sh_impl_unsigned! { $t, u64 }\n+        sh_impl_unsigned! { $t, usize }\n+\n+        sh_impl_signed! { $t, i8 }\n+        sh_impl_signed! { $t, i16 }\n+        sh_impl_signed! { $t, i32 }\n+        sh_impl_signed! { $t, i64 }\n+        sh_impl_signed! { $t, isize }\n     )*)\n }\n \n@@ -88,6 +152,32 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl Add<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn add(self, other: $t) -> Wrapping<$t> {\n+                self + Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl AddAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn add_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self + other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl AddAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn add_assign(&mut self, other: $t) {\n+                self.add_assign(Wrapping(other))\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Sub for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -98,6 +188,32 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl Sub<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn sub(self, other: $t) -> Wrapping<$t> {\n+                self - Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl SubAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn sub_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self - other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl SubAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn sub_assign(&mut self, other: $t) {\n+                self.sub_assign(Wrapping(other))\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Mul for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -108,6 +224,32 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl Mul<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn mul(self, other: $t) -> Wrapping<$t> {\n+                self * Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl MulAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn mul_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self * other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl MulAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn mul_assign(&mut self, other: $t) {\n+                self.mul_assign(Wrapping(other))\n+            }\n+        }\n+\n         #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n         impl Div for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -118,6 +260,68 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl Div<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn div(self, other: $t) -> Wrapping<$t> {\n+                self / Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl DivAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn div_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self / other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl DivAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn div_assign(&mut self, other: $t) {\n+                self.div_assign(Wrapping(other))\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl Rem for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0.wrapping_rem(other.0))\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl Rem<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn rem(self, other: $t) -> Wrapping<$t> {\n+                self % Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl RemAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn rem_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self % other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl RemAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn rem_assign(&mut self, other: $t) {\n+                self.rem_assign(Wrapping(other))\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -138,6 +342,32 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl BitXor<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn bitxor(self, other: $t) -> Wrapping<$t> {\n+                self ^ Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitXorAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitxor_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self ^ other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl BitXorAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitxor_assign(&mut self, other: $t) {\n+                self.bitxor_assign(Wrapping(other))\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitOr for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -148,6 +378,32 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl BitOr<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn bitor(self, other: $t) -> Wrapping<$t> {\n+                self | Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitOrAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitor_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self | other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl BitOrAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitor_assign(&mut self, other: $t) {\n+                self.bitor_assign(Wrapping(other))\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitAnd for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -157,6 +413,32 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 & other.0)\n             }\n         }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl BitAnd<$t> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn bitand(self, other: $t) -> Wrapping<$t> {\n+                self & Wrapping(other)\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitAndAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitand_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self & other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl BitAndAssign<$t> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitand_assign(&mut self, other: $t) {\n+                self.bitand_assign(Wrapping(other))\n+            }\n+        }\n     )*)\n }\n \n@@ -165,15 +447,29 @@ wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n mod shift_max {\n     #![allow(non_upper_case_globals)]\n \n+    #[cfg(target_pointer_width = \"32\")]\n+    mod platform {\n+        pub const usize: u32 = super::u32;\n+        pub const isize: u32 = super::i32;\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    mod platform {\n+        pub const usize: u32 = super::u64;\n+        pub const isize: u32 = super::i64;\n+    }\n+\n     pub const  i8: u32 = (1 << 3) - 1;\n     pub const i16: u32 = (1 << 4) - 1;\n     pub const i32: u32 = (1 << 5) - 1;\n     pub const i64: u32 = (1 << 6) - 1;\n+    pub use self::platform::isize;\n \n     pub const  u8: u32 = i8;\n     pub const u16: u32 = i16;\n     pub const u32: u32 = i32;\n     pub const u64: u32 = i64;\n+    pub use self::platform::usize;\n }\n \n macro_rules! signed_overflowing_impl {\n@@ -288,193 +584,5 @@ macro_rules! unsigned_overflowing_impl {\n     )*)\n }\n \n-signed_overflowing_impl! { i8 i16 i32 i64 }\n-unsigned_overflowing_impl! { u8 u16 u32 u64 }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-impl OverflowingOps for usize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_div(rhs as u64);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_rem(rhs as u64);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_neg();\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_shl(rhs);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_shr(rhs);\n-        (r as usize, f)\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-impl OverflowingOps for usize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_div(rhs as u32);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_rem(rhs as u32);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_neg();\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_shl(rhs);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_shr(rhs);\n-        (r as usize, f)\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-impl OverflowingOps for isize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_div(rhs as i64);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_rem(rhs as i64);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_neg();\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_shl(rhs);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_shr(rhs);\n-        (r as isize, f)\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-impl OverflowingOps for isize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_div(rhs as i32);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_rem(rhs as i32);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_neg();\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_shl(rhs);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_shr(rhs);\n-        (r as isize, f)\n-    }\n-}\n+signed_overflowing_impl! { i8 i16 i32 i64 isize }\n+unsigned_overflowing_impl! { u8 u16 u32 u64 usize }"}, {"sha": "545fd22cc592960517e1ec0242b2010d048fedeb", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f96243295a297e8e64e0d7cf9c349f69cd7dcc56/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96243295a297e8e64e0d7cf9c349f69cd7dcc56/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=f96243295a297e8e64e0d7cf9c349f69cd7dcc56", "patch": "@@ -170,7 +170,7 @@ impl IsaacRng {\n         const MIDPOINT: usize = RAND_SIZE_USIZE / 2;\n \n         macro_rules! ind {\n-            ($x:expr) => (self.mem[($x >> 2).0 as usize & (RAND_SIZE_USIZE - 1)] )\n+            ($x:expr) => (self.mem[($x >> 2u32).0 as usize & (RAND_SIZE_USIZE - 1)] )\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n@@ -452,7 +452,7 @@ impl Isaac64Rng {\n         const MP_VEC: [(usize, usize); 2] = [(0, MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n             ($x:expr) => {\n-                *self.mem.get_unchecked((($x >> 3).0 as usize) & (RAND_SIZE_64 - 1))\n+                *self.mem.get_unchecked((($x >> 3u32).0 as usize) & (RAND_SIZE_64 - 1))\n             }\n         }\n \n@@ -495,10 +495,10 @@ impl Isaac64Rng {\n                     }}\n                 }\n \n-                rngstepp!(0, 21);\n-                rngstepn!(1, 5);\n-                rngstepp!(2, 12);\n-                rngstepn!(3, 33);\n+                rngstepp!(0, 21u32);\n+                rngstepn!(1, 5u32);\n+                rngstepp!(2, 12u32);\n+                rngstepn!(3, 33u32);\n             }\n         }\n "}, {"sha": "398b400aac6cf3c046da12f354bc48d884d403a9", "filename": "src/test/run-pass/num-wrapping.rs", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/f96243295a297e8e64e0d7cf9c349f69cd7dcc56/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96243295a297e8e64e0d7cf9c349f69cd7dcc56/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs?ref=f96243295a297e8e64e0d7cf9c349f69cd7dcc56", "patch": "@@ -0,0 +1,405 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// compile-flags: -C debug-assertions\n+//\n+// Test std::num::Wrapping<T> for {uN, iN, usize, isize}\n+\n+#![feature(op_assign_traits, num_bits_bytes)]\n+\n+use std::num::Wrapping;\n+use std::ops::{\n+    Add, Sub, Mul, Div, Rem, BitXor, BitOr, BitAnd,\n+    AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitXorAssign, BitOrAssign, BitAndAssign,\n+    Shl, Shr, ShlAssign, ShrAssign\n+};\n+use std::{i8, i16, i32, i64, isize, u8, u16, u32, u64, usize};\n+\n+use std::test::black_box;\n+\n+fn main() {\n+    test_ops();\n+    test_op_assigns();\n+    test_sh_ops();\n+    test_sh_op_assigns();\n+}\n+\n+fn test_ops() {\n+    macro_rules! op_test {\n+        ($op:ident ($lhs:expr, $rhs:expr) == $ans:expr) => {\n+            assert_eq!(black_box(Wrapping($lhs).$op(Wrapping($rhs))), Wrapping($ans));\n+            assert_eq!(black_box(Wrapping($lhs).$op($rhs)), Wrapping($ans));\n+        }\n+    }\n+\n+    op_test!(add(i8::MAX, 1) == i8::MIN);\n+    op_test!(add(i16::MAX, 1) == i16::MIN);\n+    op_test!(add(i32::MAX, 1) == i32::MIN);\n+    op_test!(add(i64::MAX, 1) == i64::MIN);\n+    op_test!(add(isize::MAX, 1) == isize::MIN);\n+\n+    op_test!(add(u8::MAX, 1) == 0);\n+    op_test!(add(u16::MAX, 1) == 0);\n+    op_test!(add(u32::MAX, 1) == 0);\n+    op_test!(add(u64::MAX, 1) == 0);\n+    op_test!(add(usize::MAX, 1) == 0);\n+\n+\n+    op_test!(sub(i8::MIN, 1) == i8::MAX);\n+    op_test!(sub(i16::MIN, 1) == i16::MAX);\n+    op_test!(sub(i32::MIN, 1) == i32::MAX);\n+    op_test!(sub(i64::MIN, 1) == i64::MAX);\n+    op_test!(sub(isize::MIN, 1) == isize::MAX);\n+\n+    op_test!(sub(0u8, 1) == u8::MAX);\n+    op_test!(sub(0u16, 1) == u16::MAX);\n+    op_test!(sub(0u32, 1) == u32::MAX);\n+    op_test!(sub(0u64, 1) == u64::MAX);\n+    op_test!(sub(0usize, 1) == usize::MAX);\n+\n+\n+    op_test!(mul(i8::MAX, 2) == -2);\n+    op_test!(mul(i16::MAX, 2) == -2);\n+    op_test!(mul(i32::MAX, 2) == -2);\n+    op_test!(mul(i64::MAX, 2) == -2);\n+    op_test!(mul(isize::MAX, 2) == -2);\n+\n+    op_test!(mul(u8::MAX, 2) == u8::MAX - 1);\n+    op_test!(mul(u16::MAX, 2) == u16::MAX - 1);\n+    op_test!(mul(u32::MAX, 2) == u32::MAX - 1);\n+    op_test!(mul(u64::MAX, 2) == u64::MAX - 1);\n+    op_test!(mul(usize::MAX, 2) == usize::MAX - 1);\n+\n+\n+    op_test!(div(i8::MIN, -1) == i8::MIN);\n+    op_test!(div(i16::MIN, -1) == i16::MIN);\n+    op_test!(div(i32::MIN, -1) == i32::MIN);\n+    op_test!(div(i64::MIN, -1) == i64::MIN);\n+    op_test!(div(isize::MIN, -1) == isize::MIN);\n+\n+\n+    op_test!(rem(i8::MIN, -1) == 0);\n+    op_test!(rem(i16::MIN, -1) == 0);\n+    op_test!(rem(i32::MIN, -1) == 0);\n+    op_test!(rem(i64::MIN, -1) == 0);\n+    op_test!(rem(isize::MIN, -1) == 0);\n+\n+    // these are not that interesting, just testing to make sure they are implemented correctly\n+    op_test!(bitxor(0b101010i8, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010i16, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010i32, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010i64, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010isize, 0b100110) == 0b001100);\n+\n+    op_test!(bitxor(0b101010u8, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010u16, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010u32, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010u64, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010usize, 0b100110) == 0b001100);\n+\n+\n+    op_test!(bitor(0b101010i8, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010i16, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010i32, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010i64, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010isize, 0b100110) == 0b101110);\n+\n+    op_test!(bitor(0b101010u8, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010u16, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010u32, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010u64, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010usize, 0b100110) == 0b101110);\n+\n+\n+    op_test!(bitand(0b101010i8, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010i16, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010i32, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010i64, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010isize, 0b100110) == 0b100010);\n+\n+    op_test!(bitand(0b101010u8, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010u16, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010u32, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010u64, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010usize, 0b100110) == 0b100010);\n+}\n+\n+fn test_op_assigns() {\n+    macro_rules! op_assign_test {\n+        ($op:ident ($initial:expr, $rhs:expr) == $ans:expr) => {\n+            {\n+                let mut tmp = Wrapping($initial);\n+                tmp = black_box(tmp);\n+                tmp.$op(Wrapping($rhs));\n+                assert_eq!(black_box(tmp), Wrapping($ans));\n+            }\n+            {\n+                let mut tmp = Wrapping($initial);\n+                tmp = black_box(tmp);\n+                tmp.$op($rhs);\n+                assert_eq!(black_box(tmp), Wrapping($ans));\n+            }\n+        }\n+    }\n+    op_assign_test!(add_assign(i8::MAX, 1) == i8::MIN);\n+    op_assign_test!(add_assign(i16::MAX, 1) == i16::MIN);\n+    op_assign_test!(add_assign(i32::MAX, 1) == i32::MIN);\n+    op_assign_test!(add_assign(i64::MAX, 1) == i64::MIN);\n+    op_assign_test!(add_assign(isize::MAX, 1) == isize::MIN);\n+\n+    op_assign_test!(add_assign(u8::MAX, 1) == u8::MIN);\n+    op_assign_test!(add_assign(u16::MAX, 1) == u16::MIN);\n+    op_assign_test!(add_assign(u32::MAX, 1) == u32::MIN);\n+    op_assign_test!(add_assign(u64::MAX, 1) == u64::MIN);\n+    op_assign_test!(add_assign(usize::MAX, 1) == usize::MIN);\n+\n+\n+    op_assign_test!(sub_assign(i8::MIN, 1) == i8::MAX);\n+    op_assign_test!(sub_assign(i16::MIN, 1) == i16::MAX);\n+    op_assign_test!(sub_assign(i32::MIN, 1) == i32::MAX);\n+    op_assign_test!(sub_assign(i64::MIN, 1) == i64::MAX);\n+    op_assign_test!(sub_assign(isize::MIN, 1) == isize::MAX);\n+\n+    op_assign_test!(sub_assign(u8::MIN, 1) == u8::MAX);\n+    op_assign_test!(sub_assign(u16::MIN, 1) == u16::MAX);\n+    op_assign_test!(sub_assign(u32::MIN, 1) == u32::MAX);\n+    op_assign_test!(sub_assign(u64::MIN, 1) == u64::MAX);\n+    op_assign_test!(sub_assign(usize::MIN, 1) == usize::MAX);\n+\n+\n+    op_assign_test!(mul_assign(i8::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(i16::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(i32::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(i64::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(isize::MAX, 2) == -2);\n+\n+    op_assign_test!(mul_assign(u8::MAX, 2) == u8::MAX - 1);\n+    op_assign_test!(mul_assign(u16::MAX, 2) == u16::MAX - 1);\n+    op_assign_test!(mul_assign(u32::MAX, 2) == u32::MAX - 1);\n+    op_assign_test!(mul_assign(u64::MAX, 2) == u64::MAX - 1);\n+    op_assign_test!(mul_assign(usize::MAX, 2) == usize::MAX - 1);\n+\n+\n+    op_assign_test!(div_assign(i8::MIN, -1) == i8::MIN);\n+    op_assign_test!(div_assign(i16::MIN, -1) == i16::MIN);\n+    op_assign_test!(div_assign(i32::MIN, -1) == i32::MIN);\n+    op_assign_test!(div_assign(i64::MIN, -1) == i64::MIN);\n+    op_assign_test!(div_assign(isize::MIN, -1) == isize::MIN);\n+\n+\n+    op_assign_test!(rem_assign(i8::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(i16::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(i32::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(i64::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(isize::MIN, -1) == 0);\n+\n+\n+    // these are not that interesting, just testing to make sure they are implemented correctly\n+    op_assign_test!(bitxor_assign(0b101010i8, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010i16, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010i32, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010i64, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010isize, 0b100110) == 0b001100);\n+\n+    op_assign_test!(bitxor_assign(0b101010u8, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010u16, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010u32, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010u64, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010usize, 0b100110) == 0b001100);\n+\n+\n+    op_assign_test!(bitor_assign(0b101010i8, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010i16, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010i32, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010i64, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010isize, 0b100110) == 0b101110);\n+\n+    op_assign_test!(bitor_assign(0b101010u8, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010u16, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010u32, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010u64, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010usize, 0b100110) == 0b101110);\n+\n+\n+    op_assign_test!(bitand_assign(0b101010i8, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010i16, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010i32, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010i64, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010isize, 0b100110) == 0b100010);\n+\n+    op_assign_test!(bitand_assign(0b101010u8, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010u16, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010u32, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010u64, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010usize, 0b100110) == 0b100010);\n+}\n+\n+fn test_sh_ops() {\n+    macro_rules! sh_test {\n+        ($op:ident ($lhs:expr, $rhs:expr) == $ans:expr) => {\n+            assert_eq!(black_box(Wrapping($lhs).$op($rhs)), Wrapping($ans));\n+        }\n+    }\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as u8) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as u8) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as u8) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as u8) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as u8) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as i8) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as i8) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as i8) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as i8) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as i8) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as i16) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as i16) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as i16) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as i16) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as i16) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as i16) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as i16) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as i16) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as i16) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as i16) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as u16) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as u16) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as u16) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as u16) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as u16) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as u16) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as u16) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as u16) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as u16) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as u16) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as i32) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as i32) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as i32) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as i32) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as i32) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as i32) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as i32) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as i32) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as i32) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as i32) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as u32) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as u32) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as u32) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as u32) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as u32) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as u32) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as u32) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as u32) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as u32) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as u32) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as i64) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as i64) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as i64) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as i64) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as i64) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as i64) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as i64) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as i64) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as i64) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as i64) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as u64) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as u64) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as u64) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as u64) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as u64) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as u64) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as u64) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as u64) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as u64) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as u64) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as isize) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as isize) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as isize) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as isize) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as isize) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as isize) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as isize) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as isize) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as isize) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as isize) == usize::MAX - 1);\n+\n+    sh_test!(shl(i8::MAX, (i8::BITS + 1) as usize) == -2);\n+    sh_test!(shl(i16::MAX, (i16::BITS + 1) as usize) == -2);\n+    sh_test!(shl(i32::MAX, (i32::BITS + 1) as usize) == -2);\n+    sh_test!(shl(i64::MAX, (i64::BITS + 1) as usize) == -2);\n+    sh_test!(shl(isize::MAX, (isize::BITS + 1) as usize) == -2);\n+\n+    sh_test!(shl(u8::MAX, (u8::BITS + 1) as usize) == u8::MAX - 1);\n+    sh_test!(shl(u16::MAX, (u16::BITS + 1) as usize) == u16::MAX - 1);\n+    sh_test!(shl(u32::MAX, (u32::BITS + 1) as usize) == u32::MAX - 1);\n+    sh_test!(shl(u64::MAX, (u64::BITS + 1) as usize) == u64::MAX - 1);\n+    sh_test!(shl(usize::MAX, (usize::BITS + 1) as usize) == usize::MAX - 1);\n+\n+\n+    sh_test!(shr(i8::MAX, i8::BITS + 1) == i8::MAX / 2);\n+    sh_test!(shr(i16::MAX, i16::BITS + 1) == i16::MAX / 2);\n+    sh_test!(shr(i32::MAX, i32::BITS + 1) == i32::MAX / 2);\n+    sh_test!(shr(i64::MAX, i64::BITS + 1) == i64::MAX / 2);\n+    sh_test!(shr(isize::MAX, isize::BITS + 1) == isize::MAX / 2);\n+\n+    sh_test!(shr(u8::MAX, u8::BITS + 1) == u8::MAX / 2);\n+    sh_test!(shr(u16::MAX, u16::BITS + 1) == u16::MAX / 2);\n+    sh_test!(shr(u32::MAX, u32::BITS + 1) == u32::MAX / 2);\n+    sh_test!(shr(u64::MAX, u64::BITS + 1) == u64::MAX / 2);\n+    sh_test!(shr(usize::MAX, usize::BITS + 1) == usize::MAX / 2);\n+}\n+\n+fn test_sh_op_assigns() {\n+    macro_rules! sh_assign_test {\n+        ($op:ident ($initial:expr, $rhs:expr) == $ans:expr) => {{\n+            let mut tmp = Wrapping($initial);\n+            tmp = black_box(tmp);\n+            tmp.$op($rhs);\n+            assert_eq!(black_box(tmp), Wrapping($ans));\n+        }}\n+    }\n+    sh_assign_test!(shl_assign(i8::MAX, i8::BITS + 1) == -2);\n+    sh_assign_test!(shl_assign(i16::MAX, i16::BITS + 1) == -2);\n+    sh_assign_test!(shl_assign(i32::MAX, i32::BITS + 1) == -2);\n+    sh_assign_test!(shl_assign(i64::MAX, i64::BITS + 1) == -2);\n+    sh_assign_test!(shl_assign(isize::MAX, isize::BITS + 1) == -2);\n+\n+    sh_assign_test!(shl_assign(u8::MAX, u8::BITS + 1) == u8::MAX - 1);\n+    sh_assign_test!(shl_assign(u16::MAX, u16::BITS + 1) == u16::MAX - 1);\n+    sh_assign_test!(shl_assign(u32::MAX, u32::BITS + 1) == u32::MAX - 1);\n+    sh_assign_test!(shl_assign(u64::MAX, u64::BITS + 1) == u64::MAX - 1);\n+    sh_assign_test!(shl_assign(usize::MAX, usize::BITS + 1) == usize::MAX - 1);\n+\n+\n+    sh_assign_test!(shr_assign(i8::MAX, i8::BITS + 1) == i8::MAX / 2);\n+    sh_assign_test!(shr_assign(i16::MAX, i16::BITS + 1) == i16::MAX / 2);\n+    sh_assign_test!(shr_assign(i32::MAX, i32::BITS + 1) == i32::MAX / 2);\n+    sh_assign_test!(shr_assign(i64::MAX, i64::BITS + 1) == i64::MAX / 2);\n+    sh_assign_test!(shr_assign(isize::MAX, isize::BITS + 1) == isize::MAX / 2);\n+\n+    sh_assign_test!(shr_assign(u8::MAX, u8::BITS + 1) == u8::MAX / 2);\n+    sh_assign_test!(shr_assign(u16::MAX, u16::BITS + 1) == u16::MAX / 2);\n+    sh_assign_test!(shr_assign(u32::MAX, u32::BITS + 1) == u32::MAX / 2);\n+    sh_assign_test!(shr_assign(u64::MAX, u64::BITS + 1) == u64::MAX / 2);\n+    sh_assign_test!(shr_assign(usize::MAX, usize::BITS + 1) == usize::MAX / 2);\n+}"}]}