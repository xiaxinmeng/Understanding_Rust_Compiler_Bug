{"sha": "1a7db7892d081b03ca63d98969734dfeb7c48c9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhN2RiNzg5MmQwODFiMDNjYTYzZDk4OTY5NzM0ZGZlYjdjNDhjOWY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-06T10:55:15Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-06T10:55:15Z"}, "message": "Merge pull request #302 from Manishearth/macro\n\nMore strict macro check", "tree": {"sha": "8ad9cfb466aecded81cb8761570638c52693bd56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ad9cfb466aecded81cb8761570638c52693bd56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a7db7892d081b03ca63d98969734dfeb7c48c9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7db7892d081b03ca63d98969734dfeb7c48c9f", "html_url": "https://github.com/rust-lang/rust/commit/1a7db7892d081b03ca63d98969734dfeb7c48c9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a7db7892d081b03ca63d98969734dfeb7c48c9f/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9ecd0b9652fee465da0de13792156e1feaa0378", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9ecd0b9652fee465da0de13792156e1feaa0378", "html_url": "https://github.com/rust-lang/rust/commit/d9ecd0b9652fee465da0de13792156e1feaa0378"}, {"sha": "55729b7caabca9ceac7a920ff09f0c80dc081d0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/55729b7caabca9ceac7a920ff09f0c80dc081d0a", "html_url": "https://github.com/rust-lang/rust/commit/55729b7caabca9ceac7a920ff09f0c80dc081d0a"}], "stats": {"total": 162, "additions": 81, "deletions": 81}, "files": [{"sha": "e6185d8b400fd6ee7480e1b2574289c419ceda13", "filename": "src/attrs.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=1a7db7892d081b03ca63d98969734dfeb7c48c9f", "patch": "@@ -3,7 +3,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use reexport::*;\n-use syntax::codemap::ExpnInfo;\n+use syntax::codemap::Span;\n \n use utils::{in_macro, match_path, span_lint};\n \n@@ -21,22 +21,19 @@ impl LintPass for AttrPass {\n \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n         if is_relevant_item(item) {\n-            cx.sess().codemap().with_expn_info(item.span.expn_id,\n-                |info| check_attrs(cx, info, &item.ident, &item.attrs))\n+            check_attrs(cx, item.span, &item.ident, &item.attrs)\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n         if is_relevant_impl(item) {\n-            cx.sess().codemap().with_expn_info(item.span.expn_id,\n-                |info| check_attrs(cx, info, &item.ident, &item.attrs))\n+            check_attrs(cx, item.span, &item.ident, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n         if is_relevant_trait(item) {\n-            cx.sess().codemap().with_expn_info(item.span.expn_id,\n-                |info| check_attrs(cx, info, &item.ident, &item.attrs))\n+            check_attrs(cx, item.span, &item.ident, &item.attrs)\n         }\n     }\n }\n@@ -89,9 +86,9 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n     }\n }\n \n-fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n-               attrs: &[Attribute]) {\n-    if in_macro(cx, info) { return; }\n+fn check_attrs(cx: &Context, span: Span, ident: &Ident,\n+        attrs: &[Attribute]) {\n+    if in_macro(cx, span) { return; }\n \n     for attr in attrs {\n         if let MetaList(ref inline, ref values) = attr.node.value.node {"}, {"sha": "7326bd20c7cdbb86adefa7a8aa4dd4fed8ea403c", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=1a7db7892d081b03ca63d98969734dfeb7c48c9f", "patch": "@@ -14,7 +14,7 @@\n \n use rustc::lint::*;\n use rustc_front::hir::*;\n-use syntax::codemap::{Spanned, ExpnInfo};\n+use syntax::codemap::Spanned;\n \n use utils::{in_macro, span_help_and_lint, snippet, snippet_block};\n \n@@ -34,14 +34,13 @@ impl LintPass for CollapsibleIf {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        cx.sess().codemap().with_expn_info(expr.span.expn_id,\n-            |info| check_expr_expd(cx, expr, info))\n+\t\tif !in_macro(cx, expr.span) {\n+\t\t\tcheck_if(cx, expr)\n+\t\t}\n     }\n }\n \n-fn check_expr_expd(cx: &Context, e: &Expr, info: Option<&ExpnInfo>) {\n-    if in_macro(cx, info) { return; }\n-\n+fn check_if(cx: &Context, e: &Expr) {\n     if let ExprIf(ref check, ref then, None) = e.node {\n         if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n             single_stmt_of_block(then) {"}, {"sha": "9601a6856904cf910174f6cec6b21ab618c79e64", "filename": "src/identity_op.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=1a7db7892d081b03ca63d98969734dfeb7c48c9f", "patch": "@@ -2,9 +2,9 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n \n-use consts::{constant, is_negative};\n+use consts::{constant_simple, is_negative};\n use consts::Constant::ConstantInt;\n-use utils::{span_lint, snippet, in_external_macro};\n+use utils::{span_lint, snippet, in_macro};\n \n declare_lint! { pub IDENTITY_OP, Warn,\n                 \"using identity operations, e.g. `x + 0` or `y / 1`\" }\n@@ -18,6 +18,7 @@ impl LintPass for IdentityOp {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+        if in_macro(cx, e.span) { return; }\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n                 BiAdd | BiBitOr | BiBitXor => {\n@@ -44,20 +45,16 @@ impl LintPass for IdentityOp {\n \n \n fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some((c, needed_resolution)) = constant(cx, e) {\n-        if needed_resolution { return; } // skip linting w/ lookup for now\n-        if let ConstantInt(v, ty) = c {\n-            if match m {\n-                0 => v == 0,\n-                -1 => is_negative(ty) && v == 1,\n-                1 => !is_negative(ty) && v == 1,\n-                _ => unreachable!(),\n-            } {\n-                if in_external_macro(cx, e.span) {return;}\n-                span_lint(cx, IDENTITY_OP, span, &format!(\n-                    \"the operation is ineffective. Consider reducing it to `{}`\",\n-                   snippet(cx, arg, \"..\")));\n-            }\n+    if let Some(ConstantInt(v, ty)) = constant_simple(e) {\n+        if match m {\n+            0 => v == 0,\n+            -1 => is_negative(ty) && v == 1,\n+            1 => !is_negative(ty) && v == 1,\n+            _ => unreachable!(),\n+        } {\n+            span_lint(cx, IDENTITY_OP, span, &format!(\n+                \"the operation is ineffective. Consider reducing it to `{}`\",\n+               snippet(cx, arg, \"..\")));\n         }\n     }\n }"}, {"sha": "099ff7910acce149dc8226f11062a71b7d5da672", "filename": "src/loops.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=1a7db7892d081b03ca63d98969734dfeb7c48c9f", "patch": "@@ -84,12 +84,11 @@ impl LintPass for LoopsPass {\n                         }\n                     }\n                     // check for looping over Iterator::next() which is not what you want\n-                    else if method_name == \"next\" {\n-                        if match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n-                            span_lint(cx, ITER_NEXT_LOOP, expr.span,\n-                                      \"you are iterating over `Iterator::next()` which is an Option; \\\n-                                       this will compile but is probably not what you want\");\n-                        }\n+                    else if method_name == \"next\" &&\n+                            match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n+                        span_lint(cx, ITER_NEXT_LOOP, expr.span,\n+                                  \"you are iterating over `Iterator::next()` which is an Option; \\\n+                                   this will compile but is probably not what you want\");\n                     }\n                 }\n             }\n@@ -127,12 +126,11 @@ impl LintPass for LoopsPass {\n     fn check_stmt(&mut self, cx: &Context, stmt: &Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.node.name == \"collect\" {\n-                    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n-                        span_lint(cx, UNUSED_COLLECT, expr.span, &format!(\n-                            \"you are collect()ing an iterator and throwing away the result. \\\n-                             Consider using an explicit for loop to exhaust the iterator\"));\n-                    }\n+                if args.len() == 1 && method.node.name == \"collect\" && \n+                        match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+                    span_lint(cx, UNUSED_COLLECT, expr.span, &format!(\n+                        \"you are collect()ing an iterator and throwing away the result. \\\n+                         Consider using an explicit for loop to exhaust the iterator\"));\n                 }\n             }\n         }"}, {"sha": "b6260bb8eccddb4e81672275eddef573cc6ed7df", "filename": "src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=1a7db7892d081b03ca63d98969734dfeb7c48c9f", "patch": "@@ -1,9 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use syntax::codemap::ExpnInfo;\n use rustc::middle::ty::{TypeAndMut, TyRef};\n \n-use utils::{in_macro, span_lint};\n+use utils::{in_external_macro, span_lint};\n \n declare_lint!(pub MUT_MUT, Warn,\n               \"usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, \\\n@@ -18,8 +17,7 @@ impl LintPass for MutMut {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        cx.sess().codemap().with_expn_info(expr.span.expn_id,\n-            |info| check_expr_expd(cx, expr, info))\n+       check_expr_mut(cx, expr)\n     }\n \n     fn check_ty(&mut self, cx: &Context, ty: &Ty) {\n@@ -28,8 +26,8 @@ impl LintPass for MutMut {\n     }\n }\n \n-fn check_expr_expd(cx: &Context, expr: &Expr, info: Option<&ExpnInfo>) {\n-    if in_macro(cx, info) { return; }\n+fn check_expr_mut(cx: &Context, expr: &Expr) {\n+    if in_external_macro(cx, expr.span) { return; }\n \n     fn unwrap_addr(expr : &Expr) -> Option<&Expr> {\n         match expr.node {"}, {"sha": "44c0cd781481b8c1f707d5437a39311417b3c5b8", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=1a7db7892d081b03ca63d98969734dfeb7c48c9f", "patch": "@@ -6,7 +6,7 @@ use syntax::codemap::Span;\n use rustc_front::visit::{FnKind, Visitor, walk_ty};\n use rustc::middle::ty;\n \n-use utils::{match_type, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{match_type, snippet, span_lint, span_help_and_lint, in_macro, in_external_macro};\n use utils::{LL_PATH, VEC_PATH};\n \n /// Handles all the linting of funky types\n@@ -321,7 +321,7 @@ fn check_fndecl(cx: &Context, decl: &FnDecl) {\n }\n \n fn check_type(cx: &Context, ty: &Ty) {\n-    if in_external_macro(cx, ty.span) { return; }\n+    if in_macro(cx, ty.span) { return; }\n     let score = {\n         let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n         visitor.visit_ty(ty);"}, {"sha": "33e53710df31aa9f465800791668b78e5c76d85d", "filename": "src/utils.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7db7892d081b03ca63d98969734dfeb7c48c9f/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=1a7db7892d081b03ca63d98969734dfeb7c48c9f", "patch": "@@ -14,40 +14,51 @@ pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n \n-/// returns true if the macro that expanded the crate was outside of\n-/// the current crate or was a compiler plugin\n-pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n-    // no ExpnInfo = no macro\n-    opt_info.map_or(false, |info| {\n-        match info.callee.format {\n-            ExpnFormat::CompilerExpansion(..) => {\n-                if info.callee.name() == \"closure expansion\" {\n-                    return false;\n-                }\n-            },\n-            ExpnFormat::MacroAttribute(..) => {\n-                // these are all plugins\n-                return true;\n-            },\n-            _ => (),\n+/// returns true this expn_info was expanded by any macro\n+pub fn in_macro(cx: &Context, span: Span) -> bool {\n+    cx.sess().codemap().with_expn_info(span.expn_id,\n+            |info| info.map_or(false, |i| {\n+        match i.callee.format {\n+            ExpnFormat::CompilerExpansion(..) => false,\n+            _ => true,\n         }\n-        // no span for the callee = external macro\n-        info.callee.span.map_or(true, |span| {\n-            // no snippet = external macro or compiler-builtin expansion\n-            cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n-                // macro doesn't start with \"macro_rules\"\n-                // = compiler plugin\n-                !code.starts_with(\"macro_rules\")\n-            )\n-        })\n-    })\n+    }))\n }\n \n-/// invokes in_macro with the expansion info of the given span\n-/// slightly heavy, try to use this after other checks have already happened\n+/// returns true if the macro that expanded the crate was outside of\n+/// the current crate or was a compiler plugin\n pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n+\t/// invokes in_macro with the expansion info of the given span\n+\t/// slightly heavy, try to use this after other checks have already happened\n+\tfn in_macro_ext(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n+\t\t// no ExpnInfo = no macro\n+\t\topt_info.map_or(false, |info| {\n+\t\t\tmatch info.callee.format {\n+\t\t\t\tExpnFormat::CompilerExpansion(..) => {\n+\t\t\t\t\tif info.callee.name() == \"closure expansion\" {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t},\n+\t\t\t\tExpnFormat::MacroAttribute(..) => {\n+\t\t\t\t\t// these are all plugins\n+\t\t\t\t\treturn true;\n+\t\t\t\t},\n+\t\t\t\t_ => (),\n+\t\t\t}\n+\t\t\t// no span for the callee = external macro\n+\t\t\tinfo.callee.span.map_or(true, |span| {\n+\t\t\t\t// no snippet = external macro or compiler-builtin expansion\n+\t\t\t\tcx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n+\t\t\t\t\t// macro doesn't start with \"macro_rules\"\n+\t\t\t\t\t// = compiler plugin\n+\t\t\t\t\t!code.starts_with(\"macro_rules\")\n+\t\t\t\t)\n+\t\t\t})\n+\t\t})\n+\t}\n+\n     cx.sess().codemap().with_expn_info(span.expn_id,\n-            |info| in_macro(cx, info))\n+            |info| in_macro_ext(cx, info))\n }\n \n /// check if a DefId's path matches the given absolute type path"}]}