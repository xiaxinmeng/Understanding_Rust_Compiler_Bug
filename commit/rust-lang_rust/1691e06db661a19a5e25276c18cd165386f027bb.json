{"sha": "1691e06db661a19a5e25276c18cd165386f027bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OTFlMDZkYjY2MWExOWE1ZTI1Mjc2YzE4Y2QxNjUzODZmMDI3YmI=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-03-11T23:56:00Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-04-05T22:03:33Z"}, "message": "Future-proof the Futures API", "tree": {"sha": "8f48fcec3852c14a0df42fc5d795d76d2d39c8d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f48fcec3852c14a0df42fc5d795d76d2d39c8d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1691e06db661a19a5e25276c18cd165386f027bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1691e06db661a19a5e25276c18cd165386f027bb", "html_url": "https://github.com/rust-lang/rust/commit/1691e06db661a19a5e25276c18cd165386f027bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1691e06db661a19a5e25276c18cd165386f027bb/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20dbf28624db446c0cf67be4cc71a85931947907", "url": "https://api.github.com/repos/rust-lang/rust/commits/20dbf28624db446c0cf67be4cc71a85931947907", "html_url": "https://github.com/rust-lang/rust/commit/20dbf28624db446c0cf67be4cc71a85931947907"}], "stats": {"total": 246, "additions": 176, "deletions": 70}, "files": [{"sha": "d75a0c298c27807bc7de39aca7fcb7999177d531", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -81,7 +81,7 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{Waker, Poll};\n+use core::task::{Context, Poll};\n \n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n@@ -914,7 +914,7 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut *self), waker)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), cx)\n     }\n }"}, {"sha": "114a6b9336777087955a11b79380b453209ee2de", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -5,7 +5,7 @@\n use marker::Unpin;\n use ops;\n use pin::Pin;\n-use task::{Poll, Waker};\n+use task::{Context, Poll};\n \n /// A future represents an asynchronous computation.\n ///\n@@ -44,8 +44,9 @@ pub trait Future {\n     /// Once a future has finished, clients should not `poll` it again.\n     ///\n     /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n-    /// stores a clone of the [`Waker`] to be woken once the future can\n-    /// make progress. For example, a future waiting for a socket to become\n+    /// stores a clone of the [`Waker`] copied from the current [`Context`].\n+    /// This [`Waker`] is then woken once the future can make progress.\n+    /// For example, a future waiting for a socket to become\n     /// readable would call `.clone()` on the [`Waker`] and store it.\n     /// When a signal arrives elsewhere indicating that the socket is readable,\n     /// `[Waker::wake]` is called and the socket future's task is awoken.\n@@ -88,16 +89,17 @@ pub trait Future {\n     ///\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n+    /// [`Context`]: ../task/struct.Context.html\n     /// [`Waker`]: ../task/struct.Waker.html\n     /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n-    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output>;\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n }\n \n impl<F: ?Sized + Future + Unpin> Future for &mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut **self), waker)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), cx)\n     }\n }\n \n@@ -108,7 +110,7 @@ where\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(waker)\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(cx)\n     }\n }"}, {"sha": "29bae69ea83c1a2cf5a25bd30102aeb0ea017c7a", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -8,4 +8,4 @@ mod poll;\n pub use self::poll::Poll;\n \n mod wake;\n-pub use self::wake::{Waker, RawWaker, RawWakerVTable};\n+pub use self::wake::{Context, Waker, RawWaker, RawWakerVTable};"}, {"sha": "979a0792608c16d0877318c5bf015fd043a376eb", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 97, "deletions": 4, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -3,7 +3,7 @@\n             issue = \"50547\")]\n \n use fmt;\n-use marker::Unpin;\n+use marker::{PhantomData, Unpin};\n \n /// A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n /// which provides customized wakeup behavior.\n@@ -36,6 +36,10 @@ impl RawWaker {\n     /// The `vtable` customizes the behavior of a `Waker` which gets created\n     /// from a `RawWaker`. For each operation on the `Waker`, the associated\n     /// function in the `vtable` of the underlying `RawWaker` will be called.\n+    #[rustc_promotable]\n+    #[unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n     pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n         RawWaker {\n             data,\n@@ -63,21 +67,105 @@ pub struct RawWakerVTable {\n     /// required for this additional instance of a [`RawWaker`] and associated\n     /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n     /// of the same task that would have been awoken by the original [`RawWaker`].\n-    pub clone: unsafe fn(*const ()) -> RawWaker,\n+    clone: unsafe fn(*const ()) -> RawWaker,\n \n     /// This function will be called when `wake` is called on the [`Waker`].\n     /// It must wake up the task associated with this [`RawWaker`].\n     ///\n     /// The implemention of this function must not consume the provided data\n     /// pointer.\n-    pub wake: unsafe fn(*const ()),\n+    wake: unsafe fn(*const ()),\n+\n+    /// This function gets called when a [`RawWaker`] gets dropped.\n+    ///\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n+    drop: unsafe fn(*const ()),\n+}\n \n+impl RawWakerVTable {\n+    /// Creates a new `RawWakerVTable` from the provided `clone`, `wake`, and\n+    /// `drop` functions.\n+    ///\n+    /// # `clone`\n+    ///\n+    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n+    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n+    ///\n+    /// The implementation of this function must retain all resources that are\n+    /// required for this additional instance of a [`RawWaker`] and associated\n+    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n+    /// of the same task that would have been awoken by the original [`RawWaker`].\n+    ///\n+    /// # `wake`\n+    ///\n+    /// This function will be called when `wake` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// The implemention of this function must not consume the provided data\n+    /// pointer.\n+    ///\n+    /// # `drop`\n+    ///\n     /// This function gets called when a [`RawWaker`] gets dropped.\n     ///\n     /// The implementation of this function must make sure to release any\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n-    pub drop: unsafe fn(*const ()),\n+    #[rustc_promotable]\n+    #[unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+    pub const fn new(\n+        clone: unsafe fn(*const ()) -> RawWaker,\n+        wake: unsafe fn(*const ()),\n+        drop: unsafe fn(*const ()),\n+    ) -> Self {\n+        Self {\n+            clone,\n+            wake,\n+            drop,\n+        }\n+    }\n+}\n+\n+/// The `Context` of an asynchronous task.\n+///\n+/// Currently, `Context` only serves to provide access to a `&Waker`\n+/// which can be used to wake the current task.\n+pub struct Context<'a> {\n+    waker: &'a Waker,\n+    // Ensure we future-proof against variance changes by forcing\n+    // the lifetime to be invariant (argument-position lifetimes\n+    // are contravariant while return-position lifetimes are\n+    // covariant).\n+    _marker: PhantomData<fn(&'a ()) -> &'a ()>,\n+}\n+\n+impl<'a> Context<'a> {\n+    /// Create a new `Context` from a `&Waker`.\n+    #[inline]\n+    pub fn from_waker(waker: &'a Waker) -> Self {\n+        Context {\n+            waker,\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Returns a reference to the `Waker` for the current task.\n+    #[inline]\n+    pub fn waker(&self) -> &'a Waker {\n+        &self.waker\n+    }\n+}\n+\n+impl fmt::Debug for Context<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Context\")\n+            .field(\"waker\", &self.waker)\n+            .finish()\n+    }\n }\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n@@ -98,6 +186,7 @@ unsafe impl Sync for Waker {}\n \n impl Waker {\n     /// Wake up the task associated with this `Waker`.\n+    #[inline]\n     pub fn wake(&self) {\n         // The actual wakeup call is delegated through a virtual function call\n         // to the implementation which is defined by the executor.\n@@ -115,6 +204,7 @@ impl Waker {\n     /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n     ///\n     /// This function is primarily used for optimization purposes.\n+    #[inline]\n     pub fn will_wake(&self, other: &Waker) -> bool {\n         self.waker == other.waker\n     }\n@@ -124,6 +214,7 @@ impl Waker {\n     /// The behavior of the returned `Waker` is undefined if the contract defined\n     /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n     /// Therefore this method is unsafe.\n+    #[inline]\n     pub unsafe fn new_unchecked(waker: RawWaker) -> Waker {\n         Waker {\n             waker,\n@@ -132,6 +223,7 @@ impl Waker {\n }\n \n impl Clone for Waker {\n+    #[inline]\n     fn clone(&self) -> Self {\n         Waker {\n             // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n@@ -143,6 +235,7 @@ impl Clone for Waker {\n }\n \n impl Drop for Waker {\n+    #[inline]\n     fn drop(&mut self) {\n         // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n         // to initialize `drop` and `data` requiring the user to acknowledge"}, {"sha": "898387cb9f56ddad52843c7e83c064eb2091a79a", "filename": "src/libstd/future.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -5,7 +5,7 @@ use core::marker::Unpin;\n use core::pin::Pin;\n use core::option::Option;\n use core::ptr::NonNull;\n-use core::task::{Waker, Poll};\n+use core::task::{Context, Poll};\n use core::ops::{Drop, Generator, GeneratorState};\n \n #[doc(inline)]\n@@ -32,72 +32,83 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n-    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         // Safe because we're !Unpin + !Drop mapping to a ?Unpin value\n         let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n-        set_task_waker(waker, || match gen.resume() {\n+        set_task_context(cx, || match gen.resume() {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })\n     }\n }\n \n thread_local! {\n-    static TLS_WAKER: Cell<Option<NonNull<Waker>>> = Cell::new(None);\n+    static TLS_CX: Cell<Option<NonNull<Context<'static>>>> = Cell::new(None);\n }\n \n-struct SetOnDrop(Option<NonNull<Waker>>);\n+struct SetOnDrop(Option<NonNull<Context<'static>>>);\n \n impl Drop for SetOnDrop {\n     fn drop(&mut self) {\n-        TLS_WAKER.with(|tls_waker| {\n-            tls_waker.set(self.0.take());\n+        TLS_CX.with(|tls_cx| {\n+            tls_cx.set(self.0.take());\n         });\n     }\n }\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Sets the thread-local task context used by async/await futures.\n-pub fn set_task_waker<F, R>(waker: &Waker, f: F) -> R\n+pub fn set_task_context<F, R>(cx: &mut Context<'_>, f: F) -> R\n where\n     F: FnOnce() -> R\n {\n-    let old_waker = TLS_WAKER.with(|tls_waker| {\n-        tls_waker.replace(Some(NonNull::from(waker)))\n+    // transmute the context's lifetime to 'static so we can store it.\n+    let cx = unsafe {\n+        core::mem::transmute::<&mut Context<'_>, &mut Context<'static>>(cx)\n+    };\n+    let old_cx = TLS_CX.with(|tls_cx| {\n+        tls_cx.replace(Some(NonNull::from(cx)))\n     });\n-    let _reset_waker = SetOnDrop(old_waker);\n+    let _reset = SetOnDrop(old_cx);\n     f()\n }\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n-/// Retrieves the thread-local task waker used by async/await futures.\n+/// Retrieves the thread-local task context used by async/await futures.\n ///\n-/// This function acquires exclusive access to the task waker.\n+/// This function acquires exclusive access to the task context.\n ///\n-/// Panics if no waker has been set or if the waker has already been\n-/// retrieved by a surrounding call to get_task_waker.\n-pub fn get_task_waker<F, R>(f: F) -> R\n+/// Panics if no context has been set or if the context has already been\n+/// retrieved by a surrounding call to get_task_context.\n+pub fn get_task_context<F, R>(f: F) -> R\n where\n-    F: FnOnce(&Waker) -> R\n+    F: FnOnce(&mut Context<'_>) -> R\n {\n-    let waker_ptr = TLS_WAKER.with(|tls_waker| {\n+    let cx_ptr = TLS_CX.with(|tls_cx| {\n         // Clear the entry so that nested `get_task_waker` calls\n         // will fail or set their own value.\n-        tls_waker.replace(None)\n+        tls_cx.replace(None)\n     });\n-    let _reset_waker = SetOnDrop(waker_ptr);\n+    let _reset = SetOnDrop(cx_ptr);\n \n-    let waker_ptr = waker_ptr.expect(\n-        \"TLS Waker not set. This is a rustc bug. \\\n+    let mut cx_ptr = cx_ptr.expect(\n+        \"TLS Context not set. This is a rustc bug. \\\n         Please file an issue on https://github.com/rust-lang/rust.\");\n-    unsafe { f(waker_ptr.as_ref()) }\n+\n+    // Safety: we've ensured exclusive access to the context by\n+    // removing the pointer from TLS, only to be replaced once\n+    // we're done with it.\n+    //\n+    // The pointer that was inserted came from an `&mut Context<'_>`,\n+    // so it is safe to treat as mutable.\n+    unsafe { f(cx_ptr.as_mut()) }\n }\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Polls a future in the current thread-local task waker.\n-pub fn poll_with_tls_waker<F>(f: Pin<&mut F>) -> Poll<F::Output>\n+pub fn poll_with_tls_context<F>(f: Pin<&mut F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_waker(|waker| F::poll(f, waker))\n+    get_task_context(|cx| F::poll(f, cx))\n }"}, {"sha": "44ca56e261152bd07459fa0a57946af8d8c90284", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -346,7 +346,7 @@ macro_rules! r#await {\n         let mut pinned = $e;\n         loop {\n             if let $crate::task::Poll::Ready(x) =\n-                $crate::future::poll_with_tls_waker(unsafe {\n+                $crate::future::poll_with_tls_context(unsafe {\n                     $crate::pin::Pin::new_unchecked(&mut pinned)\n                 })\n             {"}, {"sha": "5a8101e2301198f856235370c9651181431624c0", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -12,7 +12,7 @@ use crate::panicking;\n use crate::ptr::{Unique, NonNull};\n use crate::rc::Rc;\n use crate::sync::{Arc, Mutex, RwLock, atomic};\n-use crate::task::{Waker, Poll};\n+use crate::task::{Context, Poll};\n use crate::thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n@@ -323,9 +323,9 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n impl<F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n \n-    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n-        F::poll(pinned_field, waker)\n+        F::poll(pinned_field, cx)\n     }\n }\n "}, {"sha": "503b39e181ab7ca462944d7b224b29e340b810e9", "filename": "src/test/compile-fail/must_use-in-stdlib-traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -4,7 +4,7 @@\n use std::iter::Iterator;\n use std::future::Future;\n \n-use std::task::{Poll, Waker};\n+use std::task::{Context, Poll};\n use std::pin::Pin;\n use std::unimplemented;\n \n@@ -13,7 +13,7 @@ struct MyFuture;\n impl Future for MyFuture {\n    type Output = u32;\n \n-   fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<u32> {\n+   fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<u32> {\n       Poll::Pending\n    }\n }"}, {"sha": "4f5f7724ad076d4612254ce1db243b6f4f7aa9d6", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n // aux-build:arc_wake.rs\n \n-#![feature(arbitrary_self_types, async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro, futures_api)]\n \n extern crate arc_wake;\n \n@@ -11,9 +11,7 @@ use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n-use std::task::{\n-    Poll, Waker,\n-};\n+use std::task::{Context, Poll};\n use arc_wake::ArcWake;\n \n struct Counter {\n@@ -32,11 +30,11 @@ fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n \n impl Future for WakeOnceThenComplete {\n     type Output = ();\n-    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<()> {\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n-            waker.wake();\n+            cx.waker().wake();\n             self.0 = true;\n             Poll::Pending\n         }\n@@ -146,10 +144,11 @@ where\n     let mut fut = Box::pin(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n     let waker = ArcWake::into_waker(counter.clone());\n+    let mut cx = Context::from_waker(&waker);\n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Pending, fut.as_mut().poll(&waker));\n+    assert_eq!(Poll::Pending, fut.as_mut().poll(&mut cx));\n     assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Ready(9), fut.as_mut().poll(&waker));\n+    assert_eq!(Poll::Ready(9), fut.as_mut().poll(&mut cx));\n }\n \n fn main() {"}, {"sha": "74ec56f55171aa55b644f2e3581cf2f2d6a2a7c5", "filename": "src/test/run-pass/auxiliary/arc_wake.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -1,19 +1,19 @@\n // edition:2018\n \n-#![feature(arbitrary_self_types, futures_api)]\n+#![feature(futures_api)]\n \n use std::sync::Arc;\n use std::task::{\n-    Poll, Waker, RawWaker, RawWakerVTable,\n+    Waker, RawWaker, RawWakerVTable,\n };\n \n macro_rules! waker_vtable {\n     ($ty:ident) => {\n-        &RawWakerVTable {\n-            clone: clone_arc_raw::<$ty>,\n-            drop: drop_arc_raw::<$ty>,\n-            wake: wake_arc_raw::<$ty>,\n-        }\n+        &RawWakerVTable::new(\n+            clone_arc_raw::<$ty>,\n+            wake_arc_raw::<$ty>,\n+            drop_arc_raw::<$ty>,\n+        )\n     };\n }\n "}, {"sha": "5d0b0db510f41b052d9cf95c2fb46758f2ae52c2", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1691e06db661a19a5e25276c18cd165386f027bb/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=1691e06db661a19a5e25276c18cd165386f027bb", "patch": "@@ -1,7 +1,6 @@\n // aux-build:arc_wake.rs\n \n-#![feature(arbitrary_self_types, futures_api)]\n-#![allow(unused)]\n+#![feature(futures_api)]\n \n extern crate arc_wake;\n \n@@ -12,7 +11,7 @@ use std::sync::{\n     atomic::{self, AtomicUsize},\n };\n use std::task::{\n-    Poll, Waker,\n+    Context, Poll,\n };\n use arc_wake::ArcWake;\n \n@@ -30,8 +29,9 @@ struct MyFuture;\n \n impl Future for MyFuture {\n     type Output = ();\n-    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         // Wake twice\n+        let waker = cx.waker();\n         waker.wake();\n         waker.wake();\n         Poll::Ready(())\n@@ -44,10 +44,11 @@ fn test_waker() {\n     });\n     let waker = ArcWake::into_waker(counter.clone());\n     assert_eq!(2, Arc::strong_count(&counter));\n-\n-    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n-    assert_eq!(2, counter.wakes.load(atomic::Ordering::SeqCst));\n-\n+    {\n+        let mut context = Context::from_waker(&waker);\n+        assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&mut context));\n+        assert_eq!(2, counter.wakes.load(atomic::Ordering::SeqCst));\n+    }\n     drop(waker);\n     assert_eq!(1, Arc::strong_count(&counter));\n }"}]}