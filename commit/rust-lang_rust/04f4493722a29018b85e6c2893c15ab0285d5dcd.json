{"sha": "04f4493722a29018b85e6c2893c15ab0285d5dcd", "node_id": "C_kwDOAAsO6NoAKDA0ZjQ0OTM3MjJhMjkwMThiODVlNmMyODkzYzE1YWIwMjg1ZDVkY2Q", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-03T01:31:51Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-12T00:34:35Z"}, "message": "rustdoc-search: simplify JS in `checkGenerics`", "tree": {"sha": "8f4e1cdeabae7a727bc7607d3e2eaaf8ad22f0a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f4e1cdeabae7a727bc7607d3e2eaaf8ad22f0a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04f4493722a29018b85e6c2893c15ab0285d5dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04f4493722a29018b85e6c2893c15ab0285d5dcd", "html_url": "https://github.com/rust-lang/rust/commit/04f4493722a29018b85e6c2893c15ab0285d5dcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04f4493722a29018b85e6c2893c15ab0285d5dcd/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37998ab508d5d9fa0d465d7b535dc673087dda8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/37998ab508d5d9fa0d465d7b535dc673087dda8f", "html_url": "https://github.com/rust-lang/rust/commit/37998ab508d5d9fa0d465d7b535dc673087dda8f"}], "stats": {"total": 136, "additions": 68, "deletions": 68}, "files": [{"sha": "50d5d95909f83e6ba6bc3e33fa6654c53a5deb71", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/04f4493722a29018b85e6c2893c15ab0285d5dcd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/04f4493722a29018b85e6c2893c15ab0285d5dcd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=04f4493722a29018b85e6c2893c15ab0285d5dcd", "patch": "@@ -1179,7 +1179,7 @@ function initSearch(rawSearchIndex) {\n \n         /**\n          * This function checks if the object (`row`) generics match the given type (`elem`)\n-         * generics. If there are no generics on `row`, `defaultDistance` is returned.\n+         * generics.\n          *\n          * @param {Row} row                 - The object to check.\n          * @param {QueryElement} elem       - The element from the parsed query.\n@@ -1196,82 +1196,82 @@ function initSearch(rawSearchIndex) {\n             // This search engine implements order-agnostic unification. There\n             // should be no missing duplicates (generics have \"bag semantics\"),\n             // and the row is allowed to have extras.\n-            if (elem.generics.length > 0 && row.generics.length >= elem.generics.length) {\n-                const elems = new Map();\n-                const addEntryToElems = function addEntryToElems(entry) {\n-                    if (entry.id === -1) {\n-                        // Pure generic, needs to check into it.\n-                        for (const inner_entry of entry.generics) {\n-                            addEntryToElems(inner_entry);\n-                        }\n-                        return;\n-                    }\n-                    let currentEntryElems;\n-                    if (elems.has(entry.id)) {\n-                        currentEntryElems = elems.get(entry.id);\n-                    } else {\n-                        currentEntryElems = [];\n-                        elems.set(entry.id, currentEntryElems);\n+            if (elem.generics.length <= 0 || row.generics.length < elem.generics.length) {\n+                return false;\n+            }\n+            const elems = new Map();\n+            const addEntryToElems = function addEntryToElems(entry) {\n+                if (entry.id === -1) {\n+                    // Pure generic, needs to check into it.\n+                    for (const inner_entry of entry.generics) {\n+                        addEntryToElems(inner_entry);\n                     }\n-                    currentEntryElems.push(entry);\n-                };\n-                for (const entry of row.generics) {\n-                    addEntryToElems(entry);\n+                    return;\n                 }\n-                // We need to find the type that matches the most to remove it in order\n-                // to move forward.\n-                const handleGeneric = generic => {\n-                    if (!elems.has(generic.id)) {\n-                        return false;\n-                    }\n-                    const matchElems = elems.get(generic.id);\n-                    const matchIdx = matchElems.findIndex(tmp_elem => {\n-                        if (generic.generics.length > 0 && !checkGenerics(tmp_elem, generic)) {\n-                            return false;\n-                        }\n-                        return typePassesFilter(generic.typeFilter, tmp_elem.ty);\n-                    });\n-                    if (matchIdx === -1) {\n-                        return false;\n-                    }\n-                    matchElems.splice(matchIdx, 1);\n-                    if (matchElems.length === 0) {\n-                        elems.delete(generic.id);\n-                    }\n-                    return true;\n-                };\n-                // To do the right thing with type filters, we first process generics\n-                // that have them, removing matching ones from the \"bag,\" then do the\n-                // ones with no type filter, which can match any entry regardless of its\n-                // own type.\n-                for (const generic of elem.generics) {\n-                    if (generic.typeFilter === TY_PRIMITIVE &&\n-                        generic.id === typeNameIdOfArrayOrSlice) {\n-                        const genericArray = {\n-                            id: typeNameIdOfArray,\n-                            typeFilter: TY_PRIMITIVE,\n-                            generics: generic.generics,\n-                        };\n-                        const genericSlice = {\n-                            id: typeNameIdOfSlice,\n-                            typeFilter: TY_PRIMITIVE,\n-                            generics: generic.generics,\n-                        };\n-                        if (!handleGeneric(genericArray) && !handleGeneric(genericSlice)) {\n-                            return false;\n-                        }\n-                    } else if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n+                let currentEntryElems;\n+                if (elems.has(entry.id)) {\n+                    currentEntryElems = elems.get(entry.id);\n+                } else {\n+                    currentEntryElems = [];\n+                    elems.set(entry.id, currentEntryElems);\n+                }\n+                currentEntryElems.push(entry);\n+            };\n+            for (const entry of row.generics) {\n+                addEntryToElems(entry);\n+            }\n+            // We need to find the type that matches the most to remove it in order\n+            // to move forward.\n+            const handleGeneric = generic => {\n+                if (!elems.has(generic.id)) {\n+                    return false;\n+                }\n+                const matchElems = elems.get(generic.id);\n+                const matchIdx = matchElems.findIndex(tmp_elem => {\n+                    if (generic.generics.length > 0 && !checkGenerics(tmp_elem, generic)) {\n                         return false;\n                     }\n+                    return typePassesFilter(generic.typeFilter, tmp_elem.ty);\n+                });\n+                if (matchIdx === -1) {\n+                    return false;\n                 }\n-                for (const generic of elem.generics) {\n-                    if (generic.typeFilter === -1 && !handleGeneric(generic)) {\n+                matchElems.splice(matchIdx, 1);\n+                if (matchElems.length === 0) {\n+                    elems.delete(generic.id);\n+                }\n+                return true;\n+            };\n+            // To do the right thing with type filters, we first process generics\n+            // that have them, removing matching ones from the \"bag,\" then do the\n+            // ones with no type filter, which can match any entry regardless of its\n+            // own type.\n+            for (const generic of elem.generics) {\n+                if (generic.typeFilter === TY_PRIMITIVE &&\n+                    generic.id === typeNameIdOfArrayOrSlice) {\n+                    const genericArray = {\n+                        id: typeNameIdOfArray,\n+                        typeFilter: TY_PRIMITIVE,\n+                        generics: generic.generics,\n+                    };\n+                    const genericSlice = {\n+                        id: typeNameIdOfSlice,\n+                        typeFilter: TY_PRIMITIVE,\n+                        generics: generic.generics,\n+                    };\n+                    if (!handleGeneric(genericArray) && !handleGeneric(genericSlice)) {\n                         return false;\n                     }\n+                } else if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n+                    return false;\n                 }\n-                return true;\n             }\n-            return false;\n+            for (const generic of elem.generics) {\n+                if (generic.typeFilter === -1 && !handleGeneric(generic)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n         /**"}]}