{"sha": "a626da4e7833598b26d89de01237150986582af4", "node_id": "C_kwDOAAsO6NoAKGE2MjZkYTRlNzgzMzU5OGIyNmQ4OWRlMDEyMzcxNTA5ODY1ODJhZjQ", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T19:39:39Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T20:49:53Z"}, "message": "Split out `ItemFragment` from `UrlFragment`\n\nThis allows eliminating branches in the code where a user-written\nfragment is impossible.", "tree": {"sha": "ac4429301d8fde23c4ea2a25857f2d0bae1e5dbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac4429301d8fde23c4ea2a25857f2d0bae1e5dbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a626da4e7833598b26d89de01237150986582af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a626da4e7833598b26d89de01237150986582af4", "html_url": "https://github.com/rust-lang/rust/commit/a626da4e7833598b26d89de01237150986582af4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a626da4e7833598b26d89de01237150986582af4/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a69e15c50160dcd986b18588ac263837a750a53c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a69e15c50160dcd986b18588ac263837a750a53c", "html_url": "https://github.com/rust-lang/rust/commit/a69e15c50160dcd986b18588ac263837a750a53c"}], "stats": {"total": 88, "additions": 49, "deletions": 39}, "files": [{"sha": "0069f438270c309bdd0770683531d55426681a47", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a626da4e7833598b26d89de01237150986582af4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a626da4e7833598b26d89de01237150986582af4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a626da4e7833598b26d89de01237150986582af4", "patch": "@@ -236,10 +236,23 @@ enum AnchorFailure {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n crate enum UrlFragment {\n-    Def(FragmentKind, DefId),\n+    Item(ItemFragment),\n     UserWritten(String),\n }\n \n+impl UrlFragment {\n+    /// Render the fragment, including the leading `#`.\n+    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+        match self {\n+            UrlFragment::Item(frag) => frag.render(s, tcx),\n+            UrlFragment::UserWritten(raw) => write!(s, \"#{}\", raw),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+crate struct ItemFragment(FragmentKind, DefId);\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n crate enum FragmentKind {\n     Method,\n@@ -252,7 +265,7 @@ crate enum FragmentKind {\n     VariantField,\n }\n \n-impl UrlFragment {\n+impl ItemFragment {\n     /// Create a fragment for an associated item.\n     ///\n     /// `is_prototype` is whether this associated item is a trait method\n@@ -261,21 +274,21 @@ impl UrlFragment {\n         match kind {\n             ty::AssocKind::Fn => {\n                 if is_prototype {\n-                    UrlFragment::Def(FragmentKind::TyMethod, def_id)\n+                    ItemFragment(FragmentKind::TyMethod, def_id)\n                 } else {\n-                    UrlFragment::Def(FragmentKind::Method, def_id)\n+                    ItemFragment(FragmentKind::Method, def_id)\n                 }\n             }\n-            ty::AssocKind::Const => UrlFragment::Def(FragmentKind::AssociatedConstant, def_id),\n-            ty::AssocKind::Type => UrlFragment::Def(FragmentKind::AssociatedType, def_id),\n+            ty::AssocKind::Const => ItemFragment(FragmentKind::AssociatedConstant, def_id),\n+            ty::AssocKind::Type => ItemFragment(FragmentKind::AssociatedType, def_id),\n         }\n     }\n \n     /// Render the fragment, including the leading `#`.\n     crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n         write!(s, \"#\")?;\n         match *self {\n-            UrlFragment::Def(kind, def_id) => {\n+            ItemFragment(kind, def_id) => {\n                 let name = tcx.item_name(def_id);\n                 match kind {\n                     FragmentKind::Method => write!(s, \"method.{}\", name),\n@@ -290,7 +303,6 @@ impl UrlFragment {\n                     }\n                 }\n             }\n-            UrlFragment::UserWritten(ref raw) => write!(s, \"{}\", raw),\n         }\n     }\n }\n@@ -300,7 +312,7 @@ struct ResolutionInfo {\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n-    extra_fragment: Option<UrlFragment>,\n+    extra_fragment: Option<String>,\n }\n \n #[derive(Clone)]\n@@ -339,7 +351,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &'path str,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n+    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n             module_id,\n@@ -389,10 +401,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         if let Some(field) =\n                             def.all_fields().find(|f| f.ident.name == variant_field_name)\n                         {\n-                            Ok((\n-                                ty_res,\n-                                Some(UrlFragment::Def(FragmentKind::VariantField, field.did)),\n-                            ))\n+                            Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n                         } else {\n                             Err(ResolutionFailure::NotResolved {\n                                 module_id,\n@@ -420,15 +429,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, UrlFragment)> {\n+    ) -> Option<(Res, ItemFragment)> {\n         let tcx = self.cx.tcx;\n \n         prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {\n                     let kind = item.kind;\n-                    let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n+                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n                     (Res::Primitive(prim_ty), fragment)\n                 })\n         })\n@@ -503,21 +512,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n-        user_fragment: &Option<UrlFragment>,\n+        user_fragment: &Option<String>,\n     ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n         let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, module_id)?;\n         let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n             (Some(_), Some(r_frag)) => {\n                 let diag_res = match r_frag {\n-                    UrlFragment::Def(_, did) => Res::Def(self.cx.tcx.def_kind(did), did),\n-                    // FIXME: eliminate this branch somehow\n-                    UrlFragment::UserWritten(_) => unreachable!(),\n+                    ItemFragment(_, did) => Res::Def(self.cx.tcx.def_kind(did), did),\n                 };\n                 let failure = AnchorFailure::RustdocAnchorConflict(diag_res);\n                 return Err(ErrorKind::AnchorFailure(failure));\n             }\n-            (Some(u_frag), None) => Some(u_frag.clone()),\n-            (None, Some(r_frag)) => Some(r_frag),\n+            (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n+            (None, Some(r_frag)) => Some(UrlFragment::Item(r_frag)),\n             (None, None) => None,\n         };\n         Ok((res, chosen_fragment))\n@@ -528,7 +535,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n+    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n@@ -670,7 +677,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, UrlFragment)> {\n+    ) -> Option<(Res, ItemFragment)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n@@ -685,7 +692,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n                     assoc_item.map(|item| {\n                         let kind = item.kind;\n-                        let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n+                        let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n                         (root_res, fragment)\n                     })\n                 })\n@@ -736,7 +743,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n                 if let Some(item) = assoc_item {\n                     let kind = item.kind;\n-                    let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n+                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n                     return Some((root_res, fragment));\n                 }\n \n@@ -768,13 +775,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .fields\n                     .iter()\n                     .find(|item| item.ident.name == item_name)?;\n-                Some((root_res, UrlFragment::Def(FragmentKind::StructField, field.did)))\n+                Some((root_res, ItemFragment(FragmentKind::StructField, field.did)))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n-                    let fragment = UrlFragment::from_assoc_item(\n+                    let fragment = ItemFragment::from_assoc_item(\n                         item.def_id,\n                         item.kind,\n                         !item.defaultness.has_value(),\n@@ -797,7 +804,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n-        extra_fragment: &Option<UrlFragment>,\n+        extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n@@ -812,7 +819,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         let res = match result {\n             Ok((res, frag)) => {\n-                if let Some(UrlFragment::Def(_, id)) = frag {\n+                if let Some(UrlFragment::Item(ItemFragment(_, id))) = frag {\n                     Some(Res::Def(self.cx.tcx.def_kind(id), id))\n                 } else {\n                     Some(res)\n@@ -1039,7 +1046,7 @@ impl From<AnchorFailure> for PreprocessingError<'_> {\n struct PreprocessingInfo {\n     path_str: String,\n     disambiguator: Option<Disambiguator>,\n-    extra_fragment: Option<UrlFragment>,\n+    extra_fragment: Option<String>,\n     link_text: String,\n }\n \n@@ -1125,7 +1132,7 @@ fn preprocess_link<'a>(\n     Some(Ok(PreprocessingInfo {\n         path_str,\n         disambiguator,\n-        extra_fragment: extra_fragment.map(|frag| UrlFragment::UserWritten(frag.to_owned())),\n+        extra_fragment: extra_fragment.map(|frag| frag.to_owned()),\n         link_text: link_text.to_owned(),\n     }))\n }\n@@ -1292,7 +1299,7 @@ impl LinkCollector<'_, '_> {\n         };\n \n         let verify = |kind: DefKind, id: DefId| {\n-            let (kind, id) = if let Some(UrlFragment::Def(_, id)) = fragment {\n+            let (kind, id) = if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n                 (self.cx.tcx.def_kind(id), id)\n             } else {\n                 (kind, id)\n@@ -1340,7 +1347,7 @@ impl LinkCollector<'_, '_> {\n \n         match res {\n             Res::Primitive(prim) => {\n-                if let Some(UrlFragment::Def(_, id)) = fragment {\n+                if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n                     let kind = self.cx.tcx.def_kind(id);\n \n                     // We're actually resolving an associated item of a primitive, so we need to\n@@ -1488,7 +1495,7 @@ impl LinkCollector<'_, '_> {\n                 let mut candidates = PerNS {\n                     macro_ns: self\n                         .resolve_macro(path_str, base_node)\n-                        .map(|res| (res, extra_fragment.clone())),\n+                        .map(|res| (res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n                     type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n@@ -1520,7 +1527,10 @@ impl LinkCollector<'_, '_> {\n                                         // Shouldn't happen but who knows?\n                                         Ok((res, Some(fragment)))\n                                     }\n-                                    (fragment, None) | (None, fragment) => Ok((res, fragment)),\n+                                    (fragment, None) => Ok((res, fragment)),\n+                                    (None, fragment) => {\n+                                        Ok((res, fragment.map(UrlFragment::UserWritten)))\n+                                    }\n                                 }\n                             }\n                         }\n@@ -1557,7 +1567,7 @@ impl LinkCollector<'_, '_> {\n             }\n             Some(MacroNS) => {\n                 match self.resolve_macro(path_str, base_node) {\n-                    Ok(res) => Some((res, extra_fragment.clone())),\n+                    Ok(res) => Some((res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for ns in [TypeNS, ValueNS] {\n@@ -2276,13 +2286,13 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n-) -> Result<(Res, Option<UrlFragment>), ErrorKind<'static>> {\n+) -> Result<(Res, Option<ItemFragment>), ErrorKind<'static>> {\n     cx.tcx\n         .parent(res.def_id(cx.tcx))\n         .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n             let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());\n-            (parent_def, Some(UrlFragment::Def(FragmentKind::Variant, variant.def_id)))\n+            (parent_def, Some(ItemFragment(FragmentKind::Variant, variant.def_id)))\n         })\n         .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }"}]}