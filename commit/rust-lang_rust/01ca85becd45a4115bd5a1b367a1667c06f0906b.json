{"sha": "01ca85becd45a4115bd5a1b367a1667c06f0906b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxY2E4NWJlY2Q0NWE0MTE1YmQ1YTFiMzY3YTE2NjdjMDZmMDkwNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-16T23:27:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-16T23:27:43Z"}, "message": "Auto merge of #55093 - nikomatsakis:nll-issue-54574-multisegment-path, r=pnkfelix\n\nnll type annotations in multisegment path\n\nThis turned out to be sort of tricky. The problem is that if you have a path like\n\n```\n<Foo<&'static u32>>::bar\n```\n\nand it comes from an impl like `impl<T> Foo<T>` then the self-type the user gave doesn't *directly* map to the substitutions that the impl wants. To handle this, then, we have to preserve not just the \"user-given substs\" we used to do, but also a \"user-given self-ty\", which we have to apply later. This PR makes those changes.\n\nIt also removes the code from NLL relate-ops that handled canonical variables and moves to use normal inference variables instead. This simplifies a few things and gives us a bit more flexibility (for example, I predict we are going to have to start normalizing at some point, and it would be easy now).\n\nr? @matthewjasper -- you were just touching this code, do you feel comfortable reviewing this?\n\nFixes #54574", "tree": {"sha": "d5ccbfbaf741308c228752047d8088ff87a0b7cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5ccbfbaf741308c228752047d8088ff87a0b7cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ca85becd45a4115bd5a1b367a1667c06f0906b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ca85becd45a4115bd5a1b367a1667c06f0906b", "html_url": "https://github.com/rust-lang/rust/commit/01ca85becd45a4115bd5a1b367a1667c06f0906b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ca85becd45a4115bd5a1b367a1667c06f0906b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bef62ccddb911b9cd7677717a69348a62cf61f96", "url": "https://api.github.com/repos/rust-lang/rust/commits/bef62ccddb911b9cd7677717a69348a62cf61f96", "html_url": "https://github.com/rust-lang/rust/commit/bef62ccddb911b9cd7677717a69348a62cf61f96"}, {"sha": "b70b4a6814d420222f28684f9286a21ddb980bcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b70b4a6814d420222f28684f9286a21ddb980bcf", "html_url": "https://github.com/rust-lang/rust/commit/b70b4a6814d420222f28684f9286a21ddb980bcf"}], "stats": {"total": 2108, "additions": 1260, "deletions": 848}, "files": [{"sha": "b660187945cdbb26cf2298f5a21fd8ab92014ffa", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -587,3 +587,24 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubj\n }\n \n impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::UserTypeAnnotation<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::UserTypeAnnotation::Ty(ref ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::UserTypeAnnotation::FnDef(ref def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            mir::UserTypeAnnotation::AdtDef(ref def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "e54968c5274bf130fea0d97d1baeb22f629bf69c", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -1417,3 +1417,8 @@ impl_stable_hash_for!(enum traits::QuantifierKind {\n     Universal,\n     Existential\n });\n+\n+impl_stable_hash_for!(struct ty::subst::UserSubsts<'tcx> { substs, user_self_ty });\n+\n+impl_stable_hash_for!(struct ty::subst::UserSelfTy<'tcx> { impl_def_id, self_ty });\n+"}, {"sha": "1863f08930f5f55b04b1f24fd13ff6b3ecc0c375", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -241,17 +241,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// canonicalized) then represents the values that you computed\n     /// for each of the canonical inputs to your query.\n \n-    pub(in infer) fn instantiate_canonical_with_fresh_inference_vars<T>(\n+    pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n         &self,\n         span: Span,\n         canonical: &Canonical<'tcx, T>,\n     ) -> (T, CanonicalVarValues<'tcx>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        assert_eq!(self.universe(), ty::UniverseIndex::ROOT, \"infcx not newly created\");\n-        assert_eq!(self.type_variables.borrow().num_vars(), 0, \"infcx not newly created\");\n-\n         let canonical_inference_vars =\n             self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n         let result = canonical.substitute(self.tcx, &canonical_inference_vars);"}, {"sha": "fbd38ebd78cedcf8f33f60c04110d6650fa5a4e9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -62,6 +62,7 @@ mod higher_ranked;\n pub mod lattice;\n mod lexical_region_resolve;\n mod lub;\n+pub mod nll_relate;\n pub mod opaque_types;\n pub mod outlives;\n pub mod region_constraints;"}, {"sha": "e003c1989e0963fdd709055e6e686f2aed8a83b5", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "added", "additions": 736, "deletions": 0, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,736 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This code is kind of an alternate way of doing subtyping,\n+//! supertyping, and type equating, distinct from the `combine.rs`\n+//! code but very similar in its effect and design. Eventually the two\n+//! ought to be merged. This code is intended for use in NLL.\n+//!\n+//! Here are the key differences:\n+//!\n+//! - This code generally assumes that there are no unbound type\n+//!   inferences variables, because at NLL\n+//!   time types are fully inferred up-to regions.\n+//!   - Actually, to support user-given type annotations like\n+//!     `Vec<_>`, we do have some measure of support for type\n+//!     inference variables, but we impose some simplifying\n+//!     assumptions on them that would not be suitable for the infer\n+//!     code more generally. This could be fixed.\n+//! - This code uses \"universes\" to handle higher-ranked regions and\n+//!   not the leak-check. This is \"more correct\" than what rustc does\n+//!   and we are generally migrating in this direction, but NLL had to\n+//!   get there first.\n+\n+use crate::infer::InferCtxt;\n+use crate::ty::fold::{TypeFoldable, TypeVisitor};\n+use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n+\n+pub struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+\n+    /// Callback to use when we deduce an outlives relationship\n+    delegate: D,\n+\n+    /// How are we relating `a` and `b`?\n+    ///\n+    /// - covariant means `a <: b`\n+    /// - contravariant means `b <: a`\n+    /// - invariant means `a == b\n+    /// - bivariant means that it doesn't matter\n+    ambient_variance: ty::Variance,\n+\n+    /// When we pass through a set of binders (e.g., when looking into\n+    /// a `fn` type), we push a new bound region scope onto here.  This\n+    /// will contain the instantiated region for each region in those\n+    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n+    /// use the debruijn index `d` to find the right scope, and then\n+    /// bound region name `br` to find the specific instantiation from\n+    /// within that scope. See `replace_bound_region`.\n+    ///\n+    /// This field stores the instantiations for late-bound regions in\n+    /// the `a` type.\n+    a_scopes: Vec<BoundRegionScope<'tcx>>,\n+\n+    /// Same as `a_scopes`, but for the `b` type.\n+    b_scopes: Vec<BoundRegionScope<'tcx>>,\n+}\n+\n+pub trait TypeRelatingDelegate<'tcx> {\n+    /// Push a constraint `sup: sub` -- this constraint must be\n+    /// satisfied for the two types to be related. `sub` and `sup` may\n+    /// be regions from the type or new variables created through the\n+    /// delegate.\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+\n+    /// Creates a new universe index. Used when instantiating placeholders.\n+    fn create_next_universe(&mut self) -> ty::UniverseIndex;\n+\n+    /// Creates a new region variable representing a higher-ranked\n+    /// region that is instantiated existentially. This creates an\n+    /// inference variable, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'a` with an\n+    /// inference variable (though `'b` would be instantiated first,\n+    /// as a placeholder).\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n+\n+    /// Creates a new region variable representing a\n+    /// higher-ranked region that is instantiated universally.\n+    /// This creates a new region placeholder, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'b` with a\n+    /// placeholder region.\n+    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx>;\n+\n+    /// Creates a new existential region in the given universe. This\n+    /// is used when handling subtyping and type variables -- if we\n+    /// have that `?X <: Foo<'a>`, for example, we would instantiate\n+    /// `?X` with a type like `Foo<'?0>` where `'?0` is a fresh\n+    /// existential variable created by this function. We would then\n+    /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n+    /// relation stating that `'?0: 'a`).\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ScopesAndKind<'tcx> {\n+    scopes: Vec<BoundRegionScope<'tcx>>,\n+    kind: Kind<'tcx>,\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+struct BoundRegionScope<'tcx> {\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+}\n+\n+#[derive(Copy, Clone)]\n+struct UniversallyQuantified(bool);\n+\n+impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    pub fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        delegate: D,\n+        ambient_variance: ty::Variance,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            delegate,\n+            ambient_variance,\n+            a_scopes: vec![],\n+            b_scopes: vec![],\n+        }\n+    }\n+\n+    fn ambient_covariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Covariant | ty::Variance::Invariant => true,\n+            ty::Variance::Contravariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn ambient_contravariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Contravariant | ty::Variance::Invariant => true,\n+            ty::Variance::Covariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn create_scope(\n+        &mut self,\n+        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> BoundRegionScope<'tcx> {\n+        let mut scope = BoundRegionScope::default();\n+\n+        // Create a callback that creates (via the delegate) either an\n+        // existential or placeholder region as needed.\n+        let mut next_region = {\n+            let delegate = &mut self.delegate;\n+            let mut lazy_universe = None;\n+            move |br: ty::BoundRegion| {\n+                if universally_quantified.0 {\n+                    // The first time this closure is called, create a\n+                    // new universe for the placeholders we will make\n+                    // from here out.\n+                    let universe = lazy_universe.unwrap_or_else(|| {\n+                        let universe = delegate.create_next_universe();\n+                        lazy_universe = Some(universe);\n+                        universe\n+                    });\n+\n+                    let placeholder = ty::Placeholder { universe, name: br };\n+                    delegate.next_placeholder_region(placeholder)\n+                } else {\n+                    delegate.next_existential_region_var()\n+                }\n+            }\n+        };\n+\n+        value.skip_binder().visit_with(&mut ScopeInstantiator {\n+            next_region: &mut next_region,\n+            target_index: ty::INNERMOST,\n+            bound_region_scope: &mut scope,\n+        });\n+\n+        scope\n+    }\n+\n+    /// When we encounter binders during the type traversal, we record\n+    /// the value to substitute for each of the things contained in\n+    /// that binder. (This will be either a universal placeholder or\n+    /// an existential inference variable.) Given the debruijn index\n+    /// `debruijn` (and name `br`) of some binder we have now\n+    /// encountered, this routine finds the value that we instantiated\n+    /// the region with; to do so, it indexes backwards into the list\n+    /// of ambient scopes `scopes`.\n+    fn lookup_bound_region(\n+        debruijn: ty::DebruijnIndex,\n+        br: &ty::BoundRegion,\n+        first_free_index: ty::DebruijnIndex,\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n+        // The debruijn index is a \"reverse index\" into the\n+        // scopes listing. So when we have INNERMOST (0), we\n+        // want the *last* scope pushed, and so forth.\n+        let debruijn_index = debruijn.index() - first_free_index.index();\n+        let scope = &scopes[scopes.len() - debruijn_index - 1];\n+\n+        // Find this bound region in that scope to map to a\n+        // particular region.\n+        scope.map[br]\n+    }\n+\n+    /// If `r` is a bound region, find the scope in which it is bound\n+    /// (from `scopes`) and return the value that we instantiated it\n+    /// with. Otherwise just return `r`.\n+    fn replace_bound_region(\n+        &self,\n+        r: ty::Region<'tcx>,\n+        first_free_index: ty::DebruijnIndex,\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n+        if let ty::ReLateBound(debruijn, br) = r {\n+            Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n+        } else {\n+            r\n+        }\n+    }\n+\n+    /// Push a new outlives requirement into our output set of\n+    /// constraints.\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n+\n+        self.delegate.push_outlives(sup, sub);\n+    }\n+\n+    /// When we encounter a canonical variable `var` in the output,\n+    /// equate it with `kind`. If the variable has been previously\n+    /// equated, then equate it again.\n+    fn relate_var(&mut self, var_ty: Ty<'tcx>, value_ty: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"equate_var(var_ty={:?}, value_ty={:?})\", var_ty, value_ty);\n+\n+        let generalized_ty = self.generalize_value(value_ty);\n+        self.infcx\n+            .force_instantiate_unchecked(var_ty, generalized_ty);\n+\n+        // The generalized values we extract from `canonical_var_values` have\n+        // been fully instantiated and hence the set of scopes we have\n+        // doesn't matter -- just to be sure, put an empty vector\n+        // in there.\n+        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n+\n+        // Relate the generalized kind to the original one.\n+        let result = self.relate(&generalized_ty, &value_ty);\n+\n+        // Restore the old scopes now.\n+        self.a_scopes = old_a_scopes;\n+\n+        debug!(\"equate_var: complete, result = {:?}\", result);\n+        result\n+    }\n+\n+    fn generalize_value<T: Relate<'tcx>>(&mut self, value: T) -> T {\n+        TypeGeneralizer {\n+            tcx: self.infcx.tcx,\n+            delegate: &mut self.delegate,\n+            first_free_index: ty::INNERMOST,\n+            ambient_variance: self.ambient_variance,\n+\n+            // These always correspond to an `_` or `'_` written by\n+            // user, and those are always in the root universe.\n+            universe: ty::UniverseIndex::ROOT,\n+        }.relate(&value, &value)\n+            .unwrap()\n+    }\n+}\n+\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::subtype\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let a = self.infcx.shallow_resolve(a);\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+                self.relate_var(a.into(), b.into())\n+            }\n+\n+            _ => {\n+                debug!(\n+                    \"tys(a={:?}, b={:?}, variance={:?})\",\n+                    a, b, self.ambient_variance\n+                );\n+\n+                relate::super_relate_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\n+            \"regions(a={:?}, b={:?}, variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n+\n+        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n+        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n+\n+        debug!(\"regions: v_a = {:?}\", v_a);\n+        debug!(\"regions: v_b = {:?}\", v_b);\n+\n+        if self.ambient_covariance() {\n+            // Covariance: a <= b. Hence, `b: a`.\n+            self.push_outlives(v_b, v_a);\n+        }\n+\n+        if self.ambient_contravariance() {\n+            // Contravariant: b <= a. Hence, `a: b`.\n+            self.push_outlives(v_a, v_b);\n+        }\n+\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        // We want that\n+        //\n+        // ```\n+        // for<'a> fn(&'a u32) -> &'a u32 <:\n+        //   fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // but not\n+        //\n+        // ```\n+        // fn(&'a u32) -> &'a u32 <:\n+        //   for<'b> fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // We therefore proceed as follows:\n+        //\n+        // - Instantiate binders on `b` universally, yielding a universe U1.\n+        // - Instantiate binders on `a` existentially in U1.\n+\n+        debug!(\n+            \"binders({:?}: {:?}, ambient_variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n+\n+        if self.ambient_covariance() {\n+            // Covariance, so we want `for<..> A <: for<..> B` --\n+            // therefore we compare any instantiation of A (i.e., A\n+            // instantiated with existentials) against every\n+            // instantiation of B (i.e., B instantiated with\n+            // universals).\n+\n+            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n+            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n+\n+            self.b_scopes.push(b_scope);\n+            self.a_scopes.push(a_scope);\n+\n+            // Reset the ambient variance to covariant. This is needed\n+            // to correctly handle cases like\n+            //\n+            //     for<'a> fn(&'a u32, &'a u3) == for<'b, 'c> fn(&'b u32, &'c u32)\n+            //\n+            // Somewhat surprisingly, these two types are actually\n+            // **equal**, even though the one on the right looks more\n+            // polymorphic. The reason is due to subtyping. To see it,\n+            // consider that each function can call the other:\n+            //\n+            // - The left function can call the right with `'b` and\n+            //   `'c` both equal to `'a`\n+            //\n+            // - The right function can call the left with `'a` set to\n+            //   `{P}`, where P is the point in the CFG where the call\n+            //   itself occurs. Note that `'b` and `'c` must both\n+            //   include P. At the point, the call works because of\n+            //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n+            let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.ambient_variance = variance;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        if self.ambient_contravariance() {\n+            // Contravariance, so we want `for<..> A :> for<..> B`\n+            // -- therefore we compare every instantiation of A (i.e.,\n+            // A instantiated with universals) against any\n+            // instantiation of B (i.e., B instantiated with\n+            // existentials). Opposite of above.\n+\n+            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n+            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n+\n+            self.a_scopes.push(a_scope);\n+            self.b_scopes.push(b_scope);\n+\n+            // Reset ambient variance to contravariance. See the\n+            // covariant case above for an explanation.\n+            let variance =\n+                ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.ambient_variance = variance;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        Ok(a.clone())\n+    }\n+}\n+\n+/// When we encounter a binder like `for<..> fn(..)`, we actually have\n+/// to walk the `fn` value to find all the values bound by the `for`\n+/// (these are not explicitly present in the ty representation right\n+/// now). This visitor handles that: it descends the type, tracking\n+/// binder depth, and finds late-bound regions targeting the\n+/// `for<..`>.  For each of those, it creates an entry in\n+/// `bound_region_scope`.\n+struct ScopeInstantiator<'me, 'tcx: 'me> {\n+    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+    // The debruijn index of the scope we are instantiating.\n+    target_index: ty::DebruijnIndex,\n+    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n+}\n+\n+impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.target_index.shift_in(1);\n+        t.super_visit_with(self);\n+        self.target_index.shift_out(1);\n+\n+        false\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        let ScopeInstantiator {\n+            bound_region_scope,\n+            next_region,\n+            ..\n+        } = self;\n+\n+        match r {\n+            ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n+                bound_region_scope\n+                    .map\n+                    .entry(*br)\n+                    .or_insert_with(|| next_region(*br));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+}\n+\n+/// The \"type generalize\" is used when handling inference variables.\n+///\n+/// The basic strategy for handling a constraint like `?A <: B` is to\n+/// apply a \"generalization strategy\" to the type `B` -- this replaces\n+/// all the lifetimes in the type `B` with fresh inference\n+/// variables. (You can read more about the strategy in this [blog\n+/// post].)\n+///\n+/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n+/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n+/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n+/// establishes `'0: 'x` as a constraint.\n+///\n+/// As a side-effect of this generalization procedure, we also replace\n+/// all the bound regions that we have traversed with concrete values,\n+/// so that the resulting generalized type is independent from the\n+/// scopes.\n+///\n+/// [blog post]: https://is.gd/0hKvIr\n+struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+\n+    delegate: &'me mut D,\n+\n+    /// After we generalize this type, we are going to relative it to\n+    /// some other type. What will be the variance at this point?\n+    ambient_variance: ty::Variance,\n+\n+    first_free_index: ty::DebruijnIndex,\n+\n+    universe: ty::UniverseIndex,\n+}\n+\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n+\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+                bug!(\n+                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                    a\n+                );\n+            }\n+\n+            _ => relate::super_relate_tys(self, a, a),\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n+\n+        if let ty::ReLateBound(debruijn, _) = a {\n+            if *debruijn < self.first_free_index {\n+                return Ok(a);\n+            }\n+        }\n+\n+        // For now, we just always create a fresh region variable to\n+        // replace all the regions in the source type. In the main\n+        // type checker, we special case the case where the ambient\n+        // variance is `Invariant` and try to avoid creating a fresh\n+        // region variable, but since this comes up so much less in\n+        // NLL (only when users use `_` etc) it is much less\n+        // important.\n+        //\n+        // As an aside, since these new variables are created in\n+        // `self.universe` universe, this also serves to enforce the\n+        // universe scoping rules.\n+        //\n+        // FIXME(#54105) -- if the ambient variance is bivariant,\n+        // though, we may however need to check well-formedness or\n+        // risk a problem like #41677 again.\n+\n+        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n+\n+        Ok(replacement_region_vid)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        _: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n+\n+        self.first_free_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        self.first_free_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n+    }\n+}\n+\n+impl InferCtxt<'_, '_, 'tcx> {\n+    /// A hacky sort of method used by the NLL type-relating code:\n+    ///\n+    /// - `var` must be some unbound type variable.\n+    /// - `value` must be a suitable type to use as its value.\n+    ///\n+    /// `var` will then be equated with `value`. Note that this\n+    /// sidesteps a number of important checks, such as the \"occurs\n+    /// check\" that prevents cyclic types, so it is important not to\n+    /// use this method during regular type-check.\n+    fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n+        match (&var.sty, &value.sty) {\n+            (&ty::Infer(ty::TyVar(vid)), _) => {\n+                let mut type_variables = self.type_variables.borrow_mut();\n+\n+                // In NLL, we don't have type inference variables\n+                // floating around, so we can do this rather imprecise\n+                // variant of the occurs-check.\n+                assert!(!value.has_infer_types());\n+\n+                type_variables.instantiate(vid, value);\n+            }\n+\n+            (&ty::Infer(ty::IntVar(vid)), &ty::Int(value)) => {\n+                let mut int_unification_table = self.int_unification_table.borrow_mut();\n+                int_unification_table\n+                    .unify_var_value(vid, Some(ty::IntVarValue::IntType(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n+                    });\n+            }\n+\n+            (&ty::Infer(ty::IntVar(vid)), &ty::Uint(value)) => {\n+                let mut int_unification_table = self.int_unification_table.borrow_mut();\n+                int_unification_table\n+                    .unify_var_value(vid, Some(ty::IntVarValue::UintType(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n+                    });\n+            }\n+\n+            (&ty::Infer(ty::FloatVar(vid)), &ty::Float(value)) => {\n+                let mut float_unification_table = self.float_unification_table.borrow_mut();\n+                float_unification_table\n+                    .unify_var_value(vid, Some(ty::FloatVarValue(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify float var `{:?}` with `{:?}`\", vid, value)\n+                    });\n+            }\n+\n+            _ => {\n+                bug!(\n+                    \"force_instantiate_unchecked invoked with bad combination: var={:?} value={:?}\",\n+                    var,\n+                    value,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "48b2ccbcf873749c3eac4175b0f9a566a97b8481", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -37,7 +37,7 @@ use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::subst::{Subst, Substs};\n+use ty::subst::{CanonicalUserSubsts, Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n use util::ppaux;\n \n@@ -710,7 +710,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g. via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n-    pub user_ty: Option<(CanonicalTy<'tcx>, Span)>,\n+    pub user_ty: Option<(UserTypeAnnotation<'tcx>, Span)>,\n \n     /// Name of the local, used in debuginfo and pretty-printing.\n     ///\n@@ -1737,7 +1737,7 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, CanonicalTy<'tcx>),\n+    AscribeUserType(Place<'tcx>, ty::Variance, UserTypeAnnotation<'tcx>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -2188,7 +2188,7 @@ pub enum AggregateKind<'tcx> {\n         &'tcx AdtDef,\n         usize,\n         &'tcx Substs<'tcx>,\n-        Option<CanonicalTy<'tcx>>,\n+        Option<UserTypeAnnotation<'tcx>>,\n         Option<usize>,\n     ),\n \n@@ -2392,7 +2392,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n@@ -2402,11 +2402,29 @@ pub struct Constant<'tcx> {\n     /// indicate that `Vec<_>` was explicitly specified.\n     ///\n     /// Needed for NLL to impose user-given type constraints.\n-    pub user_ty: Option<CanonicalTy<'tcx>>,\n+    pub user_ty: Option<UserTypeAnnotation<'tcx>>,\n \n     pub literal: &'tcx ty::Const<'tcx>,\n }\n \n+/// A user-given type annotation attached to a constant.  These arise\n+/// from constants that are named via paths, like `Foo::<A>::new` and\n+/// so forth.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum UserTypeAnnotation<'tcx> {\n+    Ty(CanonicalTy<'tcx>),\n+    FnDef(DefId, CanonicalUserSubsts<'tcx>),\n+    AdtDef(&'tcx AdtDef, CanonicalUserSubsts<'tcx>),\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::FnDef)(def, substs),\n+        (UserTypeAnnotation::AdtDef)(def, substs),\n+    }\n+}\n+\n newtype_index! {\n     pub struct Promoted {\n         DEBUG_FORMAT = \"promoted[{}]\""}, {"sha": "76c76404d2fd251dd3368315fcdc985fb6bdcea0", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty};\n+use ty::{ClosureSubsts, GeneratorSubsts, Region, Ty};\n use mir::*;\n use syntax_pos::Span;\n \n@@ -147,9 +147,9 @@ macro_rules! make_mir_visitor {\n             fn visit_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)* Place<'tcx>,\n                                      variance: & $($mutability)* ty::Variance,\n-                                     c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                     user_ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n                                      location: Location) {\n-                self.super_ascribe_user_ty(place, variance, c_ty, location);\n+                self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n \n             fn visit_place(&mut self,\n@@ -214,8 +214,11 @@ macro_rules! make_mir_visitor {\n                 self.super_ty(ty);\n             }\n \n-            fn visit_user_ty(&mut self, ty: & $($mutability)* CanonicalTy<'tcx>) {\n-                self.super_canonical_ty(ty);\n+            fn visit_user_type_annotation(\n+                &mut self,\n+                ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+            ) {\n+                self.super_user_type_annotation(ty);\n             }\n \n             fn visit_region(&mut self,\n@@ -390,9 +393,9 @@ macro_rules! make_mir_visitor {\n                     StatementKind::AscribeUserType(\n                         ref $($mutability)* place,\n                         ref $($mutability)* variance,\n-                        ref $($mutability)* c_ty,\n+                        ref $($mutability)* user_ty,\n                     ) => {\n-                        self.visit_ascribe_user_ty(place, variance, c_ty, location);\n+                        self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n                 }\n@@ -637,10 +640,10 @@ macro_rules! make_mir_visitor {\n             fn super_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)* Place<'tcx>,\n                                      _variance: & $($mutability)* ty::Variance,\n-                                     c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                     user_ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n                                      location: Location) {\n                 self.visit_place(place, PlaceContext::Validate, location);\n-                self.visit_user_ty(c_ty);\n+                self.visit_user_type_annotation(user_ty);\n             }\n \n             fn super_place(&mut self,\n@@ -736,7 +739,7 @@ macro_rules! make_mir_visitor {\n                     source_info: *source_info,\n                 });\n                 if let Some((user_ty, _)) = user_ty {\n-                    self.visit_user_ty(user_ty);\n+                    self.visit_user_type_annotation(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n@@ -783,7 +786,10 @@ macro_rules! make_mir_visitor {\n                 self.visit_source_scope(scope);\n             }\n \n-            fn super_canonical_ty(&mut self, _ty: & $($mutability)* CanonicalTy<'tcx>) {\n+            fn super_user_type_annotation(\n+                &mut self,\n+                _ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+            ) {\n             }\n \n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {"}, {"sha": "6f0f258a2175495f217fa5e8ff03fd11bced073b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -33,7 +33,7 @@ use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret};\n use mir::interpret::Allocation;\n-use ty::subst::{CanonicalSubsts, Kind, Substs, Subst};\n+use ty::subst::{CanonicalUserSubsts, Kind, Substs, Subst};\n use ty::ReprOptions;\n use traits;\n use traits::{Clause, Clauses, GoalKind, Goal, Goals};\n@@ -383,7 +383,7 @@ pub struct TypeckTables<'tcx> {\n     /// If the user wrote `foo.collect::<Vec<_>>()`, then the\n     /// canonical substitutions would include only `for<X> { Vec<X>\n     /// }`.\n-    user_substs: ItemLocalMap<CanonicalSubsts<'tcx>>,\n+    user_substs: ItemLocalMap<CanonicalUserSubsts<'tcx>>,\n \n     adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n@@ -573,14 +573,14 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n-    pub fn user_substs_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalSubsts<'tcx>> {\n+    pub fn user_substs_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalUserSubsts<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.user_substs\n         }\n     }\n \n-    pub fn user_substs(&self, id: hir::HirId) -> Option<CanonicalSubsts<'tcx>> {\n+    pub fn user_substs(&self, id: hir::HirId) -> Option<CanonicalUserSubsts<'tcx>> {\n         validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n         self.user_substs.get(&id.local_id).cloned()\n     }"}, {"sha": "64cfba7df6e7d4df3379bcedafd58acf72aaef4c", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 95, "deletions": 27, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -323,33 +323,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-pub type CanonicalSubsts<'gcx> = Canonical<'gcx, &'gcx Substs<'gcx>>;\n-\n-impl<'gcx> CanonicalSubsts<'gcx> {\n-    /// True if this represents a substitution like\n-    ///\n-    /// ```text\n-    /// [?0, ?1, ?2]\n-    /// ```\n-    ///\n-    /// i.e., each thing is mapped to a canonical variable with the same index.\n-    pub fn is_identity(&self) -> bool {\n-        self.value.iter().zip(CanonicalVar::new(0)..).all(|(kind, cvar)| {\n-            match kind.unpack() {\n-                UnpackedKind::Type(ty) => match ty.sty {\n-                    ty::Infer(ty::CanonicalTy(cvar1)) => cvar == cvar1,\n-                    _ => false,\n-                },\n-\n-                UnpackedKind::Lifetime(r) => match r {\n-                    ty::ReCanonical(cvar1) => cvar == *cvar1,\n-                    _ => false,\n-                },\n-            }\n-        })\n-    }\n-}\n-\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -564,3 +537,98 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         self.tcx().mk_region(ty::fold::shift_region(*region, self.region_binders_passed))\n     }\n }\n+\n+pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n+\n+impl CanonicalUserSubsts<'tcx> {\n+    /// True if this represents a substitution like\n+    ///\n+    /// ```text\n+    /// [?0, ?1, ?2]\n+    /// ```\n+    ///\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        if self.value.user_self_ty.is_some() {\n+            return false;\n+        }\n+\n+        self.value.substs.iter().zip(CanonicalVar::new(0)..).all(|(kind, cvar)| {\n+            match kind.unpack() {\n+                UnpackedKind::Type(ty) => match ty.sty {\n+                    ty::Infer(ty::CanonicalTy(cvar1)) => cvar == cvar1,\n+                    _ => false,\n+                },\n+\n+                UnpackedKind::Lifetime(r) => match r {\n+                    ty::ReCanonical(cvar1) => cvar == *cvar1,\n+                    _ => false,\n+                },\n+            }\n+        })\n+    }\n+}\n+\n+/// Stores the user-given substs to reach some fully qualified path\n+/// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct UserSubsts<'tcx> {\n+    /// The substitutions for the item as given by the user.\n+    pub substs: &'tcx Substs<'tcx>,\n+\n+    /// The self-type, in the case of a `<T>::Item` path (when applied\n+    /// to an inherent impl). See `UserSelfTy` below.\n+    pub user_self_ty: Option<UserSelfTy<'tcx>>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for UserSubsts<'tcx> {\n+        substs,\n+        user_self_ty,\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for UserSubsts<'a> {\n+        type Lifted = UserSubsts<'tcx>;\n+        substs,\n+        user_self_ty,\n+    }\n+}\n+\n+/// Specifies the user-given self-type. In the case of a path that\n+/// refers to a member in an inherent impl, this self-type is\n+/// sometimes needed to constrain the type parameters on the impl. For\n+/// example, in this code:\n+///\n+/// ```\n+/// struct Foo<T> { }\n+/// impl<A> Foo<A> { fn method() { } }\n+/// ```\n+///\n+/// when you then have a path like `<Foo<&'static u32>>::method`,\n+/// this struct would carry the def-id of the impl along with the\n+/// self-type `Foo<u32>`. Then we can instantiate the parameters of\n+/// the impl (with the substs from `UserSubsts`) and apply those to\n+/// the self-type, giving `Foo<?A>`. Finally, we unify that with\n+/// the self-type here, which contains `?A` to be `&'static u32`\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct UserSelfTy<'tcx> {\n+    pub impl_def_id: DefId,\n+    pub self_ty: Ty<'tcx>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for UserSelfTy<'tcx> {\n+        impl_def_id,\n+        self_ty,\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for UserSelfTy<'a> {\n+        type Lifted = UserSelfTy<'tcx>;\n+        impl_def_id,\n+        self_ty,\n+    }\n+}"}, {"sha": "30b263a923a7fc3f06f041cbeaa7907fbb03ac4e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -18,9 +18,10 @@ use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n use rustc::mir::{Statement, Terminator};\n+use rustc::mir::UserTypeAnnotation;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, RegionVid};\n+use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -179,7 +180,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         &mut self,\n         _place: &Place<'tcx>,\n         _variance: &ty::Variance,\n-        _c_ty: &CanonicalTy<'tcx>,\n+        _user_ty: &UserTypeAnnotation<'tcx>,\n         _location: Location,\n     ) {\n     }"}, {"sha": "363afb87ed909f7c5654515778f6b4d4e5629409", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{BasicBlock, Location, Mir, Statement, StatementKind};\n+use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n+use rustc::mir::{BasicBlock, Location, Mir, Statement, StatementKind, UserTypeAnnotation};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -65,12 +65,12 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n-    fn visit_user_ty(&mut self, _ty: &mut CanonicalTy<'tcx>) {\n-        // `user_ty` annotations represent the types that the user\n+    fn visit_user_type_annotation(&mut self, _ty: &mut UserTypeAnnotation<'tcx>) {\n+        // User type annotations represent the types that the user\n         // wrote in the progarm. We don't want to erase the regions\n         // from these types: rather, we want to add them as\n         // constraints at type-check time.\n-        debug!(\"visit_user_ty: skipping renumber\");\n+        debug!(\"visit_user_type_annotation: skipping renumber\");\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {"}, {"sha": "1e79bc272e4c0ba687dc58fe02a83375fcefc63a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -43,7 +43,7 @@ use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, UnpackedKind};\n-use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::rc::Rc;\n use std::{fmt, iter};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -966,7 +966,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         a: Ty<'tcx>,\n         v: ty::Variance,\n-        b: CanonicalTy<'tcx>,\n+        b: UserTypeAnnotation<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n@@ -1837,7 +1837,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// If this rvalue supports a user-given type annotation, then\n     /// extract and return it. This represents the final type of the\n     /// rvalue and will be unified with the inferred type.\n-    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<CanonicalTy<'tcx>> {\n+    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotation<'tcx>> {\n         match rvalue {\n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)"}, {"sha": "72120eb18413b92395fea2de045f943a29240bcf", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 73, "deletions": 696, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -10,16 +10,14 @@\n \n use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n-use rustc::infer::canonical::{Canonical, CanonicalVarInfos, CanonicalVarValues};\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n-use rustc::mir::ConstraintCategory;\n+use rustc::mir::{ConstraintCategory, UserTypeAnnotation};\n use rustc::traits::query::Fallible;\n-use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc::ty::subst::Kind;\n-use rustc::ty::{self, CanonicalTy, CanonicalVar, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::ty::relate::TypeRelation;\n+use rustc::ty::subst::{Subst, UserSelfTy, UserSubsts};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use syntax_pos::DUMMY_SP;\n \n /// Adds sufficient constraints to ensure that `a <: b`.\n pub(super) fn sub_types<'tcx>(\n@@ -32,10 +30,9 @@ pub(super) fn sub_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx.tcx,\n+        infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Covariant,\n-        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -51,10 +48,9 @@ pub(super) fn eq_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx.tcx,\n+        infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Invariant,\n-        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -66,128 +62,91 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n     v: ty::Variance,\n-    b: CanonicalTy<'tcx>,\n+    user_ty: UserTypeAnnotation<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<Ty<'tcx>> {\n     debug!(\n-        \"sub_type_and_user_type(a={:?}, b={:?}, locations={:?})\",\n-        a, b, locations\n+        \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n+        a, v, user_ty, locations\n     );\n-    let Canonical {\n-        variables: b_variables,\n-        value: b_value,\n-    } = b;\n \n     // The `TypeRelating` code assumes that the \"canonical variables\"\n     // appear in the \"a\" side, so flip `Contravariant` ambient\n     // variance to get the right relationship.\n     let v1 = ty::Contravariant.xform(v);\n \n     let mut type_relating = TypeRelating::new(\n-        infcx.tcx,\n+        infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v1,\n-        b_variables,\n     );\n-    type_relating.relate(&b_value, &a)?;\n \n-    Ok(b.substitute(\n-        infcx.tcx,\n-        &CanonicalVarValues {\n-            var_values: type_relating\n-                .canonical_var_values\n-                .into_iter()\n-                .map(|x| x.expect(\"unsubstituted canonical variable\"))\n-                .collect(),\n-        },\n-    ))\n-}\n-\n-struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n-\n-    /// Callback to use when we deduce an outlives relationship\n-    delegate: D,\n-\n-    /// How are we relating `a` and `b`?\n-    ///\n-    /// - covariant means `a <: b`\n-    /// - contravariant means `b <: a`\n-    /// - invariant means `a == b\n-    /// - bivariant means that it doesn't matter\n-    ambient_variance: ty::Variance,\n-\n-    /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here.  This\n-    /// will contain the instantiated region for each region in those\n-    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the debruijn index `d` to find the right scope, and then\n-    /// bound region name `br` to find the specific instantiation from\n-    /// within that scope. See `replace_bound_region`.\n-    ///\n-    /// This field stores the instantiations for late-bound regions in\n-    /// the `a` type.\n-    a_scopes: Vec<BoundRegionScope<'tcx>>,\n-\n-    /// Same as `a_scopes`, but for the `b` type.\n-    b_scopes: Vec<BoundRegionScope<'tcx>>,\n-\n-    /// As we execute, the type on the LHS *may* come from a canonical\n-    /// source. In that case, we will sometimes find a constraint like\n-    /// `?0 = B`, where `B` is a type from the RHS. The first time we\n-    /// find that, we simply record `B` (and the list of scopes that\n-    /// tells us how to *interpret* `B`). The next time we encounter\n-    /// `?0`, then, we can read this value out and use it.\n-    ///\n-    /// One problem: these variables may be in some other universe,\n-    /// how can we enforce that? I guess I could add some kind of\n-    /// \"minimum universe constraint\" that we can feed to the NLL checker.\n-    /// --> also, we know this doesn't happen\n-    canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n-}\n-\n-trait TypeRelatingDelegate<'tcx> {\n-    /// Push a constraint `sup: sub` -- this constraint must be\n-    /// satisfied for the two types to be related. `sub` and `sup` may\n-    /// be regions from the type or new variables created through the\n-    /// delegate.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n-\n-    /// Creates a new universe index. Used when instantiating placeholders.\n-    fn create_next_universe(&mut self) -> ty::UniverseIndex;\n+    match user_ty {\n+        UserTypeAnnotation::Ty(canonical_ty) => {\n+            let (ty, _) =\n+                infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n+            type_relating.relate(&ty, &a)?;\n+            Ok(ty)\n+        }\n+        UserTypeAnnotation::FnDef(def_id, canonical_substs) => {\n+            let (\n+                UserSubsts {\n+                    substs,\n+                    user_self_ty,\n+                },\n+                _,\n+            ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n+            let ty = infcx.tcx.mk_fn_def(def_id, substs);\n+\n+            type_relating.relate(&ty, &a)?;\n+\n+            if let Some(UserSelfTy {\n+                impl_def_id,\n+                self_ty,\n+            }) = user_self_ty\n+            {\n+                let impl_self_ty = infcx.tcx.type_of(impl_def_id);\n+                let impl_self_ty = impl_self_ty.subst(infcx.tcx, &substs);\n+\n+                // There may be type variables in `substs` and hence\n+                // in `impl_self_ty`, but they should all have been\n+                // resolved to some fixed value during the first call\n+                // to `relate`, above. Therefore, if we use\n+                // `resolve_type_vars_if_possible` we should get to\n+                // something without type variables. This is important\n+                // because the `b` type in `relate_with_variance`\n+                // below is not permitted to have inference variables.\n+                let impl_self_ty = infcx.resolve_type_vars_if_possible(&impl_self_ty);\n+                assert!(!impl_self_ty.has_infer_types());\n+\n+                type_relating.relate_with_variance(\n+                    ty::Variance::Invariant,\n+                    &self_ty,\n+                    &impl_self_ty,\n+                )?;\n+            }\n \n-    /// Creates a new region variable representing a higher-ranked\n-    /// region that is instantiated existentially. This creates an\n-    /// inference variable, typically.\n-    ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n-    /// we will invoke this method to instantiate `'a` with an\n-    /// inference variable (though `'b` would be instantiated first,\n-    /// as a placeholder).\n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n+            Ok(ty)\n+        }\n+        UserTypeAnnotation::AdtDef(adt_def, canonical_substs) => {\n+            let (\n+                UserSubsts {\n+                    substs,\n+                    user_self_ty,\n+                },\n+                _,\n+            ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n \n-    /// Creates a new region variable representing a\n-    /// higher-ranked region that is instantiated universally.\n-    /// This creates a new region placeholder, typically.\n-    ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n-    /// we will invoke this method to instantiate `'b` with a\n-    /// placeholder region.\n-    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx>;\n+            // We don't extract adt-defs with a self-type.\n+            assert!(user_self_ty.is_none());\n \n-    /// Creates a new existential region in the given universe. This\n-    /// is used when handling subtyping and type variables -- if we\n-    /// have that `?X <: Foo<'a>`, for example, we would instantiate\n-    /// `?X` with a type like `Foo<'?0>` where `'?0` is a fresh\n-    /// existential variable created by this function. We would then\n-    /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n-    /// relation stating that `'?0: 'a`).\n-    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+            let ty = infcx.tcx.mk_adt(adt_def, substs);\n+            type_relating.relate(&ty, &a)?;\n+            Ok(ty)\n+        }\n+    }\n }\n \n struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n@@ -256,585 +215,3 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n         }\n     }\n }\n-\n-#[derive(Clone, Debug)]\n-struct ScopesAndKind<'tcx> {\n-    scopes: Vec<BoundRegionScope<'tcx>>,\n-    kind: Kind<'tcx>,\n-}\n-\n-#[derive(Clone, Debug, Default)]\n-struct BoundRegionScope<'tcx> {\n-    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n-}\n-\n-#[derive(Copy, Clone)]\n-struct UniversallyQuantified(bool);\n-\n-impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn new(\n-        tcx: TyCtxt<'me, 'gcx, 'tcx>,\n-        delegate: D,\n-        ambient_variance: ty::Variance,\n-        canonical_var_infos: CanonicalVarInfos<'tcx>,\n-    ) -> Self {\n-        let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n-        Self {\n-            tcx,\n-            delegate,\n-            ambient_variance,\n-            canonical_var_values,\n-            a_scopes: vec![],\n-            b_scopes: vec![],\n-        }\n-    }\n-\n-    fn ambient_covariance(&self) -> bool {\n-        match self.ambient_variance {\n-            ty::Variance::Covariant | ty::Variance::Invariant => true,\n-            ty::Variance::Contravariant | ty::Variance::Bivariant => false,\n-        }\n-    }\n-\n-    fn ambient_contravariance(&self) -> bool {\n-        match self.ambient_variance {\n-            ty::Variance::Contravariant | ty::Variance::Invariant => true,\n-            ty::Variance::Covariant | ty::Variance::Bivariant => false,\n-        }\n-    }\n-\n-    fn create_scope(\n-        &mut self,\n-        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> BoundRegionScope<'tcx> {\n-        let mut scope = BoundRegionScope::default();\n-\n-        // Create a callback that creates (via the delegate) either an\n-        // existential or placeholder region as needed.\n-        let mut next_region = {\n-            let delegate = &mut self.delegate;\n-            let mut lazy_universe = None;\n-            move |br: ty::BoundRegion| {\n-                if universally_quantified.0 {\n-                    // The first time this closure is called, create a\n-                    // new universe for the placeholders we will make\n-                    // from here out.\n-                    let universe = lazy_universe.unwrap_or_else(|| {\n-                        let universe = delegate.create_next_universe();\n-                        lazy_universe = Some(universe);\n-                        universe\n-                    });\n-\n-                    let placeholder = ty::Placeholder { universe, name: br };\n-                    delegate.next_placeholder_region(placeholder)\n-                } else {\n-                    delegate.next_existential_region_var()\n-                }\n-            }\n-        };\n-\n-        value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            next_region: &mut next_region,\n-            target_index: ty::INNERMOST,\n-            bound_region_scope: &mut scope,\n-        });\n-\n-        scope\n-    }\n-\n-    /// When we encounter binders during the type traversal, we record\n-    /// the value to substitute for each of the things contained in\n-    /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the debruijn index\n-    /// `debruijn` (and name `br`) of some binder we have now\n-    /// encountered, this routine finds the value that we instantiated\n-    /// the region with; to do so, it indexes backwards into the list\n-    /// of ambient scopes `scopes`.\n-    fn lookup_bound_region(\n-        debruijn: ty::DebruijnIndex,\n-        br: &ty::BoundRegion,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        // The debruijn index is a \"reverse index\" into the\n-        // scopes listing. So when we have INNERMOST (0), we\n-        // want the *last* scope pushed, and so forth.\n-        let debruijn_index = debruijn.index() - first_free_index.index();\n-        let scope = &scopes[scopes.len() - debruijn_index - 1];\n-\n-        // Find this bound region in that scope to map to a\n-        // particular region.\n-        scope.map[br]\n-    }\n-\n-    /// If `r` is a bound region, find the scope in which it is bound\n-    /// (from `scopes`) and return the value that we instantiated it\n-    /// with. Otherwise just return `r`.\n-    fn replace_bound_region(\n-        &self,\n-        r: ty::Region<'tcx>,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        if let ty::ReLateBound(debruijn, br) = r {\n-            Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n-        } else {\n-            r\n-        }\n-    }\n-\n-    /// Push a new outlives requirement into our output set of\n-    /// constraints.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n-        debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n-\n-        self.delegate.push_outlives(sup, sub);\n-    }\n-\n-    /// When we encounter a canonical variable `var` in the output,\n-    /// equate it with `kind`. If the variable has been previously\n-    /// equated, then equate it again.\n-    fn relate_var(\n-        &mut self,\n-        var: CanonicalVar,\n-        b_kind: Kind<'tcx>,\n-    ) -> RelateResult<'tcx, Kind<'tcx>> {\n-        debug!(\"equate_var(var={:?}, b_kind={:?})\", var, b_kind);\n-\n-        let generalized_kind = match self.canonical_var_values[var] {\n-            Some(v) => v,\n-            None => {\n-                let generalized_kind = self.generalize_value(b_kind);\n-                self.canonical_var_values[var] = Some(generalized_kind);\n-                generalized_kind\n-            }\n-        };\n-\n-        // The generalized values we extract from `canonical_var_values` have\n-        // been fully instantiated and hence the set of scopes we have\n-        // doesn't matter -- just to be sure, put an empty vector\n-        // in there.\n-        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n-\n-        // Relate the generalized kind to the original one.\n-        let result = self.relate(&generalized_kind, &b_kind);\n-\n-        // Restore the old scopes now.\n-        self.a_scopes = old_a_scopes;\n-\n-        debug!(\"equate_var: complete, result = {:?}\", result);\n-        return result;\n-    }\n-\n-    fn generalize_value(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n-        TypeGeneralizer {\n-            tcx: self.tcx,\n-            delegate: &mut self.delegate,\n-            first_free_index: ty::INNERMOST,\n-            ambient_variance: self.ambient_variance,\n-\n-            // These always correspond to an `_` or `'_` written by\n-            // user, and those are always in the root universe.\n-            universe: ty::UniverseIndex::ROOT,\n-        }.relate(&kind, &kind)\n-            .unwrap()\n-    }\n-}\n-\n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"nll::subtype\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n-    ) -> RelateResult<'tcx, T> {\n-        debug!(\n-            \"relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n-            variance, a, b\n-        );\n-\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        debug!(\n-            \"relate_with_variance: ambient_variance = {:?}\",\n-            self.ambient_variance\n-        );\n-\n-        let r = self.relate(a, b)?;\n-\n-        self.ambient_variance = old_ambient_variance;\n-\n-        debug!(\"relate_with_variance: r={:?}\", r);\n-\n-        Ok(r)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        // Watch out for the case that we are matching a `?T` against the\n-        // right-hand side.\n-        if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n-            self.relate_var(var, b.into())?;\n-            Ok(a)\n-        } else {\n-            debug!(\n-                \"tys(a={:?}, b={:?}, variance={:?})\",\n-                a, b, self.ambient_variance\n-            );\n-\n-            relate::super_relate_tys(self, a, b)\n-        }\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        if let ty::ReCanonical(var) = a {\n-            self.relate_var(*var, b.into())?;\n-            return Ok(a);\n-        }\n-\n-        debug!(\n-            \"regions(a={:?}, b={:?}, variance={:?})\",\n-            a, b, self.ambient_variance\n-        );\n-\n-        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n-        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n-\n-        debug!(\"regions: v_a = {:?}\", v_a);\n-        debug!(\"regions: v_b = {:?}\", v_b);\n-\n-        if self.ambient_covariance() {\n-            // Covariance: a <= b. Hence, `b: a`.\n-            self.push_outlives(v_b, v_a);\n-        }\n-\n-        if self.ambient_contravariance() {\n-            // Contravariant: b <= a. Hence, `a: b`.\n-            self.push_outlives(v_a, v_b);\n-        }\n-\n-        Ok(a)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        // We want that\n-        //\n-        // ```\n-        // for<'a> fn(&'a u32) -> &'a u32 <:\n-        //   fn(&'b u32) -> &'b u32\n-        // ```\n-        //\n-        // but not\n-        //\n-        // ```\n-        // fn(&'a u32) -> &'a u32 <:\n-        //   for<'b> fn(&'b u32) -> &'b u32\n-        // ```\n-        //\n-        // We therefore proceed as follows:\n-        //\n-        // - Instantiate binders on `b` universally, yielding a universe U1.\n-        // - Instantiate binders on `a` existentially in U1.\n-\n-        debug!(\n-            \"binders({:?}: {:?}, ambient_variance={:?})\",\n-            a, b, self.ambient_variance\n-        );\n-\n-        if self.ambient_covariance() {\n-            // Covariance, so we want `for<..> A <: for<..> B` --\n-            // therefore we compare any instantiation of A (i.e., A\n-            // instantiated with existentials) against every\n-            // instantiation of B (i.e., B instantiated with\n-            // universals).\n-\n-            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n-            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n-\n-            debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n-            debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n-\n-            self.b_scopes.push(b_scope);\n-            self.a_scopes.push(a_scope);\n-\n-            // Reset the ambient variance to covariant. This is needed\n-            // to correctly handle cases like\n-            //\n-            //     for<'a> fn(&'a u32, &'a u3) == for<'b, 'c> fn(&'b u32, &'c u32)\n-            //\n-            // Somewhat surprisingly, these two types are actually\n-            // **equal**, even though the one on the right looks more\n-            // polymorphic. The reason is due to subtyping. To see it,\n-            // consider that each function can call the other:\n-            //\n-            // - The left function can call the right with `'b` and\n-            //   `'c` both equal to `'a`\n-            //\n-            // - The right function can call the left with `'a` set to\n-            //   `{P}`, where P is the point in the CFG where the call\n-            //   itself occurs. Note that `'b` and `'c` must both\n-            //   include P. At the point, the call works because of\n-            //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n-            let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n-\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-\n-            self.ambient_variance = variance;\n-\n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n-        }\n-\n-        if self.ambient_contravariance() {\n-            // Contravariance, so we want `for<..> A :> for<..> B`\n-            // -- therefore we compare every instantiation of A (i.e.,\n-            // A instantiated with universals) against any\n-            // instantiation of B (i.e., B instantiated with\n-            // existentials). Opposite of above.\n-\n-            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n-            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n-\n-            debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n-            debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n-\n-            self.a_scopes.push(a_scope);\n-            self.b_scopes.push(b_scope);\n-\n-            // Reset ambient variance to contravariance. See the\n-            // covariant case above for an explanation.\n-            let variance =\n-                ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n-\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-\n-            self.ambient_variance = variance;\n-\n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n-        }\n-\n-        Ok(a.clone())\n-    }\n-}\n-\n-/// When we encounter a binder like `for<..> fn(..)`, we actually have\n-/// to walk the `fn` value to find all the values bound by the `for`\n-/// (these are not explicitly present in the ty representation right\n-/// now). This visitor handles that: it descends the type, tracking\n-/// binder depth, and finds late-bound regions targeting the\n-/// `for<..`>.  For each of those, it creates an entry in\n-/// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'tcx: 'me> {\n-    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-    // The debruijn index of the scope we are instantiating.\n-    target_index: ty::DebruijnIndex,\n-    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n-}\n-\n-impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        self.target_index.shift_in(1);\n-        t.super_visit_with(self);\n-        self.target_index.shift_out(1);\n-\n-        false\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        let ScopeInstantiator {\n-            bound_region_scope,\n-            next_region,\n-            ..\n-        } = self;\n-\n-        match r {\n-            ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n-                bound_region_scope\n-                    .map\n-                    .entry(*br)\n-                    .or_insert_with(|| next_region(*br));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-}\n-\n-/// The \"type generalize\" is used when handling inference variables.\n-///\n-/// The basic strategy for handling a constraint like `?A <: B` is to\n-/// apply a \"generalization strategy\" to the type `B` -- this replaces\n-/// all the lifetimes in the type `B` with fresh inference\n-/// variables. (You can read more about the strategy in this [blog\n-/// post].)\n-///\n-/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n-/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n-/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n-/// establishes `'0: 'x` as a constraint.\n-///\n-/// As a side-effect of this generalization procedure, we also replace\n-/// all the bound regions that we have traversed with concrete values,\n-/// so that the resulting generalized type is independent from the\n-/// scopes.\n-///\n-/// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n-where\n-    D: TypeRelatingDelegate<'tcx> + 'me,\n-{\n-    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n-\n-    delegate: &'me mut D,\n-\n-    /// After we generalize this type, we are going to relative it to\n-    /// some other type. What will be the variance at this point?\n-    ambient_variance: ty::Variance,\n-\n-    first_free_index: ty::DebruijnIndex,\n-\n-    universe: ty::UniverseIndex,\n-}\n-\n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"nll::generalizer\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n-    ) -> RelateResult<'tcx, T> {\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n-            variance, a, b\n-        );\n-\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n-            self.ambient_variance\n-        );\n-\n-        let r = self.relate(a, b)?;\n-\n-        self.ambient_variance = old_ambient_variance;\n-\n-        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n-\n-        Ok(r)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n-\n-        match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n-                bug!(\n-                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n-                    a\n-                );\n-            }\n-\n-            _ => relate::super_relate_tys(self, a, a),\n-        }\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        _: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n-\n-        if let ty::ReLateBound(debruijn, _) = a {\n-            if *debruijn < self.first_free_index {\n-                return Ok(a);\n-            }\n-        }\n-\n-        // For now, we just always create a fresh region variable to\n-        // replace all the regions in the source type. In the main\n-        // type checker, we special case the case where the ambient\n-        // variance is `Invariant` and try to avoid creating a fresh\n-        // region variable, but since this comes up so much less in\n-        // NLL (only when users use `_` etc) it is much less\n-        // important.\n-        //\n-        // As an aside, since these new variables are created in\n-        // `self.universe` universe, this also serves to enforce the\n-        // universe scoping rules.\n-        //\n-        // FIXME(#54105) -- if the ambient variance is bivariant,\n-        // though, we may however need to check well-formedness or\n-        // risk a problem like #41677 again.\n-\n-        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n-\n-        Ok(replacement_region_vid)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: &ty::Binder<T>,\n-        _: &ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n-\n-        self.first_free_index.shift_in(1);\n-        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n-        self.first_free_index.shift_out(1);\n-        Ok(ty::Binder::bind(result))\n-    }\n-}"}, {"sha": "99c0a52a8ee36c91c56380b6d4882452f6fc9098", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -20,7 +20,7 @@ use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use hair::*;\n use rustc::hir;\n use rustc::mir::*;\n-use rustc::ty::{self, CanonicalTy, Ty};\n+use rustc::ty::{self, Ty};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Name, NodeId};\n@@ -491,7 +491,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn visit_bindings(\n         &mut self,\n         pattern: &Pattern<'tcx>,\n-        mut pattern_user_ty: Option<(CanonicalTy<'tcx>, Span)>,\n+        mut pattern_user_ty: Option<(UserTypeAnnotation<'tcx>, Span)>,\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n@@ -500,7 +500,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             NodeId,\n             Span,\n             Ty<'tcx>,\n-            Option<(CanonicalTy<'tcx>, Span)>,\n+            Option<(UserTypeAnnotation<'tcx>, Span)>,\n         ),\n     ) {\n         match *pattern.kind {\n@@ -626,7 +626,7 @@ struct Binding<'tcx> {\n struct Ascription<'tcx> {\n     span: Span,\n     source: Place<'tcx>,\n-    user_ty: CanonicalTy<'tcx>,\n+    user_ty: UserTypeAnnotation<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n@@ -1470,7 +1470,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         num_patterns: usize,\n         var_id: NodeId,\n         var_ty: Ty<'tcx>,\n-        user_var_ty: Option<(CanonicalTy<'tcx>, Span)>,\n+        user_var_ty: Option<(UserTypeAnnotation<'tcx>, Span)>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,"}, {"sha": "9865867a196ca3b34f5899cf6b6bc6e7eb0ba472", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -86,12 +86,12 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         let mut pattern = cx.pattern_from_hir(&local.pat);\n \n                         if let Some(ty) = &local.ty {\n-                            if let Some(user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n+                            if let Some(&user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n                                 pattern = Pattern {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n                                     kind: Box::new(PatternKind::AscribeUserType {\n-                                        user_ty: *user_ty,\n+                                        user_ty: UserTypeAnnotation::Ty(user_ty),\n                                         user_ty_span: ty.span,\n                                         subpattern: pattern\n                                     })"}, {"sha": "56a29f29d685f091eb72a962320c05fda3b1dbe6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -295,13 +295,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     let substs = cx.tables().node_substs(fun.hir_id);\n \n                     let user_ty = cx.tables().user_substs(fun.hir_id)\n-                        .map(|user_substs| {\n-                            user_substs.unchecked_map(|user_substs| {\n-                                // Here, we just pair an `AdtDef` with the\n-                                // `user_substs`, so no new types etc are introduced.\n-                                cx.tcx().mk_adt(adt_def, user_substs)\n-                            })\n-                        });\n+                        .map(|user_substs| UserTypeAnnotation::AdtDef(adt_def, user_substs));\n \n                     let field_refs = args.iter()\n                         .enumerate()\n@@ -725,9 +719,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {\n             let user_provided_tys = cx.tables.user_provided_tys();\n-            let user_ty = *user_provided_tys\n-                .get(ty.hir_id)\n-                .expect(&format!(\"{:?} not found in user_provided_tys, source: {:?}\", ty, source));\n+            let user_ty = UserTypeAnnotation::Ty(\n+                *user_provided_tys\n+                    .get(ty.hir_id)\n+                    .expect(&format!(\n+                        \"{:?} not found in user_provided_tys, source: {:?}\",\n+                        ty,\n+                        source,\n+                    ))\n+            );\n             if source.is_place_expr() {\n                 ExprKind::PlaceTypeAscription {\n                     source: source.to_ref(),\n@@ -759,11 +759,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn user_annotated_ty_for_def(\n+fn user_substs_applied_to_def(\n     cx: &mut Cx<'a, 'gcx, 'tcx>,\n     hir_id: hir::HirId,\n     def: &Def,\n-) -> Option<CanonicalTy<'tcx>> {\n+) -> Option<UserTypeAnnotation<'tcx>> {\n     match def {\n         // A reference to something callable -- e.g., a fn, method, or\n         // a tuple-struct or tuple-variant. This has the type of a\n@@ -772,11 +772,7 @@ fn user_annotated_ty_for_def(\n         Def::Method(_) |\n         Def::StructCtor(_, CtorKind::Fn) |\n         Def::VariantCtor(_, CtorKind::Fn) =>\n-            Some(cx.tables().user_substs(hir_id)?.unchecked_map(|user_substs| {\n-                // Here, we just pair a `DefId` with the\n-                // `user_substs`, so no new types etc are introduced.\n-                cx.tcx().mk_fn_def(def.def_id(), user_substs)\n-            })),\n+            Some(UserTypeAnnotation::FnDef(def.def_id(), cx.tables().user_substs(hir_id)?)),\n \n         Def::Const(_def_id) |\n         Def::AssociatedConst(_def_id) =>\n@@ -795,7 +791,7 @@ fn user_annotated_ty_for_def(\n             cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n \n         _ =>\n-            bug!(\"user_annotated_ty_for_def: unexpected def {:?} at {:?}\", def, hir_id)\n+            bug!(\"user_substs_applied_to_def: unexpected def {:?} at {:?}\", def, hir_id)\n     }\n }\n \n@@ -815,7 +811,7 @@ fn method_callee<'a, 'gcx, 'tcx>(\n                 .unwrap_or_else(|| {\n                     span_bug!(expr.span, \"no type-dependent def for method callee\")\n                 });\n-            let user_ty = user_annotated_ty_for_def(cx, expr.hir_id, def);\n+            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, def);\n             (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n     };\n@@ -882,7 +878,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::StructCtor(_, CtorKind::Fn) |\n         Def::VariantCtor(_, CtorKind::Fn) |\n         Def::SelfCtor(..) => {\n-            let user_ty = user_annotated_ty_for_def(cx, expr.hir_id, &def);\n+            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             ExprKind::Literal {\n                 literal: ty::Const::zero_sized(\n                     cx.tcx,"}, {"sha": "781b6c92aa13a859b00691c0bf1baa68606b8d97", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -14,11 +14,11 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::{BinOp, BorrowKind, Field, UnOp};\n+use rustc::mir::{BinOp, BorrowKind, UserTypeAnnotation, Field, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, CanonicalTy, UpvarSubsts, Region, Ty, Const};\n+use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const};\n use rustc::hir;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -268,20 +268,20 @@ pub enum ExprKind<'tcx> {\n \n         /// Optional user-given substs: for something like `let x =\n         /// Bar::<T> { ... }`.\n-        user_ty: Option<CanonicalTy<'tcx>>,\n+        user_ty: Option<UserTypeAnnotation<'tcx>>,\n \n         fields: Vec<FieldExprRef<'tcx>>,\n         base: Option<FruInfo<'tcx>>\n     },\n     PlaceTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: CanonicalTy<'tcx>,\n+        user_ty: UserTypeAnnotation<'tcx>,\n     },\n     ValueTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: CanonicalTy<'tcx>,\n+        user_ty: UserTypeAnnotation<'tcx>,\n     },\n     Closure {\n         closure_id: DefId,\n@@ -291,13 +291,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,\n-\n-        /// Optional user-given type: for something like\n-        /// `collect::<Vec<_>>`, this would be present and would\n-        /// indicate that `Vec<_>` was explicitly specified.\n-        ///\n-        /// Needed for NLL to impose user-given type constraints.\n-        user_ty: Option<CanonicalTy<'tcx>>,\n+        user_ty: Option<UserTypeAnnotation<'tcx>>,\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,"}, {"sha": "cb974366a3029b7560f86c72f0379f735e00db0c", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -20,9 +20,9 @@ use const_eval::{const_field, const_variant_index};\n \n use hair::util::UserAnnotatedTyHelpers;\n \n-use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n+use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability, UserTypeAnnotation};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, CanonicalTy, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -69,7 +69,7 @@ pub enum PatternKind<'tcx> {\n     Wild,\n \n     AscribeUserType {\n-        user_ty: CanonicalTy<'tcx>,\n+        user_ty: UserTypeAnnotation<'tcx>,\n         subpattern: Pattern<'tcx>,\n         user_ty_span: Span,\n     },\n@@ -980,7 +980,7 @@ macro_rules! CloneImpls {\n CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n-    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, CanonicalTy<'tcx>\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, UserTypeAnnotation<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {"}, {"sha": "71cbac6b7c88e7d4d97b1735112779658f8d7b44", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::ty::{self, AdtDef, CanonicalTy, TyCtxt};\n+use rustc::mir::UserTypeAnnotation;\n+use rustc::ty::{self, AdtDef, TyCtxt};\n \n crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx>;\n@@ -20,32 +21,22 @@ crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n         &self,\n         hir_id: hir::HirId,\n         adt_def: &'tcx AdtDef,\n-    ) -> Option<CanonicalTy<'tcx>> {\n+    ) -> Option<UserTypeAnnotation<'tcx>> {\n         let user_substs = self.tables().user_substs(hir_id)?;\n-        Some(user_substs.unchecked_map(|user_substs| {\n-            // Here, we just pair an `AdtDef` with the\n-            // `user_substs`, so no new types etc are introduced.\n-            self.tcx().mk_adt(adt_def, user_substs)\n-        }))\n+        Some(UserTypeAnnotation::AdtDef(adt_def, user_substs))\n     }\n \n     /// Looks up the type associated with this hir-id and applies the\n     /// user-given substitutions; the hir-id must map to a suitable\n     /// type.\n-    fn user_substs_applied_to_ty_of_hir_id(&self, hir_id: hir::HirId) -> Option<CanonicalTy<'tcx>> {\n+    fn user_substs_applied_to_ty_of_hir_id(\n+        &self,\n+        hir_id: hir::HirId,\n+    ) -> Option<UserTypeAnnotation<'tcx>> {\n         let user_substs = self.tables().user_substs(hir_id)?;\n         match &self.tables().node_id_to_type(hir_id).sty {\n-            ty::Adt(adt_def, _) => Some(user_substs.unchecked_map(|user_substs| {\n-                // Ok to call `unchecked_map` because we just pair an\n-                // `AdtDef` with the `user_substs`, so no new types\n-                // etc are introduced.\n-                self.tcx().mk_adt(adt_def, user_substs)\n-            })),\n-            ty::FnDef(def_id, _) => Some(user_substs.unchecked_map(|user_substs| {\n-                // Here, we just pair a `DefId` with the\n-                // `user_substs`, so no new types etc are introduced.\n-                self.tcx().mk_fn_def(*def_id, user_substs)\n-            })),\n+            ty::Adt(adt_def, _) => Some(UserTypeAnnotation::AdtDef(adt_def, user_substs)),\n+            ty::FnDef(def_id, _) => Some(UserTypeAnnotation::FnDef(*def_id, user_substs)),\n             sty => bug!(\n                 \"sty: {:?} should not have user-substs {:?} recorded \",\n                 sty,"}, {"sha": "14ce1bb4ccdee9c00c0c08ca6774d0643c3656be", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -95,7 +95,8 @@ use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n-use rustc::ty::subst::{CanonicalSubsts, UnpackedKind, Subst, Substs};\n+use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n+                       UserSelfTy, UserSubsts};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate, RegionKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -2136,7 +2137,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             method.substs[i]\n                         }\n                     });\n-                    self.infcx.canonicalize_response(&just_method_substs)\n+                    self.infcx.canonicalize_response(&UserSubsts {\n+                        substs: just_method_substs,\n+                        user_self_ty: None, // not relevant here\n+                    })\n                 });\n \n                 debug!(\"write_method_call: user_substs = {:?}\", user_substs);\n@@ -2163,7 +2167,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This should be invoked **before any unifications have\n     /// occurred**, so that annotations like `Vec<_>` are preserved\n     /// properly.\n-    pub fn write_user_substs_from_substs(&self, hir_id: hir::HirId, substs: &'tcx Substs<'tcx>) {\n+    pub fn write_user_substs_from_substs(\n+        &self,\n+        hir_id: hir::HirId,\n+        substs: &'tcx Substs<'tcx>,\n+        user_self_ty: Option<UserSelfTy<'tcx>>,\n+    ) {\n         debug!(\n             \"write_user_substs_from_substs({:?}, {:?}) in fcx {}\",\n             hir_id,\n@@ -2172,13 +2181,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         if !substs.is_noop() {\n-            let user_substs = self.infcx.canonicalize_response(&substs);\n+            let user_substs = self.infcx.canonicalize_response(&UserSubsts {\n+                substs,\n+                user_self_ty,\n+            });\n             debug!(\"instantiate_value_path: user_substs = {:?}\", user_substs);\n             self.write_user_substs(hir_id, user_substs);\n         }\n     }\n \n-    pub fn write_user_substs(&self, hir_id: hir::HirId, substs: CanonicalSubsts<'tcx>) {\n+    pub fn write_user_substs(&self, hir_id: hir::HirId, substs: CanonicalUserSubsts<'tcx>) {\n         debug!(\n             \"write_user_substs({:?}, {:?}) in fcx {}\",\n             hir_id,\n@@ -3617,7 +3629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n             let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-            self.write_user_substs_from_substs(hir_id, substs);\n+            self.write_user_substs_from_substs(hir_id, substs, None);\n \n             // Check bounds on type arguments used in the path.\n             let bounds = self.instantiate_bounds(path_span, did, substs);\n@@ -5005,7 +5017,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let path_segs = self.def_ids_for_path_segments(segments, def);\n \n-        let mut ufcs_associated = None;\n+        let mut user_self_ty = None;\n         match def {\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n@@ -5014,12 +5026,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(self.tcx, span, trait_did)\n                     }\n-                    ty::ImplContainer(_) => {}\n-                }\n-                if segments.len() == 1 {\n-                    // `<T>::assoc` will end up here, and so can `T::assoc`.\n-                    let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n-                    ufcs_associated = Some((container, self_ty));\n+                    ty::ImplContainer(impl_def_id) => {\n+                        if segments.len() == 1 {\n+                            // `<T>::assoc` will end up here, and so\n+                            // can `T::assoc`. It this came from an\n+                            // inherent impl, we need to record the\n+                            // `T` for posterity (see `UserSelfTy` for\n+                            // details).\n+                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n+                            user_self_ty = Some(UserSelfTy {\n+                                impl_def_id,\n+                                self_ty,\n+                            });\n+                        }\n+                    }\n                 }\n             }\n             _ => {}\n@@ -5173,6 +5193,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!substs.has_escaping_regions());\n         assert!(!ty.has_escaping_regions());\n \n+        // Write the \"user substs\" down first thing for later.\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n+\n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n         let bounds = self.instantiate_bounds(span, def_id, &substs);\n@@ -5184,7 +5208,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // the referenced item.\n         let ty_substituted = self.instantiate_type_scheme(span, &substs, &ty);\n \n-        if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n+        if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n             // is inherent, there is no `Self` parameter, instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n@@ -5208,16 +5232,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n         self.write_substs(hir_id, substs);\n \n-        debug!(\n-            \"instantiate_value_path: id={:?} substs={:?}\",\n-            node_id,\n-            substs,\n-        );\n-        self.write_user_substs_from_substs(hir_id, substs);\n-\n         (ty_substituted, new_def)\n     }\n "}, {"sha": "64e574fa8aee01819b8cb037ff7fcc45dae339d2", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -56,7 +56,7 @@ fn main() {\n //        StorageLive(_4);\n //        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> });\n+//        AscribeUserType(_4, o, Ty(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }));\n //        StorageLive(_5);\n //        StorageLive(_6);\n //        _6 = move _4;"}, {"sha": "901ace59d33a04c75320af5150fe6a485e31f67c", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -1,4 +1,4 @@\n-error: user substs: Canonical { variables: [], value: [u32] }\n+error: user substs: Canonical { variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n   --> $DIR/dump-adt-brace-struct.rs:28:5\n    |\n LL |     SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]"}, {"sha": "a26be359fc4aa4c28ed9b608c31d6604a727483d", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -1,22 +1,22 @@\n-error: user substs: Canonical { variables: [], value: [u32] }\n+error: user substs: Canonical { variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:36:13\n    |\n LL |     let x = foo::<u32>; //~ ERROR [u32]\n    |             ^^^^^^^^^^\n \n-error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: [?0, u32, ?1] }\n+error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, u32, ?1], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:42:13\n    |\n LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { variables: [], value: [u8, u16, u32] }\n+error: user substs: Canonical { variables: [], value: UserSubsts { substs: [u8, u16, u32], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:46:13\n    |\n LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: [?0, ?1, u32] }\n+error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, ?1, u32], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:54:5\n    |\n LL |     y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]"}, {"sha": "b7292c0acbe1ad2a7da829453558857dc5e46b9c", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-1.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-1.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,20 @@\n+#![feature(nll)]\n+\n+// Check that substitutions given on the self type (here, `A`) carry\n+// through to NLL.\n+\n+struct A<'a> { x: &'a u32 }\n+\n+impl<'a> A<'a> {\n+    fn new<'b, T>(x: &'a u32, y: T) -> Self {\n+        Self { x }\n+    }\n+}\n+\n+fn foo<'a>() {\n+    let v = 22;\n+    let x = A::<'a>::new(&v, 22);\n+    //~^ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "aa133ce286d51f7f6f9deac228fc88fd5c889d37", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-1.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-1.stderr?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/method-ufcs-inherent-1.rs:16:26\n+   |\n+LL |     let x = A::<'a>::new(&v, 22);\n+   |                          ^^ borrowed value does not live long enough\n+LL |     //~^ ERROR\n+LL | }\n+   | - `v` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 14:8...\n+  --> $DIR/method-ufcs-inherent-1.rs:14:8\n+   |\n+LL | fn foo<'a>() {\n+   |        ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "a77d6af5323c2c5b6d0cdaea77e7e50a694ef9a9", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-2.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,21 @@\n+#![feature(nll)]\n+\n+// Check that substitutions given on the self type (here, `A`) can be\n+// used in combination with annotations given for method arguments.\n+\n+struct A<'a> { x: &'a u32 }\n+\n+impl<'a> A<'a> {\n+    fn new<'b, T>(x: &'a u32, y: T) -> Self {\n+        Self { x }\n+    }\n+}\n+\n+fn foo<'a>() {\n+    let v = 22;\n+    let x = A::<'a>::new::<&'a u32>(&v, &v);\n+    //~^ ERROR\n+    //~| ERROR\n+}\n+\n+fn main() {}"}, {"sha": "f1f4787d05869f90831eb3f166fea9a1ab02ac1e", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-2.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-2.stderr?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,33 @@\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/method-ufcs-inherent-2.rs:16:37\n+   |\n+LL |     let x = A::<'a>::new::<&'a u32>(&v, &v);\n+   |                                     ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `v` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 14:8...\n+  --> $DIR/method-ufcs-inherent-2.rs:14:8\n+   |\n+LL | fn foo<'a>() {\n+   |        ^^\n+\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/method-ufcs-inherent-2.rs:16:41\n+   |\n+LL |     let x = A::<'a>::new::<&'a u32>(&v, &v);\n+   |                                         ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `v` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 14:8...\n+  --> $DIR/method-ufcs-inherent-2.rs:14:8\n+   |\n+LL | fn foo<'a>() {\n+   |        ^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "24d83c468f4f8cf5b332f5f6fc9f1ad06d597a59", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-3.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,20 @@\n+#![feature(nll)]\n+\n+// Check that inherent methods invoked with `<T>::new` style\n+// carry their annotations through to NLL.\n+\n+struct A<'a> { x: &'a u32 }\n+\n+impl<'a> A<'a> {\n+    fn new<'b, T>(x: &'a u32, y: T) -> Self {\n+        Self { x }\n+    }\n+}\n+\n+fn foo<'a>() {\n+    let v = 22;\n+    let x = <A<'a>>::new(&v, 22);\n+    //~^ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "f3766a8c8e52d6fdda448f3b618420990f6ccdfb", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-3.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-3.stderr?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/method-ufcs-inherent-3.rs:16:26\n+   |\n+LL |     let x = <A<'a>>::new(&v, 22);\n+   |                          ^^ borrowed value does not live long enough\n+LL |     //~^ ERROR\n+LL | }\n+   | - `v` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 14:8...\n+  --> $DIR/method-ufcs-inherent-3.rs:14:8\n+   |\n+LL | fn foo<'a>() {\n+   |        ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "3f88c3df48e006640a373f0694c44304819294a5", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-4.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-4.rs?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,22 @@\n+#![feature(nll)]\n+\n+// Check that inherent methods invoked with `<T>::new` style\n+// carry their annotations through to NLL in connection with\n+// method type parameters.\n+\n+struct A<'a> { x: &'a u32 }\n+\n+impl<'a> A<'a> {\n+    fn new<'b, T>(x: &'a u32, y: T) -> Self {\n+        Self { x }\n+    }\n+}\n+\n+fn foo<'a>() {\n+    let v = 22;\n+    let x = <A<'a>>::new::<&'a u32>(&v, &v);\n+    //~^ ERROR\n+    //~| ERROR\n+}\n+\n+fn main() {}"}, {"sha": "c9bce5077d62960bd9db1d8b358bbe1df0acbba7", "filename": "src/test/ui/nll/user-annotations/method-ufcs-inherent-4.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ca85becd45a4115bd5a1b367a1667c06f0906b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-inherent-4.stderr?ref=01ca85becd45a4115bd5a1b367a1667c06f0906b", "patch": "@@ -0,0 +1,33 @@\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/method-ufcs-inherent-4.rs:17:37\n+   |\n+LL |     let x = <A<'a>>::new::<&'a u32>(&v, &v);\n+   |                                     ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `v` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 15:8...\n+  --> $DIR/method-ufcs-inherent-4.rs:15:8\n+   |\n+LL | fn foo<'a>() {\n+   |        ^^\n+\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/method-ufcs-inherent-4.rs:17:41\n+   |\n+LL |     let x = <A<'a>>::new::<&'a u32>(&v, &v);\n+   |                                         ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `v` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 15:8...\n+  --> $DIR/method-ufcs-inherent-4.rs:15:8\n+   |\n+LL | fn foo<'a>() {\n+   |        ^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}