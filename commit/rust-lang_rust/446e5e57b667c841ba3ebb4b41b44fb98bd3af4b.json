{"sha": "446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NmU1ZTU3YjY2N2M4NDFiYTNlYmI0YjQxYjQ0ZmI5OGJkM2FmNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-14T10:00:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-14T10:00:51Z"}, "message": "Auto merge of #65399 - Centril:rollup-6lzj0w5, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #65215 (Add long error explanation for E0697)\n - #65292 (Print lifetimes with backticks)\n - #65362 (syntax: consolidate function parsing in item.rs)\n - #65363 (Remove implicit dependencies on syntax::pprust)\n - #65379 (refactor session::config::build_session_options_and_crate_config)\n - #65392 (Move `Nonterminal::to_tokenstream` to parser & don't rely directly on parser in lowering)\n - #65395 (Add some tests for fixed ICEs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b6cc0036da62d65162168901c85cf368d8ed440d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6cc0036da62d65162168901c85cf368d8ed440d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "html_url": "https://github.com/rust-lang/rust/commit/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d28a9c38fe14396e86ae274c7847e20ee0f78ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d28a9c38fe14396e86ae274c7847e20ee0f78ca9", "html_url": "https://github.com/rust-lang/rust/commit/d28a9c38fe14396e86ae274c7847e20ee0f78ca9"}, {"sha": "a73e0731f45577bb6b760fe5d8d328de2021a74f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73e0731f45577bb6b760fe5d8d328de2021a74f", "html_url": "https://github.com/rust-lang/rust/commit/a73e0731f45577bb6b760fe5d8d328de2021a74f"}], "stats": {"total": 2625, "additions": 1452, "deletions": 1173}, "files": [{"sha": "3d501cacf6f4ca57d239ff26c68091b24160e186", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -2005,6 +2005,24 @@ a (non-transparent) struct containing a single float, while `Grams` is a\n transparent wrapper around a float. This can make a difference for the ABI.\n \"##,\n \n+E0697: r##\"\n+A closure has been used as `static`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0697\n+fn main() {\n+    static || {}; // used as `static`\n+}\n+```\n+\n+Closures cannot be used as `static`. They \"save\" the environment,\n+and as such a static closure would save only a static environment\n+which would consist only of variables with a static lifetime. Given\n+this it would be better to use a proper function. The easiest fix\n+is to remove the `static` keyword.\n+\"##,\n+\n E0698: r##\"\n When using generators (or async) all type variables must be bound so a\n generator can be constructed.\n@@ -2191,7 +2209,6 @@ See [RFC 2091] for details on this and other limitations.\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-    E0697, // closures cannot be static\n //  E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported"}, {"sha": "747848edc7a8d24c24f8037558fd21b122bbaaab", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -70,7 +70,8 @@ use syntax::print::pprust;\n use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n-use syntax::parse::token::{self, Token};\n+use syntax::parse::token::{self, Nonterminal, Token};\n+use syntax::parse::ParseSess;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n \n@@ -86,6 +87,11 @@ pub struct LoweringContext<'a> {\n \n     resolver: &'a mut dyn Resolver,\n \n+    /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n+    /// if we don't have this function pointer. To avoid that dependency so that\n+    /// librustc is independent of the parser, we use dynamic dispatch here.\n+    nt_to_tokenstream: NtToTokenstream,\n+\n     /// The items being lowered are collected here.\n     items: BTreeMap<hir::HirId, hir::Item>,\n \n@@ -180,6 +186,8 @@ pub trait Resolver {\n     fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n }\n \n+type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n+\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n@@ -236,6 +244,7 @@ pub fn lower_crate(\n     dep_graph: &DepGraph,\n     krate: &Crate,\n     resolver: &mut dyn Resolver,\n+    nt_to_tokenstream: NtToTokenstream,\n ) -> hir::Crate {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to\n@@ -249,6 +258,7 @@ pub fn lower_crate(\n         sess,\n         cstore,\n         resolver,\n+        nt_to_tokenstream,\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -1022,7 +1032,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_token(&mut self, token: Token) -> TokenStream {\n         match token.kind {\n             token::Interpolated(nt) => {\n-                let tts = nt.to_tokenstream(&self.sess.parse_sess, token.span);\n+                let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n                 self.lower_token_stream(tts)\n             }\n             _ => TokenTree::Token(token).into(),"}, {"sha": "f6068855e630cc3d514c59d13d41cc553e0a6ca0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 {\n                     sp = param.span;\n                 }\n-                (format!(\"the lifetime {} as defined on\", br.name), sp)\n+                (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n             }\n             ty::ReFree(ty::FreeRegion {\n                 bound_region: ty::BoundRegion::BrNamed(_, name),\n@@ -213,15 +213,15 @@ impl<'tcx> TyCtxt<'tcx> {\n                 {\n                     sp = param.span;\n                 }\n-                (format!(\"the lifetime {} as defined on\", name), sp)\n+                (format!(\"the lifetime `{}` as defined on\", name), sp)\n             }\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n                     self.hir().span(node),\n                 ),\n                 _ => (\n-                    format!(\"the lifetime {} as defined on\", region),\n+                    format!(\"the lifetime `{}` as defined on\", region),\n                     cm.def_span(self.hir().span(node)),\n                 ),\n             },"}, {"sha": "60b1b192d10db13aac2c2479fd2fff0111b5fd7f", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHa\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n+use syntax::print::pprust;\n use syntax::source_map::MultiSpan;\n use syntax::symbol::{Symbol, sym};\n \n@@ -285,7 +286,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                             tool_ident.span,\n                             E0710,\n                             \"an unknown tool name found in scoped lint: `{}`\",\n-                            meta_item.path\n+                            pprust::path_to_string(&meta_item.path),\n                         );\n                         continue;\n                     }"}, {"sha": "84102cea8ad9fff84e24177d090c61aa36363c81", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 283, "deletions": 181, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -2038,11 +2038,7 @@ pub fn parse_error_format(\n     return error_format;\n }\n \n-pub fn build_session_options_and_crate_config(\n-    matches: &getopts::Matches,\n-) -> (Options, FxHashSet<(String, Option<String>)>) {\n-    let color = parse_color(matches);\n-\n+fn parse_crate_edition(matches: &getopts::Matches) -> Edition {\n     let edition = match matches.opt_str(\"edition\") {\n         Some(arg) => Edition::from_str(&arg).unwrap_or_else(|_|\n             early_error(\n@@ -2069,19 +2065,14 @@ pub fn build_session_options_and_crate_config(\n         )\n     }\n \n-    let (json_rendered, json_artifact_notifications) = parse_json(matches);\n-\n-    let error_format = parse_error_format(matches, color, json_rendered);\n-\n-    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n-    let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(error_format, &e[..]));\n-\n-\n-    let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n-\n-    let mut debugging_opts = build_debugging_options(matches, error_format);\n+    edition\n+}\n \n+fn check_debug_option_stability(\n+    debugging_opts: &DebuggingOptions,\n+    error_format: ErrorOutputType,\n+    json_rendered: HumanReadableErrorType,\n+) {\n     if !debugging_opts.unstable_options {\n         if let ErrorOutputType::Json { pretty: true, json_rendered } = error_format {\n             early_error(\n@@ -2097,7 +2088,13 @@ pub fn build_session_options_and_crate_config(\n             );\n         }\n     }\n+}\n \n+fn parse_output_types(\n+    debugging_opts: &DebuggingOptions,\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType,\n+) -> OutputTypes {\n     let mut output_types = BTreeMap::new();\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n@@ -2122,14 +2119,19 @@ pub fn build_session_options_and_crate_config(\n     if output_types.is_empty() {\n         output_types.insert(OutputType::Exe, None);\n     }\n+    OutputTypes(output_types)\n+}\n \n-    let mut cg = build_codegen_options(matches, error_format);\n-    let mut codegen_units = cg.codegen_units;\n+fn should_override_cgus_and_disable_thinlto(\n+    output_types: &OutputTypes,\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType,\n+    mut codegen_units: Option<usize>,\n+) -> (bool, Option<usize>) {\n     let mut disable_thinlto = false;\n-\n     // Issue #30063: if user requests LLVM-related output to one\n     // particular path, disable codegen-units.\n-    let incompatible: Vec<_> = output_types\n+    let incompatible: Vec<_> = output_types.0\n         .iter()\n         .map(|ot_path| ot_path.0)\n         .filter(|ot| !ot.is_compatible_with_codegen_units_and_single_output_file())\n@@ -2161,29 +2163,39 @@ pub fn build_session_options_and_crate_config(\n         }\n     }\n \n-    if debugging_opts.threads == 0 {\n+    if codegen_units == Some(0) {\n         early_error(\n             error_format,\n-            \"value for threads must be a positive non-zero integer\",\n+            \"value for codegen units must be a positive non-zero integer\",\n         );\n     }\n \n-    if debugging_opts.threads > 1 && debugging_opts.fuel.is_some() {\n+    (disable_thinlto, codegen_units)\n+}\n+\n+fn check_thread_count(debugging_opts: &DebuggingOptions, error_format: ErrorOutputType) {\n+    if debugging_opts.threads == 0 {\n         early_error(\n             error_format,\n-            \"optimization fuel is incompatible with multiple threads\",\n+            \"value for threads must be a positive non-zero integer\",\n         );\n     }\n \n-    if codegen_units == Some(0) {\n+    if debugging_opts.threads > 1 && debugging_opts.fuel.is_some() {\n         early_error(\n             error_format,\n-            \"value for codegen units must be a positive non-zero integer\",\n+            \"optimization fuel is incompatible with multiple threads\",\n         );\n     }\n+}\n \n-    let incremental = match (&debugging_opts.incremental, &cg.incremental) {\n-        (&Some(ref path1), &Some(ref path2)) => {\n+fn select_incremental_path(\n+    debugging_opts: &DebuggingOptions,\n+    cg: &CodegenOptions,\n+    error_format: ErrorOutputType,\n+) -> Option<PathBuf> {\n+    match (&debugging_opts.incremental, &cg.incremental) {\n+        (Some(path1), Some(path2)) => {\n             if path1 != path2 {\n                 early_error(\n                     error_format,\n@@ -2197,25 +2209,19 @@ pub fn build_session_options_and_crate_config(\n                 Some(path1)\n             }\n         }\n-        (&Some(ref path), &None) => Some(path),\n-        (&None, &Some(ref path)) => Some(path),\n-        (&None, &None) => None,\n-    }.map(|m| PathBuf::from(m));\n-\n-    if debugging_opts.profile && incremental.is_some() {\n-        early_error(\n-            error_format,\n-            \"can't instrument with gcov profiling when compiling incrementally\",\n-        );\n-    }\n-\n-    if cg.profile_generate.enabled() && cg.profile_use.is_some() {\n-        early_error(\n-            error_format,\n-            \"options `-C profile-generate` and `-C profile-use` are exclusive\",\n-        );\n-    }\n+        (Some(path), None) => Some(path),\n+        (None, Some(path)) => Some(path),\n+        (None, None) => None,\n+    }.map(|m| PathBuf::from(m))\n+}\n \n+fn collect_print_requests(\n+    cg: &mut CodegenOptions,\n+    dopts: &mut DebuggingOptions,\n+    matches: &getopts::Matches,\n+    is_unstable_enabled: bool,\n+    error_format: ErrorOutputType,\n+) -> Vec<PrintRequest> {\n     let mut prints = Vec::<PrintRequest>::new();\n     if cg.target_cpu.as_ref().map_or(false, |s| s == \"help\") {\n         prints.push(PrintRequest::TargetCPUs);\n@@ -2233,72 +2239,105 @@ pub fn build_session_options_and_crate_config(\n         prints.push(PrintRequest::CodeModels);\n         cg.code_model = None;\n     }\n-    if debugging_opts\n+    if dopts\n         .tls_model\n         .as_ref()\n         .map_or(false, |s| s == \"help\")\n     {\n         prints.push(PrintRequest::TlsModels);\n-        debugging_opts.tls_model = None;\n+        dopts.tls_model = None;\n     }\n \n-    let cg = cg;\n+    prints.extend(matches.opt_strs(\"print\").into_iter().map(|s| match &*s {\n+        \"crate-name\" => PrintRequest::CrateName,\n+        \"file-names\" => PrintRequest::FileNames,\n+        \"sysroot\" => PrintRequest::Sysroot,\n+        \"cfg\" => PrintRequest::Cfg,\n+        \"target-list\" => PrintRequest::TargetList,\n+        \"target-cpus\" => PrintRequest::TargetCPUs,\n+        \"target-features\" => PrintRequest::TargetFeatures,\n+        \"relocation-models\" => PrintRequest::RelocationModels,\n+        \"code-models\" => PrintRequest::CodeModels,\n+        \"tls-models\" => PrintRequest::TlsModels,\n+        \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n+        \"target-spec-json\" => {\n+            if is_unstable_enabled {\n+                PrintRequest::TargetSpec\n+            } else {\n+                early_error(\n+                    error_format,\n+                    \"the `-Z unstable-options` flag must also be passed to \\\n+                     enable the target-spec-json print option\",\n+                );\n+            }\n+        }\n+        req => early_error(error_format, &format!(\"unknown print request `{}`\", req)),\n+    }));\n \n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n-    let target_triple = if let Some(target) = matches.opt_str(\"target\") {\n-        if target.ends_with(\".json\") {\n+    prints\n+}\n+\n+fn parse_target_triple(matches: &getopts::Matches, error_format: ErrorOutputType) -> TargetTriple {\n+    match matches.opt_str(\"target\") {\n+        Some(target) if target.ends_with(\".json\") => {\n             let path = Path::new(&target);\n             TargetTriple::from_path(&path).unwrap_or_else(|_|\n                 early_error(error_format, &format!(\"target file {:?} does not exist\", path)))\n+        }\n+        Some(target) => TargetTriple::TargetTriple(target),\n+        _ => TargetTriple::from_triple(host_triple()),\n+    }\n+}\n+\n+fn parse_opt_level(\n+    matches: &getopts::Matches,\n+    cg: &CodegenOptions,\n+    error_format: ErrorOutputType,\n+) -> OptLevel {\n+    // The `-O` and `-C opt-level` flags specify the same setting, so we want to be able\n+    // to use them interchangeably. However, because they're technically different flags,\n+    // we need to work out manually which should take precedence if both are supplied (i.e.\n+    // the rightmost flag). We do this by finding the (rightmost) position of both flags and\n+    // comparing them. Note that if a flag is not found, its position will be `None`, which\n+    // always compared less than `Some(_)`.\n+    let max_o = matches.opt_positions(\"O\").into_iter().max();\n+    let max_c = matches.opt_strs_pos(\"C\").into_iter().flat_map(|(i, s)| {\n+        if let Some(\"opt-level\") = s.splitn(2, '=').next() {\n+            Some(i)\n         } else {\n-            TargetTriple::TargetTriple(target)\n+            None\n         }\n+    }).max();\n+    if max_o > max_c {\n+        OptLevel::Default\n     } else {\n-        TargetTriple::from_triple(host_triple())\n-    };\n-    let opt_level = {\n-        // The `-O` and `-C opt-level` flags specify the same setting, so we want to be able\n-        // to use them interchangeably. However, because they're technically different flags,\n-        // we need to work out manually which should take precedence if both are supplied (i.e.\n-        // the rightmost flag). We do this by finding the (rightmost) position of both flags and\n-        // comparing them. Note that if a flag is not found, its position will be `None`, which\n-        // always compared less than `Some(_)`.\n-        let max_o = matches.opt_positions(\"O\").into_iter().max();\n-        let max_c = matches.opt_strs_pos(\"C\").into_iter().flat_map(|(i, s)| {\n-            if let Some(\"opt-level\") = s.splitn(2, '=').next() {\n-                Some(i)\n-            } else {\n-                None\n-            }\n-        }).max();\n-        if max_o > max_c {\n-            OptLevel::Default\n-        } else {\n-            match cg.opt_level.as_ref().map(String::as_ref) {\n-                None => OptLevel::No,\n-                Some(\"0\") => OptLevel::No,\n-                Some(\"1\") => OptLevel::Less,\n-                Some(\"2\") => OptLevel::Default,\n-                Some(\"3\") => OptLevel::Aggressive,\n-                Some(\"s\") => OptLevel::Size,\n-                Some(\"z\") => OptLevel::SizeMin,\n-                Some(arg) => {\n-                    early_error(\n-                        error_format,\n-                        &format!(\n-                            \"optimization level needs to be \\\n-                             between 0-3, s or z (instead was `{}`)\",\n-                            arg\n-                        ),\n-                    );\n-                }\n+        match cg.opt_level.as_ref().map(String::as_ref) {\n+            None => OptLevel::No,\n+            Some(\"0\") => OptLevel::No,\n+            Some(\"1\") => OptLevel::Less,\n+            Some(\"2\") => OptLevel::Default,\n+            Some(\"3\") => OptLevel::Aggressive,\n+            Some(\"s\") => OptLevel::Size,\n+            Some(\"z\") => OptLevel::SizeMin,\n+            Some(arg) => {\n+                early_error(\n+                    error_format,\n+                    &format!(\n+                        \"optimization level needs to be \\\n+                            between 0-3, s or z (instead was `{}`)\",\n+                        arg\n+                    ),\n+                );\n             }\n         }\n-    };\n-    // The `-g` and `-C debuginfo` flags specify the same setting, so we want to be able\n-    // to use them interchangeably. See the note above (regarding `-O` and `-C opt-level`)\n-    // for more details.\n-    let debug_assertions = cg.debug_assertions.unwrap_or(opt_level == OptLevel::No);\n+    }\n+}\n+\n+fn select_debuginfo(\n+    matches: &getopts::Matches,\n+    cg: &CodegenOptions,\n+    error_format: ErrorOutputType,\n+) -> DebugInfo {\n     let max_g = matches.opt_positions(\"g\").into_iter().max();\n     let max_c = matches.opt_strs_pos(\"C\").into_iter().flat_map(|(i, s)| {\n         if let Some(\"debuginfo\") = s.splitn(2, '=').next() {\n@@ -2307,7 +2346,7 @@ pub fn build_session_options_and_crate_config(\n             None\n         }\n     }).max();\n-    let debuginfo = if max_g > max_c {\n+    if max_g > max_c {\n         DebugInfo::Full\n     } else {\n         match cg.debuginfo {\n@@ -2325,14 +2364,14 @@ pub fn build_session_options_and_crate_config(\n                 );\n             }\n         }\n-    };\n-\n-    let mut search_paths = vec![];\n-    for s in &matches.opt_strs(\"L\") {\n-        search_paths.push(SearchPath::from_cli_opt(&s[..], error_format));\n     }\n+}\n \n-    let libs = matches\n+fn parse_libs(\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType,\n+) -> Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> {\n+    matches\n         .opt_strs(\"l\")\n         .into_iter()\n         .map(|s| {\n@@ -2371,52 +2410,23 @@ pub fn build_session_options_and_crate_config(\n             let new_name = name_parts.next();\n             (name.to_owned(), new_name.map(|n| n.to_owned()), kind)\n         })\n-        .collect();\n-\n-    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n-    let test = matches.opt_present(\"test\");\n-\n-    let is_unstable_enabled = nightly_options::is_unstable_enabled(matches);\n-\n-    prints.extend(matches.opt_strs(\"print\").into_iter().map(|s| match &*s {\n-        \"crate-name\" => PrintRequest::CrateName,\n-        \"file-names\" => PrintRequest::FileNames,\n-        \"sysroot\" => PrintRequest::Sysroot,\n-        \"cfg\" => PrintRequest::Cfg,\n-        \"target-list\" => PrintRequest::TargetList,\n-        \"target-cpus\" => PrintRequest::TargetCPUs,\n-        \"target-features\" => PrintRequest::TargetFeatures,\n-        \"relocation-models\" => PrintRequest::RelocationModels,\n-        \"code-models\" => PrintRequest::CodeModels,\n-        \"tls-models\" => PrintRequest::TlsModels,\n-        \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n-        \"target-spec-json\" => {\n-            if is_unstable_enabled {\n-                PrintRequest::TargetSpec\n-            } else {\n-                early_error(\n-                    error_format,\n-                    \"the `-Z unstable-options` flag must also be passed to \\\n-                     enable the target-spec-json print option\",\n-                );\n-            }\n-        }\n-        req => early_error(error_format, &format!(\"unknown print request `{}`\", req)),\n-    }));\n+        .collect()\n+}\n \n-    let borrowck_mode = match debugging_opts.borrowck.as_ref().map(|s| &s[..]) {\n+fn parse_borrowck_mode(dopts: &DebuggingOptions, error_format: ErrorOutputType) -> BorrowckMode {\n+    match dopts.borrowck.as_ref().map(|s| &s[..]) {\n         None | Some(\"migrate\") => BorrowckMode::Migrate,\n         Some(\"mir\") => BorrowckMode::Mir,\n         Some(m) => early_error(error_format, &format!(\"unknown borrowck mode `{}`\", m)),\n-    };\n-\n-    if !cg.remark.is_empty() && debuginfo == DebugInfo::None {\n-        early_warn(\n-            error_format,\n-            \"-C remark requires \\\"-C debuginfo=n\\\" to show source locations\",\n-        );\n     }\n+}\n \n+fn parse_externs(\n+    matches: &getopts::Matches,\n+    debugging_opts: &DebuggingOptions,\n+    error_format: ErrorOutputType,\n+    is_unstable_enabled: bool,\n+) -> Externs {\n     if matches.opt_present(\"extern-private\") && !debugging_opts.unstable_options {\n         early_error(\n             ErrorOutputType::default(),\n@@ -2457,10 +2467,14 @@ pub fn build_session_options_and_crate_config(\n         // flag\n         entry.is_private_dep |= private;\n     }\n+    Externs(externs)\n+}\n \n-    let crate_name = matches.opt_str(\"crate-name\");\n-\n-    let remap_path_prefix = matches\n+fn parse_remap_path_prefix(\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType\n+) -> Vec<(PathBuf, PathBuf)> {\n+    matches\n         .opt_strs(\"remap-path-prefix\")\n         .into_iter()\n         .map(|remap| {\n@@ -2475,42 +2489,130 @@ pub fn build_session_options_and_crate_config(\n                 ),\n             }\n         })\n-        .collect();\n+        .collect()\n+}\n \n-    (\n-        Options {\n-            crate_types,\n-            optimize: opt_level,\n-            debuginfo,\n-            lint_opts,\n-            lint_cap,\n-            describe_lints,\n-            output_types: OutputTypes(output_types),\n-            search_paths,\n-            maybe_sysroot: sysroot_opt,\n-            target_triple,\n-            test,\n-            incremental,\n-            debugging_opts,\n-            prints,\n-            borrowck_mode,\n-            cg,\n+pub fn build_session_options(matches: &getopts::Matches) -> Options {\n+    let color = parse_color(matches);\n+\n+    let edition = parse_crate_edition(matches);\n+\n+    let (json_rendered, json_artifact_notifications) = parse_json(matches);\n+\n+    let error_format = parse_error_format(matches, color, json_rendered);\n+\n+    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n+    let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n+        .unwrap_or_else(|e| early_error(error_format, &e[..]));\n+\n+    let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n+\n+    let mut debugging_opts = build_debugging_options(matches, error_format);\n+    check_debug_option_stability(&debugging_opts, error_format, json_rendered);\n+\n+    let output_types = parse_output_types(&debugging_opts, matches, error_format);\n+\n+    let mut cg = build_codegen_options(matches, error_format);\n+    let (disable_thinlto, codegen_units) = should_override_cgus_and_disable_thinlto(\n+        &output_types,\n+        matches,\n+        error_format,\n+        cg.codegen_units,\n+    );\n+\n+    check_thread_count(&debugging_opts, error_format);\n+\n+    let incremental = select_incremental_path(&debugging_opts, &cg, error_format);\n+\n+    if debugging_opts.profile && incremental.is_some() {\n+        early_error(\n             error_format,\n-            externs: Externs(externs),\n-            crate_name,\n-            alt_std_name: None,\n-            libs,\n-            unstable_features: UnstableFeatures::from_environment(),\n-            debug_assertions,\n-            actually_rustdoc: false,\n-            cli_forced_codegen_units: codegen_units,\n-            cli_forced_thinlto_off: disable_thinlto,\n-            remap_path_prefix,\n-            edition,\n-            json_artifact_notifications,\n-        },\n-        cfg,\n-    )\n+            \"can't instrument with gcov profiling when compiling incrementally\",\n+        );\n+    }\n+\n+    if cg.profile_generate.enabled() && cg.profile_use.is_some() {\n+        early_error(\n+            error_format,\n+            \"options `-C profile-generate` and `-C profile-use` are exclusive\",\n+        );\n+    }\n+\n+    let is_unstable_enabled = nightly_options::is_unstable_enabled(matches);\n+    let prints = collect_print_requests(\n+        &mut cg,\n+        &mut debugging_opts,\n+        matches,\n+        is_unstable_enabled,\n+        error_format,\n+    );\n+\n+    let cg = cg;\n+\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n+    let target_triple = parse_target_triple(matches, error_format);\n+    let opt_level = parse_opt_level(matches, &cg, error_format);\n+    // The `-g` and `-C debuginfo` flags specify the same setting, so we want to be able\n+    // to use them interchangeably. See the note above (regarding `-O` and `-C opt-level`)\n+    // for more details.\n+    let debug_assertions = cg.debug_assertions.unwrap_or(opt_level == OptLevel::No);\n+    let debuginfo = select_debuginfo(matches, &cg, error_format);\n+\n+    let mut search_paths = vec![];\n+    for s in &matches.opt_strs(\"L\") {\n+        search_paths.push(SearchPath::from_cli_opt(&s[..], error_format));\n+    }\n+\n+    let libs = parse_libs(matches, error_format);\n+\n+    let test = matches.opt_present(\"test\");\n+\n+    let borrowck_mode = parse_borrowck_mode(&debugging_opts, error_format);\n+\n+    if !cg.remark.is_empty() && debuginfo == DebugInfo::None {\n+        early_warn(\n+            error_format,\n+            \"-C remark requires \\\"-C debuginfo=n\\\" to show source locations\",\n+        );\n+    }\n+\n+    let externs = parse_externs(matches, &debugging_opts, error_format, is_unstable_enabled);\n+\n+    let crate_name = matches.opt_str(\"crate-name\");\n+\n+    let remap_path_prefix = parse_remap_path_prefix(matches, error_format);\n+\n+    Options {\n+        crate_types,\n+        optimize: opt_level,\n+        debuginfo,\n+        lint_opts,\n+        lint_cap,\n+        describe_lints,\n+        output_types,\n+        search_paths,\n+        maybe_sysroot: sysroot_opt,\n+        target_triple,\n+        test,\n+        incremental,\n+        debugging_opts,\n+        prints,\n+        borrowck_mode,\n+        cg,\n+        error_format,\n+        externs,\n+        crate_name,\n+        alt_std_name: None,\n+        libs,\n+        unstable_features: UnstableFeatures::from_environment(),\n+        debug_assertions,\n+        actually_rustdoc: false,\n+        cli_forced_codegen_units: codegen_units,\n+        cli_forced_thinlto_off: disable_thinlto,\n+        remap_path_prefix,\n+        edition,\n+        json_artifact_notifications,\n+    }\n }\n \n pub fn make_crate_type_option() -> RustcOptGroup {"}, {"sha": "061bbdc307fc4bf4d9d03b7251fec8934c1602cf", "filename": "src/librustc/session/config/tests.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -3,8 +3,9 @@ use crate::lint;\n use crate::middle::cstore;\n use crate::session::config::{\n     build_configuration,\n-    build_session_options_and_crate_config,\n-    to_crate_config\n+    build_session_options,\n+    to_crate_config,\n+    parse_cfgspecs,\n };\n use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n use crate::session::build_session;\n@@ -18,6 +19,16 @@ use syntax::symbol::sym;\n use syntax::edition::{Edition, DEFAULT_EDITION};\n use syntax;\n use super::Options;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub fn build_session_options_and_crate_config(\n+    matches: &getopts::Matches,\n+) -> (Options, FxHashSet<(String, Option<String>)>) {\n+    (\n+        build_session_options(matches),\n+        parse_cfgspecs(matches.opt_strs(\"cfg\")),\n+    )\n+}\n \n impl ExternEntry {\n     fn new_public<S: Into<String>,"}, {"sha": "806afbd1af68c47f9fddf7dcc22c47a200b9f7a0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -166,7 +166,8 @@ pub fn run_compiler(\n         None => return Ok(()),\n     };\n \n-    let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n+    let sopts = config::build_session_options(&matches);\n+    let cfg = config::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n \n     let mut dummy_config = |sopts, cfg, diagnostic_output| {\n         let mut config = interface::Config {"}, {"sha": "328798862b864b9ab971d0b2c78280f13ea18f3e", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -541,7 +541,8 @@ pub fn lower_to_hir(\n ) -> Result<hir::map::Forest> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n-        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver);\n+        let nt_to_tokenstream = syntax::parse::nt_to_tokenstream;\n+        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver, nt_to_tokenstream);\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);"}, {"sha": "9a16d0a0715f75c9218405b324d6f46780b26868", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -45,7 +45,7 @@ use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span};\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n-use syntax::print::pprust::expr_to_string;\n+use syntax::print::pprust::{self, expr_to_string};\n use syntax::visit::FnKind;\n \n use rustc::hir::{self, GenericParamKind, PatKind};\n@@ -701,7 +701,8 @@ impl EarlyLintPass for DeprecatedAttr {\n             }\n         }\n         if attr.check_name(sym::no_start) || attr.check_name(sym::crate_id) {\n-            let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", attr.path);\n+            let path_str = pprust::path_to_string(&attr.path);\n+            let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n             lint_deprecated_attr(cx, attr, &msg, None);\n         }\n     }"}, {"sha": "ad0f75d772548b7208bf942b21d03e1280e9461b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -1,4 +1,5 @@\n use syntax::ast::{self, MetaItem};\n+use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n \n use rustc_index::bit_set::{BitSet, HybridBitSet};\n@@ -159,9 +160,8 @@ where\n                 if let Some(s) = item.value_str() {\n                     return Some(s.to_string())\n                 } else {\n-                    sess.span_err(\n-                        item.span,\n-                        &format!(\"{} attribute requires a path\", item.path));\n+                    let path = pprust::path_to_string(&item.path);\n+                    sess.span_err(item.span, &format!(\"{} attribute requires a path\", path));\n                     return None;\n                 }\n             }"}, {"sha": "43c4f720ad41d67da23169d83ff395127f57189a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -263,7 +263,8 @@ impl<'a> AstValidator<'a> {\n                 let mut err = self.err_handler().struct_span_err(poly.span,\n                     &format!(\"`?Trait` is not permitted in {}\", where_));\n                 if is_trait {\n-                    err.note(&format!(\"traits are `?{}` by default\", poly.trait_ref.path));\n+                    let path_str = pprust::path_to_string(&poly.trait_ref.path);\n+                    err.note(&format!(\"traits are `?{}` by default\", path_str));\n                 }\n                 err.emit();\n             }"}, {"sha": "2b8965aa5d41c09a56ea4f0ec173f04528911b16", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -37,6 +37,7 @@ use syntax::ext::expand::AstFragment;\n use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n+use syntax::print::pprust;\n use syntax::{span_err, struct_span_err};\n use syntax::source_map::{respan, Spanned};\n use syntax::symbol::{kw, sym};\n@@ -228,7 +229,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         .span_suggestion(\n                             path.span,\n                             \"try\",\n-                            format!(\"crate::{}\", path),\n+                            format!(\"crate::{}\", pprust::path_to_string(&path)),\n                             Applicability::MaybeIncorrect,\n                         )\n                         .emit();"}, {"sha": "e3c272e12fe51be2cc1376a1ded3a41d722cf4bb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -38,6 +38,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::ext::hygiene::{ExpnId, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::{SyntaxExtension, MacroKind, SpecialDerives};\n+use syntax::print::pprust;\n use syntax::symbol::{kw, sym};\n \n use syntax::visit::{self, Visitor};\n@@ -2011,13 +2012,13 @@ impl<'a> Resolver<'a> {\n                         let mut candidates =\n                             self.lookup_import_candidates(ident, TypeNS, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n-                            (c.path.segments.len(), c.path.to_string())\n+                            (c.path.segments.len(), pprust::path_to_string(&c.path))\n                         });\n                         if let Some(candidate) = candidates.get(0) {\n                             (\n                                 String::from(\"unresolved import\"),\n                                 Some((\n-                                    vec![(ident.span, candidate.path.to_string())],\n+                                    vec![(ident.span, pprust::path_to_string(&candidate.path))],\n                                     String::from(\"a similar path exists\"),\n                                     Applicability::MaybeIncorrect,\n                                 )),"}, {"sha": "49186088fa06a79637cb039250d83e59cb1d6ca4", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -21,6 +21,7 @@ use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n use syntax::ext::compile_declarative_macro;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n+use syntax::print::pprust;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -324,7 +325,8 @@ impl<'a> Resolver<'a> {\n \n         Ok(if ext.macro_kind() != kind {\n             let expected = kind.descr_expected();\n-            let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path);\n+            let path_str = pprust::path_to_string(path);\n+            let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str);\n             self.session.struct_span_err(path.span, &msg)\n                         .span_label(path.span, format!(\"not {} {}\", kind.article(), expected))\n                         .emit();\n@@ -805,14 +807,16 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if let Some(depr) = &stability.rustc_depr {\n-                let (message, lint) = stability::rustc_deprecation_message(depr, &path.to_string());\n+                let path = pprust::path_to_string(path);\n+                let (message, lint) = stability::rustc_deprecation_message(depr, &path);\n                 stability::early_report_deprecation(\n                     self.session, &message, depr.suggestion, lint, span\n                 );\n             }\n         }\n         if let Some(depr) = &ext.deprecation {\n-            let (message, lint) = stability::deprecation_message(depr, &path.to_string());\n+            let path = pprust::path_to_string(&path);\n+            let (message, lint) = stability::deprecation_message(depr, &path);\n             stability::early_report_deprecation(self.session, &message, None, lint, span);\n         }\n     }"}, {"sha": "b726ad1e0d63432552e91d39221aa14176e5f120", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -46,6 +46,7 @@ use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n use syntax::edition::Edition;\n use syntax::ext::base::MacroKind;\n+use syntax::print::pprust;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::{Symbol, sym};\n@@ -2957,7 +2958,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n-    let path = attr.path.to_string();\n+    let path = pprust::path_to_string(&attr.path);\n \n     if attr.is_word() {\n         Some(path)"}, {"sha": "79d91125ec4c463a50089c8161cc9655b2bf32f2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -7,7 +7,6 @@ pub use crate::util::parser::ExprPrecedence;\n \n use crate::ext::hygiene::ExpnId;\n use crate::parse::token::{self, DelimToken};\n-use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n use crate::symbol::{kw, sym, Symbol};\n@@ -70,7 +69,7 @@ impl fmt::Display for Lifetime {\n /// along with a bunch of supporting information.\n ///\n /// E.g., `std::cmp::PartialEq`.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n@@ -86,18 +85,6 @@ impl PartialEq<Symbol> for Path {\n     }\n }\n \n-impl fmt::Debug for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"path({})\", pprust::path_to_string(self))\n-    }\n-}\n-\n-impl fmt::Display for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", pprust::path_to_string(self))\n-    }\n-}\n-\n impl Path {\n     // Convert a span and an identifier to the corresponding\n     // one-segment path.\n@@ -507,19 +494,13 @@ pub struct Block {\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Pat {\n     pub id: NodeId,\n     pub kind: PatKind,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Pat {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"pat({}: {})\", self.id, pprust::pat_to_string(self))\n-    }\n-}\n-\n impl Pat {\n     /// Attempt reparsing the pattern as a type.\n     /// This is intended for use by diagnostics.\n@@ -831,7 +812,7 @@ impl UnOp {\n }\n \n /// A statement\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Stmt {\n     pub id: NodeId,\n     pub kind: StmtKind,\n@@ -865,18 +846,7 @@ impl Stmt {\n     }\n }\n \n-impl fmt::Debug for Stmt {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"stmt({}: {})\",\n-            self.id.to_string(),\n-            pprust::stmt_to_string(self)\n-        )\n-    }\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum StmtKind {\n     /// A local (let) binding.\n     Local(P<Local>),\n@@ -973,7 +943,7 @@ pub struct AnonConst {\n }\n \n /// An expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Expr {\n     pub id: NodeId,\n     pub kind: ExprKind,\n@@ -1100,12 +1070,6 @@ impl Expr {\n     }\n }\n \n-impl fmt::Debug for Expr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))\n-    }\n-}\n-\n /// Limit types of a range (inclusive or exclusive)\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub enum RangeLimits {\n@@ -1660,19 +1624,13 @@ pub enum AssocTyConstraintKind {\n     },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Ty {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"type({})\", pprust::ty_to_string(self))\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,"}, {"sha": "efc48256e7cebaee66a323e53e0d907c9e95280c", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,6 +5,7 @@ use crate::early_buffered_lints::BufferedEarlyLintId;\n use crate::ext::base::ExtCtxt;\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n+use crate::print::pprust;\n \n use errors::{Applicability, Handler};\n use syntax_pos::hygiene::Transparency;\n@@ -243,7 +244,11 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(sess, meta.span, AttrError::MultipleItem(meta.path.to_string()));\n+                    handle_errors(\n+                        sess,\n+                        meta.span,\n+                        AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+                    );\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -271,7 +276,10 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                     handle_errors(\n                                         sess,\n                                         mi.span,\n-                                        AttrError::UnknownMetaItem(mi.path.to_string(), expected),\n+                                        AttrError::UnknownMetaItem(\n+                                            pprust::path_to_string(&mi.path),\n+                                            expected,\n+                                        ),\n                                     );\n                                     continue 'outer\n                                 }\n@@ -362,7 +370,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                         sess,\n                                         meta.span(),\n                                         AttrError::UnknownMetaItem(\n-                                            mi.path.to_string(),\n+                                            pprust::path_to_string(&mi.path),\n                                             &[\"feature\", \"reason\", \"issue\", \"soft\"]\n                                         ),\n                                     );\n@@ -434,7 +442,8 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                             sess,\n                                             meta.span(),\n                                             AttrError::UnknownMetaItem(\n-                                                mi.path.to_string(), &[\"since\", \"note\"],\n+                                                pprust::path_to_string(&mi.path),\n+                                                &[\"since\", \"note\"],\n                                             ),\n                                         );\n                                         continue 'outer\n@@ -597,8 +606,11 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n                     !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n                 },\n                 _ => {\n-                    span_err!(sess.span_diagnostic, cfg.span, E0537,\n-                              \"invalid predicate `{}`\", cfg.path);\n+                    span_err!(\n+                        sess.span_diagnostic, cfg.span, E0537,\n+                        \"invalid predicate `{}`\",\n+                        pprust::path_to_string(&cfg.path)\n+                    );\n                     false\n                 }\n             }\n@@ -653,7 +665,9 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                 let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                     if item.is_some() {\n                         handle_errors(\n-                            sess, meta.span, AttrError::MultipleItem(meta.path.to_string())\n+                            sess,\n+                            meta.span,\n+                            AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n                         );\n                         return false\n                     }\n@@ -691,8 +705,10 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                                     handle_errors(\n                                         sess,\n                                         meta.span(),\n-                                        AttrError::UnknownMetaItem(mi.path.to_string(),\n-                                                                   &[\"since\", \"note\"]),\n+                                        AttrError::UnknownMetaItem(\n+                                            pprust::path_to_string(&mi.path),\n+                                            &[\"since\", \"note\"],\n+                                        ),\n                                     );\n                                     continue 'outer\n                                 }"}, {"sha": "1e44f3dd5e59aeadc30755947448359fcd67f65c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -13,6 +13,7 @@ use crate::mut_visit::*;\n use crate::parse::{DirectoryOwnership, PResult, ParseSess};\n use crate::parse::token;\n use crate::parse::parser::Parser;\n+use crate::print::pprust;\n use crate::ptr::P;\n use crate::symbol::{sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n@@ -388,7 +389,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             \"`derive` may only be applied to structs, enums and unions\");\n                         if let ast::AttrStyle::Inner = attr.style {\n                             let trait_list = derives.iter()\n-                                .map(|t| t.to_string()).collect::<Vec<_>>();\n+                                .map(|t| pprust::path_to_string(t))\n+                                .collect::<Vec<_>>();\n                             let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n                             err.span_suggestion(\n                                 span, \"try an outer attribute\", suggestion,\n@@ -587,8 +589,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n-                        let msg = format!(\"non-{kind} macro in {kind} position: {path}\",\n-                                          kind = fragment_kind.name(), path = mac.path);\n+                        let msg = format!(\n+                            \"non-{kind} macro in {kind} position: {path}\",\n+                            kind = fragment_kind.name(),\n+                            path = pprust::path_to_string(&mac.path),\n+                        );\n                         self.cx.span_err(span, &msg);\n                         self.cx.trace_macros_diag();\n                         fragment_kind.dummy(span)\n@@ -878,7 +883,7 @@ impl<'a> Parser<'a> {\n             err.span_label(span, \"caused by the macro expansion here\");\n             let msg = format!(\n                 \"the usage of `{}!` is likely invalid in {} context\",\n-                macro_path,\n+                pprust::path_to_string(&macro_path),\n                 kind_name,\n             );\n             err.note(&msg);"}, {"sha": "e4fc269d14790eee2436fdf93296cf480fb82a33", "filename": "src/libsyntax/ext/mbe/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -174,7 +174,8 @@ fn generic_extension<'cx>(\n     rhses: &[mbe::TokenTree],\n ) -> Box<dyn MacResult + 'cx> {\n     if cx.trace_macros() {\n-        trace_macros_note(cx, sp, format!(\"expanding `{}! {{ {} }}`\", name, arg));\n+        let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(arg.clone()));\n+        trace_macros_note(cx, sp, msg);\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n@@ -212,7 +213,8 @@ fn generic_extension<'cx>(\n                 }\n \n                 if cx.trace_macros() {\n-                    trace_macros_note(cx, sp, format!(\"to `{}`\", tts));\n+                    let msg = format!(\"to `{}`\", pprust::tts_to_string(tts.clone()));\n+                    trace_macros_note(cx, sp, msg);\n                 }\n \n                 let directory = Directory {"}, {"sha": "65037c4a0b8baef06bce86c1360d62c8cbc96455", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -2,6 +2,7 @@ use crate::ast;\n use crate::ext::base::ExtCtxt;\n use crate::parse::{self, token, ParseSess};\n use crate::parse::lexer::comments;\n+use crate::print::pprust;\n use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n \n use errors::Diagnostic;\n@@ -174,7 +175,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n             }\n \n             Interpolated(nt) => {\n-                let stream = nt.to_tokenstream(sess, span);\n+                let stream = parse::nt_to_tokenstream(&nt, sess, span);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,\n@@ -407,7 +408,7 @@ impl server::TokenStream for Rustc<'_> {\n         )\n     }\n     fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n-        stream.to_string()\n+        pprust::tts_to_string(stream.clone())\n     }\n     fn from_token_tree(\n         &mut self,"}, {"sha": "0bbd67589ddd077d2758dca1e86cea98f6fe113f", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -856,7 +856,7 @@ impl<'a> Parser<'a> {\n                 // This is a best-effort recovery.\n                 path.span,\n                 \"try\",\n-                format!(\"<{}>::{}\", ty_str, path),\n+                format!(\"<{}>::{}\", ty_str, pprust::path_to_string(&path)),\n                 Applicability::MaybeIncorrect,\n             )\n             .emit();"}, {"sha": "0df695d37b94f10810164165c67ed80797d1d17b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 134, "deletions": 4, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,10 +4,9 @@ use crate::ast::{self, CrateConfig, NodeId};\n use crate::early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use crate::source_map::{SourceMap, FilePathMapping};\n use crate::feature_gate::UnstableFeatures;\n-use crate::parse::parser::Parser;\n-use crate::parse::parser::emit_unclosed_delims;\n-use crate::parse::token::TokenKind;\n-use crate::tokenstream::{TokenStream, TokenTree};\n+use crate::parse::parser::{Parser, emit_unclosed_delims};\n+use crate::parse::token::{Nonterminal, TokenKind};\n+use crate::tokenstream::{self, TokenStream, TokenTree};\n use crate::print::pprust;\n use crate::symbol::Symbol;\n \n@@ -24,6 +23,8 @@ use std::borrow::Cow;\n use std::path::{Path, PathBuf};\n use std::str;\n \n+use log::info;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -407,3 +408,132 @@ impl SeqSep {\n         }\n     }\n }\n+\n+// NOTE(Centril): The following probably shouldn't be here but it acknowledges the\n+// fact that architecturally, we are using parsing (read on below to understand why).\n+\n+pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> TokenStream {\n+    // A `Nonterminal` is often a parsed AST item. At this point we now\n+    // need to convert the parsed AST to an actual token stream, e.g.\n+    // un-parse it basically.\n+    //\n+    // Unfortunately there's not really a great way to do that in a\n+    // guaranteed lossless fashion right now. The fallback here is to just\n+    // stringify the AST node and reparse it, but this loses all span\n+    // information.\n+    //\n+    // As a result, some AST nodes are annotated with the token stream they\n+    // came from. Here we attempt to extract these lossless token streams\n+    // before we fall back to the stringification.\n+    let tokens = match *nt {\n+        Nonterminal::NtItem(ref item) => {\n+            prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n+        }\n+        Nonterminal::NtTraitItem(ref item) => {\n+            prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n+        }\n+        Nonterminal::NtImplItem(ref item) => {\n+            prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n+        }\n+        Nonterminal::NtIdent(ident, is_raw) => {\n+            Some(tokenstream::TokenTree::token(token::Ident(ident.name, is_raw), ident.span).into())\n+        }\n+        Nonterminal::NtLifetime(ident) => {\n+            Some(tokenstream::TokenTree::token(token::Lifetime(ident.name), ident.span).into())\n+        }\n+        Nonterminal::NtTT(ref tt) => {\n+            Some(tt.clone().into())\n+        }\n+        _ => None,\n+    };\n+\n+    // FIXME(#43081): Avoid this pretty-print + reparse hack\n+    let source = pprust::nonterminal_to_string(nt);\n+    let filename = FileName::macro_expansion_source_code(&source);\n+    let tokens_for_real = parse_stream_from_source_str(filename, source, sess, Some(span));\n+\n+    // During early phases of the compiler the AST could get modified\n+    // directly (e.g., attributes added or removed) and the internal cache\n+    // of tokens my not be invalidated or updated. Consequently if the\n+    // \"lossless\" token stream disagrees with our actual stringification\n+    // (which has historically been much more battle-tested) then we go\n+    // with the lossy stream anyway (losing span information).\n+    //\n+    // Note that the comparison isn't `==` here to avoid comparing spans,\n+    // but it *also* is a \"probable\" equality which is a pretty weird\n+    // definition. We mostly want to catch actual changes to the AST\n+    // like a `#[cfg]` being processed or some weird `macro_rules!`\n+    // expansion.\n+    //\n+    // What we *don't* want to catch is the fact that a user-defined\n+    // literal like `0xf` is stringified as `15`, causing the cached token\n+    // stream to not be literal `==` token-wise (ignoring spans) to the\n+    // token stream we got from stringification.\n+    //\n+    // Instead the \"probably equal\" check here is \"does each token\n+    // recursively have the same discriminant?\" We basically don't look at\n+    // the token values here and assume that such fine grained token stream\n+    // modifications, including adding/removing typically non-semantic\n+    // tokens such as extra braces and commas, don't happen.\n+    if let Some(tokens) = tokens {\n+        if tokens.probably_equal_for_proc_macro(&tokens_for_real) {\n+            return tokens\n+        }\n+        info!(\"cached tokens found, but they're not \\\"probably equal\\\", \\\n+                going with stringified version\");\n+    }\n+    return tokens_for_real\n+}\n+\n+fn prepend_attrs(\n+    sess: &ParseSess,\n+    attrs: &[ast::Attribute],\n+    tokens: Option<&tokenstream::TokenStream>,\n+    span: syntax_pos::Span\n+) -> Option<tokenstream::TokenStream> {\n+    let tokens = tokens?;\n+    if attrs.len() == 0 {\n+        return Some(tokens.clone())\n+    }\n+    let mut builder = tokenstream::TokenStreamBuilder::new();\n+    for attr in attrs {\n+        assert_eq!(attr.style, ast::AttrStyle::Outer,\n+                   \"inner attributes should prevent cached tokens from existing\");\n+\n+        let source = pprust::attribute_to_string(attr);\n+        let macro_filename = FileName::macro_expansion_source_code(&source);\n+        if attr.is_sugared_doc {\n+            let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n+            builder.push(stream);\n+            continue\n+        }\n+\n+        // synthesize # [ $path $tokens ] manually here\n+        let mut brackets = tokenstream::TokenStreamBuilder::new();\n+\n+        // For simple paths, push the identifier directly\n+        if attr.path.segments.len() == 1 && attr.path.segments[0].args.is_none() {\n+            let ident = attr.path.segments[0].ident;\n+            let token = token::Ident(ident.name, ident.as_str().starts_with(\"r#\"));\n+            brackets.push(tokenstream::TokenTree::token(token, ident.span));\n+\n+        // ... and for more complicated paths, fall back to a reparse hack that\n+        // should eventually be removed.\n+        } else {\n+            let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n+            brackets.push(stream);\n+        }\n+\n+        brackets.push(attr.tokens.clone());\n+\n+        // The span we list here for `#` and for `[ ... ]` are both wrong in\n+        // that it encompasses more than each token, but it hopefully is \"good\n+        // enough\" for now at least.\n+        builder.push(tokenstream::TokenTree::token(token::Pound, attr.span));\n+        let delim_span = tokenstream::DelimSpan::from_single(attr.span);\n+        builder.push(tokenstream::TokenTree::Delimited(\n+            delim_span, token::DelimToken::Bracket, brackets.build().into()));\n+    }\n+    builder.push(tokens.clone());\n+    Some(builder.build())\n+}"}, {"sha": "400bf0f3856aa8c7319706251df8ca8bf3cab156", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 283, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -9,20 +9,19 @@ mod path;\n pub use path::PathStyle;\n mod stmt;\n mod generics;\n+use super::diagnostics::Error;\n \n use crate::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, Ident,\n-    IsAsync, MacDelimiter, Mutability, Param, StrStyle, SelfKind, TyKind, Visibility,\n-    VisibilityKind, Unsafety,\n+    self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n+    IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n };\n use crate::parse::{ParseSess, PResult, Directory, DirectoryOwnership, SeqSep, literal, token};\n-use crate::parse::diagnostics::{Error, dummy_arg};\n use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::{Token, TokenKind, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::source_map::{self, respan};\n+use crate::source_map::respan;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use crate::ThinVec;\n@@ -56,17 +55,6 @@ crate enum BlockMode {\n     Ignore,\n }\n \n-/// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n-struct ParamCfg {\n-    /// Is `self` is allowed as the first parameter?\n-    is_self_allowed: bool,\n-    /// Is `...` allowed as the tail of the parameter list?\n-    allow_c_variadic: bool,\n-    /// `is_name_required` decides if, per-parameter,\n-    /// the parameter must have a pattern or just a type.\n-    is_name_required: fn(&token::Token) -> bool,\n-}\n-\n /// Like `maybe_whole_expr`, but for things other than expressions.\n #[macro_export]\n macro_rules! maybe_whole {\n@@ -1105,271 +1093,6 @@ impl<'a> Parser<'a> {\n         res\n     }\n \n-    /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n-    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n-        let sp = self.token.span;\n-        let is_trait_item = cfg.is_self_allowed;\n-        let mut c_variadic = false;\n-        // Parse the arguments, starting out with `self` being possibly allowed...\n-        let (params, _) = self.parse_paren_comma_seq(|p| {\n-            let param = p.parse_param_general(&cfg, is_trait_item);\n-            // ...now that we've parsed the first argument, `self` is no longer allowed.\n-            cfg.is_self_allowed = false;\n-\n-            match param {\n-                Ok(param) => Ok(\n-                    if let TyKind::CVarArgs = param.ty.kind {\n-                        c_variadic = true;\n-                        if p.token != token::CloseDelim(token::Paren) {\n-                            p.span_err(\n-                                p.token.span,\n-                                \"`...` must be the last argument of a C-variadic function\",\n-                            );\n-                            // FIXME(eddyb) this should probably still push `CVarArgs`.\n-                            // Maybe AST validation/HIR lowering should emit the above error?\n-                            None\n-                        } else {\n-                            Some(param)\n-                        }\n-                    } else {\n-                        Some(param)\n-                    }\n-                ),\n-                Err(mut e) => {\n-                    e.emit();\n-                    let lo = p.prev_span;\n-                    // Skip every token until next possible arg or end.\n-                    p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n-                    // Create a placeholder argument for proper arg count (issue #34264).\n-                    let span = lo.to(p.prev_span);\n-                    Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n-                }\n-            }\n-        })?;\n-\n-        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n-\n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut params);\n-\n-        if c_variadic && params.len() <= 1 {\n-            self.span_err(\n-                sp,\n-                \"C-variadic function must be declared with at least one named argument\",\n-            );\n-        }\n-\n-        Ok(params)\n-    }\n-\n-    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n-    /// error.\n-    /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n-        let lo = self.token.span;\n-        let attrs = self.parse_outer_attributes()?;\n-\n-        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n-        if let Some(mut param) = self.parse_self_param()? {\n-            param.attrs = attrs.into();\n-            return if cfg.is_self_allowed {\n-                Ok(param)\n-            } else {\n-                self.recover_bad_self_param(param, is_trait_item)\n-            };\n-        }\n-\n-        let is_name_required = match self.token.kind {\n-            token::DotDotDot => false,\n-            _ => (cfg.is_name_required)(&self.token),\n-        };\n-        let (pat, ty) = if is_name_required || self.is_named_param() {\n-            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n-\n-            let pat = self.parse_fn_param_pat()?;\n-            if let Err(mut err) = self.expect(&token::Colon) {\n-                return if let Some(ident) = self.parameter_without_type(\n-                    &mut err,\n-                    pat,\n-                    is_name_required,\n-                    cfg.is_self_allowed,\n-                    is_trait_item,\n-                ) {\n-                    err.emit();\n-                    Ok(dummy_arg(ident))\n-                } else {\n-                    Err(err)\n-                };\n-            }\n-\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n-        } else {\n-            debug!(\"parse_param_general ident_to_pat\");\n-            let parser_snapshot_before_ty = self.clone();\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n-            if ty.is_ok() && self.token != token::Comma &&\n-               self.token != token::CloseDelim(token::Paren) {\n-                // This wasn't actually a type, but a pattern looking like a type,\n-                // so we are going to rollback and re-parse for recovery.\n-                ty = self.unexpected();\n-            }\n-            match ty {\n-                Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let bm = BindingMode::ByValue(Mutability::Immutable);\n-                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n-                    (pat, ty)\n-                }\n-                // If this is a C-variadic argument and we hit an error, return the error.\n-                Err(err) if self.token == token::DotDotDot => return Err(err),\n-                // Recover from attempting to parse the argument as a type without pattern.\n-                Err(mut err) => {\n-                    err.cancel();\n-                    mem::replace(self, parser_snapshot_before_ty);\n-                    self.recover_arg_parse()?\n-                }\n-            }\n-        };\n-\n-        let span = lo.to(self.token.span);\n-\n-        Ok(Param {\n-            attrs: attrs.into(),\n-            id: ast::DUMMY_NODE_ID,\n-            is_placeholder: false,\n-            pat,\n-            span,\n-            ty,\n-        })\n-    }\n-\n-    /// Returns the parsed optional self parameter and whether a self shortcut was used.\n-    ///\n-    /// See `parse_self_param_with_attrs` to collect attributes.\n-    fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n-        // Extract an identifier *after* having confirmed that the token is one.\n-        let expect_self_ident = |this: &mut Self| {\n-            match this.token.kind {\n-                // Preserve hygienic context.\n-                token::Ident(name, _) => {\n-                    let span = this.token.span;\n-                    this.bump();\n-                    Ident::new(name, span)\n-                }\n-                _ => unreachable!(),\n-            }\n-        };\n-        // Is `self` `n` tokens ahead?\n-        let is_isolated_self = |this: &Self, n| {\n-            this.is_keyword_ahead(n, &[kw::SelfLower])\n-            && this.look_ahead(n + 1, |t| t != &token::ModSep)\n-        };\n-        // Is `mut self` `n` tokens ahead?\n-        let is_isolated_mut_self = |this: &Self, n| {\n-            this.is_keyword_ahead(n, &[kw::Mut])\n-            && is_isolated_self(this, n + 1)\n-        };\n-        // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n-        let parse_self_possibly_typed = |this: &mut Self, m| {\n-            let eself_ident = expect_self_ident(this);\n-            let eself_hi = this.prev_span;\n-            let eself = if this.eat(&token::Colon) {\n-                SelfKind::Explicit(this.parse_ty()?, m)\n-            } else {\n-                SelfKind::Value(m)\n-            };\n-            Ok((eself, eself_ident, eself_hi))\n-        };\n-        // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n-        let recover_self_ptr = |this: &mut Self| {\n-            let msg = \"cannot pass `self` by raw pointer\";\n-            let span = this.token.span;\n-            this.struct_span_err(span, msg)\n-                .span_label(span, msg)\n-                .emit();\n-\n-            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n-        };\n-\n-        // Parse optional `self` parameter of a method.\n-        // Only a limited set of initial token sequences is considered `self` parameters; anything\n-        // else is parsed as a normal function parameter list, so some lookahead is required.\n-        let eself_lo = self.token.span;\n-        let (eself, eself_ident, eself_hi) = match self.token.kind {\n-            token::BinOp(token::And) => {\n-                let eself = if is_isolated_self(self, 1) {\n-                    // `&self`\n-                    self.bump();\n-                    SelfKind::Region(None, Mutability::Immutable)\n-                } else if is_isolated_mut_self(self, 1) {\n-                    // `&mut self`\n-                    self.bump();\n-                    self.bump();\n-                    SelfKind::Region(None, Mutability::Mutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n-                    // `&'lt self`\n-                    self.bump();\n-                    let lt = self.expect_lifetime();\n-                    SelfKind::Region(Some(lt), Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n-                    // `&'lt mut self`\n-                    self.bump();\n-                    let lt = self.expect_lifetime();\n-                    self.bump();\n-                    SelfKind::Region(Some(lt), Mutability::Mutable)\n-                } else {\n-                    // `&not_self`\n-                    return Ok(None);\n-                };\n-                (eself, expect_self_ident(self), self.prev_span)\n-            }\n-            // `*self`\n-            token::BinOp(token::Star) if is_isolated_self(self, 1) => {\n-                self.bump();\n-                recover_self_ptr(self)?\n-            }\n-            // `*mut self` and `*const self`\n-            token::BinOp(token::Star) if\n-                self.look_ahead(1, |t| t.is_mutability())\n-                && is_isolated_self(self, 2) =>\n-            {\n-                self.bump();\n-                self.bump();\n-                recover_self_ptr(self)?\n-            }\n-            // `self` and `self: TYPE`\n-            token::Ident(..) if is_isolated_self(self, 0) => {\n-                parse_self_possibly_typed(self, Mutability::Immutable)?\n-            }\n-            // `mut self` and `mut self: TYPE`\n-            token::Ident(..) if is_isolated_mut_self(self, 0) => {\n-                self.bump();\n-                parse_self_possibly_typed(self, Mutability::Mutable)?\n-            }\n-            _ => return Ok(None),\n-        };\n-\n-        let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n-        Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n-    }\n-\n-    fn is_named_param(&self) -> bool {\n-        let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n-                _ => 0,\n-            }\n-            token::BinOp(token::And) | token::AndAnd => 1,\n-            _ if self.token.is_keyword(kw::Mut) => 1,\n-            _ => 0,\n-        };\n-\n-        self.look_ahead(offset, |t| t.is_ident()) &&\n-        self.look_ahead(offset + 1, |t| t == &token::Colon)\n-    }\n-\n     fn is_crate_vis(&self) -> bool {\n         self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n     }\n@@ -1454,12 +1177,14 @@ impl<'a> Parser<'a> {\n `pub(super)`: visible only in the current module's parent\n `pub(in path::to::module)`: visible only on the specified path\"##;\n \n+        let path_str = pprust::path_to_string(&path);\n+\n         struct_span_err!(self.sess.span_diagnostic, path.span, E0704, \"{}\", msg)\n             .help(suggestion)\n             .span_suggestion(\n                 path.span,\n-                &format!(\"make this visible only to module `{}` with `in`\", path),\n-                format!(\"in {}\", path),\n+                &format!(\"make this visible only to module `{}` with `in`\", path_str),\n+                format!(\"in {}\", path_str),\n                 Applicability::MachineApplicable,\n             )\n             .emit();"}, {"sha": "660bf9b7d65f169b48a9263eeabe3384ae83a102", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -552,8 +552,11 @@ impl<'a> Parser<'a> {\n \n                         // Report non-fatal diagnostics, keep `x as usize` as an expression\n                         // in AST and continue parsing.\n-                        let msg = format!(\"`<` is interpreted as a start of generic \\\n-                                           arguments for `{}`, not a {}\", path, op_noun);\n+                        let msg = format!(\n+                            \"`<` is interpreted as a start of generic arguments for `{}`, not a {}\",\n+                            pprust::path_to_string(&path),\n+                            op_noun,\n+                        );\n                         let span_after_type = parser_snapshot_after_type.token.span;\n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,"}, {"sha": "08c624b5539d153ad7ad08556fef72911548ec1a", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 485, "deletions": 205, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -1,28 +1,23 @@\n-use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode, ParamCfg};\n-\n+use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode};\n use crate::maybe_whole;\n use crate::ptr::P;\n-use crate::ast::{\n-    self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle,\n-    Item, ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind,\n-    UseTree, UseTreeKind, PathSegment,\n-    IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n-    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n-    ForeignItem, ForeignItemKind,\n-    Ty, TyKind, Generics, GenericBounds, TraitRef,\n-    EnumDef, VariantData, StructField, AnonConst,\n-    Mac, MacDelimiter,\n-};\n+use crate::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle, AnonConst, Item, ItemKind};\n+use crate::ast::{ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n+use crate::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n+use crate::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n+use crate::ast::{Ty, TyKind, Generics, GenericBounds, TraitRef, EnumDef, VariantData, StructField};\n+use crate::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, MethodSig, SelfKind, Param};\n use crate::ext::base::DummyResult;\n use crate::parse::token;\n use crate::parse::parser::maybe_append;\n-use crate::parse::diagnostics::Error;\n+use crate::parse::diagnostics::{Error, dummy_arg};\n use crate::tokenstream::{TokenTree, TokenStream};\n-use crate::source_map::{respan, Span};\n use crate::symbol::{kw, sym};\n+use crate::source_map::{self, respan, Span};\n+use crate::ThinVec;\n \n-use std::mem;\n use log::debug;\n+use std::mem;\n use rustc_target::spec::abi::Abi;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n \n@@ -412,7 +407,7 @@ impl<'a> Parser<'a> {\n         self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n     }\n \n-    fn mk_item_with_info(\n+    pub(super) fn mk_item_with_info(\n         &self,\n         attrs: Vec<Attribute>,\n         lo: Span,\n@@ -425,16 +420,6 @@ impl<'a> Parser<'a> {\n         Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n     }\n \n-    fn recover_first_param(&mut self) -> &'static str {\n-        match self.parse_outer_attributes()\n-            .and_then(|_| self.parse_self_param())\n-            .map_err(|mut e| e.cancel())\n-        {\n-            Ok(Some(_)) => \"method\",\n-            _ => \"function\",\n-        }\n-    }\n-\n     /// This is the fall-through for parsing items.\n     fn parse_macro_use_or_failure(\n         &mut self,\n@@ -707,9 +692,11 @@ impl<'a> Parser<'a> {\n         Ok(item)\n     }\n \n-    fn parse_impl_item_(&mut self,\n-                        at_end: &mut bool,\n-                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n+    fn parse_impl_item_(\n+        &mut self,\n+        at_end: &mut bool,\n+        mut attrs: Vec<Attribute>,\n+    ) -> PResult<'a, ImplItem> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness();\n@@ -722,8 +709,11 @@ impl<'a> Parser<'a> {\n             (name, kind, generics)\n         } else if self.is_const_item() {\n             self.parse_impl_const()?\n+        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(&vis), at_end)? {\n+            // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n+            (Ident::invalid(), ast::ImplItemKind::Macro(mac), Generics::default())\n         } else {\n-            let (name, inner_attrs, generics, kind) = self.parse_impl_method(&vis, at_end)?;\n+            let (name, inner_attrs, generics, kind) = self.parse_impl_method(at_end)?;\n             attrs.extend(inner_attrs);\n             (name, kind, generics)\n         };\n@@ -783,71 +773,6 @@ impl<'a> Parser<'a> {\n         Ok((name, ImplItemKind::Const(typ, expr), Generics::default()))\n     }\n \n-    /// Parses a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(\n-        &mut self,\n-        vis: &Visibility,\n-        at_end: &mut bool\n-    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n-        // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n-        if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n-            // method macro\n-            Ok((Ident::invalid(), vec![], Generics::default(), ast::ImplItemKind::Macro(mac)))\n-        } else {\n-            let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n-            *at_end = true;\n-            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n-        }\n-    }\n-\n-    /// Parse the \"signature\", including the identifier, parameters, and generics\n-    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n-    fn parse_method_sig(\n-        &mut self,\n-        is_name_required: fn(&token::Token) -> bool,\n-    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n-        let header = self.parse_fn_front_matter()?;\n-        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n-            is_self_allowed: true,\n-            allow_c_variadic: false,\n-            is_name_required,\n-        })?;\n-        Ok((ident, MethodSig { header, decl }, generics))\n-    }\n-\n-    /// Parses all the \"front matter\" for a `fn` declaration, up to\n-    /// and including the `fn` keyword:\n-    ///\n-    /// - `const fn`\n-    /// - `unsafe fn`\n-    /// - `const unsafe fn`\n-    /// - `extern fn`\n-    /// - etc.\n-    fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n-        let is_const_fn = self.eat_keyword(kw::Const);\n-        let const_span = self.prev_span;\n-        let asyncness = self.parse_asyncness();\n-        if let IsAsync::Async { .. } = asyncness {\n-            self.ban_async_in_2015(self.prev_span);\n-        }\n-        let asyncness = respan(self.prev_span, asyncness);\n-        let unsafety = self.parse_unsafety();\n-        let (constness, unsafety, abi) = if is_const_fn {\n-            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n-        } else {\n-            let abi = self.parse_extern_abi()?;\n-            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n-        };\n-        if !self.eat_keyword(kw::Fn) {\n-            // It is possible for `expect_one_of` to recover given the contents of\n-            // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n-            // account for this.\n-            if !self.expect_one_of(&[], &[])? { unreachable!() }\n-        }\n-        Ok(FnHeader { constness, unsafety, asyncness, abi })\n-    }\n-\n     /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n     fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n         // Parse optional `auto` prefix.\n@@ -957,13 +882,7 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), TraitItemKind::Macro(mac), Generics::default())\n         } else {\n-            // This is somewhat dubious; We don't want to allow\n-            // argument names to be left off if there is a definition...\n-            //\n-            // We don't allow argument names to be left off in edition 2018.\n-            let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n-            let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n-            (ident, TraitItemKind::Method(sig, body), generics)\n+            self.parse_trait_item_method(at_end, &mut attrs)?\n         };\n \n         Ok(TraitItem {\n@@ -991,43 +910,6 @@ impl<'a> Parser<'a> {\n         Ok((ident, TraitItemKind::Const(ty, default), Generics::default()))\n     }\n \n-    /// Parse the \"body\" of a method in a trait item definition.\n-    /// This can either be `;` when there's no body,\n-    /// or e.g. a block when the method is a provided one.\n-    fn parse_trait_method_body(\n-        &mut self,\n-        at_end: &mut bool,\n-        attrs: &mut Vec<Attribute>,\n-    ) -> PResult<'a, Option<P<Block>>> {\n-        Ok(match self.token.kind {\n-            token::Semi => {\n-                debug!(\"parse_trait_method_body(): parsing required method\");\n-                self.bump();\n-                *at_end = true;\n-                None\n-            }\n-            token::OpenDelim(token::Brace) => {\n-                debug!(\"parse_trait_method_body(): parsing provided method\");\n-                *at_end = true;\n-                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                attrs.extend(inner_attrs.iter().cloned());\n-                Some(body)\n-            }\n-            token::Interpolated(ref nt) => {\n-                match **nt {\n-                    token::NtBlock(..) => {\n-                        *at_end = true;\n-                        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                        attrs.extend(inner_attrs.iter().cloned());\n-                        Some(body)\n-                    }\n-                    _ => return self.expected_semi_or_open_brace(),\n-                }\n-            }\n-            _ => return self.expected_semi_or_open_brace(),\n-        })\n-    }\n-\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n@@ -1194,45 +1076,6 @@ impl<'a> Parser<'a> {\n         Ok(ident)\n     }\n \n-    /// Parses an item-position function declaration.\n-    fn parse_item_fn(\n-        &mut self,\n-        lo: Span,\n-        vis: Visibility,\n-        attrs: Vec<Attribute>,\n-        header: FnHeader,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n-            is_self_allowed: false,\n-            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n-            is_name_required: |_| true,\n-        })?;\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let kind = ItemKind::Fn(decl, header, generics, body);\n-        self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n-    }\n-\n-    /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n-    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n-        let ident = self.parse_ident()?;\n-        let mut generics = self.parse_generics()?;\n-        let decl = self.parse_fn_decl(cfg, true)?;\n-        generics.where_clause = self.parse_where_clause()?;\n-        Ok((ident, decl, generics))\n-    }\n-\n-    /// Parses the parameter list and result type of a function declaration.\n-    pub(super) fn parse_fn_decl(\n-        &mut self,\n-        cfg: ParamCfg,\n-        ret_allow_plus: bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        Ok(P(FnDecl {\n-            inputs: self.parse_fn_params(cfg)?,\n-            output: self.parse_ret_ty(ret_allow_plus)?,\n-        }))\n-    }\n-\n     /// Parses `extern` for foreign ABIs modules.\n     ///\n     /// `extern` is expected to have been\n@@ -1344,32 +1187,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a function declaration from a foreign module.\n-    fn parse_item_foreign_fn(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-        extern_sp: Span,\n-    ) -> PResult<'a, ForeignItem> {\n-        self.expect_keyword(kw::Fn)?;\n-        let (ident, decl, generics) = self.parse_fn_sig(super::ParamCfg {\n-            is_self_allowed: false,\n-            allow_c_variadic: true,\n-            is_name_required: |_| true,\n-        })?;\n-        let span = lo.to(self.token.span);\n-        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n-        Ok(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Fn(decl, generics),\n-            id: DUMMY_NODE_ID,\n-            span,\n-            vis,\n-        })\n-    }\n-\n     /// Parses a static item from a foreign module.\n     /// Assumes that the `static` keyword is already parsed.\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n@@ -1910,3 +1727,466 @@ impl<'a> Parser<'a> {\n         })\n     }\n }\n+\n+/// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n+pub(super) struct ParamCfg {\n+    /// Is `self` is allowed as the first parameter?\n+    pub is_self_allowed: bool,\n+    /// Is `...` allowed as the tail of the parameter list?\n+    pub allow_c_variadic: bool,\n+    /// `is_name_required` decides if, per-parameter,\n+    /// the parameter must have a pattern or just a type.\n+    pub is_name_required: fn(&token::Token) -> bool,\n+}\n+\n+/// Parsing of functions and methods.\n+impl<'a> Parser<'a> {\n+    /// Parses an item-position function declaration.\n+    fn parse_item_fn(\n+        &mut self,\n+        lo: Span,\n+        vis: Visibility,\n+        attrs: Vec<Attribute>,\n+        header: FnHeader,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n+            is_name_required: |_| true,\n+        })?;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        let kind = ItemKind::Fn(decl, header, generics, body);\n+        self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n+    }\n+\n+    /// Parses a function declaration from a foreign module.\n+    fn parse_item_foreign_fn(\n+        &mut self,\n+        vis: ast::Visibility,\n+        lo: Span,\n+        attrs: Vec<Attribute>,\n+        extern_sp: Span,\n+    ) -> PResult<'a, ForeignItem> {\n+        self.expect_keyword(kw::Fn)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| true,\n+        })?;\n+        let span = lo.to(self.token.span);\n+        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n+        Ok(ast::ForeignItem {\n+            ident,\n+            attrs,\n+            kind: ForeignItemKind::Fn(decl, generics),\n+            id: DUMMY_NODE_ID,\n+            span,\n+            vis,\n+        })\n+    }\n+\n+    /// Parses a method or a macro invocation in a trait impl.\n+    fn parse_impl_method(\n+        &mut self,\n+        at_end: &mut bool,\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n+        let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n+        *at_end = true;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n+    }\n+\n+    fn parse_trait_item_method(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+    ) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+        // This is somewhat dubious; We don't want to allow\n+        // argument names to be left off if there is a definition...\n+        //\n+        // We don't allow argument names to be left off in edition 2018.\n+        let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n+        let body = self.parse_trait_method_body(at_end, attrs)?;\n+        Ok((ident, TraitItemKind::Method(sig, body), generics))\n+    }\n+\n+    /// Parse the \"body\" of a method in a trait item definition.\n+    /// This can either be `;` when there's no body,\n+    /// or e.g. a block when the method is a provided one.\n+    fn parse_trait_method_body(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+    ) -> PResult<'a, Option<P<Block>>> {\n+        Ok(match self.token.kind {\n+            token::Semi => {\n+                debug!(\"parse_trait_method_body(): parsing required method\");\n+                self.bump();\n+                *at_end = true;\n+                None\n+            }\n+            token::OpenDelim(token::Brace) => {\n+                debug!(\"parse_trait_method_body(): parsing provided method\");\n+                *at_end = true;\n+                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                attrs.extend(inner_attrs.iter().cloned());\n+                Some(body)\n+            }\n+            token::Interpolated(ref nt) => {\n+                match **nt {\n+                    token::NtBlock(..) => {\n+                        *at_end = true;\n+                        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                        attrs.extend(inner_attrs.iter().cloned());\n+                        Some(body)\n+                    }\n+                    _ => return self.expected_semi_or_open_brace(),\n+                }\n+            }\n+            _ => return self.expected_semi_or_open_brace(),\n+        })\n+    }\n+\n+    /// Parse the \"signature\", including the identifier, parameters, and generics\n+    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n+    fn parse_method_sig(\n+        &mut self,\n+        is_name_required: fn(&token::Token) -> bool,\n+    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n+        let header = self.parse_fn_front_matter()?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: true,\n+            allow_c_variadic: false,\n+            is_name_required,\n+        })?;\n+        Ok((ident, MethodSig { header, decl }, generics))\n+    }\n+\n+    /// Parses all the \"front matter\" for a `fn` declaration, up to\n+    /// and including the `fn` keyword:\n+    ///\n+    /// - `const fn`\n+    /// - `unsafe fn`\n+    /// - `const unsafe fn`\n+    /// - `extern fn`\n+    /// - etc.\n+    fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n+        let is_const_fn = self.eat_keyword(kw::Const);\n+        let const_span = self.prev_span;\n+        let asyncness = self.parse_asyncness();\n+        if let IsAsync::Async { .. } = asyncness {\n+            self.ban_async_in_2015(self.prev_span);\n+        }\n+        let asyncness = respan(self.prev_span, asyncness);\n+        let unsafety = self.parse_unsafety();\n+        let (constness, unsafety, abi) = if is_const_fn {\n+            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n+        } else {\n+            let abi = self.parse_extern_abi()?;\n+            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n+        };\n+        if !self.eat_keyword(kw::Fn) {\n+            // It is possible for `expect_one_of` to recover given the contents of\n+            // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n+            // account for this.\n+            if !self.expect_one_of(&[], &[])? { unreachable!() }\n+        }\n+        Ok(FnHeader { constness, unsafety, asyncness, abi })\n+    }\n+\n+    /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n+    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        let decl = self.parse_fn_decl(cfg, true)?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        Ok((ident, decl, generics))\n+    }\n+\n+    /// Parses the parameter list and result type of a function declaration.\n+    pub(super) fn parse_fn_decl(\n+        &mut self,\n+        cfg: ParamCfg,\n+        ret_allow_plus: bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n+        Ok(P(FnDecl {\n+            inputs: self.parse_fn_params(cfg)?,\n+            output: self.parse_ret_ty(ret_allow_plus)?,\n+        }))\n+    }\n+\n+    /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n+    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n+        let sp = self.token.span;\n+        let is_trait_item = cfg.is_self_allowed;\n+        let mut c_variadic = false;\n+        // Parse the arguments, starting out with `self` being possibly allowed...\n+        let (params, _) = self.parse_paren_comma_seq(|p| {\n+            let param = p.parse_param_general(&cfg, is_trait_item);\n+            // ...now that we've parsed the first argument, `self` is no longer allowed.\n+            cfg.is_self_allowed = false;\n+\n+            match param {\n+                Ok(param) => Ok(\n+                    if let TyKind::CVarArgs = param.ty.kind {\n+                        c_variadic = true;\n+                        if p.token != token::CloseDelim(token::Paren) {\n+                            p.span_err(\n+                                p.token.span,\n+                                \"`...` must be the last argument of a C-variadic function\",\n+                            );\n+                            // FIXME(eddyb) this should probably still push `CVarArgs`.\n+                            // Maybe AST validation/HIR lowering should emit the above error?\n+                            None\n+                        } else {\n+                            Some(param)\n+                        }\n+                    } else {\n+                        Some(param)\n+                    }\n+                ),\n+                Err(mut e) => {\n+                    e.emit();\n+                    let lo = p.prev_span;\n+                    // Skip every token until next possible arg or end.\n+                    p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                    // Create a placeholder argument for proper arg count (issue #34264).\n+                    let span = lo.to(p.prev_span);\n+                    Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n+                }\n+            }\n+        })?;\n+\n+        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut params);\n+\n+        if c_variadic && params.len() <= 1 {\n+            self.span_err(\n+                sp,\n+                \"C-variadic function must be declared with at least one named argument\",\n+            );\n+        }\n+\n+        Ok(params)\n+    }\n+\n+    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n+    /// error.\n+    /// This version of parse param doesn't necessarily require identifier names.\n+    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_outer_attributes()?;\n+\n+        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n+        if let Some(mut param) = self.parse_self_param()? {\n+            param.attrs = attrs.into();\n+            return if cfg.is_self_allowed {\n+                Ok(param)\n+            } else {\n+                self.recover_bad_self_param(param, is_trait_item)\n+            };\n+        }\n+\n+        let is_name_required = match self.token.kind {\n+            token::DotDotDot => false,\n+            _ => (cfg.is_name_required)(&self.token),\n+        };\n+        let (pat, ty) = if is_name_required || self.is_named_param() {\n+            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n+\n+            let pat = self.parse_fn_param_pat()?;\n+            if let Err(mut err) = self.expect(&token::Colon) {\n+                return if let Some(ident) = self.parameter_without_type(\n+                    &mut err,\n+                    pat,\n+                    is_name_required,\n+                    cfg.is_self_allowed,\n+                    is_trait_item,\n+                ) {\n+                    err.emit();\n+                    Ok(dummy_arg(ident))\n+                } else {\n+                    Err(err)\n+                };\n+            }\n+\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n+        } else {\n+            debug!(\"parse_param_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n+            if ty.is_ok() && self.token != token::Comma &&\n+               self.token != token::CloseDelim(token::Paren) {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(kw::Invalid, self.prev_span);\n+                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n+                    (pat, ty)\n+                }\n+                // If this is a C-variadic argument and we hit an error, return the error.\n+                Err(err) if self.token == token::DotDotDot => return Err(err),\n+                // Recover from attempting to parse the argument as a type without pattern.\n+                Err(mut err) => {\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    self.recover_arg_parse()?\n+                }\n+            }\n+        };\n+\n+        let span = lo.to(self.token.span);\n+\n+        Ok(Param {\n+            attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n+            is_placeholder: false,\n+            pat,\n+            span,\n+            ty,\n+        })\n+    }\n+\n+    /// Returns the parsed optional self parameter and whether a self shortcut was used.\n+    ///\n+    /// See `parse_self_param_with_attrs` to collect attributes.\n+    fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n+        // Extract an identifier *after* having confirmed that the token is one.\n+        let expect_self_ident = |this: &mut Self| {\n+            match this.token.kind {\n+                // Preserve hygienic context.\n+                token::Ident(name, _) => {\n+                    let span = this.token.span;\n+                    this.bump();\n+                    Ident::new(name, span)\n+                }\n+                _ => unreachable!(),\n+            }\n+        };\n+        // Is `self` `n` tokens ahead?\n+        let is_isolated_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::SelfLower])\n+            && this.look_ahead(n + 1, |t| t != &token::ModSep)\n+        };\n+        // Is `mut self` `n` tokens ahead?\n+        let is_isolated_mut_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::Mut])\n+            && is_isolated_self(this, n + 1)\n+        };\n+        // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n+        let parse_self_possibly_typed = |this: &mut Self, m| {\n+            let eself_ident = expect_self_ident(this);\n+            let eself_hi = this.prev_span;\n+            let eself = if this.eat(&token::Colon) {\n+                SelfKind::Explicit(this.parse_ty()?, m)\n+            } else {\n+                SelfKind::Value(m)\n+            };\n+            Ok((eself, eself_ident, eself_hi))\n+        };\n+        // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n+        let recover_self_ptr = |this: &mut Self| {\n+            let msg = \"cannot pass `self` by raw pointer\";\n+            let span = this.token.span;\n+            this.struct_span_err(span, msg)\n+                .span_label(span, msg)\n+                .emit();\n+\n+            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n+        };\n+\n+        // Parse optional `self` parameter of a method.\n+        // Only a limited set of initial token sequences is considered `self` parameters; anything\n+        // else is parsed as a normal function parameter list, so some lookahead is required.\n+        let eself_lo = self.token.span;\n+        let (eself, eself_ident, eself_hi) = match self.token.kind {\n+            token::BinOp(token::And) => {\n+                let eself = if is_isolated_self(self, 1) {\n+                    // `&self`\n+                    self.bump();\n+                    SelfKind::Region(None, Mutability::Immutable)\n+                } else if is_isolated_mut_self(self, 1) {\n+                    // `&mut self`\n+                    self.bump();\n+                    self.bump();\n+                    SelfKind::Region(None, Mutability::Mutable)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n+                    // `&'lt self`\n+                    self.bump();\n+                    let lt = self.expect_lifetime();\n+                    SelfKind::Region(Some(lt), Mutability::Immutable)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n+                    // `&'lt mut self`\n+                    self.bump();\n+                    let lt = self.expect_lifetime();\n+                    self.bump();\n+                    SelfKind::Region(Some(lt), Mutability::Mutable)\n+                } else {\n+                    // `&not_self`\n+                    return Ok(None);\n+                };\n+                (eself, expect_self_ident(self), self.prev_span)\n+            }\n+            // `*self`\n+            token::BinOp(token::Star) if is_isolated_self(self, 1) => {\n+                self.bump();\n+                recover_self_ptr(self)?\n+            }\n+            // `*mut self` and `*const self`\n+            token::BinOp(token::Star) if\n+                self.look_ahead(1, |t| t.is_mutability())\n+                && is_isolated_self(self, 2) =>\n+            {\n+                self.bump();\n+                self.bump();\n+                recover_self_ptr(self)?\n+            }\n+            // `self` and `self: TYPE`\n+            token::Ident(..) if is_isolated_self(self, 0) => {\n+                parse_self_possibly_typed(self, Mutability::Immutable)?\n+            }\n+            // `mut self` and `mut self: TYPE`\n+            token::Ident(..) if is_isolated_mut_self(self, 0) => {\n+                self.bump();\n+                parse_self_possibly_typed(self, Mutability::Mutable)?\n+            }\n+            _ => return Ok(None),\n+        };\n+\n+        let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n+        Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n+    }\n+\n+    fn is_named_param(&self) -> bool {\n+        let offset = match self.token.kind {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n+                _ => 0,\n+            }\n+            token::BinOp(token::And) | token::AndAnd => 1,\n+            _ if self.token.is_keyword(kw::Mut) => 1,\n+            _ => 0,\n+        };\n+\n+        self.look_ahead(offset, |t| t.is_ident()) &&\n+        self.look_ahead(offset + 1, |t| t == &token::Colon)\n+    }\n+\n+    fn recover_first_param(&mut self) -> &'static str {\n+        match self.parse_outer_attributes()\n+            .and_then(|_| self.parse_self_param())\n+            .map_err(|mut e| e.cancel())\n+        {\n+            Ok(Some(_)) => \"method\",\n+            _ => \"function\",\n+        }\n+    }\n+}"}, {"sha": "e696ab0804d6929f0e6c4215f52ddc1267476323", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -1,4 +1,5 @@\n use super::{Parser, PResult, PathStyle, PrevTokenKind, TokenType};\n+use super::item::ParamCfg;\n \n use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n use crate::ptr::P;\n@@ -281,7 +282,7 @@ impl<'a> Parser<'a> {\n         let unsafety = self.parse_unsafety();\n         let abi = self.parse_extern_abi()?;\n         self.expect_keyword(kw::Fn)?;\n-        let cfg = super::ParamCfg {\n+        let cfg = ParamCfg {\n             is_self_allowed: false,\n             allow_c_variadic: true,\n             is_name_required: |_| false,"}, {"sha": "eb74ab2b9192d8b73af9edae549d368f90dbbf09", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 134, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,16 +4,13 @@ pub use DelimToken::*;\n pub use LitKind::*;\n pub use TokenKind::*;\n \n-use crate::ast::{self};\n-use crate::parse::{parse_stream_from_source_str, ParseSess};\n-use crate::print::pprust;\n+use crate::ast;\n use crate::ptr::P;\n use crate::symbol::kw;\n-use crate::tokenstream::{self, DelimSpan, TokenStream, TokenTree};\n+use crate::tokenstream::TokenTree;\n \n use syntax_pos::symbol::Symbol;\n-use syntax_pos::{self, Span, FileName, DUMMY_SP};\n-use log::info;\n+use syntax_pos::{self, Span, DUMMY_SP};\n \n use std::fmt;\n use std::mem;\n@@ -737,131 +734,3 @@ impl fmt::Debug for Nonterminal {\n         }\n     }\n }\n-\n-impl Nonterminal {\n-    pub fn to_tokenstream(&self, sess: &ParseSess, span: Span) -> TokenStream {\n-        // A `Nonterminal` is often a parsed AST item. At this point we now\n-        // need to convert the parsed AST to an actual token stream, e.g.\n-        // un-parse it basically.\n-        //\n-        // Unfortunately there's not really a great way to do that in a\n-        // guaranteed lossless fashion right now. The fallback here is to just\n-        // stringify the AST node and reparse it, but this loses all span\n-        // information.\n-        //\n-        // As a result, some AST nodes are annotated with the token stream they\n-        // came from. Here we attempt to extract these lossless token streams\n-        // before we fall back to the stringification.\n-        let tokens = match *self {\n-            Nonterminal::NtItem(ref item) => {\n-                prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n-            }\n-            Nonterminal::NtTraitItem(ref item) => {\n-                prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n-            }\n-            Nonterminal::NtImplItem(ref item) => {\n-                prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n-            }\n-            Nonterminal::NtIdent(ident, is_raw) => {\n-                Some(TokenTree::token(Ident(ident.name, is_raw), ident.span).into())\n-            }\n-            Nonterminal::NtLifetime(ident) => {\n-                Some(TokenTree::token(Lifetime(ident.name), ident.span).into())\n-            }\n-            Nonterminal::NtTT(ref tt) => {\n-                Some(tt.clone().into())\n-            }\n-            _ => None,\n-        };\n-\n-        // FIXME(#43081): Avoid this pretty-print + reparse hack\n-        let source = pprust::nonterminal_to_string(self);\n-        let filename = FileName::macro_expansion_source_code(&source);\n-        let tokens_for_real = parse_stream_from_source_str(filename, source, sess, Some(span));\n-\n-        // During early phases of the compiler the AST could get modified\n-        // directly (e.g., attributes added or removed) and the internal cache\n-        // of tokens my not be invalidated or updated. Consequently if the\n-        // \"lossless\" token stream disagrees with our actual stringification\n-        // (which has historically been much more battle-tested) then we go\n-        // with the lossy stream anyway (losing span information).\n-        //\n-        // Note that the comparison isn't `==` here to avoid comparing spans,\n-        // but it *also* is a \"probable\" equality which is a pretty weird\n-        // definition. We mostly want to catch actual changes to the AST\n-        // like a `#[cfg]` being processed or some weird `macro_rules!`\n-        // expansion.\n-        //\n-        // What we *don't* want to catch is the fact that a user-defined\n-        // literal like `0xf` is stringified as `15`, causing the cached token\n-        // stream to not be literal `==` token-wise (ignoring spans) to the\n-        // token stream we got from stringification.\n-        //\n-        // Instead the \"probably equal\" check here is \"does each token\n-        // recursively have the same discriminant?\" We basically don't look at\n-        // the token values here and assume that such fine grained token stream\n-        // modifications, including adding/removing typically non-semantic\n-        // tokens such as extra braces and commas, don't happen.\n-        if let Some(tokens) = tokens {\n-            if tokens.probably_equal_for_proc_macro(&tokens_for_real) {\n-                return tokens\n-            }\n-            info!(\"cached tokens found, but they're not \\\"probably equal\\\", \\\n-                   going with stringified version\");\n-        }\n-        return tokens_for_real\n-    }\n-}\n-\n-fn prepend_attrs(sess: &ParseSess,\n-                 attrs: &[ast::Attribute],\n-                 tokens: Option<&tokenstream::TokenStream>,\n-                 span: syntax_pos::Span)\n-    -> Option<tokenstream::TokenStream>\n-{\n-    let tokens = tokens?;\n-    if attrs.len() == 0 {\n-        return Some(tokens.clone())\n-    }\n-    let mut builder = tokenstream::TokenStreamBuilder::new();\n-    for attr in attrs {\n-        assert_eq!(attr.style, ast::AttrStyle::Outer,\n-                   \"inner attributes should prevent cached tokens from existing\");\n-\n-        let source = pprust::attribute_to_string(attr);\n-        let macro_filename = FileName::macro_expansion_source_code(&source);\n-        if attr.is_sugared_doc {\n-            let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n-            builder.push(stream);\n-            continue\n-        }\n-\n-        // synthesize # [ $path $tokens ] manually here\n-        let mut brackets = tokenstream::TokenStreamBuilder::new();\n-\n-        // For simple paths, push the identifier directly\n-        if attr.path.segments.len() == 1 && attr.path.segments[0].args.is_none() {\n-            let ident = attr.path.segments[0].ident;\n-            let token = Ident(ident.name, ident.as_str().starts_with(\"r#\"));\n-            brackets.push(tokenstream::TokenTree::token(token, ident.span));\n-\n-        // ... and for more complicated paths, fall back to a reparse hack that\n-        // should eventually be removed.\n-        } else {\n-            let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n-            brackets.push(stream);\n-        }\n-\n-        brackets.push(attr.tokens.clone());\n-\n-        // The span we list here for `#` and for `[ ... ]` are both wrong in\n-        // that it encompasses more than each token, but it hopefully is \"good\n-        // enough\" for now at least.\n-        builder.push(tokenstream::TokenTree::token(Pound, attr.span));\n-        let delim_span = DelimSpan::from_single(attr.span);\n-        builder.push(tokenstream::TokenTree::Delimited(\n-            delim_span, DelimToken::Bracket, brackets.build().into()));\n-    }\n-    builder.push(tokens.clone());\n-    Some(builder.build())\n-}"}, {"sha": "970bacdde13a770837d3f239abe292601693463b", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -14,7 +14,6 @@\n //! ownership of the original.\n \n use crate::parse::token::{self, DelimToken, Token, TokenKind};\n-use crate::print::pprust;\n \n use syntax_pos::{BytePos, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n@@ -23,7 +22,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use smallvec::{SmallVec, smallvec};\n \n-use std::{fmt, iter, mem};\n+use std::{iter, mem};\n \n #[cfg(test)]\n mod tests;\n@@ -507,12 +506,6 @@ impl Cursor {\n     }\n }\n \n-impl fmt::Display for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&pprust::tts_to_string(self.clone()))\n-    }\n-}\n-\n impl Encodable for TokenStream {\n     fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n         self.trees().collect::<Vec<_>>().encode(encoder)"}, {"sha": "1d48e8231b40188de0990dad214758fc43f537d2", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -7,6 +7,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::parse::ParseSess;\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n@@ -248,13 +249,20 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         for attr in &item.attrs {\n             if is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n+                    let path_str = pprust::path_to_string(&attr.path);\n                     let msg = if attr.path.segments[0].ident.name ==\n                                  prev_attr.path.segments[0].ident.name {\n-                        format!(\"only one `#[{}]` attribute is allowed on any given function\",\n-                                attr.path)\n+                        format!(\n+                            \"only one `#[{}]` attribute is allowed on any given function\",\n+                            path_str,\n+                        )\n                     } else {\n-                        format!(\"`#[{}]` and `#[{}]` attributes cannot both be applied \\\n-                                to the same function\", attr.path, prev_attr.path)\n+                        format!(\n+                            \"`#[{}]` and `#[{}]` attributes cannot both be applied\n+                            to the same function\",\n+                            path_str,\n+                            pprust::path_to_string(&prev_attr.path),\n+                        )\n                     };\n \n                     self.handler.struct_span_err(attr.span, &msg)\n@@ -280,8 +288,10 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         };\n \n         if !is_fn {\n-            let msg = format!(\"the `#[{}]` attribute may only be used on bare functions\",\n-                              attr.path);\n+            let msg = format!(\n+                \"the `#[{}]` attribute may only be used on bare functions\",\n+                pprust::path_to_string(&attr.path),\n+            );\n \n             self.handler.span_err(attr.span, &msg);\n             return;\n@@ -292,8 +302,10 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         }\n \n         if !self.is_proc_macro_crate {\n-            let msg = format!(\"the `#[{}]` attribute is only usable with crates of the \\\n-                              `proc-macro` crate type\", attr.path);\n+            let msg = format!(\n+                \"the `#[{}]` attribute is only usable with crates of the `proc-macro` crate type\",\n+                pprust::path_to_string(&attr.path),\n+            );\n \n             self.handler.span_err(attr.span, &msg);\n             return;"}, {"sha": "2ceab394e9558c3e42a54711f4f42e72cc6f2fd3", "filename": "src/test/ui/associated-const/associated-const-impl-wrong-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-impl-wrong-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-impl-wrong-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-impl-wrong-lifetime.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     const NAME: &'a str = \"unit\";\n    |\n    = note: expected type `&'static str`\n               found type `&'a str`\n-note: the lifetime 'a as defined on the impl at 6:6...\n+note: the lifetime `'a` as defined on the impl at 6:6...\n   --> $DIR/associated-const-impl-wrong-lifetime.rs:6:6\n    |\n LL | impl<'a> Foo for &'a () {"}, {"sha": "c9b4ccd3e8a999a44fa4a2bd7d662e56b592cf48", "filename": "src/test/ui/associated-item/issue-48027.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,8 @@\n+trait Bar {\n+    const X: usize;\n+    fn return_n(&self) -> [u8; Bar::X]; //~ ERROR: type annotations needed\n+}\n+\n+impl dyn Bar {} //~ ERROR: the trait `Bar` cannot be made into an object\n+\n+fn main() {}"}, {"sha": "562146a426d239958816914b54b572153f309576", "filename": "src/test/ui/associated-item/issue-48027.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,21 @@\n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/issue-48027.rs:6:6\n+   |\n+LL |     const X: usize;\n+   |           - the trait cannot contain associated consts like `X`\n+...\n+LL | impl dyn Bar {}\n+   |      ^^^^^^^ the trait `Bar` cannot be made into an object\n+\n+error[E0283]: type annotations needed: cannot resolve `_: Bar`\n+  --> $DIR/issue-48027.rs:3:32\n+   |\n+LL |     const X: usize;\n+   |     --------------- required by `Bar::X`\n+LL |     fn return_n(&self) -> [u8; Bar::X];\n+   |                                ^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0038, E0283.\n+For more information about an error, try `rustc --explain E0038`."}, {"sha": "5ea98dcd4a972a194e603ec6067d98dfb659b873", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.transmute.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |    bar(foo, x)\n    |        ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 37:8...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 37:8...\n   --> $DIR/project-fn-ret-contravariant.rs:37:8\n    |\n LL | fn baz<'a,'b>(x: &'a u32) -> &'static u32 {"}, {"sha": "627609c4a9c004320be4cfc131fef7e65e2475c1", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |    bar(foo, x)\n    |        ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 44:8...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 44:8...\n   --> $DIR/project-fn-ret-invariant.rs:44:8\n    |\n LL | fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {"}, {"sha": "2101cb61a94d1fbfccce160d7f6dc979d61a78fc", "filename": "src/test/ui/associated-types/issue-44153.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fissue-44153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fissue-44153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-44153.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,19 @@\n+pub trait Array {\n+    type Element;\n+}\n+\n+pub trait Visit {\n+    fn visit() {}\n+}\n+\n+impl Array for () {\n+    type Element = ();\n+}\n+\n+impl<'a> Visit for () where\n+    (): Array<Element=&'a ()>,\n+{}\n+\n+fn main() {\n+    <() as Visit>::visit(); //~ ERROR: type mismatch resolving\n+}"}, {"sha": "b62a866a20be32c40e1f7fd2b3f1dc1ccbe0fa64", "filename": "src/test/ui/associated-types/issue-44153.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fissue-44153.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fissue-44153.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-44153.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,16 @@\n+error[E0271]: type mismatch resolving `<() as Array>::Element == &()`\n+  --> $DIR/issue-44153.rs:18:5\n+   |\n+LL |     fn visit() {}\n+   |     ---------- required by `Visit::visit`\n+...\n+LL |     <() as Visit>::visit();\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected (), found &()\n+   |\n+   = note: expected type `()`\n+              found type `&()`\n+   = note: required because of the requirements on the impl of `Visit` for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "70e30c132d05c1accdb04af39533b7b876302359", "filename": "src/test/ui/associated-types/issue-48010.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fissue-48010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fassociated-types%2Fissue-48010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-48010.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![crate_type = \"lib\"]\n+\n+pub struct Foo;\n+\n+pub struct Path<T: Bar> {\n+    _inner: T::Slice,\n+}\n+\n+pub trait Bar: Sized {\n+    type Slice: ?Sized;\n+\n+    fn open(_: &Path<Self>);\n+}\n+\n+impl Bar for Foo {\n+    type Slice = [u8];\n+\n+    fn open(_: &Path<Self>) {\n+        unimplemented!()\n+    }\n+}"}, {"sha": "efec160588fc411ec4e649a95160b8529049e9be", "filename": "src/test/ui/async-await/issues/issue-63388-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -15,12 +15,12 @@ LL |         foo: &dyn Foo, bar: &'a dyn Foo\n LL |         foo\n    |         --- this return type evaluates to the `'static` lifetime...\n    |\n-note: ...can't outlive the lifetime '_ as defined on the method body at 11:14\n+note: ...can't outlive the lifetime `'_` as defined on the method body at 11:14\n   --> $DIR/issue-63388-2.rs:11:14\n    |\n LL |         foo: &dyn Foo, bar: &'a dyn Foo\n    |              ^\n-help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime '_ as defined on the method body at 11:14\n+help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime `'_` as defined on the method body at 11:14\n    |\n LL |         foo + '_\n    |"}, {"sha": "52d43eae658aeb08e06b7ac2ab0983a043a68f94", "filename": "src/test/ui/borrowck/regions-bound-missing-bound-in-impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fborrowck%2Fregions-bound-missing-bound-in-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fborrowck%2Fregions-bound-missing-bound-in-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-bound-missing-bound-in-impl.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -24,12 +24,12 @@ LL |     fn wrong_bound1<'b,'c,'d:'a+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d\n    |\n    = note: expected type `fn(&'a isize, Inv<'c>, Inv<'c>, Inv<'d>)`\n               found type `fn(&'a isize, Inv<'_>, Inv<'c>, Inv<'d>)`\n-note: the lifetime 'c as defined on the method body at 27:24...\n+note: the lifetime `'c` as defined on the method body at 27:24...\n   --> $DIR/regions-bound-missing-bound-in-impl.rs:27:24\n    |\n LL |     fn wrong_bound1<'b,'c,'d:'a+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>) {\n    |                        ^^\n-note: ...does not necessarily outlive the lifetime 'c as defined on the method body at 27:24\n+note: ...does not necessarily outlive the lifetime `'c` as defined on the method body at 27:24\n   --> $DIR/regions-bound-missing-bound-in-impl.rs:27:24\n    |\n LL |     fn wrong_bound1<'b,'c,'d:'a+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>) {"}, {"sha": "05535659161b82e7a960dbc740a55a877590b37c", "filename": "src/test/ui/c-variadic/variadic-ffi-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -14,7 +14,7 @@ LL |   pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<\n LL | |     ap\n LL | | }\n    | |_^\n-note: ...does not necessarily outlive the lifetime 'f as defined on the function body at 7:37\n+note: ...does not necessarily outlive the lifetime `'f` as defined on the function body at 7:37\n   --> $DIR/variadic-ffi-4.rs:7:37\n    |\n LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {"}, {"sha": "8af7f882cc29925c7b434c3abba32ce731fe27d4", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -11,7 +11,7 @@ note: the anonymous lifetime #2 defined on the body at 14:48...\n    |\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...does not necessarily outlive the lifetime 'x as defined on the function body at 11:36\n+note: ...does not necessarily outlive the lifetime `'x` as defined on the function body at 11:36\n   --> $DIR/expect-fn-supply-fn.rs:11:36\n    |\n LL | fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {\n@@ -25,7 +25,7 @@ LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |\n    = note: expected type `fn(&u32)`\n               found type `fn(&'x u32)`\n-note: the lifetime 'x as defined on the function body at 11:36...\n+note: the lifetime `'x` as defined on the function body at 11:36...\n   --> $DIR/expect-fn-supply-fn.rs:11:36\n    |\n LL | fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {"}, {"sha": "9f74738315a0adbec20c0da3718730b27d04771f", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -38,7 +38,7 @@ LL | |\n LL | |\n LL | |     });\n    | |_____^\n-note: ...does not necessarily outlive the lifetime 'x as defined on the function body at 32:30\n+note: ...does not necessarily outlive the lifetime `'x` as defined on the function body at 32:30\n   --> $DIR/expect-region-supply-region.rs:32:30\n    |\n LL | fn expect_bound_supply_named<'x>() {\n@@ -52,7 +52,7 @@ LL |     closure_expecting_bound(|x: &'x u32| {\n    |\n    = note: expected type `&u32`\n               found type `&'x u32`\n-note: the lifetime 'x as defined on the function body at 32:30...\n+note: the lifetime `'x` as defined on the function body at 32:30...\n   --> $DIR/expect-region-supply-region.rs:32:30\n    |\n LL | fn expect_bound_supply_named<'x>() {"}, {"sha": "1380840e0db2d7da12c2d32565823c10118acd79", "filename": "src/test/ui/error-codes/E0478.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Ferror-codes%2FE0478.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Ferror-codes%2FE0478.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0478.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0478]: lifetime bound not satisfied\n LL |     child: Box<dyn Wedding<'kiss> + 'SnowWhite>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: lifetime parameter instantiated with the lifetime 'SnowWhite as defined on the struct at 3:22\n+note: lifetime parameter instantiated with the lifetime `'SnowWhite` as defined on the struct at 3:22\n   --> $DIR/E0478.rs:3:22\n    |\n LL | struct Prince<'kiss, 'SnowWhite> {\n    |                      ^^^^^^^^^^\n-note: but lifetime parameter must outlive the lifetime 'kiss as defined on the struct at 3:15\n+note: but lifetime parameter must outlive the lifetime `'kiss` as defined on the struct at 3:15\n   --> $DIR/E0478.rs:3:15\n    |\n LL | struct Prince<'kiss, 'SnowWhite> {"}, {"sha": "cbd6422e5df7653801413bd5708f9538c122468e", "filename": "src/test/ui/explicit/explicit-self-lifetime-mismatch.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-self-lifetime-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-self-lifetime-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-self-lifetime-mismatch.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |            Foo<'b,'a>\n    |\n    = note: expected type `Foo<'a, 'b>`\n               found type `Foo<'b, 'a>`\n-note: the lifetime 'b as defined on the impl at 6:9...\n+note: the lifetime `'b` as defined on the impl at 6:9...\n   --> $DIR/explicit-self-lifetime-mismatch.rs:6:9\n    |\n LL | impl<'a,'b> Foo<'a,'b> {\n    |         ^^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 6:6\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 6:6\n   --> $DIR/explicit-self-lifetime-mismatch.rs:6:6\n    |\n LL | impl<'a,'b> Foo<'a,'b> {\n@@ -25,12 +25,12 @@ LL |            Foo<'b,'a>\n    |\n    = note: expected type `Foo<'a, 'b>`\n               found type `Foo<'b, 'a>`\n-note: the lifetime 'a as defined on the impl at 6:6...\n+note: the lifetime `'a` as defined on the impl at 6:6...\n   --> $DIR/explicit-self-lifetime-mismatch.rs:6:6\n    |\n LL | impl<'a,'b> Foo<'a,'b> {\n    |      ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the impl at 6:9\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the impl at 6:9\n   --> $DIR/explicit-self-lifetime-mismatch.rs:6:9\n    |\n LL | impl<'a,'b> Foo<'a,'b> {"}, {"sha": "76d97dd2f585d0367e8e40f6a7007614c3fbe7d9", "filename": "src/test/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -10,7 +10,7 @@ LL | |                                     fn(Inv<'y>)) }\n    |\n    = note: expected type `std::option::Option<fn(Inv<'y>)>`\n               found type `std::option::Option<fn(Inv<'x>)>`\n-note: the lifetime 'x as defined on the function body at 32:20...\n+note: the lifetime `'x` as defined on the function body at 32:20...\n   --> $DIR/hr-subtype.rs:32:20\n    |\n LL |           fn subtype<'x,'y:'x,'z:'y>() {\n@@ -19,7 +19,7 @@ LL |           fn subtype<'x,'y:'x,'z:'y>() {\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n LL | |                                     fn(Inv<'y>)) }\n    | |__________________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime 'y as defined on the function body at 32:23\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 32:23\n   --> $DIR/hr-subtype.rs:32:23\n    |\n LL |           fn subtype<'x,'y:'x,'z:'y>() {\n@@ -41,7 +41,7 @@ LL | |                                     fn(Inv<'y>)) }\n    |\n    = note: expected type `std::option::Option<fn(Inv<'x>)>`\n               found type `std::option::Option<fn(Inv<'y>)>`\n-note: the lifetime 'x as defined on the function body at 38:22...\n+note: the lifetime `'x` as defined on the function body at 38:22...\n   --> $DIR/hr-subtype.rs:38:22\n    |\n LL |           fn supertype<'x,'y:'x,'z:'y>() {\n@@ -50,7 +50,7 @@ LL |           fn supertype<'x,'y:'x,'z:'y>() {\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n LL | |                                     fn(Inv<'y>)) }\n    | |__________________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime 'y as defined on the function body at 38:25\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:25\n   --> $DIR/hr-subtype.rs:38:25\n    |\n LL |           fn supertype<'x,'y:'x,'z:'y>() {"}, {"sha": "74f4212b2468b410d9b0a7c51cbc428eb8e217a4", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_y.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -10,7 +10,7 @@ LL | |                             fn(&'y u32)) }\n    |\n    = note: expected type `std::option::Option<fn(&'x u32)>`\n               found type `std::option::Option<fn(&'y u32)>`\n-note: the lifetime 'x as defined on the function body at 38:22...\n+note: the lifetime `'x` as defined on the function body at 38:22...\n   --> $DIR/hr-subtype.rs:38:22\n    |\n LL |           fn supertype<'x,'y:'x,'z:'y>() {\n@@ -19,7 +19,7 @@ LL |           fn supertype<'x,'y:'x,'z:'y>() {\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n LL | |                             fn(&'y u32)) }\n    | |__________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime 'y as defined on the function body at 38:25\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:25\n   --> $DIR/hr-subtype.rs:38:25\n    |\n LL |           fn supertype<'x,'y:'x,'z:'y>() {"}, {"sha": "5e80c673258b8484432a74442ec7a58020d05ac9", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |     static_val(x);\n    |                ^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 19:26...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 19:26...\n   --> $DIR/dyn-trait.rs:19:26\n    |\n LL | fn with_dyn_debug_static<'a>(x: Box<dyn Debug + 'a>) {"}, {"sha": "956ac1f1a11672789e026218f07513b4d6f6fd1f", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n    |                                                      ^^^^^^^^^^^^^^\n    |\n-note: hidden type `&'a mut &'b T` captures the lifetime 'b as defined on the function body at 28:17\n+note: hidden type `&'a mut &'b T` captures the lifetime `'b` as defined on the function body at 28:17\n   --> $DIR/hidden-lifetimes.rs:28:17\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n@@ -16,7 +16,7 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n    |                                                                      ^^^^^^^^^^^^^^\n    |\n-note: hidden type `std::rc::Rc<std::cell::RefCell<&'b T>>` captures the lifetime 'b as defined on the function body at 45:24\n+note: hidden type `std::rc::Rc<std::cell::RefCell<&'b T>>` captures the lifetime `'b` as defined on the function body at 45:24\n   --> $DIR/hidden-lifetimes.rs:45:24\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {"}, {"sha": "2ffb94348616bca0f1bddc12af34b0e3fd8eb8f5", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -24,12 +24,12 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |                                |\n    |                                this return type evaluates to the `'static` lifetime...\n    |\n-note: ...can't outlive the lifetime 'a as defined on the function body at 6:13\n+note: ...can't outlive the lifetime `'a` as defined on the function body at 6:13\n   --> $DIR/must_outlive_least_region_or_bound.rs:6:13\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |             ^^\n-help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime 'a as defined on the function body at 6:13\n+help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 6:13\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                ^^^^^^^^^^^^^^\n@@ -42,12 +42,12 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                                  |\n    |                                  this return type evaluates to the `'static` lifetime...\n    |\n-note: ...can't outlive the lifetime 'a as defined on the function body at 12:15\n+note: ...can't outlive the lifetime `'a` as defined on the function body at 12:15\n   --> $DIR/must_outlive_least_region_or_bound.rs:12:15\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               ^^\n-help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime 'a as defined on the function body at 12:15\n+help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 12:15\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static + 'a { x }\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "894a65ff389953460abc66b10c58962ea5330b35", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n    |                             ^^^^^^^^^^^^^^\n    |\n-note: hidden type `std::cell::Cell<&'x u32>` captures the lifetime 'x as defined on the function body at 17:7\n+note: hidden type `std::cell::Cell<&'x u32>` captures the lifetime `'x` as defined on the function body at 17:7\n   --> $DIR/region-escape-via-bound.rs:17:7\n    |\n LL | where 'x: 'y"}, {"sha": "1d6b5f56aa0cfae2d671e0f45b1fce008af40225", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -30,12 +30,12 @@ LL |         self.x.iter().map(|a| a.0)\n    |         |\n    |         ...but this borrow...\n    |\n-note: ...can't outlive the lifetime 'a as defined on the method body at 10:20\n+note: ...can't outlive the lifetime `'a` as defined on the method body at 10:20\n   --> $DIR/static-return-lifetime-infered.rs:10:20\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n    |                    ^^\n-help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime 'a as defined on the method body at 10:20\n+help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the method body at 10:20\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "b5287f32a50451b57473e6823c2252c3f68e1e1f", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait_impl.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.nll.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -11,7 +11,7 @@ LL | /     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n LL | |         x\n LL | |     }\n    | |_____^\n-note: ...but the lifetime must also be valid for the lifetime 'a as defined on the method body at 9:32...\n+note: ...but the lifetime must also be valid for the lifetime `'a` as defined on the method body at 9:32...\n   --> $DIR/mismatched_trait_impl.rs:9:32\n    |\n LL |     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {"}, {"sha": "734ca0819e4166251a23eb6db5abcfff8bde2afd", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait_impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -11,7 +11,7 @@ LL | /     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n LL | |         x\n LL | |     }\n    | |_____^\n-note: ...but the lifetime must also be valid for the lifetime 'a as defined on the method body at 9:32...\n+note: ...but the lifetime must also be valid for the lifetime `'a` as defined on the method body at 9:32...\n   --> $DIR/mismatched_trait_impl.rs:9:32\n    |\n LL |     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {"}, {"sha": "4fff4ee866c395898e460447eb4bdd833207f738", "filename": "src/test/ui/issues/issue-10291.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-10291.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-10291.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10291.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -12,7 +12,7 @@ LL |       drop::<Box<dyn for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n LL | |         x\n LL | |     }));\n    | |_____^\n-note: ...but the borrowed content is only valid for the lifetime 'x as defined on the function body at 1:9\n+note: ...but the borrowed content is only valid for the lifetime `'x` as defined on the function body at 1:9\n   --> $DIR/issue-10291.rs:1:9\n    |\n LL | fn test<'x>(x: &'x isize) {"}, {"sha": "b663e213ed05e357f8d8d48749573938828dd128", "filename": "src/test/ui/issues/issue-16683.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-16683.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-16683.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16683.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -16,7 +16,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |         self.a();\n    |         ^^^^\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the trait at 1:9...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the trait at 1:9...\n   --> $DIR/issue-16683.rs:1:9\n    |\n LL | trait T<'a> {"}, {"sha": "d392ea3c1b8617bae73b0833c85822c532db0e4e", "filename": "src/test/ui/issues/issue-17740.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-17740.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-17740.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17740.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -17,7 +17,7 @@ LL | |\n LL | |\n LL | |     }\n    | |_____^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 5:7\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 5:7\n   --> $DIR/issue-17740.rs:5:7\n    |\n LL | impl <'a> Foo<'a>{\n@@ -31,7 +31,7 @@ LL |     fn bar(self: &mut Foo) {\n    |\n    = note: expected type `Foo<'a>`\n               found type `Foo<'_>`\n-note: the lifetime 'a as defined on the impl at 5:7...\n+note: the lifetime `'a` as defined on the impl at 5:7...\n   --> $DIR/issue-17740.rs:5:7\n    |\n LL | impl <'a> Foo<'a>{"}, {"sha": "adcbb62e3d5bda4ee80c04f2e5e0fbb9494c1511", "filename": "src/test/ui/issues/issue-17758.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-17758.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-17758.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17758.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -17,7 +17,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |         self.foo();\n    |         ^^^^\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the trait at 4:11...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the trait at 4:11...\n   --> $DIR/issue-17758.rs:4:11\n    |\n LL | trait Foo<'a> {"}, {"sha": "04be62dc661bfe3c18c02462846d2927a33e3c8c", "filename": "src/test/ui/issues/issue-17905-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -15,7 +15,7 @@ LL | |\n LL | |         println!(\"{:?}\", self);\n LL | |     }\n    | |_____^\n-note: ...does not necessarily outlive the lifetime '_ as defined on the impl at 5:5\n+note: ...does not necessarily outlive the lifetime `'_` as defined on the impl at 5:5\n   --> $DIR/issue-17905-2.rs:5:5\n    |\n LL |     &str,\n@@ -29,7 +29,7 @@ LL |     fn say(self: &Pair<&str, isize>) {\n    |\n    = note: expected type `Pair<&str, _>`\n               found type `Pair<&str, _>`\n-note: the lifetime '_ as defined on the impl at 5:5...\n+note: the lifetime `'_` as defined on the impl at 5:5...\n   --> $DIR/issue-17905-2.rs:5:5\n    |\n LL |     &str,"}, {"sha": "13c9c09461eae290e88fa5f3d56138e92346560b", "filename": "src/test/ui/issues/issue-20831-debruijn.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -23,7 +23,7 @@ LL | |\n LL | |         self.sub = t;\n LL | |     }\n    | |_____^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 26:6\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 26:6\n   --> $DIR/issue-20831-debruijn.rs:26:6\n    |\n LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n@@ -43,7 +43,7 @@ LL | |     }\n    |\n    = note: expected type `'a`\n               found type `'_`\n-note: the lifetime 'a as defined on the impl at 26:6...\n+note: the lifetime `'a` as defined on the impl at 26:6...\n   --> $DIR/issue-20831-debruijn.rs:26:6\n    |\n LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n@@ -83,7 +83,7 @@ LL | |\n LL | |         self.sub = t;\n LL | |     }\n    | |_____^\n-note: ...but the lifetime must also be valid for the lifetime 'a as defined on the impl at 26:6...\n+note: ...but the lifetime must also be valid for the lifetime `'a` as defined on the impl at 26:6...\n   --> $DIR/issue-20831-debruijn.rs:26:6\n    |\n LL | impl<'a> Publisher<'a> for MyStruct<'a> {"}, {"sha": "d290b176161be5637aa813c8bdf6205c84042256", "filename": "src/test/ui/issues/issue-27942.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-27942.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-27942.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27942.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -11,7 +11,7 @@ note: the anonymous lifetime #1 defined on the method body at 5:5...\n    |\n LL |     fn select(&self) -> BufferViewHandle<R>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the trait at 3:18\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the trait at 3:18\n   --> $DIR/issue-27942.rs:3:18\n    |\n LL | pub trait Buffer<'a, R: Resources<'a>> {\n@@ -25,7 +25,7 @@ LL |     fn select(&self) -> BufferViewHandle<R>;\n    |\n    = note: expected type `Resources<'_>`\n               found type `Resources<'a>`\n-note: the lifetime 'a as defined on the trait at 3:18...\n+note: the lifetime `'a` as defined on the trait at 3:18...\n   --> $DIR/issue-27942.rs:3:18\n    |\n LL | pub trait Buffer<'a, R: Resources<'a>> {"}, {"sha": "726844a31841f7089c36faa311042420d046f62f", "filename": "src/test/ui/issues/issue-28848.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-28848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-28848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28848.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0478]: lifetime bound not satisfied\n LL |     Foo::<'a, 'b>::xmute(u)\n    |     ^^^^^^^^^^^^^^^^^^^^\n    |\n-note: lifetime parameter instantiated with the lifetime 'b as defined on the function body at 9:16\n+note: lifetime parameter instantiated with the lifetime `'b` as defined on the function body at 9:16\n   --> $DIR/issue-28848.rs:9:16\n    |\n LL | pub fn foo<'a, 'b>(u: &'b ()) -> &'a () {\n    |                ^^\n-note: but lifetime parameter must outlive the lifetime 'a as defined on the function body at 9:12\n+note: but lifetime parameter must outlive the lifetime `'a` as defined on the function body at 9:12\n   --> $DIR/issue-28848.rs:9:12\n    |\n LL | pub fn foo<'a, 'b>(u: &'b ()) -> &'a () {"}, {"sha": "8e75d7be066a3f2c2ccac3c2194a4d823f9e8549", "filename": "src/test/ui/issues/issue-37884.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -21,7 +21,7 @@ LL | |     {\n LL | |         Some(&mut self.0)\n LL | |     }\n    | |_____^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 3:6\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 3:6\n   --> $DIR/issue-37884.rs:3:6\n    |\n LL | impl<'a, T: 'a> Iterator for RepeatMut<'a, T> {"}, {"sha": "d686f02a9fe39ee5574120431afcbd2382f0b5c0", "filename": "src/test/ui/issues/issue-47486.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-47486.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-47486.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47486.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    () < std::mem::size_of::<_>(); //~ ERROR: mismatched types\n+    [0u8; std::mem::size_of::<_>()]; //~ ERROR: type annotations needed\n+}"}, {"sha": "af6e3010f795884da9da5a4be0c401b369d74905", "filename": "src/test/ui/issues/issue-47486.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-47486.rs:2:10\n+   |\n+LL |     () < std::mem::size_of::<_>();\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found usize\n+   |\n+   = note: expected type `()`\n+              found type `usize`\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-47486.rs:3:11\n+   |\n+LL |     [0u8; std::mem::size_of::<_>()];\n+   |           ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0282, E0308.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "b79a5ddf3e1bf601ea4c96976270225b56aa8e78", "filename": "src/test/ui/issues/issue-52213.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-52213.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-52213.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52213.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,15 +4,15 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |     match (&t,) {\n    |           ^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 1:23...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 1:23...\n   --> $DIR/issue-52213.rs:1:23\n    |\n LL | fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n    |                       ^^\n    = note: ...so that the types are compatible:\n            expected (&&(T,),)\n               found (&&'a (T,),)\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 1:27...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 1:27...\n   --> $DIR/issue-52213.rs:1:27\n    |\n LL | fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {"}, {"sha": "7b910f5e3e5a654cc88ea4fa129185cfaa66cf4e", "filename": "src/test/ui/issues/issue-55796.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the trait at 5:17...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the trait at 5:17...\n   --> $DIR/issue-55796.rs:5:17\n    |\n LL | pub trait Graph<'a> {\n@@ -25,7 +25,7 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the trait at 5:17...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the trait at 5:17...\n   --> $DIR/issue-55796.rs:5:17\n    |\n LL | pub trait Graph<'a> {"}, {"sha": "b4011990b68e6343661906ba011b390e4dd30036", "filename": "src/test/ui/lifetimes/lifetime-bound-will-change-warning.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-bound-will-change-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-bound-will-change-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-bound-will-change-warning.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     ref_obj(x)\n    |\n    = note: expected type `&std::boxed::Box<(dyn std::ops::Fn() + 'static)>`\n               found type `&std::boxed::Box<(dyn std::ops::Fn() + 'a)>`\n-note: the lifetime 'a as defined on the function body at 32:10...\n+note: the lifetime `'a` as defined on the function body at 32:10...\n   --> $DIR/lifetime-bound-will-change-warning.rs:32:10\n    |\n LL | fn test2<'a>(x: &'a Box<dyn Fn() + 'a>) {\n@@ -21,7 +21,7 @@ LL |     lib::ref_obj(x)\n    |\n    = note: expected type `&std::boxed::Box<(dyn std::ops::Fn() + 'static)>`\n               found type `&std::boxed::Box<(dyn std::ops::Fn() + 'a)>`\n-note: the lifetime 'a as defined on the function body at 37:12...\n+note: the lifetime `'a` as defined on the function body at 37:12...\n   --> $DIR/lifetime-bound-will-change-warning.rs:37:12\n    |\n LL | fn test2cc<'a>(x: &'a Box<dyn Fn() + 'a>) {"}, {"sha": "0a4744013a62ca9c0876e98638726369c90927a5", "filename": "src/test/ui/lub-if.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Flub-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Flub-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-if.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,7 +5,7 @@ LL |         s\n    |         ^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 23:17\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 23:17\n   --> $DIR/lub-if.rs:23:17\n    |\n LL | pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n@@ -18,7 +18,7 @@ LL |         s\n    |         ^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 32:17\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 32:17\n   --> $DIR/lub-if.rs:32:17\n    |\n LL | pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {"}, {"sha": "168a389446921dc1bd9b09b9f141fea2cc2aed0f", "filename": "src/test/ui/lub-match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Flub-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Flub-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-match.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,7 +5,7 @@ LL |             s\n    |             ^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 25:17\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 25:17\n   --> $DIR/lub-match.rs:25:17\n    |\n LL | pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n@@ -18,7 +18,7 @@ LL |             s\n    |             ^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 35:17\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 35:17\n   --> $DIR/lub-match.rs:35:17\n    |\n LL | pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {"}, {"sha": "0a020989d6f35d7821607e207fcb87e6aa8e0930", "filename": "src/test/ui/match/match-ref-mut-invariance.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-invariance.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-invariance.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-invariance.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |         match self.0 { ref mut x => x }\n    |\n    = note: expected type `&'a mut &'a i32`\n               found type `&'a mut &'b i32`\n-note: the lifetime 'a as defined on the method body at 9:12...\n+note: the lifetime `'a` as defined on the method body at 9:12...\n   --> $DIR/match-ref-mut-invariance.rs:9:12\n    |\n LL |     fn bar<'a>(&'a mut self) -> &'a mut &'a i32 {\n    |            ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the impl at 8:6\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the impl at 8:6\n   --> $DIR/match-ref-mut-invariance.rs:8:6\n    |\n LL | impl<'b> S<'b> {"}, {"sha": "1bea9bce11e47df90641ca478bfd6bd21c9603a7", "filename": "src/test/ui/match/match-ref-mut-let-invariance.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-let-invariance.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-let-invariance.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-let-invariance.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |         x\n    |\n    = note: expected type `&'a mut &'a i32`\n               found type `&'a mut &'b i32`\n-note: the lifetime 'a as defined on the method body at 9:12...\n+note: the lifetime `'a` as defined on the method body at 9:12...\n   --> $DIR/match-ref-mut-let-invariance.rs:9:12\n    |\n LL |     fn bar<'a>(&'a mut self) -> &'a mut &'a i32 {\n    |            ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the impl at 8:6\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the impl at 8:6\n   --> $DIR/match-ref-mut-let-invariance.rs:8:6\n    |\n LL | impl<'b> S<'b> {"}, {"sha": "74c33df37a09edcdba9311ed0eab9814fca04300", "filename": "src/test/ui/nll/issue-50716.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     let _x = *s;\n    |\n    = note: expected type `std::marker::Sized`\n               found type `std::marker::Sized`\n-note: the lifetime 'a as defined on the function body at 9:8...\n+note: the lifetime `'a` as defined on the function body at 9:8...\n   --> $DIR/issue-50716.rs:9:8\n    |\n LL | fn foo<'a, T: 'static>(s: Box<<&'a T as A>::X>)"}, {"sha": "0cdc2d9443926f55b0011a9e2d3e93280bac7368", "filename": "src/test/ui/nll/issue-52742.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-52742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-52742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52742.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n LL |         self.y = b.z\n    |                  ^^^\n    |\n-note: ...the reference is valid for the lifetime '_ as defined on the impl at 12:10...\n+note: ...the reference is valid for the lifetime `'_` as defined on the impl at 12:10...\n   --> $DIR/issue-52742.rs:12:10\n    |\n LL | impl Foo<'_, '_> {"}, {"sha": "714a63b670c66a96688a0cbeb14c71d670aa181d", "filename": "src/test/ui/nll/issue-55394.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -16,7 +16,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |         Foo { bar }\n    |               ^^^\n-note: but, the lifetime must be valid for the lifetime '_ as defined on the impl at 7:10...\n+note: but, the lifetime must be valid for the lifetime `'_` as defined on the impl at 7:10...\n   --> $DIR/issue-55394.rs:7:10\n    |\n LL | impl Foo<'_> {"}, {"sha": "2dc7236cbc2749201a9f8d291d391ef80ae5b928", "filename": "src/test/ui/nll/issue-55401.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,7 +5,7 @@ LL |     *y\n    |     ^^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 1:47\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 1:47\n   --> $DIR/issue-55401.rs:1:47\n    |\n LL | fn static_to_a_to_static_through_ref_in_tuple<'a>(x: &'a u32) -> &'static u32 {"}, {"sha": "3a152fbc6fce8e5898ac1261ca1080b80497e3cd", "filename": "src/test/ui/nll/normalization-bounds-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'d` d\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'd as defined on the function body at 12:14...\n+note: first, the lifetime cannot outlive the lifetime `'d` as defined on the function body at 12:14...\n   --> $DIR/normalization-bounds-error.rs:12:14\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n    |              ^^\n-note: ...but the lifetime must also be valid for the lifetime 'a as defined on the function body at 12:18...\n+note: ...but the lifetime must also be valid for the lifetime `'a` as defined on the function body at 12:18...\n   --> $DIR/normalization-bounds-error.rs:12:18\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}"}, {"sha": "ecf9748af9ea30f7a707915f00e64e976d36315d", "filename": "src/test/ui/nll/trait-associated-constant.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     const AC: Option<&'c str> = None;\n    |\n    = note: expected type `std::option::Option<&'b str>`\n               found type `std::option::Option<&'c str>`\n-note: the lifetime 'c as defined on the impl at 20:18...\n+note: the lifetime `'c` as defined on the impl at 20:18...\n   --> $DIR/trait-associated-constant.rs:20:18\n    |\n LL | impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct {\n    |                  ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the impl at 20:14\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the impl at 20:14\n   --> $DIR/trait-associated-constant.rs:20:14\n    |\n LL | impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct {"}, {"sha": "6986389af88149ee503d183507fb1ee1fa807319", "filename": "src/test/ui/nll/type-alias-free-regions.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -14,7 +14,7 @@ LL | |     }\n    = note: ...so that the expression is assignable:\n            expected std::boxed::Box<std::boxed::Box<&isize>>\n               found std::boxed::Box<std::boxed::Box<&isize>>\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 15:6...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 15:6...\n   --> $DIR/type-alias-free-regions.rs:15:6\n    |\n LL | impl<'a> FromBox<'a> for C<'a> {\n@@ -39,7 +39,7 @@ LL | |     }\n    = note: ...so that the expression is assignable:\n            expected std::boxed::Box<&isize>\n               found std::boxed::Box<&isize>\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 25:6...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 25:6...\n   --> $DIR/type-alias-free-regions.rs:25:6\n    |\n LL | impl<'a> FromTuple<'a> for C<'a> {"}, {"sha": "4ebd991078864f6cb986739c477de2d5dc6744e5", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n LL |     <Foo<'a>>::C\n    |     ^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 7:8...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 7:8...\n   --> $DIR/constant-in-expr-inherent-1.rs:7:8\n    |\n LL | fn foo<'a>(_: &'a u32) -> &'static u32 {"}, {"sha": "4c7adf75d2fd7a8a55687fa7046f9915df6bf217", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-normalize.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,7 +5,7 @@ LL |     <() as Foo<'a>>::C\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 17:8\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 17:8\n   --> $DIR/constant-in-expr-normalize.rs:17:8\n    |\n LL | fn foo<'a>(_: &'a u32) -> &'static u32 {"}, {"sha": "d01d022cba7967945fd5f226398fec1d0fbf85d1", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,7 +5,7 @@ LL |     <() as Foo<'a>>::C\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 9:8\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 9:8\n   --> $DIR/constant-in-expr-trait-item-1.rs:9:8\n    |\n LL | fn foo<'a>(_: &'a u32) -> &'static u32 {"}, {"sha": "dd294280b903aee8a75c7cea25fe0ba011a777b5", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,7 +5,7 @@ LL |     <T as Foo<'a>>::C\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 9:8\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 9:8\n   --> $DIR/constant-in-expr-trait-item-2.rs:9:8\n    |\n LL | fn foo<'a, T: Foo<'a>>() -> &'static u32 {"}, {"sha": "d61659e7e9afcd3c046fb42cad71504156ef8d2e", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n LL |     T::C\n    |     ^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 9:8...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:8...\n   --> $DIR/constant-in-expr-trait-item-3.rs:9:8\n    |\n LL | fn foo<'a, T: Foo<'a>>() -> &'static u32 {"}, {"sha": "d66322c48ec98c3f304e7a31574df4e90c858589", "filename": "src/test/ui/object-lifetime/object-lifetime-default-elision.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for automatic coercion due to\n LL |     ss\n    |     ^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 54:10...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 54:10...\n   --> $DIR/object-lifetime-default-elision.rs:54:10\n    |\n LL | fn load3<'a,'b>(ss: &'a dyn SomeTrait) -> &'b dyn SomeTrait {\n@@ -14,7 +14,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |     ss\n    |     ^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 54:13...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 54:13...\n   --> $DIR/object-lifetime-default-elision.rs:54:13\n    |\n LL | fn load3<'a,'b>(ss: &'a dyn SomeTrait) -> &'b dyn SomeTrait {\n@@ -29,7 +29,7 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |     ss\n    |     ^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 54:10...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 54:10...\n   --> $DIR/object-lifetime-default-elision.rs:54:10\n    |\n LL | fn load3<'a,'b>(ss: &'a dyn SomeTrait) -> &'b dyn SomeTrait {\n@@ -39,7 +39,7 @@ note: ...so that the declared lifetime parameter bounds are satisfied\n    |\n LL |     ss\n    |     ^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 54:13...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 54:13...\n   --> $DIR/object-lifetime-default-elision.rs:54:13\n    |\n LL | fn load3<'a,'b>(ss: &'a dyn SomeTrait) -> &'b dyn SomeTrait {"}, {"sha": "99f0ce0602b11c9725017d30565e5f2b006108c0", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-rptr-box-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-box-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-box-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-box-error.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     ss.t = t;\n    |\n    = note: expected type `&'a std::boxed::Box<(dyn Test + 'static)>`\n               found type `&'a std::boxed::Box<(dyn Test + 'a)>`\n-note: the lifetime 'a as defined on the function body at 14:6...\n+note: the lifetime `'a` as defined on the function body at 14:6...\n   --> $DIR/object-lifetime-default-from-rptr-box-error.rs:14:6\n    |\n LL | fn c<'a>(t: &'a Box<dyn Test+'a>, mut ss: SomeStruct<'a>) {"}, {"sha": "07d4d8c8ed40b0a94caaab4f4972c5879b965697", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-rptr-struct-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-struct-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-struct-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-struct-error.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     ss.t = t;\n    |\n    = note: expected type `&'a MyBox<(dyn Test + 'static)>`\n               found type `&'a MyBox<(dyn Test + 'a)>`\n-note: the lifetime 'a as defined on the function body at 20:6...\n+note: the lifetime `'a` as defined on the function body at 20:6...\n   --> $DIR/object-lifetime-default-from-rptr-struct-error.rs:20:6\n    |\n LL | fn c<'a>(t: &'a MyBox<dyn Test+'a>, mut ss: SomeStruct<'a>) {"}, {"sha": "f825475b96b03b336b7fa4e46a0fb70b0fc57bcd", "filename": "src/test/ui/object-lifetime/object-lifetime-default-mybox.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-mybox.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-mybox.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-mybox.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -18,7 +18,7 @@ LL |     load0(ss)\n    |\n    = note: expected type `&MyBox<(dyn SomeTrait + 'static)>`\n               found type `&MyBox<(dyn SomeTrait + 'a)>`\n-note: the lifetime 'a as defined on the function body at 30:10...\n+note: the lifetime `'a` as defined on the function body at 30:10...\n   --> $DIR/object-lifetime-default-mybox.rs:30:10\n    |\n LL | fn load2<'a>(ss: &MyBox<dyn SomeTrait + 'a>) -> MyBox<dyn SomeTrait + 'a> {"}, {"sha": "184cead21231f114d0da42fadaa113cf8ad1d333", "filename": "src/test/ui/regions/region-bounds-on-objects-and-type-parameters.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-bounds-on-objects-and-type-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-bounds-on-objects-and-type-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-bounds-on-objects-and-type-parameters.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -10,12 +10,12 @@ error[E0478]: lifetime bound not satisfied\n LL |     z: Box<dyn Is<'a>+'b+'c>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: lifetime parameter instantiated with the lifetime 'b as defined on the struct at 11:15\n+note: lifetime parameter instantiated with the lifetime `'b` as defined on the struct at 11:15\n   --> $DIR/region-bounds-on-objects-and-type-parameters.rs:11:15\n    |\n LL | struct Foo<'a,'b,'c> {\n    |               ^^\n-note: but lifetime parameter must outlive the lifetime 'a as defined on the struct at 11:12\n+note: but lifetime parameter must outlive the lifetime `'a` as defined on the struct at 11:12\n   --> $DIR/region-bounds-on-objects-and-type-parameters.rs:11:12\n    |\n LL | struct Foo<'a,'b,'c> {"}, {"sha": "911904813d0eba241b597141531fcf035a6168c4", "filename": "src/test/ui/regions/region-invariant-static-error-reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -3,7 +3,7 @@\n // over time, but this test used to exhibit some pretty bogus messages\n // that were not remotely helpful.\n \n-// error-pattern:the lifetime 'a\n+// error-pattern:the lifetime `'a`\n // error-pattern:the static lifetime\n \n struct Invariant<'a>(Option<&'a mut &'a mut ()>);"}, {"sha": "8358a7988c8088866efece25a6fd969973a7a126", "filename": "src/test/ui/regions/region-invariant-static-error-reporting.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -13,7 +13,7 @@ LL | |     };\n    |\n    = note: expected type `Invariant<'a>`\n               found type `Invariant<'static>`\n-note: the lifetime 'a as defined on the function body at 13:10...\n+note: the lifetime `'a` as defined on the function body at 13:10...\n   --> $DIR/region-invariant-static-error-reporting.rs:13:10\n    |\n LL | fn unify<'a>(x: Option<Invariant<'a>>, f: fn(Invariant<'a>)) {"}, {"sha": "74ea1b731e9ac59c6bcb91ddb283a12306e79ee6", "filename": "src/test/ui/regions/region-object-lifetime-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-2.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for autoref due to conflictin\n LL |     x.borrowed()\n    |       ^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 9:42...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:42...\n   --> $DIR/region-object-lifetime-2.rs:9:42\n    |\n LL | fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a dyn Foo) -> &'b () {\n@@ -14,7 +14,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |     x.borrowed()\n    |     ^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 9:45...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 9:45...\n   --> $DIR/region-object-lifetime-2.rs:9:45\n    |\n LL | fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a dyn Foo) -> &'b () {"}, {"sha": "105321829058838ed399cf939033a0bc3092da2a", "filename": "src/test/ui/regions/region-object-lifetime-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-4.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for autoref due to conflictin\n LL |     x.borrowed()\n    |       ^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 11:41...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 11:41...\n   --> $DIR/region-object-lifetime-4.rs:11:41\n    |\n LL | fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a (dyn Foo + 'b)) -> &'b () {\n@@ -14,7 +14,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |     x.borrowed()\n    |     ^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 11:44...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 11:44...\n   --> $DIR/region-object-lifetime-4.rs:11:44\n    |\n LL | fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a (dyn Foo + 'b)) -> &'b () {"}, {"sha": "14934d6fa4899c9490be3bc91282204fe33222d2", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -29,15 +29,15 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |     Box::new(v)\n    |              ^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 25:6...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 25:6...\n   --> $DIR/region-object-lifetime-in-coercion.rs:25:6\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      ^^\n    = note: ...so that the expression is assignable:\n            expected &[u8]\n               found &'a [u8]\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 25:9...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 25:9...\n   --> $DIR/region-object-lifetime-in-coercion.rs:25:9\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {"}, {"sha": "7a051b8ac835d0a2d3f0b8ca8c53e4d4a5a75e8e", "filename": "src/test/ui/regions/regions-addr-of-upvar-self.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for borrow expression due to\n LL |             let p: &'static mut usize = &mut self.food;\n    |                                         ^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime '_ as defined on the body at 9:18...\n+note: first, the lifetime cannot outlive the lifetime `'_` as defined on the body at 9:18...\n   --> $DIR/regions-addr-of-upvar-self.rs:9:18\n    |\n LL |         let _f = || {"}, {"sha": "c0401780b8f5b2794bd65266755485c7b450c2d2", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.migrate.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifet\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 33:15\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 33:15\n   --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:33:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 33:18\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 33:18\n   --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:33:18\n    |\n LL | fn with_assoc<'a,'b>() {"}, {"sha": "a636c9ef22c83ead07a67223d423f9f6e9347ddb", "filename": "src/test/ui/regions/regions-assoc-type-region-bound-in-trait-not-met.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n LL | impl<'a> Foo<'static> for &'a i32 {\n    |          ^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the impl at 14:6...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the impl at 14:6...\n   --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:14:6\n    |\n LL | impl<'a> Foo<'static> for &'a i32 {\n@@ -25,15 +25,15 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n LL | impl<'a,'b> Foo<'b> for &'a i64 {\n    |             ^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the impl at 19:6...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the impl at 19:6...\n   --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:6\n    |\n LL | impl<'a,'b> Foo<'b> for &'a i64 {\n    |      ^^\n    = note: ...so that the types are compatible:\n            expected Foo<'b>\n               found Foo<'_>\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the impl at 19:9...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the impl at 19:9...\n   --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:9\n    |\n LL | impl<'a,'b> Foo<'b> for &'a i64 {"}, {"sha": "81256e3b46cbb94a399d27175f88cd9614994b28", "filename": "src/test/ui/regions/regions-assoc-type-static-bound-in-trait-not-met.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n LL | impl<'a> Foo for &'a i32 {\n    |          ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the impl at 9:6...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the impl at 9:6...\n   --> $DIR/regions-assoc-type-static-bound-in-trait-not-met.rs:9:6\n    |\n LL | impl<'a> Foo for &'a i32 {"}, {"sha": "a15710b86c06e8360e0d03b899f21a3f25342d5b", "filename": "src/test/ui/regions/regions-bounds.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-bounds.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     return e;\n    |\n    = note: expected type `TupleStruct<'b>`\n               found type `TupleStruct<'a>`\n-note: the lifetime 'a as defined on the function body at 8:10...\n+note: the lifetime `'a` as defined on the function body at 8:10...\n   --> $DIR/regions-bounds.rs:8:10\n    |\n LL | fn a_fn1<'a,'b>(e: TupleStruct<'a>) -> TupleStruct<'b> {\n    |          ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the function body at 8:13\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the function body at 8:13\n   --> $DIR/regions-bounds.rs:8:13\n    |\n LL | fn a_fn1<'a,'b>(e: TupleStruct<'a>) -> TupleStruct<'b> {\n@@ -25,12 +25,12 @@ LL |     return e;\n    |\n    = note: expected type `Struct<'b>`\n               found type `Struct<'a>`\n-note: the lifetime 'a as defined on the function body at 12:10...\n+note: the lifetime `'a` as defined on the function body at 12:10...\n   --> $DIR/regions-bounds.rs:12:10\n    |\n LL | fn a_fn3<'a,'b>(e: Struct<'a>) -> Struct<'b> {\n    |          ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the function body at 12:13\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the function body at 12:13\n   --> $DIR/regions-bounds.rs:12:13\n    |\n LL | fn a_fn3<'a,'b>(e: Struct<'a>) -> Struct<'b> {"}, {"sha": "8e473dad69341e3375c6018311982e5f700032f6", "filename": "src/test/ui/regions/regions-close-object-into-object-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for borrow expression due to\n LL |     box B(&*v) as Box<dyn X>\n    |           ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 9:6...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:6...\n   --> $DIR/regions-close-object-into-object-2.rs:9:6\n    |\n LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {"}, {"sha": "c80d13e15b14726c16bc6e38b120e550220aea4b", "filename": "src/test/ui/regions/regions-close-object-into-object-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for borrow expression due to\n LL |     box B(&*v) as Box<dyn X>\n    |           ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 9:6...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:6...\n   --> $DIR/regions-close-object-into-object-4.rs:9:6\n    |\n LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {"}, {"sha": "ef21316ea83aea639866521ca102079714d32282", "filename": "src/test/ui/regions/regions-close-over-type-parameter-multiple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-multiple.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n LL |     box v as Box<dyn SomeTrait + 'a>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 18:20...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 18:20...\n   --> $DIR/regions-close-over-type-parameter-multiple.rs:18:20\n    |\n LL | fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<dyn SomeTrait + 'c> {\n@@ -14,7 +14,7 @@ note: ...so that the declared lifetime parameter bounds are satisfied\n    |\n LL |     box v as Box<dyn SomeTrait + 'a>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'c as defined on the function body at 18:26...\n+note: but, the lifetime must be valid for the lifetime `'c` as defined on the function body at 18:26...\n   --> $DIR/regions-close-over-type-parameter-multiple.rs:18:26\n    |\n LL | fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<dyn SomeTrait + 'c> {"}, {"sha": "12b89787d5f18ff5cfbf5aa83c3c4d2a8004ec9b", "filename": "src/test/ui/regions/regions-creating-enums4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-creating-enums4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-creating-enums4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-creating-enums4.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,15 +4,15 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n LL |     Ast::Add(x, y)\n    |     ^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 6:16...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 6:16...\n   --> $DIR/regions-creating-enums4.rs:6:16\n    |\n LL | fn mk_add_bad2<'a,'b>(x: &'a Ast<'a>, y: &'a Ast<'a>, z: &Ast) -> Ast<'b> {\n    |                ^^\n    = note: ...so that the expression is assignable:\n            expected &Ast<'_>\n               found &Ast<'a>\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 6:19...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 6:19...\n   --> $DIR/regions-creating-enums4.rs:6:19\n    |\n LL | fn mk_add_bad2<'a,'b>(x: &'a Ast<'a>, y: &'a Ast<'a>, z: &Ast) -> Ast<'b> {"}, {"sha": "9095451da0522bfae8e078ac54311fb44d0aef95", "filename": "src/test/ui/regions/regions-early-bound-error-method.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-early-bound-error-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-early-bound-error-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-early-bound-error-method.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n LL |         g2.get()\n    |         ^^^^^^^^\n    |\n-note: ...the reference is valid for the lifetime 'a as defined on the impl at 18:6...\n+note: ...the reference is valid for the lifetime `'a` as defined on the impl at 18:6...\n   --> $DIR/regions-early-bound-error-method.rs:18:6\n    |\n LL | impl<'a> Box<'a> {\n    |      ^^\n-note: ...but the borrowed content is only valid for the lifetime 'b as defined on the method body at 19:11\n+note: ...but the borrowed content is only valid for the lifetime `'b` as defined on the method body at 19:11\n   --> $DIR/regions-early-bound-error-method.rs:19:11\n    |\n LL |     fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a isize {"}, {"sha": "162d573362d45d1f3617a7b4464deb12ee71fc70", "filename": "src/test/ui/regions/regions-early-bound-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-early-bound-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-early-bound-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-early-bound-error.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n LL |     g1.get()\n    |     ^^^^^^^^\n    |\n-note: ...the reference is valid for the lifetime 'b as defined on the function body at 18:11...\n+note: ...the reference is valid for the lifetime `'b` as defined on the function body at 18:11...\n   --> $DIR/regions-early-bound-error.rs:18:11\n    |\n LL | fn get<'a,'b,G:GetRef<'a, isize>>(g1: G, b: &'b isize) -> &'b isize {\n    |           ^^\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 18:8\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 18:8\n   --> $DIR/regions-early-bound-error.rs:18:8\n    |\n LL | fn get<'a,'b,G:GetRef<'a, isize>>(g1: G, b: &'b isize) -> &'b isize {"}, {"sha": "ad555efadf7ec98d24cd342c3948d254661eb85d", "filename": "src/test/ui/regions/regions-free-region-ordering-callee-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-callee-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-callee-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-callee-4.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -8,12 +8,12 @@ LL | |     let z: Option<&'a &'b usize> = None;\n LL | | }\n    | |_^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 5:14\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 5:14\n   --> $DIR/regions-free-region-ordering-callee-4.rs:5:14\n    |\n LL | fn ordering4<'a, 'b, F>(a: &'a usize, b: &'b usize, x: F) where F: FnOnce(&'a &'b usize) {\n    |              ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 5:18\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 5:18\n   --> $DIR/regions-free-region-ordering-callee-4.rs:5:18\n    |\n LL | fn ordering4<'a, 'b, F>(a: &'a usize, b: &'b usize, x: F) where F: FnOnce(&'a &'b usize) {"}, {"sha": "10644174b9bc43bc7c28d3dbadb666bc6ae17914", "filename": "src/test/ui/regions/regions-free-region-ordering-incorrect.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-incorrect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-incorrect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-incorrect.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for borrow expression due to\n LL |             None => &self.val\n    |                     ^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the method body at 14:12...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the method body at 14:12...\n   --> $DIR/regions-free-region-ordering-incorrect.rs:14:12\n    |\n LL |     fn get<'a>(&'a self) -> &'b T {\n@@ -14,7 +14,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |             None => &self.val\n    |                     ^^^^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the impl at 13:6...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the impl at 13:6...\n   --> $DIR/regions-free-region-ordering-incorrect.rs:13:6\n    |\n LL | impl<'b, T> Node<'b, T> {"}, {"sha": "c4ca7e970749c4fb30a1919e137afb3f23c48c36", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-hr-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -7,12 +7,12 @@ LL | | {\n LL | | }\n    | |_^\n    |\n-note: the pointer is valid for the lifetime 'x as defined on the function body at 21:11\n+note: the pointer is valid for the lifetime `'x` as defined on the function body at 21:11\n   --> $DIR/regions-implied-bounds-projection-gap-hr-1.rs:21:11\n    |\n LL | fn callee<'x, 'y, T>(t: &'x dyn for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n    |           ^^\n-note: but the referenced data is only valid for the lifetime 'y as defined on the function body at 21:15\n+note: but the referenced data is only valid for the lifetime `'y` as defined on the function body at 21:15\n   --> $DIR/regions-implied-bounds-projection-gap-hr-1.rs:21:15\n    |\n LL | fn callee<'x, 'y, T>(t: &'x dyn for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)"}, {"sha": "f4e223bbf6f9bd5c93c3aab2cbb68784ce943fe9", "filename": "src/test/ui/regions/regions-infer-invariance-due-to-decl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-decl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-decl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-decl.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     b_isize\n    |\n    = note: expected type `Invariant<'static>`\n               found type `Invariant<'r>`\n-note: the lifetime 'r as defined on the function body at 11:23...\n+note: the lifetime `'r` as defined on the function body at 11:23...\n   --> $DIR/regions-infer-invariance-due-to-decl.rs:11:23\n    |\n LL | fn to_longer_lifetime<'r>(b_isize: Invariant<'r>) -> Invariant<'static> {"}, {"sha": "6322244fcf937e8019faed300d5fc008bd19d6cf", "filename": "src/test/ui/regions/regions-infer-invariance-due-to-mutability-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-mutability-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-mutability-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-mutability-3.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     b_isize\n    |\n    = note: expected type `Invariant<'static>`\n               found type `Invariant<'r>`\n-note: the lifetime 'r as defined on the function body at 9:23...\n+note: the lifetime `'r` as defined on the function body at 9:23...\n   --> $DIR/regions-infer-invariance-due-to-mutability-3.rs:9:23\n    |\n LL | fn to_longer_lifetime<'r>(b_isize: Invariant<'r>) -> Invariant<'static> {"}, {"sha": "7baae69945f9cda1a16a7a8bfcbc29b9ad31d95b", "filename": "src/test/ui/regions/regions-infer-invariance-due-to-mutability-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-mutability-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-mutability-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-invariance-due-to-mutability-4.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     b_isize\n    |\n    = note: expected type `Invariant<'static>`\n               found type `Invariant<'r>`\n-note: the lifetime 'r as defined on the function body at 9:23...\n+note: the lifetime `'r` as defined on the function body at 9:23...\n   --> $DIR/regions-infer-invariance-due-to-mutability-4.rs:9:23\n    |\n LL | fn to_longer_lifetime<'r>(b_isize: Invariant<'r>) -> Invariant<'static> {"}, {"sha": "6365769430f362656755958be01fdd5116a6f51b", "filename": "src/test/ui/regions/regions-infer-not-param.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-not-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-not-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-not-param.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL | fn take_direct<'a,'b>(p: Direct<'a>) -> Direct<'b> { p }\n    |\n    = note: expected type `Direct<'b>`\n               found type `Direct<'a>`\n-note: the lifetime 'a as defined on the function body at 15:16...\n+note: the lifetime `'a` as defined on the function body at 15:16...\n   --> $DIR/regions-infer-not-param.rs:15:16\n    |\n LL | fn take_direct<'a,'b>(p: Direct<'a>) -> Direct<'b> { p }\n    |                ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the function body at 15:19\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the function body at 15:19\n   --> $DIR/regions-infer-not-param.rs:15:19\n    |\n LL | fn take_direct<'a,'b>(p: Direct<'a>) -> Direct<'b> { p }\n@@ -25,12 +25,12 @@ LL | fn take_indirect2<'a,'b>(p: Indirect2<'a>) -> Indirect2<'b> { p }\n    |\n    = note: expected type `Indirect2<'b>`\n               found type `Indirect2<'a>`\n-note: the lifetime 'a as defined on the function body at 19:19...\n+note: the lifetime `'a` as defined on the function body at 19:19...\n   --> $DIR/regions-infer-not-param.rs:19:19\n    |\n LL | fn take_indirect2<'a,'b>(p: Indirect2<'a>) -> Indirect2<'b> { p }\n    |                   ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the function body at 19:22\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the function body at 19:22\n   --> $DIR/regions-infer-not-param.rs:19:22\n    |\n LL | fn take_indirect2<'a,'b>(p: Indirect2<'a>) -> Indirect2<'b> { p }\n@@ -44,12 +44,12 @@ LL | fn take_indirect2<'a,'b>(p: Indirect2<'a>) -> Indirect2<'b> { p }\n    |\n    = note: expected type `Indirect2<'b>`\n               found type `Indirect2<'a>`\n-note: the lifetime 'b as defined on the function body at 19:22...\n+note: the lifetime `'b` as defined on the function body at 19:22...\n   --> $DIR/regions-infer-not-param.rs:19:22\n    |\n LL | fn take_indirect2<'a,'b>(p: Indirect2<'a>) -> Indirect2<'b> { p }\n    |                      ^^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the function body at 19:19\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the function body at 19:19\n   --> $DIR/regions-infer-not-param.rs:19:19\n    |\n LL | fn take_indirect2<'a,'b>(p: Indirect2<'a>) -> Indirect2<'b> { p }"}, {"sha": "b1fd337b8d04b4d262640978b68dc72666d72687", "filename": "src/test/ui/regions/regions-infer-paramd-indirect.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-paramd-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-paramd-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-paramd-indirect.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -17,7 +17,7 @@ LL | |\n LL | |\n LL | |     }\n    | |_____^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 16:6\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 16:6\n   --> $DIR/regions-infer-paramd-indirect.rs:16:6\n    |\n LL | impl<'a> SetF<'a> for C<'a> {"}, {"sha": "f4eb5c8644f034872c80dba20474d346bbfbc90e", "filename": "src/test/ui/regions/regions-nested-fns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -49,7 +49,7 @@ LL | |         if false { return ay; }\n LL | |         return z;\n LL | |     }));\n    | |_____^\n-note: ...but the borrowed content is only valid for the lifetime 'x as defined on the function body at 3:11\n+note: ...but the borrowed content is only valid for the lifetime `'x` as defined on the function body at 3:11\n   --> $DIR/regions-nested-fns.rs:3:11\n    |\n LL | fn nested<'x>(x: &'x isize) {"}, {"sha": "d29fd80943f73a2030b1695284f100a793568f36", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -7,12 +7,12 @@ LL | | {\n LL | | }\n    | |_^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 22:8...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:8...\n   --> $DIR/regions-normalize-in-where-clause-list.rs:22:8\n    |\n LL | fn bar<'a, 'b>()\n    |        ^^\n-note: ...but the lifetime must also be valid for the lifetime 'b as defined on the function body at 22:12...\n+note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 22:12...\n   --> $DIR/regions-normalize-in-where-clause-list.rs:22:12\n    |\n LL | fn bar<'a, 'b>()"}, {"sha": "0992d9bf295c1c5408d5ccd91bac913a14a68e77", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.migrate.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a WithHrAssoc<TheType<'b>>`, reference has a longer lif\n LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 27:15\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 27:15\n   --> $DIR/regions-outlives-projection-container-hrtb.rs:27:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 27:18\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 27:18\n   --> $DIR/regions-outlives-projection-container-hrtb.rs:27:18\n    |\n LL | fn with_assoc<'a,'b>() {\n@@ -21,12 +21,12 @@ error[E0491]: in type `&'a WithHrAssocSub<TheType<'b>>`, reference has a longer\n LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 46:19\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 46:19\n   --> $DIR/regions-outlives-projection-container-hrtb.rs:46:19\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 46:22\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 46:22\n   --> $DIR/regions-outlives-projection-container-hrtb.rs:46:22\n    |\n LL | fn with_assoc_sub<'a,'b>() {"}, {"sha": "49e28a14d8a4ec219d21b9bdbcef7c6feb5fce29", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.migrate.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifet\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 27:15\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 27:15\n   --> $DIR/regions-outlives-projection-container-wc.rs:27:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 27:18\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 27:18\n   --> $DIR/regions-outlives-projection-container-wc.rs:27:18\n    |\n LL | fn with_assoc<'a,'b>() {"}, {"sha": "dba15fb0576eea6bcb10ff50e2a6d9e8cda3f87b", "filename": "src/test/ui/regions/regions-outlives-projection-container.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifet\n LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 28:15\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 28:15\n   --> $DIR/regions-outlives-projection-container.rs:28:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 28:18\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 28:18\n   --> $DIR/regions-outlives-projection-container.rs:28:18\n    |\n LL | fn with_assoc<'a,'b>() {\n@@ -21,12 +21,12 @@ error[E0491]: in type `&'a WithoutAssoc<TheType<'b>>`, reference has a longer li\n LL |     let _x: &'a WithoutAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 50:18\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 50:18\n   --> $DIR/regions-outlives-projection-container.rs:50:18\n    |\n LL | fn without_assoc<'a,'b>() {\n    |                  ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 50:21\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 50:21\n   --> $DIR/regions-outlives-projection-container.rs:50:21\n    |\n LL | fn without_assoc<'a,'b>() {\n@@ -38,12 +38,12 @@ error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifet\n LL |     call::<&'a WithAssoc<TheType<'b>>>();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 58:20\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 58:20\n   --> $DIR/regions-outlives-projection-container.rs:58:20\n    |\n LL | fn call_with_assoc<'a,'b>() {\n    |                    ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 58:23\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 58:23\n   --> $DIR/regions-outlives-projection-container.rs:58:23\n    |\n LL | fn call_with_assoc<'a,'b>() {\n@@ -55,12 +55,12 @@ error[E0491]: in type `&'a WithoutAssoc<TheType<'b>>`, reference has a longer li\n LL |     call::<&'a WithoutAssoc<TheType<'b>>>();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 67:23\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 67:23\n   --> $DIR/regions-outlives-projection-container.rs:67:23\n    |\n LL | fn call_without_assoc<'a,'b>() {\n    |                       ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 67:26\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 67:26\n   --> $DIR/regions-outlives-projection-container.rs:67:26\n    |\n LL | fn call_without_assoc<'a,'b>() {"}, {"sha": "49076673ad3989dd1f58ccbe183dcdf592d1c20a", "filename": "src/test/ui/regions/regions-ret-borrowed-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -12,7 +12,7 @@ LL |     with(|o| o)\n    = note: ...so that the expression is assignable:\n            expected &isize\n               found &isize\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the function body at 9:14...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 9:14...\n   --> $DIR/regions-ret-borrowed-1.rs:9:14\n    |\n LL | fn return_it<'a>() -> &'a isize {"}, {"sha": "eb1ade27acea7a3f8c51e31959a43ceca7da3fce", "filename": "src/test/ui/regions/regions-ret-borrowed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -12,7 +12,7 @@ LL |     with(|o| o)\n    = note: ...so that the expression is assignable:\n            expected &isize\n               found &isize\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the function body at 12:14...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 12:14...\n   --> $DIR/regions-ret-borrowed.rs:12:14\n    |\n LL | fn return_it<'a>() -> &'a isize {"}, {"sha": "946465bcb5f261a4437b307d33c4e954907d5187", "filename": "src/test/ui/regions/regions-return-ref-to-upvar-issue-17403.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for borrow expression due to\n LL |         let mut f = || &mut x;\n    |                        ^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime '_ as defined on the body at 7:21...\n+note: first, the lifetime cannot outlive the lifetime `'_` as defined on the body at 7:21...\n   --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:21\n    |\n LL |         let mut f = || &mut x;"}, {"sha": "6e631d40d45008119732c8a0fd60be27ce050666", "filename": "src/test/ui/regions/regions-static-bound.migrate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.migrate.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -5,7 +5,7 @@ LL |     t\n    |     ^\n    |\n    = note: ...the reference is valid for the static lifetime...\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the function body at 8:24\n+note: ...but the borrowed content is only valid for the lifetime `'a` as defined on the function body at 8:24\n   --> $DIR/regions-static-bound.rs:8:24\n    |\n LL | fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {"}, {"sha": "f835c005ff969f3df94adbba84d84e028fd91236", "filename": "src/test/ui/regions/regions-trait-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     fn get_ctxt(&self) -> &'a Ctxt {\n    |\n    = note: expected type `fn(&HasCtxt<'a>) -> &Ctxt`\n               found type `fn(&HasCtxt<'a>) -> &'a Ctxt`\n-note: the lifetime 'a as defined on the impl at 12:6...\n+note: the lifetime `'a` as defined on the impl at 12:6...\n   --> $DIR/regions-trait-1.rs:12:6\n    |\n LL | impl<'a> GetCtxt for HasCtxt<'a> {"}, {"sha": "b7c7f93149dcf031cc44e7f12769657193958804", "filename": "src/test/ui/regions/regions-trait-object-subtyping.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0478]: lifetime bound not satisfied\n LL |     x\n    |     ^\n    |\n-note: lifetime parameter instantiated with the lifetime 'a as defined on the function body at 13:9\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the function body at 13:9\n   --> $DIR/regions-trait-object-subtyping.rs:13:9\n    |\n LL | fn foo3<'a,'b>(x: &'a mut dyn Dummy) -> &'b mut dyn Dummy {\n    |         ^^\n-note: but lifetime parameter must outlive the lifetime 'b as defined on the function body at 13:12\n+note: but lifetime parameter must outlive the lifetime `'b` as defined on the function body at 13:12\n   --> $DIR/regions-trait-object-subtyping.rs:13:12\n    |\n LL | fn foo3<'a,'b>(x: &'a mut dyn Dummy) -> &'b mut dyn Dummy {\n@@ -21,7 +21,7 @@ error[E0495]: cannot infer an appropriate lifetime for automatic coercion due to\n LL |     x\n    |     ^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the function body at 13:9...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 13:9...\n   --> $DIR/regions-trait-object-subtyping.rs:13:9\n    |\n LL | fn foo3<'a,'b>(x: &'a mut dyn Dummy) -> &'b mut dyn Dummy {\n@@ -31,7 +31,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |     x\n    |     ^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 13:12...\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 13:12...\n   --> $DIR/regions-trait-object-subtyping.rs:13:12\n    |\n LL | fn foo3<'a,'b>(x: &'a mut dyn Dummy) -> &'b mut dyn Dummy {\n@@ -48,12 +48,12 @@ LL |     x\n    |\n    = note: expected type `Wrapper<&'b mut (dyn Dummy + 'b)>`\n               found type `Wrapper<&'a mut (dyn Dummy + 'a)>`\n-note: the lifetime 'b as defined on the function body at 20:15...\n+note: the lifetime `'b` as defined on the function body at 20:15...\n   --> $DIR/regions-trait-object-subtyping.rs:20:15\n    |\n LL | fn foo4<'a:'b,'b>(x: Wrapper<&'a mut dyn Dummy>) -> Wrapper<&'b mut dyn Dummy> {\n    |               ^^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the function body at 20:9\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the function body at 20:9\n   --> $DIR/regions-trait-object-subtyping.rs:20:9\n    |\n LL | fn foo4<'a:'b,'b>(x: Wrapper<&'a mut dyn Dummy>) -> Wrapper<&'b mut dyn Dummy> {"}, {"sha": "aae519c5df2e9901057e23d14e4168399d24d591", "filename": "src/test/ui/regions/regions-variance-invariant-use-covariant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-variance-invariant-use-covariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-variance-invariant-use-covariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-variance-invariant-use-covariant.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     let _: Invariant<'static> = c;\n    |\n    = note: expected type `Invariant<'static>`\n               found type `Invariant<'b>`\n-note: the lifetime 'b as defined on the function body at 11:9...\n+note: the lifetime `'b` as defined on the function body at 11:9...\n   --> $DIR/regions-variance-invariant-use-covariant.rs:11:9\n    |\n LL | fn use_<'b>(c: Invariant<'b>) {"}, {"sha": "9f39508604110df3c48abb2becb2a3a1208a8828", "filename": "src/test/ui/regions/regions-wf-trait-object.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-wf-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fregions%2Fregions-wf-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-wf-trait-object.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0478]: lifetime bound not satisfied\n LL |     x: Box<dyn TheTrait<'a>+'b>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: lifetime parameter instantiated with the lifetime 'b as defined on the struct at 6:15\n+note: lifetime parameter instantiated with the lifetime `'b` as defined on the struct at 6:15\n   --> $DIR/regions-wf-trait-object.rs:6:15\n    |\n LL | struct Foo<'a,'b> {\n    |               ^^\n-note: but lifetime parameter must outlive the lifetime 'a as defined on the struct at 6:12\n+note: but lifetime parameter must outlive the lifetime `'a` as defined on the struct at 6:12\n   --> $DIR/regions-wf-trait-object.rs:6:12\n    |\n LL | struct Foo<'a,'b> {"}, {"sha": "609a40163a30c38fcb3e8ccc7efabe9ab064f115", "filename": "src/test/ui/reject-specialized-drops-8142.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Freject-specialized-drops-8142.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Freject-specialized-drops-8142.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freject-specialized-drops-8142.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -34,7 +34,7 @@ LL | impl                    Drop for N<'static>     { fn drop(&mut self) { } }\n    |\n    = note: expected type `N<'n>`\n               found type `N<'static>`\n-note: the lifetime 'n as defined on the struct at 8:10...\n+note: the lifetime `'n` as defined on the struct at 8:10...\n   --> $DIR/reject-specialized-drops-8142.rs:8:10\n    |\n LL | struct N<'n> { x: &'n i8 }\n@@ -95,12 +95,12 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'lw`\n LL | impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'l1 as defined on the struct at 17:10...\n+note: first, the lifetime cannot outlive the lifetime `'l1` as defined on the struct at 17:10...\n   --> $DIR/reject-specialized-drops-8142.rs:17:10\n    |\n LL | struct W<'l1, 'l2> { x: &'l1 i8, y: &'l2 u8 }\n    |          ^^^\n-note: ...but the lifetime must also be valid for the lifetime 'l2 as defined on the struct at 17:15...\n+note: ...but the lifetime must also be valid for the lifetime `'l2` as defined on the struct at 17:15...\n   --> $DIR/reject-specialized-drops-8142.rs:17:15\n    |\n LL | struct W<'l1, 'l2> { x: &'l1 i8, y: &'l2 u8 }"}, {"sha": "6efc1176d05b84e9497c2dded93319511bd727b9", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-outlives-nominal-type-region-rev.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-region-rev.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-region-rev.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-region-rev.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a rev_variant_struct_region::Foo<'b>`, reference has a\n LL |         type Out = &'a Foo<'b>;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the impl at 16:10\n+note: the pointer is valid for the lifetime `'a` as defined on the impl at 16:10\n   --> $DIR/regions-outlives-nominal-type-region-rev.rs:16:10\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {\n    |          ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the impl at 16:14\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the impl at 16:14\n   --> $DIR/regions-outlives-nominal-type-region-rev.rs:16:14\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {"}, {"sha": "06e5f24dec97014cfa2f50ca81d481a3f3058cc7", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-outlives-nominal-type-region.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-region.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a variant_struct_region::Foo<'b>`, reference has a long\n LL |         type Out = &'a Foo<'b>;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the impl at 16:10\n+note: the pointer is valid for the lifetime `'a` as defined on the impl at 16:10\n   --> $DIR/regions-outlives-nominal-type-region.rs:16:10\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {\n    |          ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the impl at 16:14\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the impl at 16:14\n   --> $DIR/regions-outlives-nominal-type-region.rs:16:14\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {"}, {"sha": "d02f7b796218499bb1b208c133096fbe3e365a80", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-outlives-nominal-type-type-rev.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-type-rev.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-type-rev.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-type-rev.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a variant_struct_type::Foo<&'b i32>`, reference has a l\n LL |         type Out = &'a Foo<&'b i32>;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the impl at 16:10\n+note: the pointer is valid for the lifetime `'a` as defined on the impl at 16:10\n   --> $DIR/regions-outlives-nominal-type-type-rev.rs:16:10\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {\n    |          ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the impl at 16:14\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the impl at 16:14\n   --> $DIR/regions-outlives-nominal-type-type-rev.rs:16:14\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {"}, {"sha": "40c70f53245cfeeeeb0d45bd6402ae40c37dbf9c", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-outlives-nominal-type-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-outlives-nominal-type-type.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0491]: in type `&'a variant_struct_type::Foo<&'b i32>`, reference has a l\n LL |         type Out = &'a Foo<&'b i32>;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the impl at 16:10\n+note: the pointer is valid for the lifetime `'a` as defined on the impl at 16:10\n   --> $DIR/regions-outlives-nominal-type-type.rs:16:10\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {\n    |          ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the impl at 16:14\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the impl at 16:14\n   --> $DIR/regions-outlives-nominal-type-type.rs:16:14\n    |\n LL |     impl<'a, 'b> Trait<'a, 'b> for usize {"}, {"sha": "825c1015c51d7e37c5543e797d8ae51b7c059f66", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-struct-not-wf.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -32,12 +32,12 @@ error[E0491]: in type `&'a &'b T`, reference has a longer lifetime than the data\n LL |     type Out = &'a &'b T;\n    |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the impl at 24:6\n+note: the pointer is valid for the lifetime `'a` as defined on the impl at 24:6\n   --> $DIR/regions-struct-not-wf.rs:24:6\n    |\n LL | impl<'a, 'b, T> Trait1<'a, 'b, T> for u32 {\n    |      ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the impl at 24:10\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the impl at 24:10\n   --> $DIR/regions-struct-not-wf.rs:24:10\n    |\n LL | impl<'a, 'b, T> Trait1<'a, 'b, T> for u32 {"}, {"sha": "bce1900ca602c41e14ea4195e6cbc345531320e3", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n    |                |\n    |                ...but this borrow...\n    |\n-note: ...can't outlive the lifetime '_ as defined on the method body at 8:26\n+note: ...can't outlive the lifetime `'_` as defined on the method body at 8:26\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:26\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n    |                          ^\n-help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime '_ as defined on the method body at 8:26\n+help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime `'_` as defined on the method body at 8:26\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                     ^^^^^^^^^^^^^^^"}, {"sha": "99235e26e15e7a5a23afefd80b52671ebc3e877d", "filename": "src/test/ui/static/static-closures.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fstatic%2Fstatic-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fstatic%2Fstatic-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-closures.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,3 +6,4 @@ LL |     static || {};\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0697`."}, {"sha": "bda325dc0116045470e27a96e45ab553eff50bac", "filename": "src/test/ui/static/static-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fstatic%2Fstatic-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fstatic%2Fstatic-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-lifetime.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,7 +4,7 @@ error[E0478]: lifetime bound not satisfied\n LL | impl<'a, A: Clone> Arbitrary for ::std::borrow::Cow<'a, A> {}\n    |                    ^^^^^^^^^\n    |\n-note: lifetime parameter instantiated with the lifetime 'a as defined on the impl at 3:6\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the impl at 3:6\n   --> $DIR/static-lifetime.rs:3:6\n    |\n LL | impl<'a, A: Clone> Arbitrary for ::std::borrow::Cow<'a, A> {}"}, {"sha": "88c9c473eb0c7c0c53b32a5d83e7917ab0a54935", "filename": "src/test/ui/traits/trait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Ftraits%2Ftrait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Ftraits%2Ftrait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'b` d\n LL | impl<'a,'b> T2<'a, 'b> for S<'a, 'b> {\n    |             ^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'a as defined on the impl at 24:6...\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the impl at 24:6...\n   --> $DIR/trait-impl-of-supertrait-has-wrong-lifetime-parameters.rs:24:6\n    |\n LL | impl<'a,'b> T2<'a, 'b> for S<'a, 'b> {\n    |      ^^\n-note: ...but the lifetime must also be valid for the lifetime 'b as defined on the impl at 24:9...\n+note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the impl at 24:9...\n   --> $DIR/trait-impl-of-supertrait-has-wrong-lifetime-parameters.rs:24:9\n    |\n LL | impl<'a,'b> T2<'a, 'b> for S<'a, 'b> {"}, {"sha": "e1ccde3c9d14a80752124822237784789a5705a0", "filename": "src/test/ui/traits/trait-matching-lifetimes.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Ftraits%2Ftrait-matching-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Ftraits%2Ftrait-matching-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-matching-lifetimes.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     fn foo(x: Foo<'b,'a>) {\n    |\n    = note: expected type `fn(Foo<'a, 'b>)`\n               found type `fn(Foo<'b, 'a>)`\n-note: the lifetime 'b as defined on the impl at 13:9...\n+note: the lifetime `'b` as defined on the impl at 13:9...\n   --> $DIR/trait-matching-lifetimes.rs:13:9\n    |\n LL | impl<'a,'b> Tr for Foo<'a,'b> {\n    |         ^^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 13:6\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 13:6\n   --> $DIR/trait-matching-lifetimes.rs:13:6\n    |\n LL | impl<'a,'b> Tr for Foo<'a,'b> {\n@@ -25,12 +25,12 @@ LL |     fn foo(x: Foo<'b,'a>) {\n    |\n    = note: expected type `fn(Foo<'a, 'b>)`\n               found type `fn(Foo<'b, 'a>)`\n-note: the lifetime 'a as defined on the impl at 13:6...\n+note: the lifetime `'a` as defined on the impl at 13:6...\n   --> $DIR/trait-matching-lifetimes.rs:13:6\n    |\n LL | impl<'a,'b> Tr for Foo<'a,'b> {\n    |      ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the impl at 13:9\n+note: ...does not necessarily outlive the lifetime `'b` as defined on the impl at 13:9\n   --> $DIR/trait-matching-lifetimes.rs:13:9\n    |\n LL | impl<'a,'b> Tr for Foo<'a,'b> {"}, {"sha": "de3a997a19ed8d65bfd70d86a534f3ba92a4021c", "filename": "src/test/ui/ufcs/ufcs-explicit-self-bad.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -38,7 +38,7 @@ note: the anonymous lifetime #1 defined on the method body at 37:5...\n    |\n LL |     fn dummy2(self: &Bar<T>) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 35:6\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 35:6\n   --> $DIR/ufcs-explicit-self-bad.rs:35:6\n    |\n LL | impl<'a, T> SomeTrait for &'a Bar<T> {\n@@ -52,7 +52,7 @@ LL |     fn dummy2(self: &Bar<T>) {}\n    |\n    = note: expected type `&'a Bar<T>`\n               found type `&Bar<T>`\n-note: the lifetime 'a as defined on the impl at 35:6...\n+note: the lifetime `'a` as defined on the impl at 35:6...\n   --> $DIR/ufcs-explicit-self-bad.rs:35:6\n    |\n LL | impl<'a, T> SomeTrait for &'a Bar<T> {\n@@ -76,7 +76,7 @@ note: the anonymous lifetime #2 defined on the method body at 39:5...\n    |\n LL |     fn dummy3(self: &&Bar<T>) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 35:6\n+note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 35:6\n   --> $DIR/ufcs-explicit-self-bad.rs:35:6\n    |\n LL | impl<'a, T> SomeTrait for &'a Bar<T> {\n@@ -90,7 +90,7 @@ LL |     fn dummy3(self: &&Bar<T>) {}\n    |\n    = note: expected type `&'a Bar<T>`\n               found type `&Bar<T>`\n-note: the lifetime 'a as defined on the impl at 35:6...\n+note: the lifetime `'a` as defined on the impl at 35:6...\n   --> $DIR/ufcs-explicit-self-bad.rs:35:6\n    |\n LL | impl<'a, T> SomeTrait for &'a Bar<T> {"}, {"sha": "0f93927683ea677024ffe744918934e984b2289b", "filename": "src/test/ui/variance/variance-btree-invariant-types.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,7 +6,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::IterMut<'_, &'new (), _>`\n               found type `std::collections::btree_map::IterMut<'_, &'static (), _>`\n-note: the lifetime 'new as defined on the function body at 3:21...\n+note: the lifetime `'new` as defined on the function body at 3:21...\n   --> $DIR/variance-btree-invariant-types.rs:3:21\n    |\n LL | fn iter_cov_key<'a, 'new>(v: IterMut<'a, &'static (), ()>) -> IterMut<'a, &'new (), ()> {\n@@ -21,7 +21,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::IterMut<'_, _, &'new ()>`\n               found type `std::collections::btree_map::IterMut<'_, _, &'static ()>`\n-note: the lifetime 'new as defined on the function body at 6:21...\n+note: the lifetime `'new` as defined on the function body at 6:21...\n   --> $DIR/variance-btree-invariant-types.rs:6:21\n    |\n LL | fn iter_cov_val<'a, 'new>(v: IterMut<'a, (), &'static ()>) -> IterMut<'a, (), &'new ()> {\n@@ -36,7 +36,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::IterMut<'_, &'static (), _>`\n               found type `std::collections::btree_map::IterMut<'_, &'new (), _>`\n-note: the lifetime 'new as defined on the function body at 9:24...\n+note: the lifetime `'new` as defined on the function body at 9:24...\n   --> $DIR/variance-btree-invariant-types.rs:9:24\n    |\n LL | fn iter_contra_key<'a, 'new>(v: IterMut<'a, &'new (), ()>) -> IterMut<'a, &'static (), ()> {\n@@ -51,7 +51,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::IterMut<'_, _, &'static ()>`\n               found type `std::collections::btree_map::IterMut<'_, _, &'new ()>`\n-note: the lifetime 'new as defined on the function body at 12:24...\n+note: the lifetime `'new` as defined on the function body at 12:24...\n   --> $DIR/variance-btree-invariant-types.rs:12:24\n    |\n LL | fn iter_contra_val<'a, 'new>(v: IterMut<'a, (), &'new ()>) -> IterMut<'a, (), &'static ()> {\n@@ -66,7 +66,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::OccupiedEntry<'_, &'new (), _>`\n               found type `std::collections::btree_map::OccupiedEntry<'_, &'static (), _>`\n-note: the lifetime 'new as defined on the function body at 16:20...\n+note: the lifetime `'new` as defined on the function body at 16:20...\n   --> $DIR/variance-btree-invariant-types.rs:16:20\n    |\n LL | fn occ_cov_key<'a, 'new>(v: OccupiedEntry<'a, &'static (), ()>)\n@@ -81,7 +81,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::OccupiedEntry<'_, _, &'new ()>`\n               found type `std::collections::btree_map::OccupiedEntry<'_, _, &'static ()>`\n-note: the lifetime 'new as defined on the function body at 20:20...\n+note: the lifetime `'new` as defined on the function body at 20:20...\n   --> $DIR/variance-btree-invariant-types.rs:20:20\n    |\n LL | fn occ_cov_val<'a, 'new>(v: OccupiedEntry<'a, (), &'static ()>)\n@@ -96,7 +96,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::OccupiedEntry<'_, &'static (), _>`\n               found type `std::collections::btree_map::OccupiedEntry<'_, &'new (), _>`\n-note: the lifetime 'new as defined on the function body at 24:23...\n+note: the lifetime `'new` as defined on the function body at 24:23...\n   --> $DIR/variance-btree-invariant-types.rs:24:23\n    |\n LL | fn occ_contra_key<'a, 'new>(v: OccupiedEntry<'a, &'new (), ()>)\n@@ -111,7 +111,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::OccupiedEntry<'_, _, &'static ()>`\n               found type `std::collections::btree_map::OccupiedEntry<'_, _, &'new ()>`\n-note: the lifetime 'new as defined on the function body at 28:23...\n+note: the lifetime `'new` as defined on the function body at 28:23...\n   --> $DIR/variance-btree-invariant-types.rs:28:23\n    |\n LL | fn occ_contra_val<'a, 'new>(v: OccupiedEntry<'a, (), &'new ()>)\n@@ -126,7 +126,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::VacantEntry<'_, &'new (), _>`\n               found type `std::collections::btree_map::VacantEntry<'_, &'static (), _>`\n-note: the lifetime 'new as defined on the function body at 33:20...\n+note: the lifetime `'new` as defined on the function body at 33:20...\n   --> $DIR/variance-btree-invariant-types.rs:33:20\n    |\n LL | fn vac_cov_key<'a, 'new>(v: VacantEntry<'a, &'static (), ()>)\n@@ -141,7 +141,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::VacantEntry<'_, _, &'new ()>`\n               found type `std::collections::btree_map::VacantEntry<'_, _, &'static ()>`\n-note: the lifetime 'new as defined on the function body at 37:20...\n+note: the lifetime `'new` as defined on the function body at 37:20...\n   --> $DIR/variance-btree-invariant-types.rs:37:20\n    |\n LL | fn vac_cov_val<'a, 'new>(v: VacantEntry<'a, (), &'static ()>)\n@@ -156,7 +156,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::VacantEntry<'_, &'static (), _>`\n               found type `std::collections::btree_map::VacantEntry<'_, &'new (), _>`\n-note: the lifetime 'new as defined on the function body at 41:23...\n+note: the lifetime `'new` as defined on the function body at 41:23...\n   --> $DIR/variance-btree-invariant-types.rs:41:23\n    |\n LL | fn vac_contra_key<'a, 'new>(v: VacantEntry<'a, &'new (), ()>)\n@@ -171,7 +171,7 @@ LL |     v\n    |\n    = note: expected type `std::collections::btree_map::VacantEntry<'_, _, &'static ()>`\n               found type `std::collections::btree_map::VacantEntry<'_, _, &'new ()>`\n-note: the lifetime 'new as defined on the function body at 45:23...\n+note: the lifetime `'new` as defined on the function body at 45:23...\n   --> $DIR/variance-btree-invariant-types.rs:45:23\n    |\n LL | fn vac_contra_val<'a, 'new>(v: VacantEntry<'a, (), &'new ()>)"}, {"sha": "27017e5dc47d6120feae44151450a9b150dfa851", "filename": "src/test/ui/variance/variance-contravariant-arg-object.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-object.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     v\n    |\n    = note: expected type `dyn Get<&'min i32>`\n               found type `dyn Get<&'max i32>`\n-note: the lifetime 'min as defined on the function body at 10:21...\n+note: the lifetime `'min` as defined on the function body at 10:21...\n   --> $DIR/variance-contravariant-arg-object.rs:10:21\n    |\n LL | fn get_min_from_max<'min, 'max>(v: Box<dyn Get<&'max i32>>)\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 10:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 10:27\n   --> $DIR/variance-contravariant-arg-object.rs:10:27\n    |\n LL | fn get_min_from_max<'min, 'max>(v: Box<dyn Get<&'max i32>>)\n@@ -25,12 +25,12 @@ LL |     v\n    |\n    = note: expected type `dyn Get<&'max i32>`\n               found type `dyn Get<&'min i32>`\n-note: the lifetime 'min as defined on the function body at 17:21...\n+note: the lifetime `'min` as defined on the function body at 17:21...\n   --> $DIR/variance-contravariant-arg-object.rs:17:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>(v: Box<dyn Get<&'min i32>>)\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 17:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 17:27\n   --> $DIR/variance-contravariant-arg-object.rs:17:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>(v: Box<dyn Get<&'min i32>>)"}, {"sha": "1752b3b36a484ab5918c2a02bb9b5351a861f7ef", "filename": "src/test/ui/variance/variance-contravariant-arg-trait-match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-trait-match.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     impls_get::<G,&'min i32>()\n    |\n    = note: expected type `Get<&'min i32>`\n               found type `Get<&'max i32>`\n-note: the lifetime 'min as defined on the function body at 10:21...\n+note: the lifetime `'min` as defined on the function body at 10:21...\n   --> $DIR/variance-contravariant-arg-trait-match.rs:10:21\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 10:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 10:27\n   --> $DIR/variance-contravariant-arg-trait-match.rs:10:27\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n@@ -25,12 +25,12 @@ LL |     impls_get::<G,&'max i32>()\n    |\n    = note: expected type `Get<&'max i32>`\n               found type `Get<&'min i32>`\n-note: the lifetime 'min as defined on the function body at 16:21...\n+note: the lifetime `'min` as defined on the function body at 16:21...\n   --> $DIR/variance-contravariant-arg-trait-match.rs:16:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 16:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 16:27\n   --> $DIR/variance-contravariant-arg-trait-match.rs:16:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>()"}, {"sha": "e35aec4c0ce27a9b10ae2f0a93d72e89ea8ae287", "filename": "src/test/ui/variance/variance-contravariant-self-trait-match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-self-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-self-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-self-trait-match.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     impls_get::<&'min G>();\n    |\n    = note: expected type `Get`\n               found type `Get`\n-note: the lifetime 'min as defined on the function body at 10:21...\n+note: the lifetime `'min` as defined on the function body at 10:21...\n   --> $DIR/variance-contravariant-self-trait-match.rs:10:21\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 10:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 10:27\n   --> $DIR/variance-contravariant-self-trait-match.rs:10:27\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n@@ -25,12 +25,12 @@ LL |     impls_get::<&'max G>();\n    |\n    = note: expected type `Get`\n               found type `Get`\n-note: the lifetime 'min as defined on the function body at 16:21...\n+note: the lifetime `'min` as defined on the function body at 16:21...\n   --> $DIR/variance-contravariant-self-trait-match.rs:16:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 16:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 16:27\n   --> $DIR/variance-contravariant-self-trait-match.rs:16:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>()"}, {"sha": "b986edb809f6c05effdab7a6df6d8b6f6c5e739b", "filename": "src/test/ui/variance/variance-covariant-arg-object.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-object.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     v\n    |\n    = note: expected type `dyn Get<&'min i32>`\n               found type `dyn Get<&'max i32>`\n-note: the lifetime 'min as defined on the function body at 10:21...\n+note: the lifetime `'min` as defined on the function body at 10:21...\n   --> $DIR/variance-covariant-arg-object.rs:10:21\n    |\n LL | fn get_min_from_max<'min, 'max>(v: Box<dyn Get<&'max i32>>)\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 10:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 10:27\n   --> $DIR/variance-covariant-arg-object.rs:10:27\n    |\n LL | fn get_min_from_max<'min, 'max>(v: Box<dyn Get<&'max i32>>)\n@@ -25,12 +25,12 @@ LL |     v\n    |\n    = note: expected type `dyn Get<&'max i32>`\n               found type `dyn Get<&'min i32>`\n-note: the lifetime 'min as defined on the function body at 18:21...\n+note: the lifetime `'min` as defined on the function body at 18:21...\n   --> $DIR/variance-covariant-arg-object.rs:18:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>(v: Box<dyn Get<&'min i32>>)\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 18:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 18:27\n   --> $DIR/variance-covariant-arg-object.rs:18:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>(v: Box<dyn Get<&'min i32>>)"}, {"sha": "aa383fcc26280f99610de6819ce904d54be9129b", "filename": "src/test/ui/variance/variance-covariant-arg-trait-match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-trait-match.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     impls_get::<G,&'min i32>()\n    |\n    = note: expected type `Get<&'min i32>`\n               found type `Get<&'max i32>`\n-note: the lifetime 'min as defined on the function body at 10:21...\n+note: the lifetime `'min` as defined on the function body at 10:21...\n   --> $DIR/variance-covariant-arg-trait-match.rs:10:21\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 10:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 10:27\n   --> $DIR/variance-covariant-arg-trait-match.rs:10:27\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n@@ -25,12 +25,12 @@ LL |     impls_get::<G,&'max i32>()\n    |\n    = note: expected type `Get<&'max i32>`\n               found type `Get<&'min i32>`\n-note: the lifetime 'min as defined on the function body at 17:21...\n+note: the lifetime `'min` as defined on the function body at 17:21...\n   --> $DIR/variance-covariant-arg-trait-match.rs:17:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 17:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 17:27\n   --> $DIR/variance-covariant-arg-trait-match.rs:17:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>()"}, {"sha": "a25d1044d42565b80019b18b9b1908cee387e13b", "filename": "src/test/ui/variance/variance-covariant-self-trait-match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-self-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-self-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-self-trait-match.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     impls_get::<&'min G>();\n    |\n    = note: expected type `Get`\n               found type `Get`\n-note: the lifetime 'min as defined on the function body at 10:21...\n+note: the lifetime `'min` as defined on the function body at 10:21...\n   --> $DIR/variance-covariant-self-trait-match.rs:10:21\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 10:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 10:27\n   --> $DIR/variance-covariant-self-trait-match.rs:10:27\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n@@ -25,12 +25,12 @@ LL |     impls_get::<&'max G>();\n    |\n    = note: expected type `Get`\n               found type `Get`\n-note: the lifetime 'min as defined on the function body at 17:21...\n+note: the lifetime `'min` as defined on the function body at 17:21...\n   --> $DIR/variance-covariant-self-trait-match.rs:17:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 17:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 17:27\n   --> $DIR/variance-covariant-self-trait-match.rs:17:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>()"}, {"sha": "8ff1e23e8add826c9d80e291e937f8b34a2bdf6e", "filename": "src/test/ui/variance/variance-invariant-arg-object.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-object.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     v\n    |\n    = note: expected type `dyn Get<&'min i32>`\n               found type `dyn Get<&'max i32>`\n-note: the lifetime 'min as defined on the function body at 7:21...\n+note: the lifetime `'min` as defined on the function body at 7:21...\n   --> $DIR/variance-invariant-arg-object.rs:7:21\n    |\n LL | fn get_min_from_max<'min, 'max>(v: Box<dyn Get<&'max i32>>)\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 7:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 7:27\n   --> $DIR/variance-invariant-arg-object.rs:7:27\n    |\n LL | fn get_min_from_max<'min, 'max>(v: Box<dyn Get<&'max i32>>)\n@@ -25,12 +25,12 @@ LL |     v\n    |\n    = note: expected type `dyn Get<&'max i32>`\n               found type `dyn Get<&'min i32>`\n-note: the lifetime 'min as defined on the function body at 14:21...\n+note: the lifetime `'min` as defined on the function body at 14:21...\n   --> $DIR/variance-invariant-arg-object.rs:14:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>(v: Box<dyn Get<&'min i32>>)\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 14:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 14:27\n   --> $DIR/variance-invariant-arg-object.rs:14:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>(v: Box<dyn Get<&'min i32>>)"}, {"sha": "b58993737c783be9db2ace5dbf732ba0e71f0d16", "filename": "src/test/ui/variance/variance-invariant-arg-trait-match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-trait-match.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     impls_get::<G,&'min i32>()\n    |\n    = note: expected type `Get<&'min i32>`\n               found type `Get<&'max i32>`\n-note: the lifetime 'min as defined on the function body at 7:21...\n+note: the lifetime `'min` as defined on the function body at 7:21...\n   --> $DIR/variance-invariant-arg-trait-match.rs:7:21\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 7:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 7:27\n   --> $DIR/variance-invariant-arg-trait-match.rs:7:27\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n@@ -25,12 +25,12 @@ LL |     impls_get::<G,&'max i32>()\n    |\n    = note: expected type `Get<&'max i32>`\n               found type `Get<&'min i32>`\n-note: the lifetime 'min as defined on the function body at 13:21...\n+note: the lifetime `'min` as defined on the function body at 13:21...\n   --> $DIR/variance-invariant-arg-trait-match.rs:13:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 13:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 13:27\n   --> $DIR/variance-invariant-arg-trait-match.rs:13:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>()"}, {"sha": "4a1d4d28b4805ae356b48264edc9d028f51b6212", "filename": "src/test/ui/variance/variance-invariant-self-trait-match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-self-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-self-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-self-trait-match.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     impls_get::<&'min G>();\n    |\n    = note: expected type `Get`\n               found type `Get`\n-note: the lifetime 'min as defined on the function body at 7:21...\n+note: the lifetime `'min` as defined on the function body at 7:21...\n   --> $DIR/variance-invariant-self-trait-match.rs:7:21\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 7:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 7:27\n   --> $DIR/variance-invariant-self-trait-match.rs:7:27\n    |\n LL | fn get_min_from_max<'min, 'max, G>()\n@@ -25,12 +25,12 @@ LL |     impls_get::<&'max G>();\n    |\n    = note: expected type `Get`\n               found type `Get`\n-note: the lifetime 'min as defined on the function body at 13:21...\n+note: the lifetime `'min` as defined on the function body at 13:21...\n   --> $DIR/variance-invariant-self-trait-match.rs:13:21\n    |\n LL | fn get_max_from_min<'min, 'max, G>()\n    |                     ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 13:27\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 13:27\n   --> $DIR/variance-invariant-self-trait-match.rs:13:27\n    |\n LL | fn get_max_from_min<'min, 'max, G>()"}, {"sha": "618f56da512d6aa6a71765fed3bc5a408f3192f7", "filename": "src/test/ui/variance/variance-use-contravariant-struct-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-contravariant-struct-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-contravariant-struct-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-contravariant-struct-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     v\n    |\n    = note: expected type `SomeStruct<&'min ()>`\n               found type `SomeStruct<&'max ()>`\n-note: the lifetime 'min as defined on the function body at 8:8...\n+note: the lifetime `'min` as defined on the function body at 8:8...\n   --> $DIR/variance-use-contravariant-struct-1.rs:8:8\n    |\n LL | fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n    |        ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 8:13\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 8:13\n   --> $DIR/variance-use-contravariant-struct-1.rs:8:13\n    |\n LL | fn foo<'min,'max>(v: SomeStruct<&'max ()>)"}, {"sha": "0b3a8dcfc86f4ab731b0ce613a33dce286e223eb", "filename": "src/test/ui/variance/variance-use-covariant-struct-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-covariant-struct-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-covariant-struct-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-covariant-struct-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     v\n    |\n    = note: expected type `SomeStruct<&'max ()>`\n               found type `SomeStruct<&'min ()>`\n-note: the lifetime 'min as defined on the function body at 6:8...\n+note: the lifetime `'min` as defined on the function body at 6:8...\n   --> $DIR/variance-use-covariant-struct-1.rs:6:8\n    |\n LL | fn foo<'min,'max>(v: SomeStruct<&'min ()>)\n    |        ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 6:13\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 6:13\n   --> $DIR/variance-use-covariant-struct-1.rs:6:13\n    |\n LL | fn foo<'min,'max>(v: SomeStruct<&'min ()>)"}, {"sha": "31deefb535e94cafa528747f3d5e4a7bc3ae0934", "filename": "src/test/ui/variance/variance-use-invariant-struct-1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-invariant-struct-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-invariant-struct-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-use-invariant-struct-1.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -6,12 +6,12 @@ LL |     v\n    |\n    = note: expected type `SomeStruct<&'min ()>`\n               found type `SomeStruct<&'max ()>`\n-note: the lifetime 'min as defined on the function body at 8:8...\n+note: the lifetime `'min` as defined on the function body at 8:8...\n   --> $DIR/variance-use-invariant-struct-1.rs:8:8\n    |\n LL | fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n    |        ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 8:13\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 8:13\n   --> $DIR/variance-use-invariant-struct-1.rs:8:13\n    |\n LL | fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n@@ -25,12 +25,12 @@ LL |     v\n    |\n    = note: expected type `SomeStruct<&'max ()>`\n               found type `SomeStruct<&'min ()>`\n-note: the lifetime 'min as defined on the function body at 15:8...\n+note: the lifetime `'min` as defined on the function body at 15:8...\n   --> $DIR/variance-use-invariant-struct-1.rs:15:8\n    |\n LL | fn bar<'min,'max>(v: SomeStruct<&'min ()>)\n    |        ^^^^\n-note: ...does not necessarily outlive the lifetime 'max as defined on the function body at 15:13\n+note: ...does not necessarily outlive the lifetime `'max` as defined on the function body at 15:13\n   --> $DIR/variance-use-invariant-struct-1.rs:15:13\n    |\n LL | fn bar<'min,'max>(v: SomeStruct<&'min ()>)"}, {"sha": "f078431033216c67050d8fa4a663f762e8b74d08", "filename": "src/test/ui/wf/issue-48638.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fwf%2Fissue-48638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fwf%2Fissue-48638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fissue-48638.rs?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+pub trait D {}\n+pub struct DT;\n+impl D for DT {}\n+\n+pub trait A<R: D>: Sized {\n+    type AS;\n+}\n+\n+pub struct As<R: D>(R);\n+\n+pub struct AT;\n+impl<R: D> A<R> for AT {\n+    type AS = As<R>;\n+}\n+\n+#[repr(packed)]\n+struct S(<AT as A<DT>>::AS);\n+\n+fn main() {}"}, {"sha": "93d16514a50783240f65339e48ecb3275f74b805", "filename": "src/test/ui/wf/wf-static-method.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fwf%2Fwf-static-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b/src%2Ftest%2Fui%2Fwf%2Fwf-static-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-static-method.stderr?ref=446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "patch": "@@ -4,12 +4,12 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n LL |         u\n    |         ^\n    |\n-note: ...the reference is valid for the lifetime 'a as defined on the impl at 14:6...\n+note: ...the reference is valid for the lifetime `'a` as defined on the impl at 14:6...\n   --> $DIR/wf-static-method.rs:14:6\n    |\n LL | impl<'a, 'b> Foo<'a, 'b, Evil<'a, 'b>> for () {\n    |      ^^\n-note: ...but the borrowed content is only valid for the lifetime 'b as defined on the impl at 14:10\n+note: ...but the borrowed content is only valid for the lifetime `'b` as defined on the impl at 14:10\n   --> $DIR/wf-static-method.rs:14:10\n    |\n LL | impl<'a, 'b> Foo<'a, 'b, Evil<'a, 'b>> for () {\n@@ -21,12 +21,12 @@ error[E0478]: lifetime bound not satisfied\n LL |         let me = Self::make_me();\n    |                  ^^^^^^^^^^^^^\n    |\n-note: lifetime parameter instantiated with the lifetime 'b as defined on the impl at 23:10\n+note: lifetime parameter instantiated with the lifetime `'b` as defined on the impl at 23:10\n   --> $DIR/wf-static-method.rs:23:10\n    |\n LL | impl<'a, 'b> Foo<'a, 'b, ()> for IndirectEvil<'a, 'b> {\n    |          ^^\n-note: but lifetime parameter must outlive the lifetime 'a as defined on the impl at 23:6\n+note: but lifetime parameter must outlive the lifetime `'a` as defined on the impl at 23:6\n   --> $DIR/wf-static-method.rs:23:6\n    |\n LL | impl<'a, 'b> Foo<'a, 'b, ()> for IndirectEvil<'a, 'b> {\n@@ -38,12 +38,12 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n LL |         u\n    |         ^\n    |\n-note: ...the reference is valid for the lifetime 'a as defined on the impl at 31:6...\n+note: ...the reference is valid for the lifetime `'a` as defined on the impl at 31:6...\n   --> $DIR/wf-static-method.rs:31:6\n    |\n LL | impl<'a, 'b> Evil<'a, 'b> {\n    |      ^^\n-note: ...but the borrowed content is only valid for the lifetime 'b as defined on the impl at 31:10\n+note: ...but the borrowed content is only valid for the lifetime `'b` as defined on the impl at 31:10\n   --> $DIR/wf-static-method.rs:31:10\n    |\n LL | impl<'a, 'b> Evil<'a, 'b> {\n@@ -55,7 +55,7 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'b` d\n LL |     <()>::static_evil(b)\n    |     ^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'b as defined on the function body at 40:13...\n+note: first, the lifetime cannot outlive the lifetime `'b` as defined on the function body at 40:13...\n   --> $DIR/wf-static-method.rs:40:13\n    |\n LL | fn evil<'a, 'b>(b: &'b u32) -> &'a u32 {\n@@ -65,7 +65,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |     <()>::static_evil(b)\n    |                       ^\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the function body at 40:9...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 40:9...\n   --> $DIR/wf-static-method.rs:40:9\n    |\n LL | fn evil<'a, 'b>(b: &'b u32) -> &'a u32 {\n@@ -82,7 +82,7 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'b` d\n LL |     <IndirectEvil>::static_evil(b)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'b as defined on the function body at 44:22...\n+note: first, the lifetime cannot outlive the lifetime `'b` as defined on the function body at 44:22...\n   --> $DIR/wf-static-method.rs:44:22\n    |\n LL | fn indirect_evil<'a, 'b>(b: &'b u32) -> &'a u32 {\n@@ -92,7 +92,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |     <IndirectEvil>::static_evil(b)\n    |                                 ^\n-note: but, the lifetime must be valid for the lifetime 'a as defined on the function body at 44:18...\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 44:18...\n   --> $DIR/wf-static-method.rs:44:18\n    |\n LL | fn indirect_evil<'a, 'b>(b: &'b u32) -> &'a u32 {"}]}