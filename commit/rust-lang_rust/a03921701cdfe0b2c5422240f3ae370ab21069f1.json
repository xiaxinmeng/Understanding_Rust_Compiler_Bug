{"sha": "a03921701cdfe0b2c5422240f3ae370ab21069f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMzkyMTcwMWNkZmUwYjJjNTQyMjI0MGYzYWUzNzBhYjIxMDY5ZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-07T08:07:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-07T08:07:10Z"}, "message": "Auto merge of #69796 - Centril:rollup-xg85jmx, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #67741 (When encountering an Item in a pat context, point at the item def)\n - #68985 (Parse & reject postfix operators after casts)\n - #69656 (Use .next() instead of .nth(0) on iterators.)\n - #69680 (rustc_expand: Factor out `Annotatable::into_tokens` to a separate method)\n - #69690 (test(pattern): add tests for combinations of pattern features)\n - #69706 (Use subslice patterns in slice methods)\n - #69727 (Avoid using `unwrap()` in suggestions)\n - #69754 (Update deprecation version to 1.42 for Error::description)\n - #69782 (Don't redundantly repeat field names (clippy::redundant_field_names))\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7388f999dff88403fe5f26f7b9e89ac7bf4b2f04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7388f999dff88403fe5f26f7b9e89ac7bf4b2f04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a03921701cdfe0b2c5422240f3ae370ab21069f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a03921701cdfe0b2c5422240f3ae370ab21069f1", "html_url": "https://github.com/rust-lang/rust/commit/a03921701cdfe0b2c5422240f3ae370ab21069f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a03921701cdfe0b2c5422240f3ae370ab21069f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2890b37b861247de3b8c6ba2ecbcd00048c728a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2890b37b861247de3b8c6ba2ecbcd00048c728a1", "html_url": "https://github.com/rust-lang/rust/commit/2890b37b861247de3b8c6ba2ecbcd00048c728a1"}, {"sha": "709325af672a5513fb70d31b882784f698a195b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/709325af672a5513fb70d31b882784f698a195b7", "html_url": "https://github.com/rust-lang/rust/commit/709325af672a5513fb70d31b882784f698a195b7"}], "stats": {"total": 1526, "additions": 1311, "deletions": 215}, "files": [{"sha": "8efacf108fc2f160f2c28c85c6d4fe75b6712cad", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -959,7 +959,7 @@ impl<T> LinkedList<T> {\n         let it = self.head;\n         let old_len = self.len;\n \n-        DrainFilter { list: self, it: it, pred: filter, idx: 0, old_len: old_len }\n+        DrainFilter { list: self, it, pred: filter, idx: 0, old_len }\n     }\n }\n "}, {"sha": "7523d9c5ba3b133739f1f28932dc4a4bf5d3413b", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1659,7 +1659,7 @@ struct SetLenOnDrop<'a> {\n impl<'a> SetLenOnDrop<'a> {\n     #[inline]\n     fn new(len: &'a mut usize) -> Self {\n-        SetLenOnDrop { local_len: *len, len: len }\n+        SetLenOnDrop { local_len: *len, len }\n     }\n \n     #[inline]"}, {"sha": "0e12e6360da9512363d87f7631939a89161e1024", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -103,7 +103,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first(&self) -> Option<&T> {\n-        self.get(0)\n+        if let [first, ..] = self { Some(first) } else { None }\n     }\n \n     /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n@@ -121,7 +121,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first_mut(&mut self) -> Option<&mut T> {\n-        self.get_mut(0)\n+        if let [first, ..] = self { Some(first) } else { None }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -139,7 +139,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first(&self) -> Option<(&T, &[T])> {\n-        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n+        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -159,12 +159,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            let split = self.split_at_mut(1);\n-            Some((&mut split.0[0], split.1))\n-        }\n+        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -182,8 +177,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last(&self) -> Option<(&T, &[T])> {\n-        let len = self.len();\n-        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n+        if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -203,13 +197,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        let len = self.len();\n-        if len == 0 {\n-            None\n-        } else {\n-            let split = self.split_at_mut(len - 1);\n-            Some((&mut split.1[0], split.0))\n-        }\n+        if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n     /// Returns the last element of the slice, or `None` if it is empty.\n@@ -226,8 +214,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last(&self) -> Option<&T> {\n-        let last_idx = self.len().checked_sub(1)?;\n-        self.get(last_idx)\n+        if let [.., last] = self { Some(last) } else { None }\n     }\n \n     /// Returns a mutable pointer to the last item in the slice.\n@@ -245,8 +232,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last_mut(&mut self) -> Option<&mut T> {\n-        let last_idx = self.len().checked_sub(1)?;\n-        self.get_mut(last_idx)\n+        if let [.., last] = self { Some(last) } else { None }\n     }\n \n     /// Returns a reference to an element or subslice depending on the type of"}, {"sha": "7495468a05b6ccf74febb12fee681d73ab1c1760", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -55,13 +55,15 @@ pub struct Diagnostic {\n }\n \n macro_rules! diagnostic_child_methods {\n-    ($spanned:ident, $regular:ident, $level:expr) => (\n+    ($spanned:ident, $regular:ident, $level:expr) => {\n         /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `spans` and\n         /// `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $spanned<S, T>(mut self, spans: S, message: T) -> Diagnostic\n-            where S: MultiSpan, T: Into<String>\n+        where\n+            S: MultiSpan,\n+            T: Into<String>,\n         {\n             self.children.push(Diagnostic::spanned(spans, $level, message));\n             self\n@@ -74,7 +76,7 @@ macro_rules! diagnostic_child_methods {\n             self.children.push(Diagnostic::new($level, message));\n             self\n         }\n-    )\n+    };\n }\n \n /// Iterator over the children diagnostics of a `Diagnostic`.\n@@ -96,7 +98,7 @@ impl Diagnostic {\n     /// Creates a new diagnostic with the given `level` and `message`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n-        Diagnostic { level: level, message: message.into(), spans: vec![], children: vec![] }\n+        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n     }\n \n     /// Creates a new diagnostic with the given `level` and `message` pointing to\n@@ -107,12 +109,7 @@ impl Diagnostic {\n         S: MultiSpan,\n         T: Into<String>,\n     {\n-        Diagnostic {\n-            level: level,\n-            message: message.into(),\n-            spans: spans.into_spans(),\n-            children: vec![],\n-        }\n+        Diagnostic { level, message: message.into(), spans: spans.into_spans(), children: vec![] }\n     }\n \n     diagnostic_child_methods!(span_error, error, Level::Error);"}, {"sha": "e1b5ec041db060624fced447af1dd25ef26bdcff", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -192,7 +192,7 @@ impl DefPath {\n             }\n         }\n         data.reverse();\n-        DefPath { data: data, krate: krate }\n+        DefPath { data, krate }\n     }\n \n     /// Returns a string representation of the `DefPath` without"}, {"sha": "18bdecafecd3cf37f43f3f41f735c70c9d3ccc46", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1446,7 +1446,7 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n         match successor_count {\n             0 => Ok(()),\n \n-            1 => write!(fmt, \" -> {:?}\", self.successors().nth(0).unwrap()),\n+            1 => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n \n             _ => {\n                 write!(fmt, \" -> [\")?;"}, {"sha": "4f8efc1607eaa0114bdd1b190c9c00677267cacf", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -258,7 +258,7 @@ pub enum Visibility {\n \n impl<'tcx> CodegenUnit<'tcx> {\n     pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n-        CodegenUnit { name: name, items: Default::default(), size_estimate: None }\n+        CodegenUnit { name, items: Default::default(), size_estimate: None }\n     }\n \n     pub fn name(&self) -> Symbol {"}, {"sha": "a5efea9e5fa4d73c4ea7720132ca2017f4c35966", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -532,9 +532,9 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                 nested,\n             }) => tcx.lift(&substs).map(|substs| {\n                 traits::VtableGenerator(traits::VtableGeneratorData {\n-                    generator_def_id: generator_def_id,\n-                    substs: substs,\n-                    nested: nested,\n+                    generator_def_id,\n+                    substs,\n+                    nested,\n                 })\n             }),\n             traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {"}, {"sha": "48ef81c1d5bf7590086cb62713341d916ff66dd5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -2256,22 +2256,22 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut { ty: ty, mutbl: hir::Mutability::Mut })\n+        self.mk_ref(r, TypeAndMut { ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut { ty: ty, mutbl: hir::Mutability::Not })\n+        self.mk_ref(r, TypeAndMut { ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]\n     pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut { ty: ty, mutbl: hir::Mutability::Mut })\n+        self.mk_ptr(TypeAndMut { ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut { ty: ty, mutbl: hir::Mutability::Not })\n+        self.mk_ptr(TypeAndMut { ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]\n@@ -2393,7 +2393,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_ty_param(self, index: u32, name: Symbol) -> Ty<'tcx> {\n-        self.mk_ty(Param(ParamTy { index, name: name }))\n+        self.mk_ty(Param(ParamTy { index, name }))\n     }\n \n     #[inline]"}, {"sha": "445df76cd32beac1adbdb14d4f50791ea6fc1500", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -241,7 +241,7 @@ impl<'tcx> Instance<'tcx> {\n             def_id,\n             substs\n         );\n-        Instance { def: InstanceDef::Item(def_id), substs: substs }\n+        Instance { def: InstanceDef::Item(def_id), substs }\n     }\n \n     pub fn mono(tcx: TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {"}, {"sha": "7bcd63b965534187a00acb4b318abf50a104babd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -370,7 +370,7 @@ pub trait DefIdTree: Copy {\n \n impl<'tcx> DefIdTree for TyCtxt<'tcx> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n-        self.def_key(id).parent.map(|index| DefId { index: index, ..id })\n+        self.def_key(id).parent.map(|index| DefId { index, ..id })\n     }\n }\n \n@@ -2227,7 +2227,7 @@ impl ReprOptions {\n         if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.def_path_str(did))) {\n             flags.insert(ReprFlags::IS_LINEAR);\n         }\n-        ReprOptions { int: size, align: max_align, pack: min_pack, flags: flags }\n+        ReprOptions { int: size, align: max_align, pack: min_pack, flags }\n     }\n \n     #[inline]"}, {"sha": "cbaabd8e1f1373a2c4ae788a2ad36703ece93239", "filename": "src/librustc/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -34,10 +34,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !value.has_projections() {\n             value\n         } else {\n-            value.fold_with(&mut NormalizeAfterErasingRegionsFolder {\n-                tcx: self,\n-                param_env: param_env,\n-            })\n+            value.fold_with(&mut NormalizeAfterErasingRegionsFolder { tcx: self, param_env })\n         }\n     }\n "}, {"sha": "10f27bf66f38396deaaf5bffb30bb8a12b648cc2", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -287,7 +287,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n             let substs = relate_substs(relation, None, a.substs, b.substs)?;\n-            Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n+            Ok(ty::TraitRef { def_id: a.def_id, substs })\n         }\n     }\n }\n@@ -303,7 +303,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n             let substs = relate_substs(relation, None, a.substs, b.substs)?;\n-            Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs: substs })\n+            Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs })\n         }\n     }\n }"}, {"sha": "47bf7822b1f552be14615d5133ad5105594a0c4b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1193,7 +1193,7 @@ pub struct ParamTy {\n \n impl<'tcx> ParamTy {\n     pub fn new(index: u32, name: Symbol) -> ParamTy {\n-        ParamTy { index, name: name }\n+        ParamTy { index, name }\n     }\n \n     pub fn for_self() -> ParamTy {"}, {"sha": "fcebedb2601c2d0775883807737d62479bc2d1a8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -357,7 +357,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut dtor_did = None;\n         let ty = self.type_of(adt_did);\n         self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n-            if let Some(item) = self.associated_items(impl_did).in_definition_order().nth(0) {\n+            if let Some(item) = self.associated_items(impl_did).in_definition_order().next() {\n                 if validate(self, impl_did).is_ok() {\n                     dtor_did = Some(item.def_id);\n                 }"}, {"sha": "e0c619fcbd3789176fe641258533a99fdf0f7893", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -482,7 +482,7 @@ impl<'a> TraitDef<'a> {\n                         })\n                         .cloned(),\n                 );\n-                push(Annotatable::Item(P(ast::Item { attrs: attrs, ..(*newitem).clone() })))\n+                push(Annotatable::Item(P(ast::Item { attrs, ..(*newitem).clone() })))\n             }\n             _ => {\n                 // Non-Item derive is an error, but it should have been"}, {"sha": "470a2bb8e1ea5842d145324985ee000fb3f49606", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -148,7 +148,7 @@ impl LlvmType for CastTarget {\n             .prefix\n             .iter()\n             .flat_map(|option_kind| {\n-                option_kind.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.llvm_type(cx))\n+                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk }.llvm_type(cx))\n             })\n             .chain((0..rest_count).map(|_| rest_ll_unit))\n             .collect();"}, {"sha": "f15e626c2783b0593cd596de1bf4aad828bcea4e", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::ast::{self, Attribute, Name, NodeId, PatKind};\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{self, TokenStream};\n+use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n use rustc_data_structures::fx::FxHashMap;\n@@ -118,6 +118,31 @@ impl Annotatable {\n         }\n     }\n \n+    crate fn into_tokens(self) -> TokenStream {\n+        // `Annotatable` can be converted into tokens directly, but we\n+        // are packing it into a nonterminal as a piece of AST to make\n+        // the produced token stream look nicer in pretty-printed form.\n+        let nt = match self {\n+            Annotatable::Item(item) => token::NtItem(item),\n+            Annotatable::TraitItem(item) | Annotatable::ImplItem(item) => {\n+                token::NtItem(P(item.and_then(ast::AssocItem::into_item)))\n+            }\n+            Annotatable::ForeignItem(item) => {\n+                token::NtItem(P(item.and_then(ast::ForeignItem::into_item)))\n+            }\n+            Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n+            Annotatable::Expr(expr) => token::NtExpr(expr),\n+            Annotatable::Arm(..)\n+            | Annotatable::Field(..)\n+            | Annotatable::FieldPat(..)\n+            | Annotatable::GenericParam(..)\n+            | Annotatable::Param(..)\n+            | Annotatable::StructField(..)\n+            | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n+        };\n+        TokenTree::token(token::Interpolated(Lrc::new(nt)), DUMMY_SP).into()\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,"}, {"sha": "effa89e8bfb21736080ffc31e8ddd41d2ea19205", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -10,12 +10,11 @@ use rustc_ast::ast::{ItemKind, MacArgs, MacStmtStyle, StmtKind};\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::map_in_place::MapInPlace;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::Features;\n use rustc_parse::configure;\n@@ -668,38 +667,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    // `Annotatable` can be converted into tokens directly, but we are packing it\n-                    // into a nonterminal as a piece of AST to make the produced token stream\n-                    // look nicer in pretty-printed form. This may be no longer necessary.\n-                    let item_tok = TokenTree::token(\n-                        token::Interpolated(Lrc::new(match item {\n-                            Annotatable::Item(item) => token::NtItem(item),\n-                            Annotatable::TraitItem(item) | Annotatable::ImplItem(item) => {\n-                                token::NtItem(P(item.and_then(ast::AssocItem::into_item)))\n-                            }\n-                            Annotatable::ForeignItem(item) => {\n-                                token::NtItem(P(item.and_then(ast::ForeignItem::into_item)))\n-                            }\n-                            Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n-                            Annotatable::Expr(expr) => token::NtExpr(expr),\n-                            Annotatable::Arm(..)\n-                            | Annotatable::Field(..)\n-                            | Annotatable::FieldPat(..)\n-                            | Annotatable::GenericParam(..)\n-                            | Annotatable::Param(..)\n-                            | Annotatable::StructField(..)\n-                            | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n-                        })),\n-                        DUMMY_SP,\n-                    )\n-                    .into();\n-                    let item = attr.unwrap_normal_item();\n-                    if let MacArgs::Eq(..) = item.args {\n+                    let tokens = item.into_tokens();\n+                    let attr_item = attr.unwrap_normal_item();\n+                    if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n                     }\n                     let tok_result =\n-                        expander.expand(self.cx, span, item.args.inner_tokens(), item_tok);\n-                    self.parse_ast_fragment(tok_result, fragment_kind, &item.path, span)\n+                        expander.expand(self.cx, span, attr_item.args.inner_tokens(), tokens);\n+                    self.parse_ast_fragment(tok_result, fragment_kind, &attr_item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match validate_attr::parse_meta(self.cx.parse_sess, &attr) {"}, {"sha": "04f5b03c0e15cb26eae880e99d5ac5b5e7fe10d1", "filename": "src/librustc_infer/infer/at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n         T: ToTrace<'tcx>,\n     {\n         let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n-        Trace { at: self, trace: trace, a_is_expected }\n+        Trace { at: self, trace, a_is_expected }\n     }\n }\n "}, {"sha": "bb0c124a1892dffe39120a82e68a4a44c6b7aaf6", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -19,7 +19,7 @@ impl<'combine, 'infcx, 'tcx> Equate<'combine, 'infcx, 'tcx> {\n         fields: &'combine mut CombineFields<'infcx, 'tcx>,\n         a_is_expected: bool,\n     ) -> Equate<'combine, 'infcx, 'tcx> {\n-        Equate { fields: fields, a_is_expected: a_is_expected }\n+        Equate { fields, a_is_expected }\n     }\n }\n "}, {"sha": "cab632935fd8eace53218592333286d34dbfb3d5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -77,11 +77,11 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             if found_anon_region {\n                                 let is_first = index == 0;\n                                 Some(AnonymousParamInfo {\n-                                    param: param,\n+                                    param,\n                                     param_ty: new_param_ty,\n-                                    param_ty_span: param_ty_span,\n-                                    bound_region: bound_region,\n-                                    is_first: is_first,\n+                                    param_ty_span,\n+                                    bound_region,\n+                                    is_first,\n                                 })\n                             } else {\n                                 None"}, {"sha": "8b26bcef5730459786740e0f52f2f9ebefbade33", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -18,7 +18,7 @@ impl<'combine, 'infcx, 'tcx> Glb<'combine, 'infcx, 'tcx> {\n         fields: &'combine mut CombineFields<'infcx, 'tcx>,\n         a_is_expected: bool,\n     ) -> Glb<'combine, 'infcx, 'tcx> {\n-        Glb { fields: fields, a_is_expected: a_is_expected }\n+        Glb { fields, a_is_expected }\n     }\n }\n "}, {"sha": "20ddeec68503aa9f9a6ab57fd3a03d2f7240bb56", "filename": "src/librustc_infer/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flub.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -18,7 +18,7 @@ impl<'combine, 'infcx, 'tcx> Lub<'combine, 'infcx, 'tcx> {\n         fields: &'combine mut CombineFields<'infcx, 'tcx>,\n         a_is_expected: bool,\n     ) -> Lub<'combine, 'infcx, 'tcx> {\n-        Lub { fields: fields, a_is_expected: a_is_expected }\n+        Lub { fields, a_is_expected }\n     }\n }\n "}, {"sha": "6ebe3f575976041781f949a37602b05c68ce6abd", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -85,7 +85,7 @@ impl<'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n         let mut regions = FxHashSet::default();\n         regions.insert(initial_region);\n-        TaintSet { directions: directions, regions: regions }\n+        TaintSet { directions, regions }\n     }\n \n     fn fixed_point("}, {"sha": "868b95043796b8b563e39727229ecb818e36bf03", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -766,7 +766,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         b: Region<'tcx>,\n         origin: SubregionOrigin<'tcx>,\n     ) -> Region<'tcx> {\n-        let vars = TwoRegions { a: a, b: b };\n+        let vars = TwoRegions { a, b };\n         if let Some(&c) = self.combine_map(t).get(&vars) {\n             return tcx.mk_region(ReVar(c));\n         }"}, {"sha": "562fbc246f7ee9b700e4cd542c483b382093bb1a", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -160,7 +160,7 @@ pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: &T) -> Fix\n where\n     T: TypeFoldable<'tcx>,\n {\n-    let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n+    let mut full_resolver = FullTypeResolver { infcx, err: None };\n     let result = value.fold_with(&mut full_resolver);\n     match full_resolver.err {\n         None => Ok(result),"}, {"sha": "f6fc38b5358871d50a3c0e620e1c2daf683cc013", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -19,7 +19,7 @@ impl<'combine, 'infcx, 'tcx> Sub<'combine, 'infcx, 'tcx> {\n         f: &'combine mut CombineFields<'infcx, 'tcx>,\n         a_is_expected: bool,\n     ) -> Sub<'combine, 'infcx, 'tcx> {\n-        Sub { fields: f, a_is_expected: a_is_expected }\n+        Sub { fields: f, a_is_expected }\n     }\n \n     fn with_expected_switched<R, F: FnOnce(&mut Self) -> R>(&mut self, f: F) -> R {"}, {"sha": "800f8e91a78016ef1ae4a15ab1a0be7602483eb0", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -619,7 +619,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n         obligation: PredicateObligation<'tcx>,\n         code: FulfillmentErrorCode<'tcx>,\n     ) -> FulfillmentError<'tcx> {\n-        FulfillmentError { obligation: obligation, code: code, points_at_arg_span: false }\n+        FulfillmentError { obligation, code, points_at_arg_span: false }\n     }\n }\n "}, {"sha": "78483cf6577dec47eda044cb6f87ca8d19098a5e", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -403,7 +403,7 @@ pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n \n impl<'tcx, T> Normalized<'tcx, T> {\n     pub fn with<U>(self, value: U) -> Normalized<'tcx, U> {\n-        Normalized { value: value, obligations: self.obligations }\n+        Normalized { value, obligations: self.obligations }\n     }\n }\n \n@@ -1291,7 +1291,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n                 substs: trait_ref.substs,\n                 item_def_id: obligation.predicate.item_def_id,\n             },\n-            ty: ty,\n+            ty,\n         }\n     });\n "}, {"sha": "c0d8f3cfd4f86611747e7934a3a94f50fb9c7528", "filename": "src/librustc_infer/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fselect.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -2923,7 +2923,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n         ));\n \n-        Ok(VtableClosureData { closure_def_id, substs: substs, nested: obligations })\n+        Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n     }\n \n     /// In the case of closure types and fn pointers,"}, {"sha": "cd4595e76ccec05290006ac934da5f3887e197ef", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -55,7 +55,7 @@ struct PredicateSet<'tcx> {\n \n impl PredicateSet<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx: tcx, set: Default::default() }\n+        Self { tcx, set: Default::default() }\n     }\n \n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {"}, {"sha": "e0db2ae64ff211a048f20874bee92125ebbce251", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -377,10 +377,10 @@ impl<'s> LintLevelsBuilder<'s> {\n         let prev = self.cur;\n         if !specs.is_empty() {\n             self.cur = self.sets.list.len() as u32;\n-            self.sets.list.push(LintSet::Node { specs: specs, parent: prev });\n+            self.sets.list.push(LintSet::Node { specs, parent: prev });\n         }\n \n-        BuilderPush { prev: prev, changed: prev != self.cur }\n+        BuilderPush { prev, changed: prev != self.cur }\n     }\n \n     /// Called after `push` when the scope of a set of attributes are exited."}, {"sha": "7624b1d562f08e43b4527330eee45241f22586d5", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -493,7 +493,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             edition: tcx.sess.edition(),\n             has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n             has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n-            has_default_lib_allocator: has_default_lib_allocator,\n+            has_default_lib_allocator,\n             plugin_registrar_fn: tcx.plugin_registrar_fn(LOCAL_CRATE).map(|id| id.index),\n             proc_macro_decls_static: if is_proc_macro {\n                 let id = tcx.proc_macro_decls_static(LOCAL_CRATE).unwrap();"}, {"sha": "fefef69d63cbde5c7cddb020c12bbd2255573dbd", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -175,7 +175,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n                 self.append_place_to_string(\n-                    PlaceRef { local: local, projection: &[] },\n+                    PlaceRef { local, projection: &[] },\n                     buf,\n                     autoderef,\n                     &including_downcast,"}, {"sha": "675463cb1c1f98ab85916b4ea8f27554289c20be", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -140,7 +140,7 @@ impl<N: Idx> LivenessValues<N> {\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n     crate fn new(elements: Rc<RegionValueElements>) -> Self {\n-        Self { points: SparseBitMatrix::new(elements.num_points), elements: elements }\n+        Self { points: SparseBitMatrix::new(elements.num_points), elements }\n     }\n \n     /// Iterate through each region that has a value in this set."}, {"sha": "67b00e9ffdd5f2f0366afabebcf62a69d08bf2a7", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -486,7 +486,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             defining_ty,\n             unnormalized_output_ty,\n             unnormalized_input_tys,\n-            yield_ty: yield_ty,\n+            yield_ty,\n         }\n     }\n "}, {"sha": "a9ef7ef6c528a2a93aa79472e0de2de4470a6b33", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -72,7 +72,7 @@ pub struct Edge {\n \n fn outgoing(body: &Body<'_>, bb: BasicBlock) -> Vec<Edge> {\n     (0..body[bb].terminator().successors().count())\n-        .map(|index| Edge { source: bb, index: index })\n+        .map(|index| Edge { source: bb, index })\n         .collect()\n }\n "}, {"sha": "7e36a3cf2bfec646b4fb471c0e8a412c354a6d69", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -474,7 +474,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     }\n \n     fn record_move(&mut self, place: &Place<'tcx>, path: MovePathIndex) {\n-        let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n+        let move_out = self.builder.data.moves.push(MoveOut { path, source: self.loc });\n         debug!(\n             \"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n             self.loc, place, move_out, path"}, {"sha": "fff9c740f7e493ab944b1e607380b0dae6d933d5", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -655,7 +655,7 @@ where\n             }\n             local => PlaceTy {\n                 // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local { frame: self.cur_frame(), local: local },\n+                place: Place::Local { frame: self.cur_frame(), local },\n                 layout: self.layout_of_local(self.frame(), local, None)?,\n             },\n         };"}, {"sha": "7177bf726d4033b3caf36347b294dcb4be7ed85f", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -13,7 +13,7 @@ pub fn custom_coerce_unsize_info<'tcx>(\n     let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n     let trait_ref = ty::Binder::bind(ty::TraitRef {\n-        def_id: def_id,\n+        def_id,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty.into()]),\n     });\n "}, {"sha": "45cecc1b125d88525d0087e48dd725c045bf0ed8", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -75,8 +75,8 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         {\n             let source_info = SourceInfo {\n                 scope: OUTERMOST_SOURCE_SCOPE,\n-                span: span, // FIXME: Consider using just the span covering the function\n-                            // argument declaration.\n+                span, // FIXME: Consider using just the span covering the function\n+                      // argument declaration.\n             };\n             // Gather all arguments, skip return value.\n             let places = local_decls"}, {"sha": "d060a0eab3db05ed9885d6d92e0dfc057ff8bb2a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -506,7 +506,7 @@ fn locals_live_across_suspend_points(\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n-            let loc = Location { block: block, statement_index: data.statements.len() };\n+            let loc = Location { block, statement_index: data.statements.len() };\n \n             if !movable {\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows."}, {"sha": "22ac3410a75ab7d3458ee81a3aa88257adf94e22", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n-        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+        let mdpe = MoveDataParamEnv { move_data, param_env };\n \n         let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n             .into_engine(tcx, body, def_id)"}, {"sha": "597d3f0237a71dc20a2acd61eed75a40e167cf41", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n         };\n \n         let first_succ = {\n-            if let Some(&first_succ) = terminator.successors().nth(0) {\n+            if let Some(&first_succ) = terminator.successors().next() {\n                 if terminator.successors().all(|s| *s == first_succ) {\n                     let count = terminator.successors().count();\n                     self.pred_count[first_succ] -= (count - 1) as u32;"}, {"sha": "0b303e230e2875c90b706dfae34318092568477c", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -549,7 +549,7 @@ where\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n         let tcx = self.tcx();\n         let drop_trait = tcx.lang_items().drop_trait().unwrap();\n-        let drop_fn = tcx.associated_items(drop_trait).in_definition_order().nth(0).unwrap();\n+        let drop_fn = tcx.associated_items(drop_trait).in_definition_order().next().unwrap();\n         let ty = self.place_ty(self.place);\n         let substs = tcx.mk_substs_trait(ty, &[]);\n \n@@ -872,7 +872,7 @@ where\n         debug!(\"drop_flag_reset_block({:?},{:?})\", self, mode);\n \n         let block = self.new_block(unwind, TerminatorKind::Goto { target: succ });\n-        let block_start = Location { block: block, statement_index: 0 };\n+        let block_start = Location { block, statement_index: 0 };\n         self.elaborator.clear_drop_flag(block_start, self.path, mode);\n         block\n     }\n@@ -921,7 +921,7 @@ where\n \n         let call = TerminatorKind::Call {\n             func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-            args: args,\n+            args,\n             destination: Some((unit_temp, target)),\n             cleanup: None,\n             from_hir_call: false,"}, {"sha": "1fd5f3c4395873e105aa40a63929c419fd66e127", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -297,7 +297,7 @@ where\n     writeln!(w, \"{}{:?}{}: {{\", INDENT, block, cleanup_text)?;\n \n     // List of statements in the middle.\n-    let mut current_location = Location { block: block, statement_index: 0 };\n+    let mut current_location = Location { block, statement_index: 0 };\n     for statement in &data.statements {\n         extra_data(PassWhere::BeforeLocation(current_location), w)?;\n         let indented_body = format!(\"{0}{0}{1:?};\", INDENT, statement);"}, {"sha": "80fa0c44860e4ecc4449df16de4412670ff82674", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // value being matched, taking the variance field into account.\n                 candidate.ascriptions.push(Ascription {\n                     span: user_ty_span,\n-                    user_ty: user_ty,\n+                    user_ty,\n                     source: match_pair.place,\n                     variance,\n                 });"}, {"sha": "d23a2708dc478d2a2bdaf7a101e810757734886b", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -64,10 +64,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let len = prefix.len() + suffix.len();\n                 let op = if slice.is_some() { BinOp::Ge } else { BinOp::Eq };\n-                Test {\n-                    span: match_pair.pattern.span,\n-                    kind: TestKind::Len { len: len as u64, op: op },\n-                }\n+                Test { span: match_pair.pattern.span, kind: TestKind::Len { len: len as u64, op } }\n             }\n \n             PatKind::Or { .. } => bug!(\"or-patterns should have already been handled\"),"}, {"sha": "b60a637471e131e731589ae0835839d449709698", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -418,7 +418,7 @@ struct GuardFrameLocal {\n \n impl GuardFrameLocal {\n     fn new(id: hir::HirId, _binding_mode: BindingMode) -> Self {\n-        GuardFrameLocal { id: id }\n+        GuardFrameLocal { id }\n     }\n }\n "}, {"sha": "8d7225c8c7b51ef3a883014dcf5106b91b173bfa", "filename": "src/librustc_mir_build/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -84,7 +84,7 @@ fn mirror_stmts<'a, 'tcx>(\n \n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     kind: StmtKind::Let {\n-                        remainder_scope: remainder_scope,\n+                        remainder_scope,\n                         init_scope: region::Scope {\n                             id: hir_id.local_id,\n                             data: region::ScopeData::Node,"}, {"sha": "ecf0bed6a6e31b7f65185d5ace34e73afd916fb8", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1000,7 +1000,7 @@ impl<'tcx> Constructor<'tcx> {\n                         PatKind::Leaf { subpatterns }\n                     }\n                 }\n-                ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n+                ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n                 _ => PatKind::Wild,\n             },"}, {"sha": "505c6139ad63bf2e616ab04551f2a5bf1de4c75d", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -544,8 +544,8 @@ impl<'a> Parser<'a> {\n         // Save the state of the parser before parsing type normally, in case there is a\n         // LessThan comparison after this cast.\n         let parser_snapshot_before_type = self.clone();\n-        match self.parse_ty_no_plus() {\n-            Ok(rhs) => Ok(mk_expr(self, rhs)),\n+        let cast_expr = match self.parse_ty_no_plus() {\n+            Ok(rhs) => mk_expr(self, rhs),\n             Err(mut type_err) => {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n@@ -599,17 +599,70 @@ impl<'a> Parser<'a> {\n                             )\n                             .emit();\n \n-                        Ok(expr)\n+                        expr\n                     }\n                     Err(mut path_err) => {\n                         // Couldn't parse as a path, return original error and parser state.\n                         path_err.cancel();\n                         mem::replace(self, parser_snapshot_after_type);\n-                        Err(type_err)\n+                        return Err(type_err);\n                     }\n                 }\n             }\n-        }\n+        };\n+\n+        self.parse_and_disallow_postfix_after_cast(cast_expr)\n+    }\n+\n+    /// Parses a postfix operators such as `.`, `?`, or index (`[]`) after a cast,\n+    /// then emits an error and returns the newly parsed tree.\n+    /// The resulting parse tree for `&x as T[0]` has a precedence of `((&x) as T)[0]`.\n+    fn parse_and_disallow_postfix_after_cast(\n+        &mut self,\n+        cast_expr: P<Expr>,\n+    ) -> PResult<'a, P<Expr>> {\n+        // Save the memory location of expr before parsing any following postfix operators.\n+        // This will be compared with the memory location of the output expression.\n+        // If they different we can assume we parsed another expression because the existing expression is not reallocated.\n+        let addr_before = &*cast_expr as *const _ as usize;\n+        let span = cast_expr.span;\n+        let with_postfix = self.parse_dot_or_call_expr_with_(cast_expr, span)?;\n+        let changed = addr_before != &*with_postfix as *const _ as usize;\n+\n+        // Check if an illegal postfix operator has been added after the cast.\n+        // If the resulting expression is not a cast, or has a different memory location, it is an illegal postfix operator.\n+        if !matches!(with_postfix.kind, ExprKind::Cast(_, _) | ExprKind::Type(_, _)) || changed {\n+            let msg = format!(\n+                \"casts cannot be followed by {}\",\n+                match with_postfix.kind {\n+                    ExprKind::Index(_, _) => \"indexing\",\n+                    ExprKind::Try(_) => \"?\",\n+                    ExprKind::Field(_, _) => \"a field access\",\n+                    ExprKind::MethodCall(_, _) => \"a method call\",\n+                    ExprKind::Call(_, _) => \"a function call\",\n+                    ExprKind::Await(_) => \"`.await`\",\n+                    _ => unreachable!(\"parse_dot_or_call_expr_with_ shouldn't produce this\"),\n+                }\n+            );\n+            let mut err = self.struct_span_err(span, &msg);\n+            // If type ascription is \"likely an error\", the user will already be getting a useful\n+            // help message, and doesn't need a second.\n+            if self.last_type_ascription.map_or(false, |last_ascription| last_ascription.1) {\n+                self.maybe_annotate_with_ascription(&mut err, false);\n+            } else {\n+                let suggestions = vec![\n+                    (span.shrink_to_lo(), \"(\".to_string()),\n+                    (span.shrink_to_hi(), \")\".to_string()),\n+                ];\n+                err.multipart_suggestion(\n+                    \"try surrounding the expression in parentheses\",\n+                    suggestions,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n+        };\n+        Ok(with_postfix)\n     }\n \n     fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n@@ -955,7 +1008,7 @@ impl<'a> Parser<'a> {\n         };\n         let kind = if es.len() == 1 && !trailing_comma {\n             // `(e)` is parenthesized `e`.\n-            ExprKind::Paren(es.into_iter().nth(0).unwrap())\n+            ExprKind::Paren(es.into_iter().next().unwrap())\n         } else {\n             // `(e,)` is a tuple with only one field, `e`.\n             ExprKind::Tup(es)"}, {"sha": "4c041fd669d67178f22b62548d5b08933ae9dbad", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -479,7 +479,7 @@ impl<'a> Parser<'a> {\n         // Here, `(pat,)` is a tuple pattern.\n         // For backward compatibility, `(..)` is a tuple pattern as well.\n         Ok(if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n-            PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+            PatKind::Paren(fields.into_iter().next().unwrap())\n         } else {\n             PatKind::Tuple(fields)\n         })"}, {"sha": "c4469331b66694fdd91a06ed5d5a8b738c416c58", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -198,7 +198,7 @@ impl<'a> Parser<'a> {\n         })?;\n \n         if ts.len() == 1 && !trailing {\n-            let ty = ts.into_iter().nth(0).unwrap().into_inner();\n+            let ty = ts.into_iter().next().unwrap().into_inner();\n             let maybe_bounds = allow_plus == AllowPlus::Yes && self.token.is_like_plus();\n             match ty.kind {\n                 // `(TY_BOUND_NOPAREN) + BOUND + ...`."}, {"sha": "6b5e927214f5a74b9b34092da5e9fa4722923100", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -2102,7 +2102,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 .is_ok()\n             {\n                 let def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id: def_id, import_ids: smallvec![] });\n+                found_traits.push(TraitCandidate { def_id, import_ids: smallvec![] });\n             }\n         }\n "}, {"sha": "7281173e9db7842d41fa3faa3054e968d8472436", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1032,13 +1032,13 @@ struct Shadower {\n }\n \n fn original_label(span: Span) -> Original {\n-    Original { kind: ShadowKind::Label, span: span }\n+    Original { kind: ShadowKind::Label, span }\n }\n fn shadower_label(span: Span) -> Shadower {\n-    Shadower { kind: ShadowKind::Label, span: span }\n+    Shadower { kind: ShadowKind::Label, span }\n }\n fn original_lifetime(span: Span) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span: span }\n+    Original { kind: ShadowKind::Lifetime, span }\n }\n fn shadower_lifetime(param: &hir::GenericParam<'_>) -> Shadower {\n     Shadower { kind: ShadowKind::Lifetime, span: param.span }\n@@ -1347,7 +1347,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n-            map: map,\n+            map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,"}, {"sha": "ec251c224b6907ae258ae9513e331a806c5167a0", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -334,7 +334,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                                     Some(_) => ImplKind::Direct,\n                                     None => ImplKind::Inherent,\n                                 },\n-                                span: span,\n+                                span,\n                                 value: String::new(),\n                                 parent: None,\n                                 children: items"}, {"sha": "2005366f83986da3b91a9e70561f68d45beb2dee", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -793,7 +793,7 @@ impl Sig for ast::ForeignItem {\n                 text.push_str(&name);\n                 text.push(';');\n \n-                Ok(Signature { text: text, defs: defs, refs: vec![] })\n+                Ok(Signature { text, defs, refs: vec![] })\n             }\n             ast::ForeignItemKind::Macro(..) => Err(\"macro\"),\n         }"}, {"sha": "c263da69c3521131cdb846bbf0a02c4dc650c129", "filename": "src/librustc_session/code_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_session%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_session%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fcode_stats.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -70,7 +70,7 @@ impl CodeStats {\n             type_description: type_desc.to_string(),\n             align: align.bytes(),\n             overall_size: overall_size.bytes(),\n-            packed: packed,\n+            packed,\n             opt_discr_size: opt_discr_size.map(|s| s.bytes()),\n             variants,\n         };"}, {"sha": "66cdf46bd4e5febcef386a39b33e75b63562a4d3", "filename": "src/librustc_span/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_span%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_span%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fdef_id.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -130,7 +130,7 @@ impl DefId {\n     /// Makes a local `DefId` from the given `DefIndex`.\n     #[inline]\n     pub fn local(index: DefIndex) -> DefId {\n-        DefId { krate: LOCAL_CRATE, index: index }\n+        DefId { krate: LOCAL_CRATE, index }\n     }\n \n     #[inline]"}, {"sha": "cd2d2c4c3d768c843a6cb7263f0921a046e832df", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -620,7 +620,7 @@ impl SourceMap {\n     /// if no character could be found or if an error occurred while retrieving the code snippet.\n     pub fn span_extend_to_prev_char(&self, sp: Span, c: char) -> Span {\n         if let Ok(prev_source) = self.span_to_prev_source(sp) {\n-            let prev_source = prev_source.rsplit(c).nth(0).unwrap_or(\"\").trim_start();\n+            let prev_source = prev_source.rsplit(c).next().unwrap_or(\"\").trim_start();\n             if !prev_source.is_empty() && !prev_source.contains('\\n') {\n                 return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n             }\n@@ -640,7 +640,7 @@ impl SourceMap {\n         for ws in &[\" \", \"\\t\", \"\\n\"] {\n             let pat = pat.to_owned() + ws;\n             if let Ok(prev_source) = self.span_to_prev_source(sp) {\n-                let prev_source = prev_source.rsplit(&pat).nth(0).unwrap_or(\"\").trim_start();\n+                let prev_source = prev_source.rsplit(&pat).next().unwrap_or(\"\").trim_start();\n                 if !prev_source.is_empty() && (!prev_source.contains('\\n') || accept_newlines) {\n                     return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n                 }\n@@ -655,7 +655,7 @@ impl SourceMap {\n     pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n         match self.span_to_snippet(sp) {\n             Ok(snippet) => {\n-                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_end();\n+                let snippet = snippet.split(c).next().unwrap_or(\"\").trim_end();\n                 if !snippet.is_empty() && !snippet.contains('\\n') {\n                     sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n                 } else {"}, {"sha": "8b1ba57e8194561e09e45422891c1ca38aaf0bf5", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -47,7 +47,7 @@ pub fn resolve_instance<'tcx>(\n                 }\n             }\n         };\n-        Some(Instance { def: def, substs: substs })\n+        Some(Instance { def, substs })\n     };\n     debug!(\"resolve(def_id={:?}, substs={:?}) = {:?}\", def_id, substs, result);\n     result"}, {"sha": "8689db1b1eb56dddecedc8996d439f706abe5a33", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -675,7 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // The `Future` trait has only one associted item, `Output`,\n         // so check that this is what we see.\n         let output_assoc_item =\n-            self.tcx.associated_items(future_trait).in_definition_order().nth(0).unwrap().def_id;\n+            self.tcx.associated_items(future_trait).in_definition_order().next().unwrap().def_id;\n         if output_assoc_item != predicate.projection_ty.item_def_id {\n             span_bug!(\n                 cause_span,"}, {"sha": "7570d9d4b28ac7ceb81bdbf798fd787a18c2787e", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -404,7 +404,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let needs = Needs::maybe_mut_place(mutbl);\n         let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n \n-        let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n+        let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n             _ if tm.ty.references_error() => self.tcx.types.err,\n             hir::BorrowKind::Raw => {"}, {"sha": "084601fbde1d437ec0f45d9785d546badbc2e524", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -547,10 +547,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 (&self_ty.kind, parent_pred)\n                             {\n                                 if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n-                                    let id = self.tcx.hir().as_local_hir_id(def.did).unwrap();\n-                                    let node = self.tcx.hir().get(id);\n+                                    let node = self\n+                                        .tcx\n+                                        .hir()\n+                                        .as_local_hir_id(def.did)\n+                                        .map(|id| self.tcx.hir().get(id));\n                                     match node {\n-                                        hir::Node::Item(hir::Item { kind, .. }) => {\n+                                        Some(hir::Node::Item(hir::Item { kind, .. })) => {\n                                             if let Some(g) = kind.generics() {\n                                                 let key = match &g.where_clause.predicates[..] {\n                                                     [.., pred] => {"}, {"sha": "60c5bcbb78df553e7b683844b4d58262a8bf961f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -4234,7 +4234,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let substs = self.fresh_substs_for_item(span, did);\n         let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n-        TypeAndSubsts { substs: substs, ty: substd_ty }\n+        TypeAndSubsts { substs, ty: substd_ty }\n     }\n \n     /// Unifies the output type with the expected type early, for more coercions\n@@ -5244,7 +5244,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .tcx\n                     .associated_items(future_trait)\n                     .in_definition_order()\n-                    .nth(0)\n+                    .next()\n                     .unwrap()\n                     .def_id;\n                 let predicate ="}, {"sha": "dd4b407ac52cbb22f18de775e20168261e0f395d", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 79, "deletions": 24, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -63,6 +63,22 @@ struct TopInfo<'tcx> {\n     ///              found type `std::result::Result<_, _>`\n     /// ```\n     span: Option<Span>,\n+    /// This refers to the parent pattern. Used to provide extra diagnostic information on errors.\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///   --> $DIR/const-in-struct-pat.rs:8:17\n+    ///   |\n+    /// L | struct f;\n+    ///   | --------- unit struct defined here\n+    /// ...\n+    /// L |     let Thing { f } = t;\n+    ///   |                 ^\n+    ///   |                 |\n+    ///   |                 expected struct `std::string::String`, found struct `f`\n+    ///   |                 `f` is interpreted as a unit struct, not a new binding\n+    ///   |                 help: bind the struct field to a different name instead: `f: other_f`\n+    /// ```\n+    parent_pat: Option<&'tcx Pat<'tcx>>,\n }\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n@@ -120,7 +136,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Option<Span>,\n         origin_expr: bool,\n     ) {\n-        self.check_pat(pat, expected, INITIAL_BM, TopInfo { expected, origin_expr, span });\n+        let info = TopInfo { expected, origin_expr, span, parent_pat: None };\n+        self.check_pat(pat, expected, INITIAL_BM, info);\n     }\n \n     /// Type check the given `pat` against the `expected` type\n@@ -161,8 +178,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n             }\n             PatKind::Or(pats) => {\n+                let parent_pat = Some(pat);\n                 for pat in pats {\n-                    self.check_pat(pat, expected, def_bm, ti);\n+                    self.check_pat(pat, expected, def_bm, TopInfo { parent_pat, ..ti });\n                 }\n                 expected\n             }\n@@ -501,7 +519,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ident(\n         &self,\n-        pat: &Pat<'_>,\n+        pat: &'tcx Pat<'tcx>,\n         ba: hir::BindingAnnotation,\n         var_id: HirId,\n         sub: Option<&'tcx Pat<'tcx>>,\n@@ -546,7 +564,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat(&p, expected, def_bm, ti);\n+            self.check_pat(&p, expected, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         }\n \n         local_ty\n@@ -647,6 +665,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             variant_ty\n         } else {\n             for field in fields {\n+                let ti = TopInfo { parent_pat: Some(&pat), ..ti };\n                 self.check_pat(&field.pat, self.tcx.types.err, def_bm, ti);\n             }\n             return self.tcx.types.err;\n@@ -656,9 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.demand_eqtype_pat(pat.span, expected, pat_ty, ti);\n \n         // Type-check subpatterns.\n-        if self\n-            .check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm, ti)\n-        {\n+        if self.check_struct_pat_fields(pat_ty, &pat, variant, fields, etc, def_bm, ti) {\n             pat_ty\n         } else {\n             self.tcx.types.err\n@@ -696,18 +713,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n-        if let Some(mut err) =\n+        let (pat_ty, pat_res) =\n+            self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n+        if let Some(err) =\n             self.demand_suptype_with_origin(&self.pattern_cause(ti, pat.span), expected, pat_ty)\n         {\n-            err.emit();\n+            self.emit_bad_pat_path(err, pat.span, res, pat_res, segments, ti.parent_pat);\n         }\n         pat_ty\n     }\n \n+    fn emit_bad_pat_path(\n+        &self,\n+        mut e: DiagnosticBuilder<'_>,\n+        pat_span: Span,\n+        res: Res,\n+        pat_res: Res,\n+        segments: &'b [hir::PathSegment<'b>],\n+        parent_pat: Option<&Pat<'_>>,\n+    ) {\n+        if let Some(span) = self.tcx.hir().res_span(pat_res) {\n+            e.span_label(span, &format!(\"{} defined here\", res.descr()));\n+            if let [hir::PathSegment { ident, .. }] = &*segments {\n+                e.span_label(\n+                    pat_span,\n+                    &format!(\n+                        \"`{}` is interpreted as {} {}, not a new binding\",\n+                        ident,\n+                        res.article(),\n+                        res.descr(),\n+                    ),\n+                );\n+                let (msg, sugg) = match parent_pat {\n+                    Some(Pat { kind: hir::PatKind::Struct(..), .. }) => (\n+                        \"bind the struct field to a different name instead\",\n+                        format!(\"{}: other_{}\", ident, ident.as_str().to_lowercase()),\n+                    ),\n+                    _ => (\n+                        \"introduce a new binding instead\",\n+                        format!(\"other_{}\", ident.as_str().to_lowercase()),\n+                    ),\n+                };\n+                e.span_suggestion(ident.span, msg, sugg, Applicability::HasPlaceholders);\n+            }\n+        }\n+        e.emit();\n+    }\n+\n     fn check_pat_tuple_struct(\n         &self,\n-        pat: &Pat<'_>,\n+        pat: &'tcx Pat<'tcx>,\n         qpath: &hir::QPath<'_>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n@@ -717,8 +772,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n+            let parent_pat = Some(pat);\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err, def_bm, ti);\n+                self.check_pat(&pat, tcx.types.err, def_bm, TopInfo { parent_pat, ..ti });\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -793,7 +849,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(&subpat, field_ty, def_bm, ti);\n+                self.check_pat(&subpat, field_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n@@ -938,8 +994,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_struct_pat_fields(\n         &self,\n         adt_ty: Ty<'tcx>,\n-        pat_id: HirId,\n-        span: Span,\n+        pat: &'tcx Pat<'tcx>,\n         variant: &'tcx ty::VariantDef,\n         fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n@@ -950,7 +1005,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (substs, adt) = match adt_ty.kind {\n             ty::Adt(adt, substs) => (substs, adt),\n-            _ => span_bug!(span, \"struct pattern is not an ADT\"),\n+            _ => span_bug!(pat.span, \"struct pattern is not an ADT\"),\n         };\n         let kind_name = adt.variant_descr();\n \n@@ -983,7 +1038,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .get(&ident)\n                         .map(|(i, f)| {\n                             self.write_field_index(field.hir_id, *i);\n-                            self.tcx.check_stability(f.did, Some(pat_id), span);\n+                            self.tcx.check_stability(f.did, Some(pat.hir_id), span);\n                             self.field_ty(span, f, substs)\n                         })\n                         .unwrap_or_else(|| {\n@@ -994,7 +1049,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(&field.pat, field_ty, def_bm, ti);\n+            self.check_pat(&field.pat, field_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         }\n \n         let mut unmentioned_fields = variant\n@@ -1017,7 +1072,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n             struct_span_err!(\n                 tcx.sess,\n-                span,\n+                pat.span,\n                 E0638,\n                 \"`..` required with {} marked as non-exhaustive\",\n                 kind_name\n@@ -1029,14 +1084,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if kind_name == \"union\" {\n             if fields.len() != 1 {\n                 tcx.sess\n-                    .struct_span_err(span, \"union patterns should have exactly one field\")\n+                    .struct_span_err(pat.span, \"union patterns should have exactly one field\")\n                     .emit();\n             }\n             if etc {\n-                tcx.sess.struct_span_err(span, \"`..` cannot be used in union patterns\").emit();\n+                tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n             }\n         } else if !etc && !unmentioned_fields.is_empty() {\n-            self.error_unmentioned_fields(span, &unmentioned_fields, variant);\n+            self.error_unmentioned_fields(pat.span, &unmentioned_fields, variant);\n         }\n         no_field_errors\n     }\n@@ -1196,7 +1251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ref(\n         &self,\n-        pat: &Pat<'_>,\n+        pat: &'tcx Pat<'tcx>,\n         inner: &'tcx Pat<'tcx>,\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n@@ -1236,7 +1291,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, ti);\n+        self.check_pat(&inner, inner_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         rptr_ty\n     }\n "}, {"sha": "44473fee643c638d3aafce57f8c01bcd1cebf576", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -31,10 +31,10 @@ pub fn infer_predicates<'tcx>(\n         predicates_added = false;\n \n         let mut visitor = InferVisitor {\n-            tcx: tcx,\n+            tcx,\n             global_inferred_outlives: &mut global_inferred_outlives,\n             predicates_added: &mut predicates_added,\n-            explicit_map: explicit_map,\n+            explicit_map,\n         };\n \n         // Visit all the crates and infer predicates"}, {"sha": "41b8e66d265922242d0c7002d325657d4fb37729", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -44,7 +44,7 @@ impl Module<'hir> {\n         vis: &'hir hir::Visibility<'hir>,\n     ) -> Module<'hir> {\n         Module {\n-            name: name,\n+            name,\n             id: hir::CRATE_HIR_ID,\n             vis,\n             where_outer: rustc_span::DUMMY_SP,"}, {"sha": "44f8e8bd1717a97d892553553050476b19c79505", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -2461,7 +2461,7 @@ impl RandomState {\n         KEYS.with(|keys| {\n             let (k0, k1) = keys.get();\n             keys.set((k0.wrapping_add(1), k1));\n-            RandomState { k0: k0, k1: k1 }\n+            RandomState { k0, k1 }\n         })\n     }\n }"}, {"sha": "3f6501bc7b4f6b37978de6f3c4dcc11d99a9b50f", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -135,7 +135,7 @@ pub trait Error: Debug + Display {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.41.0\", reason = \"use the Display impl or to_string()\")]\n+    #[rustc_deprecated(since = \"1.42.0\", reason = \"use the Display impl or to_string()\")]\n     fn description(&self) -> &str {\n         \"description() is deprecated; use Display\"\n     }"}, {"sha": "f36aa1846a16c172333b1397ed01204fbeaa890b", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -96,7 +96,7 @@ impl<T> Cursor<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: T) -> Cursor<T> {\n-        Cursor { pos: 0, inner: inner }\n+        Cursor { pos: 0, inner }\n     }\n \n     /// Consumes this cursor, returning the underlying value."}, {"sha": "0103e4bd628d7e757dc70c14aa78639c53238755", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -371,7 +371,7 @@ where\n     F: FnMut(&R) -> usize,\n {\n     let start_len = buf.len();\n-    let mut g = Guard { len: buf.len(), buf: buf };\n+    let mut g = Guard { len: buf.len(), buf };\n     let ret;\n     loop {\n         if g.len == g.buf.len() {\n@@ -939,7 +939,7 @@ pub trait Read {\n     where\n         Self: Sized,\n     {\n-        Take { inner: self, limit: limit }\n+        Take { inner: self, limit }\n     }\n }\n "}, {"sha": "0cb16b19d7326767cb2282cd74edfea3489f66d0", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -416,7 +416,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Mutex<T> {\n \n impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n     unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> {\n-        poison::map_result(lock.poison.borrow(), |guard| MutexGuard { lock: lock, poison: guard })\n+        poison::map_result(lock.poison.borrow(), |guard| MutexGuard { lock, poison: guard })\n     }\n }\n "}, {"sha": "50f54dbf14306a1644d0ab77345156d2d968c385", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -465,16 +465,13 @@ impl<T> From<T> for RwLock<T> {\n \n impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n     unsafe fn new(lock: &'rwlock RwLock<T>) -> LockResult<RwLockReadGuard<'rwlock, T>> {\n-        poison::map_result(lock.poison.borrow(), |_| RwLockReadGuard { lock: lock })\n+        poison::map_result(lock.poison.borrow(), |_| RwLockReadGuard { lock })\n     }\n }\n \n impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     unsafe fn new(lock: &'rwlock RwLock<T>) -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n-        poison::map_result(lock.poison.borrow(), |guard| RwLockWriteGuard {\n-            lock: lock,\n-            poison: guard,\n-        })\n+        poison::map_result(lock.poison.borrow(), |guard| RwLockWriteGuard { lock, poison: guard })\n     }\n }\n "}, {"sha": "d8d15615d7c338ac8f99466d51ce11460dc26d30", "filename": "src/test/ui/blind/blind-item-block-middle.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fblind%2Fblind-item-block-middle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fblind%2Fblind-item-block-middle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblind%2Fblind-item-block-middle.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,8 +1,15 @@\n error[E0308]: mismatched types\n   --> $DIR/blind-item-block-middle.rs:6:9\n    |\n+LL | mod foo { pub struct bar; }\n+   |           --------------- unit struct defined here\n+...\n LL |     let bar = 5;\n-   |         ^^^ expected integer, found struct `foo::bar`\n+   |         ^^^\n+   |         |\n+   |         expected integer, found struct `foo::bar`\n+   |         `bar` is interpreted as a unit struct, not a new binding\n+   |         help: introduce a new binding instead: `other_bar`\n \n error: aborting due to previous error\n "}, {"sha": "13606e498ef7def6410991eb7378197788a2d3dc", "filename": "src/test/ui/issues/auxiliary/issue-69725.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-69725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-69725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-69725.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,8 @@\n+#[derive(Clone)]\n+pub struct Struct<A>(A);\n+\n+impl<A> Struct<A> {\n+    pub fn new() -> Self {\n+        todo!()\n+    }\n+}"}, {"sha": "1e61178f42edbca6727c7e20d382f088a3c806d8", "filename": "src/test/ui/issues/issue-33504.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-33504.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-33504.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33504.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,8 +1,15 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-33504.rs:7:13\n    |\n+LL | struct Test;\n+   | ------------ unit struct defined here\n+...\n LL |         let Test = 1;\n-   |             ^^^^ expected integer, found struct `Test`\n+   |             ^^^^\n+   |             |\n+   |             expected integer, found struct `Test`\n+   |             `Test` is interpreted as a unit struct, not a new binding\n+   |             help: introduce a new binding instead: `other_test`\n \n error: aborting due to previous error\n "}, {"sha": "5451cf423559ed14d681785ac1f503ac07b81a4d", "filename": "src/test/ui/issues/issue-4968.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-4968.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-4968.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4968.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,8 +1,15 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-4968.rs:5:16\n    |\n+LL | const A: (isize,isize) = (4,2);\n+   | ------------------------------- constant defined here\n+LL | fn main() {\n LL |     match 42 { A => () }\n-   |                ^ expected integer, found tuple\n+   |                ^\n+   |                |\n+   |                expected integer, found tuple\n+   |                `A` is interpreted as a constant, not a new binding\n+   |                help: introduce a new binding instead: `other_a`\n    |\n    = note: expected type `{integer}`\n              found tuple `(isize, isize)`"}, {"sha": "a89980964ca0ab56afe3cbbd9fb77b1d82b811e8", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:8:9\n    |\n+LL | enum A { B, C }\n+   |          - unit variant defined here\n+...\n LL |     match (true, false) {\n    |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),"}, {"sha": "b8130b41f21673997f4244f35a52a68fd5dea52f", "filename": "src/test/ui/issues/issue-69725.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,11 @@\n+// aux-build:issue-69725.rs\n+\n+extern crate issue_69725;\n+use issue_69725::Struct;\n+\n+fn crash<A>() {\n+    let _ = Struct::<A>::new().clone();\n+    //~^ ERROR: no method named `clone` found\n+}\n+\n+fn main() {}"}, {"sha": "667383e072a5415d90563af85fb459d807f7063d", "filename": "src/test/ui/issues/issue-69725.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,18 @@\n+error[E0599]: no method named `clone` found for struct `issue_69725::Struct<A>` in the current scope\n+  --> $DIR/issue-69725.rs:7:32\n+   |\n+LL |     let _ = Struct::<A>::new().clone();\n+   |                                ^^^^^ method not found in `issue_69725::Struct<A>`\n+   | \n+  ::: $DIR/auxiliary/issue-69725.rs:2:1\n+   |\n+LL | pub struct Struct<A>(A);\n+   | ------------------------ doesn't satisfy `issue_69725::Struct<A>: std::clone::Clone`\n+   |\n+   = note: the method `clone` exists but the following trait bounds were not satisfied:\n+           `A: std::clone::Clone`\n+           which is required by `issue_69725::Struct<A>: std::clone::Clone`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "0d3121d60455d95c6df8c9602f338e26aca8701b", "filename": "src/test/ui/issues/issue-7867.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-7867.rs:7:9\n    |\n+LL | enum A { B, C }\n+   |          - unit variant defined here\n+...\n LL |     match (true, false) {\n    |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),"}, {"sha": "723c7fa92b10d00e68495694d61285687e70f944", "filename": "src/test/ui/match/match-tag-nullary.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/match-tag-nullary.rs:4:40\n    |\n+LL | enum B { B }\n+   |          - unit variant defined here\n+LL | \n LL | fn main() { let x: A = A::A; match x { B::B => { } } }\n    |                                    -   ^^^^ expected enum `A`, found enum `B`\n    |                                    |"}, {"sha": "aafd47993836ca4fb3d8a8d931855d5724cf8682", "filename": "src/test/ui/or-patterns/box-patterns.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2For-patterns%2Fbox-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2For-patterns%2Fbox-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fbox-patterns.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,37 @@\n+// Test or-patterns with box-patterns\n+\n+// run-pass\n+\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+#[derive(Debug)]\n+enum Test {\n+    Foo,\n+    Bar,\n+    Baz,\n+    Qux,\n+}\n+\n+fn test(x: Option<Box<Test>>) -> MatchArm {\n+    match x {\n+        Some(box Test::Foo | box Test::Bar) => MatchArm::Arm(0),\n+        Some(box Test::Baz) => MatchArm::Arm(1),\n+        Some(_) => MatchArm::Arm(2),\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(test(Some(Box::new(Test::Foo))), MatchArm::Arm(0));\n+    assert_eq!(test(Some(Box::new(Test::Bar))), MatchArm::Arm(0));\n+    assert_eq!(test(Some(Box::new(Test::Baz))), MatchArm::Arm(1));\n+    assert_eq!(test(Some(Box::new(Test::Qux))), MatchArm::Arm(2));\n+    assert_eq!(test(None), MatchArm::Wild);\n+}"}, {"sha": "05c907e8246798fedceef45006e491078b02da9b", "filename": "src/test/ui/or-patterns/slice-patterns.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2For-patterns%2Fslice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2For-patterns%2Fslice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fslice-patterns.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,53 @@\n+// Test or-patterns with slice-patterns\n+\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+#[derive(Debug)]\n+enum Test {\n+    Foo,\n+    Bar,\n+    Baz,\n+    Qux,\n+}\n+\n+fn test(foo: &[Option<Test>]) -> MatchArm {\n+    match foo {\n+        [.., Some(Test::Qux | Test::Foo)] => MatchArm::Arm(0),\n+        [Some(Test::Foo), .., Some(Test::Baz | Test::Bar)] => MatchArm::Arm(1),\n+        [.., Some(Test::Bar | Test::Baz), _] => MatchArm::Arm(2),\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    let foo = vec![\n+        Some(Test::Foo),\n+        Some(Test::Bar),\n+        Some(Test::Baz),\n+        Some(Test::Qux),\n+    ];\n+\n+    // path 1a\n+    assert_eq!(test(&foo), MatchArm::Arm(0));\n+    // path 1b\n+    assert_eq!(test(&[Some(Test::Bar), Some(Test::Foo)]), MatchArm::Arm(0));\n+    // path 2a\n+    assert_eq!(test(&foo[..3]), MatchArm::Arm(1));\n+    // path 2b\n+    assert_eq!(test(&[Some(Test::Foo), Some(Test::Foo), Some(Test::Bar)]), MatchArm::Arm(1));\n+    // path 3a\n+    assert_eq!(test(&foo[1..3]), MatchArm::Arm(2));\n+    // path 3b\n+    assert_eq!(test(&[Some(Test::Bar), Some(Test::Baz), Some(Test::Baz), Some(Test::Bar)]),\n+        MatchArm::Arm(2));\n+    // path 4\n+    assert_eq!(test(&foo[4..]), MatchArm::Wild);\n+}"}, {"sha": "e725aa5d73d1f97d00f6f2a0c924826ffc1c7922", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,171 @@\n+// edition:2018\n+#![crate_type = \"lib\"]\n+#![feature(type_ascription)]\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+// This tests the parser for \"x as Y[z]\". It errors, but we want to give useful\n+// errors and parse such that further code gives useful errors.\n+pub fn index_after_as_cast() {\n+    vec![1, 2, 3] as Vec<i32>[0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+    vec![1, 2, 3]: Vec<i32>[0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn index_after_cast_to_index() {\n+    (&[0]) as &[i32][0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+    (&[0i32]): &[i32; 1][0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn cast_after_cast() {\n+    if 5u64 as i32 as u16 == 0u16 {\n+\n+    }\n+    if 5u64: u64: u64 == 0u64 {\n+\n+    }\n+    let _ = 5u64: u64: u64 as u8 as i8 == 9i8;\n+    let _ = 0i32: i32: i32;\n+    let _ = 0 as i32: i32;\n+    let _ = 0i32: i32 as i32;\n+    let _ = 0 as i32 as i32;\n+    let _ = 0i32: i32: i32 as u32 as i32;\n+}\n+\n+pub fn cast_cast_method_call() {\n+    let _ = 0i32: i32: i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32: i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32 as i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32 as i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32.count_ones(): u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32.count_ones(): u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32.count_ones() as u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32.count_ones() as u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+}\n+\n+pub fn multiline_error() {\n+    let _ = 0\n+        as i32\n+        .count_ones();\n+    //~^^^ ERROR: casts cannot be followed by a method call\n+}\n+\n+// this tests that the precedence for `!x as Y.Z` is still what we expect\n+pub fn precedence() {\n+    let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn method_calls() {\n+    0 as i32.max(0);\n+    //~^ ERROR: casts cannot be followed by a method call\n+    0: i32.max(0);\n+    //~^ ERROR: casts cannot be followed by a method call\n+}\n+\n+pub fn complex() {\n+    let _ = format!(\n+        \"{} and {}\",\n+        if true { 33 } else { 44 } as i32.max(0),\n+        //~^ ERROR: casts cannot be followed by a method call\n+        if true { 33 } else { 44 }: i32.max(0)\n+        //~^ ERROR: casts cannot be followed by a method call\n+    );\n+}\n+\n+pub fn in_condition() {\n+    if 5u64 as i32.max(0) == 0 {\n+        //~^ ERROR: casts cannot be followed by a method call\n+    }\n+    if 5u64: u64.max(0) == 0 {\n+        //~^ ERROR: casts cannot be followed by a method call\n+    }\n+}\n+\n+pub fn inside_block() {\n+    let _ = if true {\n+        5u64 as u32.max(0) == 0\n+        //~^ ERROR: casts cannot be followed by a method call\n+    } else { false };\n+    let _ = if true {\n+        5u64: u64.max(0) == 0\n+        //~^ ERROR: casts cannot be followed by a method call\n+    } else { false };\n+}\n+\n+static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n+//~^ ERROR: casts cannot be followed by indexing\n+\n+static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n+//~^ ERROR: casts cannot be followed by indexing\n+\n+\n+pub fn cast_then_try() -> Result<u64,u64> {\n+    Err(0u64) as Result<u64,u64>?;\n+    //~^ ERROR: casts cannot be followed by ?\n+    Err(0u64): Result<u64,u64>?;\n+    //~^ ERROR: casts cannot be followed by ?\n+    Ok(1)\n+}\n+\n+\n+pub fn cast_then_call() {\n+    type F = fn(u8);\n+    // type ascription won't actually do [unique drop fn type] -> fn(u8) casts.\n+    let drop_ptr = drop as fn(u8);\n+    drop as F();\n+    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+    drop_ptr: F();\n+    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+}\n+\n+pub fn cast_to_fn_should_work() {\n+    let drop_ptr = drop as fn(u8);\n+    drop as fn(u8);\n+    drop_ptr: fn(u8);\n+}\n+\n+pub fn parens_after_cast_error() {\n+    let drop_ptr = drop as fn(u8);\n+    drop as fn(u8)(0);\n+    //~^ ERROR: casts cannot be followed by a function call\n+    drop_ptr: fn(u8)(0);\n+    //~^ ERROR: casts cannot be followed by a function call\n+}\n+\n+pub async fn cast_then_await() {\n+    Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n+    //~^ ERROR: casts cannot be followed by `.await`\n+\n+    Box::pin(noop()): Pin<Box<_>>.await;\n+    //~^ ERROR: casts cannot be followed by `.await`\n+}\n+\n+pub async fn noop() {}\n+\n+#[derive(Default)]\n+pub struct Foo {\n+    pub bar: u32,\n+}\n+\n+pub fn struct_field() {\n+    Foo::default() as Foo.bar;\n+    //~^ ERROR: cannot be followed by a field access\n+    Foo::default(): Foo.bar;\n+    //~^ ERROR: cannot be followed by a field access\n+}"}, {"sha": "255e9f409218b9df6d25c8f73d3a519c7793574c", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.stderr", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,392 @@\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:10:5\n+   |\n+LL |     vec![1, 2, 3] as Vec<i32>[0];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (vec![1, 2, 3] as Vec<i32>)[0];\n+   |     ^                         ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:12:5\n+   |\n+LL |     vec![1, 2, 3]: Vec<i32>[0];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (vec![1, 2, 3]: Vec<i32>)[0];\n+   |     ^                       ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:17:5\n+   |\n+LL |     (&[0]) as &[i32][0];\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     ((&[0]) as &[i32])[0];\n+   |     ^                ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:19:5\n+   |\n+LL |     (&[0i32]): &[i32; 1][0];\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     ((&[0i32]): &[i32; 1])[0];\n+   |     ^                    ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:39:13\n+   |\n+LL |     let _ = 0i32: i32: i32.count_ones();\n+   |             ^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32: i32).count_ones();\n+   |             ^              ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:41:13\n+   |\n+LL |     let _ = 0 as i32: i32.count_ones();\n+   |             ^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32: i32).count_ones();\n+   |             ^             ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:43:13\n+   |\n+LL |     let _ = 0i32: i32 as i32.count_ones();\n+   |             ^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32 as i32).count_ones();\n+   |             ^                ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:45:13\n+   |\n+LL |     let _ = 0 as i32 as i32.count_ones();\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32 as i32).count_ones();\n+   |             ^               ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:47:13\n+   |\n+LL |     let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32: i32 as u32 as i32).count_ones();\n+   |             ^                            ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:49:13\n+   |\n+LL |     let _ = 0i32: i32.count_ones(): u32;\n+   |             ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32).count_ones(): u32;\n+   |             ^         ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:51:13\n+   |\n+LL |     let _ = 0 as i32.count_ones(): u32;\n+   |             ^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32).count_ones(): u32;\n+   |             ^        ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:53:13\n+   |\n+LL |     let _ = 0i32: i32.count_ones() as u32;\n+   |             ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32).count_ones() as u32;\n+   |             ^         ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:55:13\n+   |\n+LL |     let _ = 0 as i32.count_ones() as u32;\n+   |             ^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32).count_ones() as u32;\n+   |             ^        ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:57:13\n+   |\n+LL |     let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n+   |             ^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32: i32).count_ones() as u32 as i32;\n+   |             ^              ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:62:13\n+   |\n+LL |       let _ = 0\n+   |  _____________^\n+LL | |         as i32\n+   | |______________^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0\n+LL |         as i32)\n+   |\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:70:18\n+   |\n+LL |     let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let x: i32 = (&vec![1, 2, 3] as &Vec<i32>)[0];\n+   |                  ^                           ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:75:5\n+   |\n+LL |     0 as i32.max(0);\n+   |     ^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (0 as i32).max(0);\n+   |     ^        ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:77:5\n+   |\n+LL |     0: i32.max(0);\n+   |     ^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (0: i32).max(0);\n+   |     ^      ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:92:8\n+   |\n+LL |     if 5u64 as i32.max(0) == 0 {\n+   |        ^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     if (5u64 as i32).max(0) == 0 {\n+   |        ^           ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:95:8\n+   |\n+LL |     if 5u64: u64.max(0) == 0 {\n+   |        ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     if (5u64: u64).max(0) == 0 {\n+   |        ^         ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:102:9\n+   |\n+LL |         5u64 as u32.max(0) == 0\n+   |         ^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (5u64 as u32).max(0) == 0\n+   |         ^           ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:106:9\n+   |\n+LL |         5u64: u64.max(0) == 0\n+   |         ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (5u64: u64).max(0) == 0\n+   |         ^         ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:111:24\n+   |\n+LL | static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n+   |                        ^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL | static bar: &[i32] = &((&[1,2,3] as &[i32])[0..1]);\n+   |                        ^                  ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:114:25\n+   |\n+LL | static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL | static bar2: &[i32] = &((&[1i32,2,3]: &[i32; 3])[0..1]);\n+   |                         ^                      ^\n+\n+error: casts cannot be followed by ?\n+  --> $DIR/issue-35813-postfix-after-cast.rs:119:5\n+   |\n+LL |     Err(0u64) as Result<u64,u64>?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Err(0u64) as Result<u64,u64>)?;\n+   |     ^                            ^\n+\n+error: casts cannot be followed by ?\n+  --> $DIR/issue-35813-postfix-after-cast.rs:121:5\n+   |\n+LL |     Err(0u64): Result<u64,u64>?;\n+   |     ^^^^^^^^^-^^^^^^^^^^^^^^^^\n+   |              |\n+   |              help: maybe write a path separator here: `::`\n+   |\n+   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:145:5\n+   |\n+LL |     drop as fn(u8)(0);\n+   |     ^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (drop as fn(u8))(0);\n+   |     ^              ^\n+\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:147:5\n+   |\n+LL |     drop_ptr: fn(u8)(0);\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (drop_ptr: fn(u8))(0);\n+   |     ^                ^\n+\n+error: casts cannot be followed by `.await`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:152:5\n+   |\n+LL |     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>).await;\n+   |     ^                                                     ^\n+\n+error: casts cannot be followed by `.await`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:155:5\n+   |\n+LL |     Box::pin(noop()): Pin<Box<_>>.await;\n+   |     ^^^^^^^^^^^^^^^^-^^^^^^^^^^^^\n+   |                     |\n+   |                     help: maybe write a path separator here: `::`\n+   |\n+   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+\n+error: casts cannot be followed by a field access\n+  --> $DIR/issue-35813-postfix-after-cast.rs:167:5\n+   |\n+LL |     Foo::default() as Foo.bar;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Foo::default() as Foo).bar;\n+   |     ^                     ^\n+\n+error: casts cannot be followed by a field access\n+  --> $DIR/issue-35813-postfix-after-cast.rs:169:5\n+   |\n+LL |     Foo::default(): Foo.bar;\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Foo::default(): Foo).bar;\n+   |     ^                   ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:84:9\n+   |\n+LL |         if true { 33 } else { 44 } as i32.max(0),\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (if true { 33 } else { 44 } as i32).max(0),\n+   |         ^                                 ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:86:9\n+   |\n+LL |         if true { 33 } else { 44 }: i32.max(0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (if true { 33 } else { 44 }: i32).max(0)\n+   |         ^                               ^\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/issue-35813-postfix-after-cast.rs:131:13\n+   |\n+LL |     drop as F();\n+   |             ^^^ only `Fn` traits may use parentheses\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/issue-35813-postfix-after-cast.rs:133:15\n+   |\n+LL |     drop_ptr: F();\n+   |               ^^^ only `Fn` traits may use parentheses\n+\n+error: aborting due to 36 previous errors\n+\n+For more information about this error, try `rustc --explain E0214`."}, {"sha": "ef9669a6b9e5ae9fca05f23ff0dea1f983269711", "filename": "src/test/ui/pattern/bindings-after-at/box-patterns.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbox-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbox-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbox-patterns.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,36 @@\n+// Test bindings-after-at with box-patterns\n+\n+// run-pass\n+\n+#![feature(bindings_after_at)]\n+#![feature(box_patterns)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+fn test(x: Option<Box<i32>>) -> MatchArm {\n+    match x {\n+        ref bar @ Some(box n) if n > 0 => {\n+            // bar is a &Option<Box<i32>>\n+            assert_eq!(bar, &x);\n+\n+            MatchArm::Arm(0)\n+        },\n+        Some(ref bar @ box n) if n < 0 => {\n+            // bar is a &Box<i32> here\n+            assert_eq!(**bar, n);\n+\n+            MatchArm::Arm(1)\n+        },\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(test(Some(Box::new(2))), MatchArm::Arm(0));\n+    assert_eq!(test(Some(Box::new(-1))), MatchArm::Arm(1));\n+    assert_eq!(test(Some(Box::new(0))), MatchArm::Wild);\n+}"}, {"sha": "ca8826f03f1ad0acf841861fd770af2f6e033404", "filename": "src/test/ui/pattern/bindings-after-at/or-patterns-box-patterns.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns-box-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns-box-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns-box-patterns.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,45 @@\n+// Test bindings-after-at with or-patterns and box-patterns\n+\n+// run-pass\n+\n+#![feature(bindings_after_at)]\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+#[derive(Debug, PartialEq)]\n+enum Test {\n+    Foo,\n+    Bar,\n+    Baz,\n+    Qux,\n+}\n+\n+fn test(foo: Option<Box<Test>>) -> MatchArm {\n+    match foo {\n+        ref bar @ Some(box Test::Foo | box Test::Bar) => {\n+            assert_eq!(bar, &foo);\n+\n+            MatchArm::Arm(0)\n+        },\n+        Some(ref bar @ box Test::Baz | ref bar @ box Test::Qux) => {\n+            assert!(**bar == Test::Baz || **bar == Test::Qux);\n+\n+            MatchArm::Arm(1)\n+        },\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(test(Some(Box::new(Test::Foo))), MatchArm::Arm(0));\n+    assert_eq!(test(Some(Box::new(Test::Bar))), MatchArm::Arm(0));\n+    assert_eq!(test(Some(Box::new(Test::Baz))), MatchArm::Arm(1));\n+    assert_eq!(test(Some(Box::new(Test::Qux))), MatchArm::Arm(1));\n+    assert_eq!(test(None), MatchArm::Wild);\n+}"}, {"sha": "65c2b3741b3e303432e80b22f7cfc132ab90c243", "filename": "src/test/ui/pattern/bindings-after-at/or-patterns-slice-patterns.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns-slice-patterns.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,56 @@\n+// Test bindings-after-at with or-patterns and slice-patterns\n+\n+// run-pass\n+\n+#![feature(bindings_after_at)]\n+#![feature(or_patterns)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+#[derive(Debug, PartialEq)]\n+enum Test {\n+    Foo,\n+    Bar,\n+    Baz,\n+    Qux,\n+}\n+\n+fn test(foo: &[Option<Test>]) -> MatchArm {\n+    match foo {\n+        bar @ [Some(Test::Foo), .., Some(Test::Qux | Test::Foo)] => {\n+            assert_eq!(bar, foo);\n+\n+            MatchArm::Arm(0)\n+        },\n+        [.., bar @ Some(Test::Bar | Test::Qux), _] => {\n+            assert!(bar == &Some(Test::Bar) || bar == &Some(Test::Qux));\n+\n+            MatchArm::Arm(1)\n+        },\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    let foo = vec![\n+        Some(Test::Foo),\n+        Some(Test::Bar),\n+        Some(Test::Baz),\n+        Some(Test::Qux),\n+    ];\n+\n+    // path 1a\n+    assert_eq!(test(&foo), MatchArm::Arm(0));\n+    // path 1b\n+    assert_eq!(test(&[Some(Test::Foo), Some(Test::Bar), Some(Test::Foo)]), MatchArm::Arm(0));\n+    // path 2a\n+    assert_eq!(test(&foo[..3]), MatchArm::Arm(1));\n+    // path 2b\n+    assert_eq!(test(&[Some(Test::Bar), Some(Test::Qux), Some(Test::Baz)]), MatchArm::Arm(1));\n+    // path 3\n+    assert_eq!(test(&foo[1..2]), MatchArm::Wild);\n+}"}, {"sha": "a0e14004ab1b0b35b0878eaeee73184b11408585", "filename": "src/test/ui/pattern/bindings-after-at/or-patterns.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2For-patterns.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,40 @@\n+// Test bindings-after-at with or-patterns\n+\n+// run-pass\n+\n+#![feature(bindings_after_at)]\n+#![feature(or_patterns)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+enum Test {\n+    Foo,\n+    Bar,\n+    Baz,\n+    Qux,\n+}\n+\n+fn test(foo: Option<Test>) -> MatchArm {\n+    match foo {\n+        bar @ Some(Test::Foo | Test::Bar) => {\n+            assert!(bar == Some(Test::Foo) || bar == Some(Test::Bar));\n+\n+            MatchArm::Arm(0)\n+        },\n+        Some(_) => MatchArm::Arm(1),\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(test(Some(Test::Foo)), MatchArm::Arm(0));\n+    assert_eq!(test(Some(Test::Bar)), MatchArm::Arm(0));\n+    assert_eq!(test(Some(Test::Baz)), MatchArm::Arm(1));\n+    assert_eq!(test(Some(Test::Qux)), MatchArm::Arm(1));\n+    assert_eq!(test(None), MatchArm::Wild);\n+}"}, {"sha": "7e50527af0b97b69b753112f4ca8aa150d638769", "filename": "src/test/ui/pattern/bindings-after-at/slice-patterns.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fslice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fslice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fslice-patterns.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,40 @@\n+// Test bindings-after-at with slice-patterns\n+\n+// run-pass\n+\n+#![feature(bindings_after_at)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+fn test(foo: &[i32]) -> MatchArm {\n+    match foo {\n+        [bar @ .., n] if n == &5 => {\n+            for i in bar {\n+                assert!(i < &5);\n+            }\n+\n+            MatchArm::Arm(0)\n+        },\n+        bar @ [x0, .., xn] => {\n+            assert_eq!(x0, &1);\n+            assert_eq!(x0, &1);\n+            assert_eq!(xn, &4);\n+            assert_eq!(bar, &[1, 2, 3, 4]);\n+\n+            MatchArm::Arm(1)\n+        },\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    let foo = vec![1, 2, 3, 4, 5];\n+\n+    assert_eq!(test(&foo), MatchArm::Arm(0));\n+    assert_eq!(test(&foo[..4]), MatchArm::Arm(1));\n+    assert_eq!(test(&foo[0..1]), MatchArm::Wild);\n+}"}, {"sha": "10d30ec1a1b189941d8143a2b559d264b3718895", "filename": "src/test/ui/rfc-2005-default-binding-mode/const.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,10 +1,17 @@\n error[E0308]: mismatched types\n   --> $DIR/const.rs:14:9\n    |\n+LL | const FOO: Foo = Foo{bar: 5};\n+   | ----------------------------- constant defined here\n+...\n LL |     match &f {\n    |           -- this expression has type `&Foo`\n LL |         FOO => {},\n-   |         ^^^ expected `&Foo`, found struct `Foo`\n+   |         ^^^\n+   |         |\n+   |         expected `&Foo`, found struct `Foo`\n+   |         `FOO` is interpreted as a constant, not a new binding\n+   |         help: introduce a new binding instead: `other_foo`\n \n error: aborting due to previous error\n "}, {"sha": "1cbba935402a90a398c23516952e496a392a0c15", "filename": "src/test/ui/suggestions/const-in-struct-pat.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,11 @@\n+#[allow(non_camel_case_types)]\n+struct foo;\n+struct Thing {\n+    foo: String,\n+}\n+\n+fn example(t: Thing) {\n+    let Thing { foo } = t; //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "0a010dcab4c26ba5f193adbe7d495f5a827fa6fc", "filename": "src/test/ui/suggestions/const-in-struct-pat.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/const-in-struct-pat.rs:8:17\n+   |\n+LL | struct foo;\n+   | ----------- unit struct defined here\n+...\n+LL |     let Thing { foo } = t;\n+   |                 ^^^     - this expression has type `Thing`\n+   |                 |\n+   |                 expected struct `std::string::String`, found struct `foo`\n+   |                 `foo` is interpreted as a unit struct, not a new binding\n+   |                 help: bind the struct field to a different name instead: `foo: other_foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8d6fd2abb6d5f133fb2f85f79d5ace8c28ca75e0", "filename": "src/test/ui/type/ascription/issue-54516.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -2,5 +2,7 @@ use std::collections::BTreeMap;\n \n fn main() {\n     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-    //~^ ERROR expected one of\n+    //~^ ERROR casts cannot be followed by a function call\n+    //~| ERROR expected value, found module `std::mem` [E0423]\n+    //~| ERROR cannot find type `size_of` in this scope [E0412]\n }"}, {"sha": "fdf35700ef94cf278af823c94ad56a0ff24495fa", "filename": "src/test/ui/type/ascription/issue-54516.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,13 +1,31 @@\n-error: expected one of `!`, `,`, or `::`, found `(`\n-  --> $DIR/issue-54516.rs:4:58\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-54516.rs:4:20\n    |\n LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-   |                            -                             ^ expected one of `!`, `,`, or `::`\n+   |                    ^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                            |\n    |                            help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n \n-error: aborting due to previous error\n+error[E0423]: expected value, found module `std::mem`\n+  --> $DIR/issue-54516.rs:4:20\n+   |\n+LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n+   |                    ^^^^^^^^- help: maybe you meant to write a path separator here: `::`\n+   |                    |\n+   |                    not a value\n+\n+error[E0412]: cannot find type `size_of` in this scope\n+  --> $DIR/issue-54516.rs:4:29\n+   |\n+LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n+   |                            -^^^^^^^ not found in this scope\n+   |                            |\n+   |                            help: maybe you meant to write a path separator here: `::`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0412, E0423.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "bcf9f88cb414b0ac93d260d555d8bd2cf0e54864", "filename": "src/test/ui/type/ascription/issue-60933.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,4 +1,6 @@\n fn main() {\n     let u: usize = std::mem:size_of::<u32>();\n-    //~^ ERROR expected one of\n+    //~^ ERROR casts cannot be followed by a function call\n+    //~| ERROR expected value, found module `std::mem` [E0423]\n+    //~| ERROR cannot find type `size_of` in this scope [E0412]\n }"}, {"sha": "cd9ae8f49f4f1e8c7406bc91ff44b99a2d50d158", "filename": "src/test/ui/type/ascription/issue-60933.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -1,13 +1,31 @@\n-error: expected one of `!`, `::`, or `;`, found `(`\n-  --> $DIR/issue-60933.rs:2:43\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-60933.rs:2:20\n    |\n LL |     let u: usize = std::mem:size_of::<u32>();\n-   |                            -              ^ expected one of `!`, `::`, or `;`\n+   |                    ^^^^^^^^-^^^^^^^^^^^^^^\n    |                            |\n    |                            help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n \n-error: aborting due to previous error\n+error[E0423]: expected value, found module `std::mem`\n+  --> $DIR/issue-60933.rs:2:20\n+   |\n+LL |     let u: usize = std::mem:size_of::<u32>();\n+   |                    ^^^^^^^^- help: maybe you meant to write a path separator here: `::`\n+   |                    |\n+   |                    not a value\n+\n+error[E0412]: cannot find type `size_of` in this scope\n+  --> $DIR/issue-60933.rs:2:29\n+   |\n+LL |     let u: usize = std::mem:size_of::<u32>();\n+   |                            -^^^^^^^ not found in this scope\n+   |                            |\n+   |                            help: maybe you meant to write a path separator here: `::`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0412, E0423.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "839d914baa9548ee856e7913ad76bcc9894daa05", "filename": "src/tools/unicode-table-generator/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03921701cdfe0b2c5422240f3ae370ab21069f1/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs?ref=a03921701cdfe0b2c5422240f3ae370ab21069f1", "patch": "@@ -147,7 +147,7 @@ fn main() {\n         eprintln!(\"Must provide path to write unicode tables to\");\n         eprintln!(\n             \"e.g. {} src/libcore/unicode/unicode_data.rs\",\n-            std::env::args().nth(0).unwrap_or_default()\n+            std::env::args().next().unwrap_or_default()\n         );\n         std::process::exit(1);\n     });"}]}