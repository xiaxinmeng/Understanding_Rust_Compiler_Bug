{"sha": "007ec666ad4a529682c35936d85ac81f7979f1b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwN2VjNjY2YWQ0YTUyOTY4MmMzNTkzNmQ4NWFjODFmNzk3OWYxYjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-04T15:38:26Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-04T15:52:23Z"}, "message": "Reorganize translation of expr_field\n\nIssue #667", "tree": {"sha": "86e8ab8ecfdcdea57648a9f6394502fb427c2657", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86e8ab8ecfdcdea57648a9f6394502fb427c2657"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/007ec666ad4a529682c35936d85ac81f7979f1b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/007ec666ad4a529682c35936d85ac81f7979f1b6", "html_url": "https://github.com/rust-lang/rust/commit/007ec666ad4a529682c35936d85ac81f7979f1b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/007ec666ad4a529682c35936d85ac81f7979f1b6/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e652588bfb3edea298026f56648057677b0fa3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e652588bfb3edea298026f56648057677b0fa3f", "html_url": "https://github.com/rust-lang/rust/commit/6e652588bfb3edea298026f56648057677b0fa3f"}], "stats": {"total": 110, "additions": 54, "deletions": 56}, "files": [{"sha": "b62e7a1f3d32c4398eeee21484e3343a47289819", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/007ec666ad4a529682c35936d85ac81f7979f1b6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007ec666ad4a529682c35936d85ac81f7979f1b6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=007ec666ad4a529682c35936d85ac81f7979f1b6", "patch": "@@ -2366,7 +2366,6 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n           _ { }\n         }\n     }\n-    \n     ret trans_eager_binop(bcx, op, Load(bcx, lhs_res.val), t, rhs_val, t,\n                           save_in(lhs_res.val));\n }\n@@ -3149,54 +3148,49 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n     }\n }\n \n-fn trans_field(cx: @block_ctxt, sp: span, base: @ast::expr,\n-               field: ast::ident) -> lval_maybe_callee {\n-    let {bcx, val} = trans_expr(cx, base);\n-    ret trans_field_inner(bcx, sp, val, ty::expr_ty(bcx_tcx(cx), base),\n-                          field);\n+fn trans_object_field(bcx: @block_ctxt, o: @ast::expr, field: ast::ident)\n+    -> {bcx: @block_ctxt, mthptr: ValueRef, objptr: ValueRef} {\n+    let {bcx, val} = trans_expr(bcx, o);\n+    let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), o));\n+    ret trans_object_field_inner(bcx, val, field, ty);\n }\n \n-fn trans_field_inner(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n-                     field: ast::ident) -> lval_maybe_callee {\n-    let r = autoderef(cx, v, t0);\n-    let t = r.ty;\n-    alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_rec(fields) {\n-        let ix: uint = ty::field_idx(bcx_ccx(cx).sess, sp, field, fields);\n-        let r_bcx = r.bcx;\n-        // Silly check\n-        check type_is_tup_like(r_bcx, t);\n-        let v = GEP_tup_like(r_bcx, t, r.val, [0, ix as int]);\n-        ret lval_no_env(v.bcx, v.val, true);\n-      }\n-      ty::ty_obj(methods) {\n-        let ix: uint = ty::method_idx(bcx_ccx(cx).sess, sp, field, methods);\n-        let vtbl = GEP(r.bcx, r.val, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-        vtbl = Load(r.bcx, vtbl);\n+fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n+                            field: ast::ident, o_ty: ty::t)\n+    -> {bcx: @block_ctxt, mthptr: ValueRef, objptr: ValueRef} {\n+    let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n+    let mths = alt ty::struct(tcx, o_ty) { ty::ty_obj(ms) { ms } };\n \n-        let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-        vtbl = PointerCast(cx, vtbl, vtbl_type);\n+    let ix = ty::method_idx(ccx.sess, bcx.sp, field, mths);\n+    let vtbl = Load(bcx, GEP(bcx, o, [C_int(0), C_int(abi::obj_field_vtbl)]));\n+    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n+    vtbl = PointerCast(bcx, vtbl, vtbl_type);\n \n-        let v = GEP(r.bcx, vtbl, [C_int(0), C_int(ix as int)]);\n-        let tcx = bcx_tcx(cx);\n-        let ccx = bcx_ccx(cx);\n+    let v = GEP(bcx, vtbl, [C_int(0), C_int(ix as int)]);\n+    let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, mths[ix]);\n+    let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n+    let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n+    // FIXME: constrain ty_obj?\n+    check non_ty_var(ccx, ret_ty);\n \n-        let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, methods[ix]);\n-        let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n-        let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n-        // FIXME: constrain ty_obj?\n-        check non_ty_var(ccx, ret_ty);\n+    let ll_fn_ty = type_of_fn(ccx, bcx.sp, ty::ty_fn_proto(tcx, fn_ty),\n+                              true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n+                              ret_ty, 0u);\n+    v = Load(bcx, PointerCast(bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n+    ret {bcx: bcx, mthptr: v, objptr: o};\n+}\n \n-        let ll_fn_ty =\n-            type_of_fn(ccx, sp, ty::ty_fn_proto(tcx, fn_ty),\n-                       true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n-                       ret_ty, 0u);\n-        v = Load(r.bcx, PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n-        ret {bcx: r.bcx, val: v, is_mem: true,\n-             env: obj_env(r.val), generic: none};\n-      }\n-      _ { bcx_ccx(cx).sess.unimpl(\"field variant in trans_field\"); }\n-    }\n+\n+fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n+                   field: ast::ident) -> lval_result {\n+    let {bcx, val} = trans_expr(bcx, base);\n+    let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), base));\n+    let fields = alt ty::struct(bcx_tcx(bcx), ty) { ty::ty_rec(fs) { fs } };\n+    let ix = ty::field_idx(bcx_ccx(bcx).sess, bcx.sp, field, fields);\n+    // Silly check\n+    check type_is_tup_like(bcx, ty);\n+    let {bcx, val} = GEP_tup_like(bcx, ty, val, [0, ix as int]);\n+    ret {bcx: bcx, val: val, is_mem: true};\n }\n \n fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n@@ -3248,24 +3242,30 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     ret lval_mem(next_cx, elt);\n }\n \n-fn trans_callee(cx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n+fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n-      ast::expr_path(p) { ret trans_path(cx, p, e.id); }\n+      ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n       ast::expr_field(base, ident) {\n-        ret trans_field(cx, e.span, base, ident);\n+        // Lval means record field, so not a method\n+        if !expr_is_lval(bcx_tcx(bcx), e) {\n+            let of = trans_object_field(bcx, base, ident);\n+            ret {bcx: of.bcx, val: of.mthptr, is_mem: true,\n+                 env: obj_env(of.objptr), generic: none};\n+        }\n       }\n       ast::expr_self_method(ident) {\n-        alt cx.fcx.llself {\n+        alt bcx.fcx.llself {\n           some(pair) {\n-            ret trans_field_inner(cx, e.span, pair.v, pair.t, ident);\n+            let fld = trans_object_field_inner(bcx, pair.v, ident, pair.t);\n+            ret {bcx: fld.bcx, val: fld.mthptr, is_mem: true,\n+                 env: obj_env(fld.objptr), generic: none};\n           }\n         }\n       }\n-      _ {\n-        let lv = trans_lval(cx, e);\n-        ret lval_no_env(lv.bcx, lv.val, lv.is_mem);\n-      }\n+      _ {}\n     }\n+    let lv = trans_lval(bcx, e);\n+    ret lval_no_env(lv.bcx, lv.val, lv.is_mem);\n }\n \n fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n@@ -3298,8 +3298,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n         ret lval_maybe_callee_to_lval(v, ty::expr_ty(bcx_tcx(cx), e));\n       }\n       ast::expr_field(base, ident) {\n-        let f = trans_field(cx, e.span, base, ident);\n-        ret lval_maybe_callee_to_lval(f, ty::expr_ty(bcx_tcx(cx), e));\n+        ret trans_rec_field(cx, base, ident);\n       }\n       ast::expr_index(base, idx) {\n         ret trans_index(cx, e.span, base, idx, e.id);\n@@ -4325,9 +4324,8 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_call(f, args) {\n         ret trans_call(bcx, f, none, args, e.id, dest);\n       }\n-      // FIXME[DPS] untangle non-lval fields from trans_lval\n       ast::expr_field(_, _) {\n-        ret lval_to_dps(bcx, e, dest);\n+        fail \"Taking the value of a method does not work yet (issue #435)\";\n       }\n \n       // These return nothing"}]}