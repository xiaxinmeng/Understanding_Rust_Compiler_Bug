{"sha": "6cf430147e35bbf902cf4539349621ed559d0ddb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZjQzMDE0N2UzNWJiZjkwMmNmNDUzOTM0OTYyMWVkNTU5ZDBkZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-24T07:01:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-24T07:01:25Z"}, "message": "auto merge of #14388 : kballard/rust/nonfatal_lexer_errors, r=alexcrichton\n\nMost errors that arise in the lexer can be recovered from. This allows\r\nfor more than one syntax error to be reported at a time.", "tree": {"sha": "315ec9270979c371e2179f70c49d2c0a52972b1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/315ec9270979c371e2179f70c49d2c0a52972b1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cf430147e35bbf902cf4539349621ed559d0ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf430147e35bbf902cf4539349621ed559d0ddb", "html_url": "https://github.com/rust-lang/rust/commit/6cf430147e35bbf902cf4539349621ed559d0ddb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cf430147e35bbf902cf4539349621ed559d0ddb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bec8d724638da22c3d54f2357442cef88d10b1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bec8d724638da22c3d54f2357442cef88d10b1e", "html_url": "https://github.com/rust-lang/rust/commit/3bec8d724638da22c3d54f2357442cef88d10b1e"}, {"sha": "4c9dace5d56123eef470896110f593af93180c45", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9dace5d56123eef470896110f593af93180c45", "html_url": "https://github.com/rust-lang/rust/commit/4c9dace5d56123eef470896110f593af93180c45"}], "stats": {"total": 359, "additions": 148, "deletions": 211}, "files": [{"sha": "63b1bf440612e1a8b7b8066ae77cb9b9b9093f44", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=6cf430147e35bbf902cf4539349621ed559d0ddb", "patch": "@@ -291,7 +291,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if is_eof(rdr) {\n-                rdr.fatal(\"unterminated block comment\".to_strbuf());\n+                rdr.fatal(\"unterminated block comment\");\n             }\n             if rdr.curr_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines,"}, {"sha": "34116c3a4be9eddfdbb95dc926d761c592d56809", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 103, "deletions": 142, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=6cf430147e35bbf902cf4539349621ed559d0ddb", "patch": "@@ -21,15 +21,16 @@ use std::mem::replace;\n use std::num::from_str_radix;\n use std::rc::Rc;\n use std::str;\n-use std::strbuf::StrBuf;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n pub trait Reader {\n     fn is_eof(&self) -> bool;\n     fn next_token(&mut self) -> TokenAndSpan;\n-    fn fatal(&self, StrBuf) -> !;\n-    fn span_diag<'a>(&'a self) -> &'a SpanHandler;\n+    /// Report a fatal error with the current span.\n+    fn fatal(&self, &str) -> !;\n+    /// Report a non-fatal error with the current span.\n+    fn err(&self, &str);\n     fn peek(&self) -> TokenAndSpan;\n }\n \n@@ -101,15 +102,17 @@ impl<'a> Reader for StringReader<'a> {\n         string_advance_token(self);\n         ret_val\n     }\n-    fn fatal(&self, m: StrBuf) -> ! {\n-        self.span_diagnostic.span_fatal(self.peek_span, m.as_slice())\n+    fn fatal(&self, m: &str) -> ! {\n+        self.span_diagnostic.span_fatal(self.peek_span, m)\n+    }\n+    fn err(&self, m: &str) {\n+        self.span_diagnostic.span_err(self.peek_span, m)\n     }\n-    fn span_diag<'a>(&'a self) -> &'a SpanHandler { self.span_diagnostic }\n     fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n         TokenAndSpan {\n             tok: self.peek_tok.clone(),\n-            sp: self.peek_span.clone(),\n+            sp: self.peek_span,\n         }\n     }\n }\n@@ -123,55 +126,58 @@ impl<'a> Reader for TtReader<'a> {\n         debug!(\"TtReader: r={:?}\", r);\n         r\n     }\n-    fn fatal(&self, m: StrBuf) -> ! {\n-        self.sp_diag.span_fatal(self.cur_span, m.as_slice());\n+    fn fatal(&self, m: &str) -> ! {\n+        self.sp_diag.span_fatal(self.cur_span, m);\n+    }\n+    fn err(&self, m: &str) {\n+        self.sp_diag.span_err(self.cur_span, m);\n     }\n-    fn span_diag<'a>(&'a self) -> &'a SpanHandler { self.sp_diag }\n     fn peek(&self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: self.cur_tok.clone(),\n-            sp: self.cur_span.clone(),\n+            sp: self.cur_span,\n         }\n     }\n }\n \n // report a lexical error spanning [`from_pos`, `to_pos`)\n-fn fatal_span(rdr: &mut StringReader,\n-              from_pos: BytePos,\n-              to_pos: BytePos,\n-              m: StrBuf)\n-           -> ! {\n+fn fatal_span(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n     rdr.peek_span = codemap::mk_sp(from_pos, to_pos);\n     rdr.fatal(m);\n }\n \n+fn err_span(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m: &str) {\n+    rdr.peek_span = codemap::mk_sp(from_pos, to_pos);\n+    rdr.err(m);\n+}\n+\n // report a lexical error spanning [`from_pos`, `to_pos`), appending an\n // escaped character to the error message\n fn fatal_span_char(rdr: &mut StringReader,\n-                   from_pos: BytePos,\n-                   to_pos: BytePos,\n-                   m: StrBuf,\n-                   c: char)\n-                -> ! {\n-    let mut m = m;\n+                   from_pos: BytePos, to_pos: BytePos,\n+                   m: &str, c: char) -> ! {\n+    let mut m = m.to_strbuf();\n+    m.push_str(\": \");\n+    char::escape_default(c, |c| m.push_char(c));\n+    fatal_span(rdr, from_pos, to_pos, m.as_slice());\n+}\n+\n+fn err_span_char(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n+    let mut m = m.to_strbuf();\n     m.push_str(\": \");\n     char::escape_default(c, |c| m.push_char(c));\n-    fatal_span(rdr, from_pos, to_pos, m.into_strbuf());\n+    err_span(rdr, from_pos, to_pos, m.as_slice());\n }\n \n // report a lexical error spanning [`from_pos`, `to_pos`), appending the\n // offending string to the error message\n-fn fatal_span_verbose(rdr: &mut StringReader,\n-                      from_pos: BytePos,\n-                      to_pos: BytePos,\n-                      m: StrBuf)\n-                   -> ! {\n-    let mut m = m;\n+fn fatal_span_verbose(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n+    let mut m = m.to_strbuf();\n     m.push_str(\": \");\n     let from = byte_offset(rdr, from_pos).to_uint();\n     let to = byte_offset(rdr, to_pos).to_uint();\n     m.push_str(rdr.filemap.src.as_slice().slice(from, to));\n-    fatal_span(rdr, from_pos, to_pos, m);\n+    fatal_span(rdr, from_pos, to_pos, m.as_slice());\n }\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n@@ -283,36 +289,13 @@ pub fn nextnextch_is(rdr: &StringReader, c: char) -> bool {\n     nextnextch(rdr) == Some(c)\n }\n \n-fn hex_digit_val(c: Option<char>) -> int {\n-    let d = c.unwrap_or('\\x00');\n-\n-    if in_range(c, '0', '9') { return (d as int) - ('0' as int); }\n-    if in_range(c, 'a', 'f') { return (d as int) - ('a' as int) + 10; }\n-    if in_range(c, 'A', 'F') { return (d as int) - ('A' as int) + 10; }\n-    fail!();\n-}\n-\n pub fn is_whitespace(c: Option<char>) -> bool {\n     match c.unwrap_or('\\x00') { // None can be null for now... it's not whitespace\n         ' ' | '\\n' | '\\t' | '\\r' => true,\n         _ => false\n     }\n }\n \n-fn in_range(c: Option<char>, lo: char, hi: char) -> bool {\n-    match c {\n-        Some(c) => lo <= c && c <= hi,\n-        _ => false\n-    }\n-}\n-\n-fn is_dec_digit(c: Option<char>) -> bool { return in_range(c, '0', '9'); }\n-\n-fn is_hex_digit(c: Option<char>) -> bool {\n-    return in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n-            in_range(c, 'A', 'F');\n-}\n-\n // EFFECT: eats whitespace and comments.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise.\n fn consume_whitespace_and_comments(rdr: &mut StringReader)\n@@ -403,9 +386,9 @@ fn consume_block_comment(rdr: &mut StringReader) -> Option<TokenAndSpan> {\n     while level > 0 {\n         if is_eof(rdr) {\n             let msg = if is_doc_comment {\n-                \"unterminated block doc-comment\".to_strbuf()\n+                \"unterminated block doc-comment\"\n             } else {\n-                \"unterminated block comment\".to_strbuf()\n+                \"unterminated block comment\"\n             };\n             fatal_span(rdr, start_bpos, rdr.last_pos, msg);\n         } else if rdr.curr_is('/') && nextch_is(rdr, '*') {\n@@ -456,13 +439,13 @@ fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<StrBuf>\n         let exponent = scan_digits(rdr, 10u);\n         if exponent.len() > 0u {\n             rslt.push_str(exponent.as_slice());\n-            return Some(rslt);\n         } else {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       \"scan_exponent: bad fp literal\".to_strbuf());\n+            err_span(rdr, start_bpos, rdr.last_pos, \"scan_exponent: bad fp literal\");\n+            rslt.push_str(\"1\"); // arbitrary placeholder exponent\n         }\n+        Some(rslt)\n     } else {\n-        return None::<StrBuf>;\n+        None\n     }\n }\n \n@@ -484,14 +467,9 @@ fn scan_digits(rdr: &mut StringReader, radix: uint) -> StrBuf {\n fn check_float_base(rdr: &mut StringReader, start_bpos: BytePos, last_bpos: BytePos,\n                     base: uint) {\n     match base {\n-      16u => {\n-          fatal_span(rdr, start_bpos, last_bpos,\n-                     \"hexadecimal float literal is not supported\".to_strbuf())\n-      }\n-      8u => fatal_span(rdr, start_bpos, last_bpos,\n-                     \"octal float literal is not supported\".to_strbuf()),\n-      2u => fatal_span(rdr, start_bpos, last_bpos,\n-                     \"binary float literal is not supported\".to_strbuf()),\n+      16u => err_span(rdr, start_bpos, last_bpos, \"hexadecimal float literal is not supported\"),\n+      8u => err_span(rdr, start_bpos, last_bpos, \"octal float literal is not supported\"),\n+      2u => err_span(rdr, start_bpos, last_bpos, \"binary float literal is not supported\"),\n       _ => ()\n     }\n }\n@@ -517,7 +495,6 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n     }\n     num_str = scan_digits(rdr, base);\n     c = rdr.curr.unwrap_or('\\x00');\n-    nextch(rdr);\n     if c == 'u' || c == 'i' {\n         enum Result { Signed(ast::IntTy), Unsigned(ast::UintTy) }\n         let signed = c == 'i';\n@@ -550,14 +527,16 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n                       else { Unsigned(ast::TyU64) };\n         }\n         if num_str.len() == 0u {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       \"no valid digits found for number\".to_strbuf());\n+            err_span(rdr, start_bpos, rdr.last_pos, \"no valid digits found for number\");\n+            num_str = \"1\".to_strbuf();\n         }\n         let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                  base as uint) {\n             Some(p) => p,\n-            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n-                               \"int literal is too large\".to_strbuf())\n+            None => {\n+                err_span(rdr, start_bpos, rdr.last_pos, \"int literal is too large\");\n+                1\n+            }\n         };\n \n         match tp {\n@@ -607,22 +586,23 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n             check_float_base(rdr, start_bpos, rdr.last_pos, base);\n             return token::LIT_FLOAT(str_to_ident(num_str.as_slice()), ast::TyF128);\n         }\n-        fatal_span(rdr, start_bpos, rdr.last_pos,\n-                   \"expected `f32`, `f64` or `f128` suffix\".to_strbuf());\n+        err_span(rdr, start_bpos, rdr.last_pos, \"expected `f32`, `f64` or `f128` suffix\");\n     }\n     if is_float {\n         check_float_base(rdr, start_bpos, rdr.last_pos, base);\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str.as_slice()));\n     } else {\n         if num_str.len() == 0u {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       \"no valid digits found for number\".to_strbuf());\n+            err_span(rdr, start_bpos, rdr.last_pos, \"no valid digits found for number\");\n+            num_str = \"1\".to_strbuf();\n         }\n         let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                  base as uint) {\n             Some(p) => p,\n-            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n-                               \"int literal is too large\".to_strbuf())\n+            None => {\n+                err_span(rdr, start_bpos, rdr.last_pos, \"int literal is too large\");\n+                1\n+            }\n         };\n \n         debug!(\"lexing {} as an unsuffixed integer literal\",\n@@ -631,34 +611,33 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n     }\n }\n \n-fn scan_numeric_escape(rdr: &mut StringReader, n_hex_digits: uint) -> char {\n-    let mut accum_int = 0;\n-    let mut i = n_hex_digits;\n+fn scan_numeric_escape(rdr: &mut StringReader, n_hex_digits: uint, delim: char) -> char {\n+    let mut accum_int = 0u32;\n     let start_bpos = rdr.last_pos;\n-    while i != 0u && !is_eof(rdr) {\n-        let n = rdr.curr;\n-        if !is_hex_digit(n) {\n-            fatal_span_char(\n-                rdr,\n-                rdr.last_pos,\n-                rdr.pos,\n-                \"illegal character in numeric character escape\".to_strbuf(),\n-                n.unwrap());\n+    for _ in range(0, n_hex_digits) {\n+        if is_eof(rdr) {\n+            fatal_span(rdr, start_bpos, rdr.last_pos, \"unterminated numeric character escape\");\n         }\n-        bump(rdr);\n+        if rdr.curr_is(delim) {\n+            err_span(rdr, start_bpos, rdr.last_pos, \"numeric character escape is too short\");\n+            break;\n+        }\n+        let c = rdr.curr.unwrap_or('\\x00');\n         accum_int *= 16;\n-        accum_int += hex_digit_val(n);\n-        i -= 1u;\n-    }\n-    if i != 0 && is_eof(rdr) {\n-        fatal_span(rdr, start_bpos, rdr.last_pos,\n-                   \"unterminated numeric character escape\".to_strbuf());\n+        accum_int += c.to_digit(16).unwrap_or_else(|| {\n+            err_span_char(rdr, rdr.last_pos, rdr.pos,\n+                          \"illegal character in numeric character escape\", c);\n+            0\n+        }) as u32;\n+        bump(rdr);\n     }\n \n-    match char::from_u32(accum_int as u32) {\n+    match char::from_u32(accum_int) {\n         Some(x) => x,\n-        None => fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           \"illegal numeric character escape\".to_strbuf())\n+        None => {\n+            err_span(rdr, start_bpos, rdr.last_pos, \"illegal numeric character escape\");\n+            '?'\n+        }\n     }\n }\n \n@@ -706,7 +685,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n             }\n         })\n     }\n-    if is_dec_digit(c) {\n+    if c.map_or(false, |c| c.is_digit_radix(10)) {\n         return scan_number(c.unwrap(), rdr);\n     }\n     fn binop(rdr: &mut StringReader, op: token::BinOp) -> token::Token {\n@@ -823,16 +802,13 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n             let tok = &token::IDENT(ident, false);\n \n             if token::is_keyword(token::keywords::Self, tok) {\n-                fatal_span(rdr, start, rdr.last_pos,\n-                           \"invalid lifetime name: 'self \\\n-                            is no longer a special lifetime\".to_strbuf());\n+                err_span(rdr, start, rdr.last_pos,\n+                         \"invalid lifetime name: 'self is no longer a special lifetime\");\n             } else if token::is_any_keyword(tok) &&\n                 !token::is_keyword(token::keywords::Static, tok) {\n-                fatal_span(rdr, start, rdr.last_pos,\n-                           \"invalid lifetime name\".to_strbuf());\n-            } else {\n-                return token::LIFETIME(ident);\n+                err_span(rdr, start, rdr.last_pos, \"invalid lifetime name\");\n             }\n+            return token::LIFETIME(ident);\n         }\n \n         // Otherwise it is a character constant:\n@@ -853,28 +829,20 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n                             '\\'' => '\\'',\n                             '\"' => '\"',\n                             '0' => '\\x00',\n-                            'x' => scan_numeric_escape(rdr, 2u),\n-                            'u' => scan_numeric_escape(rdr, 4u),\n-                            'U' => scan_numeric_escape(rdr, 8u),\n+                            'x' => scan_numeric_escape(rdr, 2u, '\\''),\n+                            'u' => scan_numeric_escape(rdr, 4u, '\\''),\n+                            'U' => scan_numeric_escape(rdr, 8u, '\\''),\n                             c2 => {\n-                                fatal_span_char(rdr,\n-                                                escaped_pos,\n-                                                rdr.last_pos,\n-                                                \"unknown character \\\n-                                                 escape\".to_strbuf(),\n-                                                c2)\n+                                err_span_char(rdr, escaped_pos, rdr.last_pos,\n+                                              \"unknown character escape\", c2);\n+                                c2\n                             }\n                         }\n                     }\n                 }\n             }\n             '\\t' | '\\n' | '\\r' | '\\'' => {\n-                fatal_span_char(\n-                    rdr,\n-                    start,\n-                    rdr.last_pos,\n-                    \"character constant must be escaped\".to_strbuf(),\n-                    c2);\n+                err_span_char(rdr, start, rdr.last_pos, \"character constant must be escaped\", c2);\n             }\n             _ => {}\n         }\n@@ -883,9 +851,8 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n                                // Byte offsetting here is okay because the\n                                // character before position `start` is an\n                                // ascii single quote.\n-                               start - BytePos(1),\n-                               rdr.last_pos,\n-                               \"unterminated character constant\".to_strbuf());\n+                               start - BytePos(1), rdr.last_pos,\n+                               \"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n         return token::LIT_CHAR(c2);\n@@ -896,17 +863,15 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n         bump(rdr);\n         while !rdr.curr_is('\"') {\n             if is_eof(rdr) {\n-                fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           \"unterminated double quote string\".to_strbuf());\n+                fatal_span(rdr, start_bpos, rdr.last_pos, \"unterminated double quote string\");\n             }\n \n             let ch = rdr.curr.unwrap();\n             bump(rdr);\n             match ch {\n               '\\\\' => {\n                 if is_eof(rdr) {\n-                    fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           \"unterminated double quote string\".to_strbuf());\n+                    fatal_span(rdr, start_bpos, rdr.last_pos, \"unterminated double quote string\");\n                 }\n \n                 let escaped = rdr.curr.unwrap();\n@@ -922,17 +887,16 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n                   '\\n' => consume_whitespace(rdr),\n                   '0' => accum_str.push_char('\\x00'),\n                   'x' => {\n-                    accum_str.push_char(scan_numeric_escape(rdr, 2u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 2u, '\"'));\n                   }\n                   'u' => {\n-                    accum_str.push_char(scan_numeric_escape(rdr, 4u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 4u, '\"'));\n                   }\n                   'U' => {\n-                    accum_str.push_char(scan_numeric_escape(rdr, 8u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 8u, '\"'));\n                   }\n                   c2 => {\n-                    fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n-                                    \"unknown string escape\".to_strbuf(), c2);\n+                    err_span_char(rdr, escaped_pos, rdr.last_pos, \"unknown string escape\", c2);\n                   }\n                 }\n               }\n@@ -952,21 +916,19 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n         }\n \n         if is_eof(rdr) {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       \"unterminated raw string\".to_strbuf());\n+            fatal_span(rdr, start_bpos, rdr.last_pos, \"unterminated raw string\");\n         } else if !rdr.curr_is('\"') {\n             fatal_span_char(rdr, start_bpos, rdr.last_pos,\n                             \"only `#` is allowed in raw string delimitation; \\\n-                             found illegal character\".to_strbuf(),\n+                             found illegal character\",\n                             rdr.curr.unwrap());\n         }\n         bump(rdr);\n         let content_start_bpos = rdr.last_pos;\n         let mut content_end_bpos;\n         'outer: loop {\n             if is_eof(rdr) {\n-                fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           \"unterminated raw string\".to_strbuf());\n+                fatal_span(rdr, start_bpos, rdr.last_pos, \"unterminated raw string\");\n             }\n             if rdr.curr_is('\"') {\n                 content_end_bpos = rdr.last_pos;\n@@ -1013,8 +975,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n       '^' => { return binop(rdr, token::CARET); }\n       '%' => { return binop(rdr, token::PERCENT); }\n       c => {\n-          fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n-                          \"unknown start of token\".to_strbuf(), c);\n+          fatal_span_char(rdr, rdr.last_pos, rdr.pos, \"unknown start of token\", c);\n       }\n     }\n }"}, {"sha": "2a358ae8307b6318c1765438259af59cb63dc3a7", "filename": "src/test/compile-fail/bad-char-literals.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Ftest%2Fcompile-fail%2Fbad-char-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Ftest%2Fcompile-fail%2Fbad-char-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-char-literals.rs?ref=6cf430147e35bbf902cf4539349621ed559d0ddb", "patch": "@@ -8,8 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-cr\n+// ignore-tidy-tab\n fn main() {\n     // these literals are just silly.\n     ''';\n-    //~^ ERROR: character constant must be escaped\n+    //~^ ERROR: character constant must be escaped: \\'\n+\n+    // note that this is a literal \"\\n\" byte\n+    '\n+';\n+    //~^^ ERROR: character constant must be escaped: \\n\n+\n+    // note that this is a literal \"\\r\" byte\n+    '\r'; //~ ERROR: character constant must be escaped: \\r\n+\n+    // note that this is a literal tab character here\n+    '\t';\n+    //~^ ERROR: character constant must be escaped: \\t\n }"}, {"sha": "c5226cfec457bcb461d97e4ef599e8e9a6f758e1", "filename": "src/test/compile-fail/bad-char-literals2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Fbad-char-literals2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Fbad-char-literals2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-char-literals2.rs?ref=3bec8d724638da22c3d54f2357442cef88d10b1e", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    // note that this is a literal \"\\n\" byte\n-    '\n-';\n-    //~^^ ERROR: character constant must be escaped\n-}"}, {"sha": "079fbe6c5dc29ebee324de0608069b9ecd0ce63a", "filename": "src/test/compile-fail/bad-char-literals3.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Fbad-char-literals3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Fbad-char-literals3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-char-literals3.rs?ref=3bec8d724638da22c3d54f2357442cef88d10b1e", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-cr\n-fn main() {\n-    // note that this is a literal \"\\r\" byte\n-    '\n-'; //~^ ERROR: character constant must be escaped\n-}"}, {"sha": "6560e91423b2ffdb88f435d71b85ea2449f4b7b1", "filename": "src/test/compile-fail/bad-char-literals4.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Fbad-char-literals4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Fbad-char-literals4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-char-literals4.rs?ref=3bec8d724638da22c3d54f2357442cef88d10b1e", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-tab\n-fn main() {\n-    // note that this is a literal tab character here\n-    '\t';\n-    //~^ ERROR: character constant must be escaped\n-}"}, {"sha": "47ad473c577c21162d4fe18df46372c47dfdaf5b", "filename": "src/test/compile-fail/issue-10412.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs?ref=6cf430147e35bbf902cf4539349621ed559d0ddb", "patch": "@@ -9,16 +9,17 @@\n // except according to those terms.\n \n \n-trait Serializable<'self, T> { //~ ERROR: no longer a special lifetime\n-    fn serialize(val : &'self T) -> Vec<u8> ;\n-    fn deserialize(repr : &[u8]) -> &'self T;\n+trait Serializable<'self, T> { //~ ERROR no longer a special lifetime\n+    fn serialize(val : &'self T) -> Vec<u8> ; //~ ERROR no longer a special lifetime\n+    fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR no longer a special lifetime\n }\n \n-impl<'self> Serializable<str> for &'self str {\n-    fn serialize(val : &'self str) -> Vec<u8> {\n+impl<'self> Serializable<str> for &'self str { //~ ERROR no longer a special lifetime\n+    //~^ ERROR no longer a special lifetime\n+    fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR no longer a special lifetime\n         vec!(1)\n     }\n-    fn deserialize(repr: &[u8]) -> &'self str {\n+    fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR no longer a special lifetime\n         \"hi\"\n     }\n }"}, {"sha": "fe46cec776dfa77a86a0bf8fc06d0bec2a2014b5", "filename": "src/test/compile-fail/lex-illegal-num-char-escape-2.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bec8d724638da22c3d54f2357442cef88d10b1e/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs?ref=3bec8d724638da22c3d54f2357442cef88d10b1e", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-static c: char =\n-    '\\Uffffffff' //~ ERROR: illegal numeric character escape\n-;"}, {"sha": "8f4c756c891d515c9ec64d8e42f2c431fe739311", "filename": "src/test/compile-fail/lex-illegal-num-char-escape.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf430147e35bbf902cf4539349621ed559d0ddb/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs?ref=6cf430147e35bbf902cf4539349621ed559d0ddb", "patch": "@@ -11,3 +11,25 @@\n static c: char =\n     '\\u539_' //~ ERROR: illegal character in numeric character escape\n ;\n+\n+static c2: char =\n+    '\\Uffffffff' //~ ERROR: illegal numeric character escape\n+;\n+\n+static c3: char =\n+    '\\x1' //~ ERROR: numeric character escape is too short\n+;\n+\n+static c4: char =\n+    '\\u23q' //~  ERROR: illegal character in numeric character escape\n+;\n+//~^^ ERROR: numeric character escape is too short\n+\n+static s: &'static str =\n+    \"\\x1\" //~ ERROR: numeric character escape is too short\n+;\n+\n+static s2: &'static str =\n+    \"\\u23q\" //~ ERROR: illegal character in numeric character escape\n+;\n+//~^^ ERROR: numeric character escape is too short"}]}