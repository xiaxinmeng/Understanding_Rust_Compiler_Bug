{"sha": "cd4706413fb891ffe33ef06e0c229d97258fbfaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNDcwNjQxM2ZiODkxZmZlMzNlZjA2ZTBjMjI5ZDk3MjU4ZmJmYWY=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-09-27T13:17:13Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-09-27T13:17:13Z"}, "message": "Run cargo dev fmt", "tree": {"sha": "1ad809b19f6528df39cf23a9f8f24b5f2e8c6eee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ad809b19f6528df39cf23a9f8f24b5f2e8c6eee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd4706413fb891ffe33ef06e0c229d97258fbfaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd4706413fb891ffe33ef06e0c229d97258fbfaf", "html_url": "https://github.com/rust-lang/rust/commit/cd4706413fb891ffe33ef06e0c229d97258fbfaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd4706413fb891ffe33ef06e0c229d97258fbfaf/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "798a5cf5bc70eb7d9140b8bed4ed8c48ab16feae", "url": "https://api.github.com/repos/rust-lang/rust/commits/798a5cf5bc70eb7d9140b8bed4ed8c48ab16feae", "html_url": "https://github.com/rust-lang/rust/commit/798a5cf5bc70eb7d9140b8bed4ed8c48ab16feae"}], "stats": {"total": 187, "additions": 71, "deletions": 116}, "files": [{"sha": "3e786da28dfe84224ba1cb9784b47e596c135a5d", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd4706413fb891ffe33ef06e0c229d97258fbfaf/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd4706413fb891ffe33ef06e0c229d97258fbfaf/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=cd4706413fb891ffe33ef06e0c229d97258fbfaf", "patch": "@@ -1,10 +1,10 @@\n+use crate::utils::qualify_min_const_fn::is_min_const_fn;\n use crate::utils::{fn_has_unsatisfiable_preds, has_drop, is_entrypoint_fn, span_lint, trait_ref_of_method};\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use crate::utils::qualify_min_const_fn::is_min_const_fn;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;"}, {"sha": "dfe2aadffc04d6757454d2f262182d70aa8b6048", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd4706413fb891ffe33ef06e0c229d97258fbfaf/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd4706413fb891ffe33ef06e0c229d97258fbfaf/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=cd4706413fb891ffe33ef06e0c229d97258fbfaf", "patch": "@@ -18,9 +18,9 @@ pub mod internal_lints;\n pub mod numeric_literal;\n pub mod paths;\n pub mod ptr;\n+pub mod qualify_min_const_fn;\n pub mod sugg;\n pub mod usage;\n-pub mod qualify_min_const_fn;\n \n pub use self::attrs::*;\n pub use self::diagnostics::*;"}, {"sha": "c1684575930d87da47dfe2c2b4e3a75e5578dc5f", "filename": "clippy_lints/src/utils/qualify_min_const_fn.rs", "status": "modified", "additions": 69, "deletions": 114, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/cd4706413fb891ffe33ef06e0c229d97258fbfaf/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd4706413fb891ffe33ef06e0c229d97258fbfaf/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs?ref=cd4706413fb891ffe33ef06e0c229d97258fbfaf", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n-use rustc_span::symbol::{sym};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use std::borrow::Cow;\n@@ -23,15 +23,9 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                 | ty::PredicateAtom::ConstEvaluatable(..)\n                 | ty::PredicateAtom::ConstEquate(..)\n                 | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n-                ty::PredicateAtom::ObjectSafe(_) => {\n-                    panic!(\"object safe predicate on function: {:#?}\", predicate)\n-                }\n-                ty::PredicateAtom::ClosureKind(..) => {\n-                    panic!(\"closure kind predicate on function: {:#?}\", predicate)\n-                }\n-                ty::PredicateAtom::Subtype(_) => {\n-                    panic!(\"subtype predicate on function: {:#?}\", predicate)\n-                }\n+                ty::PredicateAtom::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n+                ty::PredicateAtom::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n+                ty::PredicateAtom::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n                 ty::PredicateAtom::Trait(pred, _) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n@@ -47,12 +41,12 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                                  on const fn parameters are unstable\"\n                                     .into(),\n                             ));\n-                        }\n+                        },\n                         // other kinds of bounds are either tautologies\n                         // or cause errors in other passes\n                         _ => continue,\n                     }\n-                }\n+                },\n             }\n         }\n         match predicates.parent {\n@@ -92,24 +86,23 @@ fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n \n         match ty.kind() {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n-                    return Err((span, \"mutable references in const fn are unstable\".into()));\n-            }\n+                return Err((span, \"mutable references in const fn are unstable\".into()));\n+            },\n             ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n-                    return Err((span, \"function pointers in const fn are unstable\".into()));\n-            }\n+                return Err((span, \"function pointers in const fn are unstable\".into()));\n+            },\n             ty::Dynamic(preds, _) => {\n                 for pred in preds.iter() {\n                     match pred.skip_binder() {\n-                        ty::ExistentialPredicate::AutoTrait(_)\n-                        | ty::ExistentialPredicate::Projection(_) => {\n+                        ty::ExistentialPredicate::AutoTrait(_) | ty::ExistentialPredicate::Projection(_) => {\n                             return Err((\n                                 span,\n                                 \"trait bounds other than `Sized` \\\n                                  on const fn parameters are unstable\"\n                                     .into(),\n                             ));\n-                        }\n+                        },\n                         ty::ExistentialPredicate::Trait(trait_ref) => {\n                             if Some(trait_ref.def_id) != tcx.lang_items().sized_trait() {\n                                 return Err((\n@@ -119,55 +112,40 @@ fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n                                         .into(),\n                                 ));\n                             }\n-                        }\n+                        },\n                     }\n                 }\n-            }\n-            _ => {}\n+            },\n+            _ => {},\n         }\n     }\n     Ok(())\n }\n \n-fn check_rvalue(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    def_id: DefId,\n-    rvalue: &Rvalue<'tcx>,\n-    span: Span,\n-) -> McfResult {\n+fn check_rvalue(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, rvalue: &Rvalue<'tcx>, span: Span) -> McfResult {\n     match rvalue {\n-        Rvalue::ThreadLocalRef(_) => {\n-            Err((span, \"cannot access thread local storage in const fn\".into()))\n-        }\n-        Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n-            check_operand(tcx, operand, span, body)\n-        }\n-        Rvalue::Len(place)\n-        | Rvalue::Discriminant(place)\n-        | Rvalue::Ref(_, _, place)\n-        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span,  body),\n+        Rvalue::ThreadLocalRef(_) => Err((span, \"cannot access thread local storage in const fn\".into())),\n+        Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => check_operand(tcx, operand, span, body),\n+        Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+            check_place(tcx, *place, span, body)\n+        },\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n             let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n             match (cast_in, cast_out) {\n                 (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                     Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n-                }\n+                },\n                 _ => check_operand(tcx, operand, span, body),\n             }\n-        }\n-        Rvalue::Cast(\n-            CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer),\n-            operand,\n-            _,\n-        ) => check_operand(tcx, operand, span, body),\n+        },\n+        Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer), operand, _) => {\n+            check_operand(tcx, operand, span, body)\n+        },\n         Rvalue::Cast(\n             CastKind::Pointer(\n-                PointerCast::UnsafeFnPointer\n-                | PointerCast::ClosureFnPointer(_)\n-                | PointerCast::ReifyFnPointer,\n+                PointerCast::UnsafeFnPointer | PointerCast::ClosureFnPointer(_) | PointerCast::ReifyFnPointer,\n             ),\n             _,\n             _,\n@@ -177,10 +155,7 @@ fn check_rvalue(\n                 deref_ty.ty\n             } else {\n                 // We cannot allow this for now.\n-                return Err((\n-                    span,\n-                    \"unsizing casts are only allowed for references right now\".into(),\n-                ));\n+                return Err((span, \"unsizing casts are only allowed for references right now\".into()));\n             };\n             let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n             if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n@@ -191,7 +166,7 @@ fn check_rvalue(\n                 // We just can't allow trait objects until we have figured out trait method calls.\n                 Err((span, \"unsizing casts are not allowed in const fn\".into()))\n             }\n-        }\n+        },\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n             check_operand(tcx, lhs, span, body)?;\n@@ -200,53 +175,45 @@ fn check_rvalue(\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n                 Ok(())\n             } else {\n-                Err((span, \"only int, `bool` and `char` operations are stable in const fn\".into()))\n+                Err((\n+                    span,\n+                    \"only int, `bool` and `char` operations are stable in const fn\".into(),\n+                ))\n             }\n-        }\n+        },\n         Rvalue::NullaryOp(NullOp::SizeOf, _) => Ok(()),\n-        Rvalue::NullaryOp(NullOp::Box, _) => {\n-            Err((span, \"heap allocations are not allowed in const fn\".into()))\n-        }\n+        Rvalue::NullaryOp(NullOp::Box, _) => Err((span, \"heap allocations are not allowed in const fn\".into())),\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {\n                 check_operand(tcx, operand, span, body)\n             } else {\n                 Err((span, \"only int and `bool` operations are stable in const fn\".into()))\n             }\n-        }\n+        },\n         Rvalue::Aggregate(_, operands) => {\n             for operand in operands {\n                 check_operand(tcx, operand, span, body)?;\n             }\n             Ok(())\n-        }\n+        },\n     }\n }\n \n-fn check_statement(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    def_id: DefId,\n-    statement: &Statement<'tcx>,\n-) -> McfResult {\n+fn check_statement(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, statement: &Statement<'tcx>) -> McfResult {\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(box (place, rval)) => {\n-            check_place(tcx, *place, span,  body)?;\n+            check_place(tcx, *place, span, body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n-        }\n+        },\n \n         StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, body),\n \n         // just an assignment\n-        StatementKind::SetDiscriminant { place, .. } => {\n-            check_place(tcx, **place, span,  body)\n-        }\n+        StatementKind::SetDiscriminant { place, .. } => check_place(tcx, **place, span, body),\n \n-        StatementKind::LlvmInlineAsm { .. } => {\n-            Err((span, \"cannot use inline assembly in const fn\".into()))\n-        }\n+        StatementKind::LlvmInlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n \n         // These are all NOPs\n         StatementKind::StorageLive(_)\n@@ -258,12 +225,7 @@ fn check_statement(\n     }\n }\n \n-fn check_operand(\n-    tcx: TyCtxt<'tcx>,\n-    operand: &Operand<'tcx>,\n-    span: Span,\n-    body: &Body<'tcx>,\n-) -> McfResult {\n+fn check_operand(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n     match operand {\n         Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n@@ -273,12 +235,7 @@ fn check_operand(\n     }\n }\n \n-fn check_place(\n-    tcx: TyCtxt<'tcx>,\n-    place: Place<'tcx>,\n-    span: Span,\n-    body: &Body<'tcx>,\n-) -> McfResult {\n+fn check_place(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n     let mut cursor = place.projection.as_ref();\n     while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n@@ -288,26 +245,22 @@ fn check_place(\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {\n-                            return Err((span, \"accessing union fields is unstable\".into()));\n+                        return Err((span, \"accessing union fields is unstable\".into()));\n                     }\n                 }\n-            }\n+            },\n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Downcast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Deref\n-            | ProjectionElem::Index(_) => {}\n+            | ProjectionElem::Index(_) => {},\n         }\n     }\n \n     Ok(())\n }\n \n-fn check_terminator(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n-    terminator: &Terminator<'tcx>,\n-) -> McfResult {\n+fn check_terminator(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, terminator: &Terminator<'tcx>) -> McfResult {\n     let span = terminator.source_info.span;\n     match &terminator.kind {\n         TerminatorKind::FalseEdge { .. }\n@@ -317,20 +270,23 @@ fn check_terminator(\n         | TerminatorKind::Resume\n         | TerminatorKind::Unreachable => Ok(()),\n \n-        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span,  body),\n+        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, body),\n         TerminatorKind::DropAndReplace { place, value, .. } => {\n-            check_place(tcx, *place, span,  body)?;\n+            check_place(tcx, *place, span, body)?;\n             check_operand(tcx, value, span, body)\n-        }\n+        },\n \n-        TerminatorKind::SwitchInt { discr, switch_ty: _, values: _, targets: _ } => {\n-            check_operand(tcx, discr, span, body)\n-        }\n+        TerminatorKind::SwitchInt {\n+            discr,\n+            switch_ty: _,\n+            values: _,\n+            targets: _,\n+        } => check_operand(tcx, discr, span, body),\n \n         TerminatorKind::Abort => Err((span, \"abort is not stable in const fn\".into())),\n         TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n             Err((span, \"const fn generators are unstable\".into()))\n-        }\n+        },\n \n         TerminatorKind::Call {\n             func,\n@@ -342,8 +298,7 @@ fn check_terminator(\n         } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(fn_def_id, _) = *fn_ty.kind() {\n-                if !rustc_mir::const_eval::is_min_const_fn(tcx, fn_def_id)\n-                {\n+                if !rustc_mir::const_eval::is_min_const_fn(tcx, fn_def_id) {\n                     return Err((\n                         span,\n                         format!(\n@@ -359,9 +314,7 @@ fn check_terminator(\n                 // within const fns. `transmute` is allowed in all other const contexts.\n                 // This won't really scale to more intrinsics or functions. Let's allow const\n                 // transmutes in const fn before we add more hacks to this.\n-                if tcx.fn_sig(fn_def_id).abi() == RustIntrinsic\n-                    && tcx.item_name(fn_def_id) == sym::transmute\n-                {\n+                if tcx.fn_sig(fn_def_id).abi() == RustIntrinsic && tcx.item_name(fn_def_id) == sym::transmute {\n                     return Err((\n                         span,\n                         \"can only call `transmute` from const items, not `const fn`\".into(),\n@@ -377,14 +330,16 @@ fn check_terminator(\n             } else {\n                 Err((span, \"can only call other const fns within const fn\".into()))\n             }\n-        }\n+        },\n \n-        TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n-            check_operand(tcx, cond, span, body)\n-        }\n+        TerminatorKind::Assert {\n+            cond,\n+            expected: _,\n+            msg: _,\n+            target: _,\n+            cleanup: _,\n+        } => check_operand(tcx, cond, span, body),\n \n-        TerminatorKind::InlineAsm { .. } => {\n-            Err((span, \"cannot use inline assembly in const fn\".into()))\n-        }\n+        TerminatorKind::InlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n     }\n }"}]}