{"sha": "2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMTFlODFmMWU5NGM3ODgzYzdkZGU2OTRlOWJhNmY3YTU2MmRkOTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-15T17:35:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-15T17:35:59Z"}, "message": "Rollup merge of #64250 - Xanewok:save-analysis-assoc-nested, r=varkor\n\nsave-analysis: Nest typeck tables when processing functions/methods\n\nFixes an issue where we did not nest tables correctly when resolving\nassociated types in formal argument/return type positions.\n\nThis was the minimized reproduction case that I tested the fix on:\n```rust\npub trait Trait {\n    type Assoc;\n}\n\npub struct A;\n\npub fn func() {\n    fn _inner1<U: Trait>(_: U::Assoc) {}\n    fn _inner2<U: Trait>() -> U::Assoc { unimplemented!() }\n\n    impl A {\n        fn _inner1<U: Trait>(self, _: U::Assoc) {}\n        fn _inner2<U: Trait>(self) -> U::Assoc { unimplemented!() }\n    }\n}\n```\nusing `debug_assertions`-enabled rustc and by additionally passing `-Zsave-analysis`.\n\nUnfortunately the original assertion fired is a *debug* one and from what I can tell we don't run the tests with these on, so I'm not adding a test here. If I missed it and there is a way to run tests with these on, I'd love to add a test case for this.\n\nCloses #63663\nCloses #50328\nCloses #43982", "tree": {"sha": "113a8dcc0720bc0c29b993f5afd6626c324cd40a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/113a8dcc0720bc0c29b993f5afd6626c324cd40a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdfnZ/CRBK7hj4Ov3rIwAAdHIIAHVTy3XNar7eCQRHfds7QTsr\nBH43ijPMhKRgINM2U/L9tVryONpGtsH4y3NLiaBVunWWCk7DDIo+q5EigxpagkEt\nzFB7v68eDcS2ldebnuNDddjbwXg5raXDU5x/e1CJA6YF7prC6wDvwTYdHDwFgUiW\nTDHkvvrSg+5kDbfEi2RMZeHMzscov4PPee8yXj96DAC2REUPCP0LUoGuS/XM4B3Z\noiz4hBI9nAeZE6ctXPz5l+RSS5sVy8SVS2et7bGL1AihcBjB1ApBe/gF7N1H2ynB\nRYJJK0B6i0UtFGbmmFkPmyWqVdQ+cTL5zsoQ+Vb+6NKlvvSqrOWDqQOsJpMcHmA=\n=TUbQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 113a8dcc0720bc0c29b993f5afd6626c324cd40a\nparent 0a2e07ec1dc5194e12dfb1ca00c4bc87533ac88d\nparent a946b8d6e1ff39f22e3f9f1c46ba81898901d907\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568568959 +0200\ncommitter GitHub <noreply@github.com> 1568568959 +0200\n\nRollup merge of #64250 - Xanewok:save-analysis-assoc-nested, r=varkor\n\nsave-analysis: Nest typeck tables when processing functions/methods\n\nFixes an issue where we did not nest tables correctly when resolving\nassociated types in formal argument/return type positions.\n\nThis was the minimized reproduction case that I tested the fix on:\n```rust\npub trait Trait {\n    type Assoc;\n}\n\npub struct A;\n\npub fn func() {\n    fn _inner1<U: Trait>(_: U::Assoc) {}\n    fn _inner2<U: Trait>() -> U::Assoc { unimplemented!() }\n\n    impl A {\n        fn _inner1<U: Trait>(self, _: U::Assoc) {}\n        fn _inner2<U: Trait>(self) -> U::Assoc { unimplemented!() }\n    }\n}\n```\nusing `debug_assertions`-enabled rustc and by additionally passing `-Zsave-analysis`.\n\nUnfortunately the original assertion fired is a *debug* one and from what I can tell we don't run the tests with these on, so I'm not adding a test here. If I missed it and there is a way to run tests with these on, I'd love to add a test case for this.\n\nCloses #63663\nCloses #50328\nCloses #43982\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "html_url": "https://github.com/rust-lang/rust/commit/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a2e07ec1dc5194e12dfb1ca00c4bc87533ac88d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2e07ec1dc5194e12dfb1ca00c4bc87533ac88d", "html_url": "https://github.com/rust-lang/rust/commit/0a2e07ec1dc5194e12dfb1ca00c4bc87533ac88d"}, {"sha": "a946b8d6e1ff39f22e3f9f1c46ba81898901d907", "url": "https://api.github.com/repos/rust-lang/rust/commits/a946b8d6e1ff39f22e3f9f1c46ba81898901d907", "html_url": "https://github.com/rust-lang/rust/commit/a946b8d6e1ff39f22e3f9f1c46ba81898901d907"}], "stats": {"total": 193, "additions": 113, "deletions": 80}, "files": [{"sha": "0155803e30580ace326f457a2559e75a2ef5836b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "patch": "@@ -205,26 +205,24 @@ pub struct LocalTableInContext<'a, V> {\n fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n                                      hir_id: hir::HirId,\n                                      mut_access: bool) {\n-    if cfg!(debug_assertions) {\n-        if let Some(local_id_root) = local_id_root {\n-            if hir_id.owner != local_id_root.index {\n-                ty::tls::with(|tcx| {\n-                    bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n-                          TypeckTables with local_id_root {:?}\",\n-                         tcx.hir().node_to_string(hir_id),\n-                         DefId::local(hir_id.owner),\n-                         local_id_root)\n-                });\n-            }\n-        } else {\n-            // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-            // These are just expected to be empty and their `local_id_root` is\n-            // `None`. Therefore we cannot verify whether a given `HirId` would\n-            // be a valid key for the given table. Instead we make sure that\n-            // nobody tries to write to such a Null Object table.\n-            if mut_access {\n-                bug!(\"access to invalid TypeckTables\")\n-            }\n+    if let Some(local_id_root) = local_id_root {\n+        if hir_id.owner != local_id_root.index {\n+            ty::tls::with(|tcx| {\n+                bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                        TypeckTables with local_id_root {:?}\",\n+                        tcx.hir().node_to_string(hir_id),\n+                        DefId::local(hir_id.owner),\n+                        local_id_root)\n+            });\n+        }\n+    } else {\n+        // We use \"Null Object\" TypeckTables in some of the analysis passes.\n+        // These are just expected to be empty and their `local_id_root` is\n+        // `None`. Therefore we cannot verify whether a given `HirId` would\n+        // be a valid key for the given table. Instead we make sure that\n+        // nobody tries to write to such a Null Object table.\n+        if mut_access {\n+            bug!(\"access to invalid TypeckTables\")\n         }\n     }\n }"}, {"sha": "55f6b91e7143106e336086ffb4ef0142f6969222", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 63, "deletions": 56, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "patch": "@@ -130,6 +130,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.save_ctxt.span_from_span(span)\n     }\n \n+    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n+        self.save_ctxt.lookup_def_id(ref_id)\n+    }\n+\n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n@@ -223,13 +227,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        match self.save_ctxt.get_path_res(ref_id) {\n-            Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => None,\n-            def => Some(def.def_id()),\n-        }\n-    }\n-\n     fn process_formals(&mut self, formals: &'l [ast::Param], qualname: &str) {\n         for arg in formals {\n             self.visit_pat(&arg.pat);\n@@ -283,36 +280,32 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident, span) {\n-            let sig_str = crate::make_signature(&sig.decl, &generics);\n-            if body.is_some() {\n-                self.nest_tables(\n-                    id,\n-                    |v| v.process_formals(&sig.decl.inputs, &method_data.qualname),\n-                );\n-            }\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        self.nest_tables(id, |v| {\n+            if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n+                v.process_formals(&sig.decl.inputs, &method_data.qualname);\n+                v.process_generic_params(&generics, &method_data.qualname, id);\n \n-            self.process_generic_params(&generics, &method_data.qualname, id);\n+                method_data.value = crate::make_signature(&sig.decl, &generics);\n+                method_data.sig = sig::method_signature(id, ident, generics, sig, &v.save_ctxt);\n \n-            method_data.value = sig_str;\n-            method_data.sig = sig::method_signature(id, ident, generics, sig, &self.save_ctxt);\n-            let hir_id = self.tcx.hir().node_to_hir_id(id);\n-            self.dumper.dump_def(&access_from_vis!(self.save_ctxt, vis, hir_id), method_data);\n-        }\n+                v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, hir_id), method_data);\n+            }\n \n-        // walk arg and return types\n-        for arg in &sig.decl.inputs {\n-            self.visit_ty(&arg.ty);\n-        }\n+            // walk arg and return types\n+            for arg in &sig.decl.inputs {\n+                v.visit_ty(&arg.ty);\n+            }\n \n-        if let ast::FunctionRetTy::Ty(ref ret_ty) = sig.decl.output {\n-            self.visit_ty(ret_ty);\n-        }\n+            if let ast::FunctionRetTy::Ty(ref ret_ty) = sig.decl.output {\n+                v.visit_ty(ret_ty);\n+            }\n \n-        // walk the fn body\n-        if let Some(body) = body {\n-            self.nest_tables(id, |v| v.visit_block(body));\n-        }\n+            // walk the fn body\n+            if let Some(body) = body {\n+                v.visit_block(body);\n+            }\n+        });\n     }\n \n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n@@ -377,26 +370,31 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         ty_params: &'l ast::Generics,\n         body: &'l ast::Block,\n     ) {\n-        if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(fn_data, DefData, item.span);\n-            self.nest_tables(\n-                item.id,\n-                |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n-            );\n-            self.process_generic_params(ty_params, &fn_data.qualname, item.id);\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, hir_id), fn_data);\n-        }\n+        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        self.nest_tables(item.id, |v| {\n+            if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n+                down_cast_data!(fn_data, DefData, item.span);\n+                v.process_formals(&decl.inputs, &fn_data.qualname);\n+                v.process_generic_params(ty_params, &fn_data.qualname, item.id);\n \n-        for arg in &decl.inputs {\n-            self.visit_ty(&arg.ty);\n-        }\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), fn_data);\n+            }\n \n-        if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n-            self.visit_ty(&ret_ty);\n-        }\n+            for arg in &decl.inputs {\n+                v.visit_ty(&arg.ty)\n+            }\n+\n+            if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n+                if let ast::TyKind::ImplTrait(..) = ret_ty.node {\n+                    // FIXME: Opaque type desugaring prevents us from easily\n+                    // processing trait bounds. See `visit_ty` for more details.\n+                } else {\n+                    v.visit_ty(&ret_ty);\n+                }\n+            }\n \n-        self.nest_tables(item.id, |v| v.visit_block(&body));\n+            v.visit_block(&body);\n+        });\n     }\n \n     fn process_static_or_const_item(\n@@ -1113,11 +1111,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n-                for bound in bounds.iter() {\n-                    if let ast::GenericBound::Trait(trait_ref, _) = bound {\n-                        self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n-                    }\n-                }\n+                self.process_bounds(&bounds);\n             }\n             ast::ImplItemKind::Macro(_) => {}\n         }\n@@ -1364,10 +1358,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.visit_ty(&ty);\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n-            OpaqueTy(ref _bounds, ref ty_params) => {\n+            OpaqueTy(ref bounds, ref ty_params) => {\n                 let qualname = format!(\"::{}\",\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n-                // FIXME do something with _bounds\n+\n                 let value = String::new();\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n@@ -1393,6 +1387,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     );\n                 }\n \n+                self.process_bounds(bounds);\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Mac(_) => (),\n@@ -1449,6 +1444,18 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.visit_ty(element);\n                 self.nest_tables(length.id, |v| v.visit_expr(&length.value));\n             }\n+            ast::TyKind::ImplTrait(id, ref bounds) => {\n+                // FIXME: As of writing, the opaque type lowering introduces\n+                // another DefPath scope/segment (used to declare the resulting\n+                // opaque type item).\n+                // However, the synthetic scope does *not* have associated\n+                // typeck tables, which means we can't nest it and we fire an\n+                // assertion when resolving the qualified type paths in trait\n+                // bounds...\n+                // This will panic if called on return type `impl Trait`, which\n+                // we guard against in `process_fn`.\n+                self.nest_tables(id, |v| v.process_bounds(bounds));\n+            }\n             _ => visit::walk_ty(self, t),\n         }\n     }"}, {"sha": "055ccf6c2c4f83c3270fbb4d71dbf3f00f33f481", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "patch": "@@ -312,7 +312,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     let impl_id = self.next_impl_id();\n                     let span = self.span_from_span(sub_span);\n \n-                    let type_data = self.lookup_ref_id(typ.id);\n+                    let type_data = self.lookup_def_id(typ.id);\n                     type_data.map(|type_data| {\n                         Data::RelationData(Relation {\n                             kind: RelationKind::Impl {\n@@ -322,7 +322,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                             from: id_from_def_id(type_data),\n                             to: trait_ref\n                                 .as_ref()\n-                                .and_then(|t| self.lookup_ref_id(t.ref_id))\n+                                .and_then(|t| self.lookup_def_id(t.ref_id))\n                                 .map(id_from_def_id)\n                                 .unwrap_or_else(|| null_id()),\n                         },\n@@ -495,7 +495,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_trait_ref_data(&self, trait_ref: &ast::TraitRef) -> Option<Ref> {\n-        self.lookup_ref_id(trait_ref.ref_id).and_then(|def_id| {\n+        self.lookup_def_id(trait_ref.ref_id).and_then(|def_id| {\n             let span = trait_ref.path.span;\n             if generated_code(span) {\n                 return None;\n@@ -870,7 +870,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         })\n     }\n \n-    fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n+    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n         match self.get_path_res(ref_id) {\n             Res::PrimTy(_) | Res::SelfTy(..) | Res::Err => None,\n             def => Some(def.def_id()),"}, {"sha": "92e85884f664dbcc43f88023f439d802f08e6009", "filename": "src/test/ui/save-analysis/issue-63663.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-63663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e11e81f1e94c7883c7dde694e9ba6f7a562dd91/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-63663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-63663.rs?ref=2e11e81f1e94c7883c7dde694e9ba6f7a562dd91", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+// compile-flags: -Zsave-analysis\n+\n+pub trait Trait {\n+    type Assoc;\n+}\n+\n+pub struct A;\n+\n+trait Generic<T> {}\n+impl<T> Generic<T> for () {}\n+\n+// Don't ICE when resolving type paths in return type `impl Trait`\n+fn assoc_in_opaque_type_bounds<U: Trait>() -> impl Generic<U::Assoc> {}\n+\n+// Check that this doesn't ICE when processing associated const in formal\n+// argument and return type of functions defined inside function/method scope.\n+pub fn func() {\n+    fn _inner1<U: Trait>(_: U::Assoc) {}\n+    fn _inner2<U: Trait>() -> U::Assoc { unimplemented!() }\n+\n+    impl A {\n+        fn _inner1<U: Trait>(self, _: U::Assoc) {}\n+        fn _inner2<U: Trait>(self) -> U::Assoc { unimplemented!() }\n+    }\n+}\n+\n+fn main() {}"}]}