{"sha": "8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkM2NmOTIzN2RjYzlkNGYyYTdjMGJkZTQyZGMxMzNlNjBmNTFjN2Q=", "commit": {"author": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2020-08-30T19:47:05Z"}, "committer": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2020-08-30T20:13:47Z"}, "message": "Improve documentation of slice::get_unchecked() / split_at_unchecked()\n\nThanks to Ivan Tham, who gave the majority of these suggestions during\ntheir review.", "tree": {"sha": "3d937fdb90e6a09067b0a3dc3aca734c78229cc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d937fdb90e6a09067b0a3dc3aca734c78229cc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d", "html_url": "https://github.com/rust-lang/rust/commit/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d/comments", "author": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08996ac543b4d330bef790ff9f727e99c7a539c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08996ac543b4d330bef790ff9f727e99c7a539c", "html_url": "https://github.com/rust-lang/rust/commit/d08996ac543b4d330bef790ff9f727e99c7a539c"}], "stats": {"total": 72, "additions": 41, "deletions": 31}, "files": [{"sha": "76d54ad93051620858c33e1af2472e711b8940d6", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d", "patch": "@@ -288,10 +288,12 @@ impl<T> [T] {\n     /// Returns a reference to an element or subslice, without doing bounds\n     /// checking.\n     ///\n-    /// This is generally not recommended, use with caution!\n+    /// For a safe alternative see [`get`].\n+    ///\n+    /// # Safety\n+    ///\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n-    /// For a safe alternative see [`get`].\n     ///\n     /// [`get`]: #method.get\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n@@ -320,10 +322,12 @@ impl<T> [T] {\n     /// Returns a mutable reference to an element or subslice, without doing\n     /// bounds checking.\n     ///\n-    /// This is generally not recommended, use with caution!\n+    /// For a safe alternative see [`get_mut`].\n+    ///\n+    /// # Safety\n+    ///\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n-    /// For a safe alternative see [`get_mut`].\n     ///\n     /// [`get_mut`]: #method.get_mut\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n@@ -1133,20 +1137,20 @@ impl<T> [T] {\n     ///\n     /// {\n     ///    let (left, right) = v.split_at(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    ///    assert_eq!(left, []);\n+    ///    assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n+    ///     assert_eq!(left, [1, 2]);\n+    ///     assert_eq!(right, [3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n+    ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);\n+    ///     assert_eq!(right, []);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1175,12 +1179,12 @@ impl<T> [T] {\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n     ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1, 0]);\n-    ///     assert!(right == [3, 0, 5, 6]);\n+    ///     assert_eq!(left, [1, 0]);\n+    ///     assert_eq!(right, [3, 0, 5, 6]);\n     ///     left[1] = 2;\n     ///     right[1] = 4;\n     /// }\n-    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n+    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1197,11 +1201,14 @@ impl<T> [T] {\n     /// the index `mid` itself) and the second will contain all\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n-    /// This is generally not recommended, use with caution!\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n     /// For a safe alternative see [`split_at`].\n     ///\n+    /// # Safety\n+    ///\n+    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting reference is not used. The caller has to ensure that\n+    /// `0 <= mid <= self.len()`.\n+    ///\n     /// [`split_at`]: #method.split_at\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n@@ -1214,26 +1221,26 @@ impl<T> [T] {\n     ///\n     /// unsafe {\n     ///    let (left, right) = v.split_at_unchecked(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    ///    assert_eq!(left, []);\n+    ///    assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// unsafe {\n     ///     let (left, right) = v.split_at_unchecked(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n+    ///     assert_eq!(left, [1, 2]);\n+    ///     assert_eq!(right, [3, 4, 5, 6]);\n     /// }\n     ///\n     /// unsafe {\n     ///     let (left, right) = v.split_at_unchecked(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n+    ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);\n+    ///     assert_eq!(right, []);\n     /// }\n     /// ```\n     #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n     #[inline]\n     unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n-        // SAFETY: Caller has to check that 0 <= mid < self.len()\n+        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n         unsafe { (self.get_unchecked(..mid), self.get_unchecked(mid..)) }\n     }\n \n@@ -1243,11 +1250,14 @@ impl<T> [T] {\n     /// the index `mid` itself) and the second will contain all\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n-    /// This is generally not recommended, use with caution!\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n     /// For a safe alternative see [`split_at_mut`].\n     ///\n+    /// # Safety\n+    ///\n+    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting reference is not used. The caller has to ensure that\n+    /// `0 <= mid <= self.len()`.\n+    ///\n     /// [`split_at_mut`]: #method.split_at_mut\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n@@ -1260,22 +1270,22 @@ impl<T> [T] {\n     /// // scoped to restrict the lifetime of the borrows\n     /// unsafe {\n     ///     let (left, right) = v.split_at_mut_unchecked(2);\n-    ///     assert!(left == [1, 0]);\n-    ///     assert!(right == [3, 0, 5, 6]);\n+    ///     assert_eq!(left, [1, 0]);\n+    ///     assert_eq!(right, [3, 0, 5, 6]);\n     ///     left[1] = 2;\n     ///     right[1] = 4;\n     /// }\n-    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n+    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n     /// ```\n     #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n     #[inline]\n     unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         let len = self.len();\n         let ptr = self.as_mut_ptr();\n \n-        // SAFETY: Caller has to check that 0 <= mid < self.len().\n+        // SAFETY: Caller has to check that `0 <= mid <= self.len()`.\n         //\n-        // [ptr; mid] and [mid; len] are not overlapping, so returning a mutable reference\n+        // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n         // is fine.\n         unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }\n     }"}]}