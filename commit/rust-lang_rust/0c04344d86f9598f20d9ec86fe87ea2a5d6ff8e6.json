{"sha": "0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMDQzNDRkODZmOTU5OGYyMGQ5ZWM4NmZlODdlYTJhNWQ2ZmY4ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-23T21:33:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-23T21:33:22Z"}, "message": "Auto merge of #73669 - Manishearth:rollup-0n4u7vq, r=Manishearth\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #72780 (Enforce doc alias check)\n - #72876 (Mention that BTreeMap::new() doesn't allocate)\n - #73244 (Check for assignments between non-conflicting generator saved locals)\n - #73488 (code coverage foundation for hash and num_counters)\n - #73523 (Fix -Z unpretty=everybody_loops)\n - #73587 (Move remaining `NodeId` APIs from `Definitions` to `Resolver`)\n - #73601 (Point at the call span when overflow occurs during monomorphization)\n - #73613 (The const propagator cannot trace references.)\n - #73614 (fix `intrinsics::needs_drop` docs)\n - #73630 (Provide context on E0308 involving fn items)\n - #73665 (rustc: Modernize wasm checks for atomics)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e6464d73da3f86b256a929ff1d520431f12956b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6464d73da3f86b256a929ff1d520431f12956b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "html_url": "https://github.com/rust-lang/rust/commit/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff5b446d2fdbd898bc97a751f2f72858de185cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff5b446d2fdbd898bc97a751f2f72858de185cf1", "html_url": "https://github.com/rust-lang/rust/commit/ff5b446d2fdbd898bc97a751f2f72858de185cf1"}, {"sha": "6ed6a844e19138fe78a6ed07a71e105792539f4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed6a844e19138fe78a6ed07a71e105792539f4f", "html_url": "https://github.com/rust-lang/rust/commit/6ed6a844e19138fe78a6ed07a71e105792539f4f"}], "stats": {"total": 1753, "additions": 1217, "deletions": 536}, "files": [{"sha": "b54566e7176b0db24feae34fda0f743323ecd4ea", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -4200,6 +4200,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_session\","}, {"sha": "350249f5db5198643b19cf97e0a94ec648da2243", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -490,6 +490,8 @@ struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n     ///\n+    /// Does not allocate anything on its own.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "2298958b88101c84d39f23aa45e1249214423c8a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1291,7 +1291,7 @@ extern \"rust-intrinsic\" {\n     /// implements `Copy`.\n     ///\n     /// If the actual type neither requires drop glue nor implements\n-    /// `Copy`, then may return `true` or `false`.\n+    /// `Copy`, then the return value of this function is unspecified.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::needs_drop`](../../std/mem/fn.needs_drop.html)."}, {"sha": "00665c4cafb6b4d24d23c180cddeecaa52cd0414", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -253,7 +253,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(_, FnSig { ref decl, header }, ref generics, ref body) => {\n-                let fn_def_id = self.resolver.definitions().local_def_id(id);\n+                let fn_def_id = self.resolver.local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n \n@@ -342,7 +342,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self_ty: ref ty,\n                 items: ref impl_items,\n             } => {\n-                let def_id = self.resolver.definitions().local_def_id(id);\n+                let def_id = self.resolver.local_def_id(id);\n \n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n@@ -646,7 +646,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n-        let def_id = self.resolver.definitions().local_def_id(i.id);\n+        let def_id = self.resolver.local_def_id(i.id);\n         hir::ForeignItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n@@ -747,7 +747,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n-        let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+        let trait_item_def_id = self.resolver.local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n@@ -812,7 +812,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n-        let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+        let impl_item_def_id = self.resolver.local_def_id(i.id);\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n@@ -1320,12 +1320,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                     if let Some(def_id) = def_id.as_local() {\n                                         for param in &generics.params {\n                                             if let GenericParamKind::Type { .. } = param.kind {\n-                                                if def_id\n-                                                    == self\n-                                                        .resolver\n-                                                        .definitions()\n-                                                        .local_def_id(param.id)\n-                                                {\n+                                                if def_id == self.resolver.local_def_id(param.id) {\n                                                     add_bounds\n                                                         .entry(param.id)\n                                                         .or_default()"}, {"sha": "39b14ac4588326dd66ca3b520d5d4b3edb496381", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -54,7 +54,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_session::config::nightly_options;\n use rustc_session::lint::{builtin::BARE_TRAIT_OBJECTS, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::ParseSess;\n@@ -205,6 +205,19 @@ pub trait Resolver {\n     fn next_node_id(&mut self) -> NodeId;\n \n     fn trait_map(&self) -> &NodeMap<Vec<hir::TraitCandidate>>;\n+\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n+\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId;\n+\n+    fn create_def(\n+        &mut self,\n+        parent: LocalDefId,\n+        node_id: ast::NodeId,\n+        data: DefPathData,\n+        expn_id: ExpnId,\n+        span: Span,\n+    ) -> LocalDefId;\n }\n \n type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n@@ -436,7 +449,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 match tree.kind {\n                     UseTreeKind::Simple(_, id1, id2) => {\n                         for &id in &[id1, id2] {\n-                            self.lctx.resolver.definitions().create_def_with_parent(\n+                            self.lctx.resolver.create_def(\n                                 owner,\n                                 id,\n                                 DefPathData::Misc,\n@@ -488,7 +501,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     | ItemKind::Enum(_, ref generics)\n                     | ItemKind::TyAlias(_, ref generics, ..)\n                     | ItemKind::Trait(_, _, ref generics, ..) => {\n-                        let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n+                        let def_id = self.lctx.resolver.local_def_id(item.id);\n                         let count = generics\n                             .params\n                             .iter()\n@@ -564,7 +577,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .map(|(&k, v)| (self.node_id_to_hir_id[k].unwrap(), v.clone()))\n             .collect();\n \n-        self.resolver.definitions().init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n+        let mut def_id_to_hir_id = IndexVec::default();\n+\n+        for (node_id, hir_id) in self.node_id_to_hir_id.into_iter_enumerated() {\n+            if let Some(def_id) = self.resolver.opt_local_def_id(node_id) {\n+                if def_id_to_hir_id.len() <= def_id.index() {\n+                    def_id_to_hir_id.resize(def_id.index() + 1, None);\n+                }\n+                def_id_to_hir_id[def_id] = hir_id;\n+            }\n+        }\n+\n+        self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n         hir::Crate {\n             item: hir::CrateItem { module, attrs, span: c.span },\n@@ -628,7 +652,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n             .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n-        let def_id = self.resolver.definitions().local_def_id(owner);\n+        let def_id = self.resolver.local_def_id(owner);\n         self.current_hir_id_owner.push((def_id, counter));\n         let ret = f(self);\n         let (new_def_id, new_counter) = self.current_hir_id_owner.pop().unwrap();\n@@ -671,8 +695,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n \n             *local_id_counter += 1;\n-            let owner = this.resolver.definitions().opt_local_def_id(owner).expect(\n-                \"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n+            let owner = this.resolver.opt_local_def_id(owner).expect(\n+                \"you forgot to call `create_def` or are lowering node-IDs \\\n                  that do not belong to the current owner\",\n             );\n \n@@ -800,7 +824,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n \n         // Add a definition for the in-band lifetime def.\n-        self.resolver.definitions().create_def_with_parent(\n+        self.resolver.create_def(\n             parent_def_id,\n             node_id,\n             DefPathData::LifetimeNs(str_name),\n@@ -1088,7 +1112,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                     let impl_trait_node_id = self.resolver.next_node_id();\n                     let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n-                    self.resolver.definitions().create_def_with_parent(\n+                    self.resolver.create_def(\n                         parent_def_id,\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n@@ -1154,7 +1178,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             let node_id = self.resolver.next_node_id();\n \n                             // Add a definition for the in-band const def.\n-                            self.resolver.definitions().create_def_with_parent(\n+                            self.resolver.create_def(\n                                 parent_def_id,\n                                 node_id,\n                                 DefPathData::AnonConst,\n@@ -1339,7 +1363,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         // Add a definition for the in-band `Param`.\n-                        let def_id = self.resolver.definitions().local_def_id(def_node_id);\n+                        let def_id = self.resolver.local_def_id(def_node_id);\n \n                         let hir_bounds = self.lower_param_bounds(\n                             bounds,\n@@ -1428,7 +1452,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.resolver.definitions().local_def_id(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n@@ -1620,7 +1644,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let def_node_id = self.context.resolver.next_node_id();\n                     let hir_id =\n                         self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n-                    self.context.resolver.definitions().create_def_with_parent(\n+                    self.context.resolver.create_def(\n                         self.parent,\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().name),\n@@ -1870,7 +1894,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.resolver.definitions().local_def_id(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n "}, {"sha": "54271d3dd04919e61a9fad93c31e8d1007ba2c59", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -23,6 +23,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n use rustc_session::Session;\n+use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n use rustc_target::spec::{CodeModel, RelocModel};\n \n@@ -140,7 +141,7 @@ pub fn target_machine_factory(\n     // lower atomic operations to single-threaded operations.\n     if singlethread\n         && sess.target.target.llvm_target.contains(\"wasm32\")\n-        && features.iter().any(|s| *s == \"+atomics\")\n+        && sess.target_features.contains(&sym::atomics)\n     {\n         singlethread = false;\n     }"}, {"sha": "0a1cc31044a228557ba0f64ef3287e0c1a6eb6ef", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -23,7 +23,6 @@ use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n-use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n@@ -141,26 +140,20 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             \"count_code_region\" => {\n-                if let ty::InstanceDef::Item(fn_def_id) = caller_instance.def {\n-                    let caller_fn_path = tcx.def_path_str(fn_def_id);\n-                    debug!(\n-                        \"count_code_region to llvm.instrprof.increment(fn_name={})\",\n-                        caller_fn_path\n-                    );\n-\n-                    // FIXME(richkadel): (1) Replace raw function name with mangled function name;\n-                    // (2) Replace hardcoded `1234` in `hash` with a computed hash (as discussed in)\n-                    // the MCP (compiler-team/issues/278); and replace the hardcoded `1` for\n-                    // `num_counters` with the actual number of counters per function (when the\n-                    // changes are made to inject more than one counter per function).\n-                    let (fn_name, _len_val) = self.const_str(Symbol::intern(&caller_fn_path));\n-                    let index = args[0].immediate();\n-                    let hash = self.const_u64(1234);\n-                    let num_counters = self.const_u32(1);\n-                    self.instrprof_increment(fn_name, hash, num_counters, index)\n-                } else {\n-                    bug!(\"intrinsic count_code_region: no src.instance\");\n-                }\n+                // FIXME(richkadel): The current implementation assumes the MIR for the given\n+                // caller_instance represents a single function. Validate and/or correct if inlining\n+                // and/or monomorphization invalidates these assumptions.\n+                let coverage_data = tcx.coverage_data(caller_instance.def_id());\n+                let mangled_fn = tcx.symbol_name(caller_instance);\n+                let (mangled_fn_name, _len_val) = self.const_str(mangled_fn.name);\n+                let hash = self.const_u64(coverage_data.hash);\n+                let num_counters = self.const_u32(coverage_data.num_counters);\n+                let index = args[0].immediate();\n+                debug!(\n+                    \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    mangled_fn.name, hash, num_counters, index\n+                );\n+                self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n             }\n             \"va_start\" => self.va_start(args[0].immediate()),\n             \"va_end\" => self.va_end(args[0].immediate()),"}, {"sha": "d6ef94bfd1727352d154943afa1ef06bbf1510dd", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,6 +1,7 @@\n use super::archive;\n use super::command::Command;\n use super::symbol_export;\n+use rustc_span::symbol::sym;\n \n use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n@@ -1036,9 +1037,7 @@ impl<'a> WasmLd<'a> {\n         //\n         // * `--export=*tls*` - when `#[thread_local]` symbols are used these\n         //   symbols are how the TLS segments are initialized and configured.\n-        let atomics = sess.opts.cg.target_feature.contains(\"+atomics\")\n-            || sess.target.target.options.features.contains(\"+atomics\");\n-        if atomics {\n+        if sess.target_features.contains(&sym::atomics) {\n             cmd.arg(\"--shared-memory\");\n             cmd.arg(\"--max-memory=1073741824\");\n             cmd.arg(\"--import-memory\");"}, {"sha": "b45ab0f80ffac4a4cd2c4b3b1c4068d3b0b32a26", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -307,6 +307,7 @@ pub fn run_compiler(\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n                 }\n+                trace!(\"finished pretty-printing\");\n                 return early_exit();\n             }\n "}, {"sha": "79b70682739326b1ea18c4254e7cbc83fbade8d1", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 30, "deletions": 119, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -8,14 +8,12 @@ pub use crate::def_id::DefPathHash;\n use crate::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::hir;\n \n-use rustc_ast::ast;\n use rustc_ast::crate_disambiguator::CrateDisambiguator;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n \n use log::debug;\n use std::fmt::Write;\n@@ -73,17 +71,12 @@ impl DefPathTable {\n }\n \n /// The definition table containing node definitions.\n-/// It holds the `DefPathTable` for local `DefId`s/`DefPath`s and it also stores a\n-/// mapping from `NodeId`s to local `DefId`s.\n-#[derive(Clone, Default)]\n+/// It holds the `DefPathTable` for `LocalDefId`s/`DefPath`s.\n+/// It also stores mappings to convert `LocalDefId`s to/from `HirId`s.\n+#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n \n-    def_id_to_span: IndexVec<LocalDefId, Span>,\n-\n-    node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n-    def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n-\n     // FIXME(eddyb) ideally all `LocalDefId`s would be HIR owners.\n     pub(super) def_id_to_hir_id: IndexVec<LocalDefId, Option<hir::HirId>>,\n     /// The reverse mapping of `def_id_to_hir_id`.\n@@ -94,12 +87,6 @@ pub struct Definitions {\n     parent_modules_of_macro_defs: FxHashMap<ExpnId, DefId>,\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n-    /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n-    /// we know what parent node that fragment should be attached to thanks to this table.\n-    invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n-    /// Indices of unnamed struct or variant fields with unresolved attributes.\n-    placeholder_field_indices: FxHashMap<ast::NodeId, usize>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -319,16 +306,6 @@ impl Definitions {\n         })\n     }\n \n-    #[inline]\n-    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<LocalDefId> {\n-        self.node_id_to_def_id.get(&node).copied()\n-    }\n-\n-    #[inline]\n-    pub fn local_def_id(&self, node: ast::NodeId) -> LocalDefId {\n-        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n-    }\n-\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n         self.local_def_id_to_hir_id(def_id)\n@@ -349,18 +326,8 @@ impl Definitions {\n         self.hir_id_to_def_id.get(&hir_id).copied()\n     }\n \n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n-    #[inline]\n-    pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        if let Some(def_id) = def_id.as_local() { Some(self.def_id_to_span[def_id]) } else { None }\n-    }\n-\n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    pub fn create_root_def(\n-        &mut self,\n-        crate_name: &str,\n-        crate_disambiguator: CrateDisambiguator,\n-    ) -> LocalDefId {\n+    pub fn new(crate_name: &str, crate_disambiguator: CrateDisambiguator) -> Definitions {\n         let key = DefKey {\n             parent: None,\n             disambiguated_data: DisambiguatedDefPathData {\n@@ -372,52 +339,39 @@ impl Definitions {\n         let parent_hash = DefKey::root_parent_stable_hash(crate_name, crate_disambiguator);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n-        // Create the definition.\n-        let root = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n+        // Create the root definition.\n+        let mut table = DefPathTable::default();\n+        let root = LocalDefId { local_def_index: table.allocate(key, def_path_hash) };\n         assert_eq!(root.local_def_index, CRATE_DEF_INDEX);\n \n-        assert_eq!(self.def_id_to_node_id.push(ast::CRATE_NODE_ID), root);\n-        assert_eq!(self.def_id_to_span.push(rustc_span::DUMMY_SP), root);\n-\n-        self.node_id_to_def_id.insert(ast::CRATE_NODE_ID, root);\n-        self.set_invocation_parent(ExpnId::root(), root);\n+        Definitions {\n+            table,\n+            def_id_to_hir_id: Default::default(),\n+            hir_id_to_def_id: Default::default(),\n+            expansions_that_defined: Default::default(),\n+            parent_modules_of_macro_defs: Default::default(),\n+        }\n+    }\n \n-        root\n+    /// Retrieves the root definition.\n+    pub fn get_root_def(&self) -> LocalDefId {\n+        LocalDefId { local_def_index: CRATE_DEF_INDEX }\n     }\n \n     /// Adds a definition with a parent definition.\n-    pub fn create_def_with_parent(\n+    pub fn create_def(\n         &mut self,\n         parent: LocalDefId,\n-        node_id: ast::NodeId,\n         data: DefPathData,\n         expn_id: ExpnId,\n-        span: Span,\n+        mut next_disambiguator: impl FnMut(LocalDefId, DefPathData) -> u32,\n     ) -> LocalDefId {\n-        debug!(\n-            \"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n-            parent, node_id, data\n-        );\n-\n-        assert!(\n-            !self.node_id_to_def_id.contains_key(&node_id),\n-            \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n-            node_id,\n-            data,\n-            self.table.def_key(self.node_id_to_def_id[&node_id].local_def_index),\n-        );\n+        debug!(\"create_def(parent={:?}, data={:?}, expn_id={:?})\", parent, data, expn_id);\n \n         // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n \n-        // Find the next free disambiguator for this key.\n-        let disambiguator = {\n-            let next_disamb = self.next_disambiguator.entry((parent, data)).or_insert(0);\n-            let disambiguator = *next_disamb;\n-            *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n-            disambiguator\n-        };\n-\n+        let disambiguator = next_disambiguator(parent, data);\n         let key = DefKey {\n             parent: Some(parent.local_def_index),\n             disambiguated_data: DisambiguatedDefPathData { data, disambiguator },\n@@ -426,55 +380,36 @@ impl Definitions {\n         let parent_hash = self.table.def_path_hash(parent.local_def_index);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n-        debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n+        debug!(\"create_def: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n         let def_id = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n \n-        assert_eq!(self.def_id_to_node_id.push(node_id), def_id);\n-        assert_eq!(self.def_id_to_span.push(span), def_id);\n-\n-        // Some things for which we allocate `LocalDefId`s don't correspond to\n-        // anything in the AST, so they don't have a `NodeId`. For these cases\n-        // we don't need a mapping from `NodeId` to `LocalDefId`.\n-        if node_id != ast::DUMMY_NODE_ID {\n-            debug!(\"create_def_with_parent: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n-            self.node_id_to_def_id.insert(node_id, def_id);\n-        }\n-\n         if expn_id != ExpnId::root() {\n             self.expansions_that_defined.insert(def_id, expn_id);\n         }\n \n         def_id\n     }\n \n-    /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n+    /// Initializes the `LocalDefId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n-    pub fn init_node_id_to_hir_id_mapping(\n+    pub fn init_def_id_to_hir_id_mapping(\n         &mut self,\n-        mapping: IndexVec<ast::NodeId, Option<hir::HirId>>,\n+        mapping: IndexVec<LocalDefId, Option<hir::HirId>>,\n     ) {\n         assert!(\n             self.def_id_to_hir_id.is_empty(),\n             \"trying to initialize `LocalDefId` <-> `HirId` mappings twice\"\n         );\n \n-        self.def_id_to_hir_id = self\n-            .def_id_to_node_id\n-            .iter()\n-            .map(|&node_id| mapping.get(node_id).and_then(|&hir_id| hir_id))\n-            .collect();\n-\n         // Build the reverse mapping of `def_id_to_hir_id`.\n         self.hir_id_to_def_id = mapping\n-            .into_iter_enumerated()\n-            .filter_map(|(node_id, hir_id)| {\n-                hir_id.and_then(|hir_id| {\n-                    self.node_id_to_def_id.get(&node_id).map(|&def_id| (hir_id, def_id))\n-                })\n-            })\n+            .iter_enumerated()\n+            .filter_map(|(def_id, hir_id)| hir_id.map(|hir_id| (hir_id, def_id)))\n             .collect();\n+\n+        self.def_id_to_hir_id = mapping;\n     }\n \n     pub fn expansion_that_defined(&self, id: LocalDefId) -> ExpnId {\n@@ -488,30 +423,6 @@ impl Definitions {\n     pub fn add_parent_module_of_macro_def(&mut self, expn_id: ExpnId, module: DefId) {\n         self.parent_modules_of_macro_defs.insert(expn_id, module);\n     }\n-\n-    pub fn invocation_parent(&self, invoc_id: ExpnId) -> LocalDefId {\n-        self.invocation_parents[&invoc_id]\n-    }\n-\n-    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: LocalDefId) {\n-        let old_parent = self.invocation_parents.insert(invoc_id, parent);\n-        assert!(old_parent.is_none(), \"parent `LocalDefId` is reset for an invocation\");\n-    }\n-\n-    pub fn placeholder_field_index(&self, node_id: ast::NodeId) -> usize {\n-        self.placeholder_field_indices[&node_id]\n-    }\n-\n-    pub fn set_placeholder_field_index(&mut self, node_id: ast::NodeId, index: usize) {\n-        let old_index = self.placeholder_field_indices.insert(node_id, index);\n-        assert!(old_index.is_none(), \"placeholder field index is reset for a node ID\");\n-    }\n-\n-    pub fn lint_node_id(&mut self, expn_id: ExpnId) -> ast::NodeId {\n-        self.invocation_parents\n-            .get(&expn_id)\n-            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[*id])\n-    }\n }\n \n impl DefPathData {"}, {"sha": "7fdcbd31df3c5085663428ea3fb2c1cafaeff250", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1256,7 +1256,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             (ty::FnDef(did1, substs1), ty::FnPtr(sig2)) => {\n                 let sig1 = self.tcx.fn_sig(*did1).subst(self.tcx, substs1);\n                 let mut values = self.cmp_fn_sig(&sig1, sig2);\n-                values.0.push_normal(format!(\n+                values.0.push_highlighted(format!(\n                     \" {{{}}}\",\n                     self.tcx.def_path_str_with_substs(*did1, substs1)\n                 ));"}, {"sha": "920cc6021e68781d3933c7c697cc616019095c8f", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -202,6 +202,7 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n }\n \n pub fn run_compiler<R: Send>(mut config: Config, f: impl FnOnce(&Compiler) -> R + Send) -> R {\n+    log::trace!(\"run_compiler\");\n     let stderr = config.stderr.take();\n     util::spawn_thread_pool(\n         config.opts.edition,"}, {"sha": "e9a4119f4a3332e43edb5890a25d87c8d61ca9eb", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -101,6 +101,7 @@ pub fn configure_and_expand(\n     krate: ast::Crate,\n     crate_name: &str,\n ) -> Result<(ast::Crate, BoxedResolver)> {\n+    log::trace!(\"configure_and_expand\");\n     // Currently, we ignore the name resolution data structures for the purposes of dependency\n     // tracking. Instead we will run name resolution and include its output in the hash of each\n     // item, much like we do for macro expansion. In other words, the hash reflects not just\n@@ -230,6 +231,7 @@ fn configure_and_expand_inner<'a>(\n     resolver_arenas: &'a ResolverArenas<'a>,\n     metadata_loader: &'a MetadataLoaderDyn,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n+    log::trace!(\"configure_and_expand_inner\");\n     pre_expansion_lint(sess, lint_store, &krate);\n \n     let mut resolver = Resolver::new(sess, &krate, crate_name, metadata_loader, &resolver_arenas);\n@@ -357,6 +359,7 @@ fn configure_and_expand_inner<'a>(\n         should_loop |= true;\n     }\n     if should_loop {\n+        log::debug!(\"replacing bodies with loop {{}}\");\n         util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }\n \n@@ -734,7 +737,10 @@ pub fn create_global_ctxt<'tcx>(\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n-    let defs: &'tcx Definitions = arena.alloc(mem::take(&mut resolver_outputs.definitions));\n+    let defs: &'tcx Definitions = arena.alloc(mem::replace(\n+        &mut resolver_outputs.definitions,\n+        Definitions::new(crate_name, sess.local_crate_disambiguator()),\n+    ));\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n "}, {"sha": "4a41c3e97cafc3c99ee59ad811c8d9a01688b9ac", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -169,6 +169,7 @@ impl<'tcx> Queries<'tcx> {\n     pub fn expansion(\n         &self,\n     ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>> {\n+        log::trace!(\"expansion\");\n         self.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let (krate, lint_store) = self.register_plugins()?.take();"}, {"sha": "2c80c846681a66e60eba35f04fca53d0e5f40289", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_expand::base::SyntaxExtension;\n-use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::cstore::DepKind;\n@@ -896,6 +896,7 @@ impl<'a> CrateLoader<'a> {\n         &mut self,\n         item: &ast::Item,\n         definitions: &Definitions,\n+        def_id: LocalDefId,\n     ) -> CrateNum {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n@@ -918,7 +919,6 @@ impl<'a> CrateLoader<'a> {\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n-                let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,"}, {"sha": "1bdac1039b55a48e07bb179599993968857b0fdf", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -488,6 +488,8 @@ impl<'a> CrateLocator<'a> {\n                 && self.triple != TargetTriple::from_triple(config::host_triple())\n             {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n+            } else if self.crate_name == sym::profiler_builtins {\n+                err.note(&\"the compiler may have been built without the profiler runtime\");\n             }\n             err.span_label(self.span, \"can't find crate\");\n             err"}, {"sha": "3a4fc581f5f2607d91e1a34c5b199bdfc8532eb6", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -56,7 +56,7 @@ fn fn_sig<'hir>(node: Node<'hir>) -> Option<&'hir FnSig<'hir>> {\n     }\n }\n \n-fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n+pub fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n     match node {\n         Node::Item(Item {\n             kind: ItemKind::Const(_, body) | ItemKind::Static(.., body) | ItemKind::Fn(.., body),"}, {"sha": "f5b0b73c49de1cf7230f100bfd2e3d53a377d7c5", "filename": "src/librustc_middle/ich/hcx.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fhcx.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -67,13 +67,15 @@ impl<'a> StableHashingContext<'a> {\n     /// Don't use it for anything else or you'll run the risk of\n     /// leaking data out of the tracking system.\n     #[inline]\n-    pub fn new(\n+    fn new_with_or_without_spans(\n         sess: &'a Session,\n         krate: &'a hir::Crate<'a>,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        always_ignore_spans: bool,\n     ) -> Self {\n-        let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n+        let hash_spans_initial =\n+            !always_ignore_spans && !sess.opts.debugging_opts.incremental_ignore_spans;\n \n         StableHashingContext {\n             sess,\n@@ -88,6 +90,33 @@ impl<'a> StableHashingContext<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn new(\n+        sess: &'a Session,\n+        krate: &'a hir::Crate<'a>,\n+        definitions: &'a Definitions,\n+        cstore: &'a dyn CrateStore,\n+    ) -> Self {\n+        Self::new_with_or_without_spans(\n+            sess,\n+            krate,\n+            definitions,\n+            cstore,\n+            /*always_ignore_spans=*/ false,\n+        )\n+    }\n+\n+    #[inline]\n+    pub fn ignore_spans(\n+        sess: &'a Session,\n+        krate: &'a hir::Crate<'a>,\n+        definitions: &'a Definitions,\n+        cstore: &'a dyn CrateStore,\n+    ) -> Self {\n+        let always_ignore_spans = true;\n+        Self::new_with_or_without_spans(sess, krate, definitions, cstore, always_ignore_spans)\n+    }\n+\n     #[inline]\n     pub fn sess(&self) -> &'a Session {\n         self.sess"}, {"sha": "d89c35d313ca3c41d0c15d84867d167906b778fc", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -164,8 +164,8 @@ pub struct Body<'tcx> {\n     /// The user may be writing e.g. `&[(SOME_CELL, 42)][i].1` and this would get promoted, because\n     /// we'd statically know that no thing with interior mutability will ever be available to the\n     /// user without some serious unsafe code.  Now this means that our promoted is actually\n-    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because the\n-    /// index may be a runtime value. Such a promoted value is illegal because it has reachable\n+    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because\n+    /// the index may be a runtime value. Such a promoted value is illegal because it has reachable\n     /// interior mutability. This flag just makes this situation very obvious where the previous\n     /// implementation without the flag hid this situation silently.\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n@@ -2921,3 +2921,18 @@ impl Location {\n         }\n     }\n }\n+\n+/// Coverage data associated with each function (MIR) instrumented with coverage counters, when\n+/// compiled with `-Zinstrument_coverage`. The query `tcx.coverage_data(DefId)` computes these\n+/// values on demand (during code generation). This query is only valid after executing the MIR pass\n+/// `InstrumentCoverage`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub struct CoverageData {\n+    /// A hash value that can be used by the consumer of the coverage profile data to detect\n+    /// changes to the instrumented source of the associated MIR body (typically, for an\n+    /// individual function).\n+    pub hash: u64,\n+\n+    /// The total number of coverage region counters added to the MIR `Body`.\n+    pub num_counters: u32,\n+}"}, {"sha": "2f51b98085b4eea4d1b1f7395c8484b1f34e2834", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -231,6 +231,12 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n+        query coverage_data(key: DefId) -> mir::CoverageData {\n+            desc { |tcx| \"retrieving coverage data from MIR for `{}`\", tcx.def_path_str(key) }\n+            storage(ArenaCacheSelector<'tcx>)\n+            cache_on_disk_if { key.is_local() }\n+        }\n+\n         query promoted_mir(key: DefId) -> IndexVec<mir::Promoted, mir::Body<'tcx>> {\n             desc { |tcx| \"optimizing promoted MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)"}, {"sha": "df08e083d2cbb98ebbeab0e60a3dc73be98cface", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1307,6 +1307,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         StableHashingContext::new(self.sess, krate, self.definitions, &*self.cstore)\n     }\n \n+    #[inline(always)]\n+    pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n+        let krate = self.gcx.untracked_crate;\n+\n+        StableHashingContext::ignore_spans(self.sess, krate, self.definitions, &*self.cstore)\n+    }\n+\n     // This method makes sure that we have a DepNode and a Fingerprint for\n     // every upstream crate. It needs to be called once right after the tcx is\n     // created."}, {"sha": "f9b3c319c1f66654463ee89ff3c6386007f9325c", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 80, "deletions": 57, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -178,7 +178,7 @@ use crate::monomorphize;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{ErrorReported, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -195,6 +195,7 @@ use rustc_middle::ty::print::obsolete::DefPathBasedNames;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_session::config::EntryFnType;\n+use rustc_span::source_map::{dummy_spanned, respan, Span, Spanned, DUMMY_SP};\n use smallvec::SmallVec;\n use std::iter;\n \n@@ -294,7 +295,13 @@ pub fn collect_crate_mono_items(\n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_iter(roots).for_each(|root| {\n                 let mut recursion_depths = DefIdMap::default();\n-                collect_items_rec(tcx, root, visited, &mut recursion_depths, inlining_map);\n+                collect_items_rec(\n+                    tcx,\n+                    dummy_spanned(root),\n+                    visited,\n+                    &mut recursion_depths,\n+                    inlining_map,\n+                );\n             });\n         });\n     }\n@@ -323,37 +330,38 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n     // We can only codegen items that are instantiable - items all of\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip codegenning them.\n-    roots.retain(|root| root.is_instantiable(tcx));\n-\n     roots\n+        .into_iter()\n+        .filter_map(|root| root.node.is_instantiable(tcx).then_some(root.node))\n+        .collect()\n }\n \n // Collect all monomorphized items reachable from `starting_point`\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    starting_point: MonoItem<'tcx>,\n+    starting_point: Spanned<MonoItem<'tcx>>,\n     visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n ) {\n-    if !visited.lock_mut().insert(starting_point) {\n+    if !visited.lock_mut().insert(starting_point.node) {\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(tcx, true));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.node.to_string(tcx, true));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n-    match starting_point {\n+    match starting_point.node {\n         MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n             debug_assert!(should_monomorphize_locally(tcx, &instance));\n \n             let ty = instance.monomorphic_ty(tcx);\n-            visit_drop_use(tcx, ty, true, &mut neighbors);\n+            visit_drop_use(tcx, ty, true, starting_point.span, &mut neighbors);\n \n             recursion_depth_reset = None;\n \n@@ -366,7 +374,8 @@ fn collect_items_rec<'tcx>(\n             debug_assert!(should_monomorphize_locally(tcx, &instance));\n \n             // Keep track of the monomorphization recursion depth\n-            recursion_depth_reset = Some(check_recursion_limit(tcx, instance, recursion_depths));\n+            recursion_depth_reset =\n+                Some(check_recursion_limit(tcx, instance, starting_point.span, recursion_depths));\n             check_type_length_limit(tcx, instance);\n \n             rustc_data_structures::stack::ensure_sufficient_stack(|| {\n@@ -378,7 +387,7 @@ fn collect_items_rec<'tcx>(\n         }\n     }\n \n-    record_accesses(tcx, starting_point, &neighbors[..], inlining_map);\n+    record_accesses(tcx, starting_point.node, neighbors.iter().map(|i| &i.node), inlining_map);\n \n     for neighbour in neighbors {\n         collect_items_rec(tcx, neighbour, visited, recursion_depths, inlining_map);\n@@ -388,13 +397,13 @@ fn collect_items_rec<'tcx>(\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx, true));\n+    debug!(\"END collect_items_rec({})\", starting_point.node.to_string(tcx, true));\n }\n \n-fn record_accesses<'tcx>(\n+fn record_accesses<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'tcx>,\n     caller: MonoItem<'tcx>,\n-    callees: &[MonoItem<'tcx>],\n+    callees: impl Iterator<Item = &'a MonoItem<'tcx>>,\n     inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n ) {\n     let is_inlining_candidate = |mono_item: &MonoItem<'tcx>| {\n@@ -405,14 +414,15 @@ fn record_accesses<'tcx>(\n     // FIXME: Call `is_inlining_candidate` when pushing to `neighbors` in `collect_items_rec`\n     // instead to avoid creating this `SmallVec`.\n     let accesses: SmallVec<[_; 128]> =\n-        callees.iter().map(|mono_item| (*mono_item, is_inlining_candidate(mono_item))).collect();\n+        callees.map(|mono_item| (*mono_item, is_inlining_candidate(mono_item))).collect();\n \n     inlining_map.lock_mut().record_accesses(caller, &accesses);\n }\n \n fn check_recursion_limit<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n+    span: Span,\n     recursion_depths: &mut DefIdMap<usize>,\n ) -> (DefId, usize) {\n     let def_id = instance.def_id();\n@@ -432,12 +442,13 @@ fn check_recursion_limit<'tcx>(\n     // infinite expansion.\n     if !tcx.sess.recursion_limit().value_within_limit(adjusted_recursion_depth) {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n-        if let Some(def_id) = def_id.as_local() {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id);\n-            tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n-        } else {\n-            tcx.sess.fatal(&error);\n-        }\n+        let mut err = tcx.sess.struct_span_fatal(span, &error);\n+        err.span_note(\n+            tcx.def_span(def_id),\n+            &format!(\"`{}` defined here\", tcx.def_path_str(def_id)),\n+        );\n+        err.emit();\n+        FatalError.raise();\n     }\n \n     recursion_depths.insert(def_id, recursion_depth + 1);\n@@ -498,7 +509,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n struct MirNeighborCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n-    output: &'a mut Vec<MonoItem<'tcx>>,\n+    output: &'a mut Vec<Spanned<MonoItem<'tcx>>>,\n     instance: Instance<'tcx>,\n }\n \n@@ -520,6 +531,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n+        let span = self.body.source_info(location).span;\n+\n         match *rvalue {\n             // When doing an cast from a regular pointer to a fat pointer, we\n             // have to instantiate all methods of the trait being cast to, so we\n@@ -542,6 +555,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         self.tcx,\n                         target_ty,\n                         source_ty,\n+                        span,\n                         self.output,\n                     );\n                 }\n@@ -553,7 +567,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             ) => {\n                 let fn_ty = operand.ty(self.body, self.tcx);\n                 let fn_ty = self.monomorphize(fn_ty);\n-                visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                visit_fn_use(self.tcx, fn_ty, false, span, &mut self.output);\n             }\n             mir::Rvalue::Cast(\n                 mir::CastKind::Pointer(PointerCast::ClosureFnPointer(_)),\n@@ -571,7 +585,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         if should_monomorphize_locally(self.tcx, &instance) {\n-                            self.output.push(create_fn_mono_item(instance));\n+                            self.output.push(create_fn_mono_item(instance, span));\n                         }\n                     }\n                     _ => bug!(),\n@@ -583,15 +597,15 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     tcx.require_lang_item(ExchangeMallocFnLangItem, None);\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n                 if should_monomorphize_locally(tcx, &instance) {\n-                    self.output.push(create_fn_mono_item(instance));\n+                    self.output.push(create_fn_mono_item(instance, span));\n                 }\n             }\n             mir::Rvalue::ThreadLocalRef(def_id) => {\n                 assert!(self.tcx.is_thread_local_static(def_id));\n                 let instance = Instance::mono(self.tcx, def_id);\n                 if should_monomorphize_locally(self.tcx, &instance) {\n                     trace!(\"collecting thread-local static {:?}\", def_id);\n-                    self.output.push(MonoItem::Static(def_id));\n+                    self.output.push(respan(span, MonoItem::Static(def_id)));\n                 }\n             }\n             _ => { /* not interesting */ }\n@@ -626,32 +640,33 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n         debug!(\"visiting terminator {:?} @ {:?}\", terminator, location);\n+        let source = self.body.source_info(location).span;\n \n         let tcx = self.tcx;\n         match terminator.kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.body, tcx);\n                 let callee_ty = self.monomorphize(callee_ty);\n-                visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n+                visit_fn_use(self.tcx, callee_ty, true, source, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref place, .. }\n             | mir::TerminatorKind::DropAndReplace { ref place, .. } => {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let ty = self.monomorphize(ty);\n-                visit_drop_use(self.tcx, ty, true, self.output);\n+                visit_drop_use(self.tcx, ty, true, source, self.output);\n             }\n             mir::TerminatorKind::InlineAsm { ref operands, .. } => {\n                 for op in operands {\n                     match *op {\n                         mir::InlineAsmOperand::SymFn { ref value } => {\n                             let fn_ty = self.monomorphize(value.literal.ty);\n-                            visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                            visit_fn_use(self.tcx, fn_ty, false, source, &mut self.output);\n                         }\n                         mir::InlineAsmOperand::SymStatic { def_id } => {\n                             let instance = Instance::mono(self.tcx, def_id);\n                             if should_monomorphize_locally(self.tcx, &instance) {\n                                 trace!(\"collecting asm sym static {:?}\", def_id);\n-                                self.output.push(MonoItem::Static(def_id));\n+                                self.output.push(respan(source, MonoItem::Static(def_id)));\n                             }\n                         }\n                         _ => {}\n@@ -687,17 +702,19 @@ fn visit_drop_use<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     let instance = Instance::resolve_drop_in_place(tcx, ty);\n-    visit_instance_use(tcx, instance, is_direct_call, output);\n+    visit_instance_use(tcx, instance, is_direct_call, source, output);\n }\n \n fn visit_fn_use<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     if let ty::FnDef(def_id, substs) = ty.kind {\n         let instance = if is_direct_call {\n@@ -706,15 +723,16 @@ fn visit_fn_use<'tcx>(\n             ty::Instance::resolve_for_fn_ptr(tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n                 .unwrap()\n         };\n-        visit_instance_use(tcx, instance, is_direct_call, output);\n+        visit_instance_use(tcx, instance, is_direct_call, source, output);\n     }\n }\n \n fn visit_instance_use<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::Instance<'tcx>,\n     is_direct_call: bool,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n     if !should_monomorphize_locally(tcx, &instance) {\n@@ -730,7 +748,7 @@ fn visit_instance_use<'tcx>(\n         ty::InstanceDef::DropGlue(_, None) => {\n             // Don't need to emit noop drop glue if we are calling directly.\n             if !is_direct_call {\n-                output.push(create_fn_mono_item(instance));\n+                output.push(create_fn_mono_item(instance, source));\n             }\n         }\n         ty::InstanceDef::DropGlue(_, Some(_))\n@@ -740,7 +758,7 @@ fn visit_instance_use<'tcx>(\n         | ty::InstanceDef::Item(..)\n         | ty::InstanceDef::FnPtrShim(..)\n         | ty::InstanceDef::CloneShim(..) => {\n-            output.push(create_fn_mono_item(instance));\n+            output.push(create_fn_mono_item(instance, source));\n         }\n     }\n }\n@@ -832,7 +850,6 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n-            use rustc_span::DUMMY_SP;\n             if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n                 return false;\n             }\n@@ -886,9 +903,9 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     }\n }\n \n-fn create_fn_mono_item(instance: Instance<'_>) -> MonoItem<'_> {\n+fn create_fn_mono_item(instance: Instance<'_>, source: Span) -> Spanned<MonoItem<'_>> {\n     debug!(\"create_fn_mono_item(instance={})\", instance);\n-    MonoItem::Fn(instance)\n+    respan(source, MonoItem::Fn(instance))\n }\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n@@ -897,7 +914,8 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: Ty<'tcx>,\n     impl_ty: Ty<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     assert!(\n         !trait_ty.needs_subst()\n@@ -927,12 +945,12 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n                     .unwrap()\n                 })\n                 .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n-                .map(create_fn_mono_item);\n+                .map(|item| create_fn_mono_item(item, source));\n             output.extend(methods);\n         }\n \n         // Also add the destructor.\n-        visit_drop_use(tcx, impl_ty, false, output);\n+        visit_drop_use(tcx, impl_ty, false, source, output);\n     }\n }\n \n@@ -943,7 +961,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n struct RootCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mode: MonoItemCollectionMode,\n-    output: &'a mut Vec<MonoItem<'tcx>>,\n+    output: &'a mut Vec<Spanned<MonoItem<'tcx>>>,\n     entry_fn: Option<(LocalDefId, EntryFnType)>,\n }\n \n@@ -980,7 +998,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n \n                         let ty = Instance::new(def_id.to_def_id(), InternalSubsts::empty())\n                             .monomorphic_ty(self.tcx);\n-                        visit_drop_use(self.tcx, ty, true, self.output);\n+                        visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                     }\n                 }\n             }\n@@ -989,12 +1007,12 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n                     def_id_to_string(self.tcx, self.tcx.hir().local_def_id(item.hir_id))\n                 );\n-                self.output.push(MonoItem::GlobalAsm(item.hir_id));\n+                self.output.push(dummy_spanned(MonoItem::GlobalAsm(item.hir_id)));\n             }\n             hir::ItemKind::Static(..) => {\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 debug!(\"RootCollector: ItemKind::Static({})\", def_id_to_string(self.tcx, def_id));\n-                self.output.push(MonoItem::Static(def_id.to_def_id()));\n+                self.output.push(dummy_spanned(MonoItem::Static(def_id.to_def_id())));\n             }\n             hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n@@ -1051,7 +1069,7 @@ impl RootCollector<'_, 'v> {\n             debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n \n             let instance = Instance::mono(self.tcx, def_id.to_def_id());\n-            self.output.push(create_fn_mono_item(instance));\n+            self.output.push(create_fn_mono_item(instance, DUMMY_SP));\n         }\n     }\n \n@@ -1088,7 +1106,7 @@ impl RootCollector<'_, 'v> {\n         .unwrap()\n         .unwrap();\n \n-        self.output.push(create_fn_mono_item(start_instance));\n+        self.output.push(create_fn_mono_item(start_instance, DUMMY_SP));\n     }\n }\n \n@@ -1100,7 +1118,7 @@ fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n fn create_mono_items_for_default_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &'tcx hir::Item<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     match item.kind {\n         hir::ItemKind::Impl { ref generics, ref items, .. } => {\n@@ -1145,8 +1163,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n                         .unwrap()\n                         .unwrap();\n \n-                    let mono_item = create_fn_mono_item(instance);\n-                    if mono_item.is_instantiable(tcx) && should_monomorphize_locally(tcx, &instance)\n+                    let mono_item = create_fn_mono_item(instance, DUMMY_SP);\n+                    if mono_item.node.is_instantiable(tcx)\n+                        && should_monomorphize_locally(tcx, &instance)\n                     {\n                         output.push(mono_item);\n                     }\n@@ -1158,14 +1177,18 @@ fn create_mono_items_for_default_impls<'tcx>(\n }\n \n /// Scans the miri alloc in order to find function calls, closures, and drop-glue.\n-fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n+fn collect_miri<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    alloc_id: AllocId,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+) {\n     match tcx.global_alloc(alloc_id) {\n         GlobalAlloc::Static(def_id) => {\n             assert!(!tcx.is_thread_local_static(def_id));\n             let instance = Instance::mono(tcx, def_id);\n             if should_monomorphize_locally(tcx, &instance) {\n                 trace!(\"collecting static {:?}\", def_id);\n-                output.push(MonoItem::Static(def_id));\n+                output.push(dummy_spanned(MonoItem::Static(def_id)));\n             }\n         }\n         GlobalAlloc::Memory(alloc) => {\n@@ -1179,7 +1202,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n         GlobalAlloc::Function(fn_instance) => {\n             if should_monomorphize_locally(tcx, &fn_instance) {\n                 trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n-                output.push(create_fn_mono_item(fn_instance));\n+                output.push(create_fn_mono_item(fn_instance, DUMMY_SP));\n             }\n         }\n     }\n@@ -1189,7 +1212,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n fn collect_neighbours<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     debug!(\"collect_neighbours: {:?}\", instance.def_id());\n     let body = tcx.instance_mir(instance.def);\n@@ -1207,7 +1230,7 @@ fn def_id_to_string(tcx: TyCtxt<'_>, def_id: LocalDefId) -> String {\n fn collect_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     value: ConstValue<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     match value {\n         ConstValue::Scalar(Scalar::Ptr(ptr)) => collect_miri(tcx, ptr.alloc_id, output),"}, {"sha": "eb614170baae5b943ea781159d052d4341388b85", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -574,8 +574,16 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n \n             // Do not try creating references (#67862)\n-            Rvalue::Ref(_, _, place_ref) => {\n-                trace!(\"skipping Ref({:?})\", place_ref);\n+            Rvalue::AddressOf(_, place) | Rvalue::Ref(_, _, place) => {\n+                trace!(\"skipping AddressOf | Ref for {:?}\", place);\n+\n+                // This may be creating mutable references or immutable references to cells.\n+                // If that happens, the pointed to value could be mutated via that reference.\n+                // Since we aren't tracking references, the const propagator loses track of what\n+                // value the local has right now.\n+                // Thus, all locals that have their reference taken\n+                // must not take part in propagation.\n+                Self::remove_const(&mut self.ecx, place.local);\n \n                 return None;\n             }\n@@ -715,6 +723,9 @@ enum ConstPropMode {\n     OnlyInsideOwnBlock,\n     /// The `Local` can be propagated into but reads cannot be propagated.\n     OnlyPropagateInto,\n+    /// The `Local` cannot be part of propagation at all. Any statement\n+    /// referencing it either for reading or writing will not get propagated.\n+    NoPropagation,\n }\n \n struct CanConstProp {\n@@ -780,7 +791,9 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n                         // end of the block anyway, and inside the block we overwrite previous\n                         // states as applicable.\n                         ConstPropMode::OnlyInsideOwnBlock => {}\n-                        other => {\n+                        ConstPropMode::NoPropagation => {}\n+                        ConstPropMode::OnlyPropagateInto => {}\n+                        other @ ConstPropMode::FullConstProp => {\n                             trace!(\n                                 \"local {:?} can't be propagated because of multiple assignments\",\n                                 local,\n@@ -812,7 +825,7 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             | MutatingUse(MutatingUseContext::Borrow)\n             | MutatingUse(MutatingUseContext::AddressOf) => {\n                 trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n-                self.can_const_prop[local] = ConstPropMode::OnlyPropagateInto;\n+                self.can_const_prop[local] = ConstPropMode::NoPropagation;\n             }\n         }\n     }\n@@ -857,19 +870,22 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             }\n                         }\n                     }\n-                    if can_const_prop == ConstPropMode::OnlyInsideOwnBlock {\n-                        trace!(\n-                            \"found local restricted to its block. Will remove it from const-prop after block is finished. Local: {:?}\",\n-                            place.local\n-                        );\n-                        self.locals_of_current_block.insert(place.local);\n-                    }\n-\n-                    if can_const_prop == ConstPropMode::OnlyPropagateInto {\n-                        trace!(\"can't propagate into {:?}\", place);\n-                        if place.local != RETURN_PLACE {\n-                            Self::remove_const(&mut self.ecx, place.local);\n+                    match can_const_prop {\n+                        ConstPropMode::OnlyInsideOwnBlock => {\n+                            trace!(\n+                                \"found local restricted to its block. \\\n+                                Will remove it from const-prop after block is finished. Local: {:?}\",\n+                                place.local\n+                            );\n+                            self.locals_of_current_block.insert(place.local);\n                         }\n+                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                            trace!(\"can't propagate into {:?}\", place);\n+                            if place.local != RETURN_PLACE {\n+                                Self::remove_const(&mut self.ecx, place.local);\n+                            }\n+                        }\n+                        ConstPropMode::FullConstProp => {}\n                     }\n                 } else {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n@@ -889,6 +905,12 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                     );\n                     Self::remove_const(&mut self.ecx, place.local);\n                 }\n+            } else {\n+                trace!(\n+                    \"cannot propagate into {:?}, because the type of the local is generic.\",\n+                    place,\n+                );\n+                Self::remove_const(&mut self.ecx, place.local);\n             }\n         } else {\n             match statement.kind {"}, {"sha": "59be8dc224dee57d4d1e959160ff80646e23cf6f", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 213, "deletions": 56, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -64,15 +64,15 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{GeneratorStateLangItem, PinTypeLangItem};\n use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir::visit::{MutVisitor, PlaceContext};\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::GeneratorSubsts;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::PanicStrategy;\n use std::borrow::Cow;\n-use std::iter;\n+use std::{iter, ops};\n \n pub struct StateTransform;\n \n@@ -417,11 +417,7 @@ fn replace_local<'tcx>(\n \n struct LivenessInfo {\n     /// Which locals are live across any suspension point.\n-    ///\n-    /// GeneratorSavedLocal is indexed in terms of the elements in this set;\n-    /// i.e. GeneratorSavedLocal::new(1) corresponds to the second local\n-    /// included in this set.\n-    live_locals: BitSet<Local>,\n+    saved_locals: GeneratorSavedLocals,\n \n     /// The set of saved locals live at each suspension point.\n     live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n@@ -524,49 +520,75 @@ fn locals_live_across_suspend_points(\n             live_locals_at_suspension_points.push(live_locals);\n         }\n     }\n+\n     debug!(\"live_locals_anywhere = {:?}\", live_locals_at_any_suspension_point);\n+    let saved_locals = GeneratorSavedLocals(live_locals_at_any_suspension_point);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n     let live_locals_at_suspension_points = live_locals_at_suspension_points\n         .iter()\n-        .map(|live_here| renumber_bitset(&live_here, &live_locals_at_any_suspension_point))\n+        .map(|live_here| saved_locals.renumber_bitset(&live_here))\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n         body_ref,\n-        &live_locals_at_any_suspension_point,\n+        &saved_locals,\n         always_live_locals.clone(),\n         requires_storage_results,\n     );\n \n     LivenessInfo {\n-        live_locals: live_locals_at_any_suspension_point,\n+        saved_locals,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness: storage_liveness_map,\n     }\n }\n \n-/// Renumbers the items present in `stored_locals` and applies the renumbering\n-/// to 'input`.\n+/// The set of `Local`s that must be saved across yield points.\n ///\n-/// For example, if `stored_locals = [1, 3, 5]`, this would be renumbered to\n-/// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n-fn renumber_bitset(\n-    input: &BitSet<Local>,\n-    stored_locals: &BitSet<Local>,\n-) -> BitSet<GeneratorSavedLocal> {\n-    assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n-    let mut out = BitSet::new_empty(stored_locals.count());\n-    for (idx, local) in stored_locals.iter().enumerate() {\n-        let saved_local = GeneratorSavedLocal::from(idx);\n-        if input.contains(local) {\n-            out.insert(saved_local);\n+/// `GeneratorSavedLocal` is indexed in terms of the elements in this set;\n+/// i.e. `GeneratorSavedLocal::new(1)` corresponds to the second local\n+/// included in this set.\n+struct GeneratorSavedLocals(BitSet<Local>);\n+\n+impl GeneratorSavedLocals {\n+    /// Returns an iterator over each `GeneratorSavedLocal` along with the `Local` it corresponds\n+    /// to.\n+    fn iter_enumerated(&self) -> impl '_ + Iterator<Item = (GeneratorSavedLocal, Local)> {\n+        self.iter().enumerate().map(|(i, l)| (GeneratorSavedLocal::from(i), l))\n+    }\n+\n+    /// Transforms a `BitSet<Local>` that contains only locals saved across yield points to the\n+    /// equivalent `BitSet<GeneratorSavedLocal>`.\n+    fn renumber_bitset(&self, input: &BitSet<Local>) -> BitSet<GeneratorSavedLocal> {\n+        assert!(self.superset(&input), \"{:?} not a superset of {:?}\", self.0, input);\n+        let mut out = BitSet::new_empty(self.count());\n+        for (saved_local, local) in self.iter_enumerated() {\n+            if input.contains(local) {\n+                out.insert(saved_local);\n+            }\n         }\n+        out\n+    }\n+\n+    fn get(&self, local: Local) -> Option<GeneratorSavedLocal> {\n+        if !self.contains(local) {\n+            return None;\n+        }\n+\n+        let idx = self.iter().take_while(|&l| l < local).count();\n+        Some(GeneratorSavedLocal::new(idx))\n+    }\n+}\n+\n+impl ops::Deref for GeneratorSavedLocals {\n+    type Target = BitSet<Local>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n     }\n-    debug!(\"renumber_bitset({:?}, {:?}) => {:?}\", input, stored_locals, out);\n-    out\n }\n \n /// For every saved local, looks for which locals are StorageLive at the same\n@@ -575,24 +597,24 @@ fn renumber_bitset(\n /// computation; see `GeneratorLayout` for more.\n fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n-    stored_locals: &BitSet<Local>,\n+    saved_locals: &GeneratorSavedLocals,\n     always_live_locals: storage::AlwaysLiveLocals,\n     requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n+    assert_eq!(body.local_decls.len(), saved_locals.domain_size());\n \n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n     debug!(\"always_live = {:?}\", always_live_locals);\n \n     // Locals that are always live or ones that need to be stored across\n     // suspension points are not eligible for overlap.\n     let mut ineligible_locals = always_live_locals.into_inner();\n-    ineligible_locals.intersect(stored_locals);\n+    ineligible_locals.intersect(saved_locals);\n \n     // Compute the storage conflicts for all eligible locals.\n     let mut visitor = StorageConflictVisitor {\n         body,\n-        stored_locals: &stored_locals,\n+        saved_locals: &saved_locals,\n         local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n \n@@ -609,16 +631,14 @@ fn compute_storage_conflicts(\n     // However, in practice these bitsets are not usually large. The layout code\n     // also needs to keep track of how many conflicts each local has, so it's\n     // simpler to keep it this way for now.\n-    let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n-    for (idx_a, local_a) in stored_locals.iter().enumerate() {\n-        let saved_local_a = GeneratorSavedLocal::new(idx_a);\n+    let mut storage_conflicts = BitMatrix::new(saved_locals.count(), saved_locals.count());\n+    for (saved_local_a, local_a) in saved_locals.iter_enumerated() {\n         if ineligible_locals.contains(local_a) {\n             // Conflicts with everything.\n             storage_conflicts.insert_all_into_row(saved_local_a);\n         } else {\n             // Keep overlap information only for stored locals.\n-            for (idx_b, local_b) in stored_locals.iter().enumerate() {\n-                let saved_local_b = GeneratorSavedLocal::new(idx_b);\n+            for (saved_local_b, local_b) in saved_locals.iter_enumerated() {\n                 if local_conflicts.contains(local_a, local_b) {\n                     storage_conflicts.insert(saved_local_a, saved_local_b);\n                 }\n@@ -630,7 +650,7 @@ fn compute_storage_conflicts(\n \n struct StorageConflictVisitor<'mir, 'tcx, 's> {\n     body: &'mir Body<'tcx>,\n-    stored_locals: &'s BitSet<Local>,\n+    saved_locals: &'s GeneratorSavedLocals,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n@@ -666,7 +686,7 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n         }\n \n         let mut eligible_storage_live = flow_state.clone();\n-        eligible_storage_live.intersect(&self.stored_locals);\n+        eligible_storage_live.intersect(&self.saved_locals);\n \n         for local in eligible_storage_live.iter() {\n             self.local_conflicts.union_row_with(&eligible_storage_live, local);\n@@ -678,15 +698,15 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     }\n }\n \n-/// Validates the typeck view of the generator against the actual set of types retained between\n+/// Validates the typeck view of the generator against the actual set of types saved between\n /// yield points.\n fn sanitize_witness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     did: DefId,\n     witness: Ty<'tcx>,\n     upvars: &Vec<Ty<'tcx>>,\n-    retained: &BitSet<Local>,\n+    saved_locals: &GeneratorSavedLocals,\n ) {\n     let allowed_upvars = tcx.erase_regions(upvars);\n     let allowed = match witness.kind {\n@@ -703,8 +723,8 @@ fn sanitize_witness<'tcx>(\n     let param_env = tcx.param_env(did);\n \n     for (local, decl) in body.local_decls.iter_enumerated() {\n-        // Ignore locals which are internal or not retained between yields.\n-        if !retained.contains(local) || decl.internal {\n+        // Ignore locals which are internal or not saved between yields.\n+        if !saved_locals.contains(local) || decl.internal {\n             continue;\n         }\n         let decl_ty = tcx.normalize_erasing_regions(param_env, decl.ty);\n@@ -724,35 +744,27 @@ fn sanitize_witness<'tcx>(\n }\n \n fn compute_layout<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    source: MirSource<'tcx>,\n-    upvars: &Vec<Ty<'tcx>>,\n-    interior: Ty<'tcx>,\n-    always_live_locals: &storage::AlwaysLiveLocals,\n-    movable: bool,\n+    liveness: LivenessInfo,\n     body: &mut Body<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n     IndexVec<BasicBlock, Option<BitSet<Local>>>,\n ) {\n-    // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n-        live_locals,\n+        saved_locals,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n-    } = locals_live_across_suspend_points(tcx, body, source, always_live_locals, movable);\n-\n-    sanitize_witness(tcx, body, source.def_id(), interior, upvars, &live_locals);\n+    } = liveness;\n \n     // Gather live local types and their indices.\n     let mut locals = IndexVec::<GeneratorSavedLocal, _>::new();\n     let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n-    for (idx, local) in live_locals.iter().enumerate() {\n+    for (saved_local, local) in saved_locals.iter_enumerated() {\n         locals.push(local);\n         tys.push(body.local_decls[local].ty);\n-        debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n+        debug!(\"generator saved local {:?} => {:?}\", saved_local, local);\n     }\n \n     // Leave empty variants for the UNRESUMED, RETURNED, and POISONED states.\n@@ -1260,11 +1272,25 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         let always_live_locals = storage::AlwaysLiveLocals::new(&body);\n \n+        let liveness_info =\n+            locals_live_across_suspend_points(tcx, body, source, &always_live_locals, movable);\n+\n+        sanitize_witness(tcx, body, def_id, interior, &upvars, &liveness_info.saved_locals);\n+\n+        if tcx.sess.opts.debugging_opts.validate_mir {\n+            let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias {\n+                assigned_local: None,\n+                saved_locals: &liveness_info.saved_locals,\n+                storage_conflicts: &liveness_info.storage_conflicts,\n+            };\n+\n+            vis.visit_body(body);\n+        }\n+\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points\n-        let (remap, layout, storage_liveness) =\n-            compute_layout(tcx, source, &upvars, interior, &always_live_locals, movable, body);\n+        let (remap, layout, storage_liveness) = compute_layout(liveness_info, body);\n \n         let can_return = can_return(tcx, body);\n \n@@ -1315,3 +1341,134 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         create_generator_resume_function(tcx, transform, source, body, can_return);\n     }\n }\n+\n+/// Looks for any assignments between locals (e.g., `_4 = _5`) that will both be converted to fields\n+/// in the generator state machine but whose storage is not marked as conflicting\n+///\n+/// Validation needs to happen immediately *before* `TransformVisitor` is invoked, not after.\n+///\n+/// This condition would arise when the assignment is the last use of `_5` but the initial\n+/// definition of `_4` if we weren't extra careful to mark all locals used inside a statement as\n+/// conflicting. Non-conflicting generator saved locals may be stored at the same location within\n+/// the generator state machine, which would result in ill-formed MIR: the left-hand and right-hand\n+/// sides of an assignment may not alias. This caused a miscompilation in [#73137].\n+///\n+/// [#73137]: https://github.com/rust-lang/rust/issues/73137\n+struct EnsureGeneratorFieldAssignmentsNeverAlias<'a> {\n+    saved_locals: &'a GeneratorSavedLocals,\n+    storage_conflicts: &'a BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n+    assigned_local: Option<GeneratorSavedLocal>,\n+}\n+\n+impl EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n+    fn saved_local_for_direct_place(&self, place: Place<'_>) -> Option<GeneratorSavedLocal> {\n+        if place.is_indirect() {\n+            return None;\n+        }\n+\n+        self.saved_locals.get(place.local)\n+    }\n+\n+    fn check_assigned_place(&mut self, place: Place<'tcx>, f: impl FnOnce(&mut Self)) {\n+        if let Some(assigned_local) = self.saved_local_for_direct_place(place) {\n+            assert!(self.assigned_local.is_none(), \"`check_assigned_place` must not recurse\");\n+\n+            self.assigned_local = Some(assigned_local);\n+            f(self);\n+            self.assigned_local = None;\n+        }\n+    }\n+}\n+\n+impl Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, location: Location) {\n+        let lhs = match self.assigned_local {\n+            Some(l) => l,\n+            None => {\n+                // This visitor only invokes `visit_place` for the right-hand side of an assignment\n+                // and only after setting `self.assigned_local`. However, the default impl of\n+                // `Visitor::super_body` may call `visit_place` with a `NonUseContext` for places\n+                // with debuginfo. Ignore them here.\n+                assert!(!context.is_use());\n+                return;\n+            }\n+        };\n+\n+        let rhs = match self.saved_local_for_direct_place(*place) {\n+            Some(l) => l,\n+            None => return,\n+        };\n+\n+        if !self.storage_conflicts.contains(lhs, rhs) {\n+            bug!(\n+                \"Assignment between generator saved locals whose storage is not \\\n+                    marked as conflicting: {:?}: {:?} = {:?}\",\n+                location,\n+                lhs,\n+                rhs,\n+            );\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n+                self.check_assigned_place(*lhs, |this| this.visit_rvalue(rhs, location));\n+            }\n+\n+            // FIXME: Does `llvm_asm!` have any aliasing requirements?\n+            StatementKind::LlvmInlineAsm(_) => {}\n+\n+            StatementKind::FakeRead(..)\n+            | StatementKind::SetDiscriminant { .. }\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Retag(..)\n+            | StatementKind::AscribeUserType(..)\n+            | StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        // Checking for aliasing in terminators is probably overkill, but until we have actual\n+        // semantics, we should be conservative here.\n+        match &terminator.kind {\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination: Some((dest, _)),\n+                cleanup: _,\n+                from_hir_call: _,\n+                fn_span: _,\n+            } => {\n+                self.check_assigned_place(*dest, |this| {\n+                    this.visit_operand(func, location);\n+                    for arg in args {\n+                        this.visit_operand(arg, location);\n+                    }\n+                });\n+            }\n+\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n+                self.check_assigned_place(*resume_arg, |this| this.visit_operand(value, location));\n+            }\n+\n+            // FIXME: Does `asm!` have any aliasing requirements?\n+            TerminatorKind::InlineAsm { .. } => {}\n+\n+            TerminatorKind::Call { .. }\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {}\n+        }\n+    }\n+}"}, {"sha": "06b648ab5a908dd3710b02d5cbdde751cfdf4c11", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 157, "deletions": 56, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,75 +1,159 @@\n use crate::transform::{MirPass, MirSource};\n use crate::util::patch::MirPatch;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n-use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::*;\n+use rustc_middle::hir;\n+use rustc_middle::ich::StableHashingContext;\n+use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use rustc_middle::mir::{\n+    self, traversal, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo,\n+    StatementKind, Terminator, TerminatorKind, START_BLOCK,\n+};\n use rustc_middle::ty;\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ConstKind, FnDef};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n /// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n /// the intrinsic llvm.instrprof.increment.\n pub struct InstrumentCoverage;\n \n+/// The `query` provider for `CoverageData`, requested by `codegen_intrinsic_call()` when\n+/// constructing the arguments for `llvm.instrprof.increment`.\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n+    providers.coverage_data = |tcx, def_id| {\n+        let mir_body = tcx.optimized_mir(def_id);\n+        // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n+        // represents a single function. Validate and/or correct if inlining and/or monomorphization\n+        // invalidates these assumptions.\n+        let count_code_region_fn =\n+            tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n+        let mut num_counters: u32 = 0;\n+        // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n+        // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+        // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n+        // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+        // instrumented function) is valid.\n+        for (_, data) in traversal::preorder(mir_body) {\n+            if let Some(terminator) = &data.terminator {\n+                if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n+                    &terminator.kind\n+                {\n+                    if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n+                        if called_fn_def_id == count_code_region_fn {\n+                            if let Operand::Constant(constant) =\n+                                args.get(0).expect(\"count_code_region has at least one arg\")\n+                            {\n+                                if let ConstKind::Value(ConstValue::Scalar(value)) =\n+                                    constant.literal.val\n+                                {\n+                                    let index = value\n+                                        .to_u32()\n+                                        .expect(\"count_code_region index at arg0 is u32\");\n+                                    num_counters = std::cmp::max(num_counters, index + 1);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let hash = if num_counters > 0 { hash_mir_source(tcx, def_id) } else { 0 };\n+        CoverageData { num_counters, hash }\n+    };\n+}\n+\n+struct Instrumentor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    num_counters: u32,\n+}\n+\n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            debug!(\"instrumenting {:?}\", src.def_id());\n-            instrument_coverage(tcx, body);\n+            // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+            // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+            if src.promoted.is_none() {\n+                debug!(\n+                    \"instrumenting {:?}, span: {}\",\n+                    src.def_id(),\n+                    tcx.sess.source_map().span_to_string(mir_body.span)\n+                );\n+                Instrumentor::new(tcx).inject_counters(mir_body);\n+            }\n         }\n     }\n }\n \n-// The first counter (start of the function) is index zero.\n-const INIT_FUNCTION_COUNTER: u32 = 0;\n-\n-/// Injects calls to placeholder function `count_code_region()`.\n-// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n-// The complete solution will inject counters at each conditional code branch.\n-pub fn instrument_coverage<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let span = body.span.shrink_to_lo();\n-\n-    let count_code_region_fn = function_handle(\n-        tcx,\n-        tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n-        span,\n-    );\n-    let counter_index = Operand::const_from_scalar(\n-        tcx,\n-        tcx.types.u32,\n-        Scalar::from_u32(INIT_FUNCTION_COUNTER),\n-        span,\n-    );\n-\n-    let mut patch = MirPatch::new(body);\n-\n-    let new_block = patch.new_block(placeholder_block(SourceInfo::outermost(body.span)));\n-    let next_block = START_BLOCK;\n-\n-    let temp = patch.new_temp(tcx.mk_unit(), body.span);\n-    patch.patch_terminator(\n-        new_block,\n-        TerminatorKind::Call {\n-            func: count_code_region_fn,\n-            args: vec![counter_index],\n-            // new_block will swapped with the next_block, after applying patch\n-            destination: Some((Place::from(temp), new_block)),\n-            cleanup: None,\n-            from_hir_call: false,\n-            fn_span: span,\n-        },\n-    );\n-\n-    patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n-    patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n-\n-    patch.apply(body);\n-\n-    // To insert the `new_block` in front of the first block in the counted branch (for example,\n-    // the START_BLOCK, at the top of the function), just swap the indexes, leaving the rest of the\n-    // graph unchanged.\n-    body.basic_blocks_mut().swap(next_block, new_block);\n+impl<'tcx> Instrumentor<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self { tcx, num_counters: 0 }\n+    }\n+\n+    fn next_counter(&mut self) -> u32 {\n+        let next = self.num_counters;\n+        self.num_counters += 1;\n+        next\n+    }\n+\n+    fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) {\n+        // FIXME(richkadel): As a first step, counters are only injected at the top of each\n+        // function. The complete solution will inject counters at each conditional code branch.\n+        let top_of_function = START_BLOCK;\n+        let entire_function = mir_body.span;\n+\n+        self.inject_counter(mir_body, top_of_function, entire_function);\n+    }\n+\n+    fn inject_counter(\n+        &mut self,\n+        mir_body: &mut mir::Body<'tcx>,\n+        next_block: BasicBlock,\n+        code_region: Span,\n+    ) {\n+        let injection_point = code_region.shrink_to_lo();\n+\n+        let count_code_region_fn = function_handle(\n+            self.tcx,\n+            self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n+            injection_point,\n+        );\n+        let counter_index = Operand::const_from_scalar(\n+            self.tcx,\n+            self.tcx.types.u32,\n+            Scalar::from_u32(self.next_counter()),\n+            injection_point,\n+        );\n+\n+        let mut patch = MirPatch::new(mir_body);\n+\n+        let temp = patch.new_temp(self.tcx.mk_unit(), code_region);\n+        let new_block = patch.new_block(placeholder_block(code_region));\n+        patch.patch_terminator(\n+            new_block,\n+            TerminatorKind::Call {\n+                func: count_code_region_fn,\n+                args: vec![counter_index],\n+                // new_block will swapped with the next_block, after applying patch\n+                destination: Some((Place::from(temp), new_block)),\n+                cleanup: None,\n+                from_hir_call: false,\n+                fn_span: injection_point,\n+            },\n+        );\n+\n+        patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n+        patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+\n+        patch.apply(mir_body);\n+\n+        // To insert the `new_block` in front of the first block in the counted branch (the\n+        // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n+        mir_body.basic_blocks_mut().swap(next_block, new_block);\n+    }\n }\n \n fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n@@ -79,14 +163,31 @@ fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Ope\n     Operand::function_handle(tcx, fn_def_id, substs, span)\n }\n \n-fn placeholder_block<'tcx>(source_info: SourceInfo) -> BasicBlockData<'tcx> {\n+fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n     BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n-            source_info,\n+            source_info: SourceInfo::outermost(span),\n             // this gets overwritten by the counter Call\n             kind: TerminatorKind::Unreachable,\n         }),\n         is_cleanup: false,\n     }\n }\n+\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> u64 {\n+    let hir_node = tcx.hir().get_if_local(def_id).expect(\"DefId is local\");\n+    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n+    let hir_body = tcx.hir().body(fn_body_id);\n+    let mut hcx = tcx.create_no_span_stable_hashing_context();\n+    hash(&mut hcx, &hir_body.value).to_smaller_hash()\n+}\n+\n+fn hash(\n+    hcx: &mut StableHashingContext<'tcx>,\n+    node: &impl HashStable<StableHashingContext<'tcx>>,\n+) -> Fingerprint {\n+    let mut stable_hasher = StableHasher::new();\n+    node.hash_stable(hcx, &mut stable_hasher);\n+    stable_hasher.finish()\n+}"}, {"sha": "8ca240d2c7da77eeffcc15137d77304ed3ba7706", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -56,6 +56,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n         promoted_mir,\n         ..*providers\n     };\n+    instrument_coverage::provide(providers);\n }\n \n fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {"}, {"sha": "6f6104c3d6932f5783edb6156444b713bc368a4f", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -24,6 +24,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_expand = { path = \"../librustc_expand\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "ef43f597eab4754df4325d7e1cb6ab9893be50fb", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -19,6 +19,7 @@ use rustc_ast::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind,\n use rustc_ast::ast::{AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_attr as attr;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n@@ -171,7 +172,7 @@ impl<'a> Resolver<'a> {\n         fragment: &AstFragment,\n         parent_scope: ParentScope<'a>,\n     ) -> MacroRulesScope<'a> {\n-        collect_definitions(&mut self.definitions, fragment, parent_scope.expansion);\n+        collect_definitions(self, fragment, parent_scope.expansion);\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n         visitor.parent_scope.macro_rules\n@@ -647,9 +648,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 } else if orig_name == Some(kw::SelfLower) {\n                     self.r.graph_root\n                 } else {\n-                    let def_id = self.r.definitions.local_def_id(item.id);\n+                    let def_id = self.r.local_def_id(item.id);\n                     let crate_id =\n-                        self.r.crate_loader.process_extern_crate(item, &self.r.definitions);\n+                        self.r.crate_loader.process_extern_crate(item, &self.r.definitions, def_id);\n                     self.r.extern_crate_map.insert(def_id, crate_id);\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n@@ -704,7 +705,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             ItemKind::Mod(..) if ident.name == kw::Invalid => {} // Crate root\n \n             ItemKind::Mod(..) => {\n-                let def_id = self.r.definitions.local_def_id(item.id);\n+                let def_id = self.r.local_def_id(item.id);\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id.to_def_id(), ident.name);\n                 let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n@@ -727,18 +728,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let res =\n-                    Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let res =\n-                    Res::Def(DefKind::Const, self.r.definitions.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Const, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let res =\n-                    Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n@@ -748,15 +746,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n             // These items live in the type namespace.\n             ItemKind::TyAlias(..) => {\n-                let res = Res::Def(\n-                    DefKind::TyAlias,\n-                    self.r.definitions.local_def_id(item.id).to_def_id(),\n-                );\n+                let res = Res::Def(DefKind::TyAlias, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(_, _) => {\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 self.r.variant_vis.insert(def_id, vis);\n                 let module_kind = ModuleKind::Def(DefKind::Enum, def_id, ident.name);\n                 let module = self.r.new_module(\n@@ -771,17 +766,14 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let res = Res::Def(\n-                    DefKind::TraitAlias,\n-                    self.r.definitions.local_def_id(item.id).to_def_id(),\n-                );\n+                let res = Res::Def(DefKind::TraitAlias, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref vdata, _) => {\n                 // Define a name in the type namespace.\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Struct, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -814,15 +806,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     }\n                     let ctor_res = Res::Def(\n                         DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(vdata)),\n-                        self.r.definitions.local_def_id(ctor_node_id).to_def_id(),\n+                        self.r.local_def_id(ctor_node_id).to_def_id(),\n                     );\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n                     self.r.struct_constructors.insert(def_id, (ctor_res, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Union, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -831,7 +823,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::Trait(..) => {\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n \n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n@@ -856,18 +848,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n         let (res, ns) = match item.kind {\n-            ForeignItemKind::Fn(..) => (\n-                Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id).to_def_id()),\n-                ValueNS,\n-            ),\n-            ForeignItemKind::Static(..) => (\n-                Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id).to_def_id()),\n-                ValueNS,\n-            ),\n-            ForeignItemKind::TyAlias(..) => (\n-                Res::Def(DefKind::ForeignTy, self.r.definitions.local_def_id(item.id).to_def_id()),\n-                TypeNS,\n-            ),\n+            ForeignItemKind::Fn(..) => {\n+                (Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n+            }\n+            ForeignItemKind::Static(..) => {\n+                (Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n+            }\n+            ForeignItemKind::TyAlias(..) => {\n+                (Res::Def(DefKind::ForeignTy, self.r.local_def_id(item.id).to_def_id()), TypeNS)\n+            }\n             ForeignItemKind::MacCall(_) => unreachable!(),\n         };\n         let parent = self.parent_scope.module;\n@@ -1170,7 +1159,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScope<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n-        let def_id = self.r.definitions.local_def_id(item.id);\n+        let def_id = self.r.local_def_id(item.id);\n         let (ext, ident, span, macro_rules) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n@@ -1315,7 +1304,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         // Add the item to the trait info.\n-        let item_def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+        let item_def_id = self.r.local_def_id(item.id).to_def_id();\n         let (res, ns) = match item.kind {\n             AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n             AssocItemKind::Fn(_, ref sig, _, _) => {\n@@ -1417,7 +1406,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         let ident = variant.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.r.definitions.local_def_id(variant.id).to_def_id();\n+        let def_id = self.r.local_def_id(variant.id).to_def_id();\n         let res = Res::Def(DefKind::Variant, def_id);\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n@@ -1435,7 +1424,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n         let ctor_node_id = variant.data.ctor_id().unwrap_or(variant.id);\n-        let ctor_def_id = self.r.definitions.local_def_id(ctor_node_id).to_def_id();\n+        let ctor_def_id = self.r.local_def_id(ctor_node_id).to_def_id();\n         let ctor_kind = CtorKind::from_ast(&variant.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n         self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));"}, {"sha": "0ca01a384e73ef108313f9c00cf942c1b9014fa9", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -29,6 +29,7 @@ use crate::Resolver;\n use rustc_ast::ast;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::pluralize;\n use rustc_middle::ty;\n@@ -64,7 +65,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n         self.r.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n-        let def_id = self.r.definitions.local_def_id(id);\n+        let def_id = self.r.local_def_id(id);\n         if !used {\n             if self.r.maybe_unused_trait_imports.contains(&def_id) {\n                 // Check later.\n@@ -246,7 +247,7 @@ impl Resolver<'_> {\n                     }\n                 }\n                 ImportKind::ExternCrate { .. } => {\n-                    let def_id = self.definitions.local_def_id(import.id);\n+                    let def_id = self.local_def_id(import.id);\n                     self.maybe_unused_extern_crates.push((def_id, import.span));\n                 }\n                 ImportKind::MacroUse => {"}, {"sha": "f1063f42c91ecb295ea84920ca14f288ea1eff60", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,8 +1,10 @@\n+use crate::Resolver;\n use log::debug;\n use rustc_ast::ast::*;\n use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, FnKind};\n use rustc_ast::walk_list;\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions::*;\n@@ -11,26 +13,26 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n \n crate fn collect_definitions(\n-    definitions: &mut Definitions,\n+    resolver: &mut Resolver<'_>,\n     fragment: &AstFragment,\n     expansion: ExpnId,\n ) {\n-    let parent_def = definitions.invocation_parent(expansion);\n-    fragment.visit_with(&mut DefCollector { definitions, parent_def, expansion });\n+    let parent_def = resolver.invocation_parents[&expansion];\n+    fragment.visit_with(&mut DefCollector { resolver, parent_def, expansion });\n }\n \n /// Creates `DefId`s for nodes in the AST.\n-struct DefCollector<'a> {\n-    definitions: &'a mut Definitions,\n+struct DefCollector<'a, 'b> {\n+    resolver: &'a mut Resolver<'b>,\n     parent_def: LocalDefId,\n     expansion: ExpnId,\n }\n \n-impl<'a> DefCollector<'a> {\n+impl<'a, 'b> DefCollector<'a, 'b> {\n     fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> LocalDefId {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n+        self.resolver.create_def(parent_def, node_id, data, self.expansion, span)\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: LocalDefId, f: F) {\n@@ -43,12 +45,13 @@ impl<'a> DefCollector<'a> {\n         let index = |this: &Self| {\n             index.unwrap_or_else(|| {\n                 let node_id = NodeId::placeholder_from_expn_id(this.expansion);\n-                this.definitions.placeholder_field_index(node_id)\n+                this.resolver.placeholder_field_indices[&node_id]\n             })\n         };\n \n         if field.is_placeholder {\n-            self.definitions.set_placeholder_field_index(field.id, index(self));\n+            let old_index = self.resolver.placeholder_field_indices.insert(field.id, index(self));\n+            assert!(old_index.is_none(), \"placeholder field index is reset for a node ID\");\n             self.visit_macro_invoc(field.id);\n         } else {\n             let name = field.ident.map_or_else(|| sym::integer(index(self)), |ident| ident.name);\n@@ -58,11 +61,13 @@ impl<'a> DefCollector<'a> {\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId) {\n-        self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n+        let old_parent =\n+            self.resolver.invocation_parents.insert(id.placeholder_to_expn_id(), self.parent_def);\n+        assert!(old_parent.is_none(), \"parent `LocalDefId` is reset for an invocation\");\n     }\n }\n \n-impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n+impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     fn visit_item(&mut self, i: &'a Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "afe96ca7007817bd6f1bb4690d36fa9935c92cc2", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -108,7 +108,7 @@ impl<'a> Resolver<'a> {\n                 match outer_res {\n                     Res::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n                         if let Some(impl_span) =\n-                            maybe_impl_defid.and_then(|def_id| self.definitions.opt_span(def_id))\n+                            maybe_impl_defid.and_then(|def_id| self.opt_span(def_id))\n                         {\n                             err.span_label(\n                                 reduce_impl_span_to_impl_keyword(sm, impl_span),\n@@ -127,12 +127,12 @@ impl<'a> Resolver<'a> {\n                         return err;\n                     }\n                     Res::Def(DefKind::TyParam, def_id) => {\n-                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                        if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"type parameter from outer function\");\n                         }\n                     }\n                     Res::Def(DefKind::ConstParam, def_id) => {\n-                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                        if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"const parameter from outer function\");\n                         }\n                     }\n@@ -846,7 +846,7 @@ impl<'a> Resolver<'a> {\n                 Applicability::MaybeIncorrect,\n             );\n             let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n-                LOCAL_CRATE => self.definitions.opt_span(def_id),\n+                LOCAL_CRATE => self.opt_span(def_id),\n                 _ => Some(\n                     self.session\n                         .source_map()"}, {"sha": "8a6541b399e381e8ff8e746978f26300e2f012b7", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -12,6 +12,7 @@ use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBindin\n use rustc_ast::ast::NodeId;\n use rustc_ast::unwrap_or;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n@@ -1393,7 +1394,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let is_good_import =\n                 binding.is_import() && !binding.is_ambiguity() && !ident.span.from_expansion();\n             if is_good_import || binding.is_macro_def() {\n-                let res = binding.res().map_id(|id| this.definitions.local_def_id(id));\n+                let res = binding.res().map_id(|id| this.local_def_id(id));\n                 if res != def::Res::Err {\n                     reexports.push(Export { ident, res, span: binding.span, vis: binding.vis });\n                 }"}, {"sha": "6f769c3c59cae6fda1efdecd28104866d245ddea", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -16,6 +16,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{unwrap_or, walk_list};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n@@ -707,7 +708,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn with_scope<T>(&mut self, id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let id = self.r.definitions.local_def_id(id);\n+        let id = self.r.local_def_id(id);\n         let module = self.r.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n@@ -759,7 +760,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n             this.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                let item_def_id = this.r.definitions.local_def_id(item.id).to_def_id();\n+                let item_def_id = this.r.local_def_id(item.id).to_def_id();\n                 this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n                     visit::walk_item(this, item);\n                 });\n@@ -839,7 +840,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let local_def_id = this.r.definitions.local_def_id(item.id).to_def_id();\n+                    let local_def_id = this.r.local_def_id(item.id).to_def_id();\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n@@ -880,7 +881,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let local_def_id = this.r.definitions.local_def_id(item.id).to_def_id();\n+                    let local_def_id = this.r.local_def_id(item.id).to_def_id();\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n@@ -961,7 +962,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n             // Plain insert (no renaming).\n-            let res = Res::Def(def_kind, self.r.definitions.local_def_id(param.id).to_def_id());\n+            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n \n             match param.kind {\n                 GenericParamKind::Type { .. } => {\n@@ -1111,7 +1112,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             this.with_self_rib(Res::SelfTy(None, None), |this| {\n                 // Resolve the trait reference, if necessary.\n                 this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n-                    let item_def_id = this.r.definitions.local_def_id(item_id).to_def_id();\n+                    let item_def_id = this.r.local_def_id(item_id).to_def_id();\n                     this.with_self_rib(Res::SelfTy(trait_id, Some(item_def_id)), |this| {\n                         if let Some(trait_ref) = opt_trait_reference.as_ref() {\n                             // Resolve type arguments in the trait path.\n@@ -2002,7 +2003,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if let StmtKind::Item(ref item) = stmt.kind {\n                 if let ItemKind::MacroDef(..) = item.kind {\n                     num_macro_definition_ribs += 1;\n-                    let res = self.r.definitions.local_def_id(item.id).to_def_id();\n+                    let res = self.r.local_def_id(item.id).to_def_id();\n                     self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n                     self.label_ribs.push(Rib::new(MacroDefinition(res)));\n                 }\n@@ -2296,7 +2297,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) -> SmallVec<[LocalDefId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.r.definitions.local_def_id(import.id);\n+            let id = self.r.local_def_id(import.id);\n             self.r.maybe_unused_trait_imports.insert(id);\n             self.r.add_to_glob_map(&import, trait_name);\n             import_ids.push(id);"}, {"sha": "1bce160acb6100ebbb2d23edd8c6a2d49f484ab1", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -512,7 +512,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 _ => {}\n             }\n             if !suggested {\n-                if let Some(span) = self.r.definitions.opt_span(def_id) {\n+                if let Some(span) = self.r.opt_span(def_id) {\n                     err.span_label(span, &format!(\"`{}` defined here\", path_str));\n                 }\n                 err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str));\n@@ -536,7 +536,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 if nightly_options::is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n-                    if let Some(span) = self.r.definitions.opt_span(def_id) {\n+                    if let Some(span) = self.r.opt_span(def_id) {\n                         err.span_help(span, msg);\n                     } else {\n                         err.help(msg);\n@@ -593,7 +593,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 bad_struct_syntax_suggestion(def_id);\n             }\n             (Res::Def(DefKind::Ctor(_, CtorKind::Fn), def_id), _) if ns == ValueNS => {\n-                if let Some(span) = self.r.definitions.opt_span(def_id) {\n+                if let Some(span) = self.r.opt_span(def_id) {\n                     err.span_label(span, &format!(\"`{}` defined here\", path_str));\n                 }\n                 err.span_label(span, format!(\"did you mean `{}( /* fields */ )`?\", path_str));"}, {"sha": "ce068b8ac69a45bda1ce19184773ca6f70c564dc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 106, "deletions": 25, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -27,6 +27,7 @@ use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::ptr_key::PtrKey;\n@@ -36,9 +37,10 @@ use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n-use rustc_hir::definitions::{DefKey, Definitions};\n+use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n use rustc_hir::TraitCandidate;\n+use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n@@ -256,31 +258,21 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n     }\n }\n \n-struct UsePlacementFinder<'d> {\n-    definitions: &'d Definitions,\n-    target_module: LocalDefId,\n+struct UsePlacementFinder {\n+    target_module: NodeId,\n     span: Option<Span>,\n     found_use: bool,\n }\n \n-impl<'d> UsePlacementFinder<'d> {\n-    fn check(\n-        definitions: &'d Definitions,\n-        krate: &Crate,\n-        target_module: DefId,\n-    ) -> (Option<Span>, bool) {\n-        if let Some(target_module) = target_module.as_local() {\n-            let mut finder =\n-                UsePlacementFinder { definitions, target_module, span: None, found_use: false };\n-            visit::walk_crate(&mut finder, krate);\n-            (finder.span, finder.found_use)\n-        } else {\n-            (None, false)\n-        }\n+impl UsePlacementFinder {\n+    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n+        let mut finder = UsePlacementFinder { target_module, span: None, found_use: false };\n+        visit::walk_crate(&mut finder, krate);\n+        (finder.span, finder.found_use)\n     }\n }\n \n-impl<'tcx, 'd> Visitor<'tcx> for UsePlacementFinder<'d> {\n+impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     fn visit_mod(\n         &mut self,\n         module: &'tcx ast::Mod,\n@@ -291,7 +283,7 @@ impl<'tcx, 'd> Visitor<'tcx> for UsePlacementFinder<'d> {\n         if self.span.is_some() {\n             return;\n         }\n-        if self.definitions.local_def_id(node_id) != self.target_module {\n+        if node_id != self.target_module {\n             visit::walk_mod(self, module);\n             return;\n         }\n@@ -979,6 +971,19 @@ pub struct Resolver<'a> {\n     lint_buffer: LintBuffer,\n \n     next_node_id: NodeId,\n+\n+    def_id_to_span: IndexVec<LocalDefId, Span>,\n+\n+    node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n+    def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n+\n+    /// Indices of unnamed struct or variant fields with unresolved attributes.\n+    placeholder_field_indices: FxHashMap<NodeId, usize>,\n+    /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n+    /// we know what parent node that fragment should be attached to thanks to this table.\n+    invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n+\n+    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1042,7 +1047,7 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n \n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n-impl rustc_ast_lowering::Resolver for Resolver<'_> {\n+impl ResolverAstLowering for Resolver<'_> {\n     fn def_key(&mut self, id: DefId) -> DefKey {\n         if let Some(id) = id.as_local() {\n             self.definitions().def_key(id)\n@@ -1113,6 +1118,56 @@ impl rustc_ast_lowering::Resolver for Resolver<'_> {\n     fn trait_map(&self) -> &NodeMap<Vec<TraitCandidate>> {\n         &self.trait_map\n     }\n+\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n+        self.node_id_to_def_id.get(&node).copied()\n+    }\n+\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+    }\n+\n+    /// Adds a definition with a parent definition.\n+    fn create_def(\n+        &mut self,\n+        parent: LocalDefId,\n+        node_id: ast::NodeId,\n+        data: DefPathData,\n+        expn_id: ExpnId,\n+        span: Span,\n+    ) -> LocalDefId {\n+        assert!(\n+            !self.node_id_to_def_id.contains_key(&node_id),\n+            \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n+            node_id,\n+            data,\n+            self.definitions.def_key(self.node_id_to_def_id[&node_id]),\n+        );\n+\n+        // Find the next free disambiguator for this key.\n+        let next_disambiguator = &mut self.next_disambiguator;\n+        let next_disambiguator = |parent, data| {\n+            let next_disamb = next_disambiguator.entry((parent, data)).or_insert(0);\n+            let disambiguator = *next_disamb;\n+            *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n+            disambiguator\n+        };\n+\n+        let def_id = self.definitions.create_def(parent, data, expn_id, next_disambiguator);\n+\n+        assert_eq!(self.def_id_to_span.push(span), def_id);\n+\n+        // Some things for which we allocate `LocalDefId`s don't correspond to\n+        // anything in the AST, so they don't have a `NodeId`. For these cases\n+        // we don't need a mapping from `NodeId` to `LocalDefId`.\n+        if node_id != ast::DUMMY_NODE_ID {\n+            debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n+            self.node_id_to_def_id.insert(node_id, def_id);\n+        }\n+        assert_eq!(self.def_id_to_node_id.push(node_id), def_id);\n+\n+        def_id\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1143,8 +1198,18 @@ impl<'a> Resolver<'a> {\n         let mut module_map = FxHashMap::default();\n         module_map.insert(LocalDefId { local_def_index: CRATE_DEF_INDEX }, graph_root);\n \n-        let mut definitions = Definitions::default();\n-        definitions.create_root_def(crate_name, session.local_crate_disambiguator());\n+        let definitions = Definitions::new(crate_name, session.local_crate_disambiguator());\n+        let root = definitions.get_root_def();\n+\n+        let mut def_id_to_span = IndexVec::default();\n+        assert_eq!(def_id_to_span.push(rustc_span::DUMMY_SP), root);\n+        let mut def_id_to_node_id = IndexVec::default();\n+        assert_eq!(def_id_to_node_id.push(CRATE_NODE_ID), root);\n+        let mut node_id_to_def_id = FxHashMap::default();\n+        node_id_to_def_id.insert(CRATE_NODE_ID, root);\n+\n+        let mut invocation_parents = FxHashMap::default();\n+        invocation_parents.insert(ExpnId::root(), root);\n \n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = session\n             .opts\n@@ -1263,6 +1328,12 @@ impl<'a> Resolver<'a> {\n             variant_vis: Default::default(),\n             lint_buffer: LintBuffer::default(),\n             next_node_id: NodeId::from_u32(1),\n+            def_id_to_span,\n+            node_id_to_def_id,\n+            def_id_to_node_id,\n+            placeholder_field_indices: Default::default(),\n+            invocation_parents,\n+            next_disambiguator: Default::default(),\n         }\n     }\n \n@@ -1457,7 +1528,7 @@ impl<'a> Resolver<'a> {\n     #[inline]\n     fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n         if import.is_glob() {\n-            let def_id = self.definitions.local_def_id(import.id);\n+            let def_id = self.local_def_id(import.id);\n             self.glob_map.entry(def_id).or_default().insert(ident.name);\n         }\n     }\n@@ -2538,7 +2609,11 @@ impl<'a> Resolver<'a> {\n         for UseError { mut err, candidates, def_id, instead, suggestion } in\n             self.use_injections.drain(..)\n         {\n-            let (span, found_use) = UsePlacementFinder::check(&self.definitions, krate, def_id);\n+            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n+                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n+            } else {\n+                (None, false)\n+            };\n             if !candidates.is_empty() {\n                 diagnostics::show_candidates(&mut err, span, &candidates, instead, found_use);\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n@@ -2934,6 +3009,12 @@ impl<'a> Resolver<'a> {\n     pub fn all_macros(&self) -> &FxHashMap<Symbol, Res> {\n         &self.all_macros\n     }\n+\n+    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n+    #[inline]\n+    pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n+        if let Some(def_id) = def_id.as_local() { Some(self.def_id_to_span[def_id]) } else { None }\n+    }\n }\n \n fn names_to_string(names: &[Symbol]) -> String {"}, {"sha": "398b0e92d9d8cf5fcbfb531b7ed84661aa882798", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -7,6 +7,7 @@ use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy};\n use crate::{CrateLint, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n use rustc_ast::ast::{self, NodeId};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, StabilityLevel};\n use rustc_data_structures::fx::FxHashSet;\n@@ -190,7 +191,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         )));\n \n         let parent_scope = if let Some(module_id) = parent_module_id {\n-            let parent_def_id = self.definitions.local_def_id(module_id);\n+            let parent_def_id = self.local_def_id(module_id);\n             self.definitions.add_parent_module_of_macro_def(expn_id, parent_def_id.to_def_id());\n             self.module_map[&parent_def_id]\n         } else {\n@@ -340,7 +341,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId {\n-        self.definitions.lint_node_id(expn_id)\n+        self.invocation_parents\n+            .get(&expn_id)\n+            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[*id])\n     }\n \n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool {"}, {"sha": "c5a866817cb4a1930a5b085f22f32d11d50212c2", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1849,6 +1849,7 @@ fn parse_pretty(\n                 }\n             }\n         };\n+        log::debug!(\"got unpretty option: {:?}\", first);\n         first\n     }\n }\n@@ -1977,9 +1978,11 @@ impl PpMode {\n         use PpMode::*;\n         use PpSourceMode::*;\n         match *self {\n-            PpmSource(PpmNormal | PpmEveryBodyLoops | PpmIdentified) => false,\n+            PpmSource(PpmNormal | PpmIdentified) => false,\n \n-            PpmSource(PpmExpanded | PpmExpandedIdentified | PpmExpandedHygiene)\n+            PpmSource(\n+                PpmExpanded | PpmEveryBodyLoops | PpmExpandedIdentified | PpmExpandedHygiene,\n+            )\n             | PpmHir(_)\n             | PpmHirTree(_)\n             | PpmMir"}, {"sha": "973891eb84eda2006a56ad9b195d58c60520b5e0", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -880,8 +880,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n-        \"instrument the generated code with LLVM code region counters to \\\n-        (in the future) generate coverage reports (experimental; default: no)\"),\n+        \"instrument the generated code with LLVM code region counters to (in the \\\n+        future) generate coverage reports (default: no; note, the compiler build \\\n+        config must include `profiler = true`)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "fa1368b104c7e02e45eb217dfe7f9024693babd6", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -159,6 +159,7 @@ symbols! {\n         assume_init,\n         async_await,\n         async_closure,\n+        atomics,\n         attr,\n         attributes,\n         attr_literals,\n@@ -587,6 +588,7 @@ symbols! {\n         proc_macro_mod,\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n+        profiler_builtins,\n         profiler_runtime,\n         ptr_guaranteed_eq,\n         ptr_guaranteed_ne,"}, {"sha": "85c073ca3003439aec9fd2e5a057e11e2239aa0e", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -34,6 +34,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n         self.suggest_missing_await(err, expr, expected, expr_ty);\n+        self.note_need_for_fn_pointer(err, expected, expr_ty);\n     }\n \n     // Requires that the two types unify, and prints an error message if"}, {"sha": "0325782e69d516a17d127c8ad2bc2b835723e9d4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -5362,6 +5362,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn note_need_for_fn_pointer(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        let (sig, did, substs) = match (&expected.kind, &found.kind) {\n+            (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n+                let sig1 = self.tcx.fn_sig(*did1).subst(self.tcx, substs1);\n+                let sig2 = self.tcx.fn_sig(*did2).subst(self.tcx, substs2);\n+                if sig1 != sig2 {\n+                    return;\n+                }\n+                err.note(\n+                    \"different `fn` items always have unique types, even if their signatures are \\\n+                     the same\",\n+                );\n+                (sig1, *did1, substs1)\n+            }\n+            (ty::FnDef(did, substs), ty::FnPtr(sig2)) => {\n+                let sig1 = self.tcx.fn_sig(*did).subst(self.tcx, substs);\n+                if sig1 != *sig2 {\n+                    return;\n+                }\n+                (sig1, *did, substs)\n+            }\n+            _ => return,\n+        };\n+        err.help(&format!(\"change the expected type to be function pointer `{}`\", sig));\n+        err.help(&format!(\n+            \"if the expected type is due to type inference, cast the expected `fn` to a function \\\n+             pointer: `{} as {}`\",\n+            self.tcx.def_path_str_with_substs(did, substs),\n+            sig\n+        ));\n+    }\n+\n     /// A common error is to add an extra semicolon:\n     ///\n     /// ```"}, {"sha": "6dec016cc2ee3d7a0c70de06ce58d2567510d912", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -486,6 +486,33 @@ impl Attributes {\n         })\n     }\n \n+    /// Enforce the format of attributes inside `#[doc(...)]`.\n+    pub fn check_doc_attributes(\n+        diagnostic: &::rustc_errors::Handler,\n+        mi: &ast::MetaItem,\n+    ) -> Option<(String, String)> {\n+        mi.meta_item_list().and_then(|list| {\n+            for meta in list {\n+                if meta.check_name(sym::alias) {\n+                    if !meta.is_value_str()\n+                        || meta\n+                            .value_str()\n+                            .map(|s| s.to_string())\n+                            .unwrap_or_else(String::new)\n+                            .is_empty()\n+                    {\n+                        diagnostic.span_err(\n+                            meta.span(),\n+                            \"doc alias attribute expects a string: #[doc(alias = \\\"0\\\")]\",\n+                        );\n+                    }\n+                }\n+            }\n+\n+            None\n+        })\n+    }\n+\n     pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n             if !attr.check_name(sym::doc) {\n@@ -529,6 +556,7 @@ impl Attributes {\n                 } else {\n                     if attr.check_name(sym::doc) {\n                         if let Some(mi) = attr.meta() {\n+                            Attributes::check_doc_attributes(&diagnostic, &mi);\n                             if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n                                 // Extracted #[doc(cfg(...))]\n                                 match Cfg::parse(cfg_mi) {"}, {"sha": "7ceec94d81e762ee32c19c428f6be95179eb9f7a", "filename": "src/test/mir-opt/const_prop/bad_op_unsafe_oob_for_slices/32bit/rustc.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F32bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F32bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F32bit%2Frustc.main.ConstProp.diff?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -46,22 +46,8 @@\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n                                            // + literal: Const { ty: usize, val: Value(Scalar(0x00000003)) }\n--         _7 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n--         _8 = Lt(_6, _7);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+         _7 = const 3usize;               // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // ty::Const\n-+                                          // + ty: usize\n-+                                          // + val: Value(Scalar(0x00000003))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000003)) }\n-+         _8 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // ty::Const\n-+                                          // + ty: bool\n-+                                          // + val: Value(Scalar(0x00))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          _7 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+          _8 = Lt(_6, _7);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n           assert(move _8, \"index out of bounds: the len is {} but the index is {}\", move _7, _6) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n       }\n   "}, {"sha": "483a6f232ef79677a0b2b7e31425a61d3b80f6bf", "filename": "src/test/mir-opt/const_prop/bad_op_unsafe_oob_for_slices/64bit/rustc.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F64bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F64bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F64bit%2Frustc.main.ConstProp.diff?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -46,22 +46,8 @@\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n                                            // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }\n--         _7 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n--         _8 = Lt(_6, _7);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+         _7 = const 3usize;               // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // ty::Const\n-+                                          // + ty: usize\n-+                                          // + val: Value(Scalar(0x0000000000000003))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }\n-+         _8 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // ty::Const\n-+                                          // + ty: bool\n-+                                          // + val: Value(Scalar(0x00))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n-+                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          _7 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+          _8 = Lt(_6, _7);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n           assert(move _8, \"index out of bounds: the len is {} but the index is {}\", move _7, _6) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n       }\n   "}, {"sha": "043b22870f49e047180b00fc363e8c3cb1f0787d", "filename": "src/test/mir-opt/const_prop_miscompile.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -0,0 +1,22 @@\n+#![feature(raw_ref_op)]\n+\n+// EMIT_MIR rustc.foo.ConstProp.diff\n+fn foo() {\n+    let mut u = (1,);\n+    *&mut u.0 = 5;\n+    let y = { u.0 } == 5;\n+}\n+\n+// EMIT_MIR rustc.bar.ConstProp.diff\n+fn bar() {\n+    let mut v = (1,);\n+    unsafe {\n+        *&raw mut v.0 = 5;\n+    }\n+    let y = { v.0 } == 5;\n+}\n+\n+fn main() {\n+    foo();\n+    bar();\n+}"}, {"sha": "c87f67bf9f587b5ed1adc05e1d24638a34928a01", "filename": "src/test/mir-opt/const_prop_miscompile/rustc.bar.ConstProp.diff", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile%2Frustc.bar.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile%2Frustc.bar.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile%2Frustc.bar.ConstProp.diff?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -0,0 +1,75 @@\n+- // MIR for `bar` before ConstProp\n++ // MIR for `bar` after ConstProp\n+  \n+  fn bar() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/const_prop_miscompile.rs:11:10: 11:10\n+      let mut _1: (i32,);                  // in scope 0 at $DIR/const_prop_miscompile.rs:12:9: 12:14\n+      let _2: ();                          // in scope 0 at $DIR/const_prop_miscompile.rs:13:5: 15:6\n+      let mut _3: *mut i32;                // in scope 0 at $DIR/const_prop_miscompile.rs:14:10: 14:22\n+      let mut _5: i32;                     // in scope 0 at $DIR/const_prop_miscompile.rs:16:13: 16:20\n+      scope 1 {\n+          debug v => _1;                   // in scope 1 at $DIR/const_prop_miscompile.rs:12:9: 12:14\n+          let _4: bool;                    // in scope 1 at $DIR/const_prop_miscompile.rs:16:9: 16:10\n+          scope 2 {\n+          }\n+          scope 3 {\n+              debug y => _4;               // in scope 3 at $DIR/const_prop_miscompile.rs:16:9: 16:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:12:9: 12:14\n+-         _1 = (const 1i32,);              // scope 0 at $DIR/const_prop_miscompile.rs:12:17: 12:21\n++         _1 = const (1i32,);              // scope 0 at $DIR/const_prop_miscompile.rs:12:17: 12:21\n+                                           // ty::Const\n+-                                          // + ty: i32\n++                                          // + ty: (i32,)\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/const_prop_miscompile.rs:12:18: 12:19\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n++                                          // + span: $DIR/const_prop_miscompile.rs:12:17: 12:21\n++                                          // + literal: Const { ty: (i32,), val: Value(Scalar(0x00000001)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:13:5: 15:6\n+          StorageLive(_3);                 // scope 2 at $DIR/const_prop_miscompile.rs:14:10: 14:22\n+          _3 = &raw mut (_1.0: i32);       // scope 2 at $DIR/const_prop_miscompile.rs:14:10: 14:22\n+          (*_3) = const 5i32;              // scope 2 at $DIR/const_prop_miscompile.rs:14:9: 14:26\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000005))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const_prop_miscompile.rs:14:25: 14:26\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000005)) }\n+          StorageDead(_3);                 // scope 2 at $DIR/const_prop_miscompile.rs:14:26: 14:27\n+          _2 = const ();                   // scope 2 at $DIR/const_prop_miscompile.rs:13:5: 15:6\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const_prop_miscompile.rs:13:5: 15:6\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:15:5: 15:6\n+          StorageLive(_4);                 // scope 1 at $DIR/const_prop_miscompile.rs:16:9: 16:10\n+          StorageLive(_5);                 // scope 1 at $DIR/const_prop_miscompile.rs:16:13: 16:20\n+          _5 = (_1.0: i32);                // scope 1 at $DIR/const_prop_miscompile.rs:16:15: 16:18\n+          _4 = Eq(move _5, const 5i32);    // scope 1 at $DIR/const_prop_miscompile.rs:16:13: 16:25\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000005))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const_prop_miscompile.rs:16:24: 16:25\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000005)) }\n+          StorageDead(_5);                 // scope 1 at $DIR/const_prop_miscompile.rs:16:24: 16:25\n+          _0 = const ();                   // scope 0 at $DIR/const_prop_miscompile.rs:11:10: 17:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const_prop_miscompile.rs:11:10: 17:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_4);                 // scope 1 at $DIR/const_prop_miscompile.rs:17:1: 17:2\n+          StorageDead(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:17:1: 17:2\n+          return;                          // scope 0 at $DIR/const_prop_miscompile.rs:17:2: 17:2\n+      }\n+  }\n+  "}, {"sha": "8a6850d2fe3adaa7611579501650079b34d95364", "filename": "src/test/mir-opt/const_prop_miscompile/rustc.foo.ConstProp.diff", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile%2Frustc.foo.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile%2Frustc.foo.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop_miscompile%2Frustc.foo.ConstProp.diff?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -0,0 +1,63 @@\n+- // MIR for `foo` before ConstProp\n++ // MIR for `foo` after ConstProp\n+  \n+  fn foo() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/const_prop_miscompile.rs:4:10: 4:10\n+      let mut _1: (i32,);                  // in scope 0 at $DIR/const_prop_miscompile.rs:5:9: 5:14\n+      let mut _2: &mut i32;                // in scope 0 at $DIR/const_prop_miscompile.rs:6:6: 6:14\n+      let mut _4: i32;                     // in scope 0 at $DIR/const_prop_miscompile.rs:7:13: 7:20\n+      scope 1 {\n+          debug u => _1;                   // in scope 1 at $DIR/const_prop_miscompile.rs:5:9: 5:14\n+          let _3: bool;                    // in scope 1 at $DIR/const_prop_miscompile.rs:7:9: 7:10\n+          scope 2 {\n+              debug y => _3;               // in scope 2 at $DIR/const_prop_miscompile.rs:7:9: 7:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:5:9: 5:14\n+-         _1 = (const 1i32,);              // scope 0 at $DIR/const_prop_miscompile.rs:5:17: 5:21\n++         _1 = const (1i32,);              // scope 0 at $DIR/const_prop_miscompile.rs:5:17: 5:21\n+                                           // ty::Const\n+-                                          // + ty: i32\n++                                          // + ty: (i32,)\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/const_prop_miscompile.rs:5:18: 5:19\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n++                                          // + span: $DIR/const_prop_miscompile.rs:5:17: 5:21\n++                                          // + literal: Const { ty: (i32,), val: Value(Scalar(0x00000001)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:6:6: 6:14\n+          _2 = &mut (_1.0: i32);           // scope 1 at $DIR/const_prop_miscompile.rs:6:6: 6:14\n+          (*_2) = const 5i32;              // scope 1 at $DIR/const_prop_miscompile.rs:6:5: 6:18\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000005))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const_prop_miscompile.rs:6:17: 6:18\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000005)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:6:18: 6:19\n+          StorageLive(_3);                 // scope 1 at $DIR/const_prop_miscompile.rs:7:9: 7:10\n+          StorageLive(_4);                 // scope 1 at $DIR/const_prop_miscompile.rs:7:13: 7:20\n+          _4 = (_1.0: i32);                // scope 1 at $DIR/const_prop_miscompile.rs:7:15: 7:18\n+          _3 = Eq(move _4, const 5i32);    // scope 1 at $DIR/const_prop_miscompile.rs:7:13: 7:25\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000005))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const_prop_miscompile.rs:7:24: 7:25\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000005)) }\n+          StorageDead(_4);                 // scope 1 at $DIR/const_prop_miscompile.rs:7:24: 7:25\n+          _0 = const ();                   // scope 0 at $DIR/const_prop_miscompile.rs:4:10: 8:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const_prop_miscompile.rs:4:10: 8:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_3);                 // scope 1 at $DIR/const_prop_miscompile.rs:8:1: 8:2\n+          StorageDead(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:8:1: 8:2\n+          return;                          // scope 0 at $DIR/const_prop_miscompile.rs:8:2: 8:2\n+      }\n+  }\n+  "}, {"sha": "2f01099107d9ee44d1f91ca55c76253927366967", "filename": "src/test/rustdoc-ui/check-doc-alias-attr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -0,0 +1,9 @@\n+#![feature(doc_alias)]\n+\n+#[doc(alias = \"foo\")] // ok!\n+pub struct Bar;\n+\n+#[doc(alias)] //~ ERROR\n+#[doc(alias = 0)] //~ ERROR\n+#[doc(alias(\"bar\"))] //~ ERROR\n+pub struct Foo;"}, {"sha": "480acc821aaa85fd1c525ad7511da8140d77d5d1", "filename": "src/test/rustdoc-ui/check-doc-alias-attr.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -0,0 +1,20 @@\n+error: doc alias attribute expects a string: #[doc(alias = \"0\")]\n+  --> $DIR/check-doc-alias-attr.rs:6:7\n+   |\n+LL | #[doc(alias)]\n+   |       ^^^^^\n+\n+error: doc alias attribute expects a string: #[doc(alias = \"0\")]\n+  --> $DIR/check-doc-alias-attr.rs:7:7\n+   |\n+LL | #[doc(alias = 0)]\n+   |       ^^^^^^^^^\n+\n+error: doc alias attribute expects a string: #[doc(alias = \"0\")]\n+  --> $DIR/check-doc-alias-attr.rs:8:7\n+   |\n+LL | #[doc(alias(\"bar\"))]\n+   |       ^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "abae40162a0fcacdfc6f58397fc0fa8622f60204", "filename": "src/test/ui/fn/fn-item-type.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Ffn%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Ffn%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Ffn-item-type.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -12,22 +12,44 @@ impl<T> Foo for T { /* `foo` is still default here */ }\n fn main() {\n     eq(foo::<u8>, bar::<u8>);\n     //~^ ERROR mismatched types\n-    //~|  expected fn item `fn(_) -> _ {foo::<u8>}`\n-    //~|  found fn item `fn(_) -> _ {bar::<u8>}`\n-    //~|  expected fn item, found a different fn item\n+    //~| expected fn item `fn(_) -> _ {foo::<u8>}`\n+    //~| found fn item `fn(_) -> _ {bar::<u8>}`\n+    //~| expected fn item, found a different fn item\n+    //~| different `fn` items always have unique types, even if their signatures are the same\n+    //~| change the expected type to be function pointer\n+    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n \n     eq(foo::<u8>, foo::<i8>);\n     //~^ ERROR mismatched types\n     //~| expected `u8`, found `i8`\n+    //~| different `fn` items always have unique types, even if their signatures are the same\n+    //~| change the expected type to be function pointer\n+    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n \n     eq(bar::<String>, bar::<Vec<u8>>);\n     //~^ ERROR mismatched types\n-    //~|  expected fn item `fn(_) -> _ {bar::<std::string::String>}`\n-    //~|  found fn item `fn(_) -> _ {bar::<std::vec::Vec<u8>>}`\n-    //~|  expected struct `std::string::String`, found struct `std::vec::Vec`\n+    //~| expected fn item `fn(_) -> _ {bar::<std::string::String>}`\n+    //~| found fn item `fn(_) -> _ {bar::<std::vec::Vec<u8>>}`\n+    //~| expected struct `std::string::String`, found struct `std::vec::Vec`\n+    //~| different `fn` items always have unique types, even if their signatures are the same\n+    //~| change the expected type to be function pointer\n+    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n \n     // Make sure we distinguish between trait methods correctly.\n     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n     //~^ ERROR mismatched types\n     //~| expected `u8`, found `u16`\n+    //~| different `fn` items always have unique types, even if their signatures are the same\n+    //~| change the expected type to be function pointer\n+    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n+\n+    eq(foo::<u8>, bar::<u8> as fn(isize) -> isize);\n+    //~^ ERROR mismatched types\n+    //~| expected fn item `fn(_) -> _ {foo::<u8>}`\n+    //~| found fn pointer `fn(_) -> _`\n+    //~| expected fn item, found fn pointer\n+    //~| change the expected type to be function pointer\n+    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n+\n+    eq(foo::<u8> as fn(isize) -> isize, bar::<u8>); // ok!\n }"}, {"sha": "bfa9efa219f4c8aa71c2df4a1a00e8e0820f74d8", "filename": "src/test/ui/fn/fn-item-type.stderr", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Ffn%2Ffn-item-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Ffn%2Ffn-item-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Ffn-item-type.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -6,34 +6,57 @@ LL |     eq(foo::<u8>, bar::<u8>);\n    |\n    = note: expected fn item `fn(_) -> _ {foo::<u8>}`\n               found fn item `fn(_) -> _ {bar::<u8>}`\n+   = note: different `fn` items always have unique types, even if their signatures are the same\n+   = help: change the expected type to be function pointer `fn(isize) -> isize`\n+   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `foo::<u8> as fn(isize) -> isize`\n \n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:19:19\n+  --> $DIR/fn-item-type.rs:22:19\n    |\n LL |     eq(foo::<u8>, foo::<i8>);\n    |                   ^^^^^^^^^ expected `u8`, found `i8`\n    |\n    = note: expected fn item `fn(_) -> _ {foo::<u8>}`\n               found fn item `fn(_) -> _ {foo::<i8>}`\n+   = note: different `fn` items always have unique types, even if their signatures are the same\n+   = help: change the expected type to be function pointer `fn(isize) -> isize`\n+   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `foo::<u8> as fn(isize) -> isize`\n \n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:23:23\n+  --> $DIR/fn-item-type.rs:29:23\n    |\n LL |     eq(bar::<String>, bar::<Vec<u8>>);\n    |                       ^^^^^^^^^^^^^^ expected struct `std::string::String`, found struct `std::vec::Vec`\n    |\n    = note: expected fn item `fn(_) -> _ {bar::<std::string::String>}`\n               found fn item `fn(_) -> _ {bar::<std::vec::Vec<u8>>}`\n+   = note: different `fn` items always have unique types, even if their signatures are the same\n+   = help: change the expected type to be function pointer `fn(isize) -> isize`\n+   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `bar::<std::string::String> as fn(isize) -> isize`\n \n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:30:26\n+  --> $DIR/fn-item-type.rs:39:26\n    |\n LL |     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n    |                          ^^^^^^^^^^^^^^^^^ expected `u8`, found `u16`\n    |\n    = note: expected fn item `fn() {<u8 as Foo>::foo}`\n               found fn item `fn() {<u16 as Foo>::foo}`\n+   = note: different `fn` items always have unique types, even if their signatures are the same\n+   = help: change the expected type to be function pointer `fn()`\n+   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `<u8 as Foo>::foo as fn()`\n \n-error: aborting due to 4 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/fn-item-type.rs:46:19\n+   |\n+LL |     eq(foo::<u8>, bar::<u8> as fn(isize) -> isize);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected fn item, found fn pointer\n+   |\n+   = note: expected fn item `fn(_) -> _ {foo::<u8>}`\n+           found fn pointer `fn(_) -> _`\n+   = help: change the expected type to be function pointer `fn(isize) -> isize`\n+   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `foo::<u8> as fn(isize) -> isize`\n+\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "9fee01c1ba62329789f91af0e17a8c080203df7d", "filename": "src/test/ui/infinite/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,9 +1,3 @@\n-//\n-// We get an error message at the top of file (dummy span).\n-// This is not helpful, but also kind of annoying to prevent,\n-// so for now just live with it.\n-// This test case was originally for issue #2258.\n-\n // build-fail\n \n trait ToOpt: Sized {\n@@ -23,11 +17,9 @@ impl<T:Clone> ToOpt for Option<T> {\n }\n \n fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n-//~^ ERROR reached the recursion limit while instantiating `function::<std::option::Option<\n     if counter > 0 {\n         function(counter - 1, t.to_option());\n-        // FIXME(#4287) Error message should be here. It should be\n-        // a type error to instantiate `test` at a type other than T.\n+        //~^ ERROR reached the recursion limit while instantiating `function::<std::option::Option<\n     }\n }\n "}, {"sha": "7b22393ee7c0f7a7ee856a87c1dbd9d35fd83fca", "filename": "src/test/ui/infinite/infinite-instantiation.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,11 +1,16 @@\n error: reached the recursion limit while instantiating `function::<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<usize>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n-  --> $DIR/infinite-instantiation.rs:25:1\n+  --> $DIR/infinite-instantiation.rs:21:9\n+   |\n+LL |         function(counter - 1, t.to_option());\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `function` defined here\n+  --> $DIR/infinite-instantiation.rs:19:1\n    |\n LL | / fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n-LL | |\n LL | |     if counter > 0 {\n LL | |         function(counter - 1, t.to_option());\n-...  |\n+LL | |\n LL | |     }\n LL | | }\n    | |_^"}, {"sha": "b0fcb74764b987b8e3f2fe1160cf4d1d2ee48a9e", "filename": "src/test/ui/issues/issue-67552.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -18,13 +18,13 @@ fn identity<T>(x: T) -> T {\n }\n \n fn rec<T>(mut it: T)\n-//~^ ERROR reached the recursion limit while instantiating\n where\n     T: Iterator,\n {\n     if () == () {\n         T::count(it);\n     } else {\n         rec(identity(&mut it))\n+        //~^ ERROR reached the recursion limit while instantiating\n     }\n }"}, {"sha": "3bb2016f07d24f03fc2f609343be749f589e3408", "filename": "src/test/ui/issues/issue-67552.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,10 +1,16 @@\n error: reached the recursion limit while instantiating `rec::<&mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut Empty>`\n+  --> $DIR/issue-67552.rs:27:9\n+   |\n+LL |         rec(identity(&mut it))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `rec` defined here\n   --> $DIR/issue-67552.rs:20:1\n    |\n LL | / fn rec<T>(mut it: T)\n-LL | |\n LL | | where\n LL | |     T: Iterator,\n+LL | | {\n ...  |\n LL | |     }\n LL | | }"}, {"sha": "14bdd8511119e0fdda184fb679c9d44925c5218c", "filename": "src/test/ui/issues/issue-8727.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8727.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -3,12 +3,10 @@\n \n // build-fail\n \n-fn generic<T>() {\n+fn generic<T>() { //~ WARN function cannot return without recursing\n     generic::<Option<T>>();\n }\n-//~^^^ ERROR reached the recursion limit while instantiating `generic::<std::option::Option<\n-//~| WARN function cannot return without recursing\n-\n+//~^^ ERROR reached the recursion limit while instantiating `generic::<std::option::Option<\n \n \n fn main () {"}, {"sha": "70709fd33ac3ac170f287fbeaaf70ce118c59c2f", "filename": "src/test/ui/issues/issue-8727.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -10,6 +10,12 @@ LL |     generic::<Option<T>>();\n    = help: a `loop` may express intention better if this is on purpose\n \n error: reached the recursion limit while instantiating `generic::<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/issue-8727.rs:7:5\n+   |\n+LL |     generic::<Option<T>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `generic` defined here\n   --> $DIR/issue-8727.rs:6:1\n    |\n LL | / fn generic<T>() {"}, {"sha": "136c03cd9f1bcad4a1b1062f2fdc44515f81ffba", "filename": "src/test/ui/mir/mir_detects_invalid_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -19,6 +19,6 @@ fn mod_by_zero() {\n fn oob_error_for_slices() {\n     let a: *const [_] = &[1, 2, 3];\n     unsafe {\n-        let _b = (*a)[3]; //~ ERROR this operation will panic at runtime [unconditional_panic]\n+        let _b = (*a)[3];\n     }\n }"}, {"sha": "0b6dbfd7c3d85f61c00c4f8aad2a1c3ac1c896fb", "filename": "src/test/ui/mir/mir_detects_invalid_ops.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -12,11 +12,5 @@ error: this operation will panic at runtime\n LL |     let _z = 1 % y;\n    |              ^^^^^ attempt to calculate the remainder with a divisor of zero\n \n-error: this operation will panic at runtime\n-  --> $DIR/mir_detects_invalid_ops.rs:22:18\n-   |\n-LL |         let _b = (*a)[3];\n-   |                  ^^^^^^^ index out of bounds: the len is 3 but the index is 3\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "0552847c48ca9ac7b3ecaeac38d422e7e89b296c", "filename": "src/test/ui/recursion/issue-38591-non-regular-dropck-recursion.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,4 +1,22 @@\n error: reached the recursion limit while instantiating `std::intrinsics::drop_in_place::<S<fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(u32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))>> - shim(Some(S<fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(u32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))>))`\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+LL | |     // Code here does not matter - this is replaced by the\n+LL | |     // real drop glue by the compiler.\n+LL | |     drop_in_place(to_drop)\n+LL | | }\n+   | |_^\n+   |\n+note: `std::intrinsics::drop_in_place` defined here\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+LL | |     // Code here does not matter - this is replaced by the\n+LL | |     // real drop glue by the compiler.\n+LL | |     drop_in_place(to_drop)\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "373cc17d0e0fe1c05ceccc17740f8e3733a13d9a", "filename": "src/test/ui/recursion/recursion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -12,11 +12,10 @@ impl<T:Dot> Dot for Cons<T> {\n     self.head * other.head + self.tail.dot(other.tail)\n   }\n }\n-fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize { //~ ERROR recursion limit\n+fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n   match n {    0 => {first.dot(second)}\n-      // FIXME(#4287) Error message should be here. It should be\n-      // a type error to instantiate `test` at a type other than T.\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n+    //~^ ERROR recursion limit\n   }\n }\n pub fn main() {"}, {"sha": "0c0eba68c83b4d1ac7cd4181db93e553e0c9ca93", "filename": "src/test/ui/recursion/recursion.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr?ref=0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "patch": "@@ -1,11 +1,16 @@\n error: reached the recursion limit while instantiating `test::<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Nil>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/recursion.rs:17:11\n+   |\n+LL |     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `test` defined here\n   --> $DIR/recursion.rs:15:1\n    |\n LL | / fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n LL | |   match n {    0 => {first.dot(second)}\n-LL | |       // FIXME(#4287) Error message should be here. It should be\n-LL | |       // a type error to instantiate `test` at a type other than T.\n LL | |     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n+LL | |\n LL | |   }\n LL | | }\n    | |_^"}]}