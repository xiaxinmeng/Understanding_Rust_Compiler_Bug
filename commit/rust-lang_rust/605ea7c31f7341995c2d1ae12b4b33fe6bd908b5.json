{"sha": "605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNWVhN2MzMWY3MzQxOTk1YzJkMWFlMTJiNGIzM2ZlNmJkOTA4YjU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-27T19:03:39Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-27T19:03:39Z"}, "message": "Rollup merge of #49426 - lukaslueg:patch-1, r=kennytm\n\nUpdate CONTRIBUTING.md\n\nThe current link is a 404, just link to the main repo page", "tree": {"sha": "19b13ac2494f1e1b347ee8aae9c48150677434f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b13ac2494f1e1b347ee8aae9c48150677434f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlq6lYwACgkQ/vbIBR0O\nATzk1A//Ykju4rJsUrzq1aK2paZA/+rik5FQ/HsjSb5a6hQK84Ezc+v3t5ks8BIX\n3VuoknNhcZTqYnBGQd98eRGsm45oS0SNaekxLYOvW8dkFtxqaPBhRXTQDn/4JWyO\nqUFrE7uADbhyEF5X7a/lKRU6b913AXEeO/1t5XoXle4vswAyOtQ8hQsPqdG71hvo\njd47efLjWktZdh4Ch+ckAE5UOU5yAdtn4jPHrndjSEc8h1sUU3p1B2MamZ1fNlyz\nEnSt3NpnNVr6TAE5pkxTLVNJqNOmymv7TFlgDbhUaHi2PJ0v3O07BojSc0cWIEEI\nQjiJ39AHAz8axP8RqrKitQrwhh0f0q4KnUltlBX15WNJSiSOSnH3RvjlJHFnhFcg\nuMoMxEoUJEijhRyY1ydeGhIWwKcvuzO5splP3b9jzcsg/8n17Xzk/AODFEO2C5ZF\nnhfX6Uxc0U9fMGuHBcqmR5usrR62EDqFrfenpa0ky/L/LccwZM1GZnXtg2Xw3JEr\nebPwTEdahwnBTkqc6eWVaaCEB3vyMLqY/QF/LZP7JMDvkRQgkfTLBweYm81NZbZ6\n/NPHcOT4vZmmYcNRmvx74nXx03zagz2QfPvQlBHKlDYuzlMqGTLqwCiMkXBcf7N1\nI1JfanFpzGpBwXlXC9K9lcenlBXn1KIFe8f7KvM4m4vUob3n3EY=\n=i+Nl\n-----END PGP SIGNATURE-----", "payload": "tree 19b13ac2494f1e1b347ee8aae9c48150677434f3\nparent 19fe9d1181bb15f76cdf2b5335edff5a82c5152b\nparent f513fbdf36ad0708fb222b8d55bc086dd4be18cf\nauthor kennytm <kennytm@gmail.com> 1522177419 +0800\ncommitter kennytm <kennytm@gmail.com> 1522177419 +0800\n\nRollup merge of #49426 - lukaslueg:patch-1, r=kennytm\n\nUpdate CONTRIBUTING.md\n\nThe current link is a 404, just link to the main repo page\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "html_url": "https://github.com/rust-lang/rust/commit/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19fe9d1181bb15f76cdf2b5335edff5a82c5152b", "url": "https://api.github.com/repos/rust-lang/rust/commits/19fe9d1181bb15f76cdf2b5335edff5a82c5152b", "html_url": "https://github.com/rust-lang/rust/commit/19fe9d1181bb15f76cdf2b5335edff5a82c5152b"}, {"sha": "f513fbdf36ad0708fb222b8d55bc086dd4be18cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f513fbdf36ad0708fb222b8d55bc086dd4be18cf", "html_url": "https://github.com/rust-lang/rust/commit/f513fbdf36ad0708fb222b8d55bc086dd4be18cf"}], "stats": {"total": 686, "additions": 344, "deletions": 342}, "files": [{"sha": "7a62405f059677affac001298e8f5fd2f9dbe515", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -594,7 +594,7 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n [inom]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-nominated\n [eeasy]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy\n [lru]: https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-asc\n-[rfcbot]: https://github.com/dikaiosune/rust-dashboard/blob/master/RFCBOT.md\n+[rfcbot]: https://github.com/anp/rfcbot-rs/\n \n ## Out-of-tree Contributions\n [out-of-tree-contributions]: #out-of-tree-contributions"}, {"sha": "87144c27c9e11b1b71749f832c354cba97ff59f6", "filename": "src/libcore/array.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -59,7 +59,7 @@ unsafe impl<T, A: Unsize<[T]>> FixedSizeArray<T> for A {\n }\n \n /// The error type returned when a conversion from a slice to an array fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Debug, Copy, Clone)]\n pub struct TryFromSliceError(());\n \n@@ -148,7 +148,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.26.0\")]\n             impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n                 type Error = TryFromSliceError;\n \n@@ -162,7 +162,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.26.0\")]\n             impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n                 type Error = TryFromSliceError;\n "}, {"sha": "bbeebf52a73c19ddeda47bfcc44187b4532ed7a0", "filename": "src/libcore/char.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -265,7 +265,7 @@ impl FromStr for char {\n }\n \n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;\n \n@@ -280,11 +280,11 @@ impl TryFrom<u32> for char {\n }\n \n /// The error type returned when a conversion from u32 to char fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct CharTryFromError(());\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl fmt::Display for CharTryFromError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"converted integer out of range for `char`\".fmt(f)"}, {"sha": "637213957848c6b7c01bf35fb791a96356669a76", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -322,22 +322,26 @@ pub trait From<T>: Sized {\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Into`]: trait.Into.html\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     fn try_into(self) -> Result<T, Self::Error>;\n }\n \n /// Attempt to construct `Self` via a conversion.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     fn try_from(value: T) -> Result<Self, Self::Error>;\n }\n \n@@ -405,7 +409,7 @@ impl<T> From<T> for T {\n \n \n // TryFrom implies TryInto\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl<T, U> TryInto<U> for T where U: TryFrom<T>\n {\n     type Error = U::Error;\n@@ -417,7 +421,7 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n \n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl<T, U> TryFrom<U> for T where T: From<U> {\n     type Error = !;\n "}, {"sha": "72b48b565719c90271a57d61cd7a806fe4d5c51c", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -91,7 +91,7 @@ macro_rules! step_impl_unsigned {\n             #[inline]\n             #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n+                match <$t>::private_try_from(n) {\n                     Ok(n_as_t) => self.checked_add(n_as_t),\n                     Err(_) => None,\n                 }\n@@ -123,7 +123,7 @@ macro_rules! step_impl_signed {\n             #[inline]\n             #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n+                match <$unsigned>::private_try_from(n) {\n                     Ok(n_as_unsigned) => {\n                         // Wrapping in unsigned space handles cases like\n                         // `-120_i8.add_usize(200) == Some(80_i8)`,\n@@ -461,3 +461,73 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}\n+\n+/// Compensate removal of some impls per\n+/// https://github.com/rust-lang/rust/pull/49305#issuecomment-376293243\n+trait PrivateTryFromUsize: Sized {\n+    fn private_try_from(n: usize) -> Result<Self, ()>;\n+}\n+\n+impl<T> PrivateTryFromUsize for T where T: TryFrom<usize> {\n+    #[inline]\n+    fn private_try_from(n: usize) -> Result<Self, ()> {\n+        T::try_from(n).map_err(|_| ())\n+    }\n+}\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($($target:ty),*) => {$(\n+        impl PrivateTryFromUsize for $target {\n+            #[inline]\n+            fn private_try_from(value: usize) -> Result<Self, ()> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+macro_rules! try_from_upper_bounded {\n+    ($($target:ty),*) => {$(\n+        impl PrivateTryFromUsize for $target {\n+            #[inline]\n+            fn private_try_from(u: usize) -> Result<$target, ()> {\n+                if u > (<$target>::max_value() as usize) {\n+                    Err(())\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_unbounded!(u16, u32, u64, u128);\n+    try_from_unbounded!(i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_upper_bounded!(u16);\n+    try_from_unbounded!(u32, u64, u128);\n+    try_from_upper_bounded!(i32);\n+    try_from_unbounded!(i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_upper_bounded!(u16, u32);\n+    try_from_unbounded!(u64, u128);\n+    try_from_upper_bounded!(i32, i64);\n+    try_from_unbounded!(i128);\n+}"}, {"sha": "ee041e1e4f1d9e82d5573a15d0d99a9181496ff6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 30, "deletions": 69, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -3647,7 +3647,7 @@ macro_rules! from_str_radix_int_impl {\n from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n \n /// The error type returned when a checked integral type conversion fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Debug, Copy, Clone)]\n pub struct TryFromIntError(());\n \n@@ -3662,39 +3662,24 @@ impl TryFromIntError {\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl fmt::Display for TryFromIntError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         self.__description().fmt(fmt)\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl From<!> for TryFromIntError {\n     fn from(never: !) -> TryFromIntError {\n         never\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = !;\n-\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n // only negative bounds\n macro_rules! try_from_lower_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3713,7 +3698,7 @@ macro_rules! try_from_lower_bounded {\n // unsigned to signed (only positive bound)\n macro_rules! try_from_upper_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3732,7 +3717,7 @@ macro_rules! try_from_upper_bounded {\n // all other cases\n macro_rules! try_from_both_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3789,82 +3774,44 @@ try_from_both_bounded!(i128, u64, u32, u16, u8);\n try_from_upper_bounded!(usize, isize);\n try_from_lower_bounded!(isize, usize);\n \n+try_from_upper_bounded!(usize, u8);\n+try_from_upper_bounded!(usize, i8, i16);\n+try_from_both_bounded!(isize, u8);\n+try_from_both_bounded!(isize, i8);\n+\n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n     use convert::TryFrom;\n \n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8);\n+    // Fallible across platfoms, only implementation differs\n     try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16);\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16);\n     rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u8);\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i16);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n     use convert::TryFrom;\n \n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16);\n+    // Fallible across platfoms, only implementation differs\n+    try_from_both_bounded!(isize, u16);\n     try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32);\n     rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u8, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i16, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"64\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n     use convert::TryFrom;\n \n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16, u32);\n+    // Fallible across platfoms, only implementation differs\n+    try_from_both_bounded!(isize, u16, u32);\n     try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n     rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u8, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i16, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n }\n \n #[doc(hidden)]\n@@ -4074,6 +4021,20 @@ impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")]\n impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n \n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n+\n // Note: integers can only be represented with full precision in a float if\n // they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n // Lossy float conversions are not implemented at this time."}, {"sha": "2c8e27abac9c0e3afeb2274b27612c6568f8bfda", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -39,6 +39,9 @@ pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use convert::{AsRef, AsMut, Into, From};\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+#[doc(no_inline)]\n+pub use convert::{TryFrom, TryInto};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use default::Default;"}, {"sha": "1a68f04532d204a91a920d5d07b928936d051b65", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -43,7 +43,6 @@\n #![feature(step_trait)]\n #![feature(test)]\n #![feature(trusted_len)]\n-#![feature(try_from)]\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n #![feature(atomic_nand)]"}, {"sha": "c7edb55b378c36ce1208c32a96ef6b448f15c778", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -37,15 +37,6 @@ mod flt2dec;\n mod dec2flt;\n mod bignum;\n \n-\n-/// Adds the attribute to all items in the block.\n-macro_rules! cfg_block {\n-    ($(#[$attr:meta]{$($it:item)*})*) => {$($(\n-        #[$attr]\n-        $it\n-    )*)*}\n-}\n-\n /// Groups items that assume the pointer width is either 16/32/64, and has to be altered if\n /// support for larger/smaller pointer widths are added in the future.\n macro_rules! assume_usize_width {\n@@ -318,42 +309,6 @@ assume_usize_width! {\n \n     test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n     test_impl_try_from_always_ok! { test_try_i16isize, i16, isize }\n-\n-    test_impl_try_from_always_ok! { test_try_usizeu64, usize, u64 }\n-    test_impl_try_from_always_ok! { test_try_usizeu128, usize, u128 }\n-    test_impl_try_from_always_ok! { test_try_usizei128, usize, i128 }\n-\n-    test_impl_try_from_always_ok! { test_try_isizei64, isize, i64 }\n-    test_impl_try_from_always_ok! { test_try_isizei128, isize, i128 }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_always_ok! { test_try_usizeu16, usize, u16 }\n-            test_impl_try_from_always_ok! { test_try_isizei16, isize, i16 }\n-            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n-            test_impl_try_from_always_ok! { test_try_usizei32, usize, i32 }\n-            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n-            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n-            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n-            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_always_ok! { test_try_u32isize, u32, isize }\n-            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_always_ok! { test_try_u64usize, u64, usize }\n-            test_impl_try_from_always_ok! { test_try_i64isize, i64, isize }\n-        }\n-    );\n }\n \n /// Conversions where max of $source can be represented as $target,\n@@ -402,24 +357,6 @@ assume_usize_width! {\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu64, isize, u64 }\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu128, isize, u128 }\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeusize, isize, usize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu16, isize, u16 }\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n-\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64usize, i64, usize }\n-        }\n-    );\n }\n \n /// Conversions where max of $source can not be represented as $target,\n@@ -461,29 +398,9 @@ test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i64, u128, i64 }\n test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i128, u128, i128 }\n \n assume_usize_width! {\n-    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64isize, u64, isize }\n-    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128isize, u128, isize }\n-\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei8, usize, i8 }\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei16, usize, i16 }\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizeisize, usize, isize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei64, usize, i64 }\n-        }\n-    );\n }\n \n /// Conversions where min/max of $source can not be represented as $target.\n@@ -543,34 +460,6 @@ test_impl_try_from_same_sign_err! { test_try_i128i64, i128, i64 }\n \n assume_usize_width! {\n     test_impl_try_from_same_sign_err! { test_try_usizeu8, usize, u8 }\n-    test_impl_try_from_same_sign_err! { test_try_u128usize, u128, usize }\n-    test_impl_try_from_same_sign_err! { test_try_i128isize, i128, isize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_same_sign_err! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n-\n-            test_impl_try_from_same_sign_err! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n-            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n-\n-            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n-            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n-            test_impl_try_from_same_sign_err! { test_try_usizeu32, usize, u32 }\n-\n-            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n-            test_impl_try_from_same_sign_err! { test_try_isizei32, isize, i32 }\n-        }\n-    );\n }\n \n /// Conversions where neither the min nor the max of $source can be represented by\n@@ -615,22 +504,6 @@ test_impl_try_from_signed_to_unsigned_err! { test_try_i128u64, i128, u64 }\n assume_usize_width! {\n     test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu8, isize, u8 }\n     test_impl_try_from_signed_to_unsigned_err! { test_try_i128usize, i128, usize }\n-\n-    cfg_block! {\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i32usize, i32, usize }\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n-        }\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n-\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n-        }\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu32, isize, u32 }\n-        }\n-    }\n }\n \n macro_rules! test_float {"}, {"sha": "4bc64acc7630690ddae18eda0394d5bfbe7bd3d0", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -11,7 +11,7 @@\n use infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use traits::FulfillmentContext;\n+use traits::{FulfillmentContext, TraitEngine};\n use ty::{self, Ty, TypeFoldable};\n use ty::outlives::Component;\n use ty::wf;"}, {"sha": "8eee6f35ab9565680c6de5376fe7584d1fc7a607", "filename": "src/librustc/traits/engine.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use ty::{self, Ty, TyCtxt};\n+use hir::def_id::DefId;\n+\n+use super::{FulfillmentContext, FulfillmentError};\n+use super::{ObligationCause, PendingPredicateObligation, PredicateObligation};\n+\n+pub trait TraitEngine<'tcx>: 'tcx {\n+    fn normalize_projection_type<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx>;\n+\n+    fn register_bound<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        cause: ObligationCause<'tcx>,\n+    );\n+\n+    fn register_predicate_obligation<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    );\n+\n+    fn select_all_or_error<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn select_where_possible<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>>;\n+}\n+\n+impl<'a, 'gcx, 'tcx> dyn TraitEngine<'tcx> {\n+    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+        Box::new(FulfillmentContext::new())\n+    }\n+\n+    pub fn register_predicate_obligations<I>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        obligations: I,\n+    ) where\n+        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+}"}, {"sha": "1c091d68a2ef1474271ff7cb64f858a560c05b67", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -21,6 +21,7 @@ use middle::const_val::{ConstEvalErr, ErrKind};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n+use super::engine::TraitEngine;\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n@@ -85,19 +86,72 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n+    pub fn register_predicate_obligations<I>(&mut self,\n+                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             obligations: I)\n+        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+\n+    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n+    /// only attempts to select obligations that haven't been seen before.\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n+              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n+        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n+\n+        let mut errors = Vec::new();\n+\n+        loop {\n+            debug!(\"select: starting another iteration\");\n+\n+            // Process pending obligations.\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                selcx,\n+                register_region_obligations: self.register_region_obligations\n+            });\n+            debug!(\"select: outcome={:?}\", outcome);\n+\n+            // FIXME: if we kept the original cache key, we could mark projection\n+            // obligations as complete for the projection cache here.\n+\n+            errors.extend(\n+                outcome.errors.into_iter()\n+                              .map(|e| to_fulfillment_error(e)));\n+\n+            // If nothing new was added, no need to keep looping.\n+            if outcome.stalled {\n+                break;\n+            }\n+        }\n+\n+        debug!(\"select({} predicates remaining, {} errors) done\",\n+               self.predicates.len(), errors.len());\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// \"Normalize\" a projection type `<SomeType as SomeTrait>::X` by\n     /// creating a fresh type variable `$0` as well as a projection\n     /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n     /// inference engine runs, it will attempt to find an impl of\n     /// `SomeTrait` or a where clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    pub fn normalize_projection_type(&mut self,\n-                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                     param_env: ty::ParamEnv<'tcx>,\n-                                     projection_ty: ty::ProjectionTy<'tcx>,\n-                                     cause: ObligationCause<'tcx>)\n-                                     -> Ty<'tcx>\n+    fn normalize_projection_type<'a, 'gcx>(&mut self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 projection_ty: ty::ProjectionTy<'tcx>,\n+                                 cause: ObligationCause<'tcx>)\n+                                 -> Ty<'tcx>\n     {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n@@ -125,12 +179,12 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Requires that `ty` must implement the trait with `def_id` in\n     /// the given environment. This trait must not have any type\n     /// parameters (except for `Self`).\n-    pub fn register_bound(&mut self,\n-                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>,\n-                          def_id: DefId,\n-                          cause: ObligationCause<'tcx>)\n+    fn register_bound<'a, 'gcx>(&mut self,\n+                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      ty: Ty<'tcx>,\n+                      def_id: DefId,\n+                      cause: ObligationCause<'tcx>)\n     {\n         let trait_ref = ty::TraitRef {\n             def_id,\n@@ -144,9 +198,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligation(&mut self,\n-                                         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                         obligation: PredicateObligation<'tcx>)\n+    fn register_predicate_obligation<'a, 'gcx>(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                     obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n@@ -162,19 +216,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligations<I>(&mut self,\n-                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             obligations: I)\n-        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n-    {\n-        for obligation in obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-    }\n-\n-    pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                               -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_all_or_error<'a, 'gcx>(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n \n@@ -190,58 +234,17 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                                 -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_where_possible<'a, 'gcx>(&mut self,\n+                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                             -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n     }\n \n-    pub fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n         self.predicates.pending_obligations()\n     }\n-\n-    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n-    /// only attempts to select obligations that haven't been seen before.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n-              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n-        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n-\n-        let mut errors = Vec::new();\n-\n-        loop {\n-            debug!(\"select: starting another iteration\");\n-\n-            // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                selcx,\n-                register_region_obligations: self.register_region_obligations\n-            });\n-            debug!(\"select: outcome={:?}\", outcome);\n-\n-            // FIXME: if we kept the original cache key, we could mark projection\n-            // obligations as complete for the projection cache here.\n-\n-            errors.extend(\n-                outcome.errors.into_iter()\n-                              .map(|e| to_fulfillment_error(e)));\n-\n-            // If nothing new was added, no need to keep looping.\n-            if outcome.stalled {\n-                break;\n-            }\n-        }\n-\n-        debug!(\"select({} predicates remaining, {} errors) done\",\n-               self.predicates.len(), errors.len());\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(errors)\n-        }\n-    }\n }\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {"}, {"sha": "1d5d3e41c9c9a4e628a3ce5b8ecf7b71dd94ba4a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -34,7 +34,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n-pub use self::fulfill::FulfillmentContext;\n+pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal, Normalized};\n@@ -45,6 +45,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::IntercrateAmbiguityCause;\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n+pub use self::engine::TraitEngine;\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -54,6 +55,7 @@ pub use self::util::transitive_bounds;\n \n mod coherence;\n pub mod error_reporting;\n+mod engine;\n mod fulfill;\n mod project;\n mod object_safety;"}, {"sha": "a9d1c8bcc3d995865bb03b7eab182060fa2112ac", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -26,7 +26,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use ty::subst::{Subst, Substs};\n-use traits::{self, ObligationCause};\n+use traits::{self, ObligationCause, TraitEngine};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;"}, {"sha": "31e851126d76ad495b8abf0d2513357d890c6ef4", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -18,7 +18,8 @@ use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n use infer::InferCtxt;\n use syntax_pos::Span;\n-use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n+use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n+             TraitEngine, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::TypeFoldable;"}, {"sha": "6f08fcf702595eb49957fc70ff8c43516c6925c9", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -48,7 +48,7 @@\n \n #![cfg_attr(stage0, feature(slice_patterns))]\n #![cfg_attr(stage0, feature(i128_type))]\n-#![feature(try_from)]\n+#![cfg_attr(stage0, feature(try_from))]\n \n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]"}, {"sha": "544cb5eefc8868a86ba3a2adf9e33d56d7647e7e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -20,7 +20,7 @@ use dataflow::move_paths::MoveData;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n-use rustc::traits::{self, Normalized, FulfillmentContext};\n+use rustc::traits::{self, Normalized, TraitEngine};\n use rustc::traits::query::NoSolution;\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     where\n         OP: FnOnce(&mut Self) -> InferResult<'tcx, R>,\n     {\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new(self.infcx.tcx);\n         let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op(self))?;\n         fulfill_cx.register_predicate_obligations(self.infcx, obligations);\n         if let Err(e) = fulfill_cx.select_all_or_error(self.infcx) {"}, {"sha": "aeefd5ab1d5aca903db44e5e8b20d7d2e4e3744b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n-use rustc::traits;\n+use rustc::traits::{self, TraitEngine};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;"}, {"sha": "bff070ab73de342f06fab3ac80c225277594057e", "filename": "src/librustc_traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -12,7 +12,7 @@ use rustc::infer::InferCtxt;\n use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryRegionConstraints,\n                               QueryResult};\n use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc::traits::FulfillmentContext;\n+use rustc::traits::{FulfillmentContext, TraitEngine};\n use rustc::traits::query::NoSolution;\n use rustc::ty;\n use std::fmt::Debug;"}, {"sha": "d508b6df924c23895c011c26714fc09911afa32f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ObligationCause};\n+use rustc::traits::{ObligationCause, TraitEngine};\n use util::common::ErrorReported;\n \n use syntax::ast;\n@@ -84,7 +84,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let impl_param_env = tcx.param_env(self_type_did);\n         let tcx = infcx.tcx;\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let mut fulfillment_cx = TraitEngine::new(tcx);\n \n         let named_type = tcx.type_of(self_type_did);\n "}, {"sha": "0f0f59c28f8259c7d4fd874959cc3720d277fc9b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -95,7 +95,7 @@ use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n@@ -195,7 +195,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n-    fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+    fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n@@ -634,7 +634,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n                 maybe_tables: infcx.in_progress_tables,\n             },\n             infcx,\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            fulfillment_cx: RefCell::new(TraitEngine::new(tcx)),\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n@@ -2910,7 +2910,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n+                let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n \n                 // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n                 // to identity so the resulting type is not constrained.\n@@ -2921,7 +2921,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // out unconstrained or ambiguous, as we're\n                         // just trying to get hints here.\n                         self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = FulfillmentContext::new();\n+                            let mut fulfill = TraitEngine::new(self.tcx);\n                             for obligation in ok.obligations {\n                                 fulfill.register_predicate_obligation(self, obligation);\n                             }"}, {"sha": "aa4322783c606741805d835572e949208cc3cb79", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -15,7 +15,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n-use rustc::traits::{self, ObligationCause};\n+use rustc::traits::{self, TraitEngine, ObligationCause};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::TypeFoldable;\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n@@ -172,34 +172,34 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = match tcx.lang_items().require(UnsizeTraitLangItem) {\n+    let unsize_trait = match gcx.lang_items().require(UnsizeTraitLangItem) {\n         Ok(id) => id,\n         Err(err) => {\n-            tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+            gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n         }\n     };\n \n     // this provider should only get invoked for local def-ids\n-    let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n+    let impl_node_id = gcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n-    let source = tcx.type_of(impl_did);\n-    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let source = gcx.type_of(impl_did);\n+    let trait_ref = gcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n            target);\n \n-    let span = tcx.hir.span(impl_node_id);\n-    let param_env = tcx.param_env(impl_did);\n+    let span = gcx.hir.span(impl_node_id);\n+    let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_regions());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n@@ -208,11 +208,11 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n+    gcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n-        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n-                           mt_b: ty::TypeAndMut<'tcx>,\n-                           mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+        let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n+                           mt_b: ty::TypeAndMut<'gcx>,\n+                           mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n             if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n                 infcx.report_mismatched_types(&cause,\n                                              mk_ptr(mt_b.ty),\n@@ -225,20 +225,20 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n             (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n             }\n \n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n             (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                           def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = tcx.item_path_str(def_a.did);\n-                    let target_path = tcx.item_path_str(def_b.did);\n-                    span_err!(tcx.sess,\n+                    let source_path = gcx.item_path_str(def_a.did);\n+                    let target_path = gcx.item_path_str(def_b.did);\n+                    span_err!(gcx.sess,\n                               span,\n                               E0377,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n@@ -292,9 +292,9 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let diff_fields = fields.iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+                        let (a, b) = (f.ty(gcx, substs_a), f.ty(gcx, substs_b));\n \n-                        if tcx.type_of(f.did).is_phantom_data() {\n+                        if gcx.type_of(f.did).is_phantom_data() {\n                             // Ignore PhantomData fields\n                             return None;\n                         }\n@@ -321,22 +321,22 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     .collect::<Vec<_>>();\n \n                 if diff_fields.is_empty() {\n-                    span_err!(tcx.sess,\n+                    span_err!(gcx.sess,\n                               span,\n                               E0374,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = tcx.hir.expect_item(impl_node_id);\n+                    let item = gcx.hir.expect_item(impl_node_id);\n                     let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        tcx.hir.span(impl_node_id)\n+                        gcx.hir.span(impl_node_id)\n                     };\n \n-                    let mut err = struct_span_err!(tcx.sess,\n+                    let mut err = struct_span_err!(gcx.sess,\n                                                    span,\n                                                    E0375,\n                                                    \"implementing the trait \\\n@@ -363,7 +363,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             _ => {\n-                span_err!(tcx.sess,\n+                span_err!(gcx.sess,\n                           span,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n@@ -372,11 +372,11 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_node_id);\n-        let predicate = tcx.predicate_for_trait_def(param_env,\n+        let predicate = gcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,\n                                                     0,"}, {"sha": "86c5e49d1674bc9603416532e5e0b60947f34520", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -88,6 +88,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_patterns)]\n #![cfg_attr(stage0, feature(i128_type))]\n #![cfg_attr(stage0, feature(never_type))]\n+#![feature(dyn_trait)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -111,7 +112,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine};\n use session::{CompileIncomplete, config};\n use util::common::time;\n \n@@ -160,7 +161,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n         match infcx.at(&cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfill_cx.register_predicate_obligations(infcx, obligations);"}, {"sha": "3d0c96585b55209b95c2d38dfd0591643cbd3ca0", "filename": "src/libstd/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -275,14 +275,14 @@ impl Error for num::ParseIntError {\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl Error for num::TryFromIntError {\n     fn description(&self) -> &str {\n         self.__description()\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl Error for array::TryFromSliceError {\n     fn description(&self) -> &str {\n         self.__description()\n@@ -356,7 +356,7 @@ impl Error for cell::BorrowMutError {\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl Error for char::CharTryFromError {\n     fn description(&self) -> &str {\n         \"converted integer out of range for `char`\""}, {"sha": "2673f3ccfa3abd9cff77660e554a8938b5330a0d", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -10,7 +10,6 @@\n \n use io::prelude::*;\n \n-use core::convert::TryInto;\n use cmp;\n use io::{self, Initializer, SeekFrom, Error, ErrorKind};\n \n@@ -260,9 +259,26 @@ fn slice_write(pos_mut: &mut u64, slice: &mut [u8], buf: &[u8]) -> io::Result<us\n     Ok(amt)\n }\n \n+/// Compensate removal of some impls per\n+/// https://github.com/rust-lang/rust/pull/49305#issuecomment-376293243\n+#[cfg(any(target_pointer_width = \"16\",\n+          target_pointer_width = \"32\"))]\n+fn try_into(n: u64) -> Result<usize, ()> {\n+    if n <= (<usize>::max_value() as u64) {\n+        Ok(n as usize)\n+    } else {\n+        Err(())\n+    }\n+}\n+\n+#[cfg(any(target_pointer_width = \"64\"))]\n+fn try_into(n: u64) -> Result<usize, ()> {\n+    Ok(n as usize)\n+}\n+\n // Resizing write implementation\n fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n-    let pos: usize = (*pos_mut).try_into().map_err(|_| {\n+    let pos: usize = try_into(*pos_mut).map_err(|_| {\n         Error::new(ErrorKind::InvalidInput,\n                     \"cursor position exceeds maximum possible vector length\")\n     })?;"}, {"sha": "15a22443b6af76ae90ceb006677d650ef3301f9e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -310,7 +310,6 @@\n #![feature(test, rustc_private)]\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n-#![feature(try_from)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "d5b7c68a3fa86b64a839cd6b83e34ec0d785a2b7", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -35,6 +35,8 @@\n #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use convert::{AsRef, AsMut, Into, From};\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+#[doc(no_inline)] pub use convert::{TryFrom, TryInto};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use default::Default;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "33e47ade8cb9cd30a7ac25d2c6a4cbc5a977cc81", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -42,7 +42,7 @@ pub use core::char::{EscapeDebug, EscapeDefault, EscapeUnicode};\n pub use core::char::ParseCharError;\n \n // unstable re-exports\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub use core::char::CharTryFromError;\n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n pub use core::char::{DecodeUtf8, decode_utf8};"}, {"sha": "c22ea1671fa590131310a79241383043169d31d0", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -39,7 +39,6 @@\n #![feature(lang_items)]\n #![feature(non_exhaustive)]\n #![feature(staged_api)]\n-#![feature(try_from)]\n #![feature(unboxed_closures)]\n \n mod bool_trie;"}, {"sha": "a9f747d09ec2dd7b4cb15ae8a184ccda312b383d", "filename": "src/test/ui/e0119/conflict-with-std.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Ftest%2Fui%2Fe0119%2Fconflict-with-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Ftest%2Fui%2Fe0119%2Fconflict-with-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fe0119%2Fconflict-with-std.rs?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(try_from)]\n-\n use std::marker::PhantomData;\n use std::convert::{TryFrom, AsRef};\n "}, {"sha": "417ff1de3f8173ff958459981f405225f673dafa", "filename": "src/test/ui/e0119/conflict-with-std.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Ftest%2Fui%2Fe0119%2Fconflict-with-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/605ea7c31f7341995c2d1ae12b4b33fe6bd908b5/src%2Ftest%2Fui%2Fe0119%2Fconflict-with-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fe0119%2Fconflict-with-std.stderr?ref=605ea7c31f7341995c2d1ae12b4b33fe6bd908b5", "patch": "@@ -1,5 +1,5 @@\n error[E0119]: conflicting implementations of trait `std::convert::AsRef<Q>` for type `std::boxed::Box<Q>`:\n-  --> $DIR/conflict-with-std.rs:17:1\n+  --> $DIR/conflict-with-std.rs:15:1\n    |\n LL | impl AsRef<Q> for Box<Q> { //~ ERROR conflicting implementations\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -9,7 +9,7 @@ LL | impl AsRef<Q> for Box<Q> { //~ ERROR conflicting implementations\n              where T: ?Sized;\n \n error[E0119]: conflicting implementations of trait `std::convert::From<S>` for type `S`:\n-  --> $DIR/conflict-with-std.rs:24:1\n+  --> $DIR/conflict-with-std.rs:22:1\n    |\n LL | impl From<S> for S { //~ ERROR conflicting implementations\n    | ^^^^^^^^^^^^^^^^^^\n@@ -18,7 +18,7 @@ LL | impl From<S> for S { //~ ERROR conflicting implementations\n            - impl<T> std::convert::From<T> for T;\n \n error[E0119]: conflicting implementations of trait `std::convert::TryFrom<X>` for type `X`:\n-  --> $DIR/conflict-with-std.rs:31:1\n+  --> $DIR/conflict-with-std.rs:29:1\n    |\n LL | impl TryFrom<X> for X { //~ ERROR conflicting implementations\n    | ^^^^^^^^^^^^^^^^^^^^^"}]}