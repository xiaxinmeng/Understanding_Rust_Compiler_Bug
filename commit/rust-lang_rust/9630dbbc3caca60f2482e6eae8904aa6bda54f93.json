{"sha": "9630dbbc3caca60f2482e6eae8904aa6bda54f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MzBkYmJjM2NhY2E2MGYyNDgyZTZlYWU4OTA0YWE2YmRhNTRmOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-06T15:11:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-06T15:11:35Z"}, "message": "Auto merge of #67091 - JohnTitor:rollup-kitphze, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #66846 (Make try_mark_previous_green aware of cycles.)\n - #66959 (Remove potential cfgs duplicates)\n - #66988 (Fix angle bracket formatting when dumping MIR debug vars)\n - #66998 (Modified the testcases for VxWorks)\n - #67008 (rustdoc: Add test for fixed issue)\n - #67023 (SGX: Fix target linker used by bootstrap)\n - #67033 (Migrate to LLVM{Get,Set}ValueName2)\n - #67049 (Simplify {IoSlice, IoSliceMut}::advance examples and tests)\n - #67054 (codegen \"unreachable\" for invalid SetDiscriminant)\n - #67081 (Fix Query type docs)\n - #67085 (Remove boxed closures in address parser.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5deec471683d621f91208385425acc4a6b04713c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5deec471683d621f91208385425acc4a6b04713c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9630dbbc3caca60f2482e6eae8904aa6bda54f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9630dbbc3caca60f2482e6eae8904aa6bda54f93", "html_url": "https://github.com/rust-lang/rust/commit/9630dbbc3caca60f2482e6eae8904aa6bda54f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9630dbbc3caca60f2482e6eae8904aa6bda54f93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0126e8ed3cc0d6fcb9dd44c36a46f9ce65010a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0126e8ed3cc0d6fcb9dd44c36a46f9ce65010a0", "html_url": "https://github.com/rust-lang/rust/commit/d0126e8ed3cc0d6fcb9dd44c36a46f9ce65010a0"}, {"sha": "931be6c3bccc38be9052433c321f11da033c57c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/931be6c3bccc38be9052433c321f11da033c57c5", "html_url": "https://github.com/rust-lang/rust/commit/931be6c3bccc38be9052433c321f11da033c57c5"}], "stats": {"total": 315, "additions": 214, "deletions": 101}, "files": [{"sha": "7ea2bb126a641ca8fa9ceb38b327ccdd3327bcbb", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -810,6 +810,7 @@ impl Build {\n                   !target.contains(\"emscripten\") &&\n                   !target.contains(\"wasm32\") &&\n                   !target.contains(\"nvptx\") &&\n+                  !target.contains(\"fortanix\") &&\n                   !target.contains(\"fuchsia\") {\n             Some(self.cc(target))\n         } else {"}, {"sha": "d952bf7ab9e2541ee18f8d4c62e4c8a3ea14a494", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -710,14 +710,25 @@ impl DepGraph {\n                                 return None\n                             }\n                             None => {\n-                                if !tcx.sess.has_errors() {\n+                                if !tcx.sess.has_errors_or_delayed_span_bugs() {\n                                     bug!(\"try_mark_previous_green() - Forcing the DepNode \\\n                                           should have set its color\")\n                                 } else {\n-                                    // If the query we just forced has resulted\n-                                    // in some kind of compilation error, we\n-                                    // don't expect that the corresponding\n-                                    // dep-node color has been updated.\n+                                    // If the query we just forced has resulted in\n+                                    // some kind of compilation error, we cannot rely on\n+                                    // the dep-node color having been properly updated.\n+                                    // This means that the query system has reached an\n+                                    // invalid state. We let the compiler continue (by\n+                                    // returning `None`) so it can emit error messages\n+                                    // and wind down, but rely on the fact that this\n+                                    // invalid state will not be persisted to the\n+                                    // incremental compilation cache because of\n+                                    // compilation errors being present.\n+                                    debug!(\"try_mark_previous_green({:?}) - END - \\\n+                                            dependency {:?} resulted in compilation error\",\n+                                           dep_node,\n+                                           dep_dep_node);\n+                                    return None\n                                 }\n                             }\n                         }"}, {"sha": "ada29c350ad04b7ac2254d1a2dc604fe2c01bae1", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -22,7 +22,7 @@ use rustc_fs_util::{path_to_c_string, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;\n use errors::{Handler, FatalError};\n \n-use std::ffi::{CString, CStr};\n+use std::ffi::CString;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n@@ -833,16 +833,16 @@ fn create_msvc_imps(\n             })\n             .filter_map(|val| {\n                 // Exclude some symbols that we know are not Rust symbols.\n-                let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                if ignored(name.to_bytes()) {\n+                let name = llvm::get_value_name(val);\n+                if ignored(name) {\n                     None\n                 } else {\n                     Some((val, name))\n                 }\n             })\n             .map(move |(val, name)| {\n                 let mut imp_name = prefix.as_bytes().to_vec();\n-                imp_name.extend(name.to_bytes());\n+                imp_name.extend(name);\n                 let imp_name = CString::new(imp_name).unwrap();\n                 (imp_name, val)\n             })"}, {"sha": "297aff93a9d28d2a67fb2febfe7e50a3cb3ad425", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::layout::{self, Size, Align, LayoutOf};\n \n use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n-use std::ffi::{CStr, CString};\n+use std::ffi::CStr;\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n@@ -392,16 +392,14 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n             } else {\n                 // If we created the global with the wrong type,\n                 // correct the type.\n-                let empty_string = const_cstr!(\"\");\n-                let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n-                let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n-                llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+                let name = llvm::get_value_name(g).to_vec();\n+                llvm::set_value_name(g, b\"\");\n \n                 let linkage = llvm::LLVMRustGetLinkage(g);\n                 let visibility = llvm::LLVMRustGetVisibility(g);\n \n                 let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                    self.llmod, name_string.as_ptr(), val_llty);\n+                    self.llmod, name.as_ptr().cast(), name.len(), val_llty);\n \n                 llvm::LLVMRustSetLinkage(new_g, linkage);\n                 llvm::LLVMRustSetVisibility(new_g, visibility);"}, {"sha": "a3782ecd92dcd0c4635244dddf6c0916240d40ab", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -32,7 +32,7 @@ use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, DebugScope,\n \n use libc::c_uint;\n use std::cell::RefCell;\n-use std::ffi::{CStr, CString};\n+use std::ffi::CString;\n \n use smallvec::SmallVec;\n use syntax_pos::{self, BytePos, Span, Pos};\n@@ -255,23 +255,11 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             return;\n         }\n \n-        let old_name = unsafe {\n-            CStr::from_ptr(llvm::LLVMGetValueName(value))\n-        };\n-        match old_name.to_str() {\n-            Ok(\"\") => {}\n-            Ok(_) => {\n-                // Avoid replacing the name if it already exists.\n-                // While we could combine the names somehow, it'd\n-                // get noisy quick, and the usefulness is dubious.\n-                return;\n-            }\n-            Err(_) => return,\n-        }\n-\n-        let cname = SmallCStr::new(name);\n-        unsafe {\n-            llvm::LLVMSetValueName(value, cname.as_ptr());\n+        // Avoid replacing the name if it already exists.\n+        // While we could combine the names somehow, it'd\n+        // get noisy quick, and the usefulness is dubious.\n+        if llvm::get_value_name(value).is_empty() {\n+            llvm::set_value_name(value, name.as_bytes());\n         }\n     }\n }"}, {"sha": "fa9fc4653680166e229627366107a9f47b8f16bb", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -76,9 +76,8 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         name: &str, ty: &'ll Type\n     ) -> &'ll Value {\n         debug!(\"declare_global(name={:?})\", name);\n-        let namebuf = SmallCStr::new(name);\n         unsafe {\n-            llvm::LLVMRustGetOrInsertGlobal(self.llmod, namebuf.as_ptr(), ty)\n+            llvm::LLVMRustGetOrInsertGlobal(self.llmod, name.as_ptr().cast(), name.len(), ty)\n         }\n     }\n "}, {"sha": "5da3275e28e8b3fc8fdb593a623cca46b3bb0065", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -701,8 +701,8 @@ extern \"C\" {\n \n     // Operations on all values\n     pub fn LLVMTypeOf(Val: &Value) -> &Type;\n-    pub fn LLVMGetValueName(Val: &Value) -> *const c_char;\n-    pub fn LLVMSetValueName(Val: &Value, Name: *const c_char);\n+    pub fn LLVMGetValueName2(Val: &Value, Length: *mut size_t) -> *const c_char;\n+    pub fn LLVMSetValueName2(Val: &Value, Name: *const c_char, NameLen: size_t);\n     pub fn LLVMReplaceAllUsesWith(OldVal: &'a Value, NewVal: &'a Value);\n     pub fn LLVMSetMetadata(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n \n@@ -774,7 +774,8 @@ extern \"C\" {\n     pub fn LLVMIsAGlobalVariable(GlobalVar: &Value) -> Option<&Value>;\n     pub fn LLVMAddGlobal(M: &'a Module, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n     pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> Option<&Value>;\n-    pub fn LLVMRustGetOrInsertGlobal(M: &'a Module, Name: *const c_char, T: &'a Type) -> &'a Value;\n+    pub fn LLVMRustGetOrInsertGlobal(M: &'a Module, Name: *const c_char, NameLen: size_t,\n+                                     T: &'a Type) -> &'a Value;\n     pub fn LLVMRustInsertPrivateGlobal(M: &'a Module, T: &'a Type) -> &'a Value;\n     pub fn LLVMGetFirstGlobal(M: &Module) -> Option<&Value>;\n     pub fn LLVMGetNextGlobal(GlobalVar: &Value) -> Option<&Value>;\n@@ -1811,7 +1812,7 @@ extern \"C\" {\n \n     pub fn LLVMRustPositionBuilderAtStart(B: &Builder<'a>, BB: &'a BasicBlock);\n \n-    pub fn LLVMRustSetComdat(M: &'a Module, V: &'a Value, Name: *const c_char);\n+    pub fn LLVMRustSetComdat(M: &'a Module, V: &'a Value, Name: *const c_char, NameLen: size_t);\n     pub fn LLVMRustUnsetComdat(V: &Value);\n     pub fn LLVMRustSetModulePICLevel(M: &Module);\n     pub fn LLVMRustSetModulePIELevel(M: &Module);"}, {"sha": "d2d418762398101dccafe400353c85fc0e7cbaf9", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -115,7 +115,8 @@ pub fn SetFunctionCallConv(fn_: &'a Value, cc: CallConv) {\n // For more details on COMDAT sections see e.g., http://www.airs.com/blog/archives/52\n pub fn SetUniqueComdat(llmod: &Module, val: &'a Value) {\n     unsafe {\n-        LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));\n+        let name = get_value_name(val);\n+        LLVMRustSetComdat(llmod, val, name.as_ptr().cast(), name.len());\n     }\n }\n \n@@ -217,6 +218,23 @@ pub fn get_param(llfn: &'a Value, index: c_uint) -> &'a Value {\n     }\n }\n \n+/// Safe wrapper for `LLVMGetValueName2` into a byte slice\n+pub fn get_value_name(value: &'a Value) -> &'a [u8] {\n+    unsafe {\n+        let mut len = 0;\n+        let data = LLVMGetValueName2(value, &mut len);\n+        std::slice::from_raw_parts(data.cast(), len)\n+    }\n+}\n+\n+/// Safe wrapper for `LLVMSetValueName2` from a byte slice\n+pub fn set_value_name(value: &Value, name: &[u8]) {\n+    unsafe {\n+        let data = name.as_ptr().cast();\n+        LLVMSetValueName2(value, data, name.len());\n+    }\n+}\n+\n pub fn build_string(f: impl FnOnce(&RustString)) -> Result<String, FromUtf8Error> {\n     let sr = RustString {\n         bytes: RefCell::new(Vec::new()),"}, {"sha": "ce703f2433506e6dbceaa2230d5e73e5cbc4b7ed", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -261,7 +261,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if self.fn_abi.ret.layout.abi.is_uninhabited() {\n             // Functions with uninhabited return values are marked `noreturn`,\n             // so we should make sure that we never actually do.\n+            // We play it safe by using a well-defined `abort`, but we could go for immediate UB\n+            // if that turns out to be helpful.\n             bx.abort();\n+            // `abort` does not terminate the block, so we still need to generate\n+            // an `unreachable` terminator after it.\n             bx.unreachable();\n             return;\n         }\n@@ -825,6 +829,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::TerminatorKind::Abort => {\n                 bx.abort();\n+                // `abort` does not terminate the block, so we still need to generate\n+                // an `unreachable` terminator after it.\n                 bx.unreachable();\n             }\n "}, {"sha": "a6dec81274915057d93c22c36195494c63899095", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -475,9 +475,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             },\n                         }\n                         // Allow RalfJ to sleep soundly knowing that even refactorings that remove\n-                        // the above error (or silence it under some conditions) will not cause UB\n+                        // the above error (or silence it under some conditions) will not cause UB.\n                         bx.abort();\n-                        // We've errored, so we don't have to produce working code.\n+                        // We still have to return an operand but it doesn't matter,\n+                        // this code is unreachable.\n                         let ty = self.monomorphize(&constant.literal.ty);\n                         let layout = bx.cx().layout_of(ty);\n                         bx.load_operand(PlaceRef::new_sized("}, {"sha": "e60b8861faf85ebc31d69dafbe94c031ddc813fe", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -333,6 +333,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         variant_index: VariantIdx\n     ) {\n         if self.layout.for_variant(bx.cx(), variant_index).abi.is_uninhabited() {\n+            // We play it safe by using a well-defined `abort`, but we could go for immediate UB\n+            // if that turns out to be helpful.\n+            bx.abort();\n             return;\n         }\n         match self.layout.variants {\n@@ -488,10 +491,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     },\n                     Err(_) => {\n                         // This is unreachable as long as runtime\n-                        // and compile-time agree on values\n+                        // and compile-time agree perfectly.\n                         // With floats that won't always be true,\n-                        // so we generate an abort.\n+                        // so we generate a (safe) abort.\n                         bx.abort();\n+                        // We still have to return a place but it doesn't matter,\n+                        // this code is unreachable.\n                         let llval = bx.cx().const_undef(\n                             bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n                         );"}, {"sha": "d1fbb949fb164326eb4fc93237e2831d0d221d66", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -22,7 +22,7 @@ use std::mem;\n use syntax::{self, ast};\n \n /// Represent the result of a query.\n-/// This result can be stolen with the `take` method and returned with the `give` method.\n+/// This result can be stolen with the `take` method and generated with the `compute` method.\n pub struct Query<T> {\n     result: RefCell<Option<Result<T>>>,\n }\n@@ -37,7 +37,7 @@ impl<T> Query<T> {\n     }\n \n     /// Takes ownership of the query result. Further attempts to take or peek the query\n-    /// result will panic unless it is returned by calling the `give` method.\n+    /// result will panic unless it is generated by calling the `compute` method.\n     pub fn take(&self) -> T {\n         self.result\n             .borrow_mut()"}, {"sha": "a44d4014b42ee41c31501c6db116b5378b1bfeee", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -202,7 +202,7 @@ fn write_graph_label<'tcx, W: Write>(\n     }\n \n     for var_debug_info in &body.var_debug_info {\n-        write!(w, r#\"debug {} => {};<br align=\"left\"/>\"#,\n+        write!(w, r#\"debug {} =&gt; {};<br align=\"left\"/>\"#,\n                var_debug_info.name, escape(&var_debug_info.place))?;\n     }\n "}, {"sha": "fb2cce3683132d720f53cb3d78ceeae8025d55ed", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -209,6 +209,9 @@ impl ops::Not for Cfg {\n \n impl ops::BitAndAssign for Cfg {\n     fn bitand_assign(&mut self, other: Cfg) {\n+        if *self == other {\n+            return;\n+        }\n         match (self, other) {\n             (&mut Cfg::False, _) | (_, Cfg::True) => {},\n             (s, Cfg::False) => *s = Cfg::False,\n@@ -238,6 +241,9 @@ impl ops::BitAnd for Cfg {\n \n impl ops::BitOrAssign for Cfg {\n     fn bitor_assign(&mut self, other: Cfg) {\n+        if *self == other {\n+            return;\n+        }\n         match (self, other) {\n             (&mut Cfg::True, _) | (_, Cfg::False) => {},\n             (s, Cfg::True) => *s = Cfg::True,"}, {"sha": "a109e38e1e3bc7e21774d9851e28c759f61ff3d8", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -2339,8 +2339,10 @@ mod tests {\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let result = File::open(filename);\n \n-        #[cfg(unix)]\n+        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n         error!(result, \"No such file or directory\");\n+        #[cfg(target_os = \"vxworks\")]\n+        error!(result, \"no such file or directory\");\n         #[cfg(windows)]\n         error!(result, 2); // ERROR_FILE_NOT_FOUND\n     }\n@@ -2352,8 +2354,10 @@ mod tests {\n \n         let result = fs::remove_file(filename);\n \n-        #[cfg(unix)]\n+        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n         error!(result, \"No such file or directory\");\n+        #[cfg(target_os = \"vxworks\")]\n+        error!(result, \"no such file or directory\");\n         #[cfg(windows)]\n         error!(result, 2); // ERROR_FILE_NOT_FOUND\n     }\n@@ -2553,7 +2557,10 @@ mod tests {\n \n         check!(fs::set_permissions(filename, fs::Permissions::from_mode(0o1777)));\n         let metadata1 = check!(fs::metadata(filename));\n+        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n         assert_eq!(mask & metadata1.permissions().mode(), 0o1777);\n+        #[cfg(target_os = \"vxworks\")]\n+        assert_eq!(mask & metadata1.permissions().mode(), 0o0777);\n     }\n \n     #[test]"}, {"sha": "a1a33bade0d7c610632cf0ce839520c520fb289a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -987,7 +987,6 @@ impl<'a> IoSliceMut<'a> {\n     /// #![feature(io_slice_advance)]\n     ///\n     /// use std::io::IoSliceMut;\n-    /// use std::mem;\n     /// use std::ops::Deref;\n     ///\n     /// let mut buf1 = [1; 8];\n@@ -1000,7 +999,7 @@ impl<'a> IoSliceMut<'a> {\n     /// ][..];\n     ///\n     /// // Mark 10 bytes as read.\n-    /// bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 10);\n+    /// bufs = IoSliceMut::advance(bufs, 10);\n     /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n     /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n     /// ```\n@@ -1090,20 +1089,19 @@ impl<'a> IoSlice<'a> {\n     /// #![feature(io_slice_advance)]\n     ///\n     /// use std::io::IoSlice;\n-    /// use std::mem;\n     /// use std::ops::Deref;\n     ///\n-    /// let mut buf1 = [1; 8];\n-    /// let mut buf2 = [2; 16];\n-    /// let mut buf3 = [3; 8];\n+    /// let buf1 = [1; 8];\n+    /// let buf2 = [2; 16];\n+    /// let buf3 = [3; 8];\n     /// let mut bufs = &mut [\n-    ///     IoSlice::new(&mut buf1),\n-    ///     IoSlice::new(&mut buf2),\n-    ///     IoSlice::new(&mut buf3),\n+    ///     IoSlice::new(&buf1),\n+    ///     IoSlice::new(&buf2),\n+    ///     IoSlice::new(&buf3),\n     /// ][..];\n     ///\n     /// // Mark 10 bytes as written.\n-    /// bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 10);\n+    /// bufs = IoSlice::advance(bufs, 10);\n     /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n     /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n     #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n@@ -2415,7 +2413,6 @@ mod tests {\n     use crate::cmp;\n     use crate::io::prelude::*;\n     use crate::io::{self, IoSlice, IoSliceMut};\n-    use crate::mem;\n     use crate::ops::Deref;\n \n     #[test]\n@@ -2731,26 +2728,26 @@ mod tests {\n         ][..];\n \n         // Only in a single buffer..\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 1);\n+        bufs = IoSliceMut::advance(bufs, 1);\n         assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n         assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n \n         // Removing a buffer, leaving others as is.\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 7);\n+        bufs = IoSliceMut::advance(bufs, 7);\n         assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n \n         // Removing a buffer and removing from the next buffer.\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 18);\n+        bufs = IoSliceMut::advance(bufs, 18);\n         assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n     }\n \n     #[test]\n     fn io_slice_mut_advance_empty_slice() {\n-        let mut empty_bufs = &mut [][..];\n+        let empty_bufs = &mut [][..];\n         // Shouldn't panic.\n-        IoSliceMut::advance(&mut empty_bufs, 1);\n+        IoSliceMut::advance(empty_bufs, 1);\n     }\n \n     #[test]\n@@ -2759,48 +2756,48 @@ mod tests {\n         let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n \n         // Going beyond the total length should be ok.\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 9);\n+        bufs = IoSliceMut::advance(bufs, 9);\n         assert!(bufs.is_empty());\n     }\n \n     #[test]\n     fn io_slice_advance() {\n-        let mut buf1 = [1; 8];\n-        let mut buf2 = [2; 16];\n-        let mut buf3 = [3; 8];\n+        let buf1 = [1; 8];\n+        let buf2 = [2; 16];\n+        let buf3 = [3; 8];\n         let mut bufs =\n-            &mut [IoSlice::new(&mut buf1), IoSlice::new(&mut buf2), IoSlice::new(&mut buf3)][..];\n+            &mut [IoSlice::new(&buf1), IoSlice::new(&buf2), IoSlice::new(&buf3)][..];\n \n         // Only in a single buffer..\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 1);\n+        bufs = IoSlice::advance(bufs, 1);\n         assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n         assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n \n         // Removing a buffer, leaving others as is.\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 7);\n+        bufs = IoSlice::advance(bufs, 7);\n         assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n \n         // Removing a buffer and removing from the next buffer.\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 18);\n+        bufs = IoSlice::advance(bufs, 18);\n         assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n     }\n \n     #[test]\n     fn io_slice_advance_empty_slice() {\n-        let mut empty_bufs = &mut [][..];\n+        let empty_bufs = &mut [][..];\n         // Shouldn't panic.\n-        IoSlice::advance(&mut empty_bufs, 1);\n+        IoSlice::advance(empty_bufs, 1);\n     }\n \n     #[test]\n     fn io_slice_advance_beyond_total_length() {\n-        let mut buf1 = [1; 8];\n-        let mut bufs = &mut [IoSlice::new(&mut buf1)][..];\n+        let buf1 = [1; 8];\n+        let mut bufs = &mut [IoSlice::new(&buf1)][..];\n \n         // Going beyond the total length should be ok.\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 9);\n+        bufs = IoSlice::advance(bufs, 9);\n         assert!(bufs.is_empty());\n     }\n }"}, {"sha": "686fa8c61a109410ab5b2c0ac8aa457cc5b46c83", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -44,19 +44,6 @@ impl<'a> Parser<'a> {\n         self.read_atomically(move |p| cb(p).filter(|_| p.is_eof()))\n     }\n \n-    // Return result of first successful parser\n-    fn read_or<T>(\n-        &mut self,\n-        parsers: &mut [Box<dyn FnMut(&mut Parser<'_>) -> Option<T> + 'static>],\n-    ) -> Option<T> {\n-        for pf in parsers {\n-            if let Some(r) = self.read_atomically(|p: &mut Parser<'_>| pf(p)) {\n-                return Some(r);\n-            }\n-        }\n-        None\n-    }\n-\n     // Apply 3 parsers sequentially\n     fn read_seq_3<A, B, C, PA, PB, PC>(&mut self, pa: PA, pb: PB, pc: PC) -> Option<(A, B, C)>\n     where\n@@ -235,9 +222,8 @@ impl<'a> Parser<'a> {\n     }\n \n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n-        let ipv4_addr = |p: &mut Parser<'_>| p.read_ipv4_addr().map(IpAddr::V4);\n-        let ipv6_addr = |p: &mut Parser<'_>| p.read_ipv6_addr().map(IpAddr::V6);\n-        self.read_or(&mut [Box::new(ipv4_addr), Box::new(ipv6_addr)])\n+        self.read_ipv4_addr().map(IpAddr::V4)\n+            .or_else(|| self.read_ipv6_addr().map(IpAddr::V6))\n     }\n \n     fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n@@ -268,9 +254,8 @@ impl<'a> Parser<'a> {\n     }\n \n     fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n-        let v4 = |p: &mut Parser<'_>| p.read_socket_addr_v4().map(SocketAddr::V4);\n-        let v6 = |p: &mut Parser<'_>| p.read_socket_addr_v6().map(SocketAddr::V6);\n-        self.read_or(&mut [Box::new(v4), Box::new(v6)])\n+        self.read_socket_addr_v4().map(SocketAddr::V4)\n+            .or_else(|| self.read_socket_addr_v6().map(SocketAddr::V6))\n     }\n }\n "}, {"sha": "720928e48e3820869ac6a89db05aee3cb12af572", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -129,8 +129,9 @@ extern \"C\" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, LLVMTypeRef Ty) {\n-  return wrap(unwrap(M)->getOrInsertGlobal(Name, unwrap(Ty)));\n+LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty) {\n+  StringRef NameRef(Name, NameLen);\n+  return wrap(unwrap(M)->getOrInsertGlobal(NameRef, unwrap(Ty)));\n }\n \n extern \"C\" LLVMValueRef\n@@ -1287,11 +1288,12 @@ extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B,\n }\n \n extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n-                                  const char *Name) {\n+                                  const char *Name, size_t NameLen) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n   GlobalObject *GV = unwrap<GlobalObject>(V);\n   if (!TargetTriple.isOSBinFormatMachO()) {\n-    GV->setComdat(unwrap(M)->getOrInsertComdat(Name));\n+    StringRef NameRef(Name, NameLen);\n+    GV->setComdat(unwrap(M)->getOrInsertComdat(NameRef));\n   }\n }\n "}, {"sha": "d9614f062b7e96e8ab3d2af71e4a2c3b635214e0", "filename": "src/test/codegen/set-discriminant-invalid.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Fcodegen%2Fset-discriminant-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Fcodegen%2Fset-discriminant-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fset-discriminant-invalid.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: -C opt-level=0\n+#![crate_type = \"lib\"]\n+\n+pub enum ApiError {}\n+#[allow(dead_code)]\n+pub struct TokioError {\n+    b: bool,\n+}\n+pub enum Error {\n+    Api {\n+        source: ApiError,\n+    },\n+    Ethereum,\n+    Tokio {\n+        source: TokioError,\n+    },\n+}\n+struct Api;\n+impl IntoError<Error> for Api\n+{\n+    type Source = ApiError;\n+    // CHECK-LABEL: @into_error\n+    // CHECK: llvm.trap()\n+    // Also check the next two instructions to make sure we do not match against `trap`\n+    // elsewhere in the code.\n+    // CHECK-NEXT: load\n+    // CHECK-NEXT: ret\n+    #[no_mangle]\n+    fn into_error(self, error: Self::Source) -> Error {\n+        Error::Api {\n+            source: (|v| v)(error),\n+        }\n+    }\n+}\n+\n+pub trait IntoError<E>\n+{\n+    /// The underlying error\n+    type Source;\n+\n+    /// Combine the information to produce the error\n+    fn into_error(self, source: Self::Source) -> E;\n+}"}, {"sha": "448ce367b8c6b5b3216635c4f1f9a42ed807477f", "filename": "src/test/incremental/issue-61323.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Fincremental%2Fissue-61323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Fincremental%2Fissue-61323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-61323.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -0,0 +1,15 @@\n+// revisions: rpass cfail\n+\n+enum A {\n+    //[cfail]~^ ERROR 3:1: 3:7: recursive type `A` has infinite size [E0072]\n+    B(C),\n+}\n+\n+#[cfg(rpass)]\n+struct C(Box<A>);\n+\n+#[cfg(cfail)]\n+struct C(A);\n+//[cfail]~^ ERROR 12:1: 12:13: recursive type `C` has infinite size [E0072]\n+\n+fn main() {}"}, {"sha": "d4835c092248e3906987f0540890a85a1f510586", "filename": "src/test/rustdoc-ui/issue-61732.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Frustdoc-ui%2Fissue-61732.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Frustdoc-ui%2Fissue-61732.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-61732.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -0,0 +1,4 @@\n+// This previously triggered an ICE.\n+\n+pub(in crate::r#mod) fn main() {}\n+//~^ ERROR expected module, found unresolved item"}, {"sha": "6c8ba48864df0a7e70377187619d8987c2443e13", "filename": "src/test/rustdoc-ui/issue-61732.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -0,0 +1,11 @@\n+error[E0577]: expected module, found unresolved item `crate::r#mod`\n+  --> $DIR/issue-61732.rs:3:8\n+   |\n+LL | pub(in crate::r#mod) fn main() {}\n+   |        ^^^^^^^^^^^^ not a module\n+\n+error: Compilation failed, aborting rustdoc\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0577`."}, {"sha": "505d6ee769ab3040c364f7f6830cac26c405f7ac", "filename": "src/test/rustdoc/duplicate-cfg.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9630dbbc3caca60f2482e6eae8904aa6bda54f93/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs?ref=9630dbbc3caca60f2482e6eae8904aa6bda54f93", "patch": "@@ -0,0 +1,15 @@\n+#![crate_name = \"foo\"]\n+#![feature(doc_cfg)]\n+\n+// @has 'foo/index.html'\n+// @!has '-' '//*[@class=\"stab portability\"]' 'feature=\"sync\" and'\n+// @has '-' '//*[@class=\"stab portability\"]' 'feature=\"sync\"'\n+#[doc(cfg(feature = \"sync\"))]\n+#[doc(cfg(feature = \"sync\"))]\n+pub struct Foo;\n+\n+#[doc(cfg(feature = \"sync\"))]\n+pub mod bar {\n+    #[doc(cfg(feature = \"sync\"))]\n+    pub struct Bar;\n+}"}]}