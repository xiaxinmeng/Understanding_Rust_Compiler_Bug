{"sha": "40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYzZkZDFmNGM1N2Q2YThlYzI2YzFiZGVmMjQ3NTNjODg0YzM4YWE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T21:41:37Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T21:41:37Z"}, "message": "Merge #982\n\n982: Implement BindingMode for pattern matching. r=flodiebold a=mjkillough\n\nImplement `BindingMode` for pattern matching, so that types can be\r\ncorrectly inferred using match ergonomics. The binding mode defaults to\r\n`Move` (referred to as 'BindingMode::BindByValue` in rustc), and is\r\nupdated by automatic dereferencing of the value being matched.\r\n\r\nFixes #888.\r\n\r\n - [Binding modes in The Reference](https://doc.rust-lang.org/reference/patterns.html#binding-modes)\r\n - [`rustc` implementation](https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src/librustc_typeck/check/_match.rs#L77) (and [definition of `BindingMode`](https://github.com/rust-lang/rust/blob/e957ed9d10ec589bdd523b88b4b44c41b1ecf763/src/librustc/ty/binding.rs))\r\n - [Match Ergonomics RFC](https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#binding-mode-rules)\n\nCo-authored-by: Michael Killough <michaeljkillough@gmail.com>", "tree": {"sha": "cf9959b252a7c9e25c4e186b57f92ff9d6bec61d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf9959b252a7c9e25c4e186b57f92ff9d6bec61d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa", "html_url": "https://github.com/rust-lang/rust/commit/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "91e7a3b6f2a9f1a09f874e9644491898338a842f", "url": "https://api.github.com/repos/rust-lang/rust/commits/91e7a3b6f2a9f1a09f874e9644491898338a842f", "html_url": "https://github.com/rust-lang/rust/commit/91e7a3b6f2a9f1a09f874e9644491898338a842f"}, {"sha": "6299ccd350c190003c51aa68f48b1edfb1a497b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6299ccd350c190003c51aa68f48b1edfb1a497b1", "html_url": "https://github.com/rust-lang/rust/commit/6299ccd350c190003c51aa68f48b1edfb1a497b1"}], "stats": {"total": 154, "additions": 137, "deletions": 17}, "files": [{"sha": "5b640004288ff50fd7d5c60fb7d78a155aaf5203", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa", "patch": "@@ -8,4 +8,5 @@ test_utils::marks!(\n     glob_enum\n     glob_across_crates\n     std_prelude\n+    match_ergonomics_ref\n );"}, {"sha": "735cdecb910c11e4a8836d367916792343cac6d0", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 82, "deletions": 17, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa", "patch": "@@ -63,6 +63,30 @@ enum ExprOrPatId {\n \n impl_froms!(ExprOrPatId: ExprId, PatId);\n \n+/// Binding modes inferred for patterns.\n+/// https://doc.rust-lang.org/reference/patterns.html#binding-modes\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+enum BindingMode {\n+    Move,\n+    Ref(Mutability),\n+}\n+\n+impl BindingMode {\n+    pub fn convert(annotation: &BindingAnnotation) -> BindingMode {\n+        match annotation {\n+            BindingAnnotation::Unannotated | BindingAnnotation::Mutable => BindingMode::Move,\n+            BindingAnnotation::Ref => BindingMode::Ref(Mutability::Shared),\n+            BindingAnnotation::RefMut => BindingMode::Ref(Mutability::Mut),\n+        }\n+    }\n+}\n+\n+impl Default for BindingMode {\n+    fn default() -> Self {\n+        BindingMode::Move\n+    }\n+}\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n@@ -530,6 +554,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: Option<&Path>,\n         subpats: &[PatId],\n         expected: &Ty,\n+        default_bm: BindingMode,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n \n@@ -542,13 +567,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n                 .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n-            self.infer_pat(subpat, &expected_ty);\n+            self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n-    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat], expected: &Ty) -> Ty {\n+    fn infer_struct_pat(\n+        &mut self,\n+        path: Option<&Path>,\n+        subpats: &[FieldPat],\n+        expected: &Ty,\n+        default_bm: BindingMode,\n+    ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n \n         self.unify(&ty, expected);\n@@ -559,15 +590,45 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n             let expected_ty =\n                 matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n-            self.infer_pat(subpat.pat, &expected_ty);\n+            self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n-    fn infer_pat(&mut self, pat: PatId, expected: &Ty) -> Ty {\n+    fn infer_pat(&mut self, pat: PatId, mut expected: &Ty, mut default_bm: BindingMode) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n \n+        let is_non_ref_pat = match &body[pat] {\n+            Pat::Tuple(..)\n+            | Pat::TupleStruct { .. }\n+            | Pat::Struct { .. }\n+            | Pat::Range { .. }\n+            | Pat::Slice { .. } => true,\n+            // TODO: Path/Lit might actually evaluate to ref, but inference is unimplemented.\n+            Pat::Path(..) | Pat::Lit(..) => true,\n+            Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Missing => false,\n+        };\n+        if is_non_ref_pat {\n+            while let Ty::Ref(inner, mutability) = expected {\n+                expected = inner;\n+                default_bm = match default_bm {\n+                    BindingMode::Move => BindingMode::Ref(*mutability),\n+                    BindingMode::Ref(Mutability::Shared) => BindingMode::Ref(Mutability::Shared),\n+                    BindingMode::Ref(Mutability::Mut) => BindingMode::Ref(*mutability),\n+                }\n+            }\n+        } else if let Pat::Ref { .. } = &body[pat] {\n+            tested_by!(match_ergonomics_ref);\n+            // When you encounter a `&pat` pattern, reset to Move.\n+            // This is so that `w` is by value: `let (_, &w) = &(1, &2);`\n+            default_bm = BindingMode::Move;\n+        }\n+\n+        // Lose mutability.\n+        let default_bm = default_bm;\n+        let expected = expected;\n+\n         let ty = match &body[pat] {\n             Pat::Tuple(ref args) => {\n                 let expectations = match *expected {\n@@ -579,7 +640,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_tys = args\n                     .iter()\n                     .zip(expectations_iter)\n-                    .map(|(&pat, ty)| self.infer_pat(pat, ty))\n+                    .map(|(&pat, ty)| self.infer_pat(pat, ty, default_bm))\n                     .collect::<Vec<_>>()\n                     .into();\n \n@@ -595,32 +656,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     _ => &Ty::Unknown,\n                 };\n-                let subty = self.infer_pat(*pat, expectation);\n+                let subty = self.infer_pat(*pat, expectation, default_bm);\n                 Ty::Ref(subty.into(), *mutability)\n             }\n             Pat::TupleStruct { path: ref p, args: ref subpats } => {\n-                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected)\n+                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n             }\n             Pat::Struct { path: ref p, args: ref fields } => {\n-                self.infer_struct_pat(p.as_ref(), fields, expected)\n+                self.infer_struct_pat(p.as_ref(), fields, expected, default_bm)\n             }\n             Pat::Path(path) => {\n                 // TODO use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n                 self.infer_path_expr(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n             }\n             Pat::Bind { mode, name: _name, subpat } => {\n+                let mode = if mode == &BindingAnnotation::Unannotated {\n+                    default_bm\n+                } else {\n+                    BindingMode::convert(mode)\n+                };\n                 let inner_ty = if let Some(subpat) = subpat {\n-                    self.infer_pat(*subpat, expected)\n+                    self.infer_pat(*subpat, expected, default_bm)\n                 } else {\n                     expected.clone()\n                 };\n                 let inner_ty = self.insert_type_vars_shallow(inner_ty);\n \n                 let bound_ty = match mode {\n-                    BindingAnnotation::Ref => Ty::Ref(inner_ty.clone().into(), Mutability::Shared),\n-                    BindingAnnotation::RefMut => Ty::Ref(inner_ty.clone().into(), Mutability::Mut),\n-                    BindingAnnotation::Mutable | BindingAnnotation::Unannotated => inner_ty.clone(),\n+                    BindingMode::Ref(mutability) => Ty::Ref(inner_ty.clone().into(), mutability),\n+                    BindingMode::Move => inner_ty.clone(),\n                 };\n                 let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n                 self.write_pat_ty(pat, bound_ty);\n@@ -700,7 +765,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::For { iterable, body, pat } => {\n                 let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-                self.infer_pat(*pat, &Ty::Unknown);\n+                self.infer_pat(*pat, &Ty::Unknown, BindingMode::default());\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n@@ -714,7 +779,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     } else {\n                         Ty::Unknown\n                     };\n-                    self.infer_pat(*arg_pat, &expected);\n+                    self.infer_pat(*arg_pat, &expected, BindingMode::default());\n                 }\n \n                 // TODO: infer lambda type etc.\n@@ -807,7 +872,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n-                        let _pat_ty = self.infer_pat(pat, &input_ty);\n+                        let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::default());\n                     }\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(guard_expr, &Expectation::has_type(Ty::Bool));\n@@ -1007,7 +1072,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         decl_ty\n                     };\n \n-                    self.infer_pat(*pat, &ty);\n+                    self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n                     self.infer_expr(*expr, &Expectation::none());\n@@ -1023,7 +1088,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref);\n \n-            self.infer_pat(*pat, &ty);\n+            self.infer_pat(*pat, &ty, BindingMode::default());\n         }\n         self.return_ty = self.make_ty(signature.ret_type());\n     }"}, {"sha": "0f2172ddfc7898fe84ece9941673e92cc86fbb6b", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=40c6dd1f4c57d6a8ec26c1bdef24753c884c38aa", "patch": "@@ -830,6 +830,60 @@ fn test(x: &i32) {\n     );\n }\n \n+#[test]\n+fn infer_pattern_match_ergonomics() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+struct A<T>(T);\n+\n+fn test() {\n+    let A(n) = &A(1);\n+    let A(n) = &mut A(1);\n+}\n+\"#),\n+    @r###\"\n+[28; 79) '{     ...(1); }': ()\n+[38; 42) 'A(n)': A<i32>\n+[40; 41) 'n': &i32\n+[45; 50) '&A(1)': &A<i32>\n+[46; 47) 'A': A<i32>(T) -> A<T>\n+[46; 50) 'A(1)': A<i32>\n+[48; 49) '1': i32\n+[60; 64) 'A(n)': A<i32>\n+[62; 63) 'n': &mut i32\n+[67; 76) '&mut A(1)': &mut A<i32>\n+[72; 73) 'A': A<i32>(T) -> A<T>\n+[72; 76) 'A(1)': A<i32>\n+[74; 75) '1': i32\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_pattern_match_ergonomics_ref() {\n+    covers!(match_ergonomics_ref);\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+fn test() {\n+    let v = &(1, &2);\n+    let (_, &w) = v;\n+}\n+\"#),\n+    @r###\"\n+[11; 57) '{     ...= v; }': ()\n+[21; 22) 'v': &(i32, &i32)\n+[25; 33) '&(1, &2)': &(i32, &i32)\n+[26; 33) '(1, &2)': (i32, &i32)\n+[27; 28) '1': i32\n+[30; 32) '&2': &i32\n+[31; 32) '2': i32\n+[43; 50) '(_, &w)': (i32, &i32)\n+[44; 45) '_': i32\n+[47; 49) '&w': &i32\n+[48; 49) 'w': i32\n+[53; 54) 'v': &(i32, &i32)\"###\n+    );\n+}\n+\n #[test]\n fn infer_adt_pattern() {\n     assert_snapshot_matches!("}]}