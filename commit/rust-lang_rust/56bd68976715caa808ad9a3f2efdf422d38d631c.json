{"sha": "56bd68976715caa808ad9a3f2efdf422d38d631c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2YmQ2ODk3NjcxNWNhYTgwOGFkOWEzZjJlZmRmNDIyZDM4ZDYzMWM=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-15T04:03:41Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-15T04:03:41Z"}, "message": "Merge branch 'incoming' of github.com:mozilla/rust into newsnap", "tree": {"sha": "e834f8c865ef120791cabf991f636d04b546ca82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e834f8c865ef120791cabf991f636d04b546ca82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56bd68976715caa808ad9a3f2efdf422d38d631c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56bd68976715caa808ad9a3f2efdf422d38d631c", "html_url": "https://github.com/rust-lang/rust/commit/56bd68976715caa808ad9a3f2efdf422d38d631c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56bd68976715caa808ad9a3f2efdf422d38d631c/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ab15c0266260faadd2804623c729efcb14e7315", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab15c0266260faadd2804623c729efcb14e7315", "html_url": "https://github.com/rust-lang/rust/commit/8ab15c0266260faadd2804623c729efcb14e7315"}, {"sha": "77e6573929702731bc0bd2c41724e6a587c7f268", "url": "https://api.github.com/repos/rust-lang/rust/commits/77e6573929702731bc0bd2c41724e6a587c7f268", "html_url": "https://github.com/rust-lang/rust/commit/77e6573929702731bc0bd2c41724e6a587c7f268"}], "stats": {"total": 344, "additions": 201, "deletions": 143}, "files": [{"sha": "edc90fe8676496cfd02bc6bb54986947099dac76", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -402,7 +402,7 @@ enum lit_ {\n     lit_str(@str),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n-    lit_int_unsuffixed(i64, int_ty),\n+    lit_int_unsuffixed(i64),\n     lit_float(@str, float_ty),\n     lit_nil,\n     lit_bool(bool),"}, {"sha": "a3d55df320bf06fc46ac194acdf5fcb927ddceaa", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -54,7 +54,7 @@ fn ends_in_lit_int(ex: @ast::expr) -> bool {\n       ast::expr_lit(node) {\n         alt node {\n           @{node: ast::lit_int(_, ast::ty_i), _} |\n-          @{node: ast::lit_int_unsuffixed(_, ast::ty_i), _}\n+          @{node: ast::lit_int_unsuffixed(_), _}\n           { true }\n           _ { false }\n         }"}, {"sha": "72b2462feb19488e09c2da6d66fe10f69690d32d", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -285,7 +285,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n \n         #debug[\"lexing %s as an unsuffixed integer literal\",\n                num_str];\n-        ret token::LIT_INT_UNSUFFIXED(parsed as i64, ast::ty_i);\n+        ret token::LIT_INT_UNSUFFIXED(parsed as i64);\n     }\n }\n "}, {"sha": "62ec5cc50f67f9d14340a6da6bad88eadc6632ac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -501,7 +501,7 @@ class parser {\n             let lo = self.span.lo;\n             self.bump();\n             alt copy self.token {\n-              token::LIT_INT_UNSUFFIXED(num, _) {\n+              token::LIT_INT_UNSUFFIXED(num) {\n                 self.bump();\n                 some(mac_var(num as uint))\n               }\n@@ -534,7 +534,7 @@ class parser {\n               token::UNDERSCORE {\n                 self.bump(); some(vstore_fixed(none))\n               }\n-              token::LIT_INT_UNSUFFIXED(i, _) if i >= 0i64 {\n+              token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 {\n                 self.bump(); some(vstore_fixed(some(i as uint)))\n               }\n               token::BINOP(token::AND) {\n@@ -553,7 +553,7 @@ class parser {\n         alt tok {\n           token::LIT_INT(i, it) { lit_int(i, it) }\n           token::LIT_UINT(u, ut) { lit_uint(u, ut) }\n-          token::LIT_INT_UNSUFFIXED(i, it) { lit_int_unsuffixed(i, it) }\n+          token::LIT_INT_UNSUFFIXED(i) { lit_int_unsuffixed(i) }\n           token::LIT_FLOAT(s, ft) { lit_float(self.get_str(s), ft) }\n           token::LIT_STR(s) { lit_str(self.get_str(s)) }\n           token::LPAREN { self.expect(token::RPAREN); lit_nil }"}, {"sha": "4f4c2ee0064cfafd3c60e3354a0799444fd3fae4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -57,7 +57,7 @@ enum token {\n     /* Literals */\n     LIT_INT(i64, ast::int_ty),\n     LIT_UINT(u64, ast::uint_ty),\n-    LIT_INT_UNSUFFIXED(i64, ast::int_ty),\n+    LIT_INT_UNSUFFIXED(i64),\n     LIT_FLOAT(str_num, ast::float_ty),\n     LIT_STR(str_num),\n \n@@ -129,8 +129,8 @@ fn to_str(in: interner<@str>, t: token) -> str {\n       LIT_UINT(u, t) {\n         uint::to_str(u as uint, 10u) + ast_util::uint_ty_to_str(t)\n       }\n-      LIT_INT_UNSUFFIXED(i, t) {\n-        int::to_str(i as int, 10u) + ast_util::int_ty_to_str(t)\n+      LIT_INT_UNSUFFIXED(i) {\n+        int::to_str(i as int, 10u)\n       }\n       LIT_FLOAT(s, t) {\n         *interner::get(in, s) +\n@@ -160,7 +160,7 @@ pure fn can_begin_expr(t: token) -> bool {\n       TILDE { true }\n       LIT_INT(_, _) { true }\n       LIT_UINT(_, _) { true }\n-      LIT_INT_UNSUFFIXED(_, _) { true }\n+      LIT_INT_UNSUFFIXED(_) { true }\n       LIT_FLOAT(_, _) { true }\n       LIT_STR(_) { true }\n       POUND { true }\n@@ -178,7 +178,7 @@ fn is_lit(t: token) -> bool {\n     alt t {\n       LIT_INT(_, _) { true }\n       LIT_UINT(_, _) { true }\n-      LIT_INT_UNSUFFIXED(_, _) { true }\n+      LIT_INT_UNSUFFIXED(_) { true }\n       LIT_FLOAT(_, _) { true }\n       LIT_STR(_) { true }\n       _ { false }"}, {"sha": "43b498eae62f44b0c50f98e33de0007fe7f56514", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -1628,15 +1628,11 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n              u64::to_str(u, 10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n-      ast::lit_int_unsuffixed(i, t) {\n+      ast::lit_int_unsuffixed(i) {\n         if i < 0_i64 {\n-            word(s.s,\n-                 \"-\" + u64::to_str(-i as u64, 10u)\n-                 + ast_util::int_ty_to_str(t));\n+            word(s.s, \"-\" + u64::to_str(-i as u64, 10u));\n         } else {\n-            word(s.s,\n-                 u64::to_str(i as u64, 10u)\n-                 + ast_util::int_ty_to_str(t));\n+            word(s.s, u64::to_str(i as u64, 10u));\n         }\n       }\n       ast::lit_float(f, t) {"}, {"sha": "f21b3850a984829a3b12e1c6d09e55b08ea63609", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -278,10 +278,9 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_uint(id.to_uint());\n       }\n       ty::ty_var_integral(id) {\n-        // TODO: should we have a different character for these? (Issue #1425)\n         w.write_char('X');\n+        w.write_char('I');\n         w.write_uint(id.to_uint());\n-        w.write_str(\"(integral)\");\n       }\n       ty::ty_param(id, did) {\n         w.write_char('p');"}, {"sha": "661ad87dfa8485a99cf2a85a9c6217aa67bd0150", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -111,7 +111,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_str(s) { const_str(*s) }\n       lit_int(n, _) { const_int(n) }\n       lit_uint(n, _) { const_uint(n) }\n-      lit_int_unsuffixed(n, _) { const_int(n) }\n+      lit_int_unsuffixed(n) { const_int(n) }\n       lit_float(n, _) { const_float(option::get(float::from_str(*n)) as f64) }\n       lit_nil { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }"}, {"sha": "590440ecb7fe5d36c9e8c6c64629edfa957c7527", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -1473,15 +1473,25 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n     ret move_val(cx, action, dst, src, t);\n }\n \n-fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n+fn trans_crate_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n+    -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_crate_lit\");\n     alt lit.node {\n       ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n       ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n-      ast::lit_int_unsuffixed(i, t) {\n-        // FIXME (#1425): should we be using cx.fcx.infcx to figure out what\n-        // to actually generate from this?\n-        C_integral(T_int_ty(cx, t), i as u64, True)\n+      ast::lit_int_unsuffixed(i) {\n+        let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n+        alt ty::get(lit_int_ty).struct {\n+          ty::ty_int(t) {\n+            C_integral(T_int_ty(cx, t), i as u64, True)\n+          }\n+          ty::ty_uint(t) {\n+            C_integral(T_uint_ty(cx, t), i as u64, False)\n+          }\n+          _ { cx.sess.span_bug(lit.span,\n+                               \"integer literal doesn't have a type\");\n+            }\n+        }\n       }\n       ast::lit_float(fs, t) { C_floating(*fs, T_float_ty(cx, t)) }\n       ast::lit_bool(b) { C_bool(b) }\n@@ -1492,13 +1502,13 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n     }\n }\n \n-fn trans_lit(cx: block, lit: ast::lit, dest: dest) -> block {\n+fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n     let _icx = cx.insn_ctxt(\"trans_lit\");\n     if dest == ignore { ret cx; }\n     alt lit.node {\n       ast::lit_str(s) { tvec::trans_estr(cx, s, ast::vstore_uniq, dest) }\n       _ {\n-        store_in_dest(cx, trans_crate_lit(cx.ccx(), lit), dest)\n+        store_in_dest(cx, trans_crate_lit(cx.ccx(), e, lit), dest)\n       }\n     }\n }\n@@ -3584,7 +3594,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           }\n           ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n           ast::expr_vstore(e, v) { ret tvec::trans_vstore(bcx, e, v, dest); }\n-          ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n+          ast::expr_lit(lit) { ret trans_lit(bcx, e, *lit, dest); }\n           ast::expr_vec(args, _) {\n             ret tvec::trans_evec(bcx, args, ast::vstore_uniq, e.id, dest);\n           }\n@@ -4684,7 +4694,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_const_expr\");\n     alt e.node {\n-      ast::expr_lit(lit) { ret trans_crate_lit(cx, *lit); }\n+      ast::expr_lit(lit) { ret trans_crate_lit(cx, e, *lit); }\n       ast::expr_binary(b, e1, e2) {\n         let te1 = trans_const_expr(cx, e1);\n         let te2 = trans_const_expr(cx, e2);"}, {"sha": "b7ceaa8ab47855f9251431daa09d1974370bfd32", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -84,6 +84,7 @@ export ty_float, mk_float, mk_mach_float, type_is_fp;\n export ty_fn, fn_ty, mk_fn;\n export ty_fn_proto, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n export ty_int, mk_int, mk_mach_int, mk_char;\n+export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n export ty_str, mk_str, type_is_str;\n export ty_vec, mk_vec, type_is_vec;\n export ty_estr, mk_estr;\n@@ -416,7 +417,8 @@ enum type_err {\n     terr_vstores_differ(terr_vstore_kind, vstore, vstore),\n     terr_in_field(@type_err, ast::ident),\n     terr_sorts(t, t),\n-    terr_self_substs\n+    terr_self_substs,\n+    terr_no_integral_type,\n }\n \n enum param_bound {\n@@ -442,7 +444,7 @@ impl of vid for tv_vid {\n \n impl of vid for tvi_vid {\n     fn to_uint() -> uint { *self }\n-    fn to_str() -> str { #fmt[\"<V (integral) %u>\", self.to_uint()] }\n+    fn to_str() -> str { #fmt[\"<VI%u>\", self.to_uint()] }\n }\n \n impl of vid for region_vid {\n@@ -619,12 +621,26 @@ fn mk_bool(cx: ctxt) -> t { mk_t(cx, ty_bool) }\n \n fn mk_int(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i)) }\n \n+fn mk_i8(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i8)) }\n+\n+fn mk_i16(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i16)) }\n+\n+fn mk_i32(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i32)) }\n+\n+fn mk_i64(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i64)) }\n+\n fn mk_float(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f)) }\n \n fn mk_uint(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u)) }\n \n fn mk_u8(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u8)) }\n \n+fn mk_u16(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u16)) }\n+\n+fn mk_u32(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u32)) }\n+\n+fn mk_u64(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u64)) }\n+\n fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n \n fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n@@ -1188,7 +1204,7 @@ pure fn type_is_unique(ty: t) -> bool {\n pure fn type_is_scalar(ty: t) -> bool {\n     alt get(ty).struct {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type | ty_ptr(_) | ty_rptr(_, _) { true }\n+      ty_var_integral(_) | ty_type | ty_ptr(_) | ty_rptr(_, _) { true }\n       _ { false }\n     }\n }\n@@ -1827,7 +1843,7 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n \n fn type_is_integral(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_int(_) | ty_uint(_) | ty_bool { true }\n+      ty_var_integral(_) | ty_int(_) | ty_uint(_) | ty_bool { true }\n       _ { false }\n     }\n }\n@@ -2531,6 +2547,10 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n       terr_self_substs {\n         ret \"inconsistent self substitution\"; // XXX this is more of a bug\n       }\n+      terr_no_integral_type {\n+        ret \"couldn't determine an appropriate integral type for integer \\\n+             literal\";\n+      }\n     }\n }\n \n@@ -2966,7 +2986,7 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     fn tycat(ty: t) -> int {\n         alt get(ty).struct {\n           ty_bool { tycat_bool }\n-          ty_int(_) | ty_uint(_) { tycat_int }\n+          ty_int(_) | ty_uint(_) | ty_var_integral(_) { tycat_int }\n           ty_float(_) { tycat_float }\n           ty_estr(_) | ty_str { tycat_str }\n           ty_evec(_, _) | ty_vec(_) { tycat_vec }"}, {"sha": "56050c0af58dfe9d91bf04ffb5a06a41f18c0369", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -73,11 +73,9 @@ import middle::ty::{tv_vid, vid};\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n import rscope::{in_binding_rscope, region_scope, type_rscope};\n-import syntax::ast::{ty_char, ty_i8, ty_i16, ty_i32, ty_i64, ty_i};\n+import syntax::ast::{ty_char, ty_i};\n import typeck::infer::{root, to_str};\n import typeck::infer::{unify_methods}; // infcx.set()\n-import typeck::infer::{min_8bit_tys, min_16bit_tys, min_32bit_tys,\n-                       min_64bit_tys};\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -624,29 +622,13 @@ fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n       ast::lit_str(_) { ty::mk_str(tcx) }\n       ast::lit_int(_, t) { ty::mk_mach_int(tcx, t) }\n       ast::lit_uint(_, t) { ty::mk_mach_uint(tcx, t) }\n-      ast::lit_int_unsuffixed(v, t) {\n+      ast::lit_int_unsuffixed(v) {\n         // An unsuffixed integer literal could have any integral type,\n         // so we create an integral type variable for it.\n-        let vid = fcx.infcx.next_ty_var_integral_id();\n-\n-        // We need to sniff at the value `v` and figure out how big of\n-        // an int it is; that determines the range of possible types\n-        // that the integral type variable could take on.\n-        let possible_types = alt v {\n-          0i64 to 127i64 { min_8bit_tys() }\n-          128i64 to 65535i64 { min_16bit_tys() }\n-          65536i64 to 4294967295i64 { min_32bit_tys() }\n-          _ { min_64bit_tys() }\n-        };\n-\n-        // Store the set of possible types and return the integral\n-        // type variable.\n-        fcx.infcx.set(fcx.infcx.tvib, vid,\n-                      root(possible_types));\n-        ty::mk_var_integral(tcx, vid);\n+        ty::mk_var_integral(tcx, fcx.infcx.next_ty_var_integral_id());\n \n         // FIXME: remove me when #1425 is finished.\n-        ty::mk_mach_int(tcx, t)\n+        ty::mk_mach_int(tcx, ty_i)\n       }\n       ast::lit_float(_, t) { ty::mk_mach_float(tcx, t) }\n       ast::lit_nil { ty::mk_nil(tcx) }"}, {"sha": "b5770528a3e2e7390c429f4920c25e6ffb4cb235", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 137, "deletions": 86, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56bd68976715caa808ad9a3f2efdf422d38d631c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=56bd68976715caa808ad9a3f2efdf422d38d631c", "patch": "@@ -147,7 +147,8 @@ import std::smallintmap::smallintmap;\n import std::smallintmap::map;\n import std::map::hashmap;\n import middle::ty;\n-import middle::ty::{tv_vid, tvi_vid, region_vid, vid};\n+import middle::ty::{tv_vid, tvi_vid, region_vid, vid,\n+                    ty_int, ty_uint, get};\n import syntax::{ast, ast_util};\n import syntax::ast::{ret_style, purity};\n import util::ppaux::{ty_to_str, mt_to_str};\n@@ -174,7 +175,7 @@ export compare_tys;\n export fixup_err, fixup_err_to_str;\n export assignment;\n export root, to_str;\n-export min_8bit_tys, min_16bit_tys, min_32bit_tys, min_64bit_tys;\n+export int_ty_set_all;\n \n // Bitvector to represent sets of integral types\n enum int_ty_set = uint;\n@@ -193,32 +194,66 @@ const INT_TY_SET_u64   : uint = 0b00_1000_0000u;\n const INT_TY_SET_i     : uint = 0b01_0000_0000u;\n const INT_TY_SET_u     : uint = 0b10_0000_0000u;\n \n-fn mk_int_ty_set() -> int_ty_set { int_ty_set(INT_TY_SET_EMPTY) }\n-\n-fn min_8bit_tys()  -> int_ty_set {\n+fn int_ty_set_all()  -> int_ty_set {\n     int_ty_set(INT_TY_SET_i8  | INT_TY_SET_u8 |\n                INT_TY_SET_i16 | INT_TY_SET_u16 |\n                INT_TY_SET_i32 | INT_TY_SET_u32 |\n                INT_TY_SET_i64 | INT_TY_SET_u64 |\n                INT_TY_SET_i   | INT_TY_SET_u)\n }\n \n-fn min_16bit_tys() -> int_ty_set {\n-    int_ty_set(INT_TY_SET_i16 | INT_TY_SET_u16 |\n-               INT_TY_SET_i32 | INT_TY_SET_u32 |\n-               INT_TY_SET_i64 | INT_TY_SET_u64 |\n-               INT_TY_SET_i   | INT_TY_SET_u)\n+fn intersection(a: int_ty_set, b: int_ty_set) -> int_ty_set {\n+    int_ty_set(*a & *b)\n }\n \n-fn min_32bit_tys() -> int_ty_set {\n-    int_ty_set(INT_TY_SET_i32 | INT_TY_SET_u32 |\n-               INT_TY_SET_i64 | INT_TY_SET_u64 |\n-               // uh, can we count on ty_i and ty_u being 32 bits?\n-               INT_TY_SET_i   | INT_TY_SET_u)\n+fn single_type_contained_in(tcx: ty::ctxt, a: int_ty_set) ->\n+    option<ty::t> {\n+    #debug[\"type_contained_in(a=%s)\", uint::to_str(*a, 10u)];\n+\n+    if *a == INT_TY_SET_i8    { ret some(ty::mk_i8(tcx)); }\n+    if *a == INT_TY_SET_u8    { ret some(ty::mk_u8(tcx)); }\n+    if *a == INT_TY_SET_i16   { ret some(ty::mk_i16(tcx)); }\n+    if *a == INT_TY_SET_u16   { ret some(ty::mk_u16(tcx)); }\n+    if *a == INT_TY_SET_i32   { ret some(ty::mk_i32(tcx)); }\n+    if *a == INT_TY_SET_u32   { ret some(ty::mk_u32(tcx)); }\n+    if *a == INT_TY_SET_i64   { ret some(ty::mk_i64(tcx)); }\n+    if *a == INT_TY_SET_u64   { ret some(ty::mk_u64(tcx)); }\n+    if *a == INT_TY_SET_i     { ret(some(ty::mk_int(tcx))); }\n+    if *a == INT_TY_SET_u     { ret(some(ty::mk_uint(tcx))); }\n+    ret none;\n }\n \n-fn min_64bit_tys() -> int_ty_set {\n-    int_ty_set(INT_TY_SET_i64 | INT_TY_SET_u64)\n+fn is_subset_of(a: int_ty_set, b: int_ty_set) -> bool {\n+    (*a & *b) == *a\n+}\n+\n+fn convert_integral_ty_to_int_ty_set(tcx: ty::ctxt, t: ty::t)\n+    -> int_ty_set {\n+\n+    alt get(t).struct {\n+      ty_int(int_ty) {\n+        alt int_ty {\n+          ast::ty_i8   { int_ty_set(INT_TY_SET_i8)  }\n+          ast::ty_i16  { int_ty_set(INT_TY_SET_i16) }\n+          ast::ty_i32  { int_ty_set(INT_TY_SET_i32) }\n+          ast::ty_i64  { int_ty_set(INT_TY_SET_i64) }\n+          ast::ty_i    { int_ty_set(INT_TY_SET_i)   }\n+          ast::ty_char { tcx.sess.bug(\n+              \"char type passed to convert_integral_ty_to_int_ty_set()\"); }\n+        }\n+      }\n+      ty_uint(uint_ty) {\n+        alt uint_ty {\n+          ast::ty_u8  { int_ty_set(INT_TY_SET_u8)  }\n+          ast::ty_u16 { int_ty_set(INT_TY_SET_u16) }\n+          ast::ty_u32 { int_ty_set(INT_TY_SET_u32) }\n+          ast::ty_u64 { int_ty_set(INT_TY_SET_u64) }\n+          ast::ty_u   { int_ty_set(INT_TY_SET_u)   }\n+        }\n+      }\n+      _ { tcx.sess.bug(\"non-integral type passed to \\\n+                        convert_integral_ty_to_int_ty_set()\"); }\n+    }\n }\n \n // Extra information needed to perform an assignment that may borrow.\n@@ -265,6 +300,7 @@ enum infer_ctxt = @{\n };\n \n enum fixup_err {\n+    unresolved_int_ty(tvi_vid),\n     unresolved_ty(tv_vid),\n     cyclic_ty(tv_vid),\n     unresolved_region(region_vid),\n@@ -273,6 +309,7 @@ enum fixup_err {\n \n fn fixup_err_to_str(f: fixup_err) -> str {\n     alt f {\n+      unresolved_int_ty(_) { \"unconstrained integral type\" }\n       unresolved_ty(_) { \"unconstrained type\" }\n       cyclic_ty(_) { \"cyclic type of infinite size\" }\n       unresolved_region(_) { \"unconstrained region\" }\n@@ -410,7 +447,7 @@ impl<V:copy to_str> of to_str for bound<V> {\n     fn to_str(cx: infer_ctxt) -> str {\n         alt self {\n           some(v) { v.to_str(cx) }\n-          none { \"none \" }\n+          none { \"none\" }\n         }\n     }\n }\n@@ -555,7 +592,7 @@ impl methods for infer_ctxt {\n         *self.ty_var_integral_counter += 1u;\n \n         self.tvib.vals.insert(id,\n-                              root(mk_int_ty_set()));\n+                              root(int_ty_set_all()));\n         ret tvi_vid(id);\n     }\n \n@@ -771,9 +808,24 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn vars_integral<V:copy vid>(\n-        _vb: vals_and_bindings<V, int_ty_set>,\n-        _a_id: V, _b_id: V) -> ures {\n-        // FIXME (#1425): do something real here.\n+        vb: vals_and_bindings<V, int_ty_set>,\n+        a_id: V, b_id: V) -> ures {\n+\n+        let {root: a_id, possible_types: a_pt} = self.get(vb, a_id);\n+        let {root: b_id, possible_types: b_pt} = self.get(vb, b_id);\n+\n+        // If we're already dealing with the same two variables,\n+        // there's nothing to do.\n+        if a_id == b_id { ret uok(); }\n+\n+        // Otherwise, take the intersection of the two sets of\n+        // possible types.\n+        let intersection = intersection(a_pt, b_pt);\n+        if *intersection == INT_TY_SET_EMPTY {\n+            ret err(ty::terr_no_integral_type);\n+        }\n+        self.set(vb, a_id, root(intersection));\n+        self.set(vb, b_id, redirect(a_id));\n         uok()\n     }\n \n@@ -789,11 +841,21 @@ impl unify_methods for infer_ctxt {\n         self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds)\n     }\n \n-    // FIXME (#1425): this is a terrible name.\n-    fn vart_integral<V: copy vid, T: copy to_str st>(\n-        _vb: vals_and_bindings<V, int_ty_set>,\n-        _a_id: V, _b: T) -> ures {\n-        // FIXME (#1425): do something real here.\n+    fn vart_integral<V: copy vid>(\n+        vb: vals_and_bindings<V, int_ty_set>,\n+        a_id: V, b: ty::t) -> ures {\n+\n+        assert ty::type_is_integral(b);\n+\n+        let {root: a_id, possible_types: a_pt} = self.get(vb, a_id);\n+\n+        let intersection =\n+            intersection(a_pt, convert_integral_ty_to_int_ty_set(\n+                self.tcx, b));\n+        if *intersection == INT_TY_SET_EMPTY {\n+            ret err(ty::terr_no_integral_type);\n+        }\n+        self.set(vb, a_id, root(intersection));\n         uok()\n     }\n \n@@ -809,10 +871,21 @@ impl unify_methods for infer_ctxt {\n         self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds)\n     }\n \n-    fn tvar_integral<V: copy vid, T: copy to_str st>(\n-        _vb: vals_and_bindings<V, int_ty_set>,\n-        _a: T, _b_id: V) -> ures {\n-        // FIXME (#1425): do something real here.\n+    fn tvar_integral<V: copy vid>(\n+        vb: vals_and_bindings<V, int_ty_set>,\n+        a: ty::t, b_id: V) -> ures {\n+\n+        assert ty::type_is_integral(a);\n+\n+        let {root: b_id, possible_types: b_pt} = self.get(vb, b_id);\n+\n+        let intersection =\n+            intersection(b_pt, convert_integral_ty_to_int_ty_set(\n+                self.tcx, a));\n+        if *intersection == INT_TY_SET_EMPTY {\n+            ret err(ty::terr_no_integral_type);\n+        }\n+        self.set(vb, b_id, root(intersection));\n         uok()\n     }\n \n@@ -1066,13 +1139,26 @@ impl methods for resolve_state {\n     }\n \n     fn resolve_ty_var_integral(vid: tvi_vid) -> ty::t {\n-        let {root:_, possible_types: its} =\n+        let {root:_, possible_types: pt} =\n             self.infcx.get(self.infcx.tvib, vid);\n-        let t1 = alt its {\n-          // FIXME (#1425): do something real here.\n-          int_ty_set(_) { ty::mk_int(self.infcx.tcx) }\n-        };\n-        ret t1;\n+        // If there's only one type in the set of possible types, then\n+        // that's the answer.\n+        alt single_type_contained_in(self.infcx.tcx, pt) {\n+          some(t) { t }\n+          none {\n+            if self.force_vars {\n+                // As a last resort, default to int.\n+                let ty = ty::mk_int(self.infcx.tcx);\n+                self.infcx.set(\n+                    self.infcx.tvib, vid,\n+                    root(convert_integral_ty_to_int_ty_set(self.infcx.tcx,\n+                                                           ty)));\n+                ty\n+            } else {\n+                ty::mk_var_integral(self.infcx.tcx, vid)\n+            }\n+          }\n+        }\n     }\n \n }\n@@ -1324,7 +1410,6 @@ iface combine {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]>;\n     fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>>;\n     fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs>;\n@@ -1516,12 +1601,6 @@ fn super_fns<C:combine>(\n     }\n }\n \n-fn super_int_tys<C:combine>(\n-    self: C, _a: ty::t, _b: ty::t) -> cres<ty::t> {\n-    // FIXME (#1425): do something real here?\n-    ok(ty::mk_int(self.infcx().tcx))\n-}\n-\n fn super_tys<C:combine>(\n     self: C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n@@ -1539,6 +1618,20 @@ fn super_tys<C:combine>(\n                  b.to_str(self.infcx())]);\n       }\n \n+      // Have to handle these first\n+      (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) {\n+        self.infcx().vars_integral(self.infcx().tvib, a_id, b_id).then {||\n+            ok(a) }\n+      }\n+      (ty::ty_var_integral(a_id), _) {\n+        self.infcx().vart_integral(self.infcx().tvib, a_id, b).then {||\n+            ok(a) }\n+      }\n+      (_, ty::ty_var_integral(b_id)) {\n+        self.infcx().tvar_integral(self.infcx().tvib, a, b_id).then {||\n+            ok(a) }\n+      }\n+\n       (ty::ty_int(_), _) |\n       (ty::ty_uint(_), _) |\n       (ty::ty_float(_), _) {\n@@ -1787,21 +1880,6 @@ impl of combine for sub {\n               (_, ty::ty_bot) {\n                 err(ty::terr_sorts(b, a))\n               }\n-\n-              // FIXME (#1425): I'm not sure if these three cases\n-              // belong here or if they belong in super_tys.\n-              (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) {\n-                self.infcx().vars_integral(self.tvib, a_id, b_id).then {||\n-                    ok(a) }\n-              }\n-              (ty::ty_var_integral(a_id), _) {\n-                self.infcx().vart_integral(self.tvib, a_id, b).then {||\n-                    ok(a) }\n-              }\n-              (_, ty::ty_var_integral(b_id)) {\n-                self.infcx().tvar_integral(self.tvib, a, b_id).then {||\n-                    ok(a) }\n-              }\n               _ {\n                 super_tys(self, a, b)\n               }\n@@ -1847,10 +1925,6 @@ impl of combine for sub {\n \n     // Traits please:\n \n-    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_int_tys(self, a, b)\n-    }\n-\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n         super_flds(self, a, b)\n     }\n@@ -2029,10 +2103,6 @@ impl of combine for lub {\n \n     // Traits please:\n \n-    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_int_tys(self, a, b)\n-    }\n-\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n         lattice_tys(self, a, b)\n     }\n@@ -2236,10 +2306,6 @@ impl of combine for glb {\n \n     // Traits please:\n \n-    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_int_tys(self, a, b)\n-    }\n-\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n         super_flds(self, a, b)\n     }\n@@ -2333,21 +2399,6 @@ fn lattice_tys<L:lattice_ops combine>(\n             lattice_var_t(self, self.infcx().tvb, b_id, a,\n                           {|x, y| self.tys(x, y) })\n           }\n-          (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) {\n-            // FIXME (#1425): do something real here?\n-            ok(a)\n-          }\n-\n-          (ty::ty_var_integral(a_id), _) {\n-            // FIXME (#1425): do something real here?\n-            ok(a)\n-          }\n-\n-          (_, ty::ty_var_integral(b_id)) {\n-            // FIXME (#1425): do something real here?\n-            ok(a)\n-          }\n-\n           _ {\n             super_tys(self, a, b)\n           }"}]}