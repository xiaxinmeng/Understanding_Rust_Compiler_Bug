{"sha": "c67497a5da33eb3167a33e938920ce04d2b883a5", "node_id": "C_kwDOAAsO6NoAKGM2NzQ5N2E1ZGEzM2ViMzE2N2EzM2U5Mzg5MjBjZTA0ZDJiODgzYTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-07T08:12:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-07T08:12:47Z"}, "message": "Auto merge of #85013 - Mark-Simulacrum:dominators-bitset, r=pnkfelix\n\nReplace dominators algorithm with simple Lengauer-Tarjan\n\nThis PR replaces our dominators implementation with that of the simple Lengauer-Tarjan algorithm, which is (to my knowledge and research) the currently accepted 'best' algorithm. The more complex variant has higher constant time overheads, and Semi-NCA (which is arguably a variant of Lengauer-Tarjan too) is not the preferred variant by the first paper cited in the documentation comments: simple Lengauer-Tarjan \"is less sensitive to pathological instances, we think it should be preferred where performance guarantees are important\" - which they are for us.\n\nThis work originally arose from noting that the keccak benchmark spent a considerable portion of its time (both instructions and cycles) in the dominator computations, which sparked an interest in potentially optimizing that code. The current algorithm largely proves slow on long \"parallel\" chains where the nearest common ancestor lookup (i.e., the intersect function) does not quickly identify a root; it is also inherently a pointer-chasing algorithm so is relatively slow on modern CPUs due to needing to hit memory - though usually in cache - in a tight loop, which still costs several cycles.\n\nThis was replaced with a bitset-based algorithm, previously studied in literature but implemented directly from dataflow equations in our case, which proved to be a significant speed up on the keccak benchmark: 20% instruction count wins, as can be seen in [this performance report](https://perf.rust-lang.org/compare.html?start=377d1a984cd2a53327092b90aa1d8b7e22d1e347&end=542da47ff78aa462384062229dad0675792f2638). This algorithm is also relatively simple in comparison to other algorithms and is easy to understand. However, these performance results showed a regression on a number of other benchmarks, and I was unable to get the bitsets to perform well enough that those regressions could be fully mitigated. The implementation \"attempt\" is seen here in the first commit, and is intended to be kept primarily so that future optimizers do not repeat that path (or can easily refer to the attempt).\n\nThe final version of this PR chooses the simple Lengauer-Tarjan algorithm, and implements it along with a number of optimizations found in literature. The current implementation is a slight improvement for many benchmarks, with keccak still being an outlier at ~20%. The implementation in this PR first implements the most basic variant of the algorithm directly from the pseudocode on page 16, physical, or 28 in the PDF of the first paper (\"Linear-Time Algorithms for Dominators and Related Problems\"). This is then followed by a number of commits which update the implementation to apply various performance improvements, as suggested by the paper. Finally, the last commit annotates the implementation with a number of comments, mostly drawn from the paper, which intend to help readers understand what is going on - these are incomplete without the paper, but writing them certainly helped my understanding. They may be helpful if future optimization attempts are attempted, so I chose to add them in.", "tree": {"sha": "b407dd930b24a6554066bb7d8a1082ce222a45c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b407dd930b24a6554066bb7d8a1082ce222a45c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c67497a5da33eb3167a33e938920ce04d2b883a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c67497a5da33eb3167a33e938920ce04d2b883a5", "html_url": "https://github.com/rust-lang/rust/commit/c67497a5da33eb3167a33e938920ce04d2b883a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c67497a5da33eb3167a33e938920ce04d2b883a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af5c6562deed1878000e791f2cb21b981a53959", "url": "https://api.github.com/repos/rust-lang/rust/commits/2af5c6562deed1878000e791f2cb21b981a53959", "html_url": "https://github.com/rust-lang/rust/commit/2af5c6562deed1878000e791f2cb21b981a53959"}, {"sha": "15483ccf9d0a0befb472e4dd3a1bfba754a1cd11", "url": "https://api.github.com/repos/rust-lang/rust/commits/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11", "html_url": "https://github.com/rust-lang/rust/commit/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11"}], "stats": {"total": 286, "additions": 235, "deletions": 51}, "files": [{"sha": "0d2ae115cb0d29d3bf561f22f35e9314fc3a440d", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 224, "deletions": 51, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/c67497a5da33eb3167a33e938920ce04d2b883a5/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67497a5da33eb3167a33e938920ce04d2b883a5/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=c67497a5da33eb3167a33e938920ce04d2b883a5", "patch": "@@ -1,81 +1,254 @@\n //! Finding the dominators in a control-flow graph.\n //!\n-//! Algorithm based on Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy,\n-//! \"A Simple, Fast Dominance Algorithm\",\n-//! Rice Computer Science TS-06-33870,\n-//! <https://www.cs.rice.edu/~keith/EMBED/dom.pdf>.\n+//! Algorithm based on Loukas Georgiadis,\n+//! \"Linear-Time Algorithms for Dominators and Related Problems\",\n+//! <ftp://ftp.cs.princeton.edu/techreports/2005/737.pdf>\n+//!\n+//! Additionally useful is the original Lengauer-Tarjan paper on this subject,\n+//! \"A Fast Algorithm for Finding Dominators in a Flowgraph\"\n+//! Thomas Lengauer and Robert Endre Tarjan.\n+//! <https://www.cs.princeton.edu/courses/archive/spr03/cs423/download/dominators.pdf>\n \n-use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n use rustc_index::vec::{Idx, IndexVec};\n use std::cmp::Ordering;\n \n #[cfg(test)]\n mod tests;\n \n-pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n-    let start_node = graph.start_node();\n-    let rpo = reverse_post_order(&graph, start_node);\n-    dominators_given_rpo(graph, &rpo)\n+struct PreOrderFrame<Iter> {\n+    pre_order_idx: PreorderIndex,\n+    iter: Iter,\n }\n \n-fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Dominators<G::Node> {\n-    let start_node = graph.start_node();\n-    assert_eq!(rpo[0], start_node);\n+rustc_index::newtype_index! {\n+    struct PreorderIndex { .. }\n+}\n \n+pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     // compute the post order index (rank) for each node\n     let mut post_order_rank = IndexVec::from_elem_n(0, graph.num_nodes());\n-    for (index, node) in rpo.iter().rev().cloned().enumerate() {\n-        post_order_rank[node] = index;\n-    }\n \n-    let mut immediate_dominators = IndexVec::from_elem_n(None, graph.num_nodes());\n-    immediate_dominators[start_node] = Some(start_node);\n-\n-    let mut changed = true;\n-    while changed {\n-        changed = false;\n-\n-        for &node in &rpo[1..] {\n-            let mut new_idom = None;\n-            for pred in graph.predecessors(node) {\n-                if immediate_dominators[pred].is_some() {\n-                    // (*) dominators for `pred` have been calculated\n-                    new_idom = Some(if let Some(new_idom) = new_idom {\n-                        intersect(&post_order_rank, &immediate_dominators, new_idom, pred)\n-                    } else {\n-                        pred\n-                    });\n-                }\n-            }\n+    // We allocate capacity for the full set of nodes, because most of the time\n+    // most of the nodes *are* reachable.\n+    let mut parent: IndexVec<PreorderIndex, PreorderIndex> =\n+        IndexVec::with_capacity(graph.num_nodes());\n+\n+    let mut stack = vec![PreOrderFrame {\n+        pre_order_idx: PreorderIndex::new(0),\n+        iter: graph.successors(graph.start_node()),\n+    }];\n+    let mut pre_order_to_real: IndexVec<PreorderIndex, G::Node> =\n+        IndexVec::with_capacity(graph.num_nodes());\n+    let mut real_to_pre_order: IndexVec<G::Node, Option<PreorderIndex>> =\n+        IndexVec::from_elem_n(None, graph.num_nodes());\n+    pre_order_to_real.push(graph.start_node());\n+    parent.push(PreorderIndex::new(0)); // the parent of the root node is the root for now.\n+    real_to_pre_order[graph.start_node()] = Some(PreorderIndex::new(0));\n+    let mut post_order_idx = 0;\n+\n+    // Traverse the graph, collecting a number of things:\n+    //\n+    // * Preorder mapping (to it, and back to the actual ordering)\n+    // * Postorder mapping (used exclusively for rank_partial_cmp on the final product)\n+    // * Parents for each vertex in the preorder tree\n+    //\n+    // These are all done here rather than through one of the 'standard'\n+    // graph traversals to help make this fast.\n+    'recurse: while let Some(frame) = stack.last_mut() {\n+        while let Some(successor) = frame.iter.next() {\n+            if real_to_pre_order[successor].is_none() {\n+                let pre_order_idx = pre_order_to_real.push(successor);\n+                real_to_pre_order[successor] = Some(pre_order_idx);\n+                parent.push(frame.pre_order_idx);\n+                stack.push(PreOrderFrame { pre_order_idx, iter: graph.successors(successor) });\n \n-            if new_idom != immediate_dominators[node] {\n-                immediate_dominators[node] = new_idom;\n-                changed = true;\n+                continue 'recurse;\n             }\n         }\n+        post_order_rank[pre_order_to_real[frame.pre_order_idx]] = post_order_idx;\n+        post_order_idx += 1;\n+\n+        stack.pop();\n     }\n \n-    Dominators { post_order_rank, immediate_dominators }\n-}\n+    let reachable_vertices = pre_order_to_real.len();\n+\n+    let mut idom = IndexVec::from_elem_n(PreorderIndex::new(0), reachable_vertices);\n+    let mut semi = IndexVec::from_fn_n(std::convert::identity, reachable_vertices);\n+    let mut label = semi.clone();\n+    let mut bucket = IndexVec::from_elem_n(vec![], reachable_vertices);\n+    let mut lastlinked = None;\n+\n+    // We loop over vertices in reverse preorder. This implements the pseudocode\n+    // of the simple Lengauer-Tarjan algorithm. A few key facts are noted here\n+    // which are helpful for understanding the code (full proofs and such are\n+    // found in various papers, including one cited at the top of this file).\n+    //\n+    // For each vertex w (which is not the root),\n+    //  * semi[w] is a proper ancestor of the vertex w (i.e., semi[w] != w)\n+    //  * idom[w] is an ancestor of semi[w] (i.e., idom[w] may equal semi[w])\n+    //\n+    // An immediate dominator of w (idom[w]) is a vertex v where v dominates w\n+    // and every other dominator of w dominates v. (Every vertex except the root has\n+    // a unique immediate dominator.)\n+    //\n+    // A semidominator for a given vertex w (semi[w]) is the vertex v with minimum\n+    // preorder number such that there exists a path from v to w in which all elements (other than w) have\n+    // preorder numbers greater than w (i.e., this path is not the tree path to\n+    // w).\n+    for w in (PreorderIndex::new(1)..PreorderIndex::new(reachable_vertices)).rev() {\n+        // Optimization: process buckets just once, at the start of the\n+        // iteration. Do not explicitly empty the bucket (even though it will\n+        // not be used again), to save some instructions.\n+        //\n+        // The bucket here contains the vertices whose semidominator is the\n+        // vertex w, which we are guaranteed to have found: all vertices who can\n+        // be semidominated by w must have a preorder number exceeding w, so\n+        // they have been placed in the bucket.\n+        //\n+        // We compute a partial set of immediate dominators here.\n+        let z = parent[w];\n+        for &v in bucket[z].iter() {\n+            // This uses the result of Lemma 5 from section 2 from the original\n+            // 1979 paper, to compute either the immediate or relative dominator\n+            // for a given vertex v.\n+            //\n+            // eval returns a vertex y, for which semi[y] is minimum among\n+            // vertices semi[v] +> y *> v. Note that semi[v] = z as we're in the\n+            // z bucket.\n+            //\n+            // Given such a vertex y, semi[y] <= semi[v] and idom[y] = idom[v].\n+            // If semi[y] = semi[v], though, idom[v] = semi[v].\n+            //\n+            // Using this, we can either set idom[v] to be:\n+            //  * semi[v] (i.e. z), if semi[y] is z\n+            //  * idom[y], otherwise\n+            //\n+            // We don't directly set to idom[y] though as it's not necessarily\n+            // known yet. The second preorder traversal will cleanup by updating\n+            // the idom for any that were missed in this pass.\n+            let y = eval(&mut parent, lastlinked, &semi, &mut label, v);\n+            idom[v] = if semi[y] < z { y } else { z };\n+        }\n+\n+        // This loop computes the semi[w] for w.\n+        semi[w] = w;\n+        for v in graph.predecessors(pre_order_to_real[w]) {\n+            let v = real_to_pre_order[v].unwrap();\n+\n+            // eval returns a vertex x from which semi[x] is minimum among\n+            // vertices semi[v] +> x *> v.\n+            //\n+            // From Lemma 4 from section 2, we know that the semidominator of a\n+            // vertex w is the minimum (by preorder number) vertex of the\n+            // following:\n+            //\n+            //  * direct predecessors of w with preorder number less than w\n+            //  * semidominators of u such that u > w and there exists (v, w)\n+            //    such that u *> v\n+            //\n+            // This loop therefore identifies such a minima. Note that any\n+            // semidominator path to w must have all but the first vertex go\n+            // through vertices numbered greater than w, so the reverse preorder\n+            // traversal we are using guarantees that all of the information we\n+            // might need is available at this point.\n+            //\n+            // The eval call will give us semi[x], which is either:\n+            //\n+            //  * v itself, if v has not yet been processed\n+            //  * A possible 'best' semidominator for w.\n+            let x = eval(&mut parent, lastlinked, &semi, &mut label, v);\n+            semi[w] = std::cmp::min(semi[w], semi[x]);\n+        }\n+        // semi[w] is now semidominator(w) and won't change any more.\n \n-fn intersect<Node: Idx>(\n-    post_order_rank: &IndexVec<Node, usize>,\n-    immediate_dominators: &IndexVec<Node, Option<Node>>,\n-    mut node1: Node,\n-    mut node2: Node,\n-) -> Node {\n-    while node1 != node2 {\n-        while post_order_rank[node1] < post_order_rank[node2] {\n-            node1 = immediate_dominators[node1].unwrap();\n+        // Optimization: Do not insert into buckets if parent[w] = semi[w], as\n+        // we then immediately know the idom.\n+        //\n+        // If we don't yet know the idom directly, then push this vertex into\n+        // our semidominator's bucket, where it will get processed at a later\n+        // stage to compute its immediate dominator.\n+        if parent[w] != semi[w] {\n+            bucket[semi[w]].push(w);\n+        } else {\n+            idom[w] = parent[w];\n         }\n \n-        while post_order_rank[node2] < post_order_rank[node1] {\n-            node2 = immediate_dominators[node2].unwrap();\n+        // Optimization: We share the parent array between processed and not\n+        // processed elements; lastlinked represents the divider.\n+        lastlinked = Some(w);\n+    }\n+\n+    // Finalize the idoms for any that were not fully settable during initial\n+    // traversal.\n+    //\n+    // If idom[w] != semi[w] then we know that we've stored vertex y from above\n+    // into idom[w]. It is known to be our 'relative dominator', which means\n+    // that it's one of w's ancestors and has the same immediate dominator as w,\n+    // so use that idom.\n+    for w in PreorderIndex::new(1)..PreorderIndex::new(reachable_vertices) {\n+        if idom[w] != semi[w] {\n+            idom[w] = idom[idom[w]];\n         }\n     }\n \n-    node1\n+    let mut immediate_dominators = IndexVec::from_elem_n(None, graph.num_nodes());\n+    for (idx, node) in pre_order_to_real.iter_enumerated() {\n+        immediate_dominators[*node] = Some(pre_order_to_real[idom[idx]]);\n+    }\n+\n+    Dominators { post_order_rank, immediate_dominators }\n+}\n+\n+/// Evaluate the link-eval virtual forest, providing the currently minimum semi\n+/// value for the passed `node` (which may be itself).\n+///\n+/// This maintains that for every vertex v, `label[v]` is such that:\n+///\n+/// ```text\n+/// semi[eval(v)] = min { semi[label[u]] | root_in_forest(v) +> u *> v }\n+/// ```\n+///\n+/// where `+>` is a proper ancestor and `*>` is just an ancestor.\n+#[inline]\n+fn eval(\n+    ancestor: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    lastlinked: Option<PreorderIndex>,\n+    semi: &IndexVec<PreorderIndex, PreorderIndex>,\n+    label: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    node: PreorderIndex,\n+) -> PreorderIndex {\n+    if is_processed(node, lastlinked) {\n+        compress(ancestor, lastlinked, semi, label, node);\n+        label[node]\n+    } else {\n+        node\n+    }\n+}\n+\n+#[inline]\n+fn is_processed(v: PreorderIndex, lastlinked: Option<PreorderIndex>) -> bool {\n+    if let Some(ll) = lastlinked { v >= ll } else { false }\n+}\n+\n+#[inline]\n+fn compress(\n+    ancestor: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    lastlinked: Option<PreorderIndex>,\n+    semi: &IndexVec<PreorderIndex, PreorderIndex>,\n+    label: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    v: PreorderIndex,\n+) {\n+    assert!(is_processed(v, lastlinked));\n+    let u = ancestor[v];\n+    if is_processed(u, lastlinked) {\n+        compress(ancestor, lastlinked, semi, label, u);\n+        if semi[label[u]] < semi[label[v]] {\n+            label[v] = label[u];\n+        }\n+        ancestor[v] = ancestor[u];\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "ff31d8f7fdcf6d5148c01a219464e6a0bb4fe22d", "filename": "compiler/rustc_data_structures/src/graph/dominators/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c67497a5da33eb3167a33e938920ce04d2b883a5/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67497a5da33eb3167a33e938920ce04d2b883a5/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs?ref=c67497a5da33eb3167a33e938920ce04d2b883a5", "patch": "@@ -32,3 +32,14 @@ fn paper() {\n     assert_eq!(immediate_dominators[5], Some(6));\n     assert_eq!(immediate_dominators[6], Some(6));\n }\n+\n+#[test]\n+fn paper_slt() {\n+    // example from the paper:\n+    let graph = TestGraph::new(\n+        1,\n+        &[(1, 2), (1, 3), (2, 3), (2, 7), (3, 4), (3, 6), (4, 5), (5, 4), (6, 7), (7, 8), (8, 5)],\n+    );\n+\n+    dominators(&graph);\n+}"}]}