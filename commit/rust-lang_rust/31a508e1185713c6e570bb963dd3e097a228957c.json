{"sha": "31a508e1185713c6e570bb963dd3e097a228957c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYTUwOGUxMTg1NzEzYzZlNTcwYmI5NjNkZDNlMDk3YTIyODk1N2M=", "commit": {"author": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2016-11-08T11:15:02Z"}, "committer": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2016-11-08T12:33:56Z"}, "message": "Allow proc_macro functions to whitelist specific attributes\n\nBy using a second attribute `attributes(Bar)` on\nproc_macro_derive, whitelist any attributes with\nthe name `Bar` in the deriving item. This allows\na proc_macro function to use custom attribtues\nwithout a custom attribute error or unused attribute\nlint.", "tree": {"sha": "8f4e844613e956fc6d90b391b89b459e4bdc85c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f4e844613e956fc6d90b391b89b459e4bdc85c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31a508e1185713c6e570bb963dd3e097a228957c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31a508e1185713c6e570bb963dd3e097a228957c", "html_url": "https://github.com/rust-lang/rust/commit/31a508e1185713c6e570bb963dd3e097a228957c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31a508e1185713c6e570bb963dd3e097a228957c/comments", "author": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "committer": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d377cf5b3fbaae4baa67b4f29a952b565ef1a814", "url": "https://api.github.com/repos/rust-lang/rust/commits/d377cf5b3fbaae4baa67b4f29a952b565ef1a814", "html_url": "https://github.com/rust-lang/rust/commit/d377cf5b3fbaae4baa67b4f29a952b565ef1a814"}], "stats": {"total": 306, "additions": 260, "deletions": 46}, "files": [{"sha": "5ee9fecfb21b3ce0d9b70aead5a85a72da01c546", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -95,7 +95,8 @@ pub mod __internal {\n     pub trait Registry {\n         fn register_custom_derive(&mut self,\n                                   trait_name: &str,\n-                                  expand: fn(TokenStream) -> TokenStream);\n+                                  expand: fn(TokenStream) -> TokenStream,\n+                                  attributes: &[&'static str]);\n     }\n \n     // Emulate scoped_thread_local!() here essentially"}, {"sha": "2f2b7d9188a4a84771b0ee98fe2ee25aca4991c2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -624,8 +624,12 @@ impl<'a> CrateLoader<'a> {\n         impl Registry for MyRegistrar {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n-                                      expand: fn(TokenStream) -> TokenStream) {\n-                let derive = SyntaxExtension::CustomDerive(Box::new(CustomDerive::new(expand)));\n+                                      expand: fn(TokenStream) -> TokenStream,\n+                                      attributes: &[&'static str]) {\n+                let attrs = attributes.iter().map(|s| InternedString::new(s)).collect();\n+                let derive = SyntaxExtension::CustomDerive(\n+                    Box::new(CustomDerive::new(expand, attrs))\n+                );\n                 self.0.push((intern(trait_name), derive));\n             }\n         }"}, {"sha": "2b80deded0aa8c32ed53f57e103ef995ab5fde31", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -12,20 +12,37 @@ use std::panic;\n \n use errors::FatalError;\n use proc_macro::{TokenStream, __internal};\n-use syntax::ast::{self, ItemKind};\n+use syntax::ast::{self, ItemKind, Attribute};\n+use syntax::attr::{mark_used, mark_known};\n use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan, Span};\n use syntax::ext::base::*;\n use syntax::fold::Folder;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token::intern;\n use syntax::print::pprust;\n+use syntax::visit::Visitor;\n+\n+struct MarkAttrs<'a>(&'a [InternedString]);\n+\n+impl<'a> Visitor for MarkAttrs<'a> {\n+    fn visit_attribute(&mut self, attr: &Attribute) {\n+        if self.0.contains(&attr.name()) {\n+            mark_used(attr);\n+            mark_known(attr);\n+        }\n+    }\n+}\n \n pub struct CustomDerive {\n     inner: fn(TokenStream) -> TokenStream,\n+    attrs: Vec<InternedString>,\n }\n \n impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream) -> CustomDerive {\n-        CustomDerive { inner: inner }\n+    pub fn new(inner: fn(TokenStream) -> TokenStream,\n+               attrs: Vec<InternedString>)\n+               -> CustomDerive {\n+        CustomDerive { inner: inner, attrs: attrs }\n     }\n }\n \n@@ -47,14 +64,17 @@ impl MultiItemModifier for CustomDerive {\n         };\n         match item.node {\n             ItemKind::Struct(..) |\n-            ItemKind::Enum(..) => {}\n+            ItemKind::Enum(..) => {},\n             _ => {\n                 ecx.span_err(span, \"custom derive attributes may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n         }\n \n+        // Mark attributes as known, and used.\n+        MarkAttrs(&self.attrs).visit_item(&item);\n+\n         let input_span = Span {\n             expn_id: ecx.codemap().record_expansion(ExpnInfo {\n                 call_site: span,\n@@ -66,12 +86,13 @@ impl MultiItemModifier for CustomDerive {\n             }),\n             ..item.span\n         };\n-        let input = __internal::new_token_stream(item);\n+\n+        let input = __internal::new_token_stream(item.clone());\n         let res = __internal::set_parse_sess(&ecx.parse_sess, || {\n             let inner = self.inner;\n             panic::catch_unwind(panic::AssertUnwindSafe(|| inner(input)))\n         });\n-        let item = match res {\n+        let new_items = match res {\n             Ok(stream) => __internal::token_stream_items(stream),\n             Err(e) => {\n                 let msg = \"custom derive attribute panicked\";\n@@ -88,12 +109,13 @@ impl MultiItemModifier for CustomDerive {\n             }\n         };\n \n-        // Right now we have no knowledge of spans at all in custom derive\n-        // macros, everything is just parsed as a string. Reassign all spans to\n-        // the input `item` for better errors here.\n-        item.into_iter().flat_map(|item| {\n+        let mut res = vec![Annotatable::Item(item)];\n+        // Reassign spans of all expanded items to the input `item`\n+        // for better errors here.\n+        res.extend(new_items.into_iter().flat_map(|item| {\n             ChangeSpan { span: input_span }.fold_item(item)\n-        }).map(Annotatable::Item).collect()\n+        }).map(Annotatable::Item));\n+        res\n     }\n }\n "}, {"sha": "5996ba70b190bbeab249aa83a81ad520c929fa18", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 52, "deletions": 15, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -30,6 +30,7 @@ struct CustomDerive {\n     trait_name: InternedString,\n     function_name: Ident,\n     span: Span,\n+    attrs: Vec<InternedString>,\n }\n \n struct CollectCustomDerives<'a> {\n@@ -133,7 +134,8 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n         }\n \n         // Once we've located the `#[proc_macro_derive]` attribute, verify\n-        // that it's of the form `#[proc_macro_derive(Foo)]`\n+        // that it's of the form `#[proc_macro_derive(Foo)]` or\n+        // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n         let list = match attr.meta_item_list() {\n             Some(list) => list,\n             None => {\n@@ -143,38 +145,69 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n                 return\n             }\n         };\n-        if list.len() != 1 {\n+        if list.len() != 1 && list.len() != 2 {\n             self.handler.span_err(attr.span(),\n-                                  \"attribute must only have one argument\");\n+                                  \"attribute must have either one or two arguments\");\n             return\n         }\n-        let attr = &list[0];\n-        let trait_name = match attr.name() {\n+        let trait_attr = &list[0];\n+        let attributes_attr = list.get(1);\n+        let trait_name = match trait_attr.name() {\n             Some(name) => name,\n             _ => {\n-                self.handler.span_err(attr.span(), \"not a meta item\");\n+                self.handler.span_err(trait_attr.span(), \"not a meta item\");\n                 return\n             }\n         };\n-        if !attr.is_word() {\n-            self.handler.span_err(attr.span(), \"must only be one word\");\n+        if !trait_attr.is_word() {\n+            self.handler.span_err(trait_attr.span(), \"must only be one word\");\n         }\n \n         if deriving::is_builtin_trait(&trait_name) {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(trait_attr.span(),\n                                   \"cannot override a built-in #[derive] mode\");\n         }\n \n         if self.derives.iter().any(|d| d.trait_name == trait_name) {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(trait_attr.span(),\n                                   \"derive mode defined twice in this crate\");\n         }\n \n+        let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n+            if !attr.check_name(\"attributes\") {\n+                self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n+            }\n+            attr.meta_item_list().unwrap_or_else(|| {\n+                self.handler.span_err(attr.span(),\n+                                      \"attribute must be of form: \\\n+                                       `attributes(foo, bar)`\");\n+                &[]\n+            }).into_iter().filter_map(|attr| {\n+                let name = match attr.name() {\n+                    Some(name) => name,\n+                    _ => {\n+                        self.handler.span_err(attr.span(), \"not a meta item\");\n+                        return None;\n+                    },\n+                };\n+\n+                if !attr.is_word() {\n+                    self.handler.span_err(attr.span(), \"must only be one word\");\n+                    return None;\n+                }\n+\n+                Some(name)\n+            }).collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n         if self.in_root {\n             self.derives.push(CustomDerive {\n                 span: item.span,\n                 trait_name: trait_name,\n                 function_name: item.ident,\n+                attrs: proc_attrs,\n             });\n         } else {\n             let msg = \"functions tagged with `#[proc_macro_derive]` must \\\n@@ -208,8 +241,8 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n //\n //          #[plugin_registrar]\n //          fn registrar(registrar: &mut Registry) {\n-//              registrar.register_custom_derive($name_trait1, ::$name1);\n-//              registrar.register_custom_derive($name_trait2, ::$name2);\n+//              registrar.register_custom_derive($name_trait1, ::$name1, &[]);\n+//              registrar.register_custom_derive($name_trait2, ::$name2, &[\"attribute_name\"]);\n //              // ...\n //          }\n //      }\n@@ -238,14 +271,18 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n         let trait_name = cx.expr_str(cd.span, cd.trait_name.clone());\n-        (path, trait_name)\n-    }).map(|(path, trait_name)| {\n+        let attrs = cx.expr_vec_slice(\n+            span,\n+            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.clone())).collect::<Vec<_>>()\n+        );\n+        (path, trait_name, attrs)\n+    }).map(|(path, trait_name, attrs)| {\n         let registrar = cx.expr_ident(span, registrar);\n         let ufcs_path = cx.path(span, vec![proc_macro, __internal, registry,\n                                            register_custom_derive]);\n         cx.expr_call(span,\n                      cx.expr_path(ufcs_path),\n-                     vec![registrar, trait_name, cx.expr_path(path)])\n+                     vec![registrar, trait_name, cx.expr_path(path), attrs])\n     }).map(|expr| {\n         cx.stmt_expr(expr)\n     }).collect::<Vec<_>>();"}, {"sha": "e22339694f9b002b910a138a6ce500e521229991", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -33,8 +33,8 @@ pub fn foo3(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n \n-#[proc_macro_derive(b, c)]\n-//~^ ERROR: attribute must only have one argument\n+#[proc_macro_derive(b, c, d)]\n+//~^ ERROR: attribute must have either one or two arguments\n pub fn foo4(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n@@ -44,3 +44,21 @@ pub fn foo4(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n pub fn foo5(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n+\n+#[proc_macro_derive(f, attributes(g = \"h\"))]\n+//~^ ERROR: must only be one word\n+pub fn foo6(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(i, attributes(j(k)))]\n+//~^ ERROR: must only be one word\n+pub fn foo7(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(l, attributes(m), n)]\n+//~^ ERROR: attribute must have either one or two arguments\n+pub fn foo8(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}"}, {"sha": "70b778b1030e7eb21228e345452b8a0a38718f9a", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![feature(proc_macro_lib)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(B, attributes(B))]\n+pub fn derive_b(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "2a68accf91f714ca5b824bde2e339382f5578632", "filename": "src/test/compile-fail-fulldeps/proc-macro/item-error.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+\n+#![feature(proc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(B)]\n+struct A {\n+    a: &u64\n+//~^ ERROR: missing lifetime specifier\n+}\n+\n+fn main() {\n+}"}, {"sha": "651a277d4abd5eab31d98efce63c2ec8282046b2", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-attributes.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+\n+#![feature(proc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(B)]\n+#[B]\n+#[C] //~ ERROR: The attribute `C` is currently unknown to the compiler\n+#[B(D)]\n+#[B(E = \"foo\")]\n+struct B;\n+\n+fn main() {}"}, {"sha": "1d34049db249fa74ef531728ef38a0712bfbf604", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/add-impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -21,13 +21,12 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AddImpl)]\n // #[cfg(proc_macro)]\n pub fn derive(input: TokenStream) -> TokenStream {\n-    (input.to_string() + \"\n-        impl B {\n+    \"impl B {\n             fn foo(&self) {}\n         }\n \n         fn foo() {}\n \n         mod bar { pub fn foo() {} }\n-    \").parse().unwrap()\n+    \".parse().unwrap()\n }"}, {"sha": "7260bc4a5e7bb275b72059598f2c2ba56f56f954", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/append-impl.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -21,11 +21,8 @@ use proc_macro::TokenStream;\n \n #[proc_macro_derive(Append)]\n pub fn derive_a(input: TokenStream) -> TokenStream {\n-    let mut input = input.to_string();\n-    input.push_str(\"\n-        impl Append for A {\n-            fn foo(&self) {}\n-        }\n-    \");\n-    input.parse().unwrap()\n+    \"impl Append for A {\n+         fn foo(&self) {}\n+     }\n+    \".parse().unwrap()\n }"}, {"sha": "eaada5542274c148ac528e51b6ab56ca7c75dcd2", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -23,5 +23,5 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n     assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n-    \"#[derive(Debug, PartialEq, Eq, Copy, Clone)] struct A;\".parse().unwrap()\n+    \"\".parse().unwrap()\n }"}, {"sha": "a02b798c8023e3b21bd58b2d15861664c693d685", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+#![feature(proc_macro_lib)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(B, attributes(B, C))]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+    assert!(input.contains(\"#[B]\"));\n+    assert!(input.contains(\"struct B {\"));\n+    assert!(input.contains(\"#[C]\"));\n+    assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n+    \"\".parse().unwrap()\n+}"}, {"sha": "bc8a0d575913b083a695b0a13fe4d11263c8dcd0", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -21,7 +21,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive1(input: TokenStream) -> TokenStream {\n     println!(\"input1: {:?}\", input.to_string());\n-    assert_eq!(input.to_string(), \"#[derive(BToC)]\\nstruct A;\\n\");\n+    assert_eq!(input.to_string(), \"struct A;\\n\");\n     \"#[derive(BToC)] struct B;\".parse().unwrap()\n }\n "}, {"sha": "50eaf035962f13acdf8090a0fc1e7e250afb1401", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/expand-with-a-macro.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -24,8 +24,6 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n     r#\"\n-        struct A;\n-\n         impl A {\n             fn a(&self) {\n                 panic!(\"hello\");"}, {"sha": "f5bb93f012490d32f75fdb55dc68fcca8cf46b54", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-b.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(Debug, PartialEq, B, Eq, Copy, Clone)]\n+#[B]\n+struct B {\n+    #[C]\n+    a: u64\n+}\n+\n+fn main() {\n+    B { a: 3 };\n+    assert_eq!(B { a: 3 }, B { a: 3 });\n+    let b = B { a: 3 };\n+    let _d = b;\n+    let _e = b;\n+}"}, {"sha": "608f86bca576899a7ce06a11419baecb4c67869c", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a508e1185713c6e570bb963dd3e097a228957c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs?ref=31a508e1185713c6e570bb963dd3e097a228957c", "patch": "@@ -15,7 +15,7 @@\n #[macro_use]\n extern crate derive_same_struct;\n \n-#[derive(AToB, BToC)]\n+#[derive(AToB)]\n struct A;\n \n fn main() {"}]}