{"sha": "72bd25de83bc1139829656a1b84a4fc04faa0554", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYmQyNWRlODNiYzExMzk4Mjk2NTZhMWI4NGE0ZmMwNGZhYTA1NTQ=", "commit": {"author": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-10-21T13:49:49Z"}, "committer": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-10-21T13:49:49Z"}, "message": "Fix merge conflicts", "tree": {"sha": "e504b6fb77e5687a84575cb36924298a6804ee6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e504b6fb77e5687a84575cb36924298a6804ee6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72bd25de83bc1139829656a1b84a4fc04faa0554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72bd25de83bc1139829656a1b84a4fc04faa0554", "html_url": "https://github.com/rust-lang/rust/commit/72bd25de83bc1139829656a1b84a4fc04faa0554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72bd25de83bc1139829656a1b84a4fc04faa0554/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "283a130ddafa01537123b0650f869abc14886911", "url": "https://api.github.com/repos/rust-lang/rust/commits/283a130ddafa01537123b0650f869abc14886911", "html_url": "https://github.com/rust-lang/rust/commit/283a130ddafa01537123b0650f869abc14886911"}, {"sha": "1a42107663b6e12dd8d2a6f4f59305a4381d8316", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a42107663b6e12dd8d2a6f4f59305a4381d8316", "html_url": "https://github.com/rust-lang/rust/commit/1a42107663b6e12dd8d2a6f4f59305a4381d8316"}], "stats": {"total": 228, "additions": 116, "deletions": 112}, "files": [{"sha": "c3d7ae0280c7788de95903e546faf85a9828e65f", "filename": "miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/miri", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -54,7 +54,7 @@ build_sysroot() {\n     # Build once, for the user to see.\n     cargo run $CARGO_BUILD_FLAGS --bin cargo-miri -- miri setup \"$@\"\n     # Call again, to just set env var.\n-    eval $(cargo run $CARGO_BUILD_FLAGS -q --bin cargo-miri -- miri setup --env \"$@\")\n+    export MIRI_SYSROOT=\"$(cargo run $CARGO_BUILD_FLAGS -q --bin cargo-miri -- miri setup --print-sysroot \"$@\")\"\n }\n \n # Prepare and set MIRI_SYSROOT.  Respects `MIRI_TEST_TARGET` and takes into account"}, {"sha": "8e2cace3385016ed9e9b486330e65c35d649f642", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -1 +1 @@\n-fa0f7d0080d8e7e9eb20aa9cbf8013f96c81287f\n+7979016aff545f7b41cc517031026020b340989d"}, {"sha": "b889ce52f386d5c1c65bda34039abc111ad6d980", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -259,6 +259,10 @@ fn setup(ask_user: bool) {\n \n     // First, we need xargo.\n     if xargo_version().map_or(true, |v| v < (0, 3, 16)) {\n+        if std::env::var(\"XARGO\").is_ok() {\n+            // The user manually gave us a xargo binary; don't do anything automatically.\n+            show_error(format!(\"Your xargo is too old; please upgrade to the latest version\"))\n+        }\n         let mut cmd = cargo();\n         cmd.args(&[\"install\", \"xargo\", \"-f\"]);\n         ask_to_run(cmd, ask_user, \"install a recent enough xargo\");\n@@ -310,7 +314,7 @@ path = \"lib.rs\"\n     File::create(dir.join(\"lib.rs\")).unwrap();\n     // Prepare xargo invocation.\n     let target = get_arg_flag_value(\"--target\");\n-    let print_env = !ask_user && has_arg_flag(\"--env\"); // whether we just print the necessary environment variable\n+    let print_sysroot = !ask_user && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n     let mut command = xargo();\n     command.arg(\"build\").arg(\"-q\");\n     command.current_dir(&dir);\n@@ -339,13 +343,9 @@ path = \"lib.rs\"\n     };\n     let sysroot = if is_host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot); // pass the env var to the processes we spawn, which will turn it into \"--sysroot\" flags\n-    if print_env {\n-        // Escape an arbitrary string for the shell: by wrapping it in `'`, the only special\n-        // character we have to worry about is `'` itself. Everything else is taken literally\n-        // in these strings. `'` is encoded as `'\"'\"'`: the outer `'` end and being a\n-        // `'`-quoted string, respectively; the `\"'\"` in the middle represents a single `'`.\n-        // (We could use `'\\''` instead of `'\"'\"'` if we wanted but let's avoid backslashes.)\n-        println!(\"MIRI_SYSROOT='{}'\", sysroot.display().to_string().replace('\\'', r#\"'\"'\"'\"#));\n+    if print_sysroot {\n+        // Print just the sysroot and nothing else; this way we do not need any escaping.\n+        println!(\"{}\", sysroot.display());\n     } else if !ask_user {\n         println!(\"A libstd for Miri is now available in `{}`.\", sysroot.display());\n     }"}, {"sha": "f4a8d176172d47908e0734a98c310e937a93c422", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -162,7 +162,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             MiriMemoryKind::Env.into(),\n         );\n         ecx.machine.cmd_line = Some(cmd_ptr);\n-        // Store the UTF-16 string.\n+        // Store the UTF-16 string. We just allocated so we know the bounds are fine.\n         let char_size = Size::from_bytes(2);\n         let cmd_alloc = ecx.memory.get_mut(cmd_ptr.alloc_id)?;\n         let mut cur_ptr = cmd_ptr;\n@@ -177,17 +177,13 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         }\n     }\n \n-    assert!(\n-        args.next().is_none(),\n-        \"start lang item has more arguments than expected\"\n-    );\n+    args.next().expect_none(\"start lang item has more arguments than expected\");\n \n     // Set the last_error to 0\n     let errno_layout = ecx.layout_of(ecx.tcx.types.u32)?;\n     let errno_place = ecx.allocate(errno_layout, MiriMemoryKind::Static.into());\n     ecx.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n-    let errno_ptr = ecx.check_mplace_access(errno_place.into(), Some(Size::from_bits(32)))?;\n-    ecx.machine.last_error = errno_ptr;\n+    ecx.machine.last_error = Some(errno_place);\n \n     Ok(ecx)\n }"}, {"sha": "c82971810c0212cb1f51a9fe5b4b5998903d2945", "filename": "src/helpers.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -95,6 +95,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let this = self.eval_context_mut();\n \n+        // Don't forget the bounds check.\n         let ptr = this.memory.check_ptr_access(\n             ptr,\n             Size::from_bytes(len as u64),\n@@ -346,6 +347,70 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n+    /// Sets the last error variable.\n+    fn set_last_error(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let errno_place = this.machine.last_error.unwrap();\n+        this.write_scalar(scalar, errno_place.into())\n+    }\n+\n+    /// Gets the last error variable.\n+    fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+        let errno_place = this.machine.last_error.unwrap();\n+        this.read_scalar(errno_place.into())?.not_undef()\n+    }\n+\n+    /// Sets the last OS error using a `std::io::Error`. This function tries to produce the most\n+    /// similar OS error from the `std::io::ErrorKind` and sets it as the last OS error.\n+    fn set_last_error_from_io_error(&mut self, e: std::io::Error) -> InterpResult<'tcx> {\n+        use std::io::ErrorKind::*;\n+        let this = self.eval_context_mut();\n+        let target = &this.tcx.tcx.sess.target.target;\n+        let last_error = if target.options.target_family == Some(\"unix\".to_owned()) {\n+            this.eval_libc(match e.kind() {\n+                ConnectionRefused => \"ECONNREFUSED\",\n+                ConnectionReset => \"ECONNRESET\",\n+                PermissionDenied => \"EPERM\",\n+                BrokenPipe => \"EPIPE\",\n+                NotConnected => \"ENOTCONN\",\n+                ConnectionAborted => \"ECONNABORTED\",\n+                AddrNotAvailable => \"EADDRNOTAVAIL\",\n+                AddrInUse => \"EADDRINUSE\",\n+                NotFound => \"ENOENT\",\n+                Interrupted => \"EINTR\",\n+                InvalidInput => \"EINVAL\",\n+                TimedOut => \"ETIMEDOUT\",\n+                AlreadyExists => \"EEXIST\",\n+                WouldBlock => \"EWOULDBLOCK\",\n+                _ => throw_unsup_format!(\"The {} error cannot be transformed into a raw os error\", e)\n+            })?\n+        } else {\n+            // FIXME: we have to implement the windows' equivalent of this.\n+            throw_unsup_format!(\"Setting the last OS error from an io::Error is unsupported for {}.\", target.target_os)\n+        };\n+        this.set_last_error(last_error)\n+    }\n+\n+    /// Helper function that consumes an `std::io::Result<T>` and returns an\n+    /// `InterpResult<'tcx,T>::Ok` instead. In case the result is an error, this function returns\n+    /// `Ok(-1)` and sets the last OS error accordingly.\n+    ///\n+    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n+    /// functions return different integer types (like `read`, that returns an `i64`)\n+    fn try_unwrap_io_result<T: From<i32>>(\n+        &mut self,\n+        result: std::io::Result<T>,\n+    ) -> InterpResult<'tcx, T> {\n+        match result {\n+            Ok(ok) => Ok(ok),\n+            Err(e) => {\n+                self.eval_context_mut().set_last_error_from_io_error(e)?;\n+                Ok((-1).into())\n+            }\n+        }\n+    }\n+\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle.\n     fn read_os_string_from_c_string(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx, OsString> {"}, {"sha": "59acff358678a817cb7065ff77859868b0c481d4", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -1,4 +1,5 @@\n #![feature(rustc_private)]\n+#![feature(option_expect_none, option_unwrap_none)]\n \n #![warn(rust_2018_idioms)]\n #![allow(clippy::cast_lossless)]"}, {"sha": "7904e1cc123b359fbc08603f7325c5abbad80b5d", "filename": "src/machine.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -91,8 +91,8 @@ pub struct Evaluator<'tcx> {\n     pub(crate) argv: Option<Pointer<Tag>>,\n     pub(crate) cmd_line: Option<Pointer<Tag>>,\n \n-    /// Last OS error.\n-    pub(crate) last_error: Option<Pointer<Tag>>,\n+    /// Last OS error location in memory. It is a 32-bit integer.\n+    pub(crate) last_error: Option<MPlaceTy<'tcx, Tag>>,\n \n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n@@ -244,10 +244,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n \n         // No more arguments.\n-        assert!(\n-            args.next().is_none(),\n-            \"`exchange_malloc` lang item has more arguments than expected\"\n-        );\n+        args.next().expect_none(\"`exchange_malloc` lang item has more arguments than expected\");\n         Ok(())\n     }\n "}, {"sha": "979b3b6cfa45186713752af16be6151cc4dafe53", "filename": "src/shims/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -134,7 +134,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let erange = this.eval_libc(\"ERANGE\")?;\n                 this.set_last_error(erange)?;\n             }\n-            Err(e) => this.consume_io_error(e)?,\n+            Err(e) => this.set_last_error_from_io_error(e)?,\n         }\n         Ok(Scalar::ptr_null(&*this.tcx))\n     }\n@@ -149,7 +149,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match env::set_current_dir(path) {\n             Ok(()) => Ok(0),\n             Err(e) => {\n-                this.consume_io_error(e)?;\n+                this.set_last_error_from_io_error(e)?;\n                 Ok(-1)\n             }\n         }"}, {"sha": "1933aee1151dc3b3b4cef7b8a5a610ca1ff55b90", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 8, "deletions": 46, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -50,7 +50,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 .memory\n                 .allocate(Size::from_bytes(size), align, kind.into());\n             if zero_init {\n-                // We just allocated this, the access cannot fail\n+                // We just allocated this, the access is definitely in-bounds.\n                 this.memory\n                     .get_mut(ptr.alloc_id)\n                     .unwrap()\n@@ -227,7 +227,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     Align::from_bytes(align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n                 );\n-                // We just allocated this, the access cannot fail\n+                // We just allocated this, the access is definitely in-bounds.\n                 this.memory\n                     .get_mut(ptr.alloc_id)\n                     .unwrap()\n@@ -349,10 +349,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let arg_dest = this.local_place(arg_local)?;\n                 this.write_scalar(data, arg_dest)?;\n \n-                assert!(\n-                    args.next().is_none(),\n-                    \"__rust_maybe_catch_panic argument has more arguments than expected\"\n-                );\n+                args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n \n                 // We ourselves will return `0`, eventually (because we will not return if we paniced).\n                 this.write_null(dest)?;\n@@ -417,8 +414,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"__errno_location\" | \"__error\" => {\n-                let errno_scalar: Scalar<Tag> = this.machine.last_error.unwrap().into();\n-                this.write_scalar(errno_scalar, dest)?;\n+                let errno_place = this.machine.last_error.unwrap();\n+                this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             \"getenv\" => {\n@@ -643,7 +640,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem.\n             \"pthread_key_create\" => {\n-                let key_ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let key_place = this.deref_operand(args[0])?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n                 let dtor = match this.test_null(this.read_scalar(args[1])?.not_undef()?)? {\n@@ -668,16 +665,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     throw_unsup!(OutOfTls);\n                 }\n \n-                let key_ptr = this\n-                    .memory\n-                    .check_ptr_access(key_ptr, key_layout.size, key_layout.align.abi)?\n-                    .expect(\"cannot be a ZST\");\n-                this.memory.get_mut(key_ptr.alloc_id)?.write_scalar(\n-                    tcx,\n-                    key_ptr,\n-                    Scalar::from_uint(key, key_layout.size).into(),\n-                    key_layout.size,\n-                )?;\n+                this.write_scalar(Scalar::from_uint(key, key_layout.size), key_place.into())?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;\n@@ -856,6 +844,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let system_info_ptr = this\n                     .check_mplace_access(system_info, None)?\n                     .expect(\"cannot be a ZST\");\n+                // We rely on `deref_operand` doing bounds checks for us.\n                 // Initialize with `0`.\n                 this.memory\n                     .get_mut(system_info_ptr.alloc_id)?\n@@ -988,33 +977,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         return Ok(None);\n     }\n-\n-    fn set_last_error(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let errno_ptr = this.machine.last_error.unwrap();\n-        this.memory.get_mut(errno_ptr.alloc_id)?.write_scalar(\n-            &*this.tcx,\n-            errno_ptr,\n-            scalar.into(),\n-            Size::from_bits(32),\n-        )\n-    }\n-\n-    fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        let this = self.eval_context_mut();\n-        let errno_ptr = this.machine.last_error.unwrap();\n-        this.memory\n-            .get(errno_ptr.alloc_id)?\n-            .read_scalar(&*this.tcx, errno_ptr, Size::from_bits(32))?\n-            .not_undef()\n-    }\n-\n-    fn consume_io_error(&mut self, e: std::io::Error) -> InterpResult<'tcx> {\n-        self.eval_context_mut().set_last_error(Scalar::from_int(\n-            e.raw_os_error().unwrap(),\n-            Size::from_bits(32),\n-        ))\n-    }\n }\n \n // Shims the linux 'getrandom()' syscall."}, {"sha": "08c9f3ec06e78cdb39e9c51cd387d42b9aedfdbb", "filename": "src/shims/fs.rs", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -7,6 +7,7 @@ use rustc::ty::layout::Size;\n use crate::stacked_borrows::Tag;\n use crate::*;\n \n+#[derive(Debug)]\n pub struct FileHandle {\n     file: File,\n }\n@@ -20,7 +21,7 @@ impl Default for FileHandler {\n     fn default() -> Self {\n         FileHandler {\n             handles: Default::default(),\n-            // 0, 1 and 2 are reserved for stdin, stdout and stderr\n+            // 0, 1 and 2 are reserved for stdin, stdout and stderr.\n             low: 3,\n         }\n     }\n@@ -99,11 +100,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let fd = options.open(path).map(|file| {\n             let mut fh = &mut this.machine.file_handler;\n             fh.low += 1;\n-            fh.handles.insert(fh.low, FileHandle { file });\n+            fh.handles.insert(fh.low, FileHandle { file }).unwrap_none();\n             fh.low\n         });\n \n-        this.consume_result(fd)\n+        this.try_unwrap_io_result(fd)\n     }\n \n     fn fcntl(\n@@ -118,7 +119,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let cmd = this.read_scalar(cmd_op)?.to_i32()?;\n-        // We only support getting the flags for a descriptor\n+        // We only support getting the flags for a descriptor.\n         if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n             // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n@@ -139,7 +140,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n         this.remove_handle_and(fd, |handle, this| {\n-            this.consume_result(handle.file.sync_all().map(|_| 0i32))\n+            this.try_unwrap_io_result(handle.file.sync_all().map(|_| 0i32))\n         })\n     }\n \n@@ -154,25 +155,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"read\")?;\n \n         let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n-        // Reading zero bytes should not change `buf`\n+        // Reading zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);\n         }\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let buf_scalar = this.read_scalar(buf_op)?.not_undef()?;\n \n-        // Remove the file handle to avoid borrowing issues\n+        // Remove the file handle to avoid borrowing issues.\n         this.remove_handle_and(fd, |mut handle, this| {\n-            // Don't use `?` to avoid returning before reinserting the handle\n+            // Don't use `?` to avoid returning before reinserting the handle.\n             let bytes = this.force_ptr(buf_scalar).and_then(|buf| {\n                 this.memory\n                     .get_mut(buf.alloc_id)?\n                     .get_bytes_mut(&*this.tcx, buf, Size::from_bytes(count))\n                     .map(|buffer| handle.file.read(buffer))\n             });\n-            // Reinsert the file handle\n-            this.machine.file_handler.handles.insert(fd, handle);\n-            this.consume_result(bytes?.map(|bytes| bytes as i64))\n+            this.machine.file_handler.handles.insert(fd, handle).unwrap_none();\n+            this.try_unwrap_io_result(bytes?.map(|bytes| bytes as i64))\n         })\n     }\n \n@@ -187,7 +187,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"write\")?;\n \n         let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n-        // Writing zero bytes should not change `buf`\n+        // Writing zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);\n         }\n@@ -200,8 +200,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .get_bytes(&*this.tcx, buf, Size::from_bytes(count))\n                     .map(|bytes| handle.file.write(bytes).map(|bytes| bytes as i64))\n             });\n-            this.machine.file_handler.handles.insert(fd, handle);\n-            this.consume_result(bytes?)\n+            this.machine.file_handler.handles.insert(fd, handle).unwrap_none();\n+            this.try_unwrap_io_result(bytes?)\n         })\n     }\n \n@@ -214,7 +214,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let result = remove_file(path).map(|_| 0);\n \n-        this.consume_result(result)\n+        this.try_unwrap_io_result(result)\n     }\n \n     /// Helper function that gets a `FileHandle` immutable reference and allows to manipulate it\n@@ -224,7 +224,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n     ///\n     /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n-    /// functions return different integer types (like `read`, that returns an `i64`)\n+    /// functions return different integer types (like `read`, that returns an `i64`).\n     fn get_handle_and<F, T: From<i32>>(&mut self, fd: i32, f: F) -> InterpResult<'tcx, T>\n     where\n         F: Fn(&FileHandle) -> InterpResult<'tcx, T>,\n@@ -248,7 +248,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n     ///\n     /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n-    /// functions return different integer types (like `read`, that returns an `i64`)\n+    /// functions return different integer types (like `read`, that returns an `i64`).\n     fn remove_handle_and<F, T: From<i32>>(&mut self, fd: i32, mut f: F) -> InterpResult<'tcx, T>\n     where\n         F: FnMut(FileHandle, &mut MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx, T>,\n@@ -262,23 +262,4 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok((-1).into())\n         }\n     }\n-\n-    /// Helper function that consumes an `std::io::Result<T>` and returns an\n-    /// `InterpResult<'tcx,T>::Ok` instead. It is expected that the result can be converted to an\n-    /// OS error using `std::io::Error::raw_os_error`.\n-    ///\n-    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n-    /// functions return different integer types (like `read`, that returns an `i64`)\n-    fn consume_result<T: From<i32>>(\n-        &mut self,\n-        result: std::io::Result<T>,\n-    ) -> InterpResult<'tcx, T> {\n-        match result {\n-            Ok(ok) => Ok(ok),\n-            Err(e) => {\n-                self.eval_context_mut().consume_io_error(e)?;\n-                Ok((-1).into())\n-            }\n-        }\n-    }\n }"}, {"sha": "46658760cc12ac36b50b873d08bcc2687cc78265", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -356,9 +356,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         _ => {\n                             // Do it in memory\n                             let mplace = this.force_allocation(dest)?;\n-                            assert!(mplace.meta.is_none());\n+                            mplace.meta.unwrap_none();\n                             // not a zst, must be valid pointer\n                             let ptr = mplace.ptr.to_ptr()?;\n+                            // we know the return place is in-bounds\n                             this.memory.get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, dest.layout.size)?;\n                         }\n                     }\n@@ -546,8 +547,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         _ => {\n                             // Do it in memory\n                             let mplace = this.force_allocation(dest)?;\n-                            assert!(mplace.meta.is_none());\n+                            mplace.meta.unwrap_none();\n                             let ptr = mplace.ptr.to_ptr()?;\n+                            // We know the return place is in-bounds\n                             this.memory\n                                 .get_mut(ptr.alloc_id)?\n                                 .mark_definedness(ptr, dest.layout.size, false);"}, {"sha": "b6aadd31a5be673688b3dffd825ca82e9e2db13a", "filename": "src/shims/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> TlsData<'tcx> {\n                 data: None,\n                 dtor,\n             },\n-        );\n+        ).unwrap_none();\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         new_key\n     }"}, {"sha": "2188b9d5394a310557ba0cb8a2ba67054c04f075", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bd25de83bc1139829656a1b84a4fc04faa0554/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=72bd25de83bc1139829656a1b84a4fc04faa0554", "patch": "@@ -172,7 +172,7 @@ impl GlobalState {\n     pub fn new_call(&mut self) -> CallId {\n         let id = self.next_call_id;\n         trace!(\"new_call: Assigning ID {}\", id);\n-        self.active_calls.insert(id);\n+        assert!(self.active_calls.insert(id));\n         self.next_call_id = NonZeroU64::new(id.get() + 1).unwrap();\n         id\n     }\n@@ -189,7 +189,7 @@ impl GlobalState {\n         self.base_ptr_ids.get(&id).copied().unwrap_or_else(|| {\n             let tag = Tag::Tagged(self.new_ptr());\n             trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n-            self.base_ptr_ids.insert(id, tag);\n+            self.base_ptr_ids.insert(id, tag).unwrap_none();\n             tag\n         })\n     }"}]}