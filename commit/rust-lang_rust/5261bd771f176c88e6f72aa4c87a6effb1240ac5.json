{"sha": "5261bd771f176c88e6f72aa4c87a6effb1240ac5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNjFiZDc3MWYxNzZjODhlNmY3MmFhNGM4N2E2ZWZmYjEyNDBhYzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-05T23:46:51Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-05T23:47:43Z"}, "message": "rt: Simplify the signature of walk_tag; stub code for the data walker", "tree": {"sha": "a989e486f2c68ad642522d005f46cc6f1e7859f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a989e486f2c68ad642522d005f46cc6f1e7859f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5261bd771f176c88e6f72aa4c87a6effb1240ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5261bd771f176c88e6f72aa4c87a6effb1240ac5", "html_url": "https://github.com/rust-lang/rust/commit/5261bd771f176c88e6f72aa4c87a6effb1240ac5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5261bd771f176c88e6f72aa4c87a6effb1240ac5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9471d82961eb18d60509247d827ce495210abbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9471d82961eb18d60509247d827ce495210abbe", "html_url": "https://github.com/rust-lang/rust/commit/a9471d82961eb18d60509247d827ce495210abbe"}], "stats": {"total": 258, "additions": 181, "deletions": 77}, "files": [{"sha": "7d6f10ce54cf9d58bfbd5c232af578cb2cc24e1d", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 181, "deletions": 77, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/5261bd771f176c88e6f72aa4c87a6effb1240ac5/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5261bd771f176c88e6f72aa4c87a6effb1240ac5/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=5261bd771f176c88e6f72aa4c87a6effb1240ac5", "patch": "@@ -76,6 +76,55 @@ round_up(T size, size_t alignment) {\n }\n \n \n+// Utility classes\n+\n+struct size_align {\n+    size_t size;\n+    size_t alignment;\n+\n+    size_align(size_t in_size = 0, size_t in_align = 1) :\n+        size(in_size), alignment(in_align) {}\n+\n+    bool is_set() const { return alignment != 0; }\n+\n+    inline void set(size_t in_size, size_t in_align) {\n+        size = in_size;\n+        alignment = in_align;\n+    }\n+\n+    inline void add(const size_align &other) {\n+        add(other.size, other.alignment);\n+    }\n+\n+    inline void add(size_t extra_size, size_t extra_align) {\n+        size += extra_size;\n+        alignment = max(alignment, extra_align);\n+    }\n+\n+    static inline size_align make(size_t in_size) {\n+        size_align sa;\n+        sa.size = sa.alignment = in_size;\n+        return sa;\n+    }\n+\n+    static inline size_align make(size_t in_size, size_t in_align) {\n+        size_align sa;\n+        sa.size = in_size;\n+        sa.alignment = in_align;\n+        return sa;\n+    }\n+};\n+\n+struct tag_info {\n+    uint16_t tag_id;                        // The tag ID.\n+    const uint8_t *info_ptr;                // Pointer to the info table.\n+    uint16_t variant_count;                 // Number of variants in the tag.\n+    const uint8_t *largest_variants_ptr;    // Ptr to largest variants table.\n+    size_align tag_sa;                      // Size and align of this tag.\n+    uint16_t n_params;                      // Number of type parameters.\n+    const type_param *params;               // Array of type parameters.\n+};\n+\n \n // Contexts\n \n@@ -117,43 +166,6 @@ class ctxt {\n };\n \n \n-struct size_align {\n-    size_t size;\n-    size_t alignment;\n-\n-    size_align(size_t in_size = 0, size_t in_align = 1) :\n-        size(in_size), alignment(in_align) {}\n-\n-    bool is_set() const { return alignment != 0; }\n-\n-    inline void set(size_t in_size, size_t in_align) {\n-        size = in_size;\n-        alignment = in_align;\n-    }\n-\n-    inline void add(const size_align &other) {\n-        add(other.size, other.alignment);\n-    }\n-\n-    inline void add(size_t extra_size, size_t extra_align) {\n-        size += extra_size;\n-        alignment = max(alignment, extra_align);\n-    }\n-\n-    static inline size_align make(size_t in_size) {\n-        size_align sa;\n-        sa.size = sa.alignment = in_size;\n-        return sa;\n-    }\n-\n-    static inline size_align make(size_t in_size, size_t in_align) {\n-        size_align sa;\n-        sa.size = in_size;\n-        sa.alignment = in_align;\n-        return sa;\n-    }\n-};\n-\n struct rust_fn {\n     void (*code)(uint8_t *rv, rust_task *task, void *env, ...);\n     void *env;\n@@ -334,37 +346,38 @@ ctxt<T>::walk_ivec(bool align) {\n template<typename T>\n void\n ctxt<T>::walk_tag(bool align) {\n-    uint16_t tag_id = get_u16_bump(sp);\n+    tag_info tinfo;\n+    tinfo.tag_id = get_u16_bump(sp);\n \n     // Determine the info pointer.\n-    uint16_t info_offset = get_u16(tables->tags + tag_id * sizeof(uint16_t));\n-    const uint8_t *info_ptr = tables->tags + info_offset;\n+    uint16_t info_offset = get_u16(tables->tags +\n+                                   tinfo.tag_id * sizeof(uint16_t));\n+    tinfo.info_ptr = tables->tags + info_offset;\n \n-    uint16_t variant_count = get_u16_bump(info_ptr);\n+    tinfo.variant_count = get_u16_bump(tinfo.info_ptr);\n \n     // Determine the largest-variants pointer.\n-    uint16_t largest_variants_offset = get_u16_bump(info_ptr);\n-    const uint8_t *largest_variants_ptr =\n-        tables->tags + largest_variants_offset;\n+    uint16_t largest_variants_offset = get_u16_bump(tinfo.info_ptr);\n+    tinfo.largest_variants_ptr = tables->tags + largest_variants_offset;\n \n     // Determine the size and alignment.\n-    size_align tag_sa = get_size_align(info_ptr);\n+    tinfo.tag_sa = get_size_align(tinfo.info_ptr);\n \n     // Determine the number of parameters.\n-    uint16_t n_params = get_u16_bump(sp);\n+    tinfo.n_params = get_u16_bump(sp);\n \n     // Read in the tag type parameters.\n-    type_param params[n_params];\n-    for (uint16_t i = 0; i < n_params; i++) {\n+    type_param params[tinfo.n_params];\n+    for (uint16_t i = 0; i < tinfo.n_params; i++) {\n         uint16_t len = get_u16_bump(sp);\n         params[i].set(this);\n         sp += len;\n     }\n \n+    tinfo.params = params;\n+\n     // Call to the implementation.\n-    static_cast<T *>(this)->walk_tag(align, tag_id, info_ptr, variant_count,\n-                                     largest_variants_ptr, tag_sa, n_params,\n-                                     params);\n+    static_cast<T *>(this)->walk_tag(align, tinfo);\n }\n \n template<typename T>\n@@ -430,10 +443,7 @@ class print : public ctxt<print> {\n           const rust_shape_tables *in_tables = NULL)\n     : ctxt<print>(other, in_sp, in_params, in_tables) {}\n \n-    void walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n-                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n-                  size_align &tag_sa, uint16_t n_params,\n-                  const type_param *params);\n+    void walk_tag(bool align, tag_info &tinfo);\n     void walk_struct(bool align, const uint8_t *end_sp);\n     void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n                   const uint8_t *ty_params_sp);\n@@ -466,23 +476,20 @@ class print : public ctxt<print> {\n };\n \n void\n-print::walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n-                uint16_t variant_count, const uint8_t *largest_variants_ptr,\n-                size_align &tag_sa, uint16_t n_params,\n-                const type_param *params) {\n-    DPRINT(\"tag%u\", tag_id);\n-    if (!n_params)\n+print::walk_tag(bool align, tag_info &tinfo) {\n+    DPRINT(\"tag%u\", tinfo.tag_id);\n+    if (!tinfo.n_params)\n         return;\n \n     DPRINT(\"<\");\n \n     bool first = true;\n-    for (uint16_t i = 0; i < n_params; i++) {\n+    for (uint16_t i = 0; i < tinfo.n_params; i++) {\n         if (!first)\n             DPRINT(\",\");\n         first = false;\n \n-        ctxt<print> sub(*this, params[i].shape);\n+        ctxt<print> sub(*this, tinfo.params[i].shape);\n         sub.walk(align);\n     }\n \n@@ -575,10 +582,7 @@ class size_of : public ctxt<size_of> {\n             const rust_shape_tables *in_tables)\n     : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n \n-    void walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n-                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n-                  size_align &tag_sa, uint16_t n_params,\n-                  const type_param *params);\n+    void walk_tag(bool align, tag_info &tinfo);\n     void walk_struct(bool align, const uint8_t *end_sp);\n     void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n \n@@ -618,21 +622,18 @@ class size_of : public ctxt<size_of> {\n };\n \n void\n-size_of::walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n-                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n-                  size_align &tag_sa, uint16_t n_params,\n-                  const type_param *params) {\n+size_of::walk_tag(bool align, tag_info &tinfo) {\n     // If the precalculated size and alignment are good, use them.\n-    if (tag_sa.is_set()) {\n-        sa = tag_sa;\n+    if (tinfo.tag_sa.is_set()) {\n+        sa = tinfo.tag_sa;\n         return;\n     }\n \n-    uint16_t n_largest_variants = get_u16_bump(largest_variants_ptr);\n+    uint16_t n_largest_variants = get_u16_bump(tinfo.largest_variants_ptr);\n     sa.set(0, 0);\n     for (uint16_t i = 0; i < n_largest_variants; i++) {\n-        uint16_t variant_id = get_u16_bump(largest_variants_ptr);\n-        uint16_t variant_offset = get_u16(info_ptr +\n+        uint16_t variant_id = get_u16_bump(tinfo.largest_variants_ptr);\n+        uint16_t variant_offset = get_u16(tinfo.info_ptr +\n                                           variant_id * sizeof(uint16_t));\n         const uint8_t *variant_ptr = tables->tags + variant_offset;\n \n@@ -657,7 +658,7 @@ size_of::walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n             sa = variant_sa;\n     }\n \n-    if (variant_count == 1) {\n+    if (tinfo.variant_count == 1) {\n         if (!sa.size)\n             sa.set(1, 1);\n     } else {\n@@ -694,5 +695,108 @@ size_of::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n            max(sa.alignment, sizeof(uintptr_t)));\n }\n \n+\n+#if 0\n+\n+// An abstract class (again using the curiously recurring template pattern)\n+// for methods that actually manipulate the data involved.\n+\n+#define DATA_SIMPLE(ty, call) \\\n+    if (align) dp.align(sizeof(ty)); \\\n+    static_cast<T *>(this)->call; \\\n+    dp += sizeof(ty);\n+\n+template<typename T,typename U>\n+class data : public ctxt<data> {\n+private:\n+    U dp;\n+\n+public:\n+    void walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n+                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n+                  size_align &tag_sa, uint16_t n_params,\n+                  const type_param *params);\n+    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n+\n+    void walk_struct(bool align, const uint8_t *end_sp) {\n+        while (sp != end_sp) {\n+            // TODO: Allow subclasses to optimize for POD if they want to.\n+            walk(align);\n+            align = true;\n+        }\n+    }\n+\n+    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n+        DATA_SIMPLE(void *, walk_evec(align, is_pod, sp_size));\n+    }\n+\n+    void walk_box(bool align)   { DATA_SIMPLE(void *, walk_box(align)); }\n+    void walk_port(bool align)  { DATA_SIMPLE(void *, walk_port(align)); }\n+    void walk_chan(bool align)  { DATA_SIMPLE(void *, walk_chan(align)); }\n+    void walk_task(bool align)  { DATA_SIMPLE(void *, walk_task(align)); }\n+\n+    void walk_fn(bool align) {\n+        if (align) dp.align(sizeof(void *));\n+        static_cast<T *>(this)->walk_fn(args);\n+        dp += sizeof(void *) * 2;\n+    }\n+\n+    void walk_obj(bool align) {\n+        if (align) dp.align(sizeof(void *));\n+        static_cast<T *>(this)->walk_obj(args);\n+        dp += sizeof(void *) * 2;\n+    }\n+\n+    void walk_var(bool align, uint8_t param_index) {\n+        static_cast<T *>(this)->walk_var(align, param_index);\n+    }\n+\n+    template<typename W>\n+    void walk_number(bool align) {\n+        DATA_SIMPLE(W, walk_number<W>(align));\n+    }\n+};\n+\n+template<typename T,typename U>\n+void\n+data<T,U>::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n+    if (!elem_sa.is_set())\n+        elem_sa = size_of::get(*this);\n+    else if (elem_sa.alignment == 8)\n+        elem_sa.alignment = 4;  // FIXME: This is an awful hack.\n+\n+    // Get a pointer to the interior vector, and skip over it.\n+    if (align) dp.align(ALIGNOF(rust_ivec *));\n+    U end_dp = dp + sizeof(rust_ivec) - sizeof(uintptr_t) + elem_sa.size * 4;\n+\n+    // Call to the implementation.\n+    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n+\n+    dp = end_dp;\n+}\n+\n+template<typename T,typename U>\n+void\n+data<T,U>::walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n+                    uint16_t variant_count,\n+                    const uint8_t *largest_variants_ptr, size_align &tag_sa,\n+                    uint16_t n_params, const type_param *params) {\n+    uint32_t tag_variant;\n+    U end_dp;\n+    if (variant_count > 1) {\n+        if (align) dp.align(ALIGNOF(uint32_t));\n+        process_tag_variant_ids(\n+        U::data<uint32_t> tag_variant = \n+}\n+\n+#endif\n+\n+\n+// Copy constructors\n+\n+class copy : public ctxt<copy> {\n+    // TODO\n+};\n+\n } // end namespace shape\n "}]}