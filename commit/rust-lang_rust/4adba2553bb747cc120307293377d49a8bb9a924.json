{"sha": "4adba2553bb747cc120307293377d49a8bb9a924", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZGJhMjU1M2JiNzQ3Y2MxMjAzMDcyOTMzNzdkNDlhOGJiOWE5MjQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-20T13:15:28Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-20T13:15:28Z"}, "message": "Use pass by value fro simple simple types", "tree": {"sha": "ae66ecbadb96363ffdecfab6aa41303c5aae1eed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae66ecbadb96363ffdecfab6aa41303c5aae1eed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4adba2553bb747cc120307293377d49a8bb9a924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4adba2553bb747cc120307293377d49a8bb9a924", "html_url": "https://github.com/rust-lang/rust/commit/4adba2553bb747cc120307293377d49a8bb9a924", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4adba2553bb747cc120307293377d49a8bb9a924/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d40131d81a23acd20df37011c9ba9601876becf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d40131d81a23acd20df37011c9ba9601876becf", "html_url": "https://github.com/rust-lang/rust/commit/9d40131d81a23acd20df37011c9ba9601876becf"}], "stats": {"total": 190, "additions": 130, "deletions": 60}, "files": [{"sha": "39dbe2cb4115d5b2dc770b90deda8f1cd611e989", "filename": "example.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4adba2553bb747cc120307293377d49a8bb9a924/example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4adba2553bb747cc120307293377d49a8bb9a924/example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example.rs?ref=4adba2553bb747cc120307293377d49a8bb9a924", "patch": "@@ -35,13 +35,13 @@ fn abc(a: u8) -> u8 {\n     a * 2\n }\n \n-/*fn bcd(b: bool, a: u8) -> u8 {\n+fn bcd(b: bool, a: u8) -> u8 {\n     if b {\n         a * 2\n     } else {\n         a * 3\n     }\n-}*/\n+}\n \n fn call() {\n     abc(42);"}, {"sha": "dfa6c2beee0b78ed5651b00fb9a9975a1e2d318d", "filename": "src/base.rs", "status": "modified", "additions": 128, "deletions": 58, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/4adba2553bb747cc120307293377d49a8bb9a924/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4adba2553bb747cc120307293377d49a8bb9a924/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=4adba2553bb747cc120307293377d49a8bb9a924", "patch": "@@ -6,6 +6,7 @@ use cretonne::prelude::*;\n use cretonne::codegen::ir::{\n     ExternalName,\n     FuncRef,\n+    StackSlot,\n     function::Function,\n };\n \n@@ -32,6 +33,7 @@ impl EntityRef for Variable {\n     }\n }\n \n+#[derive(Copy, Clone)]\n enum CValue {\n     ByRef(Value),\n     ByVal(Value),\n@@ -71,6 +73,36 @@ impl CValue {\n             }\n         }\n     }\n+\n+    fn expect_byref(self) -> Value {\n+        match self {\n+            CValue::ByRef(value) => value,\n+            CValue::ByVal(_) => unimplemented!(\"Expected CValue::ByRef, found CValue::ByVal\"),\n+            CValue::Func(_) => unimplemented!(\"Expected CValue::ByRef, found CValue::Func\"),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum CPlace {\n+    Var(Variable),\n+    Addr(Value),\n+}\n+\n+impl CPlace {\n+    fn to_cvalue<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> CValue {\n+        match self {\n+            CPlace::Var(var) => CValue::ByVal(fx.bcx.use_var(var)),\n+            CPlace::Addr(addr) => CValue::ByRef(addr),\n+        }\n+    }\n+\n+    fn expect_addr(self) -> Value {\n+        match self {\n+            CPlace::Addr(addr) => addr,\n+            CPlace::Var(_) => unreachable!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+        }\n+    }\n }\n \n pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n@@ -111,16 +143,19 @@ pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n \n                     trans_fn(cx, &mut f, def_id, substs);\n \n-                    let flags = settings::Flags::new(settings::builder());\n-                    let verify_error: String = ::cretonne::codegen::verify_function(&f, &flags)\n-                        .map(|_| String::new())\n-                        .unwrap_or_else(|err| format!(\"\\n\\ncretonne error: {}\", err));\n-\n                     let mut mir = ::std::io::Cursor::new(Vec::new());\n                     ::rustc_mir::util::write_mir_pretty(cx.tcx, Some(def_id), &mut mir).unwrap();\n                     let mut cton = String::new();\n                     ::cretonne::codegen::write_function(&mut cton, &f, None).unwrap();\n-                    tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\\n\\n{}{}\", def_id, String::from_utf8_lossy(&mir.into_inner()), cton, verify_error));\n+                    tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner()), cton));\n+\n+                    let flags = settings::Flags::new(settings::builder());\n+                    match ::cretonne::codegen::verify_function(&f, &flags) {\n+                        Ok(_) => {}\n+                        Err(err) => {\n+                            tcx.sess.fatal(&format!(\"cretonne verify error: {}\", err));\n+                        }\n+                    }\n \n                     //context.func = f;\n                     //cx.module.define_function(func_id, &mut context).unwrap();\n@@ -135,6 +170,8 @@ pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n     //cx.module.finalize_all();\n     //cx.module.finish();\n \n+    tcx.sess.fatal(\"unimplemented\");\n+\n     Box::new(::OngoingCodegen {\n         metadata: metadata,\n         //translated_module: Module::new(::cretonne_faerie::FaerieBuilder::new(,\n@@ -155,20 +192,16 @@ struct FunctionCx<'a, 'tcx: 'a> {\n     bcx: FunctionBuilder<'a, Variable>,\n     mir: &'tcx Mir<'tcx>,\n     ebb_map: HashMap<BasicBlock, Ebb>,\n-    args_map: HashMap<Local, Value>,\n+    local_map: HashMap<Local, CPlace>,\n }\n \n impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n     fn get_ebb(&self, bb: BasicBlock) -> Ebb {\n         *self.ebb_map.get(&bb).unwrap()\n     }\n \n-    fn get_local(&mut self, local: Local) -> Value {\n-        match self.mir.local_kind(local) {\n-            LocalKind::Arg => *self.args_map.get(&local).unwrap(),\n-            LocalKind::ReturnPointer => *self.args_map.get(&RETURN_PLACE).unwrap(),\n-            LocalKind::Temp | LocalKind::Var => self.bcx.use_var(Variable(local)),\n-        }\n+    fn get_local_place(&mut self, local: Local) -> CPlace {\n+        *self.local_map.get(&local).unwrap()\n     }\n \n     fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n@@ -194,36 +227,59 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, f: &mut Function, def_id\n         ebb_map.insert(bb, bcx.create_ebb());\n     }\n \n-    let mut args_map: HashMap<Local, Value> = HashMap::new();\n-    for arg in Some(RETURN_PLACE).into_iter().chain(mir.args_iter()) {\n-        let ty = types::I64;\n-        args_map.insert(arg, bcx.append_ebb_param(start_ebb, ty));\n+    let mut fx = FunctionCx {\n+        tcx: cx.tcx,\n+        module: &mut cx.module,\n+        def_id_fn_id_map: &mut cx.def_id_fn_id_map,\n+        bcx,\n+        mir,\n+        ebb_map,\n+        local_map: HashMap::new(),\n+    };\n+    let fx = &mut fx;\n+\n+    let ret_param = fx.bcx.append_ebb_param(start_ebb, types::I64);\n+    let _ = fx.bcx.create_stack_slot(StackSlotData {\n+        kind: StackSlotKind::ExplicitSlot,\n+        size: 0,\n+        offset: None,\n+    }); // Dummy stack slot for debugging\n+\n+    let func_params = mir.args_iter().map(|local| {\n+        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(mir.local_decls[local].ty)).unwrap();\n+        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+            kind: StackSlotKind::ExplicitSlot,\n+            size: layout.size.bytes() as u32,\n+            offset: None,\n+        });\n+        let ty = cton_type_from_ty(mir.local_decls[local].ty);\n+        (local, fx.bcx.append_ebb_param(start_ebb, ty.unwrap_or(types::I64)), ty, stack_slot)\n+    }).collect::<Vec<(Local, Value, Option<Type>, StackSlot)>>();\n+\n+    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param));\n+\n+    for (local, ebb_param, ty, stack_slot) in func_params {\n+        let addr = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n+        if ty.is_some() {\n+            fx.bcx.ins().stack_store(ebb_param, stack_slot, 0);\n+        } else {\n+            do_memcpy(fx, CPlace::Addr(addr), CValue::ByRef(ebb_param), mir.local_decls[local].ty);\n+        }\n+        fx.local_map.insert(local, CPlace::Addr(addr));\n     }\n \n     for local in mir.vars_and_temps_iter() {\n         let layout = cx.tcx.layout_of(ParamEnv::reveal_all().and(mir.local_decls[local].ty)).unwrap();\n-        let stack_slot = bcx.create_stack_slot(StackSlotData {\n+        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        let ty = types::I64;\n-        bcx.declare_var(Variable(local), ty);\n-        let val = bcx.ins().stack_addr(ty, stack_slot, 0);\n-        bcx.def_var(Variable(local), val);\n+        let addr = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n+        fx.local_map.insert(local, CPlace::Addr(addr));\n     }\n-    bcx.ins().jump(*ebb_map.get(&START_BLOCK).unwrap(), &[]);\n \n-    let mut fx = FunctionCx {\n-        tcx: cx.tcx,\n-        module: &mut cx.module,\n-        def_id_fn_id_map: &mut cx.def_id_fn_id_map,\n-        bcx,\n-        mir,\n-        ebb_map,\n-        args_map,\n-    };\n-    let fx = &mut fx;\n+    fx.bcx.ins().jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n \n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n         let ebb = fx.get_ebb(bb);\n@@ -270,7 +326,7 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, f: &mut Function, def_id\n                 let func_ty = func.ty(&fx.mir.local_decls, fx.tcx);\n                 let func = trans_operand(fx, func);\n                 let return_place = if let Some((place, _)) = destination {\n-                    trans_place(fx, place)\n+                    trans_place(fx, place).expect_addr()\n                 } else {\n                     fx.bcx.ins().iconst(types::I64, 0)\n                 };\n@@ -282,7 +338,11 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, f: &mut Function, def_id\n                             .map(|arg| {\n                                 let ty = arg.ty(&fx.mir.local_decls, fx.tcx);\n                                 let arg = trans_operand(fx, arg);\n-                                arg.force_stack(fx, ty)\n+                                if let Some(_) = cton_type_from_ty(ty) {\n+                                    arg.load_value(fx, ty)\n+                                } else {\n+                                    arg.force_stack(fx, ty)\n+                                }\n                             })\n                     ).collect::<Vec<_>>();\n                 match func {\n@@ -331,24 +391,28 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n             let ty = place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx);\n             let lval = trans_place(fx, place);\n             let rval = trans_rval(fx, rval);\n-            do_memcpy(fx, lval, rval, ty);\n+            do_memcpy(fx, lval, CValue::ByRef(rval), ty);\n         }\n         StatementKind::StorageLive(_) | StatementKind::StorageDead(_) | StatementKind::Nop => {}\n         _ => unimplemented!(\"stmt {:?}\", stmt),\n     }\n }\n \n-fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> Value {\n+fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace {\n     match place {\n-        Place::Local(local) => fx.get_local(*local),\n+        Place::Local(local) => fx.get_local_place(*local),\n         Place::Projection(projection) => {\n-            let base = trans_place(fx, &projection.base);\n+            let base = trans_place(fx, &projection.base).expect_addr();\n             match projection.elem {\n                 ProjectionElem::Field(field, ty) => {\n                     let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                     let field_offset = layout.fields.offset(field.index());\n-                    let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n-                    fx.bcx.ins().iadd(base, field_offset)\n+                    if field_offset.bytes() > 0 {\n+                        let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n+                        CPlace::Addr(fx.bcx.ins().iadd(base, field_offset))\n+                    } else {\n+                        CPlace::Addr(base)\n+                    }\n                 }\n                 _ => unimplemented!(\"projection {:?}\", projection),\n             }\n@@ -403,7 +467,10 @@ fn trans_rval<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, rval: &Rvalue<'tcx>)\n fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx>) -> CValue {\n     match operand {\n         Operand::Move(place) |\n-        Operand::Copy(place) => CValue::ByRef(trans_place(fx, place)),\n+        Operand::Copy(place) => {\n+            let cplace = trans_place(fx, place);\n+            cplace.to_cvalue(fx)\n+        },\n         Operand::Constant(const_) => {\n             match const_.literal {\n                 Literal::Value { value } => {\n@@ -432,22 +499,25 @@ fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx\n     }\n }\n \n-fn do_memcpy<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, to: Value, from: Value, ty: Ty<'tcx>) {\n+fn do_memcpy<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, to: CPlace, from: CValue, ty: Ty<'tcx>) {\n     let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n     let size = layout.size.bytes() as i32;\n-    let ty = match size {\n-        2 => Some(types::I16),\n-        4 => Some(types::I32),\n-        8 => Some(types::I64),\n-        _ => None,\n-    };\n-    if let Some(ty) = ty {\n-        let data = fx.bcx.ins().load(ty, MemFlags::new(), from, 0);\n-        fx.bcx.ins().store(MemFlags::new(), data, to, 0);\n-    } else {\n-        for i in 0..size {\n-            let byte = fx.bcx.ins().load(types::I8, MemFlags::new(), from, i);\n-            fx.bcx.ins().store(MemFlags::new(), byte, to, i);\n+    match to {\n+        CPlace::Var(var) => {\n+            let data = from.load_value(fx, ty);\n+            fx.bcx.def_var(var, data)\n+        },\n+        CPlace::Addr(addr) => {\n+            if cton_type_from_ty(ty).is_some() {\n+                let data = from.load_value(fx, ty);\n+                fx.bcx.ins().store(MemFlags::new(), data, addr, 0);\n+            } else {\n+                for i in 0..size {\n+                    let from = from.expect_byref();\n+                    let byte = fx.bcx.ins().load(types::I8, MemFlags::new(), from, i);\n+                    fx.bcx.ins().store(MemFlags::new(), byte, addr, i);\n+                }\n+            }\n         }\n     }\n }\n@@ -476,8 +546,8 @@ fn cton_sig_from_mono_fn_sig<'a ,'tcx: 'a>(sig: PolyFnSig<'tcx>) -> Signature {\n         _ => CallConv::SystemV,\n     };\n     Signature {\n-        params: Some(types::I64).into_iter() // First param is palce to put return val\n-            .chain(inputs.into_iter().map(|_| types::I64))\n+        params: Some(types::I64).into_iter() // First param is place to put return val\n+            .chain(inputs.into_iter().map(|ty| cton_type_from_ty(ty).unwrap_or(types::I64)))\n             .map(AbiParam::new).collect(),\n         returns: vec![],\n         call_conv,"}]}