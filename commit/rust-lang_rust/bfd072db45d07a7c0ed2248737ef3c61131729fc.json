{"sha": "bfd072db45d07a7c0ed2248737ef3c61131729fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZDA3MmRiNDVkMDdhN2MwZWQyMjQ4NzM3ZWYzYzYxMTMxNzI5ZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-06T15:32:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-06T15:32:26Z"}, "message": "Auto merge of #26038 - eddyb:dst-nested, r=luqmana\n\nAllows `Rc<RefCell<Trait>>` and other containers. Fixes #25351.\r\nr? @nrc This is the discussed strategy, more or less.", "tree": {"sha": "ffdf93fb07eba4c68e94acf586b6847a40e5811a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffdf93fb07eba4c68e94acf586b6847a40e5811a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfd072db45d07a7c0ed2248737ef3c61131729fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfd072db45d07a7c0ed2248737ef3c61131729fc", "html_url": "https://github.com/rust-lang/rust/commit/bfd072db45d07a7c0ed2248737ef3c61131729fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfd072db45d07a7c0ed2248737ef3c61131729fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b82428b5f7ad3691adaa1c2a1ed10b2c96baa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b82428b5f7ad3691adaa1c2a1ed10b2c96baa4", "html_url": "https://github.com/rust-lang/rust/commit/d6b82428b5f7ad3691adaa1c2a1ed10b2c96baa4"}, {"sha": "01dee1b77e3f594256fc380c348f7ba8fcff41db", "url": "https://api.github.com/repos/rust-lang/rust/commits/01dee1b77e3f594256fc380c348f7ba8fcff41db", "html_url": "https://github.com/rust-lang/rust/commit/01dee1b77e3f594256fc380c348f7ba8fcff41db"}], "stats": {"total": 51, "additions": 36, "deletions": 15}, "files": [{"sha": "4ea6f0cb26ea0b5d182e09ba4088666737a87403", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bfd072db45d07a7c0ed2248737ef3c61131729fc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd072db45d07a7c0ed2248737ef3c61131729fc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=bfd072db45d07a7c0ed2248737ef3c61131729fc", "patch": "@@ -2523,41 +2523,57 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::lookup_field_type_unsubstituted(tcx, def_id, f.id)\n                 }).collect::<Vec<_>>();\n \n-                // FIXME(#25351) The last field of the structure has to exist and be a\n-                // type parameter (for now, to avoid tracking edge cases).\n-                let i = if let Some(&ty::ty_param(p)) = fields.last().map(|ty| &ty.sty) {\n-                    assert!(p.space == TypeSpace);\n-                    p.idx as usize\n+                // The last field of the structure has to exist and contain type parameters.\n+                let field = if let Some(&field) = fields.last() {\n+                    field\n                 } else {\n                     return Err(Unimplemented);\n                 };\n+                let mut ty_params = vec![];\n+                ty::walk_ty(field, |ty| {\n+                    if let ty::ty_param(p) = ty.sty {\n+                        assert!(p.space == TypeSpace);\n+                        let idx = p.idx as usize;\n+                        if !ty_params.contains(&idx) {\n+                            ty_params.push(idx);\n+                        }\n+                    }\n+                });\n+                if ty_params.is_empty() {\n+                    return Err(Unimplemented);\n+                }\n \n-                // Replace the type parameter chosen for unsizing with\n-                // ty_err and ensure it does not affect any other fields.\n+                // Replace type parameters used in unsizing with\n+                // ty_err and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n                 let mut new_substs = substs_a.clone();\n-                new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n+                for &i in &ty_params {\n+                    new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n+                }\n                 for &ty in fields.init() {\n                     if ty::type_is_error(ty.subst(tcx, &new_substs)) {\n                         return Err(Unimplemented);\n                     }\n                 }\n \n-                // Extract T and U from Struct<T> and Struct<U>.\n-                let inner_source = *substs_a.types.get(TypeSpace, i);\n-                let inner_target = *substs_b.types.get(TypeSpace, i);\n+                // Extract Field<T> and Field<U> from Struct<T> and Struct<U>.\n+                let inner_source = field.subst(tcx, substs_a);\n+                let inner_target = field.subst(tcx, substs_b);\n \n-                // Check that all the source structure with the unsized\n-                // type parameter is a subtype of the target.\n-                new_substs.types.get_mut_slice(TypeSpace)[i] = inner_target;\n+                // Check that the source structure with the target's\n+                // type parameters is a subtype of the target.\n+                for &i in &ty_params {\n+                    let param_b = *substs_b.types.get(TypeSpace, i);\n+                    new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n+                }\n                 let new_struct = ty::mk_struct(tcx, def_id, tcx.mk_substs(new_substs));\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n                     return Err(Unimplemented);\n                 }\n \n-                // Construct the nested T: Unsize<U> predicate.\n+                // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(util::predicate_for_trait_def(tcx,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),"}, {"sha": "67dd4021cb5c8dd65ae347ec635c2858c4bbc6a6", "filename": "src/test/run-pass/dst-coerce-rc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bfd072db45d07a7c0ed2248737ef3c61131729fc/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd072db45d07a7c0ed2248737ef3c61131729fc/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs?ref=bfd072db45d07a7c0ed2248737ef3c61131729fc", "patch": "@@ -12,6 +12,7 @@\n \n #![feature(core)]\n \n+use std::cell::RefCell;\n use std::rc::Rc;\n \n trait Baz {\n@@ -36,4 +37,8 @@ fn main() {\n     assert_eq!(b.get(), 42);\n \n     let _c = b.clone();\n+\n+    let a: Rc<RefCell<i32>> = Rc::new(RefCell::new(42));\n+    let b: Rc<RefCell<Baz>> = a.clone();\n+    assert_eq!(b.borrow().get(), 42);\n }"}]}