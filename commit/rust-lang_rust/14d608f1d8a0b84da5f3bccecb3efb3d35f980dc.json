{"sha": "14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZDYwOGYxZDhhMGI4NGRhNWYzYmNjZWNiM2VmYjNkMzVmOTgwZGM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-06T14:58:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-06T14:58:50Z"}, "message": "Rollup merge of #71269 - Mark-Simulacrum:sat-float-casts, r=nikic\n\nDefine UB in float-to-int casts to saturate\n\nThis closes #10184 by defining the behavior there to saturate infinities and values exceeding the integral range (on the lower or upper end). `NaN` is sent to zero.", "tree": {"sha": "bb359957d2ab7197b0179d8f59310da9c1108520", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb359957d2ab7197b0179d8f59310da9c1108520"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJestCrCRBK7hj4Ov3rIwAAdHIIAETRln1rVe9mbtQUCyapmJHV\nppmU1pNe43Dd7hRYKZs/9KlIgET6Enkyd7diTnJxcfh5Uxxs//30aNzChwVIEVwC\ntJ8C18xmkkgSS7sJugmZVC8417knF39uPURf9ClvmA/G0wJZT/uTV42+vrlUd93z\nPffIJCJSRrcevpgXj3hY7cJKmksA4NCw7/EB9lRnPNcofQK3oi/JAPUe3GygMCGc\nceNXP9dS47tJylCoVNxpSZq2DDOFcccQ/iX+dTaYcd76ug1o+oYEVlpP5ERDTax4\nQpN6o+dnFbiF5goSD5FVrNGAHzpcZrC4niAn9niTb6jbjSv3rcaS/yPZCznSUPI=\n=WdYK\n-----END PGP SIGNATURE-----\n", "payload": "tree bb359957d2ab7197b0179d8f59310da9c1108520\nparent 339f574809bf8e4166b8de3cdbe7df181d37af3d\nparent f63b8bffefb0f652dc164859f4c8a10329c9117a\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588777130 +0200\ncommitter GitHub <noreply@github.com> 1588777130 +0200\n\nRollup merge of #71269 - Mark-Simulacrum:sat-float-casts, r=nikic\n\nDefine UB in float-to-int casts to saturate\n\nThis closes #10184 by defining the behavior there to saturate infinities and values exceeding the integral range (on the lower or upper end). `NaN` is sent to zero.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "html_url": "https://github.com/rust-lang/rust/commit/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "339f574809bf8e4166b8de3cdbe7df181d37af3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/339f574809bf8e4166b8de3cdbe7df181d37af3d", "html_url": "https://github.com/rust-lang/rust/commit/339f574809bf8e4166b8de3cdbe7df181d37af3d"}, {"sha": "f63b8bffefb0f652dc164859f4c8a10329c9117a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f63b8bffefb0f652dc164859f4c8a10329c9117a", "html_url": "https://github.com/rust-lang/rust/commit/f63b8bffefb0f652dc164859f4c8a10329c9117a"}], "stats": {"total": 472, "additions": 420, "deletions": 52}, "files": [{"sha": "bb532abd84bdeece18a367deccc9eda0cbd0cea5", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "patch": "@@ -768,7 +768,7 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) -> Bx::Value {\n     let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n \n-    if !bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n+    if let Some(false) = bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n         return fptosui_result;\n     }\n "}, {"sha": "1c20ea9e824772f9080c78cdef22f9bded0b8322", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "patch": "@@ -559,7 +559,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(sanitizer, Some(Sanitizer::Address));\n     tracked!(sanitizer_memory_track_origins, 2);\n     tracked!(sanitizer_recover, vec![Sanitizer::Address]);\n-    tracked!(saturating_float_casts, true);\n+    tracked!(saturating_float_casts, Some(true));\n     tracked!(share_generics, Some(true));\n     tracked!(show_span, Some(String::from(\"abc\")));\n     tracked!(src_hash_algorithm, Some(SourceFileHashAlgorithm::Sha1));"}, {"sha": "1d314238b8651d188110d89d0ff81071e2ac9e16", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "patch": "@@ -938,9 +938,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"enable origins tracking in MemorySanitizer\"),\n     sanitizer_recover: Vec<Sanitizer> = (vec![], parse_sanitizer_list, [TRACKED],\n         \"enable recovery for selected sanitizers\"),\n-    saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n+    saturating_float_casts: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n-        the max/min integer respectively, and NaN is mapped to 0 (default: no)\"),\n+        the max/min integer respectively, and NaN is mapped to 0 (default: yes)\"),\n     save_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in JSON format) information, in \\\n         addition to normal output (default: no)\"),"}, {"sha": "8ae5ee4c3f9712028ce303404c9281216859c273", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "patch": "@@ -909,13 +909,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             cast_suggestion,\n                             Applicability::MaybeIncorrect, // lossy conversion\n                         );\n-                        err.warn(\n-                            \"if the rounded value cannot be represented by the target \\\n-                                integer type, including `Inf` and `NaN`, casting will cause \\\n-                                undefined behavior \\\n-                                (see issue #10184 <https://github.com/rust-lang/rust/issues/10184> \\\n-                                for more information)\",\n-                        );\n                     }\n                     true\n                 }"}, {"sha": "789feea12d6d7e8a67ecfd84b406b5fb99571c37", "filename": "src/test/codegen/unchecked-float-casts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs?ref=14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "patch": "@@ -1,7 +1,7 @@\n-// compile-flags: -C no-prepopulate-passes\n+// This file tests that we don't generate any code for saturation when using the\n+// unchecked intrinsics.\n \n-// This file tests that we don't generate any code for saturation if\n-// -Z saturating-float-casts is not enabled.\n+// compile-flags: -C opt-level=3\n \n #![crate_type = \"lib\"]\n \n@@ -12,7 +12,7 @@ pub fn f32_to_u32(x: f32) -> u32 {\n     // CHECK-NOT: fcmp\n     // CHECK-NOT: icmp\n     // CHECK-NOT: select\n-    x as u32\n+    unsafe { x.to_int_unchecked() }\n }\n \n // CHECK-LABEL: @f32_to_i32\n@@ -22,7 +22,7 @@ pub fn f32_to_i32(x: f32) -> i32 {\n     // CHECK-NOT: fcmp\n     // CHECK-NOT: icmp\n     // CHECK-NOT: select\n-    x as i32\n+    unsafe { x.to_int_unchecked() }\n }\n \n #[no_mangle]\n@@ -31,5 +31,5 @@ pub fn f64_to_u16(x: f64) -> u16 {\n     // CHECK-NOT: fcmp\n     // CHECK-NOT: icmp\n     // CHECK-NOT: select\n-    x as u16\n+    unsafe { x.to_int_unchecked() }\n }"}, {"sha": "e6d0c94a02fac5f7ff6cb3fc7a869adefe40ad47", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts.rs", "status": "modified", "additions": 410, "deletions": 35, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs?ref=14d608f1d8a0b84da5f3bccecb3efb3d35f980dc", "patch": "@@ -1,47 +1,41 @@\n // run-pass\n+// compile-flags:-Zmir-opt-level=0\n // Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n-// compile-flags: -Z saturating-float-casts\n+//\n+// Some of these tests come from a similar file in miri,\n+// tests/run-pass/float.rs. Individual test cases are potentially duplicated\n+// with the previously existing tests, but since this runs so quickly anyway,\n+// we're not spending the time to figure out exactly which ones should be\n+// merged.\n \n #![feature(test, stmt_expr_attributes)]\n+#![feature(track_caller)]\n #![deny(overflowing_literals)]\n extern crate test;\n \n use std::{f32, f64};\n-use std::{u8, i8, u16, i16, u32, i32, u64, i64};\n-#[cfg(not(target_os=\"emscripten\"))]\n-use std::{u128, i128};\n+#[cfg(not(target_os = \"emscripten\"))]\n+use std::{i128, u128};\n+use std::{i16, i32, i64, i8, u16, u32, u64, u8};\n use test::black_box;\n \n macro_rules! test {\n     ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n         // black_box disables constant evaluation to test run-time conversions:\n         assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n                     \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n-    );\n-\n-    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n-        test!($fval, f32 -> $ity, $ival);\n-        test!($fval, f64 -> $ity, $ival);\n-    )\n-}\n \n-// This macro tests const eval in addition to run-time evaluation.\n-// If and when saturating casts are adopted, this macro should be merged with test!() to ensure\n-// that run-time and const eval agree on inputs that currently trigger a const eval error.\n-macro_rules! test_c {\n-    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => ({\n-        test!($val, $src_ty -> $dest_ty, $expected);\n         {\n             const X: $src_ty = $val;\n             const Y: $dest_ty = X as $dest_ty;\n             assert_eq!(Y, $expected,\n                         \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n         }\n-    });\n+    );\n \n     ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n-        test_c!($fval, f32 -> $ity, $ival);\n-        test_c!($fval, f64 -> $ity, $ival);\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n     )\n }\n \n@@ -55,11 +49,11 @@ macro_rules! common_fptoi_tests {\n         // as well, the test is just slightly misplaced.\n         test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n         test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n-        test_c!(0., $fty -> $ity, 0);\n-        test_c!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(0., $fty -> $ity, 0);\n+        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n         test!(-0.9, $fty -> $ity, 0);\n-        test_c!(1., $fty -> $ity, 1);\n-        test_c!(42., $fty -> $ity, 42);\n+        test!(1., $fty -> $ity, 1);\n+        test!(42., $fty -> $ity, 42);\n     )+ });\n \n     (f* -> $($ity:ident)+) => ({\n@@ -85,51 +79,432 @@ macro_rules! fptoui_tests {\n     })\n }\n \n+use std::fmt::Debug;\n+\n+// Helper function to avoid promotion so that this tests \"run-time\" casts, not CTFE.\n+#[track_caller]\n+#[inline(never)]\n+fn assert_eq<T: PartialEq + Debug>(x: T, y: T) {\n+    assert_eq!(x, y);\n+}\n+\n+trait FloatToInt<Int>: Copy {\n+    fn cast(self) -> Int;\n+    unsafe fn cast_unchecked(self) -> Int;\n+}\n+\n+impl FloatToInt<i8> for f32 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f32 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f32 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f32 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f32 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+impl FloatToInt<i8> for f64 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f64 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f64 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f64 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f64 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<i128> for f64 {\n+    fn cast(self) -> i128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<u128> for f64 {\n+    fn cast(self) -> u128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+/// Test this cast both via `as` and via `to_int_unchecked` (i.e., it must not saturate).\n+#[track_caller]\n+#[inline(never)]\n+fn test_both_cast<F, I>(x: F, y: I)\n+where\n+    F: FloatToInt<I>,\n+    I: PartialEq + Debug,\n+{\n+    assert_eq!(x.cast(), y);\n+    assert_eq!(unsafe { x.cast_unchecked() }, y);\n+}\n+\n+fn casts() {\n+    // f32 -> i8\n+    test_both_cast::<f32, i8>(127.99, 127);\n+    test_both_cast::<f32, i8>(-128.99, -128);\n+\n+    // f32 -> i32\n+    test_both_cast::<f32, i32>(0.0, 0);\n+    test_both_cast::<f32, i32>(-0.0, 0);\n+    test_both_cast::<f32, i32>(/*0x1p-149*/ f32::from_bits(0x00000001), 0);\n+    test_both_cast::<f32, i32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd), -1);\n+    test_both_cast::<f32, i32>(1.9, 1);\n+    test_both_cast::<f32, i32>(-1.9, -1);\n+    test_both_cast::<f32, i32>(5.0, 5);\n+    test_both_cast::<f32, i32>(-5.0, -5);\n+    test_both_cast::<f32, i32>(2147483520.0, 2147483520);\n+    test_both_cast::<f32, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f32 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483904.0f32 as i32, i32::MIN);\n+    assert_eq::<i32>(f32::MAX as i32, i32::MAX);\n+    assert_eq::<i32>(f32::MIN as i32, i32::MIN);\n+    assert_eq::<i32>(f32::INFINITY as i32, i32::MAX);\n+    assert_eq::<i32>(f32::NEG_INFINITY as i32, i32::MIN);\n+    assert_eq::<i32>(f32::NAN as i32, 0);\n+    assert_eq::<i32>((-f32::NAN) as i32, 0);\n+\n+    // f32 -> u32\n+    test_both_cast::<f32, u32>(0.0, 0);\n+    test_both_cast::<f32, u32>(-0.0, 0);\n+    test_both_cast::<f32, u32>(-0.9999999, 0);\n+    test_both_cast::<f32, u32>(/*0x1p-149*/ f32::from_bits(0x1), 0);\n+    test_both_cast::<f32, u32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, u32>(1.9, 1);\n+    test_both_cast::<f32, u32>(5.0, 5);\n+    test_both_cast::<f32, u32>(2147483648.0, 0x8000_0000);\n+    test_both_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n+    test_both_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n+    test_both_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n+    test_both_cast::<f32, u32>((u32::MAX - 128) as f32, u32::MAX - 255); // rounding loss\n+\n+    // unrepresentable casts:\n+\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u32>((u32::MAX - 127) as f32 as u32, u32::MAX);\n+\n+    assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n+    assert_eq::<u32>(-5.0f32 as u32, 0);\n+    assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n+    assert_eq::<u32>(f32::MIN as u32, 0);\n+    assert_eq::<u32>(f32::INFINITY as u32, u32::MAX);\n+    assert_eq::<u32>(f32::NEG_INFINITY as u32, 0);\n+    assert_eq::<u32>(f32::NAN as u32, 0);\n+    assert_eq::<u32>((-f32::NAN) as u32, 0);\n+\n+    // f32 -> i64\n+    test_both_cast::<f32, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f32, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f32, i64>(9223371487098961920.0, 9223371487098961920);\n+    test_both_cast::<f32, i64>(-9223372036854775808.0, -9223372036854775808);\n+\n+    // f64 -> i8\n+    test_both_cast::<f64, i8>(127.99, 127);\n+    test_both_cast::<f64, i8>(-128.99, -128);\n+\n+    // f64 -> i32\n+    test_both_cast::<f64, i32>(0.0, 0);\n+    test_both_cast::<f64, i32>(-0.0, 0);\n+    test_both_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i32>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i32>(1.9, 1);\n+    test_both_cast::<f64, i32>(-1.9, -1);\n+    test_both_cast::<f64, i32>(1e8, 100_000_000);\n+    test_both_cast::<f64, i32>(2147483647.0, 2147483647);\n+    test_both_cast::<f64, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f64 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483649.0f64 as i32, i32::MIN);\n+\n+    // f64 -> i64\n+    test_both_cast::<f64, i64>(0.0, 0);\n+    test_both_cast::<f64, i64>(-0.0, 0);\n+    test_both_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n+    test_both_cast::<f64, i64>(\n+        /*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001),\n+        0,\n+    );\n+    test_both_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i64>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i64>(5.0, 5);\n+    test_both_cast::<f64, i64>(5.9, 5);\n+    test_both_cast::<f64, i64>(-5.0, -5);\n+    test_both_cast::<f64, i64>(-5.9, -5);\n+    test_both_cast::<f64, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f64, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f64, i64>(9223372036854774784.0, 9223372036854774784);\n+    test_both_cast::<f64, i64>(-9223372036854775808.0, -9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<i64>(9223372036854775808.0f64 as i64, i64::MAX);\n+    assert_eq::<i64>(-9223372036854777856.0f64 as i64, i64::MIN);\n+    assert_eq::<i64>(f64::MAX as i64, i64::MAX);\n+    assert_eq::<i64>(f64::MIN as i64, i64::MIN);\n+    assert_eq::<i64>(f64::INFINITY as i64, i64::MAX);\n+    assert_eq::<i64>(f64::NEG_INFINITY as i64, i64::MIN);\n+    assert_eq::<i64>(f64::NAN as i64, 0);\n+    assert_eq::<i64>((-f64::NAN) as i64, 0);\n+\n+    // f64 -> u64\n+    test_both_cast::<f64, u64>(0.0, 0);\n+    test_both_cast::<f64, u64>(-0.0, 0);\n+    test_both_cast::<f64, u64>(-0.99999999999, 0);\n+    test_both_cast::<f64, u64>(5.0, 5);\n+    test_both_cast::<f64, u64>(1e16, 10000000000000000);\n+    test_both_cast::<f64, u64>((u64::MAX - 1024) as f64, u64::MAX - 2047); // rounding loss\n+    test_both_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<u64>(-5.0f64 as u64, 0);\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u64>((u64::MAX - 1023) as f64 as u64, u64::MAX);\n+    assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MIN as u64, 0);\n+    assert_eq::<u64>(f64::INFINITY as u64, u64::MAX);\n+    assert_eq::<u64>(f64::NEG_INFINITY as u64, 0);\n+    assert_eq::<u64>(f64::NAN as u64, 0);\n+    assert_eq::<u64>((-f64::NAN) as u64, 0);\n+\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // f64 -> i128\n+        assert_eq::<i128>(f64::MAX as i128, i128::MAX);\n+        assert_eq::<i128>(f64::MIN as i128, i128::MIN);\n+\n+        // f64 -> u128\n+        assert_eq::<u128>(f64::MAX as u128, u128::MAX);\n+        assert_eq::<u128>(f64::MIN as u128, 0);\n+    }\n+\n+    // int -> f32\n+    assert_eq::<f32>(127i8 as f32, 127.0);\n+    assert_eq::<f32>(2147483647i32 as f32, 2147483648.0);\n+    assert_eq::<f32>((-2147483648i32) as f32, -2147483648.0);\n+    assert_eq::<f32>(1234567890i32 as f32, /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06));\n+    assert_eq::<f32>(16777217i32 as f32, 16777216.0);\n+    assert_eq::<f32>((-16777217i32) as f32, -16777216.0);\n+    assert_eq::<f32>(16777219i32 as f32, 16777220.0);\n+    assert_eq::<f32>((-16777219i32) as f32, -16777220.0);\n+    assert_eq::<f32>(\n+        0x7fffff4000000001i64 as f32,\n+        /*0x1.fffffep+62*/ f32::from_bits(0x5effffff),\n+    );\n+    assert_eq::<f32>(\n+        0x8000004000000001u64 as i64 as f32,\n+        /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff),\n+    );\n+    assert_eq::<f32>(\n+        0x0020000020000001i64 as f32,\n+        /*0x1.000002p+53*/ f32::from_bits(0x5a000001),\n+    );\n+    assert_eq::<f32>(\n+        0xffdfffffdfffffffu64 as i64 as f32,\n+        /*-0x1.000002p+53*/ f32::from_bits(0xda000001),\n+    );\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        assert_eq::<f32>(i128::MIN as f32, -170141183460469231731687303715884105728.0f32);\n+        assert_eq::<f32>(u128::MAX as f32, f32::INFINITY); // saturation\n+    }\n+\n+    // int -> f64\n+    assert_eq::<f64>(127i8 as f64, 127.0);\n+    assert_eq::<f64>(i16::MIN as f64, -32768.0f64);\n+    assert_eq::<f64>(2147483647i32 as f64, 2147483647.0);\n+    assert_eq::<f64>(-2147483648i32 as f64, -2147483648.0);\n+    assert_eq::<f64>(987654321i32 as f64, 987654321.0);\n+    assert_eq::<f64>(9223372036854775807i64 as f64, 9223372036854775807.0);\n+    assert_eq::<f64>(-9223372036854775808i64 as f64, -9223372036854775808.0);\n+    assert_eq::<f64>(4669201609102990i64 as f64, 4669201609102990.0); // Feigenbaum (?)\n+    assert_eq::<f64>(9007199254740993i64 as f64, 9007199254740992.0);\n+    assert_eq::<f64>(-9007199254740993i64 as f64, -9007199254740992.0);\n+    assert_eq::<f64>(9007199254740995i64 as f64, 9007199254740996.0);\n+    assert_eq::<f64>(-9007199254740995i64 as f64, -9007199254740996.0);\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // even that fits...\n+        assert_eq::<f64>(u128::MAX as f64, 340282366920938463463374607431768211455.0f64);\n+    }\n+\n+    // f32 -> f64\n+    assert_eq::<u64>((0.0f32 as f64).to_bits(), 0.0f64.to_bits());\n+    assert_eq::<u64>(((-0.0f32) as f64).to_bits(), (-0.0f64).to_bits());\n+    assert_eq::<f64>(5.0f32 as f64, 5.0f64);\n+    assert_eq::<f64>(\n+        /*0x1p-149*/ f32::from_bits(0x1) as f64,\n+        /*0x1p-149*/ f64::from_bits(0x36a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1p-149*/ f32::from_bits(0x80000001) as f64,\n+        /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64,\n+        /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64,\n+        /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1p-119*/ f32::from_bits(0x4000000) as f64,\n+        /*0x1p-119*/ f64::from_bits(0x3880000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64,\n+        6.6382536710104395e+37,\n+    );\n+    assert_eq::<f64>(f32::INFINITY as f64, f64::INFINITY);\n+    assert_eq::<f64>(f32::NEG_INFINITY as f64, f64::NEG_INFINITY);\n+\n+    // f64 -> f32\n+    assert_eq::<u32>((0.0f64 as f32).to_bits(), 0.0f32.to_bits());\n+    assert_eq::<u32>(((-0.0f64) as f32).to_bits(), (-0.0f32).to_bits());\n+    assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n+    assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n+    assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n+    assert_eq::<f32>(\n+        /*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32,\n+        /*0x1p-149*/ f32::from_bits(0x800000),\n+    );\n+    assert_eq::<f32>(\n+        /*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32,\n+        /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728),\n+    );\n+    assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n+    assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::NEG_INFINITY as f32, f32::NEG_INFINITY);\n+}\n+\n pub fn main() {\n+    casts(); // from miri's tests\n+\n     common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n     fptoui_tests!(f* -> u8 u16 u32 u64);\n     // FIXME emscripten does not support i128\n-    #[cfg(not(target_os=\"emscripten\"))] {\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n         common_fptoi_tests!(f* -> i128 u128);\n         fptoui_tests!(f* -> u128);\n     }\n \n     // The following tests cover edge cases for some integer types.\n \n     // # u8\n-    test_c!(254., f* -> u8, 254);\n+    test!(254., f* -> u8, 254);\n     test!(256., f* -> u8, 255);\n \n     // # i8\n-    test_c!(-127., f* -> i8, -127);\n+    test!(-127., f* -> i8, -127);\n     test!(-129., f* -> i8, -128);\n-    test_c!(126., f* -> i8, 126);\n+    test!(126., f* -> i8, 126);\n     test!(128., f* -> i8, 127);\n \n     // # i32\n     // -2147483648. is i32::MIN (exactly)\n-    test_c!(-2147483648., f* -> i32, i32::MIN);\n+    test!(-2147483648., f* -> i32, i32::MIN);\n     // 2147483648. is i32::MAX rounded up\n     test!(2147483648., f32 -> i32, 2147483647);\n     // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n     // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n-    test_c!(2147483520., f32 -> i32, 2147483520);\n+    test!(2147483520., f32 -> i32, 2147483520);\n     // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n     test!(-2147483904., f* -> i32, i32::MIN);\n-    test_c!(-2147483520., f* -> i32, -2147483520);\n+    test!(-2147483520., f* -> i32, -2147483520);\n \n     // # u32\n     // round(MAX) and nextUp(round(MAX))\n-    test_c!(4294967040., f* -> u32, 4294967040);\n+    test!(4294967040., f* -> u32, 4294967040);\n     test!(4294967296., f* -> u32, 4294967295);\n \n     // # u128\n-    #[cfg(not(target_os=\"emscripten\"))]\n+    #[cfg(not(target_os = \"emscripten\"))]\n     {\n         // float->int:\n-        test_c!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+        test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n         // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n         const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n-        test_c!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+        test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n     }\n }"}]}