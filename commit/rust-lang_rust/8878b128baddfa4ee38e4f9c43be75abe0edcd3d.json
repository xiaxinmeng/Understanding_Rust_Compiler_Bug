{"sha": "8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzhiMTI4YmFkZGZhNGVlMzhlNGY5YzQzYmU3NWFiZTBlZGNkM2Q=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-21T19:11:05Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-23T01:45:34Z"}, "message": "More work on word-count.\n\nUpdated the MapReduce protocol so that it's correct more often. It's\nstill not perfect, but the bugs repro less often now.\n\nAlso found a race condition in channel sending. The problem is that\nsend and receive both need to refer to the _unread field in\ncircular_buffer. For now I just grabbed the port lock to send. We can\nprobably get around this by using atomics instead.", "tree": {"sha": "aa36c8323cffd2cff75f39a26131137300b03555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa36c8323cffd2cff75f39a26131137300b03555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "html_url": "https://github.com/rust-lang/rust/commit/8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/comments", "author": null, "committer": null, "parents": [{"sha": "8f2254b8c28c17bf7346975205b623ee92ba947c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2254b8c28c17bf7346975205b623ee92ba947c", "html_url": "https://github.com/rust-lang/rust/commit/8f2254b8c28c17bf7346975205b623ee92ba947c"}], "stats": {"total": 170, "additions": 134, "deletions": 36}, "files": [{"sha": "27b9e4030a0d3f13607137ad58f92304c874b05e", "filename": "src/lib/task.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "patch": "@@ -5,6 +5,9 @@ native \"rust\" mod rustrt {\n     fn unsupervise();\n     fn pin_task();\n     fn unpin_task();\n+    fn clone_chan(*rust_chan c) -> *rust_chan;\n+\n+    type rust_chan;\n }\n \n /**\n@@ -44,6 +47,11 @@ fn unpin() {\n     rustrt::unpin_task();\n }\n \n+fn clone_chan[T](chan[T] c) -> chan[T] {\n+    auto cloned = rustrt::clone_chan(unsafe::reinterpret_cast(c));\n+    ret unsafe::reinterpret_cast(cloned);\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "6ba749b0d5c4fb70d662b026b6d6c61087fbc866", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "patch": "@@ -850,6 +850,11 @@ unpin_task(rust_task *task) {\n     task->unpin();\n }\n \n+extern \"C\" CDECL rust_chan *\n+clone_chan(rust_task *task, rust_chan *chan) {\n+    return chan->clone(task);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "d04f5ee8ff5918518b2c4b50e69d56775dfd4cbb", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "patch": "@@ -71,9 +71,16 @@ void rust_chan::disassociate() {\n  * Attempt to send data to the associated port.\n  */\n void rust_chan::send(void *sptr) {\n+    rust_scheduler *sched = kernel->sched;\n+    I(sched, !port->is_proxy());\n+\n+    rust_port *target_port = port->referent();\n+    // TODO: We can probably avoid this lock by using atomic operations in\n+    // circular_buffer.\n+    scoped_lock with(target_port->lock);\n+\n     buffer.enqueue(sptr);\n \n-    rust_scheduler *sched = kernel->sched;\n     if (!is_associated()) {\n         W(sched, is_associated(),\n           \"rust_chan::transmit with no associated port.\");\n@@ -88,8 +95,6 @@ void rust_chan::send(void *sptr) {\n                            task->get_handle(), port->as_proxy()->handle());\n         buffer.dequeue(NULL);\n     } else {\n-        rust_port *target_port = port->referent();\n-        scoped_lock with(target_port->lock);\n         if (target_port->task->blocked_on(target_port)) {\n             DLOG(sched, comm, \"dequeued in rendezvous_ptr\");\n             buffer.dequeue(target_port->task->rendezvous_ptr);"}, {"sha": "c6d31a47f4c82caed3af08b52286239b25d887f5", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "patch": "@@ -1,5 +1,6 @@\n align_of\n check_claims\n+clone_chan\n debug_box\n debug_fn\n debug_obj"}, {"sha": "a5b5641563b18960226ee423f315cdfa6b5fbd61", "filename": "src/test/bench/task-perf/word-count.rs", "status": "modified", "additions": 110, "deletions": 31, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs?ref=8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "patch": "@@ -17,34 +17,49 @@ import std::option::none;\n import std::str;\n import std::vec;\n import std::map;\n+import std::ivec;\n+\n+import std::time;\n+import std::u64;\n+\n+import std::task;\n+import clone = std::task::clone_chan;\n \n fn map(str filename, map_reduce::putter emit) {\n+    // log_err \"mapping \" + filename;\n     auto f = io::file_reader(filename);\n \n     while(true) {\n         alt(read_word(f)) {\n             case (some(?w)) {\n-                emit(w, \"1\");\n+                emit(w, 1);\n             }\n             case (none) {\n                 break;\n             }\n         }\n     }\n+    // log_err \"done mapping \" + filename;\n }\n \n fn reduce(str word, map_reduce::getter get) {\n+    // log_err \"reducing \" + word;\n     auto count = 0;\n \n     while(true) {\n         alt(get()) {\n-            case(some(_)) { count += 1 }\n-            case(none) { break }\n+            some(_) {\n+                // log_err \"received word \" + word;\n+                count += 1;\n+            }\n+            none { break }\n         }\n     }\n \n-    auto out = io::stdout();\n-    out.write_line(#fmt(\"%s: %d\", word, count));\n+    // auto out = io::stdout();\n+    // out.write_line(#fmt(\"%s: %d\", word, count));\n+\n+    // log_err \"reduce \" + word + \" done.\";\n }\n \n mod map_reduce {\n@@ -54,74 +69,115 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter = fn(str, str) -> ();\n+    type putter = fn(str, int) -> ();\n \n     type mapper = fn(str, putter);\n \n-    type getter = fn() -> option[str];\n+    type getter = fn() -> option[int];\n \n     type reducer = fn(str, getter);\n \n     tag ctrl_proto {\n-        find_reducer(str, chan[chan[reduce_proto]]);\n+        find_reducer(u8[], chan[chan[reduce_proto]]);\n         mapper_done;\n     }\n \n     tag reduce_proto {\n-        emit_val(str);\n+        emit_val(int);\n         done;\n+        ref;\n+        release;\n     }\n \n     fn start_mappers(chan[ctrl_proto] ctrl,\n-                     vec[str] inputs) {\n+                     vec[str] inputs) -> task[] {\n+        auto tasks = ~[];\n+        // log_err \"starting mappers\";\n         for(str i in inputs) {\n-            spawn map_task(ctrl, i);\n+            // log_err \"starting mapper for \" + i;\n+            tasks += ~[spawn map_task(ctrl, i)];\n         }\n+        // log_err \"done starting mappers\";\n+        ret tasks;\n     }\n \n     fn map_task(chan[ctrl_proto] ctrl,\n                 str input) {\n-\n+        // log_err \"map_task \" + input;\n         auto intermediates = map::new_str_hash();\n \n         fn emit(&map::hashmap[str, chan[reduce_proto]] im,\n                 chan[ctrl_proto] ctrl,\n-                str key, str val) {\n+                str key, int val) {\n+            // log_err \"emitting \" + key;\n             auto c;\n             alt(im.find(key)) {\n-                case(some(?_c)) {\n+                some(?_c) {\n+                    // log_err \"reusing saved channel for \" + key;\n                     c = _c\n                 }\n-                case(none) {\n+                none {\n+                    // log_err \"fetching new channel for \" + key;\n                     auto p = port[chan[reduce_proto]]();\n-                    ctrl <| find_reducer(key, chan(p));\n+                    auto keyi = str::bytes_ivec(key);\n+                    ctrl <| find_reducer(keyi, chan(p));\n                     p |> c;\n-                    im.insert(key, c);\n+                    im.insert(key, clone(c));\n+                    c <| ref;\n                 }\n             }\n             c <| emit_val(val);\n         }\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n+\n+        for each(@tup(str, chan[reduce_proto]) kv in intermediates.items()) {\n+            // log_err \"sending done to reducer for \" + kv._0;\n+            kv._1 <| release;\n+        }\n+\n         ctrl <| mapper_done;\n+\n+        // log_err \"~map_task \" + input;\n     }\n \n     fn reduce_task(str key, chan[chan[reduce_proto]] out) {\n+        // log_err \"reduce_task \" + key;\n         auto p = port();\n \n         out <| chan(p);\n \n-        fn get(port[reduce_proto] p) -> option[str] {\n-            auto m;\n-            p |> m;\n+        auto ref_count = 0;\n+        auto is_done = false;\n \n-            alt(m) {\n-                case(emit_val(?v)) { ret some(v); }\n-                case(done) { ret none; }\n+        fn get(&port[reduce_proto] p, &mutable int ref_count,\n+               &mutable bool is_done) -> option[int] {\n+            while (!is_done || ref_count > 0) {\n+                auto m;\n+                p |> m;\n+\n+                alt(m) {\n+                    emit_val(?v) {\n+                        // log_err #fmt(\"received %d\", v);\n+                        ret some(v);\n+                    }\n+                    done {\n+                        // log_err \"all done\";\n+                        is_done = true;\n+                    }\n+                    ref {\n+                        ref_count += 1;\n+                    }\n+                    release {\n+                        ref_count -= 1;\n+                    }\n+                }\n             }\n+            ret none;\n         }\n \n-        reduce(key, bind get(p));\n+        reduce(key, bind get(p, ref_count, is_done));\n+        // log_err \"~reduce_task \" + key;\n     }\n \n     fn map_reduce (vec[str] inputs) {\n@@ -134,7 +190,7 @@ mod map_reduce {\n \n         reducers = map::new_str_hash();\n \n-        start_mappers(chan(ctrl), inputs);\n+        auto tasks = start_mappers(chan(ctrl), inputs);\n \n         auto num_mappers = vec::len(inputs) as int;\n \n@@ -143,26 +199,42 @@ mod map_reduce {\n             ctrl |> m;\n \n             alt(m) {\n-                case(mapper_done) { num_mappers -= 1; }\n-                case(find_reducer(?k, ?cc)) {\n+                mapper_done {\n+                    // log_err \"received mapper terminated.\";\n+                    num_mappers -= 1;\n+                }\n+                find_reducer(?ki, ?cc) {\n                     auto c;\n+                    auto k = str::unsafe_from_bytes_ivec(ki);\n+                    // log_err \"finding reducer for \" + k;\n                     alt(reducers.find(k)) {\n-                        case(some(?_c)) { c = _c; }\n-                        case(none) {\n+                        some(?_c) {\n+                            // log_err \"reusing existing reducer for \" + k;\n+                            c = _c;\n+                        }\n+                        none {\n+                            // log_err \"creating new reducer for \" + k;\n                             auto p = port();\n-                            spawn reduce_task(k, chan(p));\n+                            tasks += ~[spawn reduce_task(k, chan(p))];\n                             p |> c;\n                             reducers.insert(k, c);\n                         }\n                     }\n-                    cc <| c;\n+                    cc <| clone(c);\n                 }\n             }\n         }\n \n         for each(@tup(str, chan[reduce_proto]) kv in reducers.items()) {\n+            // log_err \"sending done to reducer for \" + kv._0;\n             kv._1 <| done;\n         }\n+\n+        // log_err #fmt(\"joining %u tasks\", ivec::len(tasks));\n+        for (task t in tasks) {\n+            task::join(t);\n+        }\n+        // log_err \"control task done.\";\n     }\n }\n \n@@ -174,7 +246,14 @@ fn main(vec[str] argv) {\n         fail;\n     }\n \n+    auto start = time::precise_time_ns();\n     map_reduce::map_reduce(vec::slice(argv, 1u, vec::len(argv)));\n+    auto stop = time::precise_time_ns();\n+\n+    auto elapsed = stop - start;\n+    elapsed /= 1000000u64;\n+\n+    log_err \"MapReduce completed in \" + u64::str(elapsed) + \"ms\";\n }\n \n fn read_word(io::reader r) -> option[str] {"}, {"sha": "244198f94011f99eaad2fbad98923baf199e507f", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878b128baddfa4ee38e4f9c43be75abe0edcd3d/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=8878b128baddfa4ee38e4f9c43be75abe0edcd3d", "patch": "@@ -41,7 +41,7 @@ mod map_reduce {\n \n     fn map_task(chan[ctrl_proto] ctrl,\n                 str input) {\n-        \n+\n         auto intermediates = map::new_str_hash();\n \n         fn emit(&map::hashmap[str, int] im,\n@@ -85,7 +85,7 @@ mod map_reduce {\n         while(num_mappers > 0) {\n             auto m;\n             ctrl |> m;\n-            \n+\n             alt(m) {\n                 case(mapper_done) { num_mappers -= 1; }\n                 case(find_reducer(?k, ?cc)) {"}]}